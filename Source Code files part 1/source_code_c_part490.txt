          ASSERT(*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>');
            break;
        }
        iArray++;
    }
    if (iArrayValue == -1 || iArray >= (int)ptep->m_cMaxToken) // didn't find tokValue after DESIGNTIMESPx
    {
        // BUG 9040
        //if (iArray >= (int)ptep->m_cMaxToken && iArrayValue != -1)
        //{
            // SOLUTION 1
            // overwrite the stuff from pwOld[pTokArray[iArraySav].token.ibTokMin]
            // to pwOld[pTokArray[iArrayValue].token.ibTokMac - 1]
            // SOLUTION 2
            // look for DESIGNTIMESP from pwOld[pTokArray[itokTagStart].token.ibTokMac - 1]
            // to pwOld[pTokArray[iArray].token.ibTokMac - 1] and overwrite all of those 
            // strings with spaces. We could NULL those and do the blts, but why bother
            // when the html isn't valid! 

            // make sure that all DESIGNTIMESPs are stripped off if we encountered this error case
        //}
        goto LRet;
    }

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    ichspInfoEndtagEnd = pTokArray[iArray].token.ibTokMac;

    // first copy the document till DESIGNTIMESPx
    // skip DESIGNTIMESPx and its value and set ichBeginCopy to be after that

    // NOTE - token before iArraySav'th one should be tokSpace with lenght 1 
    // and with a value of chSpace (unless Trident has modified it). If thats TRUE,
    // we should skip that too, because we added it when we put in DESIGNTIMESPx.
    
    // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
    // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
    // and Trident would have inserted EOL. If thats not the case, we will ignore it.
    if (   (iArraySav-1 > 0) /* validation */
        && (    (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 1)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    )
            ||  (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 3)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+1] == '\r')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+2] == '\n')
                    )
                )
        )
    {
        ichBegin = pTokArray[iArraySav-1].token.ibTokMin;
    }
    else
        ichBegin = pTokArray[iArraySav].token.ibTokMin;

#ifdef NEEDED
    ASSERT(ichBegin >= ichBeginCopy);

    cbNeed = (ichNewCur+(ichBegin-ichBeginCopy))*sizeof(WCHAR) + cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // BUG 15389 - look at the case of DESIGNTIMESP & convert the tag into upper/lower case...
    //memcpy(   (BYTE *)(pwNew+ichNewCur),
    //      (BYTE *)(pwOld+ichBeginCopy),
    //      (ichBegin-ichBeginCopy)*sizeof(WCHAR));
    //ichNewCur += (ichBegin-ichBeginCopy);
    if (ichBegin-ichBeginCopy >= 0)
    {
        // step 1 - copy from ichBeginCopy to '<' of the current tag
        if ((int)(pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+ichBeginCopy),
                    (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy);
            ichNewCurSav = ichNewCur+1; // used as a peg to get preceding tokTag_START i.e. '<'
        }
        // step 2 - convert current tag into upper/lower case & copy it
        if (ichBeginCopy < pTokArray[itoktagStart+1].token.ibTokMin)
        {
            ASSERT((int)(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin) > 0);
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMin),
                    (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)*sizeof(WCHAR));
            if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
            {
                // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                _wcsupr(&pwNew[ichNewCur]);
            }
            else
            {
                // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                _wcslwr(&pwNew[ichNewCur]);
            }
            ichNewCur += (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin);
        }
        else // this tag is alreay been copied
        {
            // hack
            if (pTokArray[itoktagStart+1].token.ibTokMac == ichBeginCopy) // means we are just past the current tag
            {
                if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                    _wcsupr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
                else
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                    _wcslwr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
            }
        }
        // step 3 - copy from after the tag (which is at ichtoktagStart+1) to ichBegin
        if ((int)(ichBegin-pTokArray[itoktagStart+1].token.ibTokMac) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMac),
                    (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac)*sizeof(WCHAR));
            ichNewCur += (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac);
        }
    }
    // set ichBeginCopy
    ichBeginCopy = ichspInfoEndtagEnd; // make it ready for next copy

    // copy the rest of the tag (skipping DESIGNTIMESPx = value)
    ASSERT((INT)(ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac) >= 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMac),
            (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac)*sizeof(WCHAR));
    ichNewCur += (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
#endif //NEEDED 

    memset((BYTE *)szIndex, 0, sizeof(szIndex));
    // check if the value has quotes around it and don't copy them to szIndex
    if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
        && pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
        )
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
    }
    else
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
    }
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
        goto LRet;

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            goto LRet;
        }
    }

    // get the Order Info
    pspInfoOrder = ptep->m_pspInfoOut;
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing before '<'
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing between '<>'
    // now pspInfoOrder is at correct place
    cwOrderInfo = *(WORD *)pspInfoOrder++;
    ASSERT(cwOrderInfo >= 1);
    // process this info
#ifdef NEEDED
    if (cwOrderInfo > 1) // means that we saved some info
    {
        INT cchNewCopy;

        cchNewCopy = (ichBegin-pTokArray[itoktagStart].token.ibTokMin) + (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
        ptep->FRestoreOrder(pwNew, pwOld, pspInfoOrder, &ichNewCur, cwOrderInfo, pTokArray, itoktagStart, iArray, iArraySav, iArrayValue, cchNewCopy, phgNew);
    }
#endif //NEEDED
    ichtoktagStart = ichNewCur; // init
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    for (index = 0; index < 4; index++)
    {
        BOOL fLookback = FALSE;

        cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
        cchRange = *(WORD *)ptep->m_pspInfoOut++;
        if (cchwspInfo == 2) // we didn't save any spacing info
        {
            if (index == 0) // special case BUG 8741
            {
                // Note that we didn't save anything before this tag. which means that
                // we had '>' or some text immediately before the < tag. 
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '<')
                    {
                        ichtoktagStart--;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart >= 0)
                {
                    int cws = 0;
                    int ichtagStart = ichtoktagStart;

                    // remove any such white space trident inserts.
                    while (    pwNew[ichtoktagStart] == ' '
                            || pwNew[ichtoktagStart] == '\r'
                            || pwNew[ichtoktagStart] == '\n'
                            || pwNew[ichtoktagStart] == '\t')
                    {
                        cws++;
                        ichtoktagStart--;
                    }
                    if (cws > 0)
                    {
                        ASSERT((int)(ichNewCur-ichtagStart-1) >= 0);
                        //ichtokTagStart now points to either '>' or a non-whitespace char
                        memmove((BYTE*)&pwNew[ichtoktagStart+1],
                                (BYTE*)&pwNew[ichtoktagStart+1+cws],
                                (ichNewCur-ichtagStart-1)*sizeof(WCHAR));
                        ichNewCur -= cws;
                    }
                } // if (ichtoktagStart >= 0)
            } // if (index == 0)
            goto LNext;
        }

        // note that ichtoktagStart is a position in pwNew
        switch (index)
        {
        case 0: // before < of the tag
            fLookback = TRUE;
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            ichNewCurAtIndex0 = ichNewCur; // lets save the ichNewCur before we restore pre-tag spacing
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart--;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2;
                continue;
            }
            break;
        case 1: // between <> of the tag
            fLookback = FALSE;
            // NOTE - we can assume that in 'case 0' we had put ichtoktagStart is just before '<'
            // so that we can avoid this while loop. but what if we skipped case '0'?

            // adjust ichNewCurSav to reflect the pre-tag spacing so that it doesn't become invalid
            // we may need to adjust it in ichNewCur-ichNewCurAtIndex0 < 0 case as well, but lets not
            // add code at this stage that we don't have to. (4/30/98)
            if (ichNewCurAtIndex0 != -1 && ichNewCurSav != -1 && ichNewCur-ichNewCurAtIndex0 > 0)
                ichNewCurSav = ichNewCurSav + (ichNewCur-ichNewCurAtIndex0);
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart++;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // for spacing info
                ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
                continue;
            }
            break;
        case 2: // after > of the tag
            // Observation - Trident messes up the document in following way - 
            //    If we had an EOL after '>' which is followed by HTML text, 
            //    trident eats that EOL
            // BUT
            //    If we had a space/tab before that EOL trident doesn't eat it!!!
            // so I have added the conditions
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')

            // here is the deal - If the next tone happens to be plain text, there is no danger
            // of applying the same format twice.( i.e. once for after '>' and the next time for
            // before the next '<')
            if (   (iArray+1 < (INT)ptep->m_cMaxToken) /*validation*/
                && pTokArray[iArray+1].token.tok == 0
                && pTokArray[iArray+1].token.tokClass == tokIDENTIFIER
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\r')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')
                )
            {
                fLookback = FALSE;
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '>')
                    {
                        ichtoktagStart++;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
                {
                    ptep->m_pspInfoOut += cchwspInfo-2;
                    continue;
                }
            }
            else
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
                continue;
            }
            break;
        case 3: // before matching end tag
            ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
            continue;
            //fLookback = TRUE;
            //ichtoktagStart = 0; // we ignore this info
            break;
        }

        if (index == 3) // skip this info, because we have not reached matching end tag yet
            ptep->m_pspInfoOut += cchwspInfo-2;
        //else if (index == 0)
        //  ptep->FRestoreSpacingInHTML(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);
        else
            ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);

LNext:
        if (index == 1) // we have already processed this info, just move the pointer ahead
            ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut;

    } // for ()

LRet:
    *ppwNew = pwNew; // in case this changed
    *pichNewCur = ichNewCur;

} /* RestoreSpacingSpecial() */

void
CTriEditParse::SaveSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew,
            TOKSTRUCT *pTokArray, INT iArray, UINT *pichNewCur)
{
    UINT ichNewCur = *pichNewCur;
    LPWSTR pwNew = *ppwNew;
    int iArrayPrevTag, iArrayMatch;
    UINT iArrayElem, iArrayTagStart;
    INT ichEndMatch, ichBeginMatch, ichEndPrev, ichBeginPrev, ichEndNext, ichBeginNext, ichEndTag, ichBeginTag, ichBegin, ichEnd;
    UINT cbNeed;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    LPCWSTR rgSpaceTags[] =
    {
        L" DESIGNTIMESP=",
        L" DESIGNTIMESP1=",
        L" designtimesp=",
    };

    iArrayElem = 0xFFFFFFFF; // init
    //
    // look for TokTag_START
    while (iArray >= 0)
    {
        if (   pTokArray[iArray].token.tokClass == tokTag 
            && pTokArray[iArray].token.tok == TokTag_START
            )
        {
            break;
        }
        iArray--;
    }
    if (iArray < 0) // error case
        goto LRet;
    iArrayTagStart = iArray;
    //

    // step 1
    // look for > that matches with <. we already are at ft.tokBegin2 i.e. <
    ASSERT(pTokArray[iArray].token.tok == TokTag_START);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ichBeginTag = pTokArray[iArray].token.ibTokMac;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   pTokArray[iArray].token.tok == TokTag_CLOSE 
            && pTokArray[iArray].token.tokClass == tokTag) // ft.tokEnd2 is -1
            break;
        if (pTokArray[iArray].token.tokClass == tokElem)
            iArrayElem = iArray;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find >
    {
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE); // found >
    ASSERT(pTokArray[iArray].token.tokClass == tokTag); // found >
    ichEndTag = ichBegin = pTokArray[iArray].token.ibTokMin;
    ichEnd = pTokArray[iArray].token.ibTokMac;

    // step 2
    // look for > before iArrayTagStart. Boundary case will be for the first < in the document
    // save the spacing info
    ASSERT(pTokArray[iArrayTagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[iArrayTagStart].token.tokClass == tokTag);
    ichEndPrev = pTokArray[iArrayTagStart].token.ibTokMin;
    ichBeginPrev = ichEndPrev-1;
    // look for previous TokTag_CLOSE
    // if the tag ending tag, ichBeginPrev becomes ibTokMac of '>' tag
    // if the tag is starting tag, ichBeginPrev becomes ibTokMac+(white space just after that tag)
    iArrayPrevTag = iArrayTagStart; // this is TokTag_START
    while (iArrayPrevTag >= 0)
    {
        if (       (   pTokArray[iArrayPrevTag].token.tokClass == tokTag 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_CLOSE
                    )
                || (   pTokArray[iArrayPrevTag].token.tokClass == tokSSS 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_SSSCLOSE
                    )/* VID6 - bug 22787 */
                )
        {
            break;
        }
        iArrayPrevTag--;
    }
    if (iArrayPrevTag < 0) // handle error case
    {
        // leave the old behaviour as is for V1
        while (ichBeginPrev >= 0)
        {
            if (   pwOld[ichBeginPrev] != ' '
                && pwOld[ichBeginPrev] != '\r'
                && pwOld[ichBeginPrev] != '\n'
                && pwOld[ichBeginPrev] != '\t'
                )
                break;
            ichBeginPrev--;
        }
        goto LGotEndNext;
    }
    ichBeginPrev = pTokArray[iArrayPrevTag].token.ibTokMac - 1;

LGotEndNext:
    if (ichBeginPrev < 0)
        ichBeginPrev = 0;
    else
        ichBeginPrev++;


    // step 3
    // look for TokTag_START after iArray(which currently is TokTag_CLOSE)
    // save spacing info
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    //iArrayNextStart = iArray;
    ichBeginNext = pTokArray[iArray].token.ibTokMac;
    ASSERT(ichBeginNext == ichEnd);
    ichEndNext = ichBeginNext;
    while (ichEndNext < (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
    {
        if (   pwOld[ichEndNext] != ' '
            && pwOld[ichEndNext] != '\r'
            && pwOld[ichEndNext] != '\n'
            && pwOld[ichEndNext] != '\t'
            )
            break;
        ichEndNext++;
    }

    if (ichEndNext >= (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
        ichEndNext = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac;

    // step 4
    // if iArrayElem != -1, look for pTokArray[iArrayElem].iNextprev. If its not -1, set iArrayMatch
    // look for previous TokTag_START/TokTag_END. look for previous TokTag_CLOSE
    // save spacing info
    if (iArrayElem == -1) // this can happen if we have incomplete HTML
    {
        ichEndMatch = ichBeginMatch = 0;
        goto LSkipMatchCalc;
    }
    iArrayMatch = pTokArray[iArrayElem].iNextprev;
    if (iArrayMatch != -1) // match was set while tokenizing
    {
        ichBeginMatch = ichEndMatch = 0; //init
        ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iArray].token.tokClass == tokTag);
        while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
        {
            if (   pTokArray[iArrayMatch].token.tokClass == tokTag
                && (   pTokArray[iArrayMatch].token.tok == TokTag_START
                    || pTokArray[iArrayMatch].token.tok == TokTag_END
                    )
                )
                break;
            iArrayMatch--;
        }
        if (iArrayMatch > iArray) // did find '</' or '<' after the current tag
        {
            ichEndMatch = pTokArray[iArrayMatch].token.ibTokMin;
            ichBeginMatch = ichEndMatch; // init
            // look for '>' and set ichBeginMatch
            while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
            {
                if (   (   pTokArray[iArrayMatch].token.tokClass == tokTag
                        && pTokArray[iArrayMatch].token.tok == TokTag_CLOSE
                        )
                    || (   pTokArray[iArrayMatch].token.tokClass == tokSSS
                        && pTokArray[iArrayMatch].token.tok == TokTag_SSSCLOSE
                        )/* VID6 - bug 22787 */
                    )
                    break;
                iArrayMatch--;
            }
            if (iArrayMatch >= iArray) // they may very well be the same
            {
                ichBeginMatch = pTokArray[iArrayMatch].token.ibTokMac;
                ASSERT(ichBeginMatch <= ichEndMatch);
                ASSERT(ichBeginMatch >= ichEnd);
            }
        }
    }
    else
    {
        // don't bother saving any info from here
        ichEndMatch = ichBeginMatch = 0;
    }
LSkipMatchCalc:
    if (ichEndPrev > ichBeginPrev)
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichBeginPrev);
    else
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichEndPrev);

    if (ichEndTag > ichBeginTag)
    {
        INT ichBeginTagSav = ichBeginTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichBeginTag);
        // iArray'th token is TokTag_CLOSE & iArrayTagStart is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArrayTagStart, iArray, ichEndTag, &ichBeginTagSav);
    }
    else
    {
        INT ichEndTagSav = ichEndTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichEndTag);
        // iArray'th token is TokTag_CLOSE & iArrayTagStart is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArrayTagStart, iArray, ichEndTagSav, &ichEndTagSav);
    }

    if (ichEndNext > ichBeginNext)
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichBeginNext);
    else
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichEndNext);

    if (ichEndMatch > ichBeginMatch)
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichBeginMatch);
    else
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichEndMatch);

    // realloc if needed
    cbNeed = (ichNewCur+3*wcslen(rgSpaceTags[0])+(ichEnd-ichBegin))*sizeof(WCHAR);
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    if (iswupper(pwOld[pTokArray[iArrayTagStart+1].token.ibTokMin]) != 0) // upper case
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[0]),
                (wcslen(rgSpaceTags[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[0]);
    }
    else
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[2]),
                (wcslen(rgSpaceTags[2]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[2]);
    }

    (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase, szIndex, 10);
    ptep->m_ispInfoBlock++;

    ASSERT(wcslen(szIndex) < sizeof(szIndex));
    ASSERT(sizeof(szIndex) == cchspBlockMax*sizeof(WCHAR));
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(szIndex),
            wcslen(szIndex)*sizeof(WCHAR));
    ichNewCur += wcslen(szIndex);



LRet:
    //*pcchNew = ichNewCur;
    *ppwNew = pwNew;
    *pichNewCur = ichNewCur;

    return;
} /* SaveSpacingSpecial() */


void
CTriEditParse::fnSaveAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    int cchURL = 0;
    int ichURL = 0;
    int index = iArray;
    LPCWSTR rgDspURL[] = 
    {
        L" DESIGNTIMEURL=",
    };

    ASSERT(    pTokArray[iArray].token.tok == TokElem_A
            || pTokArray[iArray].token.tok == TokElem_IMG
            || pTokArray[iArray].token.tok == TokElem_LINK);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    if (!FURLNeedSpecialHandling(pTokArray, iArray, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        iArray++;
    else // save the URL as an attribute value of DESIGNTIMEURL
    {
        // make sure we have enough space in pwNew.
        // copy from ichBeginCopy till current token's ending '>'.
        // index points to A/IMG/LINK
        while (index < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[index].token.tok == TokTag_CLOSE
                && pTokArray[index].token.tokClass == tokTag
                )
                break;
            index++;
        }
        if (index >= (int)ptep->m_cMaxToken) // invalid HTML, we didn't find '>'
        {
            iArray++;
            goto LRet;
        }
        cbNeed = (ichNewCur+pTokArray[index].token.ibTokMin-ichBeginCopy+wcslen(rgDspURL[0])+cchURL+3/*eq,quotes*/)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        {
            iArray++;
            goto LRet;
        }
        // index points to '>'
        if ((int) (pTokArray[index].token.ibTokMin-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[index].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[index].token.ibTokMin-ichBeginCopy);
        }

        if (cchURL != 0)
        {
            // add 'DESIGNTIMEURL=' followed by the current URL as quoted value
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)rgDspURL[0], 
                    wcslen(rgDspURL[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgDspURL[0]);

            pwNew[ichNewCur++] = '"';
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichURL], 
                    cchURL*sizeof(WCHAR));
            ichNewCur += cchURL;
            pwNew[ichNewCur++] = '"';
        }

        if (dwFlags & dwPreserveSourceCode)
            ptep->SaveSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, iArray-1, &ichNewCur);

        // add ending '>' and set ichBeginCopy, iArray, ichNewCur appropriately
        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[pTokArray[index].token.ibTokMin], 
                (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin);

        iArray = index+1;
        ichBeginCopy = pTokArray[index].token.ibTokMac;
    }

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
    return;

} /* fnSaveAImgLink() */

void
CTriEditParse::fnRestoreAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    LPCWSTR rgTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMEREF",
        L"DESIGNTIMEURL",
    };
    int indexStart, indexEnd, i, indexDSR, indexDSP, indexDSU;
    UINT cchsptag, cchhreftag, cchdsurltag;
    CComBSTR bstrRelativeURL;
    BOOL fHrefSrcFound = FALSE;
    UINT cbNeed;

    // we know that DESIGNTIMESP is not saved for these tags, but check it just to be sure.
    // if we find DESIGNTIMEREF, it means that the HREF was dragged on the page while in design view.
    ASSERT(    pTokArray[iArray].token.tok == TokElem_A
            || pTokArray[iArray].token.tok == TokElem_IMG
            || pTokArray[iArray].token.tok == TokElem_LINK);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    indexDSP = indexDSR = indexDSU = -1;
    //get the start tag
    indexStart = iArray;
    while (indexStart >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[indexStart].token.tok == TokTag_START)
            && (pTokArray[indexStart].token.tokClass == tokTag)
            )
        {
            break;
        }
        indexStart--;
    } // while ()
    if (indexStart < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    indexEnd = iArray;
    while (indexEnd < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[indexEnd].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[indexEnd].token.tokClass == tokTag)
            )
        {
            break;
        }
        indexEnd++;
    }
    if (indexEnd >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // look for DESIGNTIMEREF inside the tags
    cchsptag = wcslen(rgTags[0]);
    cchhreftag = wcslen(rgTags[1]);
    cchdsurltag = wcslen(rgTags[2]);
    for (i = iArray; i < indexEnd; i++)
    {
        if (       pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchsptag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchsptag))
                )
        {
            indexDSP = i;
            if (indexDSR != -1 && indexDSU != -1) // already initilized
                break;
        }
        else if (  pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchhreftag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[1], &pwOld[pTokArray[i].token.ibTokMin], cchhreftag))
                )
        {
            indexDSR = i;
            if (indexDSP != -1 && indexDSU != -1) // already initilized
                break;
        }
        else if (  pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchhreftag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[2], &pwOld[pTokArray[i].token.ibTokMin], cchdsurltag))
                )
        {
            indexDSU = i;
            if (indexDSP != -1 && indexDSR != -1) // already initilized
                break;
        }
    } // for ()

    // Here is the deal - If we found DESIGNTIMESP, it means that this A/Img/Link existed
    // while in source view. And in that case, we shouldn't find DESIGNTIMEREF. With the
    // same token, if we found DESINTIMEREF, it means that this A/Img/Link was dropped
    // while in design view, so DESIGNTIMESP shouldn't be there. They are mutually exclusive.
    
    // Also, DESIGNTIMEURL can exist only if the href was there while in source view
    // and its value was relative. This can coexist with DESIGNTIMESP, 
    // but not with DESIGNTIMEREF.
    if (indexDSP != -1 && indexDSU == -1) // we found DESIGNTIMESP, but not DESIGNTIMEURL
    {
        ASSERT(indexDSR == -1); // based on above statement, this better be true
        iArray = iArraySav + 1;
        goto LRet;
    }
    if (indexDSR == -1 && indexDSU == -1)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    if (indexDSR != -1)
    {
        ASSERT(indexDSU == -1); // this better be TRUE, because the 2 are mutually exclusive
        // at this point we know that we have DESIGNTIMEREF (that was put in as part 
        // of drag-drop operation while in design view)
        // modify the href and copy the tag.
        if ((int) (pTokArray[indexStart].token.ibTokMin-ichBeginCopy) > 0)
        {
            cbNeed = (ichNewCur+pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LRet;

            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[indexStart].token.ibTokMin-ichBeginCopy);
        }

        cbNeed = (ichNewCur+pTokArray[indexEnd].token.ibTokMac-pTokArray[indexStart].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        // trident mucks with the spacing of these tags and we didn't save any spacing info
        // soput endofline at the end of the tag.
        //pwNew[ichNewCur++] = '\r';
        //pwNew[ichNewCur++] = '\n';
        i = indexStart;

        while (i <= indexEnd)
        {
            if (i == indexDSR)
                i++; // don't copy this token
            else if (      (   pTokArray[i].token.tok == TokAttrib_HREF 
                            || pTokArray[i].token.tok == TokAttrib_SRC
                            )
                        && pTokArray[i].token.tokClass == tokAttr
                        && !fHrefSrcFound
                        )
            {
                fHrefSrcFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
            else if (      pTokArray[i].token.tok == 0 
                        && pTokArray[i].token.tokClass == tokString
                        && fHrefSrcFound
                        )
            {
                HRESULT hr;
                int cchURL;
                WCHAR *pszURL;
                BOOL fQuote = (pwOld[pTokArray[i].token.ibTokMin] == '"');

                cchURL = (fQuote)
                        ? pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin-2
                        : pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin;
                pszURL = new WCHAR [cchURL+1];

                fHrefSrcFound = FALSE;
                if (ptep->m_bstrBaseURL != NULL) // get the relative URL
                {
                    // get the URL string from pwOld and pass it in to relativise
                    memcpy( (BYTE *)pszURL,
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin + ((fQuote)? 1 : 0)],
                            (cchURL)*sizeof(WCHAR));
                    pszURL[cchURL] = '\0';
                    hr = UtilConvertToRelativeURL((LPOLESTR)pszURL, ptep->m_bstrBaseURL, NULL, &bstrRelativeURL);
                    if (SUCCEEDED(hr))
                    {
                        // can we assume that bstrRelativeURL is NULL terminated?
                        LPWSTR pszRelativeURL = bstrRelativeURL;
                        if (wcslen(pszRelativeURL) == 0)
                        {
                            memcpy( (BYTE *)&pwNew[ichNewCur],
                                    (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                    (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                            ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        }
                        else
                        {
                            pwNew[ichNewCur++] = '"';
                            memcpy( (BYTE *)&pwNew[ichNewCur],
                                    (BYTE *)pszRelativeURL,
                                    wcslen(pszRelativeURL)*sizeof(WCHAR));
                            ichNewCur += wcslen(pszRelativeURL);
                            pwNew[ichNewCur++] = '"';
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    }
                }
                else
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                delete pszURL;
                i++;
            }
            else // all other tokens
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
        // trident mucks with the spacing of these tags and we didn't save any spacing info
        // so put endofline at the end of the tag.
        //pwNew[ichNewCur++] = '\r';
        //pwNew[ichNewCur++] = '\n';
    }
    else // DESIGNTIMEURL case
    {
        int indexDSUEnd, indexDSPEnd;
        // we found DESIGNTIMEURL. It means, we had this URL while in source view and it was
        // a relative URL then.
        // Check if trident has made it absolute. If it has and the filename is same, 
        // we need to restore it. In all other cases, simply copy the URL and return.
        ASSERT(indexDSR == -1); // this better be TRUE, because the 2 are mutually exclusive
        if ((int) (pTokArray[indexStart].token.ibTokMin-ichBeginCopy) > 0)
        {
            cbNeed = (ichNewCur+pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LRet;

            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[indexStart].token.ibTokMin-ichBeginCopy);
        }

        cbNeed = (ichNewCur+pTokArray[indexEnd].token.ibTokMac-pTokArray[indexStart].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        // get indexDSUEnd
        i = indexDSU;
        indexDSUEnd = -1;
        while (i < indexEnd)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSUEnd = i;
                break;
            }
            i++;
        }
        if (indexDSUEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
        
        // get indexDSPEnd
        i = indexDSP;
        indexDSPEnd = -1;
        while (i < indexEnd)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSPEnd = i;
                break;
            }
            i++;
        }
        if (indexDSPEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }

        i = indexStart;
        while (i <= indexEnd)
        {
            if (   (i >= indexDSU && i <= indexDSUEnd)
                || (i >= indexDSP && i <= indexDSPEnd)
                )
                i++; // don't copy this token
            else if (      (   pTokArray[i].token.tok == TokAttrib_HREF 
                            || pTokArray[i].token.tok == TokAttrib_SRC
                            )
                        && pTokArray[i].token.tokClass == tokAttr
                        && !fHrefSrcFound
                        )
            {
                fHrefSrcFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
            else if (      pTokArray[i].token.tok == 0 
                        && pTokArray[i].token.tokClass == tokString
                        && fHrefSrcFound
                        )
            {
                int ichURL, ichURLEnd, ichDSURL, ichDSURLEnd;
                // if the url is now absloute and is just an absolute version of 
                // the one at indexDSUEnd, we need to replace it.
                ichURL = (pwOld[pTokArray[i].token.ibTokMin] == '"')
                        ? pTokArray[i].token.ibTokMin+1
                        : pTokArray[i].token.ibTokMin;
                ichURLEnd = (pwOld[pTokArray[i].token.ibTokMac-1] == '"')
                        ? pTokArray[i].token.ibTokMac-1
                        : pTokArray[i].token.ibTokMac;
                if (FIsAbsURL((LPOLESTR)&pwOld[ichURL]))
                {
                    WCHAR *pszURL1 = NULL;
                    WCHAR *pszURL2 = NULL;
                    int ich;

                    ichDSURL = (pwOld[pTokArray[indexDSUEnd].token.ibTokMin] == '"')
                            ? pTokArray[indexDSUEnd].token.ibTokMin+1
                            : pTokArray[indexDSUEnd].token.ibTokMin;
                    ichDSURLEnd = (pwOld[pTokArray[indexDSUEnd].token.ibTokMac-1] == '"')
                            ? pTokArray[indexDSUEnd].token.ibTokMac-1
                            : pTokArray[indexDSUEnd].token.ibTokMac;

                    // just for comparison purposes, don't look at '/' or '\' separators
                    // between filenames & directories...
                    pszURL1 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                    pszURL2 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                    if (pszURL1 == NULL || pszURL2 == NULL)
                        goto LResumeCopy;
                    memcpy((BYTE *)pszURL1, (BYTE *)&pwOld[ichDSURL], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    memcpy((BYTE *)pszURL2, (BYTE *)&pwOld[ichURLEnd-(ichDSURLEnd-ichDSURL)], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    pszURL1[ichDSURLEnd-ichDSURL] = '\0';
                    pszURL2[ichDSURLEnd-ichDSURL] = '\0';
                    for (ich = 0; ich < ichDSURLEnd-ichDSURL; ich++)
                    {
                        if (pszURL1[ich] == '/')
                            pszURL1[ich] = '\\';
                        if (pszURL2[ich] == '/')
                            pszURL2[ich] = '\\';
                    }

                    if (0 == _wcsnicmp(pszURL1, pszURL2, ichDSURLEnd-ichDSURL))
                    {
                        pwNew[ichNewCur++] = '"';
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[ichDSURL],
                                (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                        ichNewCur += (ichDSURLEnd-ichDSURL);
                        pwNew[ichNewCur++] = '"';
                    }
                    else // copy it as it is
                    {
LResumeCopy:
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    }
                    if (pszURL1 != NULL)
                        delete pszURL1;
                    if (pszURL2 != NULL)
                        delete pszURL2;
                }
                else // its realtive, simply copy it
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                i++;
            }
            else // all other tokens
            {
                // ****NOTE - we can actually do pretty printing here 
                // instead of fixing the special cases****

                // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
                // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
                // and Trident would have inserted EOL. If thats not the case, we will ignore it.
                if (   (pTokArray[i].token.tokClass == tokSpace)
                    && (pTokArray[i].token.tok == 0)
                    && (FIsWhiteSpaceToken(pwOld, pTokArray[i].token.ibTokMin, pTokArray[i].token.ibTokMac))
                    )
                {
                    if (i != indexDSU-1) // else skip the copy
                        pwNew[ichNewCur++] = ' '; // convert space+\r+\n into space
                    i++;
                }
                else
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    i++;
                }
            }
        } // while (i <= indexEnd)
    } // end of DESIGNTIMEURL case

    // we have spacing save dfor this tag, lets restore it
    if (   (indexDSP != -1)
        && (dwFlags & dwPreserveSourceCode)
        ) 
        ptep->RestoreSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, indexDSP, &ichNewCur);


    // remember to set iArray appropriately
    iArray = indexEnd + 1;
    ichBeginCopy = pTokArray[indexEnd].token.ibTokMac;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreAImgLink() */



void
CTriEditParse::fnSaveComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    UINT iCommentStart, iCommentEnd;
    LPCWSTR rgComment[] =
    {
        L"TRIEDITCOMMENT-",
        L"TRIEDITCOMMENTEND-",
        L"TRIEDITPRECOMMENT-",
    };
    int ichSp, cchComment;
    UINT cbNeed;

    // REMOVE METADATA from here, we don't need it because we are checking for end
    // of comment too.

    ASSERT(pTokArray[iArray].token.tok == TokTag_BANG);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    // early return cases
    // 1. see if this is a comment or not. It could be anything that starts with '<!'
    // e.g. <!DOCTYPE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken)
        && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+2] == '[')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+3] == 'i')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+3] == 'I')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+4] == 'f')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+4] == 'F')
        )
    {
        iCommentStart = iArray; // this is a comment we are interested in
    }
    else
    {
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }
    iCommentEnd = iArray + 2;
    ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
    if (   pTokArray[iCommentEnd].token.tok != TokTag_CLOSE 
        && pTokArray[iCommentEnd].token.tokClass != tokTag)
    {
        // we have found something that looks like a comment to begin with, but its
        // something else like a DTC, webbot stuff or some thing else...
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }

    // write the spacing info, reallocate pwNew if needed
    cchComment = pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin;
    cbNeed = (ichNewCur+2*cchComment+wcslen(rgComment[0])+wcslen(rgComment[1])+(pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy+2))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    // write till '<!--' part of the comment
    memcpy( (BYTE *)&pwNew[ichNewCur],
            (BYTE *)&pwOld[ichBeginCopy],
            (pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy;
    pwNew[ichNewCur++] = '-';
    pwNew[ichNewCur++] = '-';
    
    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[0], wcslen(rgComment[0])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[0]);
    //write spacing block
    ichSp = pTokArray[iCommentStart+1].token.ibTokMin+2; // exclude -- from <!--comment
    while (ichSp < (int)(pTokArray[iCommentStart+1].token.ibTokMac-2))// exclude -- from comment-->
    {
        switch (pwOld[ichSp++])
        {
        case ' ':
            pwNew[ichNewCur++] = chCommentSp;
            break;
        case '\t':
            pwNew[ichNewCur++] = chCommentTab;
            break;
        case '\r':
            pwNew[ichNewCur++] = chCommentEOL;
            break;
        case '\n':
            break;
        default:
            if (pwNew[ichNewCur-1] != ',')
                pwNew[ichNewCur++] = ',';
            break;
        } // switch()
    }

    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[1], wcslen(rgComment[1])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[1]);

    //write spacing block for pre comment
    // go back from pwOld[ichSp] and see where we have the last non-white space
    ichSp = pTokArray[iCommentStart].token.ibTokMin-1;
    while (    (ichSp >= 0)
            && (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\t'
                || pwOld[ichSp] == '\r' || pwOld[ichSp] == '\n'
                )
            )
    {
        ichSp--;
    }
    ichSp++; // compensate because ichSp points to non-white space character at this point
    ASSERT(pTokArray[iCommentStart].token.ibTokMin >= (UINT)ichSp);
    cbNeed = (ichNewCur+2*(pTokArray[iCommentStart].token.ibTokMin-ichSp)+wcslen(rgComment[2]))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    while (ichSp < (int)(pTokArray[iCommentStart].token.ibTokMin))
    {
        switch (pwOld[ichSp++])
        {
        case ' ':
            pwNew[ichNewCur++] = chCommentSp;
            break;
        case '\t':
            pwNew[ichNewCur++] = chCommentTab;
            break;
        case '\r':
            pwNew[ichNewCur++] = chCommentEOL;
            break;
        case '\n':
            break;
        default:
            if (pwNew[ichNewCur-1] != ',')
                pwNew[ichNewCur++] = ',';
            break;
        } // switch()
    }
    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[2], wcslen(rgComment[2])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[2]);
    
    // write the comment
    memcpy( (BYTE *)&pwNew[ichNewCur],
            (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin+2], 
            (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
    ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;

    // write the ending '>'
    pwNew[ichNewCur++] = '>'; // alternatively, we could write iCommentEnd'th token

    // set iArray & ichBeginCopy
    iArray = iCommentEnd+1;
    ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveComment() */

void
CTriEditParse::fnRestoreComment(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    ASSERT(FALSE); // this case is handled by fnRestoreObject(), so we shouldn't reach here
    return;

} /* fnRestoreComment() */

void
CTriEditParse::fnSaveTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{

    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    UINT cbNeed;
    UINT iTextAreaEnd;

    // look for TEXTAREA block and simply copy it into pwNew. Thereby avoiding the
    // space preservation & stuff.

    ASSERT(pTokArray[iArray].token.tok == TokElem_TEXTAREA);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iTextAreaEnd = pTokArray[iArray].iNextprev;
    if (iTextAreaEnd == -1) // we don't have matching </textarea>
    {
        // ignore this case
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE that we don't even need to get get the '<' before the textarea here because we are
    // not doing anything special with them. We simply are going to copy everything inside the
    // textarea to pwNew. So, we start copying from ichBeginCopy and copy till end of the 
    // textarea block.

    // get the '>' after the matching end textarea, generally this will be right after iTextAreaEnd
    while (iTextAreaEnd < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iTextAreaEnd].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iTextAreaEnd].token.tokClass == tokTag)
            )
        {
            break;
        }
        iTextAreaEnd++;
    }
    if (iTextAreaEnd >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // copy the textarea block into pwNew. Make sure that we have enough space in pwNew
    // NOTE - pTokArray[iTextAreaEnd].token.ibTokMac should be larger than ichBeginCopy,
    // but at this point in the game the assert is of no use, because no one is using 
    // debug builds (6/10/98)
    if ((int) (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy) > 0)
    {
        cbNeed = (ichNewCur+pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[ichBeginCopy], 
                (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy);
    }

    // set iArray & ichBeginCopy
    iArray = iTextAreaEnd+1;
    ichBeginCopy = pTokArray[iTextAreaEnd].token.ibTokMac;
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveTextArea() */

void
CTriEditParse::fnRestoreTextArea(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    UINT iArray = *piArrayStart;

    // ideally, (for next version) we should restore the trident-converted &gt's & stuff
    // for now, we are simply going to ignore this tag on the way back from trident
    // NOTE that we never put in designtimesp's in this block, so we souldn't have to look
    // for them here.

    ASSERT(pTokArray[iArray].token.tok == TokElem_TEXTAREA);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    iArray++; // skip this textarea tag

    *piArrayStart = iArray;
    return;

} /* fnRestoreTextArea() */

void
CTriEditParse::FilterHtml(LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew,
                          HGLOBAL *phgNew, TOKSTRUCT *pTokArray, 
                          FilterMode mode, DWORD dwFlags)
{
    UINT iArray = 0;
    UINT ichNewCur = 0;
    UINT ichBeginCopy = 0;
    HRESULT hr;
    INT index = 0;
    INT iItem;
    INT cItems = 0;
    INT cRuleMid = cRuleMax / 2; // ASSUME that cRuleMax is an even number

    FilterRule fr[cRuleMax] =
    {
    // make sure that modeInput and modeOutput have the matching entries.
    // modeInput entries
    {TokTag_BANG, TokAttrib_STARTSPAN, tokClsIgnore, TokTag_CLOSE, TokAttrib_ENDSPAN, tokClsIgnore, fnSaveDTC},
    {TokTag_SSSOPEN, -1, tokClsIgnore, TokTag_SSSCLOSE, -1, tokClsIgnore, fnSaveSSS},
    {TokTag_START, TokElem_HTML, tokClsIgnore, TokTag_CLOSE, TokElem_HTML, tokClsIgnore, fnSaveHtmlTag},
    {-1, -1, tokEntity, -1, -1, tokEntity, fnSaveNBSP},
    {-1, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnSaveHdr},
    {TokTag_END, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnSaveFtr},
    {-1, TokTag_START, tokTag, TokTag_CLOSE, -1, tokClsIgnore, fnSaveSpace},
    {TokTag_START, TokElem_OBJECT, tokElem, TokTag_CLOSE, TokElem_OBJECT, tokElem, fnSaveObject},
    {TokTag_START, TokElem_TBODY, tokElem, TokTag_CLOSE, -1, tokTag, fnSaveTbody},
    {-1, TokElem_APPLET, tokElem, -1, -1, -1, fnSaveApplet},
    {TokTag_START, TokElem_A, tokElem, TokTag_CLOSE, TokAttrib_HREF, tokTag, fnSaveAImgLink},
    {-1, TokTag_BANG, tokTag, -1, -1, tokClsIgnore, fnSaveComment},
    {TokTag_START, TokElem_TEXTAREA, tokElem, TokTag_CLOSE, TokElem_TEXTAREA, tokClsIgnore, fnSaveTextArea},

    // modeOutput entries
    {TokTag_START, TokElem_OBJECT, tokClsIgnore, TokTag_CLOSE, TokElem_OBJECT, tokClsIgnore, fnRestoreDTC},
    {TokTag_START, TokElem_SCRIPT, tokClsIgnore, TokTag_CLOSE, TokElem_SCRIPT, tokClsIgnore, fnRestoreSSS},
    {-1, -1, tokClsIgnore, -1, -1, tokClsIgnore, fnRestoreHtmlTag},
    {-1, -1, tokEntity, -1, -1, tokEntity, fnRestoreNBSP},
    {-1, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnRestoreHdr},
    {TokTag_END, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnRestoreFtr},
    {TokTag_START, TokTag_END, tokSpace, TokTag_CLOSE, -1, tokClsIgnore, fnRestoreSpace},
    {-1, TokTag_BANG, tokTag, TokTag_CLOSE, -1, tokTag, fnRestoreObject},
    {TokTag_START, TokElem_TBODY, tokElem, TokTag_CLOSE, -1, tokTag, fnRestoreTbody},
    {TokTag_START, TokElem_APPLET, tokElem, TokTag_CLOSE, -1, tokTag, fnRestoreApplet},
    {TokTag_START, TokElem_A, tokElem, TokTag_CLOSE, TokAttrib_HREF, tokTag, fnRestoreAImgLink},
    {-1, TokTag_BANG, tokTag, TokTag_CLOSE, -1, tokTag, fnRestoreObject},
    {TokTag_START, TokElem_TEXTAREA, tokElem, TokTag_CLOSE, TokElem_TEXTAREA, tokClsIgnore, fnRestoreTextArea},
    };
    
    memcpy(m_FilterRule, fr, sizeof(FilterRule)*cRuleMax);
    ASSERT(pwOld != NULL);
    ASSERT(*ppwNew != NULL);

    if (mode == modeInput)
    {
        cItems = m_cDTC + m_cSSSIn + m_cHtml + m_cNbsp + m_cHdr + m_cFtr + m_cObjIn + m_ispInfoIn + m_cAppletIn + m_cAImgLink;
        while (cItems > 0)
        {
            if (iArray >= m_cMaxToken) // this will catch error cases
                break;

            while (iArray < m_cMaxToken)
            {   
                // its OK to enumerate the comparison rules, but once we have
                // a lot of rules, this needs to be made into a function
                if (pTokArray[iArray].token.tok == m_FilterRule[0].ft.tokBegin2 && m_cDTC > 0)
                {
                    m_cDTC--;
                    iItem = 1;
                    index = 0;
                    break;
                }
                else if (     (m_FilterRule[1].ft.tokBegin2 != -1)
                            ? (pTokArray[iArray].token.tok == m_FilterRule[1].ft.tokBegin2 && m_cSSSIn > 0)
                            : (pTokArray[iArray].token.tok == m_FilterRule[1].ft.tokBegin && m_cSSSIn > 0)
                            )
                {
                    m_cSSSIn--;
                    iItem = 1;
                    index = 1;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[2].ft.tokBegin2 && m_cHtml > 0)
                {
                    m_cHtml--;
                    iItem = 1;
                    index = 2;
                    break;
                }
                else if (      m_FilterRule[3].ft.tokBegin == -1 
                            && m_FilterRule[3].ft.tokBegin2 == -1
                            && m_FilterRule[3].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cNbsp > 0)
                {
                    m_cNbsp--;
                    iItem = 1;
                    index = 3;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[4].ft.tokBegin2 && m_cHdr > 0)
                {
                    m_cHdr--;
                    iItem = 1;
                    index = 4;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[5].ft.tokBegin2
                            && pTokArray[iArray-1].token.tok == m_FilterRule[5].ft.tokBegin
                            && m_cFtr > 0
                            )
                {
                    m_cFtr--;
                    iItem = 1;
                    index = 5;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[6].ft.tokBegin2 
                            && m_FilterRule[6].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_ispInfoIn > 0
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 6;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[7].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[7].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == TokTag_START
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            && m_cObjIn > 0
                            )
                {
                    m_cObjIn--;
                    iItem = 1;
                    index = 7;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[8].ft.tokBegin2
                            && pTokArray[iArray].token.tokClass == m_FilterRule[8].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == TokTag_START
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    cItems++; //to compensate for cItems-- after the pfn() call
                    iItem = 1;
                    index = 8;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[9].ft.tokBegin2 
                            && m_FilterRule[9].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAppletIn > 0
                            )
                {
                    cItems++; //to compensate for cItems-- after the pfn() call
                    m_cAppletIn--;
                    index = 9;
                    break;
                }
                else if (      (   pTokArray[iArray].token.tok == m_FilterRule[10].ft.tokBegin2
                                || pTokArray[iArray].token.tok == TokElem_IMG
                                || pTokArray[iArray].token.tok == TokElem_LINK)
                            && m_FilterRule[10].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAImgLink > 0
                            && (pTokArray[iArray-1].token.tok == m_FilterRule[10].ft.tokBegin)
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 10;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[11].ft.tokBegin2 
                            && m_FilterRule[11].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 11;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[12].ft.tokBegin2 
                            && m_FilterRule[12].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && pTokArray[iArray-1].token.tok == m_FilterRule[12].ft.tokBegin
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 12;
                    break;
                }

                iArray++;
            }
            if (iArray < m_cMaxToken) // we found a match
            {
                // call that function
                m_FilterRule[index].pfn(    this, pwOld, ppwNew, pcchNew, phgNew, pTokArray, 
                                            &iArray, m_FilterRule[index].ft, &iItem, 
                                            &ichNewCur, &ichBeginCopy,
                                            dwFlags);
            }

            cItems--;
        } // while (cItems > 0)
    }
    else if (mode == modeOutput)
    {
        cItems = m_cObj + m_cSSSOut + m_cHtml + m_cNbsp + m_cHdr + m_cFtr + m_cComment + m_ispInfoOut + m_cAppletOut + m_cAImgLink;
        while (cItems > 0)
        {
            if (iArray >= m_cMaxToken) // this will catch error cases
                break;

            while (iArray < m_cMaxToken)
            {   
                // its OK to enumerate the comparison rules, but once we have
                // a lot of rules, this needs to be made into a function
                if (   pTokArray[iArray].token.tok == m_FilterRule[cRuleMid].ft.tokBegin2
                    && pTokArray[iArray-1].token.tok == TokTag_START
                    && m_cObj > 0
                        )
                {
                    m_cObj--;
                    index = cRuleMid;
                    iItem = m_iControl;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+1].ft.tokBegin2 && m_cSSSOut > 0)
                {
                    m_cSSSOut--;
                    iItem = 1;
                    index = cRuleMid+1;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+2].ft.tokBegin2 && m_cHtml > 0)
                {
                    m_cHtml--;
                    iItem = 1;
                    index = cRuleMid+2;
                    break;
                }
                else if (      m_FilterRule[cRuleMid+3].ft.tokBegin == -1 
                            && m_FilterRule[cRuleMid+3].ft.tokBegin2 == -1
                            && m_FilterRule[cRuleMid+3].ft.tokClsBegin == tokEntity
                            && m_cNbsp > 0)
                {
                    m_cNbsp--;
                    iItem = 1;
                    index = cRuleMid+3;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+4].ft.tokBegin2 && m_cHdr > 0)
                {
                    m_cHdr--;
                    iItem = 1;
                    index = cRuleMid+4;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+5].ft.tokBegin2 
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+5].ft.tokBegin
                            && m_cFtr > 0)
                {
                    m_cFtr--;
                    iItem = 1;
                    index = cRuleMid+5;
                    break;
                }
                else if (      (       pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+6].ft.tokClsBegin
                                    || (       pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+6].ft.tokBegin2
                                            && pTokArray[iArray].token.tokClass == tokTag
                                            )
                                    )
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    index = cRuleMid+6;
                    cItems++; // to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+7].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+7].ft.tokClsBegin
                            && m_cComment > 0
                            )
                {
                    m_cComment--;
                    iItem = 1;
                    index = cRuleMid+7;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+8].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+8].ft.tokClsBegin
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    // Note that TBody filtering is tied in with space preservation.
                    // In ideal world it shouldn't be, but thats acceptable to the most.
                    // If this view changes, we need to add some other designtime attribute 
                    // along with spacing attributes. This will be somewhat big change than 
                    // simply adding an attribute because then we need to change the code to 
                    // start going backwards in the token array in the main loop.
                    iItem = 1;
                    index = cRuleMid+8;
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+9].ft.tokBegin2
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+9].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+9].ft.tokBegin
                            && m_cAppletOut > 0
                            )
                {
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    m_cAppletOut--;
                    index = cRuleMid+9;
                    break;
                }
                else if (      (   pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+10].ft.tokBegin2
                                || pTokArray[iArray].token.tok == TokElem_IMG
                                || pTokArray[iArray].token.tok == TokElem_LINK)
                            && m_FilterRule[cRuleMid+10].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAImgLink > 0
                            && (pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+10].ft.tokBegin)
                            )
                {
                    index = cRuleMid+10;
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+11].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+11].ft.tokClsBegin
                            )
                {
                    // actually, we won't reach here - just a dummy
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    index = cRuleMid+11;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+12].ft.tokBegin2 
                            && m_FilterRule[cRuleMid+12].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+12].ft.tokBegin
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = cRuleMid+12;
                    break;
                }


                iArray++;
            }
            if (iArray < m_cMaxToken) // we found a match
            {
                // call that function
                m_FilterRule[index].pfn(    this, pwOld, ppwNew, pcchNew, phgNew, pTokArray, 
                                            &iArray, m_FilterRule[index].ft, &iItem, 
                                            &ichNewCur, &ichBeginCopy,
                                            dwFlags);
            }

            if (m_fDontDeccItem) // we can do things differently next time
            {
                m_fDontDeccItem = FALSE;
                cItems++;
            }
            cItems--;
        } // while (cItems > 0)
    }
    else
        ASSERT(FALSE);


    if (cItems == 0) // everything ok, copy rest of the doc
    {
LIncorrectcItems:
        // copy rest of the stuff into pwNew
        /* REALLOCATE pwNew IF NEEDED here use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        if (GlobalSize(*phgNew) < (ichNewCur+pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR))
        {
            hr = ReallocBuffer( phgNew,
                                (ichNewCur+pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR),
                                GMEM_MOVEABLE|GMEM_ZEROINIT);
            if (hr == E_OUTOFMEMORY)
                goto LCopyAndRet;
            ASSERT(*phgNew != NULL);
            *ppwNew = (WCHAR *)GlobalLock(*phgNew);
        }
        memcpy( (BYTE *)(*ppwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy);
        *pcchNew = ichNewCur;
    }
    else
    {
        // this means that we calculated one of m_c's incorrectly. We need to fix that
        // case in M4
        goto LIncorrectcItems;

LCopyAndRet:
        memcpy( (BYTE *)*ppwNew,
                (BYTE *)pwOld,
                (pTokArray[m_cMaxToken-1].token.ibTokMac)*sizeof(WCHAR));
        *pcchNew = pTokArray[m_cMaxToken-1].token.ibTokMac;
    }

} /* CTriEditParse::FilterHtml() */

int
CTriEditParse::ValidateTag(LPWSTR pszText)
{
    int len = 0;

    if (pszText == NULL)
        return(0);
    // check for the first non Alpha in the pszText and return it. Add '\0' at the end
    while (    (*(pszText+len) >= _T('A') && *(pszText+len) <= _T('Z'))
            || (*(pszText+len) >= _T('a') && *(pszText+len) <= _T('z'))
            || (*(pszText+len) >= _T('0') && *(pszText+len) <= _T('9'))
            )
    {
        len++;
    }

    return(len);
}

INT
CTriEditParse::GetTagID(LPWSTR pszText, TXTB token)
{
    WCHAR szTag[MAX_TOKIDLEN+1];
    int len;
    int tagID;

    len = ValidateTag(pszText+token.ibTokMin);
    if (len == 0 || len != (int)(token.ibTokMac-token.ibTokMin))
        tagID = -1;
    else
    {
		if (token.tok == 0 && token.tokClass == tokIDENTIFIER)
			tagID = -1;
		else
		{
			memcpy((BYTE *)szTag, (BYTE *)(pszText+token.ibTokMin), (min(len, MAX_TOKIDLEN))*sizeof(WCHAR));
			szTag[min(len, MAX_TOKIDLEN)] = '\0';
			tagID = IndexFromElementName((LPCTSTR) szTag);
		}
    }
    return(tagID);
}
void
CTriEditParse::PreProcessToken(TOKSTRUCT *pTokArray, INT *pitokCur, LPWSTR /*pszText*/, 
                               UINT /*cbCur*/, TXTB token, DWORD lxs, INT tagID, FilterMode mode)
{
    TOKSTRUCT *pTokT = pTokArray + *pitokCur;

    if (*pitokCur == -1) // the buffer reallocation must have failed
        goto LSkipArrayOp;

    // if (lxs & inTag) then we can ASSERT(token.tok == TokTag_START)
    //put the new token into pTokArray at *pitokCur position
    pTokT->token = token;
    pTokT->fStart = (lxs & inEndTag)?FALSE:TRUE;
    pTokT->ichStart = token.ibTokMin;
    pTokT->iNextprev = 0xFFFFFFFF; // init value
    pTokT->iNextPrevAlternate = 0xFFFFFFFF; // init value
    pTokT->tagID = tagID;

    if (mode == modeInput)
    {
        if (   pTokT->token.tok == TokTag_SSSOPEN
            && pTokT->token.tokClass == tokSSS
            && ((lxs & inSCRIPT) || (lxs & inAttribute))
            )
        {
            pTokT->token.tok = TokTag_SSSOPEN_TRIEDIT;
        }
        if (   pTokT->token.tok == TokTag_SSSCLOSE
            && pTokT->token.tokClass == tokSSS
            && ((lxs & inSCRIPT) || (lxs & inAttribute))
            )
        {
            pTokT->token.tok = TokTag_SSSCLOSE_TRIEDIT;
        }
    }

    *pitokCur += 1;

LSkipArrayOp:
    return;

} /* CTriEditParse::PreProcessToken() */


// Handle special cases of replacing things and saving the replaced contents
void
CTriEditParse::PostProcessToken(OLECHAR* /*pwOld*/, OLECHAR* /*pwNew*/, UINT* /*pcbNew*/, 
                                UINT /*cbCur*/, UINT /*cbCurSav*/, TXTB token, 
                                FilterMode mode, DWORD lxs, DWORD dwFlags)
{
    // handle special cases of replacing the DTCs, ServerSideScripts etc.
    // save the contents into a buffer if (mode == modeInput)
    // put the contents back into buffer if (mode == modeOutput)

    if (mode == modeInput)
    {
        if (   token.tok == TokAttrib_ENDSPAN
            && token.tokClass == tokAttr
            && (dwFlags & (dwFilterDTCs | dwFilterDTCsWithoutMetaTags))
            )
        {
            m_cDTC++;
        }
        if (   token.tok == TokTag_SSSCLOSE
            && token.tokClass == tokSSS
            && !(lxs & inAttribute) // !(lxs & inValue && lxs & inTag)
            && !(lxs & inSCRIPT)
            && (dwFlags & dwFilterServerSideScripts)
            )
        {
            m_cSSSIn++;
        }
        if (   token.tokClass == tokEntity
            && dwFlags != dwFilterNone
            )
        {
            m_cNbsp++;
        }
        if (   (token.tok == TokElem_OBJECT)
            && (token.tokClass == tokElem)
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cObjIn++;
        }
        if (   token.tok == TokElem_APPLET
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cAppletIn++;
        }
    }
    else if (mode == modeOutput)
    {
        if (   token.tok == TokElem_OBJECT
            && token.tokClass == tokElem
            && (lxs & inTag && !(lxs & inEndTag))
            && (dwFlags & (dwFilterDTCs | dwFilterDTCsWithoutMetaTags))
            )
        {
            m_cObj++;
        }
        if (   token.tok == TokElem_SCRIPT
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags & dwFilterServerSideScripts)
            )
        {
            m_cSSSOut++;
        }
        if (   token.tok == TokTag_BANG
            && token.tokClass == tokTag
            )
        {
            m_cComment++;
        }
        if (   token.tok == TokElem_APPLET
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cAppletOut++;
        }
    }

} /* CTriEditParse::PostProcessToken() */

HRESULT 
CTriEditParse::ProcessToken(DWORD &lxs, TXTB &tok, LPWSTR pszText, 
                            UINT /*cbCur*/, TOKSTACK *pTokStack, INT *pitokTop, 
                            TOKSTRUCT *pTokArray, INT iArrayPos, INT tagID)
{
    TXTB token = tok;

    if (*pitokTop == -1) // the buffer reallocation must have failed
        goto LSkipStackOp;

    if (lxs & inEndTag) // end tag begins, set m_fEndTagFound
        m_fEndTagFound = TRUE;

    if (tagID == -1) // we need to put only the IDENTIFIERS on the stack
    {
        // special cases (1)<%, (2)%>, (3)startspan, (4)endspan
        if (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS /*&& !(lxs & inAttribute)*/) // <%
        {
            token.tok = TokTag_SSSCLOSE; // fake it so that we can use the same code for matching %>
            goto LSpecialCase;
        }
        else if (token.tok == TokTag_SSSCLOSE && token.tokClass == tokSSS /*&& !(lxs & inAttribute)*/) // %>
        {
            m_fEndTagFound = TRUE; // lxs is not inEndTag when we get TokTag_SSSCLOSE
            goto LSpecialCase;
        }
        else if (token.tok == TokAttrib_STARTSPAN && token.tokClass == tokAttr) // startspan
        {
            token.tok = TokAttrib_ENDSPAN; // fake it so that we can use the same code for matching endspan
            goto LSpecialCase;
        }
        else if (token.tok == TokAttrib_ENDSPAN && token.tokClass == tokAttr) // endspan
        {
            LPCWSTR szDesignerControl[] =
            {
                L"\"DesignerControl\"",
                L"DesignerControl",
            };
            
            // HACK to fix FrontPage BUG - DaVinci puts a dummy endspan & startspan between
            // the "DESIGNERCONTROL" startspan-endspan pair. We want to make sure that
            // our pTokArray has correct matching iNextprev for the TokAttrib_STARTSPAN
            // Refer VID bug 3991
            if (       (iArrayPos-3 >= 0) /* validation */
                    && (   0 == _wcsnicmp(szDesignerControl[0], &pszText[pTokArray[iArrayPos-3].token.ibTokMin], wcslen(szDesignerControl[0]))
                        || 0 == _wcsnicmp(szDesignerControl[1], &pszText[pTokArray[iArrayPos-3].token.ibTokMin], wcslen(szDesignerControl[1]))
                        )
                    )
            {
                m_fEndTagFound = TRUE; // lxs is not inEndTag when we get TokAttrib_ENDSPAN
                goto LSpecialCase;
            }
            else
                goto LSkipStackOp;
        }
        else
        {
            if (m_fEndTagFound)
                m_fEndTagFound = FALSE;
            goto LSkipStackOp;
        }
    }

LSpecialCase:   
    if (m_fEndTagFound) // end tag was found previously, means pop from the stack
    {
        TOKSTACK *pTokT;

        if (*pitokTop == 0) // we don't have anything on stack, we can't delete it
            goto LSkipStackOp;

        pTokT = pTokStack + *pitokTop - 1;
        m_fEndTagFound = FALSE; // reset

        // if we get an end tag, in ideal case, the top of the stack should
        // match with what we got
        if (tagID == pTokT->tagID)
        {
            if (tagID == -1) // special case, match token.tok & token.tokClass
            {
                if (   (pTokT->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                    && (pTokT->token.tokClass == tokSSS)
                    )
                {
                    ASSERT(token.tok == TokTag_SSSCLOSE);
                    goto LMatch;
                }
                else if (   (pTokT->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                    && (pTokT->token.tokClass == tokAttr)
                    )
                {
                    ASSERT(token.tok == TokAttrib_ENDSPAN);
                    goto LMatch;
                }
                else // we may have found another special case
                {
                    goto LNoMatch;
                }
            }
LMatch:
            ASSERT(iArrayPos - 1 >= 0);
            // put iNextPrev or INextPrevAlternate for the matching start token in pTokArray
            pTokArray[pTokT->iMatch].iNextprev = iArrayPos - 1;
            ASSERT(pTokArray[pTokT->iMatch].fStart == TRUE);
            ASSERT(pTokT->ichStart == pTokArray[pTokT->iMatch].token.ibTokMin);
            pTokArray[iArrayPos-1].iNextprev = pTokT->iMatch;
            
            ASSERT(*pitokTop >= 0);
            *pitokTop -= 1; // pop the stack
        }
        else
        {
LNoMatch:
            int index;

            // look for the first entry down the array that matches
            index = *pitokTop - 1;
            while (index >= 0)
            {
                if (tagID == (pTokStack+index)->tagID)
                {
                    if (tagID == -1) // special case
                    {
                        if (       (   ((pTokStack+index)->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                                    && ((pTokStack+index)->token.tokClass == tokSSS)
                                    && (token.tok == TokTag_SSSCLOSE)
                                    && (token.tokClass == tokSSS)
                                    )
                                || (   ((pTokStack+index)->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                                    && ((pTokStack+index)->token.tokClass == tokAttr)
                                    && (token.tok == TokAttrib_ENDSPAN)
                                    && (token.tokClass == tokAttr)
                                    )
                                )
                            break;
                        //else actually, this means error case.
                    }
                    else
                        break;
                }
                index--;
            }

            if (index != -1) // match was found at index'th position on the stack
            {
                int i;
                TOKSTACK *pTokIndex = pTokStack + index;

                ASSERT(index >= 0);
                ASSERT(iArrayPos - 1 >= 0);
                
                if (tagID == -1) // special case, match token.tok & token.tokClass
                {
                    ASSERT(    (   (pTokIndex->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                                && (pTokIndex->token.tokClass == tokSSS)
                                && (token.tok == TokTag_SSSCLOSE)
                                && (token.tokClass == tokSSS)
                                )
                            || (   ((pTokStack+index)->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                                && ((pTokStack+index)->token.tokClass == tokAttr)
                                && (token.tok == TokAttrib_ENDSPAN)
                                && (token.tokClass == tokAttr)
                                )
                            );
                }
                // first of all fill in appropriate iNextprev
                pTokArray[pTokIndex->iMatch].iNextprev = iArrayPos - 1;
                ASSERT(pTokArray[pTokIndex->iMatch].fStart == TRUE);
                pTokArray[iArrayPos-1].iNextprev = pTokIndex->iMatch;

                // now fill in iNextPrevAlternate for all elements from index to *pitokTop - 1
                for (i = index+1; i <= *pitokTop - 1; i++)
                {
                    TOKSTACK *pTokSkip = pTokStack + i;

                    pTokArray[pTokSkip->iMatch].iNextPrevAlternate = iArrayPos - 1;
                    ASSERT(pTokArray[pTokSkip->iMatch].fStart == TRUE);
                    ASSERT(pTokArray[pTokSkip->iMatch].iNextprev == -1);
                } // for ()
                // decrement the stack appropriately
                *pitokTop = index;
            } // else

        } // of if (tagID == pTokT->tagID)
    } // end of if (lxs & inEndTag)
    else // push the token info on the stack
    {
        TOKSTACK *pTokT = pTokStack + *pitokTop;

        ASSERT(iArrayPos - 1 >= 0);
        //push the new token into pTokArray at *pitokCur position
        pTokT->iMatch = iArrayPos - 1;
        pTokT->tagID = tagID;
        pTokT->ichStart = token.ibTokMin;
        pTokT->token = token; // note that this isused ONLY in special cases where tagID is -1

        *pitokTop += 1;
    } //end of else case of if (lxs & inEndTag)

LSkipStackOp:

    return NOERROR;
}



// This function does following
//      (a) reads the stream 
//      (b) generates tokens
//      (c) allocates a buffer that holds replaced elements like DTCs
//      (d) does the parsing of the tokens to build a not-so-tree tree of tokens
//      (e) returns the not-so-tree tree of tokens
// VK 5/19/99: Replaced dwReserved with dwSpecialize.
// This can currently take PARSE_SPECIAL_HEAD_ONLY to terminate parsing at the <BODY>
HRESULT CTriEditParse::hrTokenizeAndParse(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew,
                        DWORD dwFlags, FilterMode mode, 
                        int cbSizeIn, UINT *pcbSizeOut, IUnknown *pUnkTrident, 
                        HGLOBAL *phgTokArray, UINT *pcMaxToken,
                        HGLOBAL *phgDocRestore, BSTR bstrBaseURL, DWORD dwSpecialize)
{
    // FilterRule structure initilization - move this at apporpriate place
    LPSTR pOld, pNew;
    UINT cbOld = 0;
    UINT cbwOld, cchwOld; // number of bytes & chars in the converted unicode string
    UINT cchNew = 0; // number of unicode chars in the new (after filtering) buffer
    HRESULT hrRet = S_OK;
    HGLOBAL hgNew, hgOld, hgTokStack;
    WCHAR *pwOld, *pwNew;
    UINT cbCur = 0; // This is actually the current character position
    TOKSTRUCT *pTokArray;
    TOKSTACK *pTokStack;
    INT itokTop = 0;
    INT itokCur = 0;
    TXTB token;
    INT cStackMax, cArrayMax;
    DWORD lxs = 0; 
    INT tagID;
    BOOL fAllocDocRestore = FALSE; // did we allocate *phgDocRestore locally? (Y/N)
    BOOL fUsePstmNew = (dwFlags & dwFilterUsePstmNew);
    HGLOBAL hgPstm = NULL;
    ULARGE_INTEGER li;
    UINT cbT = 0;
    BOOL fBeginTokSelect; // used by special case code that detects server side scripts inside a SELECT block
    BOOL fBeginTokTextarea; // used by special case code that detects server side scripts inside a TEXTAREA block
    BOOL fBeginTokLabel; // used by special case code that detects server side scripts inside a LABEL block
    BOOL fBeginTokListing; // used by special case code that detects server side scripts inside a LISTING block
    BOOL fInDTCOutput, fInDTC;

#ifdef DEBUG
    DWORD dwErr;
#endif // DEBUG

    ASSERT((PARSE_SPECIAL_NONE == dwSpecialize) || (PARSE_SPECIAL_HEAD_ONLY == dwSpecialize));

	if ( PARSE_SPECIAL_HEAD_ONLY & dwSpecialize )
		ASSERT ( dwFlags == dwFilterNone );

    // NOTE
    // this could be done another way. We can make m_pUnkTrident public member and set its value
    // at the point where the CTriEditParse object is created. But this looks fine too.
    m_pUnkTrident = pUnkTrident; // we cache this for our use.
    m_fUnicodeFile = FALSE;
    m_bstrBaseURL = bstrBaseURL;
    li.LowPart = li.HighPart = 0;
    // Initialize PTDTC related members
    if (mode == modeInput)
    {
        m_fInHdrIn = TRUE;
    }

    if (fUsePstmNew)
        li.LowPart = li.HighPart = 0;

    // initialize <TBODY> related members
    m_hgTBodyStack = NULL;
    m_pTBodyStack = NULL;
    m_iMaxTBody = m_iTBodyMax = 0;

    // initilize members used by PageTransitionDTC
    if (mode == modeInput)
    {
        m_ichPTDTC = m_cchPTDTCObj = m_cchPTDTC = 0;
        m_indexBeginBody = m_indexEndBody = 0;
        m_hgPTDTC = m_pPTDTC = NULL;
    }
    else
    {
        ASSERT(m_hgPTDTC == NULL); // make sure that it was freed (if we allocated it in modeInput case)
    }

    if (mode == modeInput)
    {
        m_fHasTitleIn = FALSE;
        m_indexTitleIn = -1;
        m_ichTitleIn = -1;
        m_cchTitleIn = -1;
        m_ichBeginBodyTagIn = -1;
        m_ichBeginHeadTagIn = -1;
        m_indexHttpEquivIn = -1;
    }
    //initilize fBeginTokSelect (used by special case code that 
    // detects server side scripts inside a SELECT block)
    fBeginTokSelect = fBeginTokTextarea = fBeginTokLabel = fBeginTokListing = FALSE;
    fInDTCOutput = fInDTC = FALSE;

    pOld = (LPSTR) GlobalLock(hOld);
    if (cbSizeIn == -1)
        cbOld = SAFE_INT64_TO_DWORD(GlobalSize(hOld));
    else
        cbOld = cbSizeIn;
    if (cbOld == 0) // zero sized file
    {
        if (pcbSizeOut)
            *pcbSizeOut = 0;
        hrRet = E_OUTOFMEMORY;
        *pcMaxToken = 0;
        if (fUsePstmNew)
            pStmNew->SetSize(li);
        else
            *phNew = NULL;
        *phgTokArray = NULL;
        goto LRetOnly;
    }
    hgNew = hgOld = hgTokStack = NULL;
    if (*((BYTE *)pOld) == 0xff && *((BYTE *)pOld+1) == 0xfe)
    {
        m_fUnicodeFile = TRUE;
        if (dwFlags & dwFilterMultiByteStream)
            dwFlags &= ~dwFilterMultiByteStream;
    }

    // allocate a buffer that will hold token structs. This is returned
    *phgTokArray = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_TOK*sizeof(TOKSTRUCT)); // stack
    if (*phgTokArray == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pTokArray = (TOKSTRUCT *) GlobalLock(*phgTokArray);
    ASSERT(pTokArray != NULL);
    cArrayMax = MIN_TOK;

    // allocate temporary buffers that for the current & filtered html documents
    hgTokStack = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_TOK*sizeof(TOKSTRUCT)); // stack
    if (hgTokStack == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pTokStack = (TOKSTACK *) GlobalLock(hgTokStack);
    ASSERT(pTokStack != NULL);
    cStackMax = MIN_TOK;

    // In most cases for NON-UNICODE streams, 
    // (cbOld+1/*for NULL*/)*sizeof(WCHAR)  will endup being lot more than what we need
    hgOld = GlobalAlloc(GMEM_ZEROINIT, (dwFlags & dwFilterMultiByteStream) 
                                        ? (cbOld+1/*for NULL*/)*sizeof(WCHAR) 
                                        : (cbOld+2/*for NULL*/));
    if (hgOld == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pwOld = (WCHAR *) GlobalLock(hgOld);
    ASSERT(pwOld != NULL);

    // we could just allocate cbOld bytes in modeInput and modeOutput. 
    // But reallocs are expensive and in both cases, we will grow by some bytes
    // if we have DTCs and/or SSSs.
    if (dwFlags & dwFilterNone) // the caller has called this function only for tokenizing
    {
        if (dwFlags & dwFilterMultiByteStream)
            cbT = (cbOld+1/*for NULL*/)*sizeof(WCHAR); // this will be bigger than what we need.
        else
            cbT = cbOld + sizeof(WCHAR); // for NULL
    }
    else
    {
        if (dwFlags & dwFilterMultiByteStream)
            cbT = (cbOld+1)*sizeof(WCHAR) + cbBufPadding;
        else
            cbT = cbOld + cbBufPadding; // no need to add +2
    }
    hgNew = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbT);
    if (hgNew == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pwNew = (WCHAR *) GlobalLock(hgNew);
    ASSERT(pwNew != NULL);

    // buffer to save all contents before/after <BODY> tag
    m_hgDocRestore = phgDocRestore ? *phgDocRestore : NULL;
    if (m_hgDocRestore == NULL)
    {
        fAllocDocRestore = TRUE;
        m_hgDocRestore = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader);
        if (m_hgDocRestore == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
    }
    // at this point we know that m_hgDocRestore is not going to be null, but lets be cautious
    // we call FilterIn only once when we load the document. (bug 15393)
    if (m_hgDocRestore != NULL && mode == modeInput)
    {
        WCHAR *pwDocRestore;
        DWORD cbDocRestore;

        // lock
        pwDocRestore = (WCHAR *) GlobalLock(m_hgDocRestore);
        // fill with zeros
        cbDocRestore = SAFE_INT64_TO_DWORD(GlobalSize(m_hgDocRestore));
        memset((BYTE *)pwDocRestore, 0, cbDocRestore);
        // unlock
        GlobalUnlock(m_hgDocRestore);
    }

    m_fEndTagFound = FALSE; // initialize

    m_cMaxToken = m_cDTC = m_cObj = m_cSSSIn = m_cSSSOut = m_cNbsp = m_iControl = m_cComment = m_cObjIn = 0;
    m_cAppletIn = m_cAppletOut = 0;
    m_fSpecialSSS = FALSE;
    m_cHtml = (mode == modeInput)? 0 : 0; // assume that we atleast have one <HTML> tag in modeInput case
    m_cHdr = m_cFtr = m_cAImgLink = 1;
    m_pspInfoCur = m_pspInfo = m_pspInfoOut = m_pspInfoOutStart = NULL;
    m_hgspInfo = NULL;
    m_ichStartSP = 0;
    if (dwFlags & dwPreserveSourceCode)
    {
        m_ispInfoIn = (mode == modeInput)? 1 : 0;
        m_ispInfoOut = (mode == modeOutput)? 1 : 0;
        if (mode == modeInput)
        {
            srand((unsigned)time(NULL));
            m_ispInfoBase = rand();
            if (0x0fffffff-m_ispInfoBase < 0x000fffff)
                m_ispInfoBase  = 0;
        }
    }
    else
    {
        m_ispInfoIn = 0;
        m_ispInfoOut = 0;
    }

    m_iArrayspLast = 0;
    m_ispInfoBlock = 0; // index of the block. stored as value of DESIGNTIMESPx tag
    m_cchspInfoTotal = 0;
    m_fDontDeccItem = FALSE; // we can do this differently next time

    // if we have multiple of these tags, we need to warn the user before going to design view
    // and not let the user switch views (bug 18474)
    m_cBodyTags = m_cHtmlTags = m_cTitleTags = m_cHeadTags = 0;

    if (dwFlags & dwFilterMultiByteStream)
    {
        // note that cbOld is actually number of characters in single byte world
        cchwOld = MultiByteToWideChar(CP_ACP, 0, pOld, (cbSizeIn==-1)?-1:cbOld, NULL, 0);
        MultiByteToWideChar(CP_ACP, 0, pOld, (cbSizeIn==-1)?-1:cbOld, pwOld, cchwOld);
    }
    else
    {
        memcpy((BYTE *)pwOld, (BYTE *)pOld, cbOld); // we are already UNICODE
        // Assume that in UNICODE world we can simply divide cbOld by sizeof(WCHAR)
        cchwOld = cbOld/sizeof(WCHAR);
    }
    *(pwOld+cchwOld) = '\0';

    // get the token & save it into a buffer
    cbwOld = cchwOld * sizeof(WCHAR);
    while (cbCur < cchwOld)
    {
        UINT cbCurSav = cbCur;

        NextToken(pwOld, cchwOld, &cbCur, &lxs, &token);
        tagID = GetTagID(pwOld, token); // only if inAttribute & inTag ????

        // if we have more of any of these tags, Trident removes them, so lets warn the user and
        // not the user go to design view (bug 18474)
        if (   (mode == modeInput)
            && (token.tokClass == tokElem)
            && (lxs & inTag)
            && !(lxs & inEndTag) /* this may be redundant, but having it does no harm */
            )
        {
            switch (token.tok)
            {
            case TokElem_BODY:
                m_cBodyTags++;
                break;
            case TokElem_HTML:
                m_cHtmlTags++;
                break;
            case TokElem_TITLE:
                m_cTitleTags++;
                break;
            case TokElem_HEAD:
                m_cHeadTags++;
                break;
            };
            if (m_cBodyTags > 1 || m_cHtmlTags > 1 || m_cTitleTags > 1 || m_cHeadTags > 1)
            {
                // skip tokenizing. we can't let this go to Trident
                memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
                cchNew = cchwOld;
                hrRet = E_FILTER_MULTIPLETAGS;
                goto LSkipTokFilter;
            }
        }

        if (   (token.tokClass == tokElem)
            && (   (token.tok == TokElem_FRAME)
                || (token.tok == TokElem_FRAMESET)
                )
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_FRAMESET;
            goto LSkipTokFilter;
        }
        if (   (token.tok == TokTag_SSSOPEN)
            && (token.tokClass == tokSSS)
            && (lxs & inAttribute)
            && !(lxs & inString)
            && !(lxs & inStringA)
            && !(fInDTCOutput)
            && (mode == modeInput)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SERVERSCRIPT;
            goto LSkipTokFilter;
        }
        if (   (token.tok == 0)
            && (token.tokClass == tokSSS)
            && (lxs & inTag)
            && (lxs & inHTXTag)
            && (lxs & inAttribute)
            && (lxs & inString || lxs & inStringA)
            && (lxs & inNestedQuoteinSSS)
            && !(fInDTCOutput)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SERVERSCRIPT;
            goto LSkipTokFilter;
        }

        // REVIEW TODO LATER - For all following special cases, we need to add !fInDTCOutput
        if (   (fBeginTokSelect)
            && (token.tok == TokTag_SSSOPEN || token.tok == TokElem_SCRIPT)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTSELECT;
            goto LSkipTokFilter;
        }

        if (   (fBeginTokTextarea)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTTEXTAREA;
            goto LSkipTokFilter;
        }
        if (   (fBeginTokLabel)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTLABEL;
            goto LSkipTokFilter;
        }
        if (   (fBeginTokListing)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTLISTING;
            goto LSkipTokFilter;
        }

        // Special cases Begin

        // special case - check if the document has <!DOCTYPE before going to Design view.
        // If it does, set m_fHasDocType flag. Trident always inserts this flag and we
        // want to remove it on the way out from Design view.
        if (   (token.tok == TokElem_TITLE)
            && (token.tokClass == tokElem)
            )
        {
            if (mode == modeInput)
            {
                m_fHasTitleIn = TRUE;
                if (m_indexTitleIn == -1)
                    m_indexTitleIn = itokCur;
            }
        }

        if (   (token.tok == TokElem_BODY)
            && (token.tokClass == tokElem)
            && (m_ichBeginBodyTagIn == -1)
            )
		{
			if ( PARSE_SPECIAL_HEAD_ONLY & dwSpecialize )
				break;
			if (mode == modeInput)
				m_ichBeginBodyTagIn = token.ibTokMin;
		}

        if (   (token.tok == TokAttrib_HTTPEQUIV || token.tok == TokAttrib_HTTP_EQUIV)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
        {
            if (m_indexHttpEquivIn == -1)
                m_indexHttpEquivIn = itokCur;
        }
        if (   (token.tok == TokElem_HEAD)
            && (token.tokClass == tokElem)
            && (m_ichBeginHeadTagIn == -1)
            && (mode == modeInput)
            )
        {
            m_ichBeginHeadTagIn = token.ibTokMin;
        }
        if (   (token.tok == TokElem_SELECT)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            && !(lxs & inSCRIPT)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokSelect = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokSelect = FALSE;
        }
        if (   (token.tok == TokElem_TEXTAREA)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokTextarea = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokTextarea = FALSE;
        }
        if (   (token.tok == TokElem_LABEL)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokLabel = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokLabel = FALSE;
        }
        if (   (token.tok == TokElem_LISTING)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokListing = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokListing = FALSE;
        }

        if (   (token.tok == TokAttrib_STARTSPAN)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
            fInDTC = TRUE;
        if (   (token.tok == TokElem_OBJECT)
            && (token.tokClass == tokElem)
            && (lxs & inEndTag)
            && (fInDTC)
            && (mode == modeInput)
            )
            fInDTCOutput = TRUE;
        if (   (token.tok == TokAttrib_ENDSPAN)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
        {
            fInDTCOutput = FALSE;
            fInDTC = FALSE;
        }
        // Special cases End


        if (itokCur == cArrayMax - 1) //allocate more memory for the array
        {
            HGLOBAL hgTokArray;
            GlobalUnlock(*phgTokArray);
            hgTokArray = *phgTokArray;
#pragma prefast(suppress:308, "noise")
            *phgTokArray = GlobalReAlloc(*phgTokArray, (cArrayMax+MIN_TOK)*sizeof(TOKSTRUCT), GMEM_MOVEABLE|GMEM_ZEROINIT);
            // if this alloc failed, we may still want to continue
            if (*phgTokArray == NULL)
            {
                GlobalFree(hgTokArray);
                hrRet = E_OUTOFMEMORY;
                *pcMaxToken = itokCur;
                if (fUsePstmNew)
                    pStmNew->SetSize(li);
                else
                    *phNew = NULL;
                goto LOOM;
            }
            else
            {
                pTokArray = (TOKSTRUCT *)GlobalLock(*phgTokArray); // do we need to unlock this first?
                ASSERT(pTokArray != NULL);
                cArrayMax += MIN_TOK;
            }
        }
        ASSERT(itokCur < cArrayMax);
        PreProcessToken(pTokArray, &itokCur, pwOld, cbCur, token, lxs, tagID, mode); //saves the token into the buffer


        if (itokTop == cStackMax - 1) //allocate more memory for the stack
        {
            HGLOBAL hg;
            GlobalUnlock(hgTokStack);
            hg = hgTokStack;
#pragma prefast(suppress: 308, "noise")
            hgTokStack = GlobalReAlloc(hgTokStack, (cStackMax+MIN_TOK)*sizeof(TOKSTACK), GMEM_MOVEABLE|GMEM_ZEROINIT);
            // if this alloc failed, we may still want to continue
            if (hgTokStack == NULL)
            {
                GlobalFree(hg);
                hrRet = E_OUTOFMEMORY;
                *pcMaxToken = itokCur;
                if (fUsePstmNew)
                    pStmNew->SetSize(li);
                else
                    *phNew = NULL;
                goto LOOM;
            }
            else
            {
                pTokStack = (TOKSTACK *)GlobalLock(hgTokStack); // do we need to unlock this first?
                ASSERT(pTokStack != NULL);
                cStackMax += MIN_TOK;
            }
        }
        ASSERT(itokTop < cStackMax);
        ProcessToken(lxs, token, pwOld, cbCur, pTokStack, &itokTop, pTokArray, itokCur, tagID); //push/pop stack, determine error states

        PostProcessToken(pwOld, pwNew, &cchNew, cbCur, cbCurSav, token, mode, lxs, dwFlags); // handle special cases of replacement 
    } // while (cbCur < cchwOld)
    *pcMaxToken = m_cMaxToken = itokCur;
    ASSERT(cchNew < GlobalSize(hgNew)); // or compare the cached value

    ASSERT(dwFlags != dwFilterDefaults);
    if (       dwFlags & dwFilterDTCs
            || dwFlags & dwFilterDTCsWithoutMetaTags
            || dwFlags & dwFilterServerSideScripts
            || dwFlags & dwPreserveSourceCode
            )
    {
        ASSERT(!(dwFlags & dwFilterNone));


        
        // check dwSpacing flag here
        if ((mode == modeOutput) && (dwFlags & dwPreserveSourceCode))
        {
            INT cchBeforeBody = 0;
            INT cchAfterBody = 0;
            INT cchPreEndBody = 0;

            ASSERT(m_pspInfoOut == NULL);
            ASSERT(m_hgDocRestore != NULL);
            m_pspInfoOut = (WORD *)GlobalLock(m_hgDocRestore);
            cchBeforeBody = (int)*m_pspInfoOut; // we are assuming that cchBeforeBody exists in this block
            m_pspInfoOut += cchBeforeBody + (sizeof(INT))/sizeof(WCHAR); // for cchBeforeBody
            cchAfterBody = (int)*m_pspInfoOut;
            m_pspInfoOut += cchAfterBody + (sizeof(INT))/sizeof(WCHAR); // for cchAfterBody
            cchPreEndBody = (int)*m_pspInfoOut;
            m_pspInfoOut += cchPreEndBody + (sizeof(INT))/sizeof(WCHAR); // for cchPreEndBody
            m_cchspInfoTotal = (int)*m_pspInfoOut;
            m_pspInfoOut += sizeof(INT)/sizeof(WCHAR);
            m_pspInfoOutStart = m_pspInfoOut;
        }

        
        ASSERT(pTokArray != NULL);
        FilterHtml( pwOld, &pwNew, &cchNew, &hgNew, pTokArray, 
                    mode, dwFlags);
        
        // check dwSpacing flag here
        if ((mode == modeOutput) && (dwFlags & dwPreserveSourceCode))
        {
            if (m_pspInfoOut != NULL)
            {
                ASSERT(m_hgDocRestore != NULL);
                GlobalUnlock(m_hgDocRestore);
            }
        }

    }

LSkipTokFilter:

    if (fUsePstmNew)
    {
        if (dwFlags & dwFilterMultiByteStream)
            li.LowPart = WideCharToMultiByte(CP_ACP, 0, pwNew, -1, NULL, 0, NULL, NULL) - 1; // to compensate for NULL character at end
        else
            li.LowPart = (cchNew)*sizeof(WCHAR);
        li.HighPart = 0;
        if (S_OK != pStmNew->SetSize(li))
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
        if (S_OK != GetHGlobalFromStream(pStmNew, &hgPstm))
        {
            hrRet = E_INVALIDARG;
            goto LOOM;
        }
        pNew = (LPSTR) GlobalLock(hgPstm);
    }
    else
    {
        // cchNew is # of unicode characters in pwNew
        // If we want to convert this UNICODE string into MultiByte string, 
        // we will need anywhere between cchNew bytes & cchNew*sizeof(WCHAR) bytes.
        // and we don't know it at this point, so lets leave the max size for allocation.
        *phNew = GlobalAlloc(GMEM_ZEROINIT, (cchNew+1)*sizeof(WCHAR));
        if (*phNew == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
        pNew = (LPSTR) GlobalLock(*phNew);
    }

    if (dwFlags & dwFilterMultiByteStream)
    {
        INT cbSize;

        cbSize = WideCharToMultiByte(CP_ACP, 0, pwNew, -1, NULL, 0, NULL, NULL) - 1; // to compensate for NULL character at end
        if (pcbSizeOut)
            *pcbSizeOut = cbSize;
        // we assume that number of characters will be the same in UNICODE or MBCS world
        // what changes is the number of bytes they need.
        WideCharToMultiByte(CP_ACP, 0, pwNew, -1, pNew, cbSize, NULL, NULL);
    }
    else
    {
        // NOTE - that we always set *pcbSizeOut to the number of BYTES in the new buffer
        if (pcbSizeOut)
            *pcbSizeOut = cchNew*sizeof(WCHAR);
        memcpy((BYTE *)pNew, (BYTE *)pwNew, cchNew*sizeof(WCHAR)); // we want to remain UNICODE
    }

#ifdef DEBUG
    dwErr = GetLastError();
#endif // DEBUG
    
    if (fUsePstmNew)
        GlobalUnlock(hgPstm);
    else
        GlobalUnlock(*phNew);

LOOM:
    // assume that the caller will free *phgTokArray
    if (*phgTokArray != NULL)
        GlobalUnlock(*phgTokArray); // do we need to check if this was already Unlocked?
    
    // assume that the caller will free *phgDocRestore if the caller allocated it
    if (fAllocDocRestore && m_hgDocRestore != NULL) // we allocated it here, so the caller doesn't need it
        GlobalUnlockFreeNull(&m_hgDocRestore);

    if (phgDocRestore)
        *phgDocRestore = m_hgDocRestore; // in case of a realloc, this may have changed.

    if (hgTokStack != NULL)
        GlobalUnlockFreeNull(&hgTokStack);
    if (hgNew != NULL)
        GlobalUnlockFreeNull(&hgNew);
    if (hgOld != NULL)
        GlobalUnlockFreeNull(&hgOld);
    if (m_hgTBodyStack != NULL)
        GlobalUnlockFreeNull(&m_hgTBodyStack);

    // check dwSpacing flag here
    if ((m_hgspInfo != NULL) && (dwFlags & dwPreserveSourceCode))
    {
        if (mode == modeInput && phgDocRestore)
        {
            WCHAR *pHdr, *pHdrSav;
            INT cchBeforeBody, cchAfterBody, cchPreEndBody;

            pHdr = (WCHAR *)GlobalLock(*phgDocRestore);
            ASSERT(pHdr != NULL);
            pHdrSav = pHdr;
            memcpy((BYTE *)&cchBeforeBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);

            memcpy((BYTE *)&cchAfterBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchAfterBody + sizeof(INT)/sizeof(WCHAR);

            memcpy((BYTE *)&cchPreEndBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchPreEndBody + sizeof(INT)/sizeof(WCHAR);


            if (GlobalSize(*phgDocRestore) < SAFE_PTR_DIFF_TO_INT(pHdr - pHdrSav)*sizeof(WCHAR) + SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD)+sizeof(int))
            {
                INT cdwSize = SAFE_PTR_DIFF_TO_INT(pHdr - pHdrSav);

                ASSERT(cdwSize >= 0); // validation
                hrRet = ReallocBuffer(  phgDocRestore,
                                        SAFE_INT64_TO_DWORD(pHdr - pHdrSav)*sizeof(WCHAR) + SAFE_INT64_TO_DWORD(m_pspInfoCur-m_pspInfo)*sizeof(WORD)+sizeof(int),
                                        GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hrRet == E_OUTOFMEMORY)
                    goto LRet;
                ASSERT(*phgDocRestore != NULL);
                pHdr = (WORD *)GlobalLock(*phgDocRestore);
                pHdr += cdwSize;
            }
            
            *(int*)pHdr = SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo);
            pHdr += sizeof(INT)/sizeof(WCHAR);

            memcpy( (BYTE *)pHdr,
                    (BYTE *)m_pspInfo,
                    SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD));
LRet:
            GlobalUnlock(*phgDocRestore);
        }
        GlobalUnlockFreeNull(&m_hgspInfo);
    }


    GlobalUnlock(hOld);
LRetOnly:
    return(hrRet);

}

void 
CTriEditParse::SetSPInfoState(WORD inState, WORD *pdwState, WORD *pdwStatePrev, BOOL *pfSave)
{
    *pfSave = TRUE;
    *pdwStatePrev = *pdwState;
    *pdwState = inState;
}

HRESULT
CTriEditParse::hrMarkOrdering(WCHAR *pwOld, TOKSTRUCT *pTokArray, INT iArrayStart, int iArrayEnd, 
                              UINT cbCur, INT *pichStartOR)
{

    HRESULT hr = S_OK;
    WORD *pspInfoSize;
    WORD cAttr = 0;

    ASSERT(m_pspInfo != NULL);
    if (m_pspInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LRetOnly;
    }

    pspInfoSize = m_pspInfoCur; // placeholder to save run size in BYTEs, size includes this DWORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save run size in BYTEs, size includes this WORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save number of Attr

    // handle the simplest case where we know that there is nothing to save
    if (cbCur == (UINT)*pichStartOR)
        goto LRet;
    // find out the number ot attributes insize this tag
    while (iArrayStart < iArrayEnd)
    {
        if (pTokArray[iArrayStart].token.tokClass == tokAttr)
        {
            INT ichStart, ichEnd;
            INT iArrayQuote = iArrayStart+1;
            INT iArrayEq = -1;

            cAttr++;
            ichStart = pTokArray[iArrayStart].token.ibTokMin;
            ichEnd = pTokArray[iArrayStart].token.ibTokMac;
            ASSERT(ichEnd > ichStart);
            
            while (iArrayQuote < iArrayEnd) // handle the case of white space before the quotes
            {
                if (pTokArray[iArrayQuote].token.tokClass == tokAttr) // gone too far, found next attr
                    break;
                if (   (   pTokArray[iArrayQuote].token.tokClass == tokValue
                        || pTokArray[iArrayQuote].token.tokClass == tokString
                        )
                    && (   pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '"'
                        || pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '\''
                        )
                    )
                    break;
                if (pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '=')
                    iArrayEq = iArrayQuote;
                iArrayQuote++;
            }

            if (   iArrayEq != -1
                && pTokArray[iArrayEq].token.tokClass == tokOp
                && pwOld[pTokArray[iArrayEq].token.ibTokMin] == '='
                && (   pTokArray[iArrayQuote].token.tokClass == tokValue
                    || pTokArray[iArrayQuote].token.tokClass == tokString
                    )
                && pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '"'
                )
            {
                *m_pspInfoCur++ = 1;
            }
            else if (   iArrayEq != -1
                && pTokArray[iArrayEq].token.tokClass == tokOp
                && pwOld[pTokArray[iArrayEq].token.ibTokMin] == '='
                && (   pTokArray[iArrayQuote].token.tokClass == tokValue
                    || pTokArray[iArrayQuote].token.tokClass == tokString
                    )
                && pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '\''
                )
            {
                *m_pspInfoCur++ = 2;
            }
            else
            {
                *m_pspInfoCur++ = 0;
            }
            *m_pspInfoCur++ = (WORD)(ichEnd-ichStart);
            memcpy((BYTE *)m_pspInfoCur, (BYTE *)&(pwOld[ichStart]), (ichEnd-ichStart)*sizeof(WCHAR));
            m_pspInfoCur += (ichEnd-ichStart);
        }
        iArrayStart++;
    }

LRet:
    *pspInfoSize++ = SAFE_PTR_DIFF_TO_WORD(m_pspInfoCur - pspInfoSize);
    *pspInfoSize = cAttr;

    *pichStartOR = cbCur; // set for next run
LRetOnly:
    return(hr);

} /* hrMarkOrdering() */

BOOL
CTriEditParse::FRestoreOrder(WCHAR *pwNew, WCHAR *pwOld, WORD *pspInfoOrder, UINT *pichNewCur, 
                             INT /*cwOrderInfo*/, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, 
                             INT iArrayDSPStart, INT iArrayDSPEnd, INT cchNewCopy, HGLOBAL *phgNew)
{
    // iArrayStart points to '<' & iArrayEnd points to '>'. (These refer to pwOld)
    // look at the attributes between iArrayStart & iArrayEnd and compare them with the attributes
    // saved in pspInfoOrder (which already points to the data saved, i.e. past cwOrderInfo)
    // If we find a matching attribute, move it to appropriate position.
    // DON'T touch extra attributes and IGNORE missing attributes because those represent user action

    HGLOBAL hgNewAttr = NULL;
    HGLOBAL hgTokList = NULL;
    BOOL *pTokList, *pTokListSav;
    WCHAR *pNewAttr, *pNewAttrSav;
    INT i, ichStart, ichEnd, iStart, iEnd, cAttr, cchTag, iStartSav, cchNew;
    BOOL fRet = TRUE;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    UINT cbNeed;
    
    ASSERT(pspInfoOrder != NULL);
    cAttr = *(WORD *)pspInfoOrder++;
    ASSERT(cAttr >= 0); // make sure that it was filled in
    if (cAttr == 0)/* || cAttr == 1)*/
        goto LRet;

    hgTokList = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (iArrayEnd-iArrayStart+1)*(sizeof(BOOL)));
    if (hgTokList == NULL) // don't reorder the attributes
    {
        fRet = FALSE;
        goto LRet;
    }
    pTokList = (BOOL *) GlobalLock(hgTokList);
    pTokListSav = pTokList;

    ichStart = pTokArray[iArrayStart].token.ibTokMin;
    ichEnd = pTokArray[iArrayEnd].token.ibTokMac;
    // cAttr*2 becase we may need to add quotes around each attr value
    hgNewAttr = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (ichEnd-ichStart+cAttr*2)*(sizeof(WCHAR)));
    if (hgNewAttr == NULL) // don't reorder the attributes
    {
        fRet = FALSE;
        goto LRet;
    }
    pNewAttr = (WCHAR *) GlobalLock(hgNewAttr);
    pNewAttrSav = pNewAttr;

    for (i = iArrayStart; i <= iArrayEnd; i++)
        *pTokList++ = FALSE;

    ASSERT(iArrayDSPEnd > iArrayDSPStart);
    for (i = iArrayDSPStart; i <= iArrayDSPEnd; i++)
    {
        ASSERT(*(pTokListSav+i-iArrayStart) == FALSE);
        *(pTokListSav+i-iArrayStart) = TRUE;
    }
    if (pwOld[pTokArray[iArrayDSPEnd+1].token.ibTokMin] == ' ')
    {
        ASSERT(*(pTokListSav+iArrayDSPEnd+1-iArrayStart) == FALSE);
        *(pTokListSav+iArrayDSPEnd+1-iArrayStart) = TRUE;
    }
    // copy contents from pwOld into pNewAttr till we find the first tokAttr/tokSpace
    iStart = iEnd = iArrayStart;
    cchTag = wcslen(rgSpaceTags[0]);
    while (iEnd < iArrayEnd)
    {
        if (   (pTokArray[iEnd].token.tokClass == tokAttr)
            /*|| (   (pTokArray[iEnd].token.tokClass == tokSpace)
                && (0 != _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iEnd].token.ibTokMin], cchTag))
                )*/
            )
        {
            break;
        }
        iEnd++;
    }
    if (iEnd >= iArrayEnd) // error
    {
        fRet = FALSE;
        goto LRet;
    }

    for (i = iStart; i < iEnd; i++)
    {
        if (*(pTokListSav+i-iArrayStart) != TRUE) // if not already copied
        {
            if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                    && pwOld[pTokArray[i].token.ibTokMin] == ' '
                    && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                    && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                    )
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (1)*sizeof(WCHAR));
                pNewAttr++;
            }
            else
            {
                if (pTokArray[i].token.tokClass == tokElem)
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    // BUG 15389 - restore proper case here
                    if (iswupper(pwOld[pTokArray[iArrayDSPStart].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                    {
                        _wcsupr(pNewAttr);
                    }
                    else
                    {
                        _wcslwr(pNewAttr);
                    }
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                else
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
            }
            *(pTokListSav+i-iArrayStart) = TRUE;
        }
    }

    iStartSav = iStart = iEnd;
    while (cAttr > 0)
    {
        INT cchAttr;
        BOOL fAddSpace;
        WORD isQuote;

        isQuote = *(WORD *)pspInfoOrder++;
        cchAttr = *(WORD *)pspInfoOrder++;
        ASSERT(cchAttr > 0); // make sure that it was filled in
        
        while (iStart <= iArrayEnd) //for (i = iStart; i <= iArrayEnd; i++)
        {
            if (   (pTokArray[iStart].token.tokClass == tokAttr)
                && (pTokArray[iStart].token.ibTokMac-pTokArray[iStart].token.ibTokMin == (UINT)cchAttr)
                && (0 == _wcsnicmp(pspInfoOrder, &pwOld[pTokArray[iStart].token.ibTokMin], cchAttr))
                )
            {
                break; // found the match, so copy from ith token to the next tokAttr
            }
            iStart++;
        } // while ()
        if (iStart >= iArrayEnd) // we know that iArrayEnd is actually '>'
            goto LNoMatch;

        // now from iStart go forward till we get the next tokAttr or '>'
        iEnd = iStart+1;
        fAddSpace = FALSE;
        while (iEnd < iArrayEnd)
        {
            if (       (pTokArray[iEnd].token.tokClass == tokAttr)
                    || (       (pTokArray[iEnd].token.tokClass == tokSpace)
                            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iEnd].token.ibTokMin], cchTag))
                            )
                    )
                break; // found the next attribute
            iEnd++;
        }
        if (iEnd == iArrayEnd)
            fAddSpace = TRUE;
        iEnd--; // iEnd will be pointing to '>' or the next Attribute, so decrement it

        for (i = iStart; i <= iEnd; i++)
        {
            if (*(pTokListSav+i-iArrayStart) != TRUE) // we didn't copy this token
            {
                if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                        && pwOld[pTokArray[i].token.ibTokMin] == ' '
                        && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                        && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                        )
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (1)*sizeof(WCHAR));
                    pNewAttr++;
                }
                else
                {
                    if (pTokArray[i].token.tokClass == tokAttr)
                    {
                        ASSERT(i == iStart);
                        ASSERT((INT)(pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) == cchAttr);
                        ASSERT(0 == _wcsnicmp(pspInfoOrder, &pwOld[pTokArray[i].token.ibTokMin], cchAttr));
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)pspInfoOrder,
                                (cchAttr)*sizeof(WCHAR));
                    }
                    else if (      (isQuote == 1)
                                && (   pTokArray[i].token.tokClass == tokValue
                                    || pTokArray[i].token.tokClass == tokString
                                    )
								&& (pwOld[pTokArray[i-1].token.ibTokMin] != '@') /*hack alert - VID BUG 23597*/
                                )
                    {
                        isQuote = 0; // the quote restoring has been taken care of for this attribute's value
                        if (pwOld[pTokArray[i].token.ibTokMin] != '"')
                            *pNewAttr++ = '"';
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        if (pwOld[pTokArray[i].token.ibTokMin] != '"')
                        {
                            *(pNewAttr+pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) = '"';
                            pNewAttr++;
                        }
                    }
                    else if (      (isQuote == 2)
                                && (   pTokArray[i].token.tokClass == tokValue
                                    || pTokArray[i].token.tokClass == tokString
                                    )
								&& (pwOld[pTokArray[i-1].token.ibTokMin] != '@') /*hack alert - VID BUG 23597*/
                                )
                    {
                        isQuote = 0; // the quote restoring has been taken care of for this attribute's value
                        // if we already have double quote, don't insert another single quote.
                        // ideally, we want to replace the double quote, but lets not do it now, because
                        // we believe that trident would have inserted double quotes to make it valid html!
                        if (pwOld[pTokArray[i].token.ibTokMin] != '\'' && pwOld[pTokArray[i].token.ibTokMin] != '"')
                            *pNewAttr++ = '\'';
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        if (pwOld[pTokArray[i].token.ibTokMin] != '\'' && pwOld[pTokArray[i].token.ibTokMin] != '"')
                        {
                            *(pNewAttr+pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) = '\'';
                            pNewAttr++;
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    }
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                *(pTokListSav+i-iArrayStart) = TRUE;
            }
        }
        if (fAddSpace)
            *pNewAttr++ = ' ';

LNoMatch:
        iStart = iStartSav;
        pspInfoOrder += cchAttr;
        cAttr--;
    } // while (cAttr > 0)

    // do we want to insert an extra space into pNewAttr here?

    // all the saved attributes are accounted for, lets copy remaining stuff
    for (i = iStartSav; i <= iArrayEnd; i++)
    {
        if (*(pTokListSav+i-iArrayStart) != TRUE) // we didn't copy this token
        {
            if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                    && pwOld[pTokArray[i].token.ibTokMin] == ' '
                    && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                    && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                    )
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (1)*sizeof(WCHAR));
                pNewAttr++;
            }
            else
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
            }
            *(pTokListSav+i-iArrayStart) = TRUE;
        }
    } // for ()
    cchNew = SAFE_PTR_DIFF_TO_INT(pNewAttr - pNewAttrSav);

    cbNeed = *pichNewCur+cchNew-cchNewCopy;
    ASSERT(cbNeed*sizeof(WCHAR) <= GlobalSize(*phgNew));
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        fRet = FALSE;
        goto LRet;
    }

    memcpy( (BYTE *)(pwNew+*pichNewCur-cchNewCopy),
            (BYTE *)(pNewAttrSav),
            cchNew*sizeof(WCHAR));
    *pichNewCur += (cchNew-cchNewCopy);

    // NOTE - Find a better way to account for the extra space added when we moved
    // the attributes. We can't avoid adding space because when we move the last attribute, 
    // there may not be a space between that and the '>'. 
    if (       /*(cchNew > cchNewCopy)
            &&*/ (pwNew[*pichNewCur-1] == '>' && pwNew[*pichNewCur-2] == ' ')
            )
    {
        pwNew[*pichNewCur-2] = pwNew[*pichNewCur-1];
        pwNew[*pichNewCur-1] = '\0';
        *pichNewCur -= 1;
    }

LRet:
    if (hgNewAttr != NULL)
        GlobalUnlockFreeNull(&hgNewAttr);
    if (hgTokList != NULL)
        GlobalUnlockFreeNull(&hgTokList);

    return(fRet);

} /* FRestoreOrder() */

HRESULT
CTriEditParse::hrMarkSpacing(WCHAR *pwOld, UINT cbCur, INT *pichStartSP)
{

    HRESULT hrRet = S_OK;
    UINT i;
    WORD cSpace, cEOL, cTab, cChar, cTagOpen, cTagClose, cTagEq;
    WORD dwState = initState;
    WORD dwStatePrev = initState;
    BOOL fSave = FALSE;
    WORD *pspInfoSize;
    
    if (m_pspInfo == NULL) // allocate it
    {
        m_hgspInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader*sizeof(WORD));
        if (m_hgspInfo == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LRet;
        }
        m_pspInfo = (WORD *) GlobalLock(m_hgspInfo);
        ASSERT(m_pspInfo != NULL);
        m_pspInfoCur = m_pspInfo;
        //ASSERT(m_ispInfoIn == 0);
    }
    else // reallocate if needed
    {
        // assumption here is that we can't have more runs than the number of characters we have to scan
        // we use *2 to reduce future reallocations
        if (GlobalSize(m_hgspInfo) < SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD) + (cbCur-*pichStartSP)*2*sizeof(WORD) + cbBufPadding)
        {
            int cdwSize = SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo); // size in DWORDs

            hrRet = ReallocBuffer(  &m_hgspInfo,
                                    SAFE_INT64_TO_DWORD(m_pspInfoCur-m_pspInfo)*sizeof(WORD) + (cbCur-*pichStartSP)*2*sizeof(WORD) + cbBufPadding,
                                    GMEM_MOVEABLE|GMEM_ZEROINIT);
            if (hrRet == E_OUTOFMEMORY)
                goto LRet;
            ASSERT(m_hgspInfo != NULL);
            m_pspInfo = (WORD *)GlobalLock(m_hgspInfo);
            m_pspInfoCur = m_pspInfo + cdwSize;
        }
    }

    //m_ispInfoIn++;
    pspInfoSize = m_pspInfoCur; // placeholder to save run size in BYTEs, size includes this DWORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save run size in BYTEs, size includes this WORD
    *m_pspInfoCur++ = SAFE_INT_DIFF_TO_WORD(cbCur-*pichStartSP);
    cSpace = cEOL = cTab = cChar = cTagOpen = cTagClose = cTagEq = 0;
    
    //scan from ichStartSP till cbCur for space, tab, eol
    // NOTE - Optimization note
    // part of this info is already in pTokArray. We should use it
    // to reduce the time in this function
    for (i = *pichStartSP; i < cbCur; i++)
    {
        switch (pwOld[i])
        {
        case ' ':
            if (dwState != inSpace)
            {
                SetSPInfoState(inSpace, &dwState, &dwStatePrev, &fSave);
                ASSERT(cSpace == 0);
            }
            cSpace++;
            break;
        case '\r':
        case '\n':
            if (dwState != inEOL)
            {
                SetSPInfoState(inEOL, &dwState, &dwStatePrev, &fSave);
                ASSERT(cEOL == 0);
            }
            if (pwOld[i] == '\n')
                cEOL++;
            break;
        case '\t':
            if (dwState != inTab)
            {
                SetSPInfoState(inTab, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTab == 0);
            }
            cTab++;
            break;
        case '<':
            if (dwState != inTagOpen)
            {
                SetSPInfoState(inTagOpen, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagOpen == 0);
            }
            cTagOpen++;
            break;
        case '>':
            if (dwState != inTagClose)
            {
                SetSPInfoState(inTagClose, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagClose == 0);
            }
            cTagClose++;
            break;
        case '=':
            if (dwState != inTagEq)
            {
                SetSPInfoState(inTagEq, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagEq == 0);
            }
            cTagEq++;
            break;
        default:
            if (dwState != inChar)
            {
                SetSPInfoState(inChar, &dwState, &dwStatePrev, &fSave);
                ASSERT(cChar == 0);
            }
            cChar++;
            break;
        } /* switch */

        if (fSave) // save previous run
        {
            if (dwStatePrev != initState)
            {
                switch (dwStatePrev)
                {
                case inSpace:
                    *m_pspInfoCur++ = inSpace;
                    *m_pspInfoCur++ = cSpace;
                    cSpace = 0;
                    break;
                case inEOL:
                    *m_pspInfoCur++ = inEOL;
                    *m_pspInfoCur++ = cEOL;
                    cEOL = 0;
                    break;
                case inTab:
                    *m_pspInfoCur++ = inTab;
                    *m_pspInfoCur++ = cTab;
                    cTab = 0;
                    break;
                case inTagOpen:
                    *m_pspInfoCur++ = inTagOpen;
                    *m_pspInfoCur++ = cTagOpen;
                    cTagOpen = 0;
                    break;
                case inTagClose:
                    *m_pspInfoCur++ = inTagClose;
                    *m_pspInfoCur++ = cTagClose;
                    cTagClose = 0;
                    break;
                case inTagEq:
                    *m_pspInfoCur++ = inTagEq;
                    *m_pspInfoCur++ = cTagEq;
                    cTagEq = 0;
                    break;
                case inChar:
                    *m_pspInfoCur++ = inChar;
                    *m_pspInfoCur++ = cChar;
                    cChar = 0;
                    break;
                }
            }
            fSave = FALSE;

        } // if (fSave)

    } // for ()
    
    *pichStartSP = cbCur; // set for next run

    //if (pwOld[i] == '\0') // end of file and we wouldn't have saved the last run
    //{
        if (cSpace > 0)
            dwStatePrev = inSpace;
        else if (cEOL > 0)
            dwStatePrev = inEOL;
        else if (cTab > 0)
            dwStatePrev = inTab;
        else if (cTagOpen > 0)
            dwStatePrev = inTagOpen;
        else if (cTagClose > 0)
            dwStatePrev = inTagClose;
        else if (cTagEq > 0)
            dwStatePrev = inTagEq;
        else if (cChar > 0)
            dwStatePrev = inChar;
        else
            dwStatePrev = initState; // handle error case

        switch (dwStatePrev) // repeat of above, make this into a function
        {
        case inSpace:
            *m_pspInfoCur++ = inSpace;
            *m_pspInfoCur++ = cSpace;
            cSpace = 0;
            break;
        case inEOL:
            *m_pspInfoCur++ = inEOL;
            *m_pspInfoCur++ = cEOL;
            cEOL = 0;
            break;
        case inTab:
            *m_pspInfoCur++ = inTab;
            *m_pspInfoCur++ = cTab;
            cTab = 0;
            break;
        case inTagOpen:
            *m_pspInfoCur++ = inTagOpen;
            *m_pspInfoCur++ = cTagOpen;
            cTagOpen = 0;
            break;
        case inTagClose:
            *m_pspInfoCur++ = inTagClose;
            *m_pspInfoCur++ = cTagClose;
            cTagClose = 0;
            break;
        case inTagEq:
            *m_pspInfoCur++ = inTagEq;
            *m_pspInfoCur++ = cTagEq;
            cTagEq = 0;
            break;
        case inChar:
            *m_pspInfoCur++ = inChar;
            *m_pspInfoCur++ = cChar;
            cChar = 0;
            break;
        } // switch()
    //} // if ()

    *pspInfoSize = SAFE_PTR_DIFF_TO_WORD(m_pspInfoCur - pspInfoSize);

LRet:
    return(hrRet);

} /* hrMarkSpacing() */


BOOL
CTriEditParse::FRestoreSpacing(LPWSTR pwNew, LPWSTR /*pwOld*/, UINT *pichNewCur, INT *pcchwspInfo,
                               INT cchRange, INT ichtoktagStart, BOOL fLookback, INT index)
{
    BOOL fRet = TRUE;
    INT ichNewCur = (INT)*pichNewCur;
    INT cchwspInfo = *pcchwspInfo;
    WORD *pspInfoCur;
    INT cchwspInfoSav, cspInfopair, cchIncDec;
    BOOL fInValue = FALSE;

    cchwspInfo -= 2; // skip the cch & cchRange
    cchwspInfoSav = cchwspInfo;
    if (fLookback)
        pspInfoCur = m_pspInfoOut + cchwspInfo-1; // cch is actual number of char, so its 1 based
    else
        pspInfoCur = m_pspInfoOut;
    cspInfopair = cchwspInfo / 2; // we assume that cchwspInfo will be even number
    ASSERT(cchwspInfo % 2 == 0);
    cchIncDec = (fLookback)? -1 : 1;

    while (cspInfopair > 0)//(pspInfoCur >= m_pspInfoOut)
    {
        WORD dwState, count;

        cspInfopair--; // ready to get next cch & its type
        if (fLookback)
        {
            count = *(WORD *)pspInfoCur--;
            dwState = *(WORD *)pspInfoCur--;
        }
        else
        {
            dwState = *(WORD *)pspInfoCur++;
            count = *(WORD *)pspInfoCur++;
        }
        cchwspInfo -= 2; // previous pair of cch and its type

        switch (dwState)
        {
        case inChar:
            ASSERT(index == 1 || index == 0 || index == 3);
            if (index == 0 || index == 3)
            {
                int countws = 0; // count of white space chars

                while (    pwNew[ichtoktagStart-countws] == ' '
                        || pwNew[ichtoktagStart-countws] == '\t'
                        || pwNew[ichtoktagStart-countws] == '\r'
                        || pwNew[ichtoktagStart-countws] == '\n'
                        )
                {
                    // skip these white space chars. They shouldn't be here
                    countws++;
                    if (ichtoktagStart-countws <= 0)
                        break;
                }
                if (countws > 0)
                {
                    if (ichtoktagStart-countws >= 0)
                    {
                        memcpy((BYTE*)&pwNew[ichtoktagStart-countws+1], (BYTE *)&pwNew[ichtoktagStart+1], (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur -= countws;
                        ichtoktagStart -= countws;
                    }
                }
            } // if (index == 0 || index == 3)

            while (    pwNew[ichtoktagStart] != ' '
                    && pwNew[ichtoktagStart] != '\t'
                    && pwNew[ichtoktagStart] != '\n'
                    && pwNew[ichtoktagStart] != '\r'
                    && pwNew[ichtoktagStart] != '<'
                    && pwNew[ichtoktagStart] != '>'
                    && pwNew[ichtoktagStart] != '='
                    && (ichNewCur > ichtoktagStart)
                    && count > 0
                    )
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we match the exact chars, we may have more contiguous chars in pwNew
            {
                while (    pwNew[ichtoktagStart] != ' '
                        && pwNew[ichtoktagStart] != '\t'
                        && pwNew[ichtoktagStart] != '\n'
                        && pwNew[ichtoktagStart] != '\r'
                        && pwNew[ichtoktagStart] != '<'
                        && pwNew[ichtoktagStart] != '>'
                        && (pwNew[ichtoktagStart] != '=' || (fInValue /*&& index == 1*/))
                        && (ichNewCur > ichtoktagStart)
                        )
                {
                    ichtoktagStart += cchIncDec;
                    cchRange--;
                    if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                    {
                        fRet = FALSE;
                        goto LRet;
                    }
                }
            }
            break;
        case inTagOpen:
        case inTagClose:
        case inTagEq:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            if (pwNew[ichtoktagStart] == '=' /* && index == 1*/)
                fInValue = TRUE;
            else
                fInValue = FALSE;
            while (    (pwNew[ichtoktagStart] == '<' || pwNew[ichtoktagStart] == '>' || pwNew[ichtoktagStart] == '=')
                    && count > 0
                    )
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            break;

        case inSpace:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            fInValue = FALSE;
            while (pwNew[ichtoktagStart] == ' ' && count > 0)
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we matched exact spaces, we may have more spaces in pwNew
            {
                if (fLookback)
                {
                    INT countT = 0;
                    //INT ichtoktagStartSav = ichtoktagStart;

                    if (cspInfopair == 0)
                        break;

                    ASSERT(index == 0 || index == 3);
                    // REMOVE EXTRA SPACES here.
                    while (pwNew[ichtoktagStart-countT] == ' ')
                        countT++;
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-(ichtoktagStart))*sizeof(WCHAR));
                            ichNewCur -= (countT-1);
                            ichtoktagStart -= (countT-1);
                            while (countT > 1)
                            {
                                pwNew[ichNewCur+countT-2] = '\0';
                                countT--;
                            }
                        }
                    }
                }
                else if (!fLookback)
                {
                    INT countT = -1;

                    ASSERT(index == 1 || index == 2);
                    // look ahead into pspInfoCur to see what the next parameters should be
                    if ((index == 1) && (*(WORD *)pspInfoCur == inChar))
                    {
                        while (    pwNew[ichtoktagStart] == ' '
                                || pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                || pwNew[ichtoktagStart] == '\t'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    else
                    {
                        while (pwNew[ichtoktagStart] == ' ')
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart+1) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT-1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                            ichNewCur -= (countT+1);
                            ichtoktagStart -= (countT+1);
                            while (countT >= 0)
                            {
                                pwNew[ichNewCur+countT] = '\0';
                                countT--;
                            }
                        }
                    }
                }
            }
            else
            {
                if (fLookback)
                {
                    ASSERT(index == 0 || index == 3);
                    if ((int)(ichNewCur-ichtoktagStart-1) >= 0)
                    {
                        // insert spaces after ichtoktagStart
                        memmove((BYTE *)&pwNew[ichtoktagStart+1+count],
                                (BYTE *)&pwNew[ichtoktagStart+1],
                                (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur += count;
                        //ichtoktagStart++;
                        while (count > 0)
                        {
                            pwNew[ichtoktagStart+count] = ' ';
                            count--;
                        }
                        //ichtoktagStart--; // compensate
                    }
                }
                else 
                {
                    ASSERT(index == 1 || index == 2);
                    if ((int)(ichNewCur-ichtoktagStart) >= 0)
                    {
                        int countT = count;

                        // insert spaces at ichtoktagStart and set ichtoktagStart after last space
                        memmove((BYTE *)&pwNew[ichtoktagStart+count],
                                (BYTE *)&pwNew[ichtoktagStart],
                                (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                        ichNewCur += count;
                        while (count > 0)
                        {
                            ASSERT((INT)(ichtoktagStart+count-1) >= 0);
                            pwNew[ichtoktagStart+count-1] = ' ';
                            count--;
                        }
                        ichtoktagStart += countT;
                    }
                }
            }
            break;
        case inEOL:
            // make sure that we have atleast count number of EOLs at 
            // pwNew[ichtoktagStart-count]
            // if fLookback, then we get '\n', else we get '\r'
            fInValue = FALSE;
            while ((pwNew[ichtoktagStart] == '\n' || pwNew[ichtoktagStart] == '\r') && count > 0)
            {
                count--;
                cchRange -= 2;
                ichtoktagStart += cchIncDec; // assume '\r' or '\n'
                ichtoktagStart += cchIncDec; // assume '\r' or '\n'
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }

            }
            if (count == 0) // we matched exact EOLs, we may have more EOLs in pwNew
            {
                if (fLookback)
                {
                    INT countT = 0;

                    ASSERT(index == 0 || index == 3);
                    // REMOVE EXTRA EOLs here.
                    while (    pwNew[ichtoktagStart-countT] == '\r'
                            || pwNew[ichtoktagStart-countT] == '\n'
                            )
                        countT++;
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-(ichtoktagStart))*sizeof(WCHAR));
                            ichNewCur -= (countT-1);
                            ichtoktagStart -= (countT-1);
                            while (countT > 1)
                            {
                                pwNew[ichNewCur+countT-2] = '\0';
                                countT--;
                            }
                        }
                    }
                }
                else if (!fLookback)
                {
                    INT countT = 0;

                    ASSERT(index == 1 || index == 2);
                    // REMOVE EXTRA EOLS here.

                    // look ahead into pspInfoCur to see what the next parameters should be
                    if ((index == 1) && (*(WORD *)pspInfoCur == inChar))
                    {
                        while (    pwNew[ichtoktagStart] == ' '
                                || pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                || pwNew[ichtoktagStart] == '\t'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    else
                    {
                        while (    pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    
                    //ASSERT(countT % 2 == 0); // assert that countT is an even number, because we should find \r & \n always in pair
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart+1) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                            ichNewCur -= (countT);
                            ichtoktagStart -= (countT);
                            while (countT >= 0)
                            {
                                pwNew[ichNewCur+countT] = '\0';
                                countT--;
                            }
                        }
                    }
                }
            }
            else
            {
                if (fLookback)
                {
                    INT i;

                    ASSERT(index == 0 || index == 3);
                    if ((int)(ichNewCur-ichtoktagStart-1) >= 0)
                    {
                        // insert EOLs after ichtoktagStart
                        memmove((BYTE *)&pwNew[ichtoktagStart+1+count*2],
                                (BYTE *)&pwNew[ichtoktagStart+1],
                                (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur += count*2;
                        count *= 2;
                        ichtoktagStart++;
                        for (i = 0; i < count; i+=2)
                        {
                            pwNew[ichtoktagStart+i] = '\r';
                            pwNew[ichtoktagStart+i+1] = '\n';
                        }
                        ichtoktagStart--; // compensate for prior increment
                    }
                }
                else 
                {
                    INT i;

                    ASSERT(index == 1 || index == 2);
                    // insert spaces at ichtoktagStart and set ichtoktagStart after last space
                    if ((int)(ichNewCur-ichtoktagStart) >= 0)
                    {
                        memmove((BYTE *)&pwNew[ichtoktagStart+count*2],
                                (BYTE *)&pwNew[ichtoktagStart],
                                (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                        ichNewCur += count*2;
                        count *= 2;
                        for (i=0; i < count; i+=2)
                        {
                            pwNew[ichtoktagStart+i] = '\r';
                            pwNew[ichtoktagStart+i+1] = '\n';
                        }
                        ichtoktagStart += count;
                    }
                }
            }

            break;
        case inTab:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            fInValue = FALSE;
            while (pwNew[ichtoktagStart] == '\t' && count > 0)
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we matched exact spaces, we may have more tabs in pwNew
            {
                // skip extra spaces in pwNew, if we had more spaces in pwNew than count
                while (pwNew[ichtoktagStart] == '\t')
                {
                    ichtoktagStart += cchIncDec;
                    cchRange--;
                    if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                    {
                        fRet = FALSE;
                        goto LRet;
                    }
                }

            }
            else
            {
                INT ichSav = ichtoktagStart;
                INT i;

                ASSERT(count > 0);
                // insert these many extra tabs at pwNew[ichtoktagStart] and increment ichNewCur
                if (fLookback)
                    ichtoktagStart++;
                if (ichNewCur-ichtoktagStart > 0)
                {
                    memmove((BYTE *)(pwNew+ichtoktagStart+count), 
                            (BYTE *)(pwNew+ichtoktagStart),
                            (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                }
                for (i = 0; i < count; i++)
                    pwNew[ichtoktagStart+i] = '\t';

                ichNewCur += count;
                if (fLookback)
                    ichtoktagStart = ichSav;
                else
                    ichtoktagStart += count;
            }
            break;
        } // switch (dwState)

    } // while ()
    if (   cspInfopair == 0
        && pwNew[ichNewCur-1] == '>'
        && ichNewCur > ichtoktagStart
        && !fLookback
        && index == 1)
    {
        INT countT = 0;

        ASSERT(cchIncDec == 1);
        // This means that we may have extra spaces & EOLs from ichtoktagStart to '>'
        // REMOVE EXTRA SPACES EOLS here.
        while (    pwNew[ichtoktagStart+countT] == ' '
                || pwNew[ichtoktagStart+countT] == '\r'
                || pwNew[ichtoktagStart+countT] == '\n'
                || pwNew[ichtoktagStart+countT] == '\t'
                )
        {
            countT++;
        }
        if (countT > 0 && pwNew[ichtoktagStart+countT] == '>')
        {
            if (ichNewCur-(ichtoktagStart+1) > 0)
            {
                memmove((BYTE *)(pwNew+ichtoktagStart),
                        (BYTE *)(pwNew+ichtoktagStart+countT),
                        (ichNewCur-(ichtoktagStart+countT))*sizeof(WCHAR));
                ichNewCur -= (countT);
                ichtoktagStart -= (countT);
                while (countT > 0)
                {
                    pwNew[ichNewCur+countT-1] = '\0';
                    countT--;
                }
            }
        }

        // Next time around - we can do the following...
        // look back from ichtoktagStart and check if we have any spaces/eols.
        // if we do, there is a likelihood that these shouldn't have been there.
        // Here is how they get there - If we had spaces between the parameter and
        // the '=' and its value, those spacves are removed by Trident. We then go
        // in and add those spaces at the end rather than at proper place because 
        // we don't break up the text. e.g. "width = 23" --> "width=23". 
        // Now, because we don't break that text, we end up inserting these spaces
        // at the end. Lets remove them.
    }
    else if (      cspInfopair == 0
                && fLookback
                && (index == 0 || index == 3)) /* VID6 - bug 18207 */
    {
        INT countT = 0;

        ASSERT(cchIncDec == -1);
        // This means that we may have extra spaces & EOLs before ichtoktagStart to '>'
        // REMOVE EXTRA SPACES EOLS here.
        while (    pwNew[ichtoktagStart-countT] == ' '
                || pwNew[ichtoktagStart-countT] == '\r'
                || pwNew[ichtoktagStart-countT] == '\n'
                || pwNew[ichtoktagStart-countT] == '\t'
                )
        {
            countT++;
        }
        if (countT > 0 && pwNew[ichtoktagStart-countT] == '>')
        {
            if (ichNewCur-(ichtoktagStart+1) > 0)
            {
                memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                        (BYTE *)(pwNew+ichtoktagStart+1),
                        (ichNewCur-(ichtoktagStart+1))*sizeof(WCHAR));
                ichNewCur -= countT;
                ichtoktagStart -= (countT); // this doesn't matter because we will exit after this
                while (countT > 0)
                {
                    pwNew[ichNewCur+countT-1] = '\0';
                    countT--;
                }
            }
        }
    }
LRet:
    m_pspInfoOut = m_pspInfoOut + cchwspInfoSav;
    *pcchwspInfo = cchwspInfo;
    *pichNewCur = ichNewCur;
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\idroptgt.cpp ===
//------------------------------------------------------------------------------
// idroptgt.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      7-15-97     created     (bash)
//
// Implementation of IDropTarget
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <ocidl.h>
#include <string.h>

#include "triedit.h"
#include "document.h"
#include "privcid.h"
#include "dispatch.h"
#include "trace.h"
#include "undo.h"

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragEnter (IDropTarget method)
//
// In design mode, accept drags that originate within Trident. Allow unlocked
// 2D positioned elements to be dragged using a dashed outline as a drag 
// rectangle. If TriEdit's constrained dragging mode has been enabled using
// the Constrain method then the drag will be constrained to points which are
// even multiples of the values in m_ptConstrain. 
//

STDMETHODIMP CTriEditDocument::DragEnter(IDataObject *pDataObject,
                        DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = GetElement(TRUE /* fInDragDrop */);

    m_fLocked = FALSE;
    m_eDirection = CONSTRAIN_NONE;

    if (SUCCEEDED(hr) &&
        m_pihtmlElement &&
        SUCCEEDED(hr=GetTridentWindow()))
    {
        BOOL f2D = FALSE;
        LONG lWidth;
        LONG lHeight;
        IHTMLElement* pihtmlElementParent=NULL;
        HBITMAP hbmp;

        _ASSERTE(m_pihtmlStyle);
        if (IsDesignMode() &&           //Are we in design mode?
            m_pihtmlStyle &&            //abort if don't have style
            IsDragSource() &&           //abort if Trident isn't source of drag
            SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && f2D &&
            SUCCEEDED(IsLocked(m_pihtmlElement, &m_fLocked)) && !m_fLocked &&
            SUCCEEDED(GetScrollPosition()) &&
            SUCCEEDED(GetElementPosition(m_pihtmlElement, &m_rcElement)))
        {
            //first, let's get a pattern brush to use for the move rectangle
            hbmp = LoadBitmap(_Module.GetModuleInstance(), (LPCWSTR)IDR_FEEDBACKRECTBMP);
            _ASSERTE(hbmp);
            m_hbrDragRect = CreatePatternBrush(hbmp);
            _ASSERTE(m_hbrDragRect);
            DeleteObject(hbmp);

            ::SetRect(&m_rcElementParent, 0, 0, 0, 0);
            hr = m_pihtmlElement->get_offsetParent(&pihtmlElementParent);
            if (SUCCEEDED(hr) && pihtmlElementParent)
            {
                GetElementPosition(pihtmlElementParent, &m_rcElementParent);
            }
            SAFERELEASE(pihtmlElementParent);

            lWidth  = m_rcElement.right - m_rcElement.left;
            lHeight = m_rcElement.bottom - m_rcElement.top;

            //this is where we'll initially draw the drag rectangle
            m_rcDragRect = m_rcElementOrig = m_rcElement;

            //convert clicked point to client coordinates
            m_ptClickLast.x = pt.x;
            m_ptClickLast.y = pt.y;
            ScreenToClient(m_hwndTrident, &m_ptClickLast);

            //save point in doc coordinates where clicked.
            m_ptClickOrig = m_ptClickLast;
            m_ptClickOrig.x += m_ptScroll.x;
            m_ptClickOrig.y += m_ptScroll.y;

            if (m_fConstrain)
            {
                m_ptConstrain.x = m_rcElement.left;
                m_ptConstrain.y = m_rcElement.top;
            }

            #define BORDER_WIDTH 7

            if (m_ptClickOrig.x < (m_rcDragRect.left - BORDER_WIDTH))
            {
                m_rcDragRect.left   = m_ptClickOrig.x;
                m_rcDragRect.right  = m_rcDragRect.left + lWidth;
            }
            else if (m_ptClickOrig.x > (m_rcDragRect.right + BORDER_WIDTH))
            {
                m_rcDragRect.right  = m_ptClickOrig.x;
                m_rcDragRect.left   = m_rcDragRect.right - lWidth;
            }

            if (m_ptClickOrig.y < (m_rcDragRect.top  - BORDER_WIDTH))
            {
                m_rcDragRect.top    = m_ptClickOrig.y;
                m_rcDragRect.bottom = m_rcDragRect.top  + lHeight;
            }
            else if (m_ptClickOrig.y > (m_rcDragRect.bottom + BORDER_WIDTH))
            {
                m_rcDragRect.bottom = m_ptClickOrig.y;
                m_rcDragRect.top    = m_rcDragRect.bottom - lHeight;
            }

            m_rcElement = m_rcDragRect;

            //Trace("DragEnter: m_rcElement(%d,%d,%d,%d)", m_rcElement.left, m_rcElement.top, m_rcElement.right, m_rcElement.bottom);
            //Trace("DragEnter: m_rcDragRect(%d,%d,%d,%d)", m_rcDragRect.left, m_rcDragRect.top, m_rcDragRect.right, m_rcDragRect.bottom);
            //Trace("DragEnter: m_ptClickLast(%d,%d)", m_ptClickLast.x, m_ptClickLast.y);
            //Trace("DragEnter: m_ptClickOrig(%d,%d)", m_ptClickOrig.x, m_ptClickOrig.y);

            //now draw the selection rect
            Draw2DDragRect(TRUE);
            *pdwEffect = DROPEFFECT_MOVE;
            hr = S_OK;
        }
        else
        if (!m_fLocked)
        {
            //something is hosed. just bail
            ReleaseElement();
        }
    }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragOver (IDropTarget method)
// 
// Provide feedback during a drag, updating the drag rectangle, and scrolling
// the document as needed.


STDMETHODIMP CTriEditDocument::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_UNEXPECTED;
    POINT ptClient;

    if (m_pihtmlElement &&
        !m_fLocked &&
        SUCCEEDED(GetScrollPosition()))  //we are handling the drag-drop
    {
            ptClient.x = pt.x;
            ptClient.y = pt.y;
            ScreenToClient(m_hwndTrident, &ptClient);

            // scroll if required
            if (S_OK == DragScroll(ptClient))
            {
                *pdwEffect = DROPEFFECT_MOVE | DROPEFFECT_SCROLL;
            }
            else
            {
                if (ptClient.x != m_ptClickLast.x || ptClient.y != m_ptClickLast.y)
                {
                    //update the last click position
                    m_ptClickLast.x = ptClient.x;
                    m_ptClickLast.y = ptClient.y;
    
                    //Trace("DragOver: m_ptClickLast(%d,%d)", m_ptClickLast.x, m_ptClickLast.y);
    
                    //erase the move rectangle
                    Draw2DDragRect(FALSE);
    
                    ConstrainXY(&ptClient);
                    SnapToGrid(&ptClient);

                    //redraw the move rectangle
                    Draw2DDragRect(TRUE);
                }
        *pdwEffect = DROPEFFECT_MOVE;
            }
        hr = S_OK;
        }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
            hr = m_pDropTgtTrident->DragOver(grfKeyState, pt, pdwEffect);
    }   

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragLeave (IDropTarget method)
// 
// If currently dragging, erase the drag rectangle.
//

STDMETHODIMP CTriEditDocument::DragLeave()
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pihtmlElement && !m_fLocked)
    {
        //erase the move rectangle
        Draw2DDragRect(FALSE);

        if (m_hbrDragRect)
        {
            DeleteObject(m_hbrDragRect);
            m_hbrDragRect = NULL;
        }
        hr = S_OK;
    }
    else if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->DragLeave();
    }
    ReleaseElement();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Drop (IDropTarget method)
//
// After a successful drag of an unlocked element, erase the drag rectangle
// and then handle the actual drop by moving or creating an item. Newly
// created items will be 2D positionable.
//

STDMETHODIMP CTriEditDocument::Drop(IDataObject *pDataObject,
                        DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pihtmlElement && !m_fLocked)
    {
        _ASSERTE(m_pihtmlElement);
        _ASSERTE(m_pihtmlStyle);

        //erase the move rectangle
        Draw2DDragRect(FALSE);

        if (m_hbrDragRect)
        {
            DeleteObject(m_hbrDragRect);
            m_hbrDragRect = NULL;
        }

        if (m_pihtmlStyle)
        {
            POINT ptOrig, ptMove;

            m_rcDragRect.left   = m_rcDragRect.left   - m_rcElementParent.left;
            m_rcDragRect.top    = m_rcDragRect.top    - m_rcElementParent.top;
            m_rcDragRect.right  = m_rcDragRect.right  - m_rcElementParent.right;
            m_rcDragRect.bottom = m_rcDragRect.bottom - m_rcElementParent.bottom;

            ptOrig.x = m_rcElementOrig.left;
            ptOrig.y = m_rcElementOrig.top;
            ptMove.x = m_rcDragRect.left;
            ptMove.y = m_rcDragRect.top;
            CUndoDrag* pUndoDrag = new CUndoDrag(m_pihtmlStyle, ptOrig, ptMove);
            if (pUndoDrag)      //constructor sets m_cRef=1
            {
                hr = AddUndoUnit(m_pUnkTrident, pUndoDrag);
                _ASSERTE(SUCCEEDED(hr));
                pUndoDrag->Release();
            }

            m_pihtmlStyle->put_pixelLeft(m_rcDragRect.left);
            m_pihtmlStyle->put_pixelTop(m_rcDragRect.top);
        }

        //cleanup
        hr = S_OK;
    }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->Drop(pDataObject, grfKeyState, pt, pdwEffect);

        // The following is to workaround a Trident bug where they don't
        // set the focus to their window upon the drop
        if (S_OK == hr)
        {
            CComPtr<IOleInPlaceSite> pInPlaceSite;
            CComPtr<IOleInPlaceFrame> pInPlaceFrame;
            CComPtr<IOleInPlaceUIWindow> pInPlaceWindow;
            RECT posRect, clipRect;
            OLEINPLACEFRAMEINFO frameInfo;
            HWND hwnd, hwndFrame;
            
            if (S_OK == m_pClientSiteHost->QueryInterface(IID_IOleInPlaceSite, (void **)&pInPlaceSite))
            {
                _ASSERTE(NULL != pInPlaceSite.p);
                if (S_OK == pInPlaceSite->GetWindowContext(&pInPlaceFrame, &pInPlaceWindow, &posRect, &clipRect, &frameInfo))
                {
                    if (NULL != pInPlaceWindow.p)
                        pInPlaceWindow->GetWindow(&hwnd);
                    else
                    {
                        _ASSERTE(NULL != pInPlaceFrame.p);
                        pInPlaceFrame->GetWindow(&hwnd);
                    }
                    // We need to walk up the parent chain till we find a frame window to work around a Vegas bug
                    // Note that this is generic enough to do the right thing for all of our clients
                    hwndFrame = hwnd;
                    do
                    {
                        if (GetWindowLong(hwndFrame, GWL_STYLE) & WS_THICKFRAME)
                            break;
                        hwndFrame = GetParent(hwndFrame);
                    } 
                    while (hwndFrame);

                    SetFocus(hwndFrame && IsWindow(hwndFrame) ? hwndFrame : hwnd);
                }
            }
        }

        // Handle 2d drop mode here
        if (S_OK == hr && !IsDragSource())
        {
            BOOL f2DCapable = FALSE;
            BOOL f2D = FALSE;

            GetElement();

            // we do the following if we are in 2DDropMode and the element is 2DCapable 
            // and the element is not already 2D or a DTC
            if (m_f2dDropMode && m_pihtmlElement &&
                SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2DCapable)) && f2DCapable &&
                SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && !f2D &&
                FAILED(IsElementDTC(m_pihtmlElement)))
            {
                HRESULT hr;
                POINT ptClient;
                            
                ptClient.x = pt.x;
                ptClient.y = pt.y;

                if (SUCCEEDED(hr = CalculateNewDropPosition(&ptClient)))
                    hr = Make2DElement(m_pihtmlElement, &ptClient);
                else
                    hr = Make2DElement(m_pihtmlElement);

                _ASSERTE(SUCCEEDED(hr));
            }
    
            if (m_pihtmlElement)
            {
                BOOL f2D = FALSE;
                VARIANT var;
                POINT ptClient;

                ptClient.x = pt.x;
                ptClient.y = pt.y;
                                       
                if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && f2D)
                {
                    if (SUCCEEDED(CalculateNewDropPosition(&ptClient)))
                    {
                        IHTMLElement *pihtmlElementParent = NULL;

                        m_pihtmlElement->get_offsetParent(&pihtmlElementParent);

                        if(pihtmlElementParent)
                        {
                            RECT rcParent;

                            if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                            {
                                m_pihtmlStyle->put_pixelLeft(ptClient.x - rcParent.left);
                                m_pihtmlStyle->put_pixelTop(ptClient.y - rcParent.top);
                            }
                            SAFERELEASE(pihtmlElementParent);
                        }
                    }

                    VariantInit(&var);
                    var.vt = VT_I4;
                    var.lVal = 0; 
                    m_pihtmlStyle->put_zIndex(var);
                    AssignZIndex(m_pihtmlElement, MADE_ABSOLUTE);
                }
            }
        }
    }

    ReleaseElement();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetElement
//
// Fetch the current Trident element and its style into m_pihtmlElement and 
// m_pihtmlStyle, respectively. If currently in mid-drag-drop (as indicated
// by fInDragDrop) then do not accept an HTML element of type "Text" as
// the currrent element. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::GetElement(BOOL fInDragDrop)
{
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLSelectionObject* pihtmlSelObj=NULL;
    IHTMLTxtRange* pihtmlTxtRange=NULL;
    IHTMLControlRange* pihtmlControlRange=NULL;
    IHTMLElement* pihtmlBodyElement=NULL;
    IUnknown* punkBody=NULL;
    IUnknown* punkElement=NULL;
    IDispatch* pidisp=NULL;
    BSTR bstrType=NULL;

    ReleaseElement();           //cleanup just in case...
    _ASSERTE(m_pUnkTrident);

    HRESULT hr = GetDocument(&pihtmlDoc2);

    if (FAILED(hr))
        goto CleanUp;

    hr = pihtmlDoc2->get_selection(&pihtmlSelObj);

    if (FAILED(hr))
        goto CleanUp;

    _ASSERTE(pihtmlSelObj);
    hr = pihtmlSelObj->get_type(&bstrType);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr) || !bstrType || (fInDragDrop && _wcsicmp(bstrType, L"Text")==0))
        goto CleanUp;

    hr = pihtmlSelObj->createRange(&pidisp);

    if (FAILED(hr) || !pidisp)
        goto CleanUp;

    hr = pidisp->QueryInterface(IID_IHTMLTxtRange, (LPVOID*)&pihtmlTxtRange);

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pihtmlTxtRange);
        hr = pihtmlTxtRange->parentElement(&m_pihtmlElement);
        goto CleanUp;
    }

    hr = pidisp->QueryInterface(IID_IHTMLControlRange, (LPVOID*)&pihtmlControlRange);

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pihtmlControlRange);
        hr = pihtmlControlRange->commonParentElement(&m_pihtmlElement);
    }

CleanUp:
    hr = E_FAIL;

    if (m_pihtmlElement)
    {
        //get the body element
        hr = pihtmlDoc2->get_body(&pihtmlBodyElement);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            //get their IUnknowns
            hr = pihtmlBodyElement->QueryInterface(IID_IUnknown, (LPVOID*)&punkBody);
            _ASSERTE(SUCCEEDED(hr));
            hr = m_pihtmlElement->QueryInterface(IID_IUnknown, (LPVOID*)&punkElement);
            _ASSERTE(SUCCEEDED(hr));

            //If they're equivalent, the body element is the current element
            //and we don't want it.
            if (punkBody == punkElement)
            {
                hr = E_FAIL;
            }
        }

        // VID98 bug 2647: if type is none, don't bother to cache style.
        // This is to workaround trident crash bug
        if (SUCCEEDED(hr) && bstrType && _wcsicmp(bstrType, L"None")!=0)
        {
            hr = m_pihtmlElement->get_style(&m_pihtmlStyle);
            _ASSERTE(SUCCEEDED(hr));
            _ASSERTE(m_pihtmlStyle);
        }
        if (FAILED(hr) || !m_pihtmlStyle)
        {
            ReleaseElement();
        }
        hr = S_OK;
    }
    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlSelObj);
    SAFERELEASE(pidisp);
    SAFERELEASE(pihtmlTxtRange);
    SAFERELEASE(pihtmlControlRange);
    SAFERELEASE(pihtmlBodyElement);
    SAFERELEASE(punkBody);
    SAFERELEASE(punkElement);
    SysFreeString(bstrType);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::ReleaseElement
//
// Release any cached reference to the current Trident element and its
// associated style. No return value.
//

void CTriEditDocument::ReleaseElement(void)
{
    SAFERELEASE(m_pihtmlElement);
    SAFERELEASE(m_pihtmlStyle);
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Draw2DDragRect
//
// After giving the drag-drop handler host a chance to draw the drag rectangle,
// draw the rectangle if the handler choose not to do so. No return value.
//

void CTriEditDocument::Draw2DDragRect(BOOL fDraw)
{
    RECT rect = m_rcDragRect;

    // S_FALSE means that the host has already drawn its own feedback
    if (m_pDragDropHandlerHost && m_pDragDropHandlerHost->DrawDragFeedback(&rect) == S_FALSE)
        return;

    if ((fDraw == m_fDragRectVisible) || (NULL == m_hwndTrident) || (NULL == m_hbrDragRect))
        return;

    HDC hdc = GetDC(m_hwndTrident);
    _ASSERTE(hdc);
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, m_hbrDragRect);
    _ASSERTE(hbrOld);

    //BUGS:M3-2723\The Drag Rectangle Must be at Least 8x8 pixels
    LONG lWidth  = max((rect.right - rect.left), 16);
    LONG lHeight = max((rect.bottom - rect.top), 16);

    SetWindowOrgEx(hdc, m_ptScroll.x, m_ptScroll.y, NULL);

    //A Value of 2 is added to the rect's left and top in all the following PatBlt function
    //to work around a rounding off bug caused by trident.

    PatBlt( hdc, rect.left + 2, rect.top + 2,
            lWidth, 1, PATINVERT);

    PatBlt( hdc, rect.left + 2, rect.top + lHeight + 1, //(2 - 1)
            lWidth, 1, PATINVERT);

    PatBlt( hdc, rect.left + 2, rect.top + 3,//(2 + 1)
            1, lHeight - (2 * 1), PATINVERT);

    PatBlt( hdc, rect.left + lWidth + 1 /*(2 - 1)*/, rect.top + 3, //(2 + 1)
            1, lHeight - (2 * 1), PATINVERT);

    m_fDragRectVisible = !m_fDragRectVisible;

    SelectObject(hdc, hbrOld);
    ReleaseDC(m_hwndTrident, hdc);
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetScrollPosition
//
// Get the Trident document's scroll position and store it in m_ptScroll. 
// Return S_OK or a Trident error code.
//

HRESULT CTriEditDocument::GetScrollPosition(void)
{
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLTextContainer* pihtmlTextContainer=NULL;
    IHTMLElement* pihtmlElement=NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(m_pUnkTrident);
    if (SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        if (SUCCEEDED(pihtmlDoc2->get_body(&pihtmlElement)))
        {
            _ASSERTE(pihtmlElement);
            if (pihtmlElement)
            {
                if (SUCCEEDED(pihtmlElement->QueryInterface(IID_IHTMLTextContainer,
                    (LPVOID*)&pihtmlTextContainer)))
                {
                    _ASSERTE(pihtmlTextContainer);
                    if (pihtmlTextContainer)
                    {
                        hr = pihtmlTextContainer->get_scrollLeft(&m_ptScroll.x);
                        _ASSERTE(SUCCEEDED(hr));
                        hr = pihtmlTextContainer->get_scrollTop(&m_ptScroll.y);
                        _ASSERTE(SUCCEEDED(hr));
                        hr = S_OK;
                    }
                }
            }
        }
    }
    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlTextContainer);
    SAFERELEASE(pihtmlElement);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragScroll
//
// Scroll the Trident document so as to make the given point visible. If a
// drag rectangle is visible it will be erased before any scrolling occurs;
// the caller is responsible for redrawing the rectangle. Returns S_OK if the
// document was scrolled, S_FALSE if not scrolling was required, or a
// Trident error.
//

#define nScrollInset 5

HRESULT CTriEditDocument::DragScroll(POINT pt)
{
    RECT rectClient, rect;
    long x = 0, y = 0;
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLWindow2* pihtmlWindow2=NULL;

    GetClientRect(m_hwndTrident, &rectClient);
    rect = rectClient;
    InflateRect(&rect, -nScrollInset, -nScrollInset);
    if (PtInRect(&rectClient, pt) && !PtInRect(&rect, pt))
    {
        // determine direction of scroll along both X & Y axis
        if (pt.x < rect.left)
            x = -nScrollInset;
        else if (pt.x >= rect.right)
            x = nScrollInset;
        if (pt.y < rect.top)
            y = -nScrollInset;
        else if (pt.y >= rect.bottom)
            y = nScrollInset;
    }

    if (x == 0 && y == 0) // no scrolling required    
        return S_FALSE;

    _ASSERTE(m_pUnkTrident);
    if (SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        _ASSERTE(pihtmlDoc2);
        if (SUCCEEDED(pihtmlDoc2->get_parentWindow(&pihtmlWindow2)))
        {
            _ASSERTE(pihtmlWindow2);

            // erase move rectangle before scrolling
            Draw2DDragRect(FALSE);

            pihtmlWindow2->scrollBy(x,y);
        }
    }

    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlWindow2);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsDragSource
//
// Return TRUE if the current OLE drag-drop was originated by Trident, or
// FALSE otherwise.
//


BOOL CTriEditDocument::IsDragSource(void)
{
    BOOL fDragSource = FALSE;
    HRESULT hr;
    VARIANT var;

    if (m_pUnkTrident)
    {
        IOleCommandTarget* pioleCmdTarget;
        if (SUCCEEDED(m_pUnkTrident->QueryInterface(IID_IOleCommandTarget,
                (LPVOID*)&pioleCmdTarget)))
        {
            _ASSERTE(pioleCmdTarget);
            if (pioleCmdTarget)
            {
                VariantInit(&var);
                var.vt = VT_BOOL;
                var.boolVal = FALSE;
                hr = pioleCmdTarget->Exec( &CMDSETID_Forms3,
                              IDM_SHDV_ISDRAGSOURCE,
                              MSOCMDEXECOPT_DONTPROMPTUSER,
                              NULL,
                              &var );
                _ASSERTE(SUCCEEDED(hr));
                fDragSource = (var.boolVal) ? TRUE:FALSE;
                pioleCmdTarget->Release();
            }
        }
    }
    return fDragSource;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::ConstrainXY
//
// If TriEdit's constrained dragging mode is enabled, constrain the 
// rectangle of the current element (m_rcElement) vis-a-vis the given
// point according to the current constraint direction, first computing
// the constraint direction if necessary. Return S_OK.
//

HRESULT CTriEditDocument::ConstrainXY(LPPOINT lppt)  //pt is in client coordinates
{
    POINT ptRel;

    if (m_fConstrain)
    {
        if (CONSTRAIN_NONE == m_eDirection)
        {
            ptRel.x = (lppt->x + m_ptScroll.x) - m_ptClickOrig.x;
            ptRel.y = (lppt->y + m_ptScroll.y) - m_ptClickOrig.y;

            if ((ptRel.x && !ptRel.y) || (abs(ptRel.x) > abs(ptRel.y)))
                m_eDirection = CONSTRAIN_HORIZONTAL;
            else
            if ((!ptRel.y && ptRel.y) || (abs(ptRel.y) > abs(ptRel.x)))
                m_eDirection = CONSTRAIN_VERTICAL;
            else
                m_eDirection = CONSTRAIN_HORIZONTAL;

            if (m_eDirection == CONSTRAIN_VERTICAL)
            {
                LONG lWidth = m_rcElement.right - m_rcElement.left;
                
                m_ptClickOrig.x = m_rcElement.left = m_ptConstrain.x;
                m_rcElement.right = m_rcElement.left + lWidth;
            }
            else
            {
                LONG lHeight = m_rcElement.bottom - m_rcElement.top;

                m_ptClickOrig.y = m_rcElement.top = m_ptConstrain.y;
                m_rcElement.bottom = m_rcElement.top + lHeight;
            }
        }
        switch(m_eDirection)
        {
            case CONSTRAIN_HORIZONTAL:
                lppt->y = (m_ptClickOrig.y - m_ptScroll.y);
                break;

            case CONSTRAIN_VERTICAL:
                lppt->x = (m_ptClickOrig.x - m_ptScroll.x);
                break;
        }
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SnapToGrid
//
// Snap the appropriate edge of the current HTML element (m_rcElement) to the
// given point, modulo the current TriEdit grid setting. Return S_OK.
//

HRESULT CTriEditDocument::SnapToGrid(LPPOINT lppt)  //pt is in client coordinates
{
    POINT ptRel;
    POINT ptDoc;

    _ASSERTE(lppt);

    //determine relative movement
    ptRel.x = (lppt->x + m_ptScroll.x) - m_ptClickOrig.x;
    ptRel.y = (lppt->y + m_ptScroll.y) - m_ptClickOrig.y;
    ptDoc.x = m_rcElement.left - m_rcElementParent.left + ptRel.x;
    ptDoc.y = m_rcElement.top - m_rcElementParent.top + ptRel.y;

    if (ptRel.x < 0)        //LEFT
    {
        if (ptDoc.x % m_ptAlign.x)
            ptDoc.x -= (ptDoc.x % m_ptAlign.x);
        else
            ptDoc.x -= m_ptAlign.x;
    }
    else
    if (ptRel.x > 0)        //RIGHT
    {
        if (ptDoc.x % m_ptAlign.x)
            ptDoc.x += m_ptAlign.x - (ptDoc.x % m_ptAlign.x);
        else
            ptDoc.x += m_ptAlign.x;
    }

    if (ptRel.y < 0)        //UP
    {
        if (ptDoc.y % m_ptAlign.y)
            ptDoc.y -= (ptDoc.y % m_ptAlign.y);
        else
            ptDoc.y -= m_ptAlign.y;
    }
    else
    if (ptRel.y > 0)        //DOWN
    {
        if (ptDoc.y % m_ptAlign.y)
            ptDoc.y += m_ptAlign.y - (ptDoc.y % m_ptAlign.y);
        else
            ptDoc.y += m_ptAlign.y;
    }

    m_rcDragRect.left   = m_rcElementParent.left + ptDoc.x;
    m_rcDragRect.top    = m_rcElementParent.top + ptDoc.y;
    m_rcDragRect.right  = m_rcDragRect.left + (m_rcElement.right  - m_rcElement.left);
    m_rcDragRect.bottom = m_rcDragRect.top + (m_rcElement.bottom - m_rcElement.top);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsDesignMode
//
// Return TRUE if Trident is in design (edit) mode, or FALSE if it is in
// browse mode.
//

BOOL CTriEditDocument::IsDesignMode(void)
{
    HRESULT hr;
    OLECMD olecmd;

    olecmd.cmdID = IDM_EDITMODE;
    hr = m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL);

    return (SUCCEEDED(hr) && (olecmd.cmdf & OLECMDF_LATCHED));
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetElementPosition
//
// Return (under prc) the position of the given HTML element in document
// coordinates. Return S_OK or a Trident error code as the return value.
//

HRESULT CTriEditDocument::GetElementPosition(IHTMLElement* pihtmlElement, LPRECT prc)
{
    IHTMLElement* pelem = NULL;
    IHTMLElement* pelemNext = NULL;
    POINT ptExtent;
    HRESULT hr;

    _ASSERTE(pihtmlElement && prc);
    if(!pihtmlElement || !prc)
        return E_POINTER;

    if(FAILED(pihtmlElement->get_offsetLeft(&prc->left)))
        return(E_FAIL);
    if(FAILED(pihtmlElement->get_offsetTop(&prc->top)))
        return(E_FAIL);

    hr = pihtmlElement->get_offsetParent(&pelemNext);

    while (SUCCEEDED(hr) && pelemNext)
    {
        POINT pt;

        if(FAILED(hr = pelemNext->get_offsetLeft(&pt.x)))
            goto QuickExit;
        if(FAILED(hr = pelemNext->get_offsetTop(&pt.y)))
            goto QuickExit;
        prc->left += pt.x;
        prc->top += pt.y;
        pelem = pelemNext;
        pelemNext = NULL;
        hr = pelem->get_offsetParent(&pelemNext);
        SAFERELEASE(pelem);
    }

    if (FAILED(hr = pihtmlElement->get_offsetWidth(&ptExtent.x)))
        goto QuickExit;
    if (FAILED(hr = pihtmlElement->get_offsetHeight(&ptExtent.y)))
        goto QuickExit;

    prc->right  = prc->left + ptExtent.x;
    prc->bottom = prc->top  + ptExtent.y;

QuickExit:
    _ASSERTE(SUCCEEDED(hr));
    SAFERELEASE(pelem);
    SAFERELEASE(pelemNext);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetTridentWindow
//
// Fetch the IOleWindow interface of the Trident instance in to m_hwndTrident.
// Return S_OK or the Trident error code.
//

STDMETHODIMP CTriEditDocument::GetTridentWindow()
{
    LPOLEWINDOW piolewinTrident;
    HRESULT hr = E_FAIL;

    if( m_pOleObjTrident &&
        SUCCEEDED(hr = m_pOleObjTrident->QueryInterface(IID_IOleWindow, (LPVOID*)&piolewinTrident)))
    {
        m_hwndTrident = NULL;
        hr = piolewinTrident->GetWindow(&m_hwndTrident);
        _ASSERTE(m_hwndTrident != NULL);
        piolewinTrident->Release();
    }

    _ASSERTE(SUCCEEDED(hr));
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CalculateNewDropPosition
//
// Adjust the given point to adjust for the fact that the Trident document may
// be scrolled. Return S_OK or a Trident error code.

HRESULT CTriEditDocument::CalculateNewDropPosition(POINT *pt)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(hr = GetTridentWindow()) && 
        ScreenToClient(m_hwndTrident, pt) &&
        SUCCEEDED(hr = GetScrollPosition()))
    {
        pt->x += m_ptScroll.x;
        pt->y += m_ptScroll.y;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\lexhtml.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __LEXHTML__
#define __LEXHTML__

#include "lex.h"
#include "tokhtml.h"

#define DS_HTML_IE3         _T("HTML - IE 3.0")
#define DS_HTML_RFC1866     _T("HTML 2.0 (RFC 1866)")


// token hints
#define BASED_HINT  0x9000
#define ERR         BASED_HINT +  0  // error
#define HWS         BASED_HINT +  1  // white space
#define HST         BASED_HINT +  2  // string "..."
#define HSL         BASED_HINT +  3  // string alternate '...'
#define HNU         BASED_HINT +  5  // number
#define HKW         BASED_HINT +  6  // keyword
#define HEN         BASED_HINT +  7  // entity &...;
#define HRN         BASED_HINT +  8  // reserved name #...
#define HEP         BASED_HINT +  9  // parameter entity %...;
#define HTA         BASED_HINT + 10  // tag open <
#define HTE         BASED_HINT + 11  // tag end >
#define HDB         BASED_HINT + 12  // dbcs (> 128).   HTMED CHANGE (walts)
#define HAV         BASED_HINT + 13  // valid attr value start char     HTMED CHANGE (walts)

// strictly single ops
#define ODA tokOpDash
#define OCO tokOpComma
#define OPI tokOpPipe
#define OPL tokOpPlus
#define OEQ tokOpEqual
#define OST tokOpStar
#define OLP tokOpLP
#define ORP tokOpRP
#define OLB tokOpLB
#define ORB tokOpRB
#define OQU tokOpQuestion
#define OLC tokDELI_LCBKT   
#define ORC tokDELI_RCBKT   
#define ONL tokNEWLINE
#define EOS tokEOF

typedef unsigned short HINT;

typedef BYTE RWATT_T;
//
// Reserved Word Attributes - HTML variant
//
enum RWATT
{
    HTML2 = 0x01,  // RFC 1866
//  IEXP2 = 0x02,  // Internet Explorer 2.0
    IEXP3 = 0x04,  // Internet Explorer 3.0
    ALL   = 0xff,  // all browsers
};
#define IEXPn (IEXP3)
#define IE40  (ALL)

typedef struct ReservedWord
{
    TCHAR *     psz;        // pointer to reserved word string 
    BYTE        cb;         // length of reserved word
    RWATT_T     att;        // attributes
} ReservedWord;

#endif // __LEXHTML__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\lexer.h ===
/* copied from ..\htmed\lexer.cpp */
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

/*++

  Copyright (c) 1995 Microsoft Corporation

  File: lexer.h

  Abstract:
        Nitty gritty lexer stuff

  Contents:

  History:
      2/14/97   cgomes:   Created


--*/
#if !defined __INC_LEXER_H__
#define __INC_LEXER_H__

#include "token.h"

extern CTableSet*   g_ptabASP;
extern PSUBLANG     g_psublangASP;
extern PTABLESET    g_arpTables[CV_MAX+1];

typedef enum tag_COMMENTTYPE
{
    CT_NORMAL       = 0,
    CT_METADATA     = -1,
    CT_IECOMMENT    = 1
} COMMENTTYPE;

HINT GetHint         (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
HINT GetTextHint     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT GetToken        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT GetTokenLength  (LPCTSTR pchLine, UINT cbLen, UINT cbCur);
UINT FindEndEntity   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
COMMENTTYPE IfHackComment   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEntityRef   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndComment  (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindServerScript(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindValue       (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndString   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindNextToken   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindTagOpen     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndTag      (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindText        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsUnknownID     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsNumber        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsElementName   (LPCTSTR pchLine, UINT cbCur, int cbTokLen, TXTB & token);
BOOL IsAttributeName (LPCTSTR pchLine, UINT cbCur, int cbTokLen, TXTB & token);
BOOL IsIdentifier(int iTokenLength, TXTB & token);
int  IndexFromElementName(LPCTSTR pszName);


CTableSet * MakeTableSet(CTableSet ** rgpts, RWATT_T att, UINT nIdName);
void SetLanguage(TCHAR * /*const CString & */strDefault, PSUBLANG rgSublang,
                 PTABLESET pTab, UINT & index, UINT nIdTemplate, CLSID clsid);
CTableSet * FindTable(CTableSet ** rgpts, /*const CString & */TCHAR *strName);
CTableSet * FindTable(CTableSet ** rgpts, CTableSet * pts);


#endif /* __INC_LEXER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\lexer.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
/* copied from ..\htmed\lexer.cpp */

/*++

  Copyright (c) 1995 Microsoft Corporation

  File: lexer.cpp

  Abstract:
        Nitty Gritty Lexer stuff

  Contents:
      SetValueSeen()
      IsSingleOp()
      IsWhiteSpace()
      MapToken()
      FindEndTag()
      MakeSublang()
      SetLanguage()
      FindTable()
      FindTable()
      RemoveTable()
      MakeTableSet()
      GetToken()
      IfHackComment()
      FindServerScript()
      FindEndComment()
      FindEndEntity()
      FindEntityRef()
      FindValue()
      FindEndString()
      FindTagOpen()
      FindText()
      FindNextToken()
      GetTextHint()
      GetHint()
      GetTokenLength()
      GetValueTokenLength()
      IsElementName()
      IsAttributeName()
      IsIdentifier()
      IsUnknownID()
      IsNumber()
      CColorHtml::SetTable()
      CColorHtml::InitSublanguages()

  History:
      2/14/97   cgomes:   Created


--*/

#include "stdafx.h"

#include "resource.h"
#include "guids.h"
#include "token.h"
#include "table.h"
#include "lexer.h"

UINT FindClientScriptEnd(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);

#undef ASSERT
#define ASSERT(b) _ASSERTE(b)
// HACK: we keep a copy of a ptr to the ASP table and sublang
// so we can do special behavior for ASP files
CTableSet* g_ptabASP = 0;
PSUBLANG g_psublangASP = 0;

PTABLESET g_arpTables[CV_MAX+1];

// NOTE: added to handle value tokens properly.
UINT GetValueTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur);

// mark state transition from value -> next attribute
inline int SetValueSeen(DWORD *plxs)
{
    if (*plxs & inValue)
    {
        *plxs &= ~inValue;
        *plxs |= inAttribute;
        return TRUE;
    }
    else
        return FALSE;
}

// REVIEW (walts) - need better way
inline void SetScriptLanguage(LPCTSTR pchLine, DWORD *plxs)
{
    LPCTSTR strJavaScript       = _T("javascript");
    LPCTSTR strVBScript         = _T("vbscript");
    // triedit's special language. Its set when we convert server-side scripts into
    // client-side scripts. Its a dummy language. if we find that as language, we
    // set in ServerASP. It is reset(removed) in FindNextToken().
    LPCTSTR strServerAsp        = _T("serverasp");

    // language attribute may have quotes around it.
    // if it does then advance past the first quote.
    //      ex. <SCRIPT LANGUAGE="VBScript">
    if(*pchLine == L'\"')
        pchLine++;

    if (_tcsnicmp(pchLine, strJavaScript, lstrlen(strJavaScript)) == 0)
    {
        *plxs &= ~inVBScript;
        *plxs &= ~inServerASP;
        *plxs |= inJavaScript;
    }
    else if (_tcsnicmp(pchLine, strVBScript, lstrlen(strVBScript)) == 0)
    {
        *plxs &= ~inJavaScript;
        *plxs &= ~inServerASP;
        *plxs |= inVBScript;
    }
    else if (_tcsnicmp(pchLine, strServerAsp, lstrlen(strServerAsp)) == 0)
    {
        *plxs &= ~inJavaScript;
        *plxs &= ~inVBScript;
        *plxs |= inServerASP;
    }
}

inline BOOL IsSingleOp(HINT hint)
{
    return ((hint >= tokOP_SINGLE) && (hint < tokOP_MAX));
};

inline BOOL IsWhiteSpace(TCHAR c)
{
    return _istspace(c);
};


// NOTE: Added to handle value tokens properly
inline IsValueChar(TCHAR ch)
{
    // REVIEW(cgomes): specify all the invalid value characters
    return ch != _T('<') && ch != _T('>');
};

////////////////////////////////////////////////////////////////////////////
//
// map parsed token to returned token

// left column must be in ascending order
static TOKEN _rgTokenMap[] =
{
    tokName,     tokSpace,
    tokNum,      tokSpace,
    tokParEnt,   tokSpace,
    tokResName,  tokSpace,
    0,           0
};

static TOKEN MapToken(TOKEN tokClass, DWORD lxs)
{
    if (IsSingleOp((HINT)tokClass))
        return tokOp;
    else if ((tokClass == tokTag) && (lxs & inHTXTag))
        return tokSSS;
    for (int i = 0; (_rgTokenMap[i] != 0) && (_rgTokenMap[i] >= tokClass); i += 2)
    {
        if (_rgTokenMap[i] == tokClass)
            return _rgTokenMap[i + 1];
    }
    return tokClass;
}

////////////////////////////////////////////////////////////////////////////

UINT FindEndTag(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD *plxs, TXTB & token)
{
    ASSERT(pchLine);
    TCHAR szEnd[16];
    ELLEX * pellex = pellexFromTextState(*plxs);
    ASSERT(0 != pellex); // shouldn't be called with something other than special text state
    UINT cbCmp = 3 + pellex->cb; // length of end tag
    ASSERT(cbCmp < sizeof szEnd);
    _tcscpy(szEnd, _T("</"));
    _tcscat(szEnd, pellex->sz);
    _tcscat(szEnd, _T(">"));

    while (cbCur < cbLen)
    {
        if (_T('<') == pchLine[cbCur])
        {
            if ((cbLen - cbCur >= cbCmp) && (0 == _tcsnicmp(szEnd, &pchLine[cbCur], cbCmp)))
            {
                *plxs &= ~TEXTMASK; // special text modes are exclusive
                token.ibTokMac = cbCur;
                return cbCur;
            }
            else if ((cbCur + 1 < cbLen) && (_T('%') == pchLine[cbCur+1]))
            {
                *plxs |= inHTXTag;
                token.ibTokMac = cbCur;
                break;
            }
            else
                cbCur++;
        }
        else
            cbCur += _tclen(&pchLine[cbCur]);
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

////////////////////////////////////////////////////////////////////////////

BOOL MakeSublang(PSUBLANG ps, UINT id, const TCHAR *strName, UINT nIdTemplate, CLSID clsid)
{
    int len;

    ASSERT( NULL != ps );

    ps->szSubLang = NULL;
    ps->lxsInitial = LxsFromSubLangIndex(id);
    ps->nIdTemplate = nIdTemplate;
    ps->clsidTemplate = clsid;

    if ((len = lstrlen(strName)) != 0)
    {
        LPTSTR szNew = new TCHAR [len+1];
        if (NULL != szNew)
        {
            _tcscpy(szNew,strName);
            ps->szSubLang = szNew;
            return TRUE;
        }
    }
    return FALSE;
}

// Set sublang and tableset array members,
// putting the default one in 0th position.
//
void SetLanguage(TCHAR * strDefault, PSUBLANG rgSublang,
                 PTABLESET pTab, UINT & index, UINT nIdTemplate, CLSID clsid)
{
    if (pTab != NULL)
    {
        int i;
        if (lstrcmp(strDefault, pTab->Name()) == 0)
            i = 0;
        else
            i = index;
        if (MakeSublang(rgSublang+i, i, pTab->Name(), nIdTemplate, clsid))
        {
            g_arpTables[i] = pTab;
            if (i)
                index++;
            else
                g_pTable = pTab;
        }
        else
            delete pTab;
    }
}

CTableSet * FindTable(CTableSet ** rgpts, TCHAR *strName)
{
    for (int n = 0; rgpts[n]; n++)
    {
        if (rgpts[n]->Name() == strName)
        //if (strcmp(rgpts[n]->Name(), strName) == 0)
            return rgpts[n];
    }
    return NULL;
}

CTableSet * FindTable(CTableSet ** rgpts, CTableSet * pts)
{
    for (int n = 0; rgpts[n]; n++)
    {
        if (rgpts[n] == pts)
            return rgpts[n];
    }
    return NULL;
}

void RemoveTable(CTableSet ** rgpts, CTableSet *pts)
{
    int n;
    for (n = 0; rgpts[n]; n++)
    {
        if (rgpts[n] == pts)
        {
            for(; rgpts[n]; n++)
                rgpts[n] = rgpts[n+1];
            return;
        }
    }
}

CTableSet * MakeTableSet(CTableSet ** /*rgpts*/, RWATT_T att, UINT nIdName)
{
    return new CStaticTableSet(att, nIdName);
}

////////////////////////////////////////////////////////////////////////
// GetToken()
//
UINT GetToken(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT (cbCur < cbLen);
    if(cbCur > cbLen)
        return cbCur;

    UINT cbCount = 0;

    // init token
    token.tok = 0;

    // initialize location where token starts
    token.ibTokMin = cbCur;

    if (*plxs & inHTXTag)
        cbCount = FindServerScript(pchLine, cbLen, cbCur, plxs, token);
    else if (*plxs & inSCRIPT && !(*plxs & inTag) && !(*plxs & inServerASP))
    {
        // NOTE that we want to skip tokenizing scripts that are special to triedit
        // when we wrap server-side scripts in client-side scripts, we set a dummy
        // language as 'serverasp'. inServerASP is set in that case.
        cbCount = FindClientScriptEnd(pchLine, cbLen, cbCur, plxs, token);
    }
    else if (*plxs & inComment)  // in a comment
    {
        if (*plxs & inSCRIPT)
            *plxs |= inScriptText;
        COMMENTTYPE ct = IfHackComment(pchLine, cbLen, cbCur, plxs, token);
        if (ct == CT_METADATA)
        {
            // Treat as an element
            cbCount = FindNextToken(pchLine, cbLen, cbCur, plxs, token);
            // Remove inBangTag
            *plxs &= ~inBangTag;
        }
        else if (ct == CT_IECOMMENT)
            cbCount = token.ibTokMac;
        else
            cbCount = FindEndComment(pchLine, cbLen, cbCur, plxs, token);
    }
    else if (*plxs & INSTRING)  // in a string
        cbCount = FindEndString(pchLine, cbLen, cbCur, plxs, token);
    else
        cbCount = FindNextToken(pchLine, cbLen, cbCur, plxs, token);

    token.tokClass = MapToken(token.tokClass, *plxs);
    return cbCount;
}

///////////////////////////////////////////////////////////////////////////////////
// IfHackComment
//
// Probe ahead in the current line to see if we have what IE recognizes
// as the end of a comment ("->"). This does not conform to RFC 1866 or SGML,
// but suppports browser behavior. This lets us tolerate comments of the
// form: "<!--- whatever ->"
// (note how it ends)
//
// Returns a COMMENTTYPE enum.
//  0 if norma comment
//  1 if IE comment
//  -1 if METADATA comment
//
// Proper comments are scanned using FindEndComment().
//
COMMENTTYPE IfHackComment(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    token.tokClass = tokComment;
    while (cbCur+1 < cbLen)
    {
        if(_tcsnicmp(&pchLine[cbCur], _T("METADATA"), lstrlen(_T("METADATA"))) == 0)
        {
            token.ibTokMac = cbCur + 1; // include second dash??
            *plxs &= ~inComment;
            // Remove inBangTag
            *plxs &= ~inBangTag;
            *plxs |= inTag;
            return CT_METADATA; // METADATA
        }
        else if (pchLine[cbCur] == '-' && pchLine[cbCur + 1] == '>')
        {
            token.ibTokMac = cbCur + 1;
            *plxs &= ~inComment;
            *plxs &= ~inScriptText;
            return CT_IECOMMENT;
        }
        else
        {
            cbCur += _tclen(&pchLine[cbCur]);
        }
    }
    return CT_NORMAL;
}


UINT FindServerScript(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;

    // parse HTX start tag
    if (*pCurrent == _T('<') && (cbCur+1 < cbLen) && *(pCurrent+1) == '%')
    {
        token.tokClass = tokTag;
        token.tok = TokTag_SSSOPEN;
        token.ibTokMac = cbCur + 2;
        *plxs |= inHTXTag;
        return token.ibTokMac;
    }

    ASSERT(*plxs & inHTXTag); // should be in HTXTag state here

    if (*pCurrent == _T('%') && (cbCur+1 < cbLen) && *(pCurrent+1) == '>')
    {
        token.tok = TokTag_SSSCLOSE;
        token.tokClass = tokSSS; //tokTag;
        token.ibTokMac = cbCur + 2;
        *plxs &= ~inHTXTag;
        if (*plxs & inNestedQuoteinSSS)
            *plxs &= ~inNestedQuoteinSSS;
        return token.ibTokMac;
    }

    token.tokClass = tokSSS;

    while (cbCur < cbLen)
    {
        if (*pCurrent == _T('%') && (cbCur+1 < cbLen) && (*(pCurrent+1) == _T('>')))
            break;
        if (   *pCurrent == _T('"') 
            && *plxs&inTag
            && *plxs&inHTXTag
            && *plxs&inAttribute
            && *plxs&inString
            )
            *plxs |= inNestedQuoteinSSS;

        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;
    return cbCur;
}

///////////////////////////////////////////////////////////////////////////////////
// FindClientScriptEnd()
//
// HTMED CHANGE: Find the end of client script block
//
UINT FindClientScriptEnd(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;

    TCHAR rgEndScript[] = _T("</SCRIPT");
    int cchEndScript = (wcslen(rgEndScript) - 1);

    if( cbCur + cchEndScript < cbLen &&
        0 == _tcsnicmp(pCurrent, rgEndScript, cchEndScript))
    {
        token.tokClass = tokTag;
        token.tok = TokTag_END;
        *plxs &= ~inSCRIPT;
        *plxs |= inEndTag;
        token.ibTokMac = cbCur + 2;
        return token.ibTokMac;
    }

    token.tokClass = tokSpace;

    while (cbCur < cbLen)
    {
        if (*pCurrent == _T('<') && (cbCur+1 < cbLen) && (*(pCurrent+1) == _T('/')))
        {
            // Check if found end </SCRIPT
            if( cbCur + cchEndScript < cbLen &&
                0 == _tcsnicmp(pCurrent, rgEndScript, cchEndScript))
            {
                // Check if found end </SCRIPT
                break;
            }
        }
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;
    return cbCur;
}

///////////////////////////////////////////////////////////////////////////////////
// FindEndComment()
//
// Find the end of comment ("--").
//
UINT FindEndComment(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    BOOL bEndComment = FALSE;
    int cb;

    ASSERT(*plxs & inComment); // must be in a comment now

    token.tokClass = tokComment;

    while (!bEndComment && cbCur < cbLen)
    {
        if (*pCurrent == _T('-'))  // check the character to see if it's the first "-" in "--"
        {
            pCurrent++;
            cbCur++;
            if ((cbCur < cbLen) &&
                (*pCurrent == _T('-'))) // we're possibly at the end, so search for the final "--" pair
            {
                bEndComment = TRUE;
            }
        }
        else
        {
            cb = _tclen(pCurrent);
            cbCur += cb;
            pCurrent += cb;
        }
    }
    if (cbCur < cbLen)
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;

    // reset state if we reach end of comment
    if (bEndComment)
        *plxs &= ~inComment;

    return cbCur;
}

/////////////////////////////////////////////////////////////
// FindEndEntity()
//
// Find the end of the special character sequence (ends with ; or whitespace).
//
UINT FindEndEntity(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    token.tokClass = tokEntity;
    int cb = GetTokenLength(pchLine, cbLen, cbCur);
    if (pchLine[cbCur + cb] == ';')
        cb++;
    token.ibTokMac = cbCur + cb;
    return token.ibTokMac;
}

/////////////////////////////////////////////////////////////
// Find an entity reference or non-entity ref, literal "&..."
//
UINT FindEntityRef(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    ASSERT(cbCur < cbLen);
    ASSERT(pchLine[cbCur] == '&'); // must be on ERO

    cbCur++;
    if (cbCur == cbLen)
    {
NotEntity:
        token.tokClass = tokIDENTIFIER; // plain text
        token.ibTokMac = cbCur;
        return cbCur;
    }

    if (pchLine[cbCur] == '#')
    {
        // parse and check valid number
        if (!IsNumber(pchLine, cbLen, cbCur + 1, token))
            goto NotEntity;

        // must be <= 3 digits
        if (token.ibTokMac - (cbCur + 1) > 3)
            goto NotEntity;

        // validate range
        TCHAR szNum[4];
        _tcsncpy(szNum, &pchLine[cbCur + 1], 3);
        if (_tcstoul(szNum, 0, 10) > 255)
            goto NotEntity;

        // we now have a valid numeric entity ref

        token.tokClass = tokEntity;
        cbCur = token.ibTokMac;

        // scan for end of entity ref

        // scan rest of alphanumeric token
        // REVIEW: Is this correct? IE 4.40.308 behaves this way
        while ((cbCur < cbLen) && IsCharAlphaNumeric(pchLine[cbCur]))
            cbCur++;

        // scan delimiter
        if (cbCur < cbLen)
            cbCur++;
        token.ibTokMac = cbCur;
        return cbCur;
    }
    else if (!IsCharAlpha(pchLine[cbCur]))
    {
        goto NotEntity;
    }
    else
    {
        // parse and check entity name
        UINT nLen = GetTokenLength(pchLine, cbLen, cbCur);
        if (!g_pTable->FindEntity(&pchLine[cbCur], nLen))
            goto NotEntity;

        cbCur += nLen;
        // eat delimiter if necessary
        if ((cbCur < cbLen) &&
            (pchLine[cbCur] == ';' || IsWhiteSpace(pchLine[cbCur])))
            cbCur++;
        token.tokClass = tokEntity;
        token.ibTokMac = cbCur;
        return cbCur;
    }
}


/////////////////////////////////////////////////////////////
// FindEndValue
// Find the end of an unquoted value.
//
// Scan for whitespace or end if tag
//
UINT FindValue(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT(cbCur < cbLen);

    do
    {
        cbCur++;
    } while ( cbCur < cbLen &&
        !IsWhiteSpace(pchLine[cbCur]) &&
        pchLine[cbCur] != '>' );

    token.tokClass = tokValue;
    token.ibTokMac = cbCur;

    // switch from value to attribute
    *plxs &= ~inValue;
    *plxs |= inAttribute;

    return cbCur;
}

/////////////////////////////////////////////////////////////
// FindEndString()
// Find the end of the string.
// Should only be called when we are in the string mode already.
//
UINT FindEndString (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;
    BOOL bInString = TRUE;
    TCHAR chDelim;

    ASSERT (*plxs & INSTRING); // must be in a string now

    token.tokClass = tokString;
    chDelim = (*plxs & inStringA) ? _T('\'') : _T('"');

    while (bInString && cbCur < cbLen)
    {
        if (*pCurrent == chDelim)
        {
            *plxs &= ~INSTRING;
            bInString = FALSE;
            SetValueSeen(plxs);
        }
        else if (*pCurrent == _T('<') &&
            cbCur+1 < cbLen &&
            *(pCurrent+1) == _T('%'))
        {
            *plxs |= inHTXTag;
            break;
        }
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
//
UINT FindTagOpen(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT(pchLine[cbCur] == '<');
    token.tokClass = tokTag;
    *plxs &= ~inScriptText;     // turn off script coloring when inside tags
    cbCur++;

    if (cbCur == cbLen)
    {
        *plxs |= inTag;
    }
    else
    {
#ifdef NEEDED // copied from htmed\lexer.cpp
        //
        // HTMED CHANGE:
        // REVIEW(cgomes): Figure out if I should turn off inSCRIPT in any of the
        // following cases.  Right now I only do it for the </ case.
        //
#endif //NEEDED         
        switch (pchLine[cbCur])
        {
        case '!': // MDO - Markup Declaration Open
            cbCur++;
            *plxs |= inBangTag;
            token.tok = TokTag_BANG;
            break;

        case '/': // End tag
            cbCur++;
            *plxs |= inEndTag;
            token.tok = TokTag_END;
#ifdef NEEDED // copied from htmed\lexer.cpp
            // HTMED CHANGE:
            // REVIEW(cgomes): Colorizer bug: it never removes the inSCRIPT state
            //  This removes the inSCRIPT in the case <SCRIPT <BODY>
            //  in this case <BODY is in error.
            //
            *plxs &= ~inSCRIPT;
#endif //NEEDED         
            break;

        // REVIEW: PI is SGML -- not in HTML, but might be added
        case '?': // PI - Processing Instruction
            cbCur++;
            *plxs |= inPITag;
            token.tok = TokTag_PI;
            break;

        case '%': // HTX -- ODBC server HTML extension
            cbCur++;
            *plxs |= inHTXTag;
            token.tok = TokTag_SSSOPEN;
            break;

        default: // Tag
            if (IsCharAlpha(pchLine[cbCur]))
            {
                *plxs |= inTag;
                token.tok = TokTag_START;
            }
            else
                token.tokClass = tokIDENTIFIER; // NOT a TAG
            break;
        }
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
//  FindText
//  Scan a token of text
//      NOTE DO NOT MODIFY this function, mainly b/c the side effects
//              will be hard to find, and will break the way
//              that everything works.
//
UINT FindText(LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    //BOOL fExtraSpace = FALSE;
    //int cSpace = 0;

    ASSERT (cbCur < cbLen);

    token.tokClass = tokIDENTIFIER;

    //if (pchLine[cbCur] == ' ' && !fExtraSpace)
    //  fExtraSpace = TRUE;
    cbCur += _tclen(&pchLine[cbCur]);
    while (cbCur < cbLen)
    {
        switch (pchLine[cbCur])
        {
        case _T('\0'):
        case _T('\n'):
        case _T('<'):
        case _T('&'):
            //if (cSpace > 0) // found extra spaces so remember them somewhere
            goto ret;
            break;
        //case _T(' '):
        //  if (!fExtraSpace)
        //      fExtraSpace = TRUE;
        //  else
        //      cSpace++;
        //  break;
        default:
            //if (cSpace > 0) // found extra spaces so remember them somewhere
            //cSpace = 0;
            //fExtraSpace = FALSE;
            break;
        }
        cbCur += _tclen(&pchLine[cbCur]);
    }

ret:
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
// FindNextToken()
//  Find the next token in the line
//
UINT FindNextToken(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT (cbCur < cbLen);
    HINT hint;

    if (!(*plxs & INTAG)) // scanning text
    {
        if (*plxs & TEXTMASK)
        {
            if (*plxs & inCOMMENT)
                token.tokClass = tokComment;
            else
                token.tokClass = tokIDENTIFIER;
            // probe for end tag </comment>
            UINT cbEnd = FindEndTag(pchLine, cbLen, cbCur, plxs, token);
            if (cbEnd > cbCur) // parsed a nonzero-length token
            {
                return cbEnd;
            }
            //else fall through to normal processing
        }
        hint = GetTextHint(pchLine, cbLen, cbCur, plxs, token);
        switch (hint)
        {
        case HTA:
            // begin a tag
            return FindTagOpen(pchLine, cbLen, cbCur, plxs, token);

        case HEN:
            // scan an entity reference
            token.ibTokMac = FindEntityRef(pchLine, cbLen, cbCur, plxs, token);
            return token.ibTokMac;

        case EOS:
        case ONL:
            return token.ibTokMac;

        case ERR:
        default:
            // scan text as a single token
            // If the editor uses token info for more than coloring
            //   (e.g. extended selections), then this will need to
            //   return smaller chunks.
            if (*plxs & inSCRIPT)
                *plxs |= inScriptText;
            return FindText(pchLine, cbLen, cbCur, token);
            break;
        }

        return cbCur;
    }

    ASSERT(*plxs & INTAG); // must be in a tag here

    BOOL bError = FALSE;
    hint = GetHint(pchLine, cbLen, cbCur, plxs, token);
    switch (hint)
    {
    case HTE:
        // Tag end: remove all tag state bits
        *plxs &= ~TAGMASK;
        cbCur++;
        token.tokClass = tokTag;
        token.tok = TokTag_CLOSE;
        token.ibTokMac = cbCur;
        break;

    case HNU:
#if 0  // lexing HTML instance, not a DTD!
        if (!IsNumber(pchLine, cbLen, cbCur, token))
            bError = TRUE;
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
        break;
#else
        // fall through
#endif

    case HRN: // reserved name start: #
#if 1  // lexing HTML instance, not a DTD!
        // simple nonwhitespace stream
        if (!(*plxs & inValue))
            bError = TRUE;
        FindValue(pchLine, cbLen, cbCur, plxs, token);
        if (bError)
        {
            token.tokClass = tokSpace;
            bError = FALSE; //"corrected" the error
        }
#else
        cbCur++;
        if (cbCur == cbLen)
            token.tokClass = tokOp;
        else
        {
            if (IsIdChar(pchLine[cbCur]))
            {
                cbCur++;
                while (cbCur < cbLen && IsIdChar(pchLine[cbCur]))
                    cbCur++;
                token.tokClass = tokResName;
            }
            else
                token.tokClass = tokOp;
        }
        token.ibTokMac = cbCur;
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
#endif
        break;

    case HEP: // parameter entity: %
#if 1  // lexing HTML instance, not a DTD!
        goto BadChar;
#else
        cbCur++;
        if (cbCur == cbLen)
        {
            token.tokClass = tokOp;
            token.ibTokMac = cbCur;
        }
        else
        {
            if (IsIdChar(pchLine[cbCur]))
            {
                token.ibTokMac = FindEndEntity(pchLine, cbLen, cbCur, plxs, token);
                token.tokClass = tokParEnt;
            }
            else
            {
                token.ibTokMac = cbCur;
                token.tokClass = tokOp;
            }
        }
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
#endif
        break;

    // ported HTMED change (walts) -- handle some chars as valid start char for attribute values.
    case HAV:
        {
        if (!(*plxs & inTag) || !SetValueSeen(plxs))
            goto BadChar;   // not in tag or attribute value.

        int iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
        token.ibTokMac = token.ibTokMin + iTokenLength;
        token.tokClass = tokValue;
        break;
        }
    // ported HTMED change (walts) -- handle some chars as valid start char for attribute values.

    case HKW:  // identifier
        {
            int iTokenLength = GetTokenLength(pchLine, cbLen, cbCur);
            token.ibTokMac = token.ibTokMin + iTokenLength;
            token.tokClass = tokName;
            //FUTURE: Don't scan attributes in an end tag
            if (*plxs & (inTag|inEndTag))
            {
                if (*plxs & inAttribute)
                {
                    IsAttributeName(pchLine, cbCur, iTokenLength, token);
                    // don't change attribute/value state here
                    // we only look for values after we've seen "=" in case OEQ below

                    // REVIEW(cgomes): what if more attributes follow
                    // the SPAN??
                    // if found STARTSPAN then pretend I am not in a tag
                    if(token.tok == TokAttrib_STARTSPAN)
                        *plxs &= ~(inTag | inAttribute);
                    // if found ENDSPAN then goback to comment state
                    else if(token.tok == TokAttrib_ENDSPAN)
                    {
                        *plxs &= ~(inTag | inAttribute);
                        *plxs |= inBangTag | inComment;
                    }
                }
                else if (SetValueSeen(plxs))
                {
                    // REVIEW (walts)
                    // Handle the client side script language detection here for the
                    // following case (language attribute value is NOT wrapped by quotes.)
                    // <SCRIPT LANGUAGE=VBScript>
                    if (*plxs & inSCRIPT)
                    {
                        SetScriptLanguage(&pchLine[cbCur], plxs);
                    }

                    //
                    // REVIEW(cgomes): It seems that any non-white space character
                    //      is valid for non-quoted attribute values.
                    //      Problem is that GetTokenLength is used to determine
                    //      the token length, which works great non-values,
                    //      but pulls egss for values.
                    //      I use GetValueTokenLength here to get the length
                    //      of value token.  GetValueTokenLength will not
                    //      stop till it hits a white space character.
                    //

                    iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
                    token.ibTokMac = token.ibTokMin + iTokenLength;
                    token.tokClass = tokName;

                    token.tokClass = tokValue;
                }
                else
                {
                    IsElementName(pchLine, cbCur, iTokenLength, token);
                    // look for attributes
                    *plxs |= inAttribute;
                    // set content state
                    if (*plxs & inTag)
                        *plxs |= TextStateFromElement(&pchLine[token.ibTokMin], iTokenLength);
                    else if ((*plxs & inEndTag) && (*plxs & TEXTMASK))
                        *plxs &= ~TextStateFromElement(&pchLine[token.ibTokMin], iTokenLength);
                    else if ((*plxs & inEndTag) && (*plxs & inSCRIPT))
                        *plxs &= ~(inSCRIPT | inScriptText | inServerASP/* | inVBScript | inJavaScript*/);
                }
            }
            else if (*plxs & inBangTag)
            {
                // FUTURE: other <!...> items like "HTML", "PUBLIC"? -- nice for DTDs
                //   Use a RW table for it if we do

                // recognize <!DOCTYPE ...>  as 'element'
                if ((iTokenLength == 7) &&
                    (0 == _tcsnicmp(&pchLine[cbCur], _T("doctype"), 7)))
                    token.tokClass = tokElem;
            }
            break;
        }

    case HST:  // string "..."
        *plxs |= inString;
        goto String;

    case HSL:  // string alternate '...'
        *plxs |= inStringA;
String:
        cbCur++;
        token.ibTokMac = FindEndString(pchLine, cbLen, cbCur, plxs, token);
        SetValueSeen(plxs);
        // Handle the client side script language detection here for the
        // following case (language attribute value is wrapped by quotes.)
        // <SCRIPT LANGUAGE="VBScript">
        if((*plxs & inSCRIPT) && (*plxs & inAttribute))
        {
            SetScriptLanguage(&pchLine[cbCur], plxs);
        }
        break;

    case HWS: // tag whitespace
        do
        {
            cbCur++;
        } while (cbCur < cbLen && IsWhiteSpace(pchLine[cbCur]));
        token.tokClass = tokSpace;
        token.ibTokMac = cbCur;
        break;

    case OEQ:
        // GetHint has set token info
        if (*plxs & inAttribute)
        {
            // start looking for values
            *plxs &= ~inAttribute;
            *plxs |= inValue;
        }
        else
            goto BadChar;
        break;

    case HTA:
        if (cbCur+1 < cbLen && '%' == pchLine[cbCur+1])
        {
            SetValueSeen(plxs);
            return FindTagOpen(pchLine, cbLen, cbCur, plxs, token);
        }
        // else fall through
    case ERR:
    case HEN:
BadChar:
        token.tokClass = tokSpace;

        // DS96# 10116 [CFlaat]: we can be in DBCS here, and so we need
        //     to make sure that our increment is double-byte aware
        cbCur += _tcsnbcnt(pchLine + cbCur, 1); // byte count for current char
        ASSERT(cbCur <= cbLen);
        token.ibTokMac = cbCur;
        break;

    // ported HTMED CHANGE (walts) - added this case to handle dbcs attribute values.
    case HDB:
        {
        // DBCS char.  Handle for attribute values within tag.
        if (!SetValueSeen(plxs))
            goto BadChar;

        int iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
        token.ibTokMac = token.ibTokMin + iTokenLength;
        token.tokClass = tokValue;
        }
        break;
    // ported HTMED CHANGE END

    default:
        // GetHint has set token info
        if (token.tokClass != tokComment && (*plxs & inValue))
            FindValue(pchLine, cbLen, cbCur, plxs, token);
        break;
    }
    if (bError)
        IsUnknownID(pchLine, cbLen, cbCur, token);
    return token.ibTokMac;
}

////////////////////////////////////////////////////////////////////
// GetTextHint()
// Like GetHint when scanning text -- look only for tags and entities
//
HINT GetTextHint(LPCTSTR pchLine, UINT /*cbLen*/, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    // if the character is bigger than 128 (dbcs) then return error
    if (pchLine[cbCur] & ~0x7F)
        return HDB;

    HINT hint = g_hintTable[pchLine[cbCur]];

    if (IsSingleOp(hint))
    {
        hint = ERR;
    }
    else if (hint == ONL || hint == EOS)
    {
        token.tokClass = tokOp;
        token.ibTokMac = cbCur + 1;
    }
    return hint;
}

////////////////////////////////////////////////////////////////////
// GetHint()
//      Use hint table to guess what the next token going to be
//      If it is a single operator, it will fill in the token info
//      as well
//
HINT GetHint(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    // if the character is bigger than 128 (dbcs) then return error
    if (pchLine[cbCur] & ~0x7F)
        return HDB;

    HINT hint = g_hintTable[pchLine[cbCur]];

    // check if it is a single op, new line or end of stream
    if (IsSingleOp(hint) || hint == ONL || hint == EOS)
    {
        token.tokClass = hint;
        token.ibTokMac = cbCur + 1;
    }
    else if (hint == ODA)
    {
        if ((cbCur + 1 < cbLen) &&
            (g_hintTable[pchLine[cbCur + 1]] == ODA) &&
            (*plxs & inBangTag))
        {
            cbCur += 2;
            *plxs |= inComment;
            COMMENTTYPE ct = IfHackComment(pchLine, cbLen, cbCur, plxs, token);
            if (ct == 0)
            {
                token.tokClass = tokComment;
                token.ibTokMac = cbCur;
            }
            else if(ct == CT_METADATA)
                hint = HTA; // tag open
        }
        else
        {
            // single -
            token.tokClass = tokOp;
            token.ibTokMac = cbCur + 1;
        }
    }
    return hint;
}

///////////////////////////////////////////////////////////////////
// GetTokenLength ()
//  return the length of a token identifier/keyword
//
UINT GetTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    UINT cb;
    UINT cbOld = cbCur;

    if (IsCharAlphaNumeric(*pCurrent))
    {
        while (cbCur < cbLen && IsIdChar(*pCurrent))
        {
            cb = _tclen(pCurrent);
            cbCur += cb;
            pCurrent += cb;
        }
    }
    return (int) max((cbCur - cbOld), 1);
}

/*

    UINT GetValueTokenLength

    Description:
        Gets the length of the token.
        This version will accept any non whitespace character
        in the token.

*/
UINT GetValueTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    UINT cb;
    UINT cbOld = cbCur;

    while (cbCur < cbLen && !_istspace(*pCurrent) && IsValueChar(*pCurrent))
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }
    return (int) max((cbCur - cbOld), 1);
}


////////////////////////////////////////////////////////////////
// IsElementName ()
//  lookup the keyword table to determine if it is a keyword or not
//
BOOL IsElementName(LPCTSTR pchLine, UINT cbCur, int iTokenLength, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int iFound = NOT_FOUND;

    if (NOT_FOUND != (iFound = g_pTable->FindElement(pCurrent, iTokenLength)))
    {
        token.tokClass = tokElem;
        token.ibTokMac = cbCur + iTokenLength;
        token.tok = iFound; // set token
    }
    return (iFound != NOT_FOUND);
}

int IndexFromElementName(LPCTSTR pszName)
{
    return g_pTable->FindElement(pszName, lstrlen(pszName));
}

////////////////////////////////////////////////////////////////
// IsAttributeName ()
// lookup the keyword table to determine if it is a keyword or not
//
BOOL IsAttributeName(LPCTSTR pchLine, UINT cbCur, int iTokenLength, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int iFound = NOT_FOUND;

    if (NOT_FOUND != (iFound = g_pTable->FindAttribute(pCurrent, iTokenLength)))
    {
        token.tokClass = tokAttr;
        // ENDSPAN__ is needed b/c the lexer does not recognize the
        // endspan-- as 2 seperate tokens.
        if(iFound == TokAttrib_ENDSPAN__)
        {
            // endspan-- found.  return TokAttrib_ENDSPAN
            // set ibTokMac to not include --.
            token.tok = TokAttrib_ENDSPAN;
            token.ibTokMac = cbCur + iTokenLength - 2;
        }
        else
        {
            token.ibTokMac = cbCur + iTokenLength;
            token.tok =  iFound; // set token
        }
    }
    return (iFound != NOT_FOUND);
}

//////////////////////////////////////////////////////////////////////////
// IsIdentifier()
// check if it is an identifier
//
BOOL IsIdentifier (int iTokenLength, TXTB & token)
{
    if (iTokenLength > 0)
    {
        token.tokClass = tokName;
        token.ibTokMac = token.ibTokMin + iTokenLength;
        return TRUE;
    }
    else
        return FALSE;
}

////////////////////////////////////////////////////////////////////
// IsUnknownID ()
//  Mark the next token as an ID
//
BOOL IsUnknownID (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    ASSERT(cbCur < cbLen);
    UINT cb;
    LPCTSTR pCurrent = &pchLine[cbCur];

    cb = _tclen(pCurrent);
    cbCur += cb;
    pCurrent += cb;

    while ((cbCur < cbLen) && IsIdChar(*pCurrent))
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.tokClass = tokSpace;
    token.ibTokMac = cbCur;
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// IsNumber()
//  Check whether the next token is an SGML NUMTOKEN
//
BOOL IsNumber(LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    if (cbCur >= cbLen)
        return FALSE;

    if (!_istdigit(pchLine[cbCur]))
        return FALSE;

    token.tokClass = tokNum;

    // assume all digits are one byte
    ASSERT(1 == _tclen(&pchLine[cbCur]));
    cbCur++;

    while (cbCur < cbLen && _istdigit(pchLine[cbCur]))
    {
        // assume all digits are one byte
        ASSERT(1 == _tclen(&pchLine[cbCur]));
        cbCur++;
    }

    token.ibTokMac = cbCur;
    return TRUE;
}



/* end of file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\privcid.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __privcid_h__
#define __privcid_h__


#include <mshtmcid.h>

//----------------------------------------------------------------------------
//
// Private Command IDs.
//
//----------------------------------------------------------------------------

#define IDM_TABKEY                  6000
#define IDM_SHTABKEY                6001
#define IDM_RETURNKEY               6002
#define IDM_ESCKEY                  6003

#if DBG == 1
#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#endif

// IE4 Shdocvw Messages

#define IDM_SHDV_FINALTITLEAVAIL         6020
#define IDM_SHDV_MIMECSETMENUOPEN        6021
#define IDM_SHDV_PRINTFRAME              6022
#define IDM_SHDV_PUTOFFLINE              6022
#define IDM_SHDV_GOBACK                  6024   // different from IDM_GOBACK
#define IDM_SHDV_GOFORWARD               6025   // different from ISM_GOFORWARD
#define IDM_SHDV_CANGOBACK               6026
#define IDM_SHDV_CANGOFORWARD            6027
#define IDM_SHDV_CANSUPPORTPICS          6028
#define IDM_SHDV_CANDEACTIVATENOW        6029
#define IDM_SHDV_DEACTIVATEMENOW         6030
#define IDM_SHDV_NODEACTIVATENOW         6031
#define IDM_SHDV_SETPENDINGURL           6032
#define IDM_SHDV_ISDRAGSOURCE            6033
#define IDM_SHDV_DOCFAMILYCHARSET        6034
#define IDM_SHDV_DOCCHARSET              6035
#define IDM_SHDV_GETMIMECSETMENU         6036
#define IDM_SHDV_GETFRAMEZONE            6037

// Flavors of refresh

#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

#define IDM_DEFAULTBLOCK                 6046

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// Used by triedit.rc
//
#define IDS_PROJNAME                    100
#define IDR_TRIEDITDOCUMENT             101
#define IDR_FEEDBACKRECTBMP             102
#define IDS_HTML                        101
#define IDS_IEXP3                       103
#define IDR_HTML                        104
#define IDS_RFC1866                     105
#define IDR_ASP                         106
#define IDR_HTMPARSE                    107
#define IDR_TRIEDITPARSE                107

#define IDS_GLYPHTABLE1                 201
#define IDS_GLYPHTABLE2                 202
#define IDS_GLYPHTABLE3                 203
#define IDS_GLYPHTABLE4                 204
#define IDS_GLYPHTABLE5                 205
#define IDS_GLYPHTABLE6                 206
#define IDS_GLYPHTABLE7                 207
#define IDS_GLYPHTABLE8                 208
#define IDS_GLYPHTABLE9                 209
#define IDS_GLYPHTABLE10                210
#define IDS_GLYPHTABLE11                211
#define IDS_GLYPHTABLE12                212
#define IDS_GLYPHTABLE13                213
#define IDS_GLYPHTABLE14                214
#define IDS_GLYPHTABLE15                215
#define IDS_GLYPHTABLE16                216
#define IDS_GLYPHTABLE17                217
#define IDS_GLYPHTABLE18                218
#define IDS_GLYPHTABLE19                219
#define IDS_GLYPHTABLE20                220
#define IDS_GLYPHTABLE21                221
#define IDS_GLYPHTABLE22                222
#define IDS_GLYPHTABLE23                223
#define IDS_GLYPHTABLE24                224

#define IDS_GLYPHTABLESTART             IDS_GLYPHTABLE1
#define IDS_GLYPHTABLEFORMEND           IDS_GLYPHTABLE2
#define IDS_GLYPHTABLEEND               IDS_GLYPHTABLE24

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED_)
#define AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_STATIC_REGISTRY

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#pragma warning(disable: 4505)	// unreferenced local function has been removed

#include <windows.h>

// Note that this include MUST be at this location (after the above include)
#include "win95wrp.h"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma warning(disable: 4100 4189 4244)	// Necessary for ia64 build
#include <atlcom.h>
#include <atlwin.h>
#pragma warning(default: 4100 4189 4244)	// Necessary for ia64 build

#include <mshtml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\table.h ===
// HTML lexer tables
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __HLTABLE_H__
#define __HLTABLE_H__

#include "lexhtml.h"

#ifndef PURE
#define PURE =0
#endif

// These values must match the number of built-in tables (CV_FIXED), 
// and the capacity of the inVariant bits of the lex state (CV_MAX).
const UINT CV_FIXED =  4; // Count Variants in Fixed tables
const UINT CV_MAX   = 16; // Count variants maximum total

// Macro for determining number of elements in an array
#define CELEM_ARRAY(a)  (sizeof(a) / sizeof(a[0]))

// length-limited string compare function pointer (e.g. strncmp/strnicmp)

typedef  int (_cdecl* PFNNCMP)(LPCTSTR, LPCTSTR, size_t);

#define CASE (TRUE)
#define NOCASE (FALSE)

#define NOT_FOUND (-1)

////////////////////////////////////////////////////////////////////////////

// return A-Z[a-z] index if alpha, else -1
inline int PeekIndex(TCHAR c, BOOL bCase /*= NOCASE*/)
{
	if ((c >= _T('A')) && (c <= _T('Z')))
		return c - _T('A');
	else if ((c >= _T('a')) && (c <= _T('z')))
		return c - _T('a') + (bCase ? 26 : 0);
	else
		return -1;
}

// static table lookups
int LookupLinearKeyword(ReservedWord *rwTable, int cel, RWATT_T att, LPCTSTR pchLine, int cbLen, BOOL bCase = NOCASE);
int LookupIndexedKeyword(ReservedWord *rwTable, int cel, int * indexTable, RWATT_T att, LPCTSTR pchLine, int cbLen, BOOL bCase = NOCASE);

// content model
// Map between element / lex state
//
struct ELLEX {
	LPCTSTR sz;
	int     cb;
	DWORD   lxs;
};

DWORD TextStateFromElement(LPCTSTR szEl, int cb);
ELLEX * pellexFromTextState(DWORD state);
inline LPCTSTR ElementFromTextState(DWORD state)
{
	ELLEX *pellex = pellexFromTextState(state);
	return pellex ? pellex->sz : 0;
}

#ifdef _DEBUG
int CheckWordTable(ReservedWord *arw, int cel, LPCTSTR szName = NULL);
int CheckWordTableIndex(ReservedWord *arw, int cel, int *ai, BOOL bCase = FALSE, LPCTSTR szName = NULL);
int MakeIndexHere(ReservedWord *arw, int cel, int *ab, BOOL bCase = FALSE, LPCTSTR szName = NULL);
#endif

int MakeIndex(ReservedWord *arw, int cel, int **pab, BOOL bCase = FALSE, LPCTSTR szName = NULL);

////////////////////////////////////////////////////////////////////////////

// test for SGML identifier character:
// alphanumeric or '-' or '.'
inline BOOL IsIdChar(TCHAR ch)
{
	return IsCharAlphaNumeric(ch) || ch == _T('-') || ch == _T('.') || ch == _T(':');
}

////////////////////////////////////////////////////////////////////////////
// Abstract Base Classes
//
class CTable
{
public:
	virtual ~CTable() {}
	virtual int Find(LPCTSTR pch, int cb) PURE;
};

class CTableSet
{
public:
	virtual ~CTableSet() {}
	virtual int FindElement(LPCTSTR pch, int cb) PURE;
	virtual int FindAttribute(LPCTSTR pch, int cb) PURE;
	virtual int FindEntity(LPCTSTR pch, int cb) PURE;
	const TCHAR* Name() const { return m_strName; }

protected:
	TCHAR m_strName[1024];

};

typedef CTable *PTABLE;
typedef CTableSet * PTABLESET;
typedef const CTableSet * PCTABLESET;

// static, built-in table
class CStaticTable : public CTable
{
public:
	CStaticTable(
		RWATT_T att,
		ReservedWord *prgrw, UINT cel, 
		int *prgi = NULL, 
		BOOL bCase = FALSE,
		LPCTSTR szName = NULL);
	virtual ~CStaticTable() {} // nothing to delete
	BOOL Find(LPCTSTR pch, int cb);
private:
	ReservedWord *m_prgrw; // reserved word table
	UINT m_cel;            // element count (size)
	int *m_prgi;           // index table
	BOOL m_bCase;          // case sensitive?
	RWATT_T m_att;         // attribute mask for table lookup
};

class CStaticTableSet : public CTableSet
{
public:
	CStaticTableSet(RWATT_T att, UINT nIdName);
	virtual ~CStaticTableSet() {}
	int FindElement(LPCTSTR pch, int cb);
	int FindAttribute(LPCTSTR pch, int cb);
	int FindEntity(LPCTSTR pch, int cb);
private:
	CStaticTable m_Elements;
	CStaticTable m_Attributes;
	CStaticTable m_Entities;
};

////////////////////////////////////////////////////////////////////////////
// CLStr
// A very simple length-and-buffer string representation
// with just enough functionality for our purpose.
class CLStr
{
public:
	CLStr() : m_cb(0), m_rgb(0) {}
	CLStr(const BYTE * rgb, DWORD cb) : m_rgb(rgb), m_cb(cb) {}
	BOOL Compare(const BYTE * rgb, DWORD cb, BOOL bCase)
	{
		int r;
		if (bCase)
			r = memcmp(rgb, m_rgb, __min(m_cb, cb));
		else
			r = _memicmp(rgb, m_rgb, __min(m_cb, cb));
		return (0 == r) ? (cb - m_cb) : r;
	}
	// data
	DWORD m_cb;
	const BYTE * m_rgb;
};
typedef CLStr * PLSTR;
typedef const CLStr * PCLSTR;
typedef const CLStr & RCLSTR;

extern CStaticTableSet * g_pTabDefault;
extern PTABLESET g_pTable;
extern HINT g_hintTable[];

#endif // __HLTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\token.h ===
/* Copied from ..\htmed\itoken.h and changed name from ITokenizer to ITokGen 
and itoken.h to token.h just to avoid name confusion in future. */

/*

    File: Token.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
		ITokenizer interface and its types

*/
#if !defined __INC_TOKEN_H__
#define __INC_TOKEN_H__

typedef int TOKEN;
// A text token block indicates the token, and its starting and ending
// indexes in the line of source just lexed.
// Note that for any N > 0, rgtxtb[N].ibTokMin >= rgtxtb[N-1].ibTokMac.
// if it is such that rgtxtb[N].ibTokMin > rgtxtb[N-1].ibTokMac, then
// the intervening unclassified characters are treated as white space tokens.

typedef struct _tagTXTB { // Text token class block
	TOKEN   tok;
	TOKEN   tokClass;
	UINT    ibTokMin;               // token length given by ibTokMac - ibTokMin
	UINT    ibTokMac;               // given in bytes
} TXTB;

// ********* defines specific to TRIEDIT begin here


enum ObjectTypes
    {	
    OT_NONE	= 0,
	OT_ACTIVEXCONTROL	= 0x1,
	OT_DESIGNTIMECONTROL	= 0x2,
	OT_INPUT	= 0x4,
	OT_TABLE	= 0x8,
	OT_APPLET	= 0x10,
	OT_INVISIBLE	= 0x8000,
	OT_VISIBLEITEMS	= 0x4fff,
	OT_ALLITEMS	= 0xffff
    };

enum ParserStates
{
	PS_HTML,
	PS_SIMPLETAG,		// simple tag that cannot have </ nested within it
	PS_OBJECT,
	PS_METADATASTART,
	PS_METADATABODY,
	PS_METADATAEND

};

enum ObjectParserStates
{
	OPS_NONE,
	OPS_CLASSID
};

enum TagStates
{
	TS_NONE,	  	// in tag, looking for the end tag
	TS_FOUNDTAGCLOSE, // found > closing the start element
	TS_FOUNDTAGEND	// found </ next token should be end tag token
};

enum DesignControlStates
{
	DTCS_NONE, 		// just found METADATA
	DTCS_TYPE,		// found TYPE attribute
	DTCS_DTCTYPE,	// found DesignerControl attribute value
	DTCS_ENDSPAN 	// found endspan
};
enum FilterMode
{ modeNone, modeInput, modeOutput };

#define cbHeader 0x8000	// initial buffer size to save all contents before/after <BODY> tag
#define MAX_BLOCKS 20 // max # of blocks that hold the replaced data 
#define MAX_TOKIDLEN 32 // max length of a token identifier


struct TOKSTRUCT // holds elements of token array generated  from the document
{
	TXTB token;
	BOOL fStart;
	UINT ichStart;
	UINT iNextprev;
	UINT iNextPrevAlternate;
	INT tagID;
};

struct TOKSTACK
{
	UINT iMatch;
	INT tagID;
	UINT ichStart; // start char position of this token in the input buffer
	TXTB token; // used in special cases (<%, %>) where tagID is -1
};


// ********* defines specific to TRIEDIT end here
interface ITokenGen : public IUnknown
{
public:
	// Gets then next token given the text
	//	pszText:	stream of text - UNICODE only!!!!
	//	cbText:		count of bytes in pszText
	//	pcbCur:		current byte position in pszText.
	//				set to 0 for start of pszText
	//	pLXS:		should be 0, on initial call
	//	pToken:		TXTB structure which contains the token info
	//	returns:
	//			NOERROR if found the next token
	//			S_FALSE if no more tokens
	//			error if there was an error
	//
	virtual HRESULT STDMETHODCALLTYPE NextToken(
		/*	[in]	  */ LPCWSTR pszText,
		/*	[in]	  */ UINT	 cbText,
		/*	[in, out] */ UINT	*pcbCur,
		/*	[in, out] */ DWORD *pLXS,
		/*	[out]	  */ TXTB	*pToken) = 0;


	// Tokenizes & Parses the input buffer
	//	hOld:	source buffer
	//	phNew or pStmNew: filtered buffer (based on dwFlagsUsePstmNew)
	//	pStmNew
	//	dwFlags:filter flags
	//	mode:	input/output mode.
	//	cbSizeIn: size of input buffer in bytes (if -1, assume NULL terminated buffer)
	//	*pcbSizeOut:size of output buffer in bytes
	//	pUnkTrident:trident's IUnknown
	//	phgTokArray:Token Array (freed by the caller)
	//	pcMaxToken:number of tokens in phgTokArray
	//	phgDocRestore:stores document contents which are used for filtering
	//	bstrBaseURL:used to convert URLs on a page into Relative URL (can be NULL)
	//	dwReserved - must be 0 (added for future use)
	//	returns:
	//		S_OK if no errors
	//		E_OUTOFMEMORY if any allocation failed
	//		E_FILTERFRAMESET or E_FILTERSERVERSCRIPT for html files that cannot be filtered

	virtual HRESULT STDMETHODCALLTYPE hrTokenizeAndParse(
		/*	[in]	*/ HGLOBAL hOld,
		/*	[out]	*/ HGLOBAL *phNew,
		/*	[in/out]*/ IStream *pStmNew,
		/*	[in]	*/ DWORD dwFlags,
		/*	[in]	*/ FilterMode mode,
		/*	[in]	*/ int cbSizeIn,
		/*	[out]	*/ UINT* pcbSizeOut,
		/*	[in]	*/ IUnknown *pUnkTrident,
		/*	[out]	*/ HGLOBAL *phgTokArray,
		/*	[out]	*/ UINT *pcMaxToken,
		/*	[in/out]*/ HGLOBAL *phgDocRestore,
		/*  [in]    */ BSTR bstrBaseURL,
		/*	[in]	*/ DWORD dwReserved) = 0;

};

enum TOKCLS { // token classes
	tokclsError = 0,

	// all standard language keywords
	tokclsKeyWordMin = 1,

	// for block start/end that are keywords instead of operators...like
	// Pascal or BASIC for instance.
	tokclsKeyWordOpenBlock = 0xfe,
	tokclsKeyWordCloseBlock = 0xff,

	tokclsKeyWordMax = 0x100,

	// all language operators
	tokclsOpMin = 0x100,
	tokclsOpSpecOpenBlock = 0x1fe,
	tokclsOpSpecCloseBlock = 0x1ff,
	tokclsOpMax = 0x200,

	// special, hard coded operators that editor keys off of
	tokclsOpSpecMin = 0x200,
	tokclsOpSpecEOL = 0x200,
	tokclsOpSpecLineCmt = 0x201, // automatic skip to eol on this one
	tokclsOpSpecEOS = 0x202,
	tokclsOpSpecMax = 0x210,

	// all identifiers, give ~500 possibilities
	tokclsIdentMin = 0x210,
	tokclsIdentUser = 0x211,        // special idents (user keywords)
	tokclsIdentMax = 0x400,

	// all constants (numeric and string)
	tokclsConstMin = 0x400,
	tokclsConstInteger = 0x400,
	tokclsConstReal = 0x401,
	tokclsConstString = 0x402,
	tokclsStringPart = 0x402,               // partial string ("....)
	tokclsConstMax = 0x410,

	// comments
	tokclsCommentMin = 0x500,
	tokclsCommentPart = 0x500,      // partial comment (/* ...)
	tokclsCommentMax = 0x510,

	// language dependent token class(es) start at 0x800 to 0xfff
	tokclsUserMin = 0x800,
	tokclsUserLast = 0xfff,
	tokclsUserMax = 0x1000,

	// mask to ignore all the bits in a token[class] that the lexer can use
	// for private status.  they will be masked off and ignored by clients
	// of the lexer.  A good use of this feature is to encode the real token
	// type in the lexer private portion (area is ~tokclsMask) when including
	// meta-token types (such as MFC/Wizard user token types) so that other
	// clients of the lexer can keep that information.
	tokclsUserMask = ~(tokclsUserMin - 1),
	tokclsMask = tokclsUserLast,

};


// NOTE:
// ========================================================================
// PLEASE LET sridharc KNOW IF YOU PLAN TO ADD/REMOVE A TOKEN FROM
// THE BELOW ENUM, SINCE HE IS DEPENDING UPON THIS ORDER FOR HIS TAG PROPERTY
// EDITING.  THANKS.
// ========================================================================
typedef enum tagElementTokens
{
	TokElem_Empty            = 0  	,  /* Empty    		*/
	TokElem_A				 = 1	,  /* A				*/
	TokElem_ADDRESS			 = 2	,  /* ADDRESS		*/
	TokElem_APPLET			 = 3	,  /* APPLET		*/
	TokElem_AREA			 = 4	,  /* AREA			*/
	TokElem_B				 = 5	,  /* B				*/
	TokElem_BASE			 = 6	,  /* BASE			*/
	TokElem_BASEFONT		 = 7	,  /* BASEFONT		*/
	TokElem_BGSOUND			 = 8	,  /* BGSOUND		*/
	TokElem_BIG				 = 9	,  /* BIG			*/
	TokElem_BLINK			 = 10	,  /* BLINK			*/
	TokElem_BLOCKQUOTE		 = 11	,  /* BLOCKQUOTE	*/
	TokElem_BODY			 = 12	,  /* BODY			*/
	TokElem_BR				 = 13	,  /* BR			*/
	TokElem_BUTTON			 = 14	,  /* BUTTON		*/
	TokElem_CAPTION			 = 15	,  /* CAPTION		*/
	TokElem_CENTER			 = 16	,  /* CENTER		*/
	TokElem_CITE			 = 17	,  /* CITE			*/
	TokElem_CODE			 = 18	,  /* CODE			*/
	TokElem_COL				 = 19	,  /* COL			*/
	TokElem_COLGROUP		 = 20	,  /* COLGROUP		*/
	TokElem_COMMENT			 = 21	,  /* COMMENT		*/
	TokElem_DD				 = 22	,  /* DD			*/
	TokElem_DFN				 = 23	,  /* DFN			*/
	TokElem_DIR				 = 24	,  /* DIR			*/
	TokElem_DIV				 = 25	,  /* DIV			*/
	TokElem_DL				 = 26	,  /* DL			*/
	TokElem_DT				 = 27	,  /* DT			*/
	TokElem_EM				 = 28	,  /* EM			*/
	TokElem_EMBED			 = 29	,  /* EMBED			*/
	TokElem_FIELDSET		 = 30	,  /* FIELDSET		*/
	TokElem_FONT			 = 31	,  /* FONT			*/
	TokElem_FORM			 = 32	,  /* FORM			*/
	TokElem_FRAME			 = 33	,  /* FRAME			*/
	TokElem_FRAMESET		 = 34	,  /* FRAMESET		*/
	TokElem_H1				 = 35	,  /* H1			*/
	TokElem_H2				 = 36	,  /* H2			*/
	TokElem_H3				 = 37	,  /* H3			*/
	TokElem_H4				 = 38	,  /* H4			*/
	TokElem_H5				 = 39	,  /* H5			*/
	TokElem_H6				 = 40	,  /* H6			*/
	TokElem_HEAD			 = 41	,  /* HEAD			*/
	TokElem_HR				 = 42	,  /* HR			*/
	TokElem_HTML			 = 43	,  /* HTML			*/
	TokElem_I				 = 44	,  /* I				*/
	TokElem_IFRAME			 = 45	,  /* IFRAME		*/
	TokElem_IMG				 = 46	,  /* IMG			*/
	TokElem_INPUT			 = 47	,  /* INPUT			*/
	TokElem_ISINDEX			 = 48	,  /* ISINDEX		*/
	TokElem_KBD				 = 49	,  /* KBD			*/
	TokElem_LABEL			 = 50	,  /* LABEL			*/
	TokElem_LEGEND			 = 51	,  /* LEGEND		*/
	TokElem_LI				 = 52	,  /* LI			*/
	TokElem_LINK			 = 53	,  /* LINK			*/
	TokElem_LISTING			 = 54	,  /* LISTING		*/
	TokElem_MAP				 = 55	,  /* MAP			*/
	TokElem_MARQUEE			 = 56	,  /* MARQUEE		*/
	TokElem_MENU			 = 57	,  /* MENU			*/
	TokElem_META			 = 58	,  /* META			*/
	TokElem_METADATA		 = 59	,  /* METADATA		*/
	TokElem_NOBR			 = 60	,  /* NOBR			*/
	TokElem_NOFRAMES		 = 61	,  /* NOFRAMES		*/
	TokElem_NOSCRIPT		 = 62	,  /* NOSCRIPT		*/
	TokElem_OBJECT			 = 63	,  /* OBJECT		*/
	TokElem_OL				 = 64	,  /* OL			*/
	TokElem_OPTION			 = 65	,  /* OPTION		*/
	TokElem_P				 = 66	,  /* P				*/
	TokElem_PARAM			 = 67	,  /* PARAM			*/
	TokElem_PLAINTEXT		 = 68	,  /* PLAINTEXT		*/
	TokElem_PRE				 = 69	,  /* PRE			*/
	TokElem_S				 = 70	,  /* S				*/
	TokElem_SAMP			 = 71	,  /* SAMP			*/
	TokElem_SCRIPT			 = 72	,  /* SCRIPT		*/
	TokElem_SELECT			 = 73	,  /* SELECT		*/
	TokElem_SMALL			 = 74	,  /* SMALL			*/
	TokElem_SPAN			 = 75	,  /* SPAN			*/
	TokElem_STRIKE			 = 76	,  /* STRIKE		*/
	TokElem_STRONG			 = 77	,  /* STRONG		*/
	TokElem_STYLE			 = 78	,  /* STYLE			*/
	TokElem_SUB				 = 79	,  /* SUB			*/
	TokElem_SUP				 = 80	,  /* SUP			*/
	TokElem_TABLE			 = 81	,  /* TABLE			*/
	TokElem_TBODY			 = 82	,  /* TBODY			*/
	TokElem_TD				 = 83	,  /* TD			*/
	TokElem_TEXTAREA		 = 84	,  /* TEXTAREA		*/
	TokElem_TFOOT			 = 85	,  /* TFOOT			*/
	TokElem_TH				 = 86	,  /* TH			*/
	TokElem_THEAD			 = 87	,  /* THEAD			*/
	TokElem_TITLE			 = 88	,  /* TITLE			*/
	TokElem_TR				 = 89	,  /* TR			*/
	TokElem_TT				 = 90	,  /* TT			*/
	TokElem_U				 = 91	,  /* U				*/
	TokElem_UL				 = 92	,  /* UL			*/
	TokElem_VAR				 = 93	,  /* VAR			*/
	TokElem_WBR				 = 94	,  /* WBR			*/
	TokElem_XMP				 = 95	  /* XMP			*/
} ElementTokens;
// NOTE:
// ========================================================================
// PLEASE LET sridharc KNOW IF YOU PLAN TO ADD/REMOVE A TOKEN FROM
// THE ABOVE ENUM, SINCE HE IS DEPENDING UPON THIS ORDER FOR HIS TAG PROPERTY
// ========================================================================

typedef enum tagAttributeTokens
{
	TokAttrib_Empty                         =0  ,   /*                      */
	TokAttrib_ACCESSKEY						=1    	,// ACCESSKEY
	TokAttrib_ACTION						=2    	,// ACTION
	TokAttrib_ALIGN							=3    	,// ALIGN
	TokAttrib_ALINK							=4    	,// ALINK
	TokAttrib_ALT							=5    	,// ALT
	TokAttrib_APPNAME						=6    	,// APPNAME
	TokAttrib_APPVERSION					=7    	,// APPVERSION
	TokAttrib_BACKGROUND					=8    	,// BACKGROUND
	TokAttrib_BACKGROUNDATTACHMENT			=9    	,// BACKGROUNDATTACHMENT
	TokAttrib_BACKGROUNDCOLOR				=10   	,// BACKGROUNDCOLOR
	TokAttrib_BACKGROUNDIMAGE				=11   	,// BACKGROUNDIMAGE
	TokAttrib_BACKGROUNDPOSITION			=12   	,// BACKGROUNDPOSITION
	TokAttrib_BACKGROUNDPOSITIONX			=13   	,// BACKGROUNDPOSITIONX
	TokAttrib_BACKGROUNDPOSITIONY			=14   	,// BACKGROUNDPOSITIONY
	TokAttrib_BACKGROUNDREPEAT				=15   	,// BACKGROUNDREPEAT
	TokAttrib_BALANCE						=16   	,// BALANCE
	TokAttrib_BEHAVIOR						=17   	,// BEHAVIOR
	TokAttrib_BGCOLOR						=18   	,// BGCOLOR
	TokAttrib_BGPROPERTIES					=19   	,// BGPROPERTIES
	TokAttrib_BORDER						=20   	,// BORDER
	TokAttrib_BORDERBOTTOM					=21   	,// BORDERBOTTOM
	TokAttrib_BORDERBOTTOMCOLOR				=22   	,// BORDERBOTTOMCOLOR
	TokAttrib_BORDERBOTTOMSTYLE				=23   	,// BORDERBOTTOMSTYLE
	TokAttrib_BORDERBOTTOMWIDTH				=24   	,// BORDERBOTTOMWIDTH
	TokAttrib_BORDERCOLOR					=25   	,// BORDERCOLOR
	TokAttrib_BORDERCOLORDARK				=26   	,// BORDERCOLORDARK
	TokAttrib_BORDERCOLORLIGHT				=27   	,// BORDERCOLORLIGHT
	TokAttrib_BORDERLEFT					=28   	,// BORDERLEFT
	TokAttrib_BORDERLEFTCOLOR				=29   	,// BORDERLEFTCOLOR
	TokAttrib_BORDERLEFTSTYLE				=30   	,// BORDERLEFTSTYLE
	TokAttrib_BORDERLEFTWIDTH				=31   	,// BORDERLEFTWIDTH
	TokAttrib_BORDERRIGHT					=32   	,// BORDERRIGHT
	TokAttrib_BORDERRIGHTCOLOR				=33   	,// BORDERRIGHTCOLOR
	TokAttrib_BORDERRIGHTSTYLE				=34   	,// BORDERRIGHTSTYLE
	TokAttrib_BORDERRIGHTWIDTH				=35   	,// BORDERRIGHTWIDTH
	TokAttrib_BORDERSTYLE					=36   	,// BORDERSTYLE
	TokAttrib_BORDERTOP						=37   	,// BORDERTOP
	TokAttrib_BORDERTOPCOLOR				=38   	,// BORDERTOPCOLOR
	TokAttrib_BORDERTOPSTYLE				=39   	,// BORDERTOPSTYLE
	TokAttrib_BORDERTOPWIDTH				=40   	,// BORDERTOPWIDTH
	TokAttrib_BORDERWIDTH					=41   	,// BORDERWIDTH
	TokAttrib_BOTTOMMARGIN					=42   	,// BOTTOMMARGIN
	TokAttrib_BREAKPOINT					=43   	,// BREAKPOINT
	TokAttrib_BUFFERDEPTH					=44   	,// BUFFERDEPTH
	TokAttrib_BUTTON						=45   	,// BUTTON
	TokAttrib_CANCELBUBBLE					=46   	,// CANCELBUBBLE
	TokAttrib_CELLPADDING					=47   	,// CELLPADDING
	TokAttrib_CELLSPACING					=48   	,// CELLSPACING
	TokAttrib_CENTER						=49   	,// CENTER
	TokAttrib_CHARSET						=50   	,// CHARSET
	TokAttrib_CHECKED						=51   	,// CHECKED
	TokAttrib_CLASS							=52   	,// CLASS
	TokAttrib_CLASSID						=53   	,// CLASSID
	TokAttrib_CLASSNAME						=54   	,// CLASSNAME
	TokAttrib_CLEAR							=55   	,// CLEAR
	TokAttrib_CLIP							=56   	,// CLIP
	TokAttrib_CODE							=57   	,// CODE
	TokAttrib_CODEBASE						=58   	,// CODEBASE
	TokAttrib_CODETYPE						=59   	,// CODETYPE
	TokAttrib_COLOR							=60   	,// COLOR
	TokAttrib_COLORDEPTH					=61   	,// COLORDEPTH
	TokAttrib_COLS							=62   	,// COLS
	TokAttrib_COLSPAN						=63   	,// COLSPAN
	TokAttrib_COMPACT						=64   	,// COMPACT
	TokAttrib_COMPLETE						=65   	,// COMPLETE
	TokAttrib_CONTENT						=66   	,// CONTENT
	TokAttrib_CONTROLS						=67   	,// CONTROLS
	TokAttrib_COOKIE						=68   	,// COOKIE
	TokAttrib_COOKIEENABLED					=69   	,// COOKIEENABLED
	TokAttrib_COORDS						=70   	,// COORDS
	TokAttrib_CSSTEXT						=71   	,// CSSTEXT
	TokAttrib_CTRLKEY						=72   	,// CTRLKEY
	TokAttrib_CURSOR						=73   	,// CURSOR
	TokAttrib_DATA							=74   	,// DATA
	TokAttrib_DECLARE						=75   	,// DECLARE
	TokAttrib_DATAFLD						=76   	,// DATAFLD
	TokAttrib_DATAFORMATAS					=77   	,// DATAFORMATAS
	TokAttrib_DATAPAGESIZE					=78   	,// DATAPAGESIZE
	TokAttrib_DATASRC						=79   	,// DATASRC
	TokAttrib_DEFAULTCHECKED				=80   	,// DEFAULTCHECKED
	TokAttrib_DEFAULTSELECTED				=81   	,// DEFAULTSELECTED
	TokAttrib_DEFAULTSTATUS					=82   	,// DEFAULTSTATUS
	TokAttrib_DEFAULTVALUE					=83   	,// DEFAULTVALUE
	TokAttrib_DIALOGARGUMENTS				=84   	,// DIALOGARGUMENTS
	TokAttrib_DIALOGHEIGHT					=85   	,// DIALOGHEIGHT
	TokAttrib_DIALOGLEFT					=86   	,// DIALOGLEFT
	TokAttrib_DIALOGTOP						=87   	,// DIALOGTOP
	TokAttrib_DIALOGWIDTH					=88   	,// DIALOGWIDTH
	TokAttrib_DIR							=89   	,// DIR
	TokAttrib_DIRECTION						=90   	,// DIRECTION
	TokAttrib_DISABLED						=91   	,// DISABLED
	TokAttrib_DISPLAY						=92   	,// DISPLAY
	TokAttrib_DOMAIN						=93   	,// DOMAIN
	TokAttrib_DYNSRC						=94   	,// DYNSRC
	TokAttrib_ENCODING						=95   	,// ENCODING
	TokAttrib_ENCTYPE						=96   	,// ENCTYPE
	TokAttrib_ENDSPAN						=97   	,// ENDSPAN
	TokAttrib_ENDSPAN__						=98   	,// ENDSPAN--
	TokAttrib_EVENT							=99   	,// EVENT
	TokAttrib_FACE							=100  	,// FACE
	TokAttrib_FGCOLOR						=101  	,// FGCOLOR
	TokAttrib_FILTER						=102  	,// FILTER
	TokAttrib_FONT							=103  	,// FONT
	TokAttrib_FONTFAMILY					=104  	,// FONTFAMILY
	TokAttrib_FONTSIZE						=105  	,// FONTSIZE
	TokAttrib_FONTSTYLE						=106  	,// FONTSTYLE
	TokAttrib_FONTVARIANT					=107  	,// FONTVARIANT
	TokAttrib_FONTWEIGHT					=108  	,// FONTWEIGHT
	TokAttrib_FOR							=109  	,// FOR
	TokAttrib_FORM							=110  	,// FORM
	TokAttrib_FRAME							=111  	,// FRAME
	TokAttrib_FRAMEBORDER					=112  	,// FRAMEBORDER
	TokAttrib_FRAMESPACING					=113  	,// FRAMESPACING
	TokAttrib_FROMELEMENT					=114  	,// FROMELEMENT
	TokAttrib_HASH							=115  	,// HASH
	TokAttrib_HEIGHT						=116  	,// HEIGHT
	TokAttrib_HIDDEN						=117  	,// HIDDEN
	TokAttrib_HOST							=118  	,// HOST
	TokAttrib_HOSTNAME						=119  	,// HOSTNAME
	TokAttrib_HREF							=120  	,// HREF
	TokAttrib_HSPACE						=121  	,// HSPACE
	TokAttrib_HTMLFOR						=122  	,// HTMLFOR
	TokAttrib_HTMLTEXT						=123  	,// HTMLTEXT
	TokAttrib_HTTPEQUIV						=124  	,// HTTPEQUIV
	TokAttrib_HTTP_EQUIV					=125  	,// HTTP-EQUIV
	TokAttrib_ID							=126  	,// ID
	TokAttrib_IN							=127  	,// IN
	TokAttrib_INDETERMINATE					=128  	,// INDETERMINATE
	TokAttrib_INDEX							=129  	,// INDEX
	TokAttrib_ISMAP							=130  	,// ISMAP
	TokAttrib_LANG							=131  	,// LANG
	TokAttrib_LANGUAGE						=132  	,// LANGUAGE
	TokAttrib_LEFTMARGIN					=133  	,// LEFTMARGIN
	TokAttrib_LENGTH						=134  	,// LENGTH
	TokAttrib_LETTERSPACING					=135  	,// LETTERSPACING
	TokAttrib_LINEHEIGHT					=136  	,// LINEHEIGHT
	TokAttrib_LINK							=137  	,// LINK
	TokAttrib_LINKCOLOR						=138  	,// LINKCOLOR
	TokAttrib_LISTSTYLE						=139  	,// LISTSTYLE
	TokAttrib_LISTSTYLEIMAGE				=140  	,// LISTSTYLEIMAGE
	TokAttrib_LISTSTYLEPOSITION				=141  	,// LISTSTYLEPOSITION
	TokAttrib_LISTSTYLETYPE					=142  	,// LISTSTYLETYPE
	TokAttrib_LOCATION						=143  	,// LOCATION
	TokAttrib_LOOP							=144  	,// LOOP
	TokAttrib_LOWSRC						=145  	,// LOWSRC
	TokAttrib_MAP							=146  	,// MAP
	TokAttrib_MARGIN						=147  	,// MARGIN
	TokAttrib_MARGINBOTTOM					=148  	,// MARGINBOTTOM
	TokAttrib_MARGINHEIGHT					=149  	,// MARGINHEIGHT
	TokAttrib_MARGINLEFT					=150  	,// MARGINLEFT
	TokAttrib_MARGINRIGHT					=151  	,// MARGINRIGHT
	TokAttrib_MARGINTOP						=152  	,// MARGINTOP
	TokAttrib_MARGINWIDTH					=153  	,// MARGINWIDTH
	TokAttrib_MAXLENGTH						=154  	,// MAXLENGTH
	TokAttrib_METHOD						=155  	,// METHOD
	TokAttrib_METHODS						=156  	,// METHODS
	TokAttrib_MIMETYPES						=157  	,// MIMETYPES
	TokAttrib_MULTIPLE						=158  	,// MULTIPLE
	TokAttrib_NAME							=159  	,// NAME
	TokAttrib_NOHREF						=160  	,// NOHREF
	TokAttrib_NORESIZE						=161  	,// NORESIZE
	TokAttrib_NOSHADE						=162  	,// NOSHADE
	TokAttrib_NOWRAP						=163  	,// NOWRAP
	TokAttrib_OBJECT						=164  	,// OBJECT
	TokAttrib_OFFSCREENBUFFERING			=165  	,// OFFSCREENBUFFERING
	TokAttrib_OFFSETHEIGHT					=166  	,// OFFSETHEIGHT
	TokAttrib_OFFSETLEFT					=167  	,// OFFSETLEFT
	TokAttrib_OFFSETPARENT					=168  	,// OFFSETPARENT
	TokAttrib_OFFSETTOP						=169  	,// OFFSETTOP
	TokAttrib_OFFSETWIDTH					=170  	,// OFFSETWIDTH
	TokAttrib_OFFSETX						=171  	,// OFFSETX
	TokAttrib_OFFSETY						=172  	,// OFFSETY
	TokAttrib_ONABORT						=173  	,// ONABORT
	TokAttrib_ONAFTERUPDATE					=174  	,// ONAFTERUPDATE
	TokAttrib_ONBEFOREUNLOAD				=175  	,// ONBEFOREUNLOAD
	TokAttrib_ONBEFOREUPDATE				=176  	,// ONBEFOREUPDATE
	TokAttrib_ONBLUR						=177  	,// ONBLUR
	TokAttrib_ONBOUNCE						=178  	,// ONBOUNCE
	TokAttrib_ONCHANGE						=179  	,// ONCHANGE
	TokAttrib_ONCLICK						=180  	,// ONCLICK
	TokAttrib_ONDATAAVAILABLE				=181  	,// ONDATAAVAILABLE
	TokAttrib_ONDATASETCHANGED				=182  	,// ONDATASETCHANGED
	TokAttrib_ONDATASETCOMPLETE				=183  	,// ONDATASETCOMPLETE
	TokAttrib_ONDBLCLICK					=184  	,// ONDBLCLICK
	TokAttrib_ONDRAGSTART					=185  	,// ONDRAGSTART
	TokAttrib_ONERROR						=186  	,// ONERROR
	TokAttrib_ONERRORUPDATE					=187  	,// ONERRORUPDATE
	TokAttrib_ONFILTERCHANGE				=188  	,// ONFILTERCHANGE
	TokAttrib_ONFINISH						=189  	,// ONFINISH
	TokAttrib_ONFOCUS						=190  	,// ONFOCUS
	TokAttrib_ONHELP						=191  	,// ONHELP
	TokAttrib_ONKEYDOWN						=192  	,// ONKEYDOWN
	TokAttrib_ONKEYPRESS					=193  	,// ONKEYPRESS
	TokAttrib_ONKEYUP						=194  	,// ONKEYUP
	TokAttrib_ONLOAD						=195  	,// ONLOAD
	TokAttrib_ONMOUSEOUT					=196  	,// ONMOUSEOUT
	TokAttrib_ONMOUSEOVER					=197  	,// ONMOUSEOVER
	TokAttrib_ONMOUSEUP						=198  	,// ONMOUSEUP
	TokAttrib_ONREADYSTATECHANGE			=199  	,// ONREADYSTATECHANGE
	TokAttrib_ONRESET						=200  	,// ONRESET
	TokAttrib_ONRESIZE						=201  	,// ONRESIZE
	TokAttrib_ONROWENTER					=202  	,// ONROWENTER
	TokAttrib_ONROWEXIT						=203  	,// ONROWEXIT
	TokAttrib_ONSCROLL						=204  	,// ONSCROLL
	TokAttrib_ONSELECT						=205  	,// ONSELECT
	TokAttrib_ONSELECTSTART					=206  	,// ONSELECTSTART
	TokAttrib_ONSUBMIT						=207  	,// ONSUBMIT
	TokAttrib_ONUNLOAD						=208  	,// ONUNLOAD
	TokAttrib_OPENER						=209  	,// OPENER
	TokAttrib_OUTERHTML						=210  	,// OUTERHTML
	TokAttrib_OUTERTEXT						=211  	,// OUTERTEXT
	TokAttrib_OUTLINE						=212  	,// OUTLINE
	TokAttrib_OVERFLOW						=213  	,// OVERFLOW
	TokAttrib_OWNINGELEMENT					=214  	,// OWNINGELEMENT
	TokAttrib_PADDING						=215  	,// PADDING
	TokAttrib_PADDINGBOTTOM					=216  	,// PADDINGBOTTOM
	TokAttrib_PADDINGLEFT					=217  	,// PADDINGLEFT
	TokAttrib_PADDINGRIGHT					=218  	,// PADDINGRIGHT
	TokAttrib_PADDINGTOP					=219  	,// PADDINGTOP
	TokAttrib_PAGEBREAKAFTER				=220  	,// PAGEBREAKAFTER
	TokAttrib_PAGEBREAKBEFORE				=221  	,// PAGEBREAKBEFORE
	TokAttrib_PALETTE						=222  	,// PALETTE
	TokAttrib_PARENT						=223  	,// PARENT
	TokAttrib_PARENTELEMENT					=224  	,// PARENTELEMENT
	TokAttrib_PARENTSTYLESHEET				=225  	,// PARENTSTYLESHEET
	TokAttrib_PARENTTEXTEDIT				=226  	,// PARENTTEXTEDIT
	TokAttrib_PARENTWINDOW					=227  	,// PARENTWINDOW
	TokAttrib_PATHNAME						=228  	,// PATHNAME
	TokAttrib_PIXELHEIGHT					=229  	,// PIXELHEIGHT
	TokAttrib_PIXELLEFT						=230  	,// PIXELLEFT
	TokAttrib_PIXELTOP						=231  	,// PIXELTOP
	TokAttrib_PIXELWIDTH					=232  	,// PIXELWIDTH
	TokAttrib_PLUGINS						=233  	,// PLUGINS
	TokAttrib_PLUGINSPAGE					=234  	,// PLUGINSPAGE
	TokAttrib_PORT							=235  	,// PORT
	TokAttrib_POSHEIGHT						=236  	,// POSHEIGHT
	TokAttrib_POSITION						=237  	,// POSITION
	TokAttrib_POSLEFT						=238  	,// POSLEFT
	TokAttrib_POSTOP						=239  	,// POSTOP
	TokAttrib_POSWIDTH						=240  	,// POSWIDTH
	TokAttrib_PROMPT						=241  	,// PROMPT
	TokAttrib_PROTOCOL						=242  	,// PROTOCOL
	TokAttrib_READONLY						=243  	,// READONLY
	TokAttrib_READYSTATE					=244  	,// READYSTATE
	TokAttrib_REASON						=245  	,// REASON
	TokAttrib_RECORDNUMBER					=246  	,// RECORDNUMBER
	TokAttrib_RECORDSET						=247  	,// RECORDSET
	TokAttrib_REF							=248  	,// REF
	TokAttrib_REFERRER						=249  	,// REFERRER
	TokAttrib_REL							=250  	,// REL
	TokAttrib_RETURNVALUE					=251  	,// RETURNVALUE
	TokAttrib_REV							=252  	,// REV
	TokAttrib_RIGHTMARGIN					=253  	,// RIGHTMARGIN
	TokAttrib_ROWS							=254  	,// ROWS
	TokAttrib_ROWSPAN						=255  	,// ROWSPAN
	TokAttrib_RULES							=256  	,// RULES
	TokAttrib_RUNAT							=257  	,// RUNAT
	TokAttrib_SCREENX						=258  	,// SCREENX
	TokAttrib_SCREENY						=259  	,// SCREENY
	TokAttrib_SCRIPTENGINE					=260  	,// SCRIPTENGINE
	TokAttrib_SCROLL						=261  	,// SCROLL
	TokAttrib_SCROLLAMOUNT					=262  	,// SCROLLAMOUNT
	TokAttrib_SCROLLDELAY					=263  	,// SCROLLDELAY
	TokAttrib_SCROLLHEIGHT					=264  	,// SCROLLHEIGHT
	TokAttrib_SCROLLING						=265  	,// SCROLLING
	TokAttrib_SCROLLLEFT					=266  	,// SCROLLLEFT
	TokAttrib_SCROLLTOP						=267  	,// SCROLLTOP
	TokAttrib_SCROLLWIDTH					=268  	,// SCROLLWIDTH
	TokAttrib_SEARCH						=269  	,// SEARCH
	TokAttrib_SELECTED						=270  	,// SELECTED
	TokAttrib_SELECTEDINDEX					=271  	,// SELECTEDINDEX
	TokAttrib_SELF							=272  	,// SELF
	TokAttrib_SHAPE							=273  	,// SHAPE
	TokAttrib_SHAPES						=274  	,// SHAPES
	TokAttrib_SHIFTKEY						=275  	,// SHIFTKEY
	TokAttrib_SIZE							=276  	,// SIZE
	TokAttrib_SPAN							=277  	,// SPAN
	TokAttrib_SOURCEINDEX					=278  	,// SOURCEINDEX
	TokAttrib_SRC							=279  	,// SRC
	TokAttrib_SRCELEMENT					=280  	,// SRCELEMENT
	TokAttrib_SRCFILTER						=281  	,// SRCFILTER
	TokAttrib_STANDBY						=282  	,// STANDBY
	TokAttrib_START							=283  	,// START
	TokAttrib_STARTSPAN						=284  	,// STARTSPAN
	TokAttrib_STATUS						=285  	,// STATUS
	TokAttrib_STYLE							=286  	,// STYLE
	TokAttrib_STYLEFLOAT					=287  	,// STYLEFLOAT
	TokAttrib_TABINDEX						=288  	,// TABINDEX
	TokAttrib_TAGNAME						=289  	,// TAGNAME
	TokAttrib_TARGET						=290  	,// TARGET
	TokAttrib_TEXT							=291  	,// TEXT
	TokAttrib_TEXTALIGN						=292  	,// TEXTALIGN
	TokAttrib_TEXTDECORATION				=293  	,// TEXTDECORATION
	TokAttrib_TEXTDECORATIONBLINK			=294  	,// TEXTDECORATIONBLINK
	TokAttrib_TEXTDECORATIONLINETHROUGH		=295  	,// TEXTDECORATIONLINETHROUGH
	TokAttrib_TEXTDECORATIONNONE			=296  	,// TEXTDECORATIONNONE
	TokAttrib_TEXTDECORATIONOVERLINE		=297  	,// TEXTDECORATIONOVERLINE
	TokAttrib_TEXTDECORATIONUNDERLINE		=298  	,// TEXTDECORATIONUNDERLINE
	TokAttrib_TEXTINDENT					=299  	,// TEXTINDENT
	TokAttrib_TEXTTRANSFORM					=300  	,// TEXTTRANSFORM
	TokAttrib_TITLE							=301  	,// TITLE
	TokAttrib_TOELEMENT						=302  	,// TOELEMENT
	TokAttrib_TOP							=303  	,// TOP
	TokAttrib_TOPMARGIN						=304  	,// TOPMARGIN
	TokAttrib_TRUESPEED						=305  	,// TRUESPEED
	TokAttrib_TYPE							=306  	,// TYPE
	TokAttrib_UPDATEINTERVAL				=307  	,// UPDATEINTERVAL
	TokAttrib_URL							=308  	,// URL
	TokAttrib_URN							=309  	,// URN
	TokAttrib_USEMAP						=310  	,// USEMAP
	TokAttrib_USERAGENT						=311  	,// USERAGENT
	TokAttrib_VALIGN						=312  	,// VALIGN
	TokAttrib_VALUE							=313  	,// VALUE
	TokAttrib_VERSION						=314  	,// VERSION
	TokAttrib_VERTICALALIGN					=315  	,// VERTICALALIGN
	TokAttrib_VIEWASTEXT					=316  	,// VIEWASTEXT
	TokAttrib_VISIBILITY					=317  	,// VISIBILITY
	TokAttrib_VLINK							=318  	,// VLINK
	TokAttrib_VLINKCOLOR					=319  	,// VLINKCOLOR
	TokAttrib_VOLUME						=320  	,// VOLUME
	TokAttrib_VRML							=321  	,// VRML
	TokAttrib_VSPACE						=322  	,// VSPACE
	TokAttrib_WIDTH							=323  	,// WIDTH
	TokAttrib_WRAP							=324  	,// WRAP
	TokAttrib_X								=325  	,// X
	TokAttrib_Y								=326  	,// Y
	TokAttrib_ZINDEX						=327  	// ZINDEX

} AttributeTokens;

typedef enum tagTagTokens
{
	TokTag_START 	=	1,	/* <  	*/
	TokTag_END 		=	2,	/* </ 	*/
	TokTag_CLOSE 	=	3,	/* >  	*/
	TokTag_BANG		=	4,	/* <! 	*/
	TokTag_PI 		=	5,	/* <? 	*/
	TokTag_SSSOPEN	=	6, 	/* <% 	*/
	TokTag_SSSCLOSE	=	7, 	/* %> 	*/
	TokTag_SSSOPEN_TRIEDIT	=	8, 	/* <% 	inside <script block>*/
	TokTag_SSSCLOSE_TRIEDIT	=	9 	/* %> 	inside <script block>*/
} TagTokens;

enum HtmlToken
{
    tokUNKNOWN = tokclsError,
    tokIDENTIFIER = tokclsIdentMin,     // identifier/plain text
    tokNEWLINE = tokclsUserMin,
	//
	// colored HTML items
	//
    tokElem,     // element name
    tokAttr,     // attribute name
	tokValue,    // attribute value
	tokComment,  // comment
    tokEntity,   // entity reference: e.g. "&nbsp;"
	tokTag,      // tag delimiter
	tokString,   // string
	tokSpace,    // whitespace and unrecognized text in a tag
	tokOp,       // operator
	tokSSS,      // server-side script <%...%>
	//
	// parsed HTML and SGML items - tokens folded with items above
	//
	tokName,     // NAMETOKEN
	tokNum,      // NUMTOKEN
	tokParEnt,   // parameter entity: e.g. "%name;"
	tokResName,  // reserved name
	//
	// operators - colors folded with tokOp above
	//
	tokOP_MIN,
	tokOpDash = tokOP_MIN,         // -
	tokOP_SINGLE,
	tokOpQuestion = tokOP_SINGLE,  // ?
	tokOpComma,                    // ,
	tokOpPipe,                     // |
	tokOpPlus,                     // +
	tokOpEqual,                    // =
	tokOpStar,                     // *
	tokOpAmp,                      // &
	tokOpCent,                     // %
	tokOpLP,                       // (
	tokOpRP,                       // )
	tokOpLB,                       // [
	tokOpRB,                       // ]
    tokOP_MAX,                     // token op MAX

    tokEOF
};

// the state of lexical analyser
//
// We're generally in one of two states:
// 1.  scanning text
// 2.  scanning tag info
//
// Within these states, the lexer can be in several substates.
//
// Text substates:
//
//      inText       HTML text content -- process markup
//      inPLAINTEXT  after a <PLAINTEXT> tag - remainder of file is not HTML
//      inCOMMENT    COMMENT content -- suppress all markup but </COMMENT>
//               color text as comment
//      inXMP        XMP content -- suppress all markup but </XMP>
//      inLISTING    LISTING content -- suppress all markup but </LISTING>
//		inSCRIPT	 SCRIPT content -- colorize with script engine
//
// Tag substates:
//
// inTag       inside a tag < ... >
// inBangTag   inside an SGML MDO tag <! ... >
// inPITag     inside an SGML Prcessing Instruction tag <? ... >
// inHTXTag    inside an ODBC HTML Extension template tag <% ... %>
// inEndTag    inside an end tag </name>
// inAttribute expecting an attribute
// inValue     expecting an attribute value (right of =)
// inComment   inside a comment
// inString        inside a " string, terminated by "
// inStringA   inside a ' (Alternate) string, terminated by '
//
enum HtmlLexState
{
	// tag types
	inTag        = 0x00000001, // <  ... >
	inBangTag    = 0x00000002, // <! ... >
	inPITag      = 0x00000004, // <? ... >
	inHTXTag     = 0x00000008, // <% ... %>
	inEndTag         = 0x00000010, // </ ... >

	// tag scanning states
	inAttribute  = 0x00000020,
	inValue      = 0x00000040,

	inComment    = 0x00000080,
	inString     = 0x00000100,
	inStringA    = 0x00000200,
	inScriptText = 0x00000400,
	inNestedQuoteinSSS= 0x00000800, // e.g. attr="<%if something Response.Write("X")%>"

	// text content model states
	inPLAINTEXT  = 0x00001000,
	inCOMMENT    = 0x00002000,
	inXMP        = 0x00004000,
	inLISTING    = 0x00008000,
	inSCRIPT	 = 0x00010000,

	// sublanguages
	inVariant    = 0x00F00000, // mask for sublang index
	inHTML2      = 0x00000000,
	inIExplore2  = 0x00100000,
	inIExplore3  = 0x00200000,

	//  script languages
	inJavaScript = 0x01000000,
	inVBScript   = 0x02000000,
	inServerASP  = 0x04000000, // in triedit's special script (serverside->clientside conversion)

};

// masks for subsets of the state
// These masks will not show up in the generated file
// Just copy paste these into your file.
#define INTAG (inTag|inBangTag|inPITag|inHTXTag|inEndTag)
#define INSTRING (inString|inStringA)
#define TAGMASK (INTAG|inAttribute|inValue|inComment|INSTRING)
#define TEXTMASK (inPLAINTEXT|inCOMMENT|inXMP|inLISTING)
#define STATEMASK (TAGMASK|TEXTMASK)

#endif __INC_TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\trace.cpp ===
/****************************************************************************
*
* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
*
*
*
*
*
*
*
****************************************************************************/

#include "stdafx.h"

#include "trace.h"

#ifdef _DEBUG

void __cdecl Trace(LPSTR lprgchFormat, ...)
{
    char rgch[128], rgchOutput[256];
    wsprintfA(rgch, "%s\n", lprgchFormat);
#if defined(_M_IX86)
    wvsprintfA(rgchOutput, rgch, (LPSTR)(((LPSTR)&lprgchFormat) + sizeof(LPSTR)));
#else
    {
    va_list lpArgs;
    va_start(lpArgs, lprgchFormat);
    wvsprintfA(rgchOutput, rgch, lpArgs);
    va_end(lpArgs);
    }
#endif
    OutputDebugStringA(rgchOutput);
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\trace.h ===
/****************************************************************************
*
* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
*
*
*
*
*
*
*
****************************************************************************/

#ifndef __TRACE_H__
#define __TRACE_H__

#ifdef _DEBUG
    void __cdecl Trace(LPSTR lprgchFormat, ...);
#else
    inline void __cdecl Trace(LPSTR /*lprgchFormat*/, ...) {}
#endif //_DEBUG

#endif //__TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\tokhtml.h ===
// tokhtml.h - Tokens and lex state for HTML
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Include lex.h before including this file.
//

#ifndef __TOKHTML_H__
#define __TOKHTML_H__

#if 0
// Moved to the IDL
enum HtmlToken
{
    tokUNKNOWN = tokclsError,
    tokIDENTIFIER = tokclsIdentMin,     // identifier/plain text
    tokNEWLINE = tokclsUserMin,
	//
	// colored HTML items
	//
    tokElem,     // element name
    tokAttr,     // attribute name
	tokValue,    // attribute value
	tokComment,  // comment
    tokEntity,   // entity reference: e.g. "&nbsp;"
	tokTag,      // tag delimiter
	tokString,   // string
	tokSpace,    // whitespace and unrecognized text in a tag
	tokOp,       // operator
	tokSSS,      // server-side script <%...%>
	//
	// parsed HTML and SGML items - tokens folded with items above
	//
	tokName,     // NAMETOKEN
	tokNum,      // NUMTOKEN
	tokParEnt,   // parameter entity: e.g. "%name;"
	tokResName,  // reserved name
	//
	// operators - colors folded with tokOp above
	//
	tokOP_MIN,
	tokOpDash = tokOP_MIN,         // -
	tokOP_SINGLE,
	tokOpQuestion = tokOP_SINGLE,  // ?
	tokOpComma,                    // ,
	tokOpPipe,                     // |
	tokOpPlus,                     // +
	tokOpEqual,                    // =
	tokOpStar,                     // *
	tokOpAmp,                      // &
	tokOpCent,                     // %
	tokOpLP,                       // (
	tokOpRP,                       // )
	tokOpLB,                       // [
	tokOpRB,                       // ]
    tokOP_MAX,                     // token op MAX

    tokEOF
};

// the state of lexical analyser
//
// We're generally in one of two states:
// 1.  scanning text
// 2.  scanning tag info
//
// Within these states, the lexer can be in several substates.
//
// Text substates:
//
// 	inText       HTML text content -- process markup
//	inPLAINTEXT  after a <PLAINTEXT> tag - remainder of file is not HTML
//	inCOMMENT    COMMENT content -- suppress all markup but </COMMENT>
//               color text as comment
//	inXMP        XMP content -- suppress all markup but </XMP>
//	inLISTING    LISTING content -- suppress all markup but </LISTING>
//	inSCRIPT	 SCRIPT content -- color using script engine.
//
// Tag substates:
//
// inTag       inside a tag < ... >
// inBangTag   inside an SGML MDO tag <! ... >
// inPITag     inside an SGML Prcessing Instruction tag <? ... >
// inHTXTag    inside an ODBC HTML Extension template tag <% ... %>
// inEndTag    inside an end tag </name>
// inAttribute expecting an attribute
// inValue     expecting an attribute value (right of =)
// inComment   inside a comment
// inString	   inside a " string, terminated by "
// inStringA   inside a ' (Alternate) string, terminated by '
//
enum HtmlLexState
{
	// tag types
	inTag        = 0x00000001, // <  ... >
	inBangTag    = 0x00000002, // <! ... >
	inPITag      = 0x00000004, // <? ... >
	inHTXTag     = 0x00000008, // <% ... %>
	inEndTag	 = 0x00000010, // </ ... >

	// tag scanning states
	inAttribute  = 0x00000020,
	inValue      = 0x00000040,

	inComment    = 0x00000080,
	inString     = 0x00000100,
	inStringA    = 0x00000200,

	// text content model states
	inPLAINTEXT  = 0x00001000,
	inCOMMENT    = 0x00002000,
	inXMP        = 0x00004000,
	inLISTING    = 0x00008000,
	inSCRIPT     = 0x00010000,

	// sublanguages
	inVariant    = 0x00F00000, // mask for sublang index
	inHTML2      = 0x00000000,
	inIExplore2  = 0x00100000,
	inIExplore3  = 0x00200000,

	//  script languages
	inJavaScript = 0x01000000,
	inVBScript   = 0x02000000,

};

// masks for subsets of the state
#define INTAG (inTag|inBangTag|inPITag|inHTXTag|inEndTag)
#define INSTRING (inString|inStringA)
#define TAGMASK (INTAG|inAttribute|inValue|inComment|INSTRING)
#define TEXTMASK (inPLAINTEXT|inCOMMENT|inXMP|inLISTING|inSCRIPT)
#define STATEMASK (TAGMASK|TEXTMASK)

#endif


// convert state <-> sublang index
inline DWORD SubLangIndexFromLxs(DWORD lxs) { return (lxs & inVariant) >> 20UL; }
inline DWORD LxsFromSubLangIndex(DWORD isl) { return (isl << 20UL) & inVariant; }

#endif // __TOKHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\table.cpp ===
// table.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// HTML keyword tables
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.


#include "stdafx.h"

#include "resource.h"
#include "guids.h"
#include "table.h"

#undef ASSERT
#define ASSERT(b) _ASSERTE(b)

// qsort/bsearch helper
int CmpFunc(const void *a, const void *b);

static const TCHAR szFileSig[] = _T("@HLX@");
static const TCHAR szElTag[]   = _T("[Elements]");
static const TCHAR szAttTag[]  = _T("[Attributes]");
static const TCHAR szEntTag[]  = _T("[Entities]");

////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
//
// table verification routines
//
int CheckWordTable(ReservedWord *arw, int cel, LPCTSTR szName /*= NULL*/)
{
	int cerr = 0;
	int cch;
	for (int i = 0; i < cel; i++)
	{
		// table must be sorted in ascending alpha order
		//
		if (i > 1)
		{
			if (!(_tcscmp(arw[i-1].psz, arw[i].psz) < 0))
			{
				ATLTRACE(_T("lexer:entries in %s out of order at %d: %s - %s\n"),
					szName?szName:_T("?"), i-1, arw[i-1].psz, arw[i].psz);
				cerr++;
			}
		}

		// length must match
		//
		cch = _tcslen(arw[i].psz);
		if (cch != arw[i].cb)
		{
			ATLTRACE(_T("lexer:Incorrect entry in %s: %s,%d should be %d\n"),
				szName?szName:_T("?"), arw[i].psz, arw[i].cb, cch);
			cerr++;
		}
	}
	return cerr;
}

int CheckWordTableIndex(ReservedWord *arw, int cel, int *ai, BOOL bCase /*= FALSE*/, LPCTSTR szName /* = NULL*/)
{
	int cerr = 0;
	int index;
	int max = bCase ? 52 : 26;

	_ASSERTE(NULL != arw);
	_ASSERTE(NULL != ai);

	int aik[] =
	{
		//A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
		  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		//a b c d e f g h i j k l m n o p q r s t u v w x y z
		  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};

	// Build correct index array on static aik
	cerr += MakeIndexHere( arw, cel, aik, bCase );

	// Compare with declared arrray
	//
	if (0 != memcmp(aik, ai, max))
		cerr++;

	// If errors, dump correct array
	if (cerr)
	{
		ATLTRACE(_T("lexer: Correct index array for %s: \n{\n\t"), szName ? szName : _T("?"));
		for (index = 0; index < max - 1; index++)
		{
			ATLTRACE(_T("%3d,"), aik[index]);
			if (index % 13 == 12)
				ATLTRACE(_T("\n\t"));
		}
		ATLTRACE(_T("%3d\n};\n"), aik[index]);
	}
	return cerr;
}
#endif

int MakeIndexHere(ReservedWord *arw, int cel, int *ab, BOOL bCase /*= FALSE*/, LPCTSTR szName /*= NULL*/)
{
	int cerr = 0;
	int index;

	ASSERT(ab != NULL);
	ASSERT(arw != NULL);

	for (int irw = cel - 1; irw > 0; irw--)
	{
		index = PeekIndex(*arw[irw].psz, bCase);
		if (-1 != index)
			ab[index] = irw;
		else
		{
			ATLTRACE(_T("lexer:error in %s: non-alpha token %s\n"), szName?szName:_T("?"), arw[irw].psz);
			cerr++;
		}
	}
	return cerr;
}

int MakeIndex(ReservedWord *arw, int cel, int **pab, BOOL bCase /*= FALSE*/, LPCTSTR szName /*= NULL*/)
{
	ASSERT(NULL != arw);
	ASSERT(NULL != pab);
	*pab = new int[ bCase ? 52 : 26 ];
	if (NULL == *pab)
		return -1;
	return MakeIndexHere(arw, cel, *pab, bCase, szName);
}

#define RW_Entry(string, attribute) \
	_T( #string ), sizeof( #string ) - 1, attribute

////////////////////////////////////////////////////////////////////////////
// reserved word table
// Two tables:
//   reserved[] = sorted table of reserved words
//   index[initial(token)] = (index of first reserved word with that initial)
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
//
// NOTE: the "HPn" elements are considered obsolete
//
static ReservedWord _rgElementNames[] =
{// psz             cb      att
	_T(""),	0, 0,
	RW_Entry(A 				,ALL	),
	RW_Entry(ADDRESS 		,ALL	),
	RW_Entry(APPLET 		,IEXPn	), // ???
	RW_Entry(AREA 			,IEXPn	),
	RW_Entry(B 				,ALL	),
	RW_Entry(BASE 			,ALL	),
	RW_Entry(BASEFONT 		,IEXPn	),
	RW_Entry(BGSOUND 		,IEXPn	), // IExplore
  	RW_Entry(BIG 			,IEXP3	),
	RW_Entry(BLINK 			,IEXPn	), // Netscape
	RW_Entry(BLOCKQUOTE 	,ALL	),
	RW_Entry(BODY 			,ALL	),
	RW_Entry(BR 			,ALL	),
	RW_Entry(BUTTON 		,IE40	),
	RW_Entry(CAPTION 		,IEXPn	), // tables
	RW_Entry(CENTER 		,IEXPn	),
	RW_Entry(CITE 			,ALL	),
	RW_Entry(CODE 			,ALL	),
	RW_Entry(COL 			,IEXP3	),
	RW_Entry(COLGROUP 		,IEXP3	), // HTML 3 tables?
	RW_Entry(COMMENT 		,ALL	), // considered obsolete
	RW_Entry(DD 			,ALL	),
	RW_Entry(DFN 			,ALL	), // RFC1866: not in the RFC, but deployed. ital or bold ital
	RW_Entry(DIR 			,ALL	),
	RW_Entry(DIV 			,IEXP3	),     // HTML 3
	RW_Entry(DL 			,ALL	),
	RW_Entry(DT 			,ALL	),
	RW_Entry(EM 			,ALL	),
	RW_Entry(EMBED 			,IEXP3	), // netscape -- IEXP3
	RW_Entry(FIELDSET 		,IE40	),
	RW_Entry(FONT 			,IEXPn	),
	RW_Entry(FORM 			,ALL	),   // forms
	RW_Entry(FRAME 			,IEXP3	), // framesets
	RW_Entry(FRAMESET 		,IEXP3	), // framesets
	RW_Entry(H1 			,ALL	), // heading 1
	RW_Entry(H2 			,ALL	), // heading 2
	RW_Entry(H3 			,ALL	), // heading 3
	RW_Entry(H4 			,ALL	), // heading 4
	RW_Entry(H5 			,ALL	), // heading 5
	RW_Entry(H6 			,ALL	), // heading 6
	RW_Entry(HEAD 			,ALL	), // document head
	RW_Entry(HR 			,ALL	),
	RW_Entry(HTML 			,ALL	),
	RW_Entry(I 				,ALL	),
	RW_Entry(IFRAME 		,IEXP3	),	// inline frames
	RW_Entry(IMG 			,ALL	),
	RW_Entry(INPUT 			,ALL	), // forms
	RW_Entry(ISINDEX 		,ALL	),
	RW_Entry(KBD 			,ALL	),
	RW_Entry(LABEL 			,IE40	),
	RW_Entry(LEGEND 		,IE40	),
	RW_Entry(LI 			,ALL	),
	RW_Entry(LINK 			,ALL	),
	RW_Entry(LISTING 		,ALL	), // RFC 1866: obsolete
	RW_Entry(MAP 			,IEXPn	),
	RW_Entry(MARQUEE 		,IEXPn	), // IExplore
	RW_Entry(MENU 			,ALL	),
	RW_Entry(META 			,ALL	),
	RW_Entry(METADATA 		,ALL	),
	RW_Entry(NOBR 			,IEXPn	),
	RW_Entry(NOFRAMES 		,IEXP3	), // framesets
	RW_Entry(NOSCRIPT 		,IE40	), // IE4 only
	RW_Entry(OBJECT 		,IEXP3	), // ActiveX
	RW_Entry(OL 			,ALL	),
	RW_Entry(OPTION 		,ALL	),   // forms
	RW_Entry(P 				,ALL	),
	RW_Entry(PARAM 			,IEXP3	), // ActiveX
	RW_Entry(PLAINTEXT 		,ALL	),   // RFC 1866: deprecated, noted as obsolete
	RW_Entry(PRE 			,ALL	),
	RW_Entry(S 				,IEXPn	), // (apparently) synonym for strike
	RW_Entry(SAMP 			,ALL	),
	RW_Entry(SCRIPT 		,IEXP3	), // ActiveX
	RW_Entry(SELECT 		,ALL	),
	RW_Entry(SMALL 			,IEXP3	),
	RW_Entry(SPAN 			,IEXP3	), // tables
	RW_Entry(STRIKE 		,IEXPn	), // not in RFC 1866 DTD, but noted as deployed
	RW_Entry(STRONG 		,ALL	),
    RW_Entry(STYLE 			,IEXP3	), // HTML 3 stylesheets
	RW_Entry(SUB 			,IEXP3	), // HTML3 ???
	RW_Entry(SUP 			,IEXP3	), // HTML3 ???
	RW_Entry(TABLE 			,IEXPn	), // tables
	RW_Entry(TBODY 			,IEXP3	), // HTML 3 tables
	RW_Entry(TD 			,IEXPn	), // tables
	RW_Entry(TEXTAREA 		,ALL	),   // forms
	RW_Entry(TFOOT 			,IEXP3	), // HTML 3 tables
	RW_Entry(TH 			,IEXPn	), // tables
	RW_Entry(THEAD 			,IEXP3	), // HTML 3 tables
	RW_Entry(TITLE 			,ALL	),
	RW_Entry(TR 			,IEXPn	), // tables
	RW_Entry(TT 			,ALL	),
	RW_Entry(U 				,ALL	),   // not in RFC 1866 DTD, but noted as deployed
	RW_Entry(UL 			,ALL	),
	RW_Entry(VAR 			,ALL	),
	RW_Entry(WBR 			,IEXPn	),
	RW_Entry(XMP 			,ALL	),   // deprecated by RFC 1866
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
// The following array is a mapping of each letter to a position in the
// table where tokens starting with that letter begin.
//
static int _rgIndexElementNames[] = // [Elements]
{
	/* A */ TokElem_A			,
	/* B */ TokElem_B			,
	/* C */	TokElem_CAPTION		,
	/* D */	TokElem_DD			,
	/* E */	TokElem_EM			,
	/* F */	TokElem_FIELDSET	,
	/* G */	0					,
	/* H */	TokElem_H1			,
	/* I */	TokElem_I			,
	/* J */	0					,
	/* K */	TokElem_KBD			,
	/* L */	TokElem_LABEL		,
	/* M */	TokElem_MAP			,
	/* N */	TokElem_NOBR		,
	/* O */	TokElem_OBJECT		,
	/* P */	TokElem_P			,
	/* Q */	0					,
	/* R */	0					,
	/* S */	TokElem_S			,
	/* T */	TokElem_TABLE		,
	/* U */	TokElem_U			,
	/* V */	TokElem_VAR			,
	/* W */	TokElem_WBR			,
	/* X */	TokElem_XMP			,
	/* Y */	0					,
	/* Z */	0
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.

//
// attribute name table
//
static ReservedWord _rgAttributeNames[] =
{// psz                 cb   att
	_T(""), 0, 0,
	RW_Entry(ACCESSKEY					,IEXP3	),
	RW_Entry(ACTION						,ALL	),
	RW_Entry(ALIGN						,ALL	),
	RW_Entry(ALINK						,IEXPn	),
	RW_Entry(ALT						,ALL	),
	RW_Entry(APPNAME					,IE40	),
	RW_Entry(APPVERSION					,IE40	),
	RW_Entry(BACKGROUND					,IEXPn	),
	RW_Entry(BACKGROUNDATTACHMENT		,IE40	),
	RW_Entry(BACKGROUNDCOLOR			,IE40	),
	RW_Entry(BACKGROUNDIMAGE			,IE40	),
	RW_Entry(BACKGROUNDPOSITION			,IE40	),
	RW_Entry(BACKGROUNDPOSITIONX		,IE40	),
	RW_Entry(BACKGROUNDPOSITIONY		,IE40	),
	RW_Entry(BACKGROUNDREPEAT			,IE40	),
	RW_Entry(BALANCE					,IE40	),
	RW_Entry(BEHAVIOR					,IEXPn	), // MARQUEE
	RW_Entry(BGCOLOR					,IEXPn	),
	RW_Entry(BGPROPERTIES				,IEXPn	),
	RW_Entry(BORDER						,IEXPn	),
	RW_Entry(BORDERBOTTOM				,IE40	),
	RW_Entry(BORDERBOTTOMCOLOR			,IE40	),
	RW_Entry(BORDERBOTTOMSTYLE			,IE40	),
	RW_Entry(BORDERBOTTOMWIDTH			,IE40	),
	RW_Entry(BORDERCOLOR				,IEXPn	), // tables
	RW_Entry(BORDERCOLORDARK			,IEXPn	), // tables
	RW_Entry(BORDERCOLORLIGHT			,IEXPn	), // tables
	RW_Entry(BORDERLEFT					,IE40	),
	RW_Entry(BORDERLEFTCOLOR			,IE40	),
	RW_Entry(BORDERLEFTSTYLE			,IE40	),
	RW_Entry(BORDERLEFTWIDTH			,IE40	),
	RW_Entry(BORDERRIGHT				,IE40	),
	RW_Entry(BORDERRIGHTCOLOR			,IE40	),
	RW_Entry(BORDERRIGHTSTYLE			,IE40	),
	RW_Entry(BORDERRIGHTWIDTH			,IE40	),
	RW_Entry(BORDERSTYLE				,IE40	),
	RW_Entry(BORDERTOP					,IE40	),
	RW_Entry(BORDERTOPCOLOR				,IE40	),
	RW_Entry(BORDERTOPSTYLE				,IE40	),
	RW_Entry(BORDERTOPWIDTH				,IE40	),
	RW_Entry(BORDERWIDTH				,IE40	),
	RW_Entry(BOTTOMMARGIN				,IEXPn	),
	RW_Entry(BREAKPOINT					,IEXPn	), // (walts) hidden META tag attribute for brkpt mapping.
	RW_Entry(BUFFERDEPTH				,IE40	),
	RW_Entry(BUTTON						,IE40	),
	RW_Entry(CANCELBUBBLE				,IE40	),
	RW_Entry(CELLPADDING				,IEXPn	), // tables
	RW_Entry(CELLSPACING				,IEXPn	), // tables
	RW_Entry(CENTER						,IEXPn	),
	RW_Entry(CHARSET					,IE40	),
	RW_Entry(CHECKED					,ALL	),
	RW_Entry(CLASS						,IEXPn	),
	RW_Entry(CLASSID					,IEXP3	), //objects
	RW_Entry(CLASSNAME					,IE40	),
	RW_Entry(CLEAR						,IEXP3	),
	RW_Entry(CLIP						,IE40	),
	RW_Entry(CODE						,IEXPn	),
	RW_Entry(CODEBASE					,IEXP3	), //objects
	RW_Entry(CODETYPE					,IE40	),
	RW_Entry(COLOR						,IEXPn	), // font
	RW_Entry(COLORDEPTH					,IE40	),
	RW_Entry(COLS						,ALL	),
	RW_Entry(COLSPAN					,IEXPn	), // tables
	RW_Entry(COMPACT					,ALL	),
	RW_Entry(COMPLETE					,IE40	),
	RW_Entry(CONTENT					,ALL	),
	RW_Entry(CONTROLS					,IEXPn	),
	RW_Entry(COOKIE						,IE40	),
	RW_Entry(COOKIEENABLED				,IE40	),
	RW_Entry(COORDS						,IEXPn	),
	RW_Entry(CSSTEXT					,IE40	),
	RW_Entry(CTRLKEY					,IE40	),
	RW_Entry(CURSOR						,IE40	),
	RW_Entry(DATA						,IEXP3	), //objects
	RW_Entry(DATAFLD					,IE40	),
	RW_Entry(DATAFORMATAS				,IE40	),
	RW_Entry(DATAPAGESIZE				,IE40	),
	RW_Entry(DATASRC					,IE40	),
	RW_Entry(DECLARE					,IEXP3	), //objects
	RW_Entry(DEFAULTCHECKED				,IE40	),
	RW_Entry(DEFAULTSELECTED			,IE40	),
	RW_Entry(DEFAULTSTATUS				,IE40	),
	RW_Entry(DEFAULTVALUE				,IE40	),
	RW_Entry(DIALOGARGUMENTS			,IE40	),
	RW_Entry(DIALOGHEIGHT				,IE40	),
	RW_Entry(DIALOGLEFT					,IE40	),
	RW_Entry(DIALOGTOP					,IE40	),
	RW_Entry(DIALOGWIDTH				,IE40	),
	RW_Entry(DIR						,IEXP3	), // HTML 3 ???
	RW_Entry(DIRECTION					,IEXPn	), // MARQUEE
	RW_Entry(DISABLED					,IE40	),
	RW_Entry(DISPLAY					,IE40	),
	RW_Entry(DOMAIN						,IE40	),
	RW_Entry(DYNSRC						,IEXPn	),
	RW_Entry(ENCODING					,IE40	),
	RW_Entry(ENCTYPE					,ALL	),
	RW_Entry(ENDSPAN					,IE40	),	// Designer control tags
	RW_Entry(ENDSPAN--					,IE40	),	// Designer control tags HACK to handle nonspace
	RW_Entry(EVENT						,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(FACE						,IEXPn	), // font
	RW_Entry(FGCOLOR					,IE40	),
	RW_Entry(FILTER						,IE40	),
	RW_Entry(FONT						,IE40	),
	RW_Entry(FONTFAMILY					,IE40	),
	RW_Entry(FONTSIZE					,IE40	),
	RW_Entry(FONTSTYLE					,IE40	),
	RW_Entry(FONTVARIANT				,IE40	),
	RW_Entry(FONTWEIGHT					,IE40	),
	RW_Entry(FOR						,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(FORM						,IE40	),
	RW_Entry(FRAME						,IE40	),
	RW_Entry(FRAMEBORDER				,IEXP3	),
	RW_Entry(FRAMESPACING				,IEXP3	),
	RW_Entry(FROMELEMENT				,IE40	),
	RW_Entry(HASH						,IE40	),
	RW_Entry(HEIGHT						,IEXPn	),
	RW_Entry(HIDDEN						,IE40	),
	RW_Entry(HOST						,IE40	),
	RW_Entry(HOSTNAME					,IE40	),
	RW_Entry(HREF						,ALL	),
	RW_Entry(HSPACE						,IEXPn	),
	RW_Entry(HTMLFOR					,IE40	),
	RW_Entry(HTMLTEXT					,IE40	),
	RW_Entry(HTTP-EQUIV					,ALL	),
	RW_Entry(HTTPEQUIV					,IE40	),
	RW_Entry(ID							,IEXPn	),
	RW_Entry(IN							,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(INDETERMINATE				,IE40	),
	RW_Entry(INDEX						,IE40	),
	RW_Entry(ISMAP						,ALL	),
	RW_Entry(LANG						,IEXPn	),
	RW_Entry(LANGUAGE					,IEXP3	),
	RW_Entry(LEFTMARGIN					,IEXPn	),
	RW_Entry(LENGTH						,IE40	),
	RW_Entry(LETTERSPACING				,IE40	),
	RW_Entry(LINEHEIGHT					,IE40	),
	RW_Entry(LINK						,IEXPn	),
	RW_Entry(LINKCOLOR					,IE40	),
	RW_Entry(LISTSTYLE					,IE40	),
	RW_Entry(LISTSTYLEIMAGE				,IE40	),
	RW_Entry(LISTSTYLEPOSITION			,IE40	),
	RW_Entry(LISTSTYLETYPE				,IE40	),
	RW_Entry(LOCATION					,IE40	),
	RW_Entry(LOOP						,IEXPn	),
	RW_Entry(LOWSRC						,IE40	),
	RW_Entry(MAP						,IE40	),
	RW_Entry(MARGIN						,IE40	),
	RW_Entry(MARGINBOTTOM				,IE40	),
	RW_Entry(MARGINHEIGHT				,IEXP3	),
	RW_Entry(MARGINLEFT					,IE40	),
	RW_Entry(MARGINRIGHT				,IE40	),
	RW_Entry(MARGINTOP					,IE40	),
	RW_Entry(MARGINWIDTH				,IEXP3	),
	RW_Entry(MAXLENGTH					,ALL	),
	RW_Entry(METHOD						,ALL	),
	RW_Entry(METHODS					,ALL	),
	RW_Entry(MIMETYPES					,IE40	),
	RW_Entry(MULTIPLE					,ALL	),
	RW_Entry(NAME						,ALL	),
	RW_Entry(NOHREF						,IEXPn	),
	RW_Entry(NORESIZE					,IEXP3	),
	RW_Entry(NOSHADE					,IEXP3	), // not implemented by IExplore 2
	RW_Entry(NOWRAP						,IEXPn	),
	RW_Entry(OBJECT						,IEXP3	), // <PARAM>
	RW_Entry(OFFSCREENBUFFERING			,IE40	),
	RW_Entry(OFFSETHEIGHT				,IE40	),
	RW_Entry(OFFSETLEFT					,IE40	),
	RW_Entry(OFFSETPARENT				,IE40	),
	RW_Entry(OFFSETTOP					,IE40	),
	RW_Entry(OFFSETWIDTH				,IE40	),
	RW_Entry(OFFSETX					,IE40	),
	RW_Entry(OFFSETY					,IE40	),
	RW_Entry(ONABORT					,IE40	),
	RW_Entry(ONAFTERUPDATE				,IE40	),
	RW_Entry(ONBEFOREUNLOAD				,IE40	),
	RW_Entry(ONBEFOREUPDATE				,IE40	),
	RW_Entry(ONBLUR						,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONBOUNCE					,IE40	),
	RW_Entry(ONCHANGE					,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONCLICK					,IEXP3	), // INPUT, A, <more>
	RW_Entry(ONDATAAVAILABLE			,IE40	),
	RW_Entry(ONDATASETCHANGED			,IE40	),
	RW_Entry(ONDATASETCOMPLETE			,IE40	),
	RW_Entry(ONDBLCLICK					,IE40	),
	RW_Entry(ONDRAGSTART				,IE40	),
	RW_Entry(ONERROR					,IE40	),
	RW_Entry(ONERRORUPDATE				,IE40	),
	RW_Entry(ONFILTERCHANGE				,IE40	),
	RW_Entry(ONFINISH					,IE40	),
	RW_Entry(ONFOCUS					,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONHELP						,IE40	),
	RW_Entry(ONKEYDOWN					,IE40	),
	RW_Entry(ONKEYPRESS					,IE40	),
	RW_Entry(ONKEYUP					,IE40	),
	RW_Entry(ONLOAD						,IEXP3	), // FRAMESET, BODY
	RW_Entry(ONMOUSEOUT					,IEXP3	), // A, AREA, <more>
	RW_Entry(ONMOUSEOVER				,IEXP3	), // A, AREA, <more>
	RW_Entry(ONMOUSEUP					,IE40	),
	RW_Entry(ONREADYSTATECHANGE			,IE40	),
	RW_Entry(ONRESET					,IE40	),
	RW_Entry(ONRESIZE					,IE40	),
	RW_Entry(ONROWENTER					,IE40	),
	RW_Entry(ONROWEXIT					,IE40	),
	RW_Entry(ONSCROLL					,IE40	),
	RW_Entry(ONSELECT					,IEXP3	), // INPUT, TEXTAREA
	RW_Entry(ONSELECTSTART				,IE40	),
	RW_Entry(ONSUBMIT					,IEXP3	), // FORM
	RW_Entry(ONUNLOAD					,IEXP3	), // FRAMESET, BODY
	RW_Entry(OPENER						,IE40	),
	RW_Entry(OUTERHTML					,IE40	),
	RW_Entry(OUTERTEXT					,IE40	),
	RW_Entry(OUTLINE					,IEXP3	),
	RW_Entry(OVERFLOW					,IE40	),
	RW_Entry(OWNINGELEMENT				,IE40	),
	RW_Entry(PADDING					,IE40	),
	RW_Entry(PADDINGBOTTOM				,IE40	),
	RW_Entry(PADDINGLEFT				,IE40	),
	RW_Entry(PADDINGRIGHT				,IE40	),
	RW_Entry(PADDINGTOP					,IE40	),
	RW_Entry(PAGEBREAKAFTER				,IE40	),
	RW_Entry(PAGEBREAKBEFORE			,IE40	),
	RW_Entry(PALETTE					,IE40	),
	RW_Entry(PARENT						,IE40	),
	RW_Entry(PARENTELEMENT				,IE40	),
	RW_Entry(PARENTSTYLESHEET			,IE40	),
	RW_Entry(PARENTTEXTEDIT				,IE40	),
	RW_Entry(PARENTWINDOW				,IE40	),
	RW_Entry(PATHNAME					,IE40	),
	RW_Entry(PIXELHEIGHT				,IE40	),
	RW_Entry(PIXELLEFT					,IE40	),
	RW_Entry(PIXELTOP					,IE40	),
	RW_Entry(PIXELWIDTH					,IE40	),
	RW_Entry(PLUGINS					,IE40	),
	RW_Entry(PLUGINSPAGE				,IE40	),
	RW_Entry(PORT						,IE40	),
	RW_Entry(POSHEIGHT					,IE40	),
	RW_Entry(POSITION					,IE40	),
	RW_Entry(POSLEFT					,IE40	),
	RW_Entry(POSTOP						,IE40	),
	RW_Entry(POSWIDTH					,IE40	),
	RW_Entry(PROMPT						,IEXPn	),
	RW_Entry(PROTOCOL					,IE40	),
	RW_Entry(READONLY					,IE40	),
	RW_Entry(READYSTATE					,IE40	),
	RW_Entry(REASON						,IE40	),
	RW_Entry(RECORDNUMBER				,IE40	),
	RW_Entry(RECORDSET					,IE40	),
	RW_Entry(REF						,IEXP3	),
	RW_Entry(REFERRER					,IE40	),
	RW_Entry(REL						,ALL	),
	RW_Entry(RETURNVALUE				,IE40	),
	RW_Entry(REV						,ALL	),
	RW_Entry(RIGHTMARGIN				,IEXPn	),
	RW_Entry(ROWS						,ALL	),
	RW_Entry(ROWSPAN					,IEXPn	), // tables
	RW_Entry(RULES						,IEXP3	),
	RW_Entry(RUNAT						,IEXP3	), // SCRIPT
	RW_Entry(SCREENX					,IE40	),
	RW_Entry(SCREENY					,IE40	),
	RW_Entry(SCRIPTENGINE				,IEXP3	),
	RW_Entry(SCROLL						,IE40	),
	RW_Entry(SCROLLAMOUNT				,IEXPn	), // MARQUEE
	RW_Entry(SCROLLDELAY				,IEXPn	), // MARQUEE
	RW_Entry(SCROLLHEIGHT				,IE40	),
	RW_Entry(SCROLLING					,IEXP3	), // frameset
	RW_Entry(SCROLLLEFT					,IE40	),
	RW_Entry(SCROLLTOP					,IE40	),
	RW_Entry(SCROLLWIDTH				,IE40	),
	RW_Entry(SEARCH						,IE40	),
	RW_Entry(SELECTED					,ALL	),
	RW_Entry(SELECTEDINDEX				,IE40	),
	RW_Entry(SELF						,IE40	),
	RW_Entry(SHAPE						,IEXPn	),
	RW_Entry(SHAPES						,IEXP3	), //objects
	RW_Entry(SHIFTKEY					,IE40	),
	RW_Entry(SIZE						,ALL	),
	RW_Entry(SOURCEINDEX				,IE40	),
	RW_Entry(SPAN						,IEXP3	),
	RW_Entry(SRC						,ALL	),
	RW_Entry(SRCELEMENT					,IE40	),
	RW_Entry(SRCFILTER					,IE40	),
	RW_Entry(STANDBY					,IEXP3	), //objects
	RW_Entry(START						,IEXPn	),
	RW_Entry(STARTSPAN					,ALL	),	// Designer control tags
	RW_Entry(STATUS						,IE40	),
	RW_Entry(STYLE						,IEXP3	),
	RW_Entry(STYLEFLOAT					,IE40	),
	RW_Entry(TABINDEX					,IEXP3	),
	RW_Entry(TAGNAME					,IE40	),
	RW_Entry(TARGET						,IEXP3	),
	RW_Entry(TEXT						,IEXPn	),
	RW_Entry(TEXTALIGN					,IE40	),
	RW_Entry(TEXTDECORATION				,IE40	),
	RW_Entry(TEXTDECORATIONBLINK		,IE40	),
	RW_Entry(TEXTDECORATIONLINETHROUGH	,IE40	),
	RW_Entry(TEXTDECORATIONNONE			,IE40	),
	RW_Entry(TEXTDECORATIONOVERLINE		,IE40	),
	RW_Entry(TEXTDECORATIONUNDERLINE	,IE40	),
	RW_Entry(TEXTINDENT					,IE40	),
	RW_Entry(TEXTTRANSFORM				,IE40	),
	RW_Entry(TITLE						,ALL	),
	RW_Entry(TOELEMENT					,IE40	),
	RW_Entry(TOP						,IE40	),
	RW_Entry(TOPMARGIN					,IEXPn	),
	RW_Entry(TRUESPEED					,IE40	),
	RW_Entry(TYPE						,IEXPn	),
	RW_Entry(UPDATEINTERVAL				,IE40	),
	RW_Entry(URL						,IEXP3	),
	RW_Entry(URN						,ALL	),
	RW_Entry(USEMAP						,IEXPn	),
	RW_Entry(USERAGENT					,IE40	),
	RW_Entry(VALIGN						,IEXPn	),
	RW_Entry(VALUE						,ALL	),
	RW_Entry(VERSION					,IEXP3	),	// HTML
	RW_Entry(VERTICALALIGN				,IE40	),
	RW_Entry(VIEWASTEXT					,ALL	),	// ViewAsText for AspView only
	RW_Entry(VISIBILITY					,IE40	),
	RW_Entry(VLINK						,IEXPn	),
	RW_Entry(VLINKCOLOR					,IE40	),
	RW_Entry(VOLUME						,IE40	),
	RW_Entry(VRML						,IEXPn	),
	RW_Entry(VSPACE						,IEXPn	),
	RW_Entry(WIDTH						,ALL	),
	RW_Entry(WRAP						,IEXP3	),
	RW_Entry(X							,IE40	),
	RW_Entry(Y							,IE40	),
	RW_Entry(ZINDEX						,IE40	),
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static int _rgIndexAttributeNames[] = // [Attributes]
{
	/* A */	TokAttrib_ACCESSKEY			,
	/* B */	TokAttrib_BACKGROUND		,
	/* C */	TokAttrib_CANCELBUBBLE		,
	/* D */	TokAttrib_DATA				,
	/* E */	TokAttrib_ENCODING			,
	/* F */	TokAttrib_FACE				,
	/* G */	0							,
	/* H */	TokAttrib_HASH				,
	/* I */	TokAttrib_ID				,
	/* J */	0							,
	/* K */	0							,
	/* L */	TokAttrib_LANG				,
	/* M */	TokAttrib_MAP				,
	/* N */	TokAttrib_NAME				,
	/* O */	TokAttrib_OBJECT			,
	/* P */	TokAttrib_PADDING			,
	/* Q */	0							,
	/* R */	TokAttrib_READONLY			,
	/* S */	TokAttrib_SCREENX			,
	/* T */	TokAttrib_TABINDEX			,
	/* U */	TokAttrib_UPDATEINTERVAL	,
	/* V */	TokAttrib_VALIGN			,
	/* W */	TokAttrib_WIDTH				,
	/* X */	TokAttrib_X					,
	/* Y */	TokAttrib_Y					,
	/* Z */	TokAttrib_ZINDEX
};

//
// Entities
//
// ALL   - Basic             - RFC 1866, 9.7.1. Numeric and Special Graphic Entity Set
// ALL   - ISO Latin 1       - RFC 1866, 9.7.2. ISO Latin 1 Character Entity Set
// IEXPn - ISO Latin 1 Added - RFC 1866, 14.    Proposed Entities
//
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static ReservedWord _rgEntity[] =
{
    _T(""),       0,      0,
    _T("AElig"),  5,      ALL,    // <!ENTITY AElig  CDATA "&#198;") -- capital AE diphthong (ligature) -->
    _T("Aacute"), 6,      ALL,    // <!ENTITY Aacute CDATA "&#193;") -- capital A, acute accent -->
    _T("Acirc"),  5,      ALL,    // <!ENTITY Acirc  CDATA "&#194;") -- capital A, circumflex accent -->
    _T("Agrave"), 6,      ALL,    // <!ENTITY Agrave CDATA "&#192;") -- capital A, grave accent -->
    _T("Aring"),  5,      ALL,    // <!ENTITY Aring  CDATA "&#197;") -- capital A, ring -->
    _T("Atilde"), 6,      ALL,    // <!ENTITY Atilde CDATA "&#195;") -- capital A, tilde -->
    _T("Auml"),   4,      ALL,    // <!ENTITY Auml   CDATA "&#196;") -- capital A, dieresis or umlaut mark -->
    _T("Ccedil"), 6,      ALL,    // <!ENTITY Ccedil CDATA "&#199;") -- capital C, cedilla -->
    _T("ETH"),    3,      ALL,    // <!ENTITY ETH    CDATA "&#208;") -- capital Eth, Icelandic -->
    _T("Eacute"), 6,      ALL,    // <!ENTITY Eacute CDATA "&#201;") -- capital E, acute accent -->
    _T("Ecirc"),  5,      ALL,    // <!ENTITY Ecirc  CDATA "&#202;") -- capital E, circumflex accent -->
    _T("Egrave"), 6,      ALL,    // <!ENTITY Egrave CDATA "&#200;") -- capital E, grave accent -->
    _T("Euml"),   4,      ALL,    // <!ENTITY Euml   CDATA "&#203;") -- capital E, dieresis or umlaut mark -->
    _T("Iacute"), 6,      ALL,    // <!ENTITY Iacute CDATA "&#205;") -- capital I, acute accent -->
    _T("Icirc"),  5,      ALL,    // <!ENTITY Icirc  CDATA "&#206;") -- capital I, circumflex accent -->
    _T("Igrave"), 6,      ALL,    // <!ENTITY Igrave CDATA "&#204;") -- capital I, grave accent -->
    _T("Iuml"),   4,      ALL,    // <!ENTITY Iuml   CDATA "&#207;") -- capital I, dieresis or umlaut mark -->
    _T("Ntilde"), 6,      ALL,    // <!ENTITY Ntilde CDATA "&#209;") -- capital N, tilde -->
    _T("Oacute"), 6,      ALL,    // <!ENTITY Oacute CDATA "&#211;") -- capital O, acute accent -->
    _T("Ocirc"),  5,      ALL,    // <!ENTITY Ocirc  CDATA "&#212;") -- capital O, circumflex accent -->
    _T("Ograve"), 6,      ALL,    // <!ENTITY Ograve CDATA "&#210;") -- capital O, grave accent -->
    _T("Oslash"), 6,      ALL,    // <!ENTITY Oslash CDATA "&#216;") -- capital O, slash -->
    _T("Otilde"), 6,      ALL,    // <!ENTITY Otilde CDATA "&#213;") -- capital O, tilde -->
    _T("Ouml"),   4,      ALL,    // <!ENTITY Ouml   CDATA "&#214;") -- capital O, dieresis or umlaut mark -->
    _T("THORN"),  5,      ALL,    // <!ENTITY THORN  CDATA "&#222;") -- capital THORN, Icelandic -->
    _T("Uacute"), 6,      ALL,    // <!ENTITY Uacute CDATA "&#218;") -- capital U, acute accent -->
    _T("Ucirc"),  5,      ALL,    // <!ENTITY Ucirc  CDATA "&#219;") -- capital U, circumflex accent -->
    _T("Ugrave"), 6,      ALL,    // <!ENTITY Ugrave CDATA "&#217;") -- capital U, grave accent -->
    _T("Uuml"),   4,      ALL,    // <!ENTITY Uuml   CDATA "&#220;") -- capital U, dieresis or umlaut mark -->
    _T("Yacute"), 6,      ALL,    // <!ENTITY Yacute CDATA "&#221;") -- capital Y, acute accent -->
    _T("aacute"), 6,      ALL,    // <!ENTITY aacute CDATA "&#225;") -- small a, acute accent -->
    _T("acirc"),  5,      ALL,    // <!ENTITY acirc  CDATA "&#226;") -- small a, circumflex accent -->
	_T("acute"),  5,      IEXPn,  // <!ENTITY acute  CDATA "&#180;") -- acute accent -->
    _T("aelig"),  5,      ALL,    // <!ENTITY aelig  CDATA "&#230;") -- small ae diphthong (ligature) -->
    _T("agrave"), 6,      ALL,    // <!ENTITY agrave CDATA "&#224;") -- small a, grave accent -->
	_T("amp"),    3,      ALL,
    _T("aring"),  5,      ALL,    // <!ENTITY aring  CDATA "&#229;") -- small a, ring -->
    _T("atilde"), 6,      ALL,    // <!ENTITY atilde CDATA "&#227;") -- small a, tilde -->
    _T("auml"),   4,      ALL,    // <!ENTITY auml   CDATA "&#228;") -- small a, dieresis or umlaut mark -->
	_T("brvbar"), 6,      IEXPn,  // <!ENTITY brvbar CDATA "&#166;") -- broken (vertical) bar -->
    _T("ccedil"), 6,      ALL,    // <!ENTITY ccedil CDATA "&#231;") -- small c, cedilla -->
	_T("cedil"),  5,      IEXPn,  // <!ENTITY cedil  CDATA "&#184;") -- cedilla -->
	_T("cent"),   4,      IEXPn,  // <!ENTITY cent   CDATA "&#162;") -- cent sign -->
	_T("copy"),   4,      IEXPn,  // <!ENTITY copy   CDATA "&#169;") -- copyright sign -->
	_T("curren"), 6,      IEXPn,  // <!ENTITY curren CDATA "&#164;") -- general currency sign -->
	_T("deg"),    3,      IEXPn,  // <!ENTITY deg    CDATA "&#176;") -- degree sign -->
	_T("divide"), 6,      IEXPn,  // <!ENTITY divide CDATA "&#247;") -- divide sign -->
    _T("eacute"), 6,      ALL,    // <!ENTITY eacute CDATA "&#233;") -- small e, acute accent -->
    _T("ecirc"),  5,      ALL,    // <!ENTITY ecirc  CDATA "&#234;") -- small e, circumflex accent -->
    _T("egrave"), 6,      ALL,    // <!ENTITY egrave CDATA "&#232;") -- small e, grave accent -->
    _T("eth"),    3,      ALL,    // <!ENTITY eth    CDATA "&#240;") -- small eth, Icelandic -->
    _T("euml"),   4,      ALL,    // <!ENTITY euml   CDATA "&#235;") -- small e, dieresis or umlaut mark -->
	_T("frac12"), 6,      IEXPn,  // <!ENTITY frac12 CDATA "&#189;") -- fraction one-half -->
	_T("frac14"), 6,      IEXPn,  // <!ENTITY frac14 CDATA "&#188;") -- fraction one-quarter -->
	_T("frac34"), 6,      IEXPn,  // <!ENTITY frac34 CDATA "&#190;") -- fraction three-quarters -->
	_T("gt"),     2,      ALL,
    _T("iacute"), 6,      ALL,    // <!ENTITY iacute CDATA "&#237;") -- small i, acute accent -->
    _T("icirc"),  5,      ALL,    // <!ENTITY icirc  CDATA "&#238;") -- small i, circumflex accent -->
	_T("iexcl"),  5,      IEXPn,  // <!ENTITY iexcl  CDATA "&#161;") -- inverted exclamation mark -->
    _T("igrave"), 6,      ALL,    // <!ENTITY igrave CDATA "&#236;") -- small i, grave accent -->
	_T("iquest"), 6,      IEXPn,  // <!ENTITY iquest CDATA "&#191;") -- inverted question mark -->
    _T("iuml"),   4,      ALL,    // <!ENTITY iuml   CDATA "&#239;") -- small i, dieresis or umlaut mark -->
	_T("laquo"),  5,      IEXPn,  // <!ENTITY laquo  CDATA "&#171;") -- angle quotation mark, left -->
	_T("lt"),     2,      ALL,
	_T("macr"),   4,      IEXPn,  // <!ENTITY macr   CDATA "&#175;") -- macron -->
	_T("micro"),  5,      IEXPn,  // <!ENTITY micro  CDATA "&#181;") -- micro sign -->
	_T("middot"), 6,      IEXPn,  // <!ENTITY middot CDATA "&#183;") -- middle dot -->
	_T("nbsp"),   4,      IEXPn,  // <!ENTITY nbsp   CDATA "&#160;") -- no-break space -->
	_T("not"),    3,      IEXPn,  // <!ENTITY not    CDATA "&#172;") -- not sign -->
    _T("ntilde"), 6,      ALL,    // <!ENTITY ntilde CDATA "&#241;") -- small n, tilde -->
    _T("oacute"), 6,      ALL,    // <!ENTITY oacute CDATA "&#243;") -- small o, acute accent -->
    _T("ocirc"),  5,      ALL,    // <!ENTITY ocirc  CDATA "&#244;") -- small o, circumflex accent -->
    _T("ograve"), 6,      ALL,    // <!ENTITY ograve CDATA "&#242;") -- small o, grave accent -->
	_T("ordf"),   4,      IEXPn,  // <!ENTITY ordf   CDATA "&#170;") -- ordinal indicator, feminine -->
	_T("ordm"),   4,      IEXPn,  // <!ENTITY ordm   CDATA "&#186;") -- ordinal indicator, masculine -->
    _T("oslash"), 6,      ALL,    // <!ENTITY oslash CDATA "&#248;") -- small o, slash -->
    _T("otilde"), 6,      ALL,    // <!ENTITY otilde CDATA "&#245;") -- small o, tilde -->
    _T("ouml"),   4,      ALL,    // <!ENTITY ouml   CDATA "&#246;") -- small o, dieresis or umlaut mark -->
	_T("para"),   4,      IEXPn,  // <!ENTITY para   CDATA "&#182;") -- pilcrow (paragraph sign) -->
	_T("plusmn"), 6,      IEXPn,  // <!ENTITY plusmn CDATA "&#177;") -- plus-or-minus sign -->
	_T("pound"),  5,      IEXPn,  // <!ENTITY pound  CDATA "&#163;") -- pound sterling sign -->
	_T("quot"),   4,      ALL,
	_T("raquo"),  5,      IEXPn,  // <!ENTITY raquo  CDATA "&#187;") -- angle quotation mark, right -->
	_T("reg"),    3,      IEXPn,  // <!ENTITY reg    CDATA "&#174;") -- registered sign -->
	_T("sect"),   4,      IEXPn,  // <!ENTITY sect   CDATA "&#167;") -- section sign -->
	_T("shy"),    3,      IEXPn,  // <!ENTITY shy    CDATA "&#173;") -- soft hyphen -->
	_T("sup1"),   4,      IEXPn,  // <!ENTITY sup1   CDATA "&#185;") -- superscript one -->
	_T("sup2"),   4,      IEXPn,  // <!ENTITY sup2   CDATA "&#178;") -- superscript two -->
	_T("sup3"),   4,      IEXPn,  // <!ENTITY sup3   CDATA "&#179;") -- superscript three -->
    _T("szlig"),  5,      ALL,    // <!ENTITY szlig  CDATA "&#223;") -- small sharp s, German (sz ligature)->
    _T("thorn"),  5,      ALL,    // <!ENTITY thorn  CDATA "&#254;") -- small thorn, Icelandic -->
	_T("times"),  5,      IEXPn,  // <!ENTITY times  CDATA "&#215;") -- multiply sign -->
    _T("uacute"), 6,      ALL,    // <!ENTITY uacute CDATA "&#250;") -- small u, acute accent -->
    _T("ucirc"),  5,      ALL,    // <!ENTITY ucirc  CDATA "&#251;") -- small u, circumflex accent -->
    _T("ugrave"), 6,      ALL,    // <!ENTITY ugrave CDATA "&#249;") -- small u, grave accent -->
	_T("uml"),    3,      IEXPn,  // <!ENTITY uml    CDATA "&#168;") -- umlaut (dieresis) -->
    _T("uuml"),   4,      ALL,    // <!ENTITY uuml   CDATA "&#252;") -- small u, dieresis or umlaut mark -->
    _T("yacute"), 6,      ALL,    // <!ENTITY yacute CDATA "&#253;") -- small y, acute accent -->
	_T("yen"),    3,      IEXPn,  // <!ENTITY yen    CDATA "&#165;") -- yen sign -->
    _T("yuml"),   4,      ALL,    // <!ENTITY yuml   CDATA "&#255;") -- small y, dieresis or umlaut mark -->

};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static int _rgIndexEntity[] =
{
//  A   B   C   D   E   F   G   H   I   J   K   L   M
	1,  0,  8,  0,  9,  0,  0,  0, 14,  0,  0,  0,  0,
//  N   O   P   Q   R   S   T   U   V   W   X   Y   Z
   18, 19,  0,  0,  0,  0, 25, 26,  0,  0,  0, 30,  0,
//  a   b   c   d   e   f   g   h   i   j   k   l   m
   31, 40, 41, 46, 48, 53, 56,  0, 57,  0,  0, 63, 65,
//  n   o   p   q   r   s   t   u   v   w   x   y   z
   68, 71, 79, 82, 83, 85, 91, 93,  0,  0,  0, 98,  0
};

////////////////////////////////////////////////////////////////////////////


//
//
//	int LookupLinearKeyword
//
//	Description:
//		Does the lookup in the given table.
//		Returns index into table if found, NOT_FOUND otw.
//
int LookupLinearKeyword
(
	ReservedWord 	*rwTable,
	int 			cel,
	RWATT_T 		att,
	LPCTSTR 		pchLine,
	int 			cbLen,
	BOOL 			bCase /* = NOCASE */
)
{
	int iTable = 0;
	ASSERT(cel > 0);

	PFNNCMP pfnNCmp = bCase ? (_tcsncmp) : (_tcsnicmp);

	do
	{
		int Cmp;
		if (0 == (Cmp = pfnNCmp(pchLine, rwTable[iTable].psz, cbLen)) &&
			 (cbLen == rwTable[iTable].cb))
			return (0 != (rwTable[iTable].att & att)) ? iTable : NOT_FOUND;
		else if (Cmp < 0)
			return NOT_FOUND;
		else
			iTable++;
	} while (iTable < cel);
	return NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////////
//  LookupIndexedKeyword()
//
int LookupIndexedKeyword
(
	ReservedWord 	*rwTable,
	int 			cel,
	int * 			indexTable,
	RWATT_T 		att,
	LPCTSTR 		pchLine,
	int 			cbLen,
	BOOL 			bCase 	/* = NOCASE */
)
{
	// lookup table:
	int iTable;
	int index = PeekIndex(*pchLine, bCase);
	if (index < 0)
		return NOT_FOUND;
	else
		iTable = indexTable[index];
	if (0 == iTable)
		return NOT_FOUND;
	int iFound = LookupLinearKeyword(&rwTable[iTable], cel - iTable,
		att, pchLine, cbLen, bCase);

	return (iFound == NOT_FOUND) ? NOT_FOUND : iTable + iFound;
}

////////////////////////////////////////////////////////////////////////////
// hinting table - character classification

// HOP
// () ? , | + [] * =
//   in tag, op
//
// HDA
// - op
// -- comment
//
// HEN
// & in text, entity ref
//   in tag, op
//
// HEP
// % in tag, parameter entity ref (%name) or op (%WS)
//
// HRN
// # reserved name
//
// HTA
// <    tag open
// </   tag end
// <!   MDO Markup delimiter open
// <?   processing instruction - what's the syntax for a complete PI tag?

// Hint table:
HINT g_hintTable[128] =
{
//    0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    EOS, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, HWS, ONL, ERR, ERR, ERR, ERR, ERR,
//   10   11   12   13   14   15   16   17   18   19   1a   1b   1c   1d   1e   1f
    ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR,
//  spc   !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /
    HWS, ERR, HST, HRN, ERR, HEP, HEN, HSL, OLP, ORP, OST, OPL, OCO, ODA, HKW, HAV,
//   0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?
    HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, ERR, ERR, HTA, OEQ, HTE, OQU,
//   @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
    ERR, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW,
//   P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _
    HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, OLB, HAV, ORB, ERR, HAV,
//   `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
    ERR, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW,
//   p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~   DEL
    HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, ERR, OPI, ERR, ERR, ERR
};

////////////////////////////////////////////////////////////////////////////
// content model
//
// Map between element / lex state
//

// 0-terminated list
// if we get more, consider putting text state in element table
static ELLEX _ElTextStateTable[] =
{
	_T("COMMENT"),   7, inCOMMENT,
	_T("LISTING"),   7, inLISTING,
	_T("PLAINTEXT"), 9, inPLAINTEXT,
	_T("SCRIPT"),	 6, inSCRIPT,
	_T("XMP"),       3, inXMP,
	0, 0, 0
};

DWORD TextStateFromElement(LPCTSTR szEl, int cb)
{
	int cmp;
	for (ELLEX *pel = _ElTextStateTable; pel->sz != 0; pel++)
	{
		if (0 == (cmp = _tcsnicmp(pel->sz, szEl, cb)))
		{
			if (cb == pel->cb)
				return pel->lxs;
		}
		else if (cmp > 0)
			return 0;
	}
	return 0;
}

ELLEX * pellexFromTextState(DWORD state)
{
	DWORD t = (state & TEXTMASK); // only want text state bits
	for (ELLEX *pellex = _ElTextStateTable; pellex->lxs != 0; pellex++)
	{
		if (t == pellex->lxs)
			return pellex;
	}
	return 0;
}


////////////////////////////////////////////////////////////////////////////
// CStaticTable
CStaticTable::CStaticTable(RWATT_T att,
						   ReservedWord *prgrw,
						   UINT cel,
						   int *prgi /*= NULL*/,
						   BOOL bCase /*= FALSE*/,
						   LPCTSTR szName /*= NULL*/)
: m_att(att), m_prgrw(prgrw), m_cel(cel), m_prgi(prgi), m_bCase(bCase)
{
	ASSERT(NULL != m_prgrw);
	ASSERT(m_cel > 0);
	ASSERT(0 == CheckWordTable(m_prgrw, cel, szName));
	if (NULL == m_prgi)
	{
		MakeIndex(m_prgrw, m_cel, &m_prgi, m_bCase, szName);
	}
	else
		ASSERT(0 == CheckWordTableIndex(m_prgrw, cel, prgi, m_bCase, szName));
}

int CStaticTable::Find(LPCTSTR pch, int cb)
{
	return LookupIndexedKeyword(m_prgrw, m_cel, m_prgi, m_att, pch, cb, m_bCase);
}

////////////////////////////////////////////////////////////////////////////
CStaticTableSet::CStaticTableSet(RWATT_T att, UINT nIdName)
:	m_Elements  ( att, _rgElementNames, CELEM_ARRAY(_rgElementNames),
				 _rgIndexElementNames, NOCASE, szElTag ),
	m_Attributes( att, _rgAttributeNames, CELEM_ARRAY(_rgAttributeNames),
				 _rgIndexAttributeNames, NOCASE, szAttTag ),
	m_Entities  ( att, _rgEntity, CELEM_ARRAY(_rgEntity),
				 _rgIndexEntity, CASE, szEntTag )
{
	::LoadString(	_Module.GetModuleInstance(),
					nIdName,
					m_strName,
					sizeof(m_strName)
					);
}

int CStaticTableSet::FindElement(LPCTSTR pch, int cb)
{
	return m_Elements.Find(pch, cb);
}

int CStaticTableSet::FindAttribute(LPCTSTR pch, int cb)
{
	return m_Attributes.Find(pch, cb);
}

int CStaticTableSet::FindEntity(LPCTSTR pch, int cb)
{
	return m_Entities.Find(pch, cb);
}

CStaticTableSet * g_pTabDefault;
PTABLESET g_pTable = 0;

////////////////////////////////////////////////////////////////////////////
//
// Custom HTML tables
//
/*

@HLX@ "Internet Explorer 3.0"
;Custom HTML tagset file must begin with the "@HLX@"
;signature and the name of the HTML variant in quotes.

[Elements]
; element set

[Attributes]
; attribute set

[Entities]
; entity set

*/

// qsort/bsearch helper
int CmpFunc(const void *a, const void *b)
{
	CLStr *A = (CLStr*)a;
	CLStr *B = (CLStr*)b;
	int r = memcmp(A->m_rgb, B->m_rgb, __min(A->m_cb, B->m_cb));
	return (0 == r) ? (A->m_cb - B->m_cb) : r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\triedcid.h ===
// triedcid.h : Command IDs for TriEdit's IOleCommandTarget
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef __TRIEDCID_H__
#define __TRIEDCID_H__

// GUID_TriEditCommandGroup {2582F1C0-084E-11d1-9A0E-006097C9B344}

#define IDM_TRIED_NUDGE_ELEMENT             2   //[in,VT_BYREF VARIANT.byref=LPPOINT]
#define IDM_TRIED_SET_ALIGNMENT             3   //[in,VT_BYREF VARIANT.byref=LPPOINT]
#define IDM_TRIED_MAKE_ABSOLUTE             4
#define IDM_TRIED_LOCK_ELEMENT              5
#define IDM_TRIED_SEND_TO_BACK              6
#define IDM_TRIED_BRING_TO_FRONT            7
#define IDM_TRIED_SEND_BACKWARD             8
#define IDM_TRIED_BRING_FORWARD             9
#define IDM_TRIED_SEND_BELOW_TEXT          10 
#define IDM_TRIED_BRING_ABOVE_TEXT         11
#define IDM_TRIED_CONSTRAIN                12   //[in,VT_BOOL]
#define IDM_TRIED_ABSOLUTE_DROP_MODE       13   //[in,VT_BOOL]
#define IDM_TRIED_INSERTROW                14
#define IDM_TRIED_INSERTCOL                15
#define IDM_TRIED_DELETEROWS               16
#define IDM_TRIED_DELETECOLS               17
#define IDM_TRIED_MERGECELLS               18
#define IDM_TRIED_SPLITCELL                19
#define IDM_TRIED_INSERTCELL               20
#define IDM_TRIED_DELETECELLS              21
#define IDM_TRIED_INSERTTABLE              22   //[in, VT_ARRAY]
#define IDM_TRIED_ACTIVATEACTIVEXCONTROLS  23
#define IDM_TRIED_ACTIVATEAPPLETS          24
#define IDM_TRIED_ACTIVATEDTCS             25
#define IDM_TRIED_BACKCOLOR                26
#define IDM_TRIED_BLOCKFMT                 27
#define IDM_TRIED_BOLD                     28
#define IDM_TRIED_BROWSEMODE               29
#define IDM_TRIED_COPY                     30
#define IDM_TRIED_CUT                      31
#define IDM_TRIED_DELETE                   32
#define IDM_TRIED_EDITMODE                 33
#define IDM_TRIED_FIND                     34
#define IDM_TRIED_FONT                     35
#define IDM_TRIED_FONTNAME                 36
#define IDM_TRIED_FONTSIZE                 37
#define IDM_TRIED_FORECOLOR                38
#define IDM_TRIED_GETBLOCKFMTS             39
#define IDM_TRIED_HYPERLINK                40
#define IDM_TRIED_IMAGE                    41
#define IDM_TRIED_INDENT                   42
#define IDM_TRIED_ITALIC                   43
#define IDM_TRIED_JUSTIFYCENTER            44
#define IDM_TRIED_JUSTIFYLEFT              45
#define IDM_TRIED_JUSTIFYRIGHT             46
#define IDM_TRIED_ORDERLIST                47
#define IDM_TRIED_OUTDENT                  48
#define IDM_TRIED_PASTE                    50
#define IDM_TRIED_PRINT                    51
#define IDM_TRIED_REDO                     52
#define IDM_TRIED_REMOVEFORMAT             53
#define IDM_TRIED_SELECTALL                54
#define IDM_TRIED_SHOWBORDERS              55
#define IDM_TRIED_SHOWDETAILS              56
#define IDM_TRIED_UNDERLINE                57
#define IDM_TRIED_UNDO                     58
#define IDM_TRIED_UNLINK                   59
#define IDM_TRIED_UNORDERLIST              60
#define IDM_TRIED_DOVERB                   61

//WARNING WARNING WARNING!!! Don't forget to modify IDM_TRIED_LAST_CID
//when you add new Command IDs

#define IDM_TRIED_LAST_CID             IDM_TRIED_DOVERB

//These are old command IDs that are here for backward compatibility
//We don't recommend using these any more
#define IDM_TRIED_IS_1D_ELEMENT         0   //[out,VT_BOOL]
#define IDM_TRIED_IS_2D_ELEMENT         1   //[out,VT_BOOL]
#define IDM_TRIED_SEND_TO_FRONT         IDM_TRIED_BRING_TO_FRONT
#define IDM_TRIED_SEND_FORWARD          IDM_TRIED_BRING_FORWARD
#define IDM_TRIED_SEND_BEHIND_1D        IDM_TRIED_SEND_BELOW_TEXT
#define IDM_TRIED_SEND_FRONT_1D         IDM_TRIED_BRING_ABOVE_TEXT
#define IDM_TRIED_SET_2D_DROP_MODE      IDM_TRIED_ABSOLUTE_DROP_MODE

#endif //__TRIEDCID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\undo.h ===
// undo.h
// Undo manager functions
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __UNDO_H__
#define __UNDO_H__

// {6501DC80-12A6-11d1-9A15-006097C9B344}
DEFINE_GUID(UID_TRIEDIT_UNDO, 
0x6501dc80, 0x12a6, 0x11d1, 0x9a, 0x15, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

#define cUndoPackMax		1024

//Add a constant when creating new undoable objects
#define TRIEDIT_UNDO_DRAG	0
#define TRIEDIT_UNDO_PACK	1

//Use this method to add undoable objects to Trident's stack
HRESULT AddUndoUnit(IUnknown* punkTrident, IOleUndoUnit* pioleUndoUnit);


class CUndo : public IOleUndoUnit
{
protected:
    ULONG m_cRef;
    BOOL m_fUndo;

public:
    CUndo();
    virtual ~CUndo();

    //IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager) PURE;
    STDMETHOD (GetDescription)(BSTR *pBstr) PURE;
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID) PURE;
    STDMETHOD (OnNextAdd)(void) PURE;
};

class CUndoDrag : public CUndo
{
protected:
    IHTMLStyle* m_pihtmlStyle;
    POINT m_ptOrig;
    POINT m_ptMove;

public:
    CUndoDrag(IHTMLStyle* pihtmlStyle, POINT m_ptOrig, POINT m_ptMove);
    virtual ~CUndoDrag();

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager);
    STDMETHOD (GetDescription)(BSTR *pBstr);
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID);
    STDMETHOD (OnNextAdd)(void);
};

class CUndoPackUnit : public CUndo
{
protected:
    ULONG m_cRef;
    CComPtr<IOleUndoUnit> m_rgUndo[cUndoPackMax]; 
    
public:
    CUndoPackUnit() {};
    virtual ~CUndoPackUnit(){};

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager);
    STDMETHOD (GetDescription)(BSTR *pBstr);
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID);
    STDMETHOD (OnNextAdd)(void);

    HRESULT PackUndo(ULONG indexStartPacking, IUnknown *pUnkTrident);
};

class CUndoPackManager
{
protected:
    CComPtr<IUnknown> m_srpUnkTrident;
    ULONG m_indexStartPacking;
    BOOL m_fPacking;
    
public:
    CUndoPackManager(IUnknown* pUnkTrident)
            { m_srpUnkTrident=pUnkTrident; 
              m_indexStartPacking=0;
              m_fPacking=FALSE;
             };
             
    virtual ~CUndoPackManager();

    HRESULT Start(void);
    HRESULT End(void);
};
#endif //__UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\undo.cpp ===
//------------------------------------------------------------------------------
// undo.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Undo support routines for TriEdit
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <ocidl.h>

#include "undo.h"
#include "triedit.h"
#include "document.h"

///////////////////////////////////////////////////////////////////////////////
//
// AddUndoUnit
//
// Add the given undo unit to the given Trident instance. Return S_OK
// or a Trident error code.
//

HRESULT AddUndoUnit(IUnknown* punkTrident, IOleUndoUnit* pioleUndoUnit)
{
    HRESULT hr = E_FAIL;
    IServiceProvider* piservProv;
    IOleUndoManager* pioleUndoManager;
    
    if (punkTrident && pioleUndoUnit)
    {
        hr = punkTrident->QueryInterface(IID_IServiceProvider, (LPVOID*)&piservProv);

        if (SUCCEEDED(hr))
        {
            _ASSERTE(piservProv);
            hr = piservProv->QueryService(IID_IOleUndoManager,
                    IID_IOleUndoManager, (LPVOID*)&pioleUndoManager);

            if (SUCCEEDED(hr))
            {
                _ASSERTE(pioleUndoManager);
                hr = pioleUndoManager->Add(pioleUndoUnit);
                _ASSERTE(SUCCEEDED(hr));
                pioleUndoManager->Release();
            }
            piservProv->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// EmptyUndoRedoStack
//
// If fUndo is TRUE, discard all undo items from the given undo manager.
// If fUndo is FALSE, discard all redo items from the given undo manager
// Return S_OK if all goes well, or a Trident error code otherwise.
//

HRESULT EmptyUndoRedoStack(BOOL fUndo, IOleUndoManager *pUndoManager)
{
	CComPtr<IEnumOleUndoUnits> srpEnum;
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0, cTotal=0;
	HRESULT hr = E_FAIL;
	
    if (fUndo)
    {
		if (FAILED(hr = pUndoManager->EnumUndoable(&srpEnum)))
			goto Fail;
	}
	else
	{
		if (FAILED(hr = pUndoManager->EnumRedoable(&srpEnum)))
			goto Fail;
	}
	

    while (SUCCEEDED(srpEnum->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <=1);
        if (srpcd == NULL)
            break;
            
        cTotal++;
        srpcd.Release();
    }

	// get the one on top of the stack and discard from that
    if (cTotal > 0)
    {
    	if (FAILED(hr = srpEnum->Reset()))
        	goto Fail; 
    	if (FAILED(hr = srpEnum->Skip(cTotal-1)))
        	goto Fail;

    	srpcd.Release();
    	if (FAILED(hr = srpEnum->Next(1, &srpcd, &cFetched)))
        	goto Fail;

		_ASSERTE(cFetched ==1);
		
    	if (FAILED(hr = pUndoManager->DiscardFrom(srpcd)))
        	goto Fail;
	}

Fail:
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// GetUndoManager
//
// Obtain and return (under *ppOleUndoManager) the IOleUndoManager
// associated with the given Trident instance. Return S_OK if a 
// manager was returned; E_FAIL otherwise.
//

HRESULT GetUndoManager(IUnknown* punkTrident, IOleUndoManager **ppOleUndoManager)
{
   HRESULT hr = E_FAIL;
   CComPtr<IServiceProvider> srpiservProv;
   CComPtr<IOleUndoManager> srpioleUndoManager;

   _ASSERTE(ppOleUndoManager != NULL);
   _ASSERTE(punkTrident != NULL);
   if (punkTrident)
    {
        hr = punkTrident->QueryInterface(IID_IServiceProvider, (LPVOID*)&srpiservProv);

        if (SUCCEEDED(hr))
        {
            _ASSERTE(srpiservProv);
            if (SUCCEEDED(hr = srpiservProv->QueryService(IID_IOleUndoManager,
                    IID_IOleUndoManager, (LPVOID*)&srpioleUndoManager)))
            {
                *ppOleUndoManager = srpioleUndoManager;
                (*ppOleUndoManager)->AddRef();
            }
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndo::CUndo
// CUndo::~Undo
//
// Simple constructor and destructor for the CUndo class. 
//

CUndo::CUndo()
{
    m_cRef = 1;
    m_fUndo = TRUE;

}

CUndo::~CUndo()
{
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndo::QueryInterface (IUnknown method)
// CUndo::AddRef (IUnknown method)
// CUndo::Release (IUnknown method)
//
// Implementations of the three IUnknown methods.
//

STDMETHODIMP CUndo::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    if (!ppvObject) 
        return E_POINTER;
    if (IsEqualGUID(riid, IID_IUnknown))
        *ppvObject = (IUnknown*)this;
    else
    if (IsEqualGUID(riid, IID_IOleUndoUnit))
        *ppvObject = (IOleUndoUnit*)this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CUndo::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_cRef);
}

STDMETHODIMP_(ULONG) CUndo::Release(void)
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_cRef);
    if (!cRef)
        delete this;
    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::CUndoDrag
// CUndoDrag::~CUndoDrag
//
// Constructor for an object which can undo the drag of an HTML element.
//

CUndoDrag::CUndoDrag(IHTMLStyle* pihtmlStyle, POINT ptOrig, POINT ptMove)
{
    m_pihtmlStyle = pihtmlStyle;
    if (m_pihtmlStyle)
        m_pihtmlStyle->AddRef();
    m_ptOrig = ptOrig;
    m_ptMove = ptMove;
}

CUndoDrag::~CUndoDrag()
{
    SAFERELEASE(m_pihtmlStyle);
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::Do (IOleUndoUnit method)
//
// Do or undo dragging of an HTML element from place to place. Set or
// restore the item's position. Return S_OK.
//

STDMETHODIMP CUndoDrag::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    if (pUndoManager)
    {
        hr = pUndoManager->Add(this);        
    }
    if (m_pihtmlStyle)
    {
        // We do a put_pixelLeft(-1) and put_pixelTop(-1) below in order
        // to work around a Trident problem.  Sometimes they don't think
        // that anything has changed - these calls below fool them into
        // thinking that the values have changed.
        if (m_fUndo)
        {
            m_pihtmlStyle->put_pixelLeft(-1);
            m_pihtmlStyle->put_pixelLeft(m_ptOrig.x);
            m_pihtmlStyle->put_pixelTop(-1);
            m_pihtmlStyle->put_pixelTop(m_ptOrig.y);
        }
        else
        {
            m_pihtmlStyle->put_pixelLeft(-1);
            m_pihtmlStyle->put_pixelLeft(m_ptMove.x);
            m_pihtmlStyle->put_pixelTop(-1);
            m_pihtmlStyle->put_pixelTop(m_ptMove.y);
        }
        m_fUndo = !m_fUndo;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::GetDescription (IOleUndoUnit method)
//
// Return the description of the undo item. Note that this function
// returns an empty string since this is the only would-be localizable
// content in TriEdit.
//

STDMETHODIMP CUndoDrag::GetDescription(BSTR *pBstr)
{
    if (pBstr)
    {
        *pBstr = SysAllocString(_T(" "));
        return S_OK;
    }
    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::GetUnitType (IOleUndoUnit method)
//
// Return the CLSID and an identifier for the undo item.
//

STDMETHODIMP CUndoDrag::GetUnitType(CLSID *pClsid, LONG *plID)
{
    if (pClsid)
        *pClsid = UID_TRIEDIT_UNDO;
    if (plID)
        *plID = TRIEDIT_UNDO_DRAG;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::OnNextAdd (IOleUndoUnit method)
//
// Do nothing, but do it extremely well.
//

STDMETHODIMP CUndoDrag::OnNextAdd(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::~CUndoPackManager
//
// Destructor for a CUndoPackManager object. If currently packing undo
// items, end the packing before destroying the object. 
//

CUndoPackManager::~CUndoPackManager(void)
{
    if (m_fPacking)
        End();
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::Start
// 
// Called to tell the pack manager to begin accumulating subsequent
// undo units into a unit that can be undone in one fell swoop. Turn
// on the packing flag. Return S_OK if all goes well or E_FAIL if
// something goes wrong.
//

HRESULT CUndoPackManager::Start(void)
{
    HRESULT hr = E_FAIL;
    CComPtr<IOleUndoManager> srpioleUndoManager;
    CComPtr<IEnumOleUndoUnits> srpEnum;
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0;

    _ASSERTE(m_indexStartPacking==0);
    
    if (FAILED(hr = GetUndoManager(m_srpUnkTrident, &srpioleUndoManager)))
        goto Fail;

    if (FAILED(hr = srpioleUndoManager->EnumUndoable(&srpEnum)))
        goto Fail;

    while(SUCCEEDED(srpEnum->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <=1);
        if (srpcd == NULL)
            break;
            
        m_indexStartPacking++;
        srpcd.Release();
    }

    m_fPacking = TRUE;

 Fail:
    if (!m_fPacking)
        m_indexStartPacking=0;
        
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::End
//
// Called to tell the pack manager to stop accumulating undo units. Pack
// the accumulated undo units in to the parent undo unit and turn off
// the packing flag. Return S_OK if all goes well or E_FAIL if something
// goes wrong.
//

HRESULT CUndoPackManager::End(void)
{
    HRESULT hr = E_FAIL;
    CUndoPackUnit *pUndoParentUnit;
    
    _ASSERTE(m_srpUnkTrident != NULL);
    pUndoParentUnit = new CUndoPackUnit();
    _ASSERTE(pUndoParentUnit  != NULL);
    
    if (FAILED(hr = pUndoParentUnit->PackUndo(m_indexStartPacking, m_srpUnkTrident)))
        goto Fail;

    m_fPacking = FALSE;
Fail:
    pUndoParentUnit->Release();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::Do (IOleUndoUnit method)
//
// Invoke the Do method of each undo unit referenced by the object. Return
// S_OK.
//

STDMETHODIMP CUndoPackUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK; 

    for (INT i=sizeof(m_rgUndo)/sizeof(IOleUndoUnit*)-1; i >= 0; i--)
    {
        if (m_rgUndo[i] == NULL)
            continue;
        
        if (FAILED(hr = m_rgUndo[i]->Do(pUndoManager)))
            goto Fail;
    }

	::EmptyUndoRedoStack(FALSE, pUndoManager);
	
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::GetDescription (IOleUndoUnit method)
//
// Return the description of the undo item. Note that this function
// returns an empty string since this string would be one of only
// two localizable strings in TriEdit.
//

STDMETHODIMP CUndoPackUnit::GetDescription(BSTR *pBstr)
{
    if (pBstr)
    {
        // In order to save localization work for the two TriEdit strings, 
        // it was decided that we would return a blank string here
        *pBstr = SysAllocString(_T(" "));
        return S_OK;
    }
    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::GetUnitType (IOleUndoUnit method)
//
// Return the CLSID and an identifier for the undo item.
//

STDMETHODIMP CUndoPackUnit::GetUnitType(CLSID *pClsid, LONG *plID)
{
    if (pClsid)
        *pClsid = UID_TRIEDIT_UNDO;
    if (plID)
        *plID = TRIEDIT_UNDO_PACK;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::OnNextAdd (IOleUndoUnit method)
//
// Do nothing, but do it extremely well.
//

STDMETHODIMP CUndoPackUnit::OnNextAdd(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::PackUndo
//
// Pack all of the undo units starting at the given index in to
// the parent undo manager. Return S_OK if all goes well, or
// E_FAIL if something goes wrong.
//

HRESULT CUndoPackUnit::PackUndo(ULONG indexStartPacking, IUnknown *pUnkTrident)
{
    HRESULT hr = E_FAIL;
    CComPtr<IOleUndoManager> srpioleUndoManager;
    CComPtr<IEnumOleUndoUnits> srpEnumUndo;
    CComPtr<IOleUndoUnit> rgUndo[cUndoPackMax]; // CONSIDER: allocate dynamically
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0, cUndo=0, i=0;
    
    if (FAILED(hr = GetUndoManager(pUnkTrident, &srpioleUndoManager)))
        goto Fail;

    if (FAILED(hr = srpioleUndoManager->EnumUndoable(&srpEnumUndo)))
        goto Fail;
        
    _ASSERTE(srpEnumUndo != NULL);
    while(SUCCEEDED(srpEnumUndo->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <= 1);
        if (srpcd == NULL)
            break;
            
        cUndo++;
        srpcd.Release();
    }

    // if there's nothing to pack
    if ((cUndo-indexStartPacking) == 0)
        return S_OK;
        
    if ((cUndo-indexStartPacking) > cUndoPackMax)
        return E_OUTOFMEMORY;
        
    // get the undo units that we want to pack
    if (FAILED(hr = srpEnumUndo->Reset()))
        goto Fail; 
    if (FAILED(hr =srpEnumUndo->Skip(indexStartPacking)))
        goto Fail;
    if (FAILED(hr = srpEnumUndo->Next(cUndo-indexStartPacking, (IOleUndoUnit **) &m_rgUndo, &cFetched)))
        goto Fail;
    _ASSERTE(cFetched == (cUndo-indexStartPacking));
    
    // now clear the undo/redo stack and then adds back the undo unit except that one that we just packed
    if (FAILED(hr = srpEnumUndo->Reset()))
        goto Fail;

    if (FAILED(hr = srpEnumUndo->Next(cUndo, (IOleUndoUnit **) &rgUndo, &cFetched)))
        goto Fail;
        
    _ASSERTE(cFetched == cUndo);

    if (FAILED(hr = srpioleUndoManager->DiscardFrom(NULL)))
        goto Fail;

    for (i=0; i < indexStartPacking; i++)
    {
        if (FAILED(hr = srpioleUndoManager->Add(rgUndo[i])))
            goto Fail;
    }

    if (FAILED(hr = ::AddUndoUnit(pUnkTrident, this)))
        goto Fail;
Fail:   
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\util.h ===
// util.h : Utility inlines/functions
// Copyright (c)1999 Microsoft Corporation, All Rights Reserved
// added during 64 bit port of triedit.

// All throughout the triedit code, we assume that 
// the size of the document is not going to exceed
// 2GB. We assert the fact when we open the document
// in filter.cpp as well. If at later point, we do exceed 
// the document size of 2GB, we need to change this too.

// Safe conversion of pointer differences.

#ifndef __UTIL_H_
#define __UTIL_H_

inline WORD SAFE_PTR_DIFF_TO_WORD(SIZE_T lptrDiff)
{
    _ASSERTE(lptrDiff <= USHRT_MAX);
    return((WORD)lptrDiff);
};
inline WORD SAFE_INT_DIFF_TO_WORD(int iDiff)
{
    _ASSERTE(iDiff <= USHRT_MAX);
    return((WORD)iDiff);
};
inline int SAFE_PTR_DIFF_TO_INT(SIZE_T lptrDiff)
{
    _ASSERTE(lptrDiff <= UINT_MAX);
    return((int)lptrDiff);
};
inline DWORD SAFE_INT64_TO_DWORD(SIZE_T iValue)
{
    _ASSERTE(iValue <= UINT_MAX);
    return((DWORD)iValue);
};
#endif __UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\triedit.cpp ===
// triedit.cpp : Implementation of DLL Exports.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f trieditps.mk in the project directory.

#include "stdafx.h"

#include <initguid.h>

#include "resource.h"
#include "triedit.h"
#include "triedcid.h"       //IOleCommandTarget CIDs for TriEdit
#include "htmparse.h"
#include "Document.h"
#include "undo.h"
#include "triedit_i.c"

CComModule _Module;

static void SpikeSharedFileCount ();

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TriEditDocument, CTriEditDocument)
	OBJECT_ENTRY(CLSID_TriEditParse, CTriEditParse)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	SpikeSharedFileCount ();

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    ITypeLib *  pTypeLib;
    TLIBATTR *  pTypeLibAttr;

	_Module.UnregisterServer();

	// Ideally, we want to fix this using ::GetModuleFileName()
	// but at this point, we want to keep changes to minimal. (1/14/99)
#ifdef _DEBUG
    hr = LoadTypeLib(L"triedit.dll", &pTypeLib);
#else
    hr = LoadTypeLib(L"triedit.dll", &pTypeLib);
#endif

    _ASSERTE(hr == S_OK);
    
    if (hr == S_OK)
    {
        if (pTypeLib->GetLibAttr(&pTypeLibAttr) == S_OK)
        {
            hr = UnRegisterTypeLib(pTypeLibAttr->guid, pTypeLibAttr->wMajorVerNum,
                    pTypeLibAttr->wMinorVerNum, pTypeLibAttr->lcid,
                    pTypeLibAttr->syskind);
            _ASSERTE(hr == S_OK);
    
            pTypeLib->ReleaseTLibAttr(pTypeLibAttr);
        }
        pTypeLib->Release();
    }

    return S_OK;
}

//	Because we've changed from a shared component to a system component, and we're now
//	installed by IE using RollBack rather than reference counting, a serious bug
//	occurs if we're installed once under IE4, IE5 is installed, and the original
//	product is uninstalled.  (We're deleted.  Bug 23681.)
//	This crude but effective routine spikes our reference count to 10000.
//	It doesn't matter so much where we're installed NOW, it matters where the shared
//	component was, or might be, installed.  Even if it's a different copy, the
//	DLL will be unregistered when its reference count is decremented to zero.
//
static void SpikeSharedFileCount ()
{
	CRegKey	keyShared;
	CRegKey	keyCurVer;
	HRESULT	hr = S_OK;

	hr = keyCurVer.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion" ) );
	_ASSERTE ( SUCCEEDED ( hr ) );

	if ( FAILED ( hr ) )
	{
		return;	// There's nothing we can do.
	}

	hr = keyShared.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls") );
	
	// We expect there to be a SharedDLLs key, but it's possible that there is none.
	if ( FAILED ( hr ) )
	{
		hr = keyShared.Create ( keyCurVer, TEXT("SharedDlls") );
	}

	_ASSERT ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		TCHAR	tszPath[_MAX_PATH];
		TCHAR	tszMod[_MAX_PATH];
		DWORD	cchPath	= _MAX_PATH;
		
		// set tszPath to be an empty string in case the QueryValue fails
		tszPath[0]=0;

		// Build the string X:\Program Files\Common Files\Microsoft Shared\Triedit\dhtmled.ocx
		hr = keyCurVer.QueryValue ( tszPath, TEXT("CommonFilesDir"), &cchPath );
		if ( SUCCEEDED ( hr ) )
		{
			_tcscat ( tszPath, TEXT("\\Microsoft Shared\\Triedit\\") );
			
			// This routine gets the full path name of this DLL.  It SHOULD be the same
			// as the path we're constructing, but that could change in the future, so
			// truncate all but the bare file name.
			if ( 0 != GetModuleFileName ( _Module.GetModuleInstance(), tszMod, _MAX_PATH ) )
			{
				_tcsrev ( tszMod );				// Reverse the string
				_tcstok ( tszMod, TEXT("\\") );	// This replaces the first backslash with a \0.
				_tcsrev ( tszMod );
				_tcscat ( tszPath, tszMod );

				hr = keyShared.SetValue ( 10000, tszPath );
			}
		}
		hr = keyShared.Close ();
	}
	keyCurVer.Close ();
}


#ifdef _ATL_STATIC_REGISTRY
#pragma warning(disable: 4100 4189)	// Necessary for ia64 build
#include <statreg.h>
#include <statreg.cpp>
#pragma warning(default: 4100 4189)	// Necessary for ia64 build
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\zorder.h ===
//------------------------------------------------------------------------------
// zorder.h
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     ThomasOl
//
// History
//      8-15-97     created     (ThomasOl)
//
//
//------------------------------------------------------------------------------

#ifndef __ZORDER_H__
#define __ZORDER_H__

enum ZIndexMode
{
    SEND_BACKWARD,
    SEND_FORWARD,
    SEND_TO_BACK,
    SEND_TO_FRONT,
    SEND_BEHIND_1D,
    SEND_FRONT_1D,
    MADE_ABSOLUTE   // we pass this mode when calling AssignZIndex during the process of making
};                  // 2D elements.

#define ZINDEX_BASE 100

class CZOrder
{
public:
    IHTMLElement* m_pihtmlElement;
    LONG          m_zOrder;

    CZOrder() : m_pihtmlElement(0), m_zOrder(0)
      {}
    CZOrder(IHTMLElement* pihtmlElement, LONG zOrder)
    {
        m_pihtmlElement = pihtmlElement;
        _ASSERTE(m_pihtmlElement);
        if (m_pihtmlElement)
            m_pihtmlElement->AddRef();
        m_zOrder = zOrder;
    }
    virtual ~CZOrder()
    {
        SAFERELEASE(m_pihtmlElement);
    }
    int operator==(const CZOrder& node) const
    {
        return (m_zOrder == node.m_zOrder);
    }
    int operator<(const CZOrder& node) const
    {
        return (m_zOrder < node.m_zOrder);
    }
    int operator>(const CZOrder& node) const
    {
        return (m_zOrder > node.m_zOrder);
    }
    int operator>=(const CZOrder& node) const
    {
        return (m_zOrder >= node.m_zOrder);
    }
    int operator<=(const CZOrder& node) const
    {
        return (m_zOrder <= node.m_zOrder);
    }
    CZOrder& operator=(const CZOrder& node)
    {
        m_pihtmlElement = node.m_pihtmlElement;
        _ASSERTE(m_pihtmlElement);
        if (m_pihtmlElement)
            m_pihtmlElement->AddRef();
        m_zOrder = node.m_zOrder;
        return *this;
    }
};

#endif //__ZORDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\win95wrp.cpp ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.cpp
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

// Includes ------------------------------------------------------------------
#include "stdafx.h"

// The following two lines will ensure that no mapping from Foo to OFoo will take place
// and the real windows APIs will get called from this file
#define __WIN95WRP_CPP__
#include "win95wrp.h"

#include <mbstring.h>
#include <commctrl.h>
#include <shlobj.h>

// Function prototypes
inline LONG UnicodeToAnsi(LPSTR szOut, LPCWSTR pwszIn, LONG cbOut, LONG cbIn = -1) throw();
inline LONG AnsiToUnicode(LPWSTR pwszOut, LPCSTR szIn, LONG cbOut, LONG cbIn = -1) throw();

BOOL g_fWin95;
BOOL g_fOSInit = FALSE;

// Debug ----------------------------------------------------------------------
#ifdef _DEBUG
#define Assert(f)   ((f) ? 0 : AssertFail(#f))
#define Verify(f)   Assert(f)
#define Debug(f)    (f)
#else
#define Assert(f)   (0)
#define Verify(f)   (f)
#define Debug(f)    (0)
#endif

#ifdef DEBUG
int AssertFail(const CHAR *pszMsg) throw()
{
	int wRet = MessageBoxA(NULL, pszMsg, "Assert Failed in Win95 layer",
						   MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 |
						   MB_SYSTEMMODAL | MB_ICONHAND );

	switch (wRet)
		{
		case IDABORT:
			FatalAppExit(0, L"BOO HOO");
			break;

		case IDRETRY:
			DebugBreak();
			// deliberately fall through to IDIGNORE in order to continue

		case IDIGNORE:

			// go aways
			break;
		}
	return 0;
}
#else
#define AssertFail(s) (0)
#endif  // ! DEBUG

// This macro determines whether a LPTSTR is an atom or string pointer
#define FATOM(x)    (!(HIWORD((x))))

// OffsetOf       - Return the byte offset into s of m
#define	OffsetOf(s,m)	(size_t)(((unsigned char*)&(((s*)0)->m))-((unsigned char*)0))

inline LONG UnicodeToAnsi(LPSTR szDestString, LPCWSTR pwszSrcString,
						  LONG  cbDestString, LONG    cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || szDestString));
	return WideCharToMultiByte(CP_ACP, 0, pwszSrcString, cbSrcString,
							   szDestString, cbDestString, NULL, NULL);

}

inline LONG AnsiToUnicode(LPWSTR pwszDestString, LPCSTR szSrcString,
						  LONG   cbDestString,   LONG   cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || pwszDestString));
	return MultiByteToWideChar(CP_ACP, 0, szSrcString, cbSrcString,
							   pwszDestString, cbDestString );
}

inline bool FWide() throw()
{
	if (!g_fOSInit)
	{
		OSVERSIONINFOA osvi;
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		GetVersionExA(&osvi);
		g_fWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId);
		g_fOSInit = TRUE;
	}

	Assert(g_fOSInit);
	return !g_fWin95;
}

//  The implementation of the Unicode to ANSI (MBCS) convertion macros use the
//  _alloca() function to allocate memory from the stack instead of the heap.
//  Allocating memory from the stack is much faster than allocating memory on
//  the heap, and the memory is automatically freed when the function is exited.
//  In addition, these macros avoid calling WideCharToMultiByte more than one
//  time.  This is done by allocating a little bit more memory than is
//  necessary.  We know that an MBC will convert into at most one WCHAR and
//  that for each WCHAR we will have a maximum of two MBC bytes.  By allocating
//  a little more than necessary, but always enough to handle the conversion
//  the second call to the conversion function is avoided.  The call to the
//  helper function UnicodeToAnsi reduces the number of argument pushes that
//  must be done in order to perform the conversion (this results in smaller
//  code, than if it called WideCharToMultiByte directly).
//
//  In order for the macros to store the temporary length and the pointer to
//  the resultant string, it is necessary to declare some local variables
//  called _len and _sz in each function that uses these conversion macros.
//  This is done by invoking the PreConvert macro in each function before any
//  uses of Convert or ConverWithLen.  (PreConvert just need to be invoked once
//  per function.)

#define PreConvert() \
	LONG   _len;     \
	LPSTR  _sz;      \
	LONG   _lJunk;   \
	_lJunk; // Unused sometimes

// stack-allocates a char buffer of size cch
#define SzAlloc(cch)  ((LPSTR)_alloca(cch))

// stack-allocates a wchar buffer of size cch
#define SzWAlloc(cch) ((LPWSTR)_alloca(cch * sizeof(WCHAR)))

// Returns a properly converted string,
//   or NULL string on failure or szFrom == NULL
// On return the variable passed via pnTo will have the output byte count
//   (including the trailing '\0' iff the nFrom is -1)
#define ConvertWithLen(szFrom, nFrom, pnTo) \
			(!szFrom ? NULL : \
				(_len = (-1 == nFrom ? (wcslen(szFrom) + 1) : nFrom) * \
						sizeof(WCHAR), \
				 _sz = SzAlloc(_len + sizeof(WCHAR)), \
				 Debug(_sz[_len] = '\0'), \
				 (((*pnTo) = UnicodeToAnsi(_sz, szFrom, _len, nFrom)) < 0 ? \
				  (AssertFail("Convert failed in Unicode wrapper"), NULL) : \
				  (Assert('\0' == _sz[_len]), _sz) ) ) )
#define Convert(szFrom) ConvertWithLen(szFrom, -1, &_lJunk)

// There are strings which are blocks of strings end to end with a trailing '\0'
// to indicate the true end.  These strings are used with the REG_MULTI_SZ
// option of the Reg... routines and the lpstrFilter field of the OPENFILENAME
// structure used in the GetOpenFileName and GetSaveFileName routines.  To help
// in converting these strings here are two routines which calculate the length
// of the Unicode and ASNI versions (including all '\0's!):

size_t
cUnicodeMultiSzLen
(
LPCWSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = wcslen(lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

size_t
cAnsiMultiSzLen
(
LPCSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = _mbslen((const unsigned char*)lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

extern "C"{

BOOL
WINAPI
OAppendMenuW(
	HMENU hMenu,
	UINT uFlags,
	UINT uIDnewItem,
	LPCWSTR lpnewItem
	)
{
	if(FWide())
		return AppendMenuW(hMenu, uFlags, uIDnewItem, lpnewItem);

	if(MF_STRING != uFlags)
		return AppendMenuA(hMenu, uFlags, uIDnewItem, (LPSTR)lpnewItem);

	PreConvert();
	LPSTR sz = Convert(lpnewItem);
	if (sz == NULL)
		return(0);
	return AppendMenuA(hMenu, uFlags, uIDnewItem, sz);
}

LRESULT
WINAPI
OCallWindowProcW(
	WNDPROC lpPrevWndFunc,
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);

	return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);  //$ CONSIDER - Not really wrapped
}

DWORD
WINAPI
OCharLowerBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	if(!lpsz)
		return 0;

	if(FWide())
		return CharLowerBuffW(lpsz, cchLength);

	DWORD i = 0;
	while(i++ < cchLength)
		{
		*lpsz = towlower(*lpsz);
		lpsz++;
		}
	return i;
}

LPWSTR
WINAPI
OCharLowerW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharLowerW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towlower((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towlower(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/29/97
LPWSTR
WINAPI
OCharPrevW(
	LPCWSTR lpszStart,
	LPCWSTR lpszCurrent)
{
	return (LPWSTR)((lpszStart != lpszCurrent) ? lpszCurrent - 1 : lpszCurrent);
}

BOOL
WINAPI
OCharToOemW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst)
{
	if(FWide())
		{
		Assert((LPSTR) lpszSrc != lpszDst);
		return CharToOemW(lpszSrc, lpszDst);
		}

	PreConvert();
	LPSTR sz = Convert(lpszSrc);

	return CharToOemA(sz, lpszDst);
}

LPWSTR
WINAPI
OCharUpperW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharUpperW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towupper((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towupper(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCopyFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	BOOL bFailIfExists
	)
{
	if (FWide())
		return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

	char szExisting[_MAX_PATH], szNew[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szExisting, lpExistingFileName, _MAX_PATH));
	Verify(0 <= UnicodeToAnsi(szNew, lpNewFileName, _MAX_PATH));
	return CopyFileA(szExisting, szNew, bFailIfExists);
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCreateDirectoryW(
	LPCWSTR lpPathName,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	if (sz == NULL)
		return(0);
	return CreateDirectoryA(sz, NULL);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: simpified on 6/25
// Smoke tested by Mark Ashton on 6/25
BOOL
WINAPI
OCreateDirectoryExW(
	LPCWSTR lpTemplateDirectory,
	LPCWSTR lpNewDirectory,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);

	PreConvert();
	LPSTR szTemplateDirectory = Convert(lpTemplateDirectory);
	LPSTR szNewDirectory      = Convert(lpNewDirectory);
	return CreateDirectoryExA(szTemplateDirectory, szNewDirectory, NULL);
}

HDC
WINAPI
OCreateEnhMetaFileW(
	HDC hdc,
	LPCWSTR lpFileName,
	CONST RECT *lpRect,
	LPCWSTR lpDescription)
{
	if(FWide())
		return CreateEnhMetaFileW(hdc, lpFileName, lpRect, lpDescription);

	PreConvert();
	LPSTR szN = Convert(lpFileName);
	LPSTR szD = ConvertWithLen(lpDescription, cUnicodeMultiSzLen(lpDescription), &_lJunk);
	return  CreateEnhMetaFileA(hdc, szN, lpRect, szD);
}

HANDLE
WINAPI
OCreateEventW(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
}

HANDLE
WINAPI
OCreateFileW(
	LPCWSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes,
	HANDLE hTemplateFile
	)
{
	// Don't even attempt this on Win95!
	Assert(0 != wcsncmp(lpFileName, L"\\\\?\\", 4));

	if(FWide())
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
			dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return CreateFileA(sz, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HFONT
WINAPI
OCreateFontIndirectW(CONST LOGFONTW * plfw)
{
	Assert(plfw);

	if(FWide())
		return CreateFontIndirectW(plfw);

	LOGFONTA  lfa;
	//HFONT     hFont = NULL;

	// It's assumed here that sizeof(LOGFONTA) <= sizeof (LOGFONTW);
	memcpy(&lfa, plfw, sizeof(LOGFONTA));

	Verify(0 <= UnicodeToAnsi(lfa.lfFaceName, plfw->lfFaceName, LF_FACESIZE));
	return CreateFontIndirectA(&lfa);
}

// From: Mark Ashton on 5/29/97
HFONT
OCreateFontW(
	int nHeight, // logical height of font
	int nWidth, // logical average character width
	int nEscapement, // angle of escapement
	int nOrientation, // base-line orientation angle
	int fnWeight, // font weight
	DWORD fdwItalic, // italic attribute flag
	DWORD fdwUnderline, // underline attribute flag
	DWORD fdwStrikeOut, // strikeout attribute flag
	DWORD fdwCharSet, // character set identifier
	DWORD fdwOutputPrecision, // output precision
	DWORD fdwClipPrecision, // clipping precision
	DWORD fdwQuality, // output quality
	DWORD fdwPitchAndFamily, // pitch and family
	LPCWSTR lpszFace) // pointer to typeface name string
{
	if (FWide())
		return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace);
	PreConvert();
	LPSTR sz = Convert(lpszFace);
	return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, sz);
}

HWND
WINAPI
OCreateMDIWindowW(
	LPWSTR lpClassName,
	LPWSTR lpWindowName,
	DWORD dwStyle,
	int X,
	int Y,
	int nWidth,
	int nHeight,
	HWND hWndParent,
	HINSTANCE hInstance,
	LPARAM lParam
	)
{
	if(FWide())
		return CreateMDIWindowW(lpClassName, lpWindowName, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWin   = Convert(lpWindowName);

	return CreateMDIWindowA(szClass, szWin, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
}

HDC
WINAPI
OCreateMetaFileW(LPCWSTR lpstr)
{
	if(FWide())
		return CreateMetaFileW(lpstr);

	PreConvert();
	LPSTR sz = Convert(lpstr);
	return CreateMetaFileA(sz);
}

HANDLE
WINAPI
OCreateSemaphoreW(
	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
	LONG lInitialCount,
	LONG lMaximumCount,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, sz);
}

HWND
WINAPI
OCreateWindowExW( DWORD dwExStyle,
			  LPCWSTR lpClassName,
				LPCWSTR lpWindowName,
				DWORD dwStyle,
				int X,
				int Y,
				int nWidth,
				int nHeight,
				HWND hWndParent ,
				HMENU hMenu,
				HINSTANCE hInstance,
				LPVOID lpParam )
{
	if(FWide())
		return CreateWindowExW(dwExStyle,
				lpClassName,
				lpWindowName,
				dwStyle,
				X,
				Y,
				nWidth,
				nHeight,
				hWndParent ,
				hMenu,
				hInstance,
				lpParam );

	PreConvert();

	LPSTR szClass;
	if (FATOM(lpClassName))
		{
		// is it an atom?
		szClass = (LPSTR) lpClassName;
		}
	else
		{
		// otherwise convert the string
		szClass = Convert(lpClassName);
		}
	LPSTR szWindow = Convert(lpWindowName);

	return CreateWindowExA (dwExStyle, szClass, szWindow, dwStyle, X, Y,
						 nWidth, nHeight, hWndParent, hMenu, hInstance,
						 lpParam);

}

HSZ
WINAPI
ODdeCreateStringHandleW(
	DWORD idInst,
	LPCWSTR psz,
	int iCodePage)
{
	if(FWide())
		{
		Assert(CP_WINUNICODE == iCodePage);
		return DdeCreateStringHandleW(idInst, psz, iCodePage);
		}
	PreConvert();
	LPSTR sz = Convert(psz);
	return DdeCreateStringHandleA(idInst, sz, CP_WINANSI);
}

UINT
WINAPI
ODdeInitializeW(
	LPDWORD pidInst,
	PFNCALLBACK pfnCallback,
	DWORD afCmd,
	DWORD ulRes)
{
	if(FWide())
		return DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
	return DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
}

LRESULT
WINAPI
ODefFrameProcW(
	HWND hWnd,
	HWND hWndMDIClient ,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefFrameProcW(hWnd, hWndMDIClient , uMsg, wParam, lParam);

	return DefFrameProcA(hWnd, hWndMDIClient , uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefMDIChildProcW(
	HWND hWnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefMDIChildProcW(hWnd, uMsg, wParam, lParam);

	return DefMDIChildProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefWindowProcW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefWindowProcW( hWnd, Msg,wParam, lParam);

	return DefWindowProcA( hWnd, Msg,wParam, lParam);
}

BOOL
WINAPI
ODeleteFileW(
	LPCWSTR pwsz)
{
	if(FWide())
		return DeleteFileW(pwsz);

	PreConvert();
	LPSTR sz = Convert(pwsz);
	return DeleteFileA(sz);
}

LRESULT
WINAPI
ODialogBoxIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW hDialogTemplate,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);

	return DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODialogBoxParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxParamW(hInstance, lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	if(FATOM(lpTemplateName))
		return DialogBoxParamA(hInstance, (LPSTR)lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	PreConvert();
	LPSTR sz = Convert(lpTemplateName);
	return DialogBoxParamA(hInstance, sz, hWndParent , lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODispatchMessageW(
	CONST MSG *lpMsg)
{
	if(FWide())
		return DispatchMessageW(lpMsg);

	return DispatchMessageA(lpMsg);
}

int
WINAPI
ODrawTextW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	LPRECT lpRect,
	UINT uFormat)
{
	// NOTE OS may write 3 characters beyond end of lpString so make room!


	if(FWide())
		return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

	bool fModifyString = (uFormat & DT_MODIFYSTRING) &&
						 (uFormat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS));

	const int nBuff = WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										  NULL, 0, NULL, NULL );
	Assert(0 <= nBuff);

	// OS may write beyond end of buffer so make room!
	const LPSTR sz = SzAlloc(nBuff + 4);

	Verify(nBuff == WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										sz, nBuff, NULL, NULL ));

	if (fModifyString)
		{
		// DrawTextA doesn't nessacerily '\0' terminate the output,
		// so have termiators ready
		memcpy(sz + nBuff, "\0\0\0\0", 4);
		}

	const int iDrawTextReturn = DrawTextA(hDC, sz, nBuff - 1, lpRect, uFormat);

	// With certain flags, DrawText modifies the string, truncating it with
	// an ellipsis.  We need to convert back and update the string passed to
	// the wrapper before we return.
	if (fModifyString && 0 <= iDrawTextReturn)
		{
		Assert('\0' == sz[nBuff + 3]); // Verify not too many were overwritten

		// The windows function prototype has lpString as constant even
		//    though the string gets modified!
		const int nStringLen = -1 != nCount ? nCount : wcslen(lpString);
		Verify(0 <= AnsiToUnicode(const_cast<LPWSTR>(lpString), sz,
								 nStringLen + 4 ));
		}
	return iDrawTextReturn;
}

// Written by Bill Hiebert on 9/4/97
// Smoke tested by Bill Hiebert 9/4/97
int
WINAPI
ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	Assert(-1 != cb);
	Assert(!(DT_MODIFYSTRING & dwDTFormat));

	if(FWide())
		return DrawTextExW(hdc, pwsz, cb, lprect, dwDTFormat, lpDTParams);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	if (sz == NULL)
		return(0);

	return DrawTextExA(hdc, sz, n, lprect, dwDTFormat, lpDTParams);
}


// Written for Carlos Gomes on 6/26/97 by Ted Smith
// Smoke tested by Carlos Gomes on 6/26
DWORD
WINAPI
OExpandEnvironmentStringsW(
	LPCWSTR lpSrc,
	LPWSTR lpDst,
	DWORD nSize
	)
{
	if (FWide())
		return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);

	PreConvert();
	LPSTR szSrc = Convert(lpSrc);
	LPSTR szDst = SzAlloc(sizeof(WCHAR) * nSize);

	if (szSrc == NULL)
		return(0);

	DWORD dwRet = ExpandEnvironmentStringsA(szSrc, szDst, sizeof(WCHAR) * nSize);

	if (dwRet)
		{
		LONG lRet = AnsiToUnicode(lpDst, szDst, nSize, min(dwRet, sizeof(WCHAR) * nSize));
		if (dwRet < (DWORD) lRet)
			{
			dwRet = lRet;
			}
		}
	else if (lpDst && 0 < nSize)
		{
		*lpDst = L'\0';
		}

	return dwRet;
}

VOID
WINAPI
OFatalAppExitW(
	UINT uAction,
	LPCWSTR lpMessageText
	)
{
	if(FWide())
		FatalAppExitW(uAction, lpMessageText);

	PreConvert();
	LPSTR sz = Convert(lpMessageText);
	FatalAppExitA(uAction, sz);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstChangeNotificationW(
	LPCWSTR lpPathName,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter
	)
{
	if (FWide())
		return FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	if (sz == NULL)
		return(INVALID_HANDLE_VALUE);

	return FindFirstChangeNotificationA(sz, bWatchSubtree, dwNotifyFilter);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstFileW(
	LPCWSTR lpFileName,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindFirstFileW(lpFileName, lpFindFileData);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(INVALID_HANDLE_VALUE);

	WIN32_FIND_DATAA findFileData;
	HANDLE h = FindFirstFileA(sz, &findFileData);
	if (INVALID_HANDLE_VALUE != h)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return h;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OFindNextFileW(
	HANDLE hFindFile,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindNextFileW(hFindFile, lpFindFileData);

	WIN32_FIND_DATAA findFileData;
	BOOL fFlag = FindNextFileA(hFindFile, &findFileData);
	if (fFlag)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return fFlag;
}

HRSRC
WINAPI
OFindResourceW(
	HINSTANCE hModule,
	LPCWSTR lpName,
	LPCWSTR lpType
	)
{
	if(FWide())
		return FindResourceW(hModule, lpName, lpType);

	LPCSTR szName = (LPCSTR)lpName;
	LPCSTR szType = (LPCSTR)lpType;

	PreConvert();
	if(!FATOM(lpName))
		szName = Convert(lpName);
	if(!FATOM(lpType))
		szType = Convert(lpType);

	return FindResourceA(hModule, szName, szType);
}

HWND
WINAPI
OFindWindowW(
	LPCWSTR lpClassName ,
	LPCWSTR lpWindowName)
{
	if(FWide())
		return FindWindowW(lpClassName , lpWindowName);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWnd   = Convert(lpWindowName);

	return FindWindowA(szClass, szWnd);
}

// Bill Hiebert of IStudio on 6/13/97 added support for the
//   FORMAT_MESSAGE_ALLOCATE_BUFFER flag
// Bill donated a bugfix for 1819 on 8/1/97

DWORD
WINAPI
OFormatMessageW(
	DWORD dwFlags,
	LPCVOID lpSource,
	DWORD dwMessageId,
	DWORD dwLanguageId,
	LPWSTR lpBuffer,
	DWORD nSize,
	va_list *Arguments)
{

	if (FWide())
		return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId,
							  lpBuffer, nSize, Arguments );

	DWORD dwRet;

	LPSTR szBuffer = NULL;

	if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
		{
		Assert(!IsBadWritePtr(lpBuffer, nSize * sizeof(WCHAR)));
		szBuffer = SzAlloc(sizeof(WCHAR) * nSize);
		}

	if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
		{
		PreConvert();
		LPSTR szSource = Convert((LPWSTR)lpSource);

		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}
	else
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}

	if (dwRet)
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{ // szBuffer contains LocalAlloc ptr to new string. lpBuffer is a
			  // WCHAR** when FORMAT_MESSAGE_ALLOCATE_BUFFER is defined.
			WCHAR* pTemp = (WCHAR*)LocalAlloc(NONZEROLPTR, (dwRet + 1) * sizeof(WCHAR) );
			dwRet = pTemp == NULL? 0 : AnsiToUnicode(pTemp, szBuffer, dwRet + 1);
			LocalFree(szBuffer);
			if (dwRet)
				{
				*(WCHAR**)lpBuffer = pTemp;
				}
			return dwRet;
			}
		else
			{ // Just convert
			return AnsiToUnicode(lpBuffer, szBuffer, nSize);
			}
		}
	else if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

BOOL
APIENTRY
OGetCharABCWidthsFloatW(
	HDC     hdc,
	UINT    uFirstChar,
	UINT    uLastChar,
	LPABCFLOAT      lpABC)
{
	if(FWide())
		return GetCharABCWidthsFloatW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsFloatA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharABCWidthsW(
	HDC hdc,
	UINT uFirstChar,
	UINT uLastChar,
	LPABC lpABC)
{
	if(FWide())
		return GetCharABCWidthsW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharWidthFloatW(
	HDC     hdc,
	UINT    iFirstChar,
	UINT    iLastChar,
	PFLOAT  pBuffer)
{
	if(FWide())
		return GetCharWidthFloatW(hdc, iFirstChar, iLastChar, pBuffer);

	return GetCharWidthFloatA(hdc, iFirstChar, iLastChar, pBuffer);
}


BOOL
WINAPI
OGetCharWidthW(
	HDC hdc,
	UINT iFirstChar,
	UINT iLastChar,
	LPINT lpBuffer)
{
	if(FWide())
		return GetCharWidth32W(hdc, iFirstChar, iLastChar, lpBuffer);

	return GetCharWidth32A(hdc, iFirstChar, iLastChar, lpBuffer);
}

// Static buffers for GetClassInfo[Ex] to return the classname
// and menuname in Unicode, when running on an Ansi system.
// The contract of GetClassInfo is that it returns const ptrs
// back to the class name and menu name.  Unfortuntely, this
// prevents us from translating these back from Ansi to Unicode,
// without having some static buffers to use.  Since we strongly
// believe that the only people calling this are doing it just to
// see if it succeeds or not, so they know whether the class is
// already registered, we've willing to just have one set of
// static buffers to use.
// CAUTION: this will work as long as two threads don't call
// GetClassInfo[Ex] at the same time!
static WCHAR g_szClassName[256];
static WCHAR g_szMenuName[256];

#ifdef DEBUG
static DWORD g_dwCallingThread = 0;    // debug global for ensuring one thread.
#endif // DEBUG

BOOL
WINAPI
OGetClassInfoW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSW lpWndClass
)
{
	if (FWide())
		return GetClassInfoW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoA(hInstance, szClassName, (LPWNDCLASSA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

BOOL
WINAPI
OGetClassInfoExW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSEXW lpWndClass
)
{
	if (FWide())
		return GetClassInfoExW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoExA(hInstance, szClassName, (LPWNDCLASSEXA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

DWORD
WINAPI
OGetClassLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetClassLongW(hWnd, nIndex);
	return GetClassLongA(hWnd, nIndex);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!
}

DWORD
WINAPI
OSetClassLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if (FWide())
		return SetClassLongW(hWnd, nIndex, dwNewLong);

	return SetClassLongA(hWnd, nIndex, dwNewLong);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!

}

int
WINAPI
OGetClassNameW(
	HWND hWnd,
	LPWSTR lpClassName,
	int nMaxCount)
{
	if(FWide())
		return GetClassNameW(hWnd, lpClassName, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount + 2);
	int nRet = GetClassNameA(hWnd, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (nRet)
		{
		// force null-termination
		sz[sizeof(WCHAR) * nMaxCount] = '\0';
		sz[sizeof(WCHAR) * nMaxCount + 1] = '\0';

		// need a temporary wide string
		LPWSTR wsz = SzWAlloc(2 * nMaxCount + 1);

		nRet = min(AnsiToUnicode(wsz, sz, 2 * nMaxCount + 1), nMaxCount);

		// copy the requested number of characters
		if (lpClassName)
			{
			memcpy(lpClassName, wsz, nRet * sizeof(WCHAR));
			}

		return nRet;
		}

	else if (lpClassName && 0 < nMaxCount)
		{
		*lpClassName = L'\0';
		}

	return nRet;
}

DWORD
WINAPI
OGetCurrentDirectoryW(
	DWORD nBufferLength,
	LPWSTR lpBuffer)
{
	if (FWide())
		return GetCurrentDirectoryW(nBufferLength, lpBuffer);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferLength);
	DWORD dwRet = GetCurrentDirectoryA(sizeof(WCHAR) * nBufferLength, sz);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(lpBuffer, sz, nBufferLength);
		}
	else if (lpBuffer && 0 < nBufferLength)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

UINT
WINAPI
OGetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPWSTR lpString,
	int nMaxCount)
{
	if(FWide())
		return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	UINT uRet = GetDlgItemTextA(hDlg, nIDDlgItem, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(uRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else if (lpString && 0 < nMaxCount)
		{
		*lpString = L'\0';
		}

	return uRet;
}

DWORD
WINAPI
OGetFileAttributesW(
	LPCWSTR lpFileName
	)
{
	if(FWide())
		return GetFileAttributesW(lpFileName);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(DWORD)(-1);

	return GetFileAttributesA(sz);
}

DWORD
WINAPI
OGetFullPathNameW(
	LPCWSTR lpFileName,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	if(FWide())
		return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);

	PreConvert();
	LPSTR szFile = Convert(lpFileName);
	if (szFile == NULL)
		return(0); // dwRet

	LPSTR szBuffer = SzAlloc(sizeof(WCHAR) * nBufferLength);
	LPSTR pszFile;

	DWORD dwRet = GetFullPathNameA(szFile ,sizeof(WCHAR) * nBufferLength, szBuffer , &pszFile);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		DWORD dwNoOfChar = AnsiToUnicode(lpBuffer, szBuffer , nBufferLength);
		*pszFile = '\0';
		*lpFilePart = lpBuffer + AnsiToUnicode(NULL, szBuffer, 0);
		return dwNoOfChar;
		}

	return dwRet;
}

DWORD
WINAPI
OGetGlyphOutlineW(
	HDC     hdc,
	UINT    uChar,
	UINT    uFormat,
	LPGLYPHMETRICS      lpgm,
	DWORD       cbBuffer,
	LPVOID      lpvBuffer,
	CONST MAT2 *    lpmat2)
{
	if (FWide())
		return GetGlyphOutlineW(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);

	return GetGlyphOutlineA(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);
}

DWORD
WINAPI
OGetKerningPairsW(
	HDC         hdc,
	DWORD       nNumPairs,
	LPKERNINGPAIR       lpkrnpair)
{
	if(FWide())
		return GetKerningPairsW(hdc, nNumPairs, lpkrnpair);

	return GetKerningPairsA(hdc, nNumPairs, lpkrnpair);
}

BOOL
WINAPI
OGetMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax)
{
	if(FWide())
		return GetMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);

	return GetMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);
}

DWORD
WINAPI
OGetModuleFileNameW(
	HINSTANCE hModule,
	LPWSTR pwszFilename,
	DWORD nSize
	)
{
	if(FWide())
		return GetModuleFileNameW(
			hModule,
			pwszFilename,
			nSize
			);

	LPSTR sz    = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = GetModuleFileNameA(hModule, sz, sizeof(WCHAR) * nSize);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(pwszFilename, sz, nSize, dwRet + 1);
		}
	else if (pwszFilename && 0 < nSize)
		{
		*pwszFilename = L'\0';
		}

	return dwRet;
}

HMODULE
WINAPI
OGetModuleHandleW(
	LPCWSTR lpModuleName
	)
{
	if(FWide())
		return GetModuleHandleW(lpModuleName);

	PreConvert();
	LPSTR sz = Convert(lpModuleName);

	return GetModuleHandleA(sz);
}

UINT
APIENTRY
OGetOutlineTextMetricsW(
	HDC hdc,
	UINT cbData,
	LPOUTLINETEXTMETRICW lpOTM)
{
	// *** TextMetrics defines BYTE elements in the structure for the
	// value of first first/last character defined in the font.
	// Problem for DBCS.

	if(FWide())
		return GetOutlineTextMetricsW(hdc, cbData, lpOTM);

	return GetOutlineTextMetricsA(hdc, cbData, (LPOUTLINETEXTMETRICA)lpOTM); //$ UNDONE_POST_98 - This doesn't convert the embedded Names...
}

UINT
WINAPI
OGetPrivateProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szFileName = Convert(lpFileName);

	return GetPrivateProfileIntA(szAppName, szKeyName, nDefault, szFileName);
}

DWORD
WINAPI
OGetPrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString,
		  nSize, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szDefault  = Convert(lpDefault);
	LPSTR szFileName = Convert(lpFileName);

	LPSTR szReturnedString = SzAlloc(sizeof(WCHAR) * nSize);

	DWORD dwRet = GetPrivateProfileStringA(szAppName, szKeyName, szDefault, szReturnedString,
	  sizeof(WCHAR) * nSize, szFileName);

	// I hope this doesn't fail because there's no clear failure value in the docs

	DWORD dwNoOfChar = AnsiToUnicode(lpReturnedString, szReturnedString, nSize);

	if (dwNoOfChar)
		return dwRet;
	else
		{
		LPWSTR lpTempString = SzWAlloc(sizeof(WCHAR) * nSize);
		if (AnsiToUnicode(lpTempString, szReturnedString, sizeof(WCHAR) * nSize))
			{
			if (lpAppName && lpKeyName)
				{
				lpTempString[nSize - 1] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 1;
				}
			else
				{
				lpTempString[nSize - 1] = L'\0';
				lpTempString[nSize - 2] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 2;
				}
			}
		}

	return dwRet;
}


int
WINAPI
OGetObjectW(
	HGDIOBJ hgdiobj,
	int cbBuffer,
	LPVOID lpvObject)
{
	if(FWide())
		return GetObjectW(hgdiobj, cbBuffer, lpvObject);

	DWORD dwObj = GetObjectType(hgdiobj);
	if (OBJ_FONT == dwObj)
		{
		//$CONSIDER: This effects all getobject call, performance?
		Assert(cbBuffer == sizeof(LOGFONTW));
		LOGFONTA  lfa;
		LOGFONTW *plfw = (LOGFONTW *)lpvObject;

		int nRet = GetObjectA(hgdiobj, sizeof(lfa), &lfa);

		if(nRet)
			{
			memcpy(plfw, &lfa, sizeof(LOGFONTA));
			Verify(0 <= AnsiToUnicode(plfw->lfFaceName, lfa.lfFaceName, LF_FACESIZE));
			}

		return nRet;
		}
	else
		{
		return GetObjectA(hgdiobj, cbBuffer, lpvObject);
		}
}

UINT
WINAPI
OGetProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault
	)
{
	if(FWide())
		return GetProfileIntW(lpAppName, lpKeyName, nDefault);

	PreConvert();
	LPSTR szApp = Convert(lpAppName);
	LPSTR szKey = Convert(lpKeyName);

	return GetProfileIntA(szApp, szKey, nDefault);
}

HANDLE
WINAPI
OGetPropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return GetPropW(hWnd, lpString);

	if(FATOM(lpString))
		return GetPropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GetPropA(hWnd, sz);
}

DWORD
WINAPI
OGetTabbedTextExtentW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions)
{
	Assert(-1 != nCount);

	if(FWide())
		return GetTabbedTextExtentW(hDC, lpString, nCount, nTabPositions, lpnTabStopPositions);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	if (sz == NULL)
		return(0);

	return GetTabbedTextExtentA(hDC, sz, n, nTabPositions, lpnTabStopPositions);
}

// From: Mark Ashton on 5/8/97
UINT
WINAPI
OGetTempFileNameW(
	LPCWSTR lpPathName,
	LPCWSTR lpPrefixString,
	UINT uUnique,
	LPWSTR lpTempFileName
	)
{
	if (FWide())
		return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

	char szPathName[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPathName, lpPathName, _MAX_PATH));

	char szPrefixString[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPrefixString, lpPrefixString, _MAX_PATH));

	char szTempFilename[_MAX_PATH];
	UINT dwRet = GetTempFileNameA(szPathName, szPrefixString, uUnique, szTempFilename);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpTempFileName, szTempFilename, _MAX_PATH));
		}
	return dwRet;
}

// From: Mark Ashton on 5/8/97
DWORD
WINAPI
OGetTempPathW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	if (FWide())
		return GetTempPathW(nBufferLength, lpBuffer);

	char szPath[_MAX_PATH];
	DWORD dwRet = GetTempPathA(_MAX_PATH, szPath);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpBuffer, szPath, nBufferLength));
		}
	return dwRet;
}

BOOL
APIENTRY
OGetTextExtentPoint32W(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	if (sz == NULL)
		return(0);

	return GetTextExtentPoint32A(hdc, sz, n, pSize);
}

BOOL
APIENTRY
OGetTextExtentPointW(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPointW(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	return GetTextExtentPointA(hdc, sz, n, pSize);
}

BOOL
APIENTRY OGetTextExtentExPointW(
					HDC hdc,
					LPCWSTR lpszStr,
					int cchString,
					int nMaxExtent,
					LPINT lpnFit,
					LPINT alpDx,
					LPSIZE pSize
					)
{
	Assert(-1 != cchString);

	if(FWide())
		return GetTextExtentExPointW(hdc, lpszStr, cchString,
									 nMaxExtent, lpnFit, alpDx, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpszStr, cchString, &n);
	if (sz == NULL)
		return(0);

	return GetTextExtentExPointA(hdc, sz, n, nMaxExtent, lpnFit, alpDx, pSize);

}

LONG
WINAPI
OGetWindowLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetWindowLongW(hWnd, nIndex);

	return GetWindowLongA(hWnd, nIndex);
}

BOOL
WINAPI
OGetTextMetricsW(
	HDC hdc,
	LPTEXTMETRICW lptm)
{
	if(FWide())
		return GetTextMetricsW(hdc, lptm);

	TEXTMETRICA tma;

	memcpy(&tma, lptm, OffsetOf(TEXTMETRIC, tmFirstChar));

	// tmFirstChar is defined as BYTE.
	// $CONSIDER : will fail for DBCS !!

	wctomb((LPSTR)&tma.tmFirstChar, lptm->tmFirstChar);
	wctomb((LPSTR)&tma.tmLastChar, lptm->tmLastChar);
	wctomb((LPSTR)&tma.tmDefaultChar, lptm->tmDefaultChar);
	wctomb((LPSTR)&tma.tmBreakChar, lptm->tmBreakChar);

	memcpy(&tma.tmItalic, &lptm->tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

	BOOL fRet = GetTextMetricsA(hdc, &tma);

	if(fRet)
		{
		memcpy(&lptm->tmItalic, &tma.tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

		// Convert tma.tmFirstChar (1 byte char) to lptm->tmFirstChar
		mbtowc(&lptm->tmFirstChar, (LPSTR)&tma.tmFirstChar, 1);
		mbtowc(&lptm->tmLastChar, (LPSTR)&tma.tmLastChar, 1);
		mbtowc(&lptm->tmDefaultChar, (LPSTR)&tma.tmDefaultChar, 1);
		mbtowc(&lptm->tmBreakChar, (LPSTR)&tma.tmBreakChar, 1);

		memcpy(lptm, &tma, OffsetOf(TEXTMETRIC, tmFirstChar));
		}

	return fRet;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OGetUserNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (FWide())
		return GetUserNameW(lpBuffer, nSize);

	DWORD dwLen = *nSize;
	LPSTR sz = SzAlloc(dwLen);

	BOOL fFlag = GetUserNameA(sz, nSize);
	if (fFlag)
		{
		*nSize = AnsiToUnicode(lpBuffer, sz, dwLen);
		}
	return fFlag;
}

BOOL
WINAPI
OGetVolumeInformationW(
	LPCWSTR lpRootPathName,
	LPWSTR lpVolumeNameBuffer,
	DWORD nVolumeNameSize,
	LPDWORD lpVolumeSerialNumber,
	LPDWORD lpMaximumComponentLength,
	LPDWORD lpFileSystemFlags,
	LPWSTR lpFileSystemNameBuffer,
	DWORD nFileSystemNameSize
	)
{
	if(FWide())
		return GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);

	PreConvert();
	LPSTR szRoot = Convert(lpRootPathName);
	LPSTR szName = SzAlloc(sizeof(WCHAR) * nVolumeNameSize);
	LPSTR szSysName = SzAlloc(sizeof(WCHAR) * nFileSystemNameSize);

	BOOL fRet = GetVolumeInformationA(szRoot, szName, sizeof(WCHAR) * nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, szSysName, sizeof(WCHAR) * nFileSystemNameSize);

	if(fRet)
		{
		if (!AnsiToUnicode(lpVolumeNameBuffer, szName, nVolumeNameSize) ||
			!AnsiToUnicode(lpFileSystemNameBuffer, szSysName, nFileSystemNameSize))
			{
			fRet = false;
			}
		}
	if (!fRet)
		{
		if (lpVolumeNameBuffer && 0 < nVolumeNameSize)
			{
			*lpVolumeNameBuffer = L'\0';
			}

		if (lpFileSystemNameBuffer && 0 < nFileSystemNameSize)
			{
			*lpFileSystemNameBuffer = L'\0';
			}
		}

	return fRet;
}

int
WINAPI
OGetWindowTextLengthW(
	HWND hWnd)
{
	if(FWide())
		return GetWindowTextLengthW(hWnd);

	return GetWindowTextLengthA(hWnd);
}

int
WINAPI
OGetWindowTextW(
	HWND hWnd,
	LPWSTR lpString,
	int nMaxCount)
{

	/*******  Blackbox Testing results for GetWindowText Win32 API ******

	TestCase    lpString    nMaxCount   Return Value    *lpString modified
	======================================================================
	Testing GetWindowTextW on WinNT :-
		A       not NULL        0           0               No
		B           NULL        0           0               No
		C           NULL    not 0           0               No
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator

	Testing GetWindowTextA on Win95 :-
		A       not NULL        0           0               Yes
		B           NULL        0               GPF!!
		C           NULL    not 0               GPF!!
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator
	*********************************************************************/

	if(FWide())
		return GetWindowTextW(hWnd, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	int nRet = GetWindowTextA(hWnd, sz, sizeof(WCHAR) * nMaxCount);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(nRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else
		{
		// GetWindowText() returns 0 when you call it on a window which
		// has no text (e.g. edit control without any text). It also initializes
		// the buffer passed in to receive the text to "\0". So we should initialize
		// the buffer passed in before returning.
		if (lpString && 0 < nMaxCount)
			{
			*lpString = L'\0';
			}
		}

	return nRet;
}

ATOM
WINAPI
OGlobalAddAtomW(
	LPCWSTR lpString
	)
{
	if(FWide())
		return GlobalAddAtomW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	if (sz == NULL)
		return(0);

	return GlobalAddAtomA(sz);
}

// From: Josh Kaplan on 8/12/97
UINT
WINAPI
OGlobalGetAtomNameW(
	ATOM nAtom,
	LPWSTR lpBuffer,
	int nSize
	)
{
	if(FWide())
		return GlobalGetAtomNameW(nAtom, lpBuffer, nSize);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nSize);
	if (GlobalGetAtomNameA(nAtom, sz, sizeof(WCHAR) * nSize))
		{
		// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
		return AnsiToUnicode(lpBuffer, sz, nSize) - 1;
		}

	if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}
	return 0;
}

BOOL
WINAPI
OGrayStringW(
	HDC hDC,
	HBRUSH hBrush,
	GRAYSTRINGPROC lpOutputFunc,
	LPARAM lpData,
	int nCount,
	int X,
	int Y,
	int nWidth,
	int nHeight)
{
	if(FWide())
		return GrayStringW(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);

	if (!lpOutputFunc)
		{
		PreConvert();
		LPSTR szData = Convert((LPCWSTR) lpData);
		if (szData == NULL)
			return(0);

		return GrayStringA(hDC, hBrush, lpOutputFunc, (LPARAM) szData, nCount, X, Y, nWidth, nHeight);
		}

	return GrayStringA(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
}

BOOL
WINAPI
OInsertMenuW(
	HMENU hMenu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if(uFlags & (MF_BITMAP | MF_OWNERDRAW))
		return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPSTR)lpNewItem);

	PreConvert();
	LPSTR sz = Convert(lpNewItem);
	return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, sz);
}

BOOL
WINAPI
OIsBadStringPtrW(
	LPCWSTR lpsz,
	UINT ucchMax
	)
{
	if(FWide())
		return IsBadStringPtrW(lpsz, ucchMax);

	return IsBadStringPtrA((LPSTR) lpsz, ucchMax * sizeof(WCHAR));  //$UNDONE_POST_98 - We should use IsBadReadPtr(strlen)!
}


BOOL
WINAPI
OIsCharAlphaNumericW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaNumericW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if (1 == cch)
		{
		return IsCharAlphaNumericA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsCharAlphaW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if(1 == cch)
		{
		return IsCharAlphaA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsDialogMessageW(
	HWND hDlg,
	LPMSG lpMsg)
{
	// WARNING!!!
	// Bug #6488. We have run into problems due to using IsDialogMessageW on
	// WinNT Japanese. The fix for the bug was calling ANSI version of
	// IsDialogMessage irrespective of whether we are running on NT or Win95.
	// The shell is compiled MBCS (not UNICODE) and they are always using the
	// ANSI versions of the routines. lpMsg passed by shell contains MBCS
	// characters & not UNICODE. So in cases where you get the message
	// structure from the Shell, you will have to call the IsDialogMessageA
	// directly and not use this wrapper.

	if(FWide())
		return IsDialogMessageW(hDlg, lpMsg);

	return IsDialogMessageA(hDlg, lpMsg);
}

// From: Mark Ashton on 5/8/97
//		 Bill Hieber - 2/5/98 fixed buffer size problem.
int
WINAPI
OLCMapStringW(
	LCID     Locale,
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	if (FWide())
		return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

	// lpSrcStr is not required to be '\0' terminated. Note that we don't support -1!
	Assert(cchSrc != -1);
	LPSTR sz = SzAlloc(cchSrc * 2);
	int dw = WideCharToMultiByte(CP_ACP, 0, lpSrcStr, cchSrc, sz, cchSrc * 2, NULL, NULL);

	LPSTR dst = cchDest ? SzAlloc(cchDest*2) : NULL;
	int dwRet = LCMapStringA(Locale, dwMapFlags, sz, dw, dst, cchDest*2);
	if (dwRet && cchDest)
		{
		dwRet = MultiByteToWideChar(CP_ACP, 0, dst, dwRet, lpDestStr, cchDest);
		}
	return dwRet;
}

HACCEL
WINAPI
OLoadAcceleratorsW(
	HINSTANCE hInst,
	LPCWSTR   lpTableName)
{
	if(FWide())
		return LoadAcceleratorsW(hInst, lpTableName);

	if(FATOM(lpTableName))
		return LoadAcceleratorsA(hInst, (LPSTR)lpTableName);

	PreConvert();
	LPSTR sz = Convert(lpTableName);
	return LoadAcceleratorsA(hInst, sz);
}

HBITMAP
WINAPI
OLoadBitmapW(
	HINSTANCE hInstance,
	LPCWSTR lpBitmapName)
{
	if(FWide())
		return LoadBitmapW(hInstance, lpBitmapName);

	if(FATOM(lpBitmapName))
		return LoadBitmapA(hInstance, (LPSTR)lpBitmapName);

	PreConvert();
	LPSTR sz = Convert(lpBitmapName);
	return LoadBitmapA(hInstance, sz);
}

HCURSOR
WINAPI
OLoadCursorW(
	HINSTANCE hInstance,
	LPCWSTR lpCursorName)
{
	if(FWide())
		return LoadCursorW(
			hInstance,
			lpCursorName);

	if (FATOM(lpCursorName))
		return LoadCursorA(hInstance, (LPSTR) lpCursorName);

	PreConvert();
	LPSTR sz = Convert(lpCursorName);
	return LoadCursorA(hInstance, sz);
}

HICON
WINAPI
OLoadIconW(
	HINSTANCE hInstance,
	LPCWSTR lpIconName)
{
	if(FWide())
		return LoadIconW(hInstance, lpIconName);

	if(FATOM(lpIconName))
		return LoadIconA(hInstance, (LPSTR)lpIconName);

	PreConvert();
	LPSTR sz = Convert(lpIconName);
	return LoadIconA(hInstance, sz);
}

HINSTANCE
WINAPI
OLoadLibraryW(
	LPCWSTR pwszFileName
	)
{
	if(FWide())
		return LoadLibraryW(pwszFileName);

	PreConvert();
	LPSTR sz = Convert(pwszFileName);
	return LoadLibraryA(sz);
}

HMODULE
WINAPI
OLoadLibraryExW(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
	)
{
	if(FWide())
		return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

	PreConvert();
	LPSTR sz = Convert(lpLibFileName);
	return LoadLibraryExA(sz, hFile, dwFlags);
}

HMENU
WINAPI
OLoadMenuIndirectW(
	CONST MENUTEMPLATEW *lpMenuTemplate)
{
	if(FWide())
		return LoadMenuIndirectW(lpMenuTemplate);

	//$NOTE: For both the ANSI and the Unicode version of this function,
	//the strings in the MENUITEMTEMPLATE structure must be Unicode strings

	return LoadMenuIndirectA(lpMenuTemplate);
}

HMENU
WINAPI
OLoadMenuW(
	HINSTANCE hInstance,
	LPCWSTR lpMenuName)
{
	if(FWide())
		return LoadMenuW(hInstance, lpMenuName);

	if(FATOM(lpMenuName))
		return LoadMenuA(hInstance, (LPCSTR)lpMenuName);

	PreConvert();
	LPSTR sz = Convert(lpMenuName);
	return LoadMenuA(hInstance, sz);
}

int
WINAPI
OLoadStringW(
	HINSTANCE hInstance,
	UINT uID,
	LPWSTR lpBuffer,
	int nBufferMax)
{
	if(FWide())
		return LoadStringW(hInstance, uID,  lpBuffer, nBufferMax);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferMax);
	int nRet = LoadStringA(hInstance, uID, sz, sizeof(WCHAR) * nBufferMax);

	if (!nRet)
		{
		if (lpBuffer && 0 < nBufferMax)
			{
			*lpBuffer = L'\0';
			}
		return 0;
		}

	LONG lRet = AnsiToUnicode(lpBuffer, sz, nBufferMax, nRet + 1); // '\0'
	if (lRet)
		{
		return lRet - 1;
		}

	LPWSTR szBuff = SzWAlloc(nRet + 1);
	lRet = AnsiToUnicode(szBuff, sz, nRet + 1, nRet + 1);
	Assert(lRet);
	memcpy(lpBuffer, szBuff, sizeof(WCHAR) * nBufferMax);
	lpBuffer[nBufferMax - 1] = L'\0';
	return nBufferMax - 1;
}

LPWSTR
WINAPI
OlstrcatW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1 || !lpString2)
		return lpString1;

	return wcscat(lpString1, lpString2);
}

int
WINAPI
OlstrcmpiW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpiW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpiA(psz1, psz2);
}

int
WINAPI
OlstrcmpW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpA(psz1, psz2);
}

LPWSTR
WINAPI
OlstrcpyW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1)
		return lpString1;

	if (!lpString2)
		lpString2 = L"";

	return wcscpy(lpString1, lpString2);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith added null string pointer handling
LPWSTR
WINAPI
OlstrcpynW(
	LPWSTR lpString1,
	LPCWSTR lpString2,
	int iMaxLength
	)
{
	if (!lpString1)
		{
		return lpString1;
		}

	if (!lpString2)
		{
		lpString2 = L"";
		}

	if(FWide())
		return lstrcpynW(lpString1, lpString2, iMaxLength);

	lpString1[--iMaxLength] = L'\0';
	return wcsncpy(lpString1, lpString2, iMaxLength);
}

int
WINAPI
OlstrlenW(
	LPCWSTR lpString
	)
{
	return lpString ? wcslen(lpString) : 0;
}

UINT
WINAPI
OMapVirtualKeyW(
	UINT uCode,
	UINT uMapType)
{
	// The only person using this so far is using uMapType == 0
	Assert(2 != uMapType);
	if (FWide())
		return MapVirtualKeyW(uCode, uMapType);
	return MapVirtualKeyA(uCode, uMapType);
}

int
WINAPI
OMessageBoxW(
	HWND hWnd ,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType)
{
	if(FWide())
		return MessageBoxW(hWnd, lpText, lpCaption, uType);

	PreConvert();
	LPSTR szText = Convert(lpText);
	LPSTR szCap  = Convert(lpCaption);

	return MessageBoxA(hWnd, szText, szCap, uType);
}

int
WINAPI
OMessageBoxIndirectW(
	LPMSGBOXPARAMSW lpmbp)
{
	Assert(!IsBadWritePtr((void*)lpmbp, sizeof MSGBOXPARAMSW));
	Assert(sizeof MSGBOXPARAMSW == lpmbp->cbSize);
	Assert(sizeof MSGBOXPARAMSW == sizeof MSGBOXPARAMSA);

	if(FWide())
		return MessageBoxIndirectW(lpmbp);

	PreConvert();

	MSGBOXPARAMSA mbpa;
	memcpy(&mbpa, lpmbp, sizeof MSGBOXPARAMSA);

	if (!FATOM(lpmbp->lpszText))
		{
		mbpa.lpszText = Convert(lpmbp->lpszText);
		}
	if (!FATOM(lpmbp->lpszCaption))
		{
		mbpa.lpszCaption = Convert(lpmbp->lpszCaption);
		}
	if ((lpmbp->dwStyle & MB_USERICON) && !FATOM(lpmbp->lpszIcon))
		{
		mbpa.lpszIcon = Convert(lpmbp->lpszIcon);
		}

	return MessageBoxIndirectA(&mbpa);
}

BOOL
WINAPI
OModifyMenuW(
	HMENU hMnu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if (MF_STRING == uFlags)
		{
		PreConvert();
		LPSTR sz = Convert(lpNewItem);
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, sz);
		}
	else
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, (LPSTR) lpNewItem);

}


// From: Mark Ashton on 5/29/97
BOOL
WINAPI
OMoveFileExW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	DWORD dwFlags
	)
{
	if (FWide())
		return MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileExA(szOld, szNew, dwFlags);
}

BOOL
WINAPI
OMoveFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName)
{
	if(FWide())
		return MoveFileW(lpExistingFileName, lpNewFileName);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileA(szOld, szNew);
}

HANDLE
WINAPI
OLoadImageW(
	HINSTANCE hinst,
	LPCWSTR lpszName,
	UINT uType,
	int cxDesired,
	int cyDesired,
	UINT fuLoad)
{
	if (FWide())
		{
		Assert(!(LR_LOADFROMFILE & fuLoad));
		return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
		}

	if (!FATOM(lpszName))
		{
		PreConvert();
		LPSTR pszName = Convert(lpszName);
		return LoadImageA(hinst, pszName, uType, cxDesired, cyDesired, fuLoad);
		}
	 else
		return LoadImageA(hinst, (LPSTR) lpszName, uType, cxDesired, cyDesired, fuLoad);
}

BOOL
WINAPI
OOemToCharW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst)
{
	if(FWide())
		{
		Assert(lpszSrc != (LPCSTR) lpszDst);
#pragma prefast(suppress:56, "do not know the size of the destination buffer")
		return OemToCharW(lpszSrc, lpszDst);
		}

	DWORD cb = _mbslen((const unsigned char *)lpszSrc);
	LPSTR szDst = SzAlloc(cb);
#pragma prefast(suppress:56, "noise")
	BOOL fRet = OemToCharA(lpszSrc, szDst);
	if(fRet)
		{
		Verify(0 <= AnsiToUnicode(lpszDst, szDst, cb));
		}
	return fRet;
}

VOID
WINAPI
OOutputDebugStringW(
	LPCWSTR lpOutputString
	)
{
	if(FWide())
		{
		OutputDebugStringW(lpOutputString);
		return;
		}

	PreConvert();
	LPSTR sz = Convert(lpOutputString);

	if (NULL == sz)
	    return;

	OutputDebugStringA(sz);
}

BOOL
WINAPI
OPeekMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax,
	UINT wRemoveMsg)
{
	if(FWide())
		return PeekMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

	return PeekMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

BOOL
WINAPI
OPostMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return PostMessageW(hWnd, Msg, wParam, lParam);

	return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OPostThreadMessageW(
	DWORD idThread,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
 {
	if (FWide())
		return PostThreadMessageW(idThread, Msg, wParam, lParam);

	return PostThreadMessageA(idThread, Msg, wParam, lParam);
 }


// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyExW(
	HKEY hKey,
	LPCWSTR lpSubKey,
	DWORD Reserved,
	LPWSTR lpClass,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	Assert(lpSubKey);
	if(FWide())
		return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	LPSTR sz2 = Convert(lpClass);
	return RegCreateKeyExA(hKey, sz, Reserved, sz2, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyW (
	HKEY hKey,
	LPCWSTR lpSubKey,
	PHKEY phkResult
	)
{
	if (FWide())
		return RegCreateKeyW(hKey, lpSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	return RegCreateKeyA(hKey, sz, phkResult);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegEnumKeyW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	DWORD cbName
	)
{
	if (FWide())
		return RegEnumKeyW(hKey, dwIndex, lpName, cbName);

	LPSTR sz = SzAlloc(cbName);
	LONG dwRet = RegEnumKeyA(hKey, dwIndex, sz, cbName);
	Verify(0 <= AnsiToUnicode(lpName, sz, cbName));
	return dwRet;
}

//  Van Kichline
//  IHammer group
//  Not supported: REG_MULTI_SZ
//
LONG
APIENTRY
ORegEnumValueW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpValueName,
	LPDWORD lpcbValueName,  // Documentation indicates this is a count of characters, despite the Hungarian.
	LPDWORD lpReserved,
	LPDWORD lpType,         // May be NULL, but we need to know it on return if lpData is not NULL.
	LPBYTE lpData,          // May be NULL
	LPDWORD lpcbData        // May be NULL is lpData is NULL
	)
{
	if (FWide())
		return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

	// Required pointers:
	if (!lpValueName || !lpcbValueName || !lpcbData && lpData)
		{
		Assert(lpValueName);
		Assert(lpcbValueName);
		Assert(!lpcbData && lpData);
		return E_POINTER;
		}

	// If NULL was specified for lpType, we need to supply our own so we can check for string results.
	DWORD dwPrivateType = 0;
	if (!lpType)
		{
		lpType = &dwPrivateType;
		}

	DWORD cbValueName  = *lpcbValueName;
	DWORD dwOrigCbData = lpcbData ? *lpcbData : 0;
	LPSTR pchValueName = SzAlloc(*lpcbValueName);

	LONG lResult = RegEnumValueA(hKey, dwIndex, pchValueName, &cbValueName, lpReserved, lpType, lpData, lpcbData);

	if (ERROR_SUCCESS == lResult)
		{
		*lpcbValueName = AnsiToUnicode(lpValueName, pchValueName, min(*lpcbValueName, cbValueName + 1)) - 1; // Returned value does NOT include terminating NULL

		if (lpData)
			{
			// If the resulting data was a string, convert it in place.
			switch (*lpType)
				{
				case REG_MULTI_SZ:
					// Not supported
					Assert(0 && REG_MULTI_SZ);
					lResult = E_FAIL;
					break;
				case REG_EXPAND_SZ:
				case REG_SZ:
					{
					Assert(lpcbData);
					LPSTR pszTemp = SzAlloc(*lpcbData); // is the number of bytes!
					memcpy(pszTemp, lpData, *lpcbData);
					*lpcbData = AnsiToUnicode((LPWSTR)lpData, pszTemp, dwOrigCbData/sizeof(WCHAR), *lpcbData) * sizeof(WCHAR);

					//	It's possible to encounter a second stage overflow, if lpData >= sizeof(Unicode)/2
					if ( 0 == *lpcbData )
						{
						lResult = ERROR_MORE_DATA;
						}
					}
					break;
				}
			}
		}

	return lResult;
}

LONG
APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
	if(FWide())
		return RegOpenKeyW(hKey, pwszSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	return RegOpenKeyA(hKey, sz, phkResult);
}

LONG
APIENTRY
ORegDeleteKeyW(
	HKEY hKey,
	LPCWSTR pwszSubKey
	)
{
	Assert(pwszSubKey);
	if(FWide())
		return RegDeleteKeyW(hKey, pwszSubKey);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);
	return RegDeleteKeyA(hKey, sz);
}

LONG
APIENTRY
ORegDeleteValueW(
	HKEY hKey,
	LPWSTR lpValueName
	)
{
	if(FWide())
		return RegDeleteValueW (hKey, lpValueName);

	PreConvert();
	LPSTR sz = Convert(lpValueName);
	return RegDeleteValueA(hKey, sz);
}

ATOM
WINAPI
ORegisterClassW(
	CONST WNDCLASSW *lpWndClass)
{
	if(FWide())
		return RegisterClassW(lpWndClass);

	WNDCLASSA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!(IsBadReadPtr(wc.lpszMenuName, sizeof(* wc.lpszMenuName)) ||
		  IsBadReadPtr(lpWndClass->lpszMenuName, sizeof (*(lpWndClass->lpszMenuName)))))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassA(&wc);
}

ATOM
WINAPI
ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass)
{
	if (FWide())
		return RegisterClassExW(lpWndClass);

	WNDCLASSEXA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!FATOM(wc.lpszMenuName))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	if (!FATOM(wc.lpszClassName))
		wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassExA(&wc);
}

BOOL
WINAPI
OUnregisterClassW
(
LPCTSTR  lpClassName,   // address of class name string
HINSTANCE  hInstance    // handle of application instance
)
{
	if(FWide())
		return UnregisterClassW(lpClassName, hInstance);

	if (FATOM(lpClassName))
		return UnregisterClassW(lpClassName, hInstance);

	PreConvert();
	LPSTR sz = Convert(lpClassName);

	return UnregisterClassA(sz, hInstance);
}

UINT
WINAPI
ORegisterClipboardFormatW(
	LPCWSTR lpszFormat)
{
	if(FWide())
		return RegisterClipboardFormatW(lpszFormat);

	PreConvert();
	LPSTR sz = Convert(lpszFormat);
	if (sz == NULL)
		return(0);

	return RegisterClipboardFormatA(sz);
}

UINT
WINAPI
ORegisterWindowMessageW(LPCWSTR lpString)
{
	if(FWide())
		return RegisterWindowMessageW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	if (sz == NULL)
		return(0);

	return  RegisterWindowMessageA(sz);
}

LONG
APIENTRY
ORegOpenKeyExW (
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if(FWide())
		return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);

	return RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
}

LONG
APIENTRY
ORegQueryInfoKeyW (
	HKEY hKey,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	LPDWORD lpReserved,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcbMaxClassLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	Assert(!lpClass && !lpcbClass); //$ UNDONE_POST_98 - Not wrapped yet!
	if(FWide())
		return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved,
								lpcSubKeys, lpcbMaxSubKeyLen,
								lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
								lpcbMaxValueLen, lpcbSecurityDescriptor,
								lpftLastWriteTime );

	if (lpClass && (!lpcbClass || IsBadWritePtr(lpcbClass, sizeof(lpcbClass))))
		{
		// lpcbClass must be valid if lpClass is non-NULL
		return ERROR_INVALID_PARAMETER;
		}

	return RegQueryInfoKeyA(hKey, NULL, NULL, lpReserved,
							lpcSubKeys, lpcbMaxSubKeyLen,
							lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
							lpcbMaxValueLen, lpcbSecurityDescriptor,
							lpftLastWriteTime );
}

LONG
APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
	PLONG   lpcbValue)
{
	if(FWide())
		return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);

	LONG  cb;
	LONG  lRet    = 0;
	LPSTR szValue = NULL;
	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	lRet = RegQueryValueA(hKey, sz, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}
	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!pwszValue)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		goto Exit;
		}


	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
		{
		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	szValue = SzAlloc(cb);

	lRet = RegQueryValueA(hKey, sz, szValue, &cb);

	if (ERROR_SUCCESS == lRet)
		{
		Verify(0 <= AnsiToUnicode(pwszValue, szValue, cb));

		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		}
	else if (pwszValue && 0 < cb)
		{
		*pwszValue = L'\0';
		}

Exit:

	return lRet;
}

LONG
APIENTRY
ORegSetValueExW(
	HKEY hKey,
	LPCWSTR lpValueName,
	DWORD Reserved,
	DWORD dwType,
	CONST BYTE* lpData,
	DWORD cbData
	)
{
	if(FWide())
		return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

	PreConvert();
	LPSTR sz = Convert(lpValueName);

	LONG lRet;

	// NOTE: when calling RegSetValueExA, if the data type is
	// REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, then the API expects the strings
	// to be ansi also.
	if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPTSTR)lpData, -1, &lData);
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else if (REG_MULTI_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPWSTR)lpData,
									  cUnicodeMultiSzLen((LPWSTR)lpData),
									  &lData );
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else
		{
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, lpData, cbData);
		}

	return lRet;
}

LONG
APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
	LPCWSTR lpData, DWORD cbData)
{
	Assert(REG_SZ == dwType);

	if(FWide())
		return RegSetValueW(hKey, lpSubKey, dwType,
			lpData, cbData);

	PreConvert();
	LPSTR szKey   = Convert(lpSubKey);
	LPSTR szValue = Convert(lpData);

	return RegSetValueA(hKey, szKey, dwType, szValue, cbData);
}

LONG
APIENTRY
ORegQueryValueExW (
	HKEY hKey,
	LPCWSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData
	)
{
	Assert(lpcbData || !lpData); // lpcbData can be NULL only if lpData is NULL
	if(FWide())
		return RegQueryValueExW (
			hKey,
			lpValueName,
			lpReserved,
			lpType,
			lpData,
			lpcbData
			);

	LPBYTE lpTempBuffer;
	DWORD dwTempType;
	DWORD cb, cbRequired;
	LONG  lRet;
	PreConvert();
	LPSTR sz = Convert(lpValueName);

	lRet = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!lpData)
		{
		switch (dwTempType)
			{
			case REG_EXPAND_SZ:
			case REG_MULTI_SZ:
			case REG_SZ:
				// Adjust size of buffer to report, to account for CHAR -> WCHAR

				*lpcbData = cb * sizeof(WCHAR);
				break;

			default:
				*lpcbData = cb;
				break;
			}

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		goto Exit;
		}


	//
	// Determine the size of buffer needed
	//

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:
			cbRequired = cb * sizeof(WCHAR);
			break;

		default:
			cbRequired = cb;
			break;
		}

	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbData < cbRequired)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbData = cbRequired;

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:

			lpTempBuffer = (LPBYTE)SzAlloc(cbRequired);

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									&dwTempType,
									lpTempBuffer,
									&cb);

			if (ERROR_SUCCESS == lRet)
				{
				switch (dwTempType)
					{
					case REG_EXPAND_SZ:
					case REG_MULTI_SZ:
					case REG_SZ:

						*lpcbData = AnsiToUnicode((LPWSTR)lpData, (LPSTR)lpTempBuffer, *lpcbData, cb);
						*lpcbData = cb * sizeof(WCHAR); // Result it in BYTES!

						// Set the type, if required.
						if (lpType)
							{
							*lpType = dwTempType;
							}
						break;
					}
				}

			goto Exit;

		default:

			//
			// No conversion of out parameters needed.  Just call narrow
			// version with args passed in, and return directly.
			//

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									lpType,
									lpData,
									lpcbData);

		}

Exit:

	return lRet;
}

HANDLE
WINAPI
ORemovePropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return RemovePropW(hWnd, lpString);

	if(FATOM(lpString))
		return RemovePropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return RemovePropA(hWnd, sz);
}

LRESULT
WINAPI
OSendDlgItemMessageW(
	HWND hDlg,
	int nIDDlgItem,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

	PreConvert();
	switch (Msg)
		{
		case LB_ADDSTRING:
		case LB_INSERTSTRING:
		case LB_SELECTSTRING:
		case LB_FINDSTRING:
		case LB_FINDSTRINGEXACT:
		case CB_ADDSTRING:
		case CB_INSERTSTRING:
		case CB_SELECTSTRING:
		case CB_FINDSTRING:
		case CB_FINDSTRINGEXACT:
			{
			lParam = (LPARAM)Convert((LPWSTR)lParam);
			break;
			}
		}

	return SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
}

LRESULT
WINAPI
OSendMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return SendMessageW(hWnd, Msg, wParam, lParam);

	return SendMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSendNotifyMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendNotifyMessageW(hWnd, Msg, wParam, lParam);

	return SendNotifyMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPCWSTR lpString)
{
	if(FWide())
		return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetDlgItemTextA(hDlg, nIDDlgItem, sz);
}

BOOL
WINAPI
OSetFileAttributesW(
	LPCWSTR lpFileName,
	DWORD dwFileAttributes
	)
{
	if (FWide())
		return SetFileAttributesW(lpFileName, dwFileAttributes);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(0);

	return SetFileAttributesA(sz, dwFileAttributes);
}

BOOL
WINAPI
OSetPropW(
	HWND hWnd,
	LPCWSTR lpString,
	HANDLE hData)
{
	if(FWide())
		return SetPropW(hWnd, lpString, hData);

	if(FATOM(lpString))
		return SetPropA(hWnd, (LPSTR)lpString, hData);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetPropA(hWnd, sz, hData);
}

BOOL
WINAPI
OSetMenuItemInfoW(
	HMENU hMenu,
	UINT uItem,
	BOOL fByPosition,
	LPCMENUITEMINFOW lpcmii
	)
{
	Assert(!IsBadWritePtr((void*)lpcmii, sizeof MENUITEMINFOW));
	Assert(sizeof MENUITEMINFOW == lpcmii->cbSize);
	Assert(sizeof MENUITEMINFOW == sizeof MENUITEMINFOA);

	if (FWide())
		return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpcmii);

	MENUITEMINFOA mii;
	memcpy(&mii, lpcmii, sizeof MENUITEMINFOA);

	if (!(lpcmii->fMask & MIIM_TYPE) ||
		MFT_STRING != (lpcmii->fType &
				  (MFT_BITMAP | MFT_SEPARATOR | MFT_OWNERDRAW | MFT_STRING) ) )
		{
		return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
		}

	PreConvert();
	mii.dwTypeData = Convert(lpcmii->dwTypeData);
	return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
}

LONG
WINAPI
OSetWindowLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if(FWide())
		return SetWindowLongW(hWnd, nIndex, dwNewLong);

	return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

HHOOK
WINAPI
OSetWindowsHookExW(
	int idHook,
	HOOKPROC lpfn,
	HINSTANCE hmod,
	DWORD dwThreadId)
{
	if(FWide())
		return SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId);

	return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);  //$ CONSIDER - Not really wrapped
}

BOOL
WINAPI
OSetWindowTextW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return SetWindowTextW(hWnd, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetWindowTextA(hWnd, sz);
}

LONG
WINAPI
OTabbedTextOutW(
	HDC hDC,
	int X,
	int Y,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions,
	int nTabOrigin)
{
	Assert(-1 != nCount);

	if(FWide())
		return TabbedTextOutW(hDC, X, Y, lpString, nCount, nTabPositions,
			lpnTabStopPositions, nTabOrigin);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);
	if (sz == NULL)
		return(0);

	return TabbedTextOutA(hDC, X, Y, sz, n, nTabPositions,
						  lpnTabStopPositions, nTabOrigin );
}

int
WINAPI
OTranslateAcceleratorW(
	HWND hWnd,
	HACCEL hAccTable,
	LPMSG lpMsg)
{
	if(FWide())
		return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

	return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
}

SHORT
WINAPI
OVkKeyScanW(
	WCHAR ch)
{
	if (FWide())
		return VkKeyScanW(ch);
	TCHAR szW[2];
	char szA[2];
	szW[0] = ch;
	szW[1] = L'\0';
	Verify(0 <= UnicodeToAnsi(szA, szW, 2));
	return VkKeyScanA(szA[0]);
}

BOOL
WINAPI
OWinHelpW(
	HWND hWndMain,
	LPCWSTR lpszHelp,
	UINT uCommand,
	DWORD dwData
	)
{
	if(FWide())
		return WinHelpW(hWndMain, lpszHelp, uCommand,dwData);

	PreConvert();
	LPSTR sz = Convert(lpszHelp);
	return WinHelpA(hWndMain, sz, uCommand, dwData);
}

BOOL
WINAPI
OWritePrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString,
	LPCWSTR lpFileName)
{
	if(FWide())
		return WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szString   = Convert(lpString);
	LPSTR szFileName = Convert(lpFileName);

	return WritePrivateProfileStringA(szAppName, szKeyName, szString, szFileName);
}

int
WINAPIV
OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
	va_list vaArgs;
	va_start(vaArgs, pwszFormat);
	int retval;

	if(FWide())
		retval = wvsprintfW(pwszOut, pwszFormat, vaArgs);
	else
		retval = _vstprintf(pwszOut, pwszFormat, vaArgs); //$CONSIDER Why isn't this vswprint?

	va_end(vaArgs);
	return retval;
}

BOOL
WINAPI
OGetVersionExW(
	LPOSVERSIONINFOW lpVersionInformation
	)
{
	if(FWide())
		return GetVersionExW(lpVersionInformation);

	if (lpVersionInformation->dwOSVersionInfoSize < sizeof(OSVERSIONINFOW))
		return false;

	OSVERSIONINFOA  osviVersionInfo;
	osviVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	int fRetval = GetVersionExA(&osviVersionInfo);

	if (fRetval)
		{
		memcpy(lpVersionInformation, &osviVersionInfo, sizeof(OSVERSIONINFOA));

		Verify(0 <= AnsiToUnicode(lpVersionInformation->szCSDVersion,
								 osviVersionInfo.szCSDVersion,
								 sizeof(lpVersionInformation->szCSDVersion)
								 /sizeof(lpVersionInformation->szCSDVersion[0])));
		}

	return fRetval;
}

LONG
APIENTRY
ORegEnumKeyExW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	LPDWORD lpcbName,
	LPDWORD lpReserved,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	PFILETIME lpftLastWriteTime
	)
{
	if(FWide())
		return RegEnumKeyExW (
			hKey,
			dwIndex,
			lpName,
			lpcbName,
			lpReserved,
			lpClass,
			lpcbClass,
			lpftLastWriteTime
			);

	LPSTR szName, szClass;
	DWORD cbName, cbClass;

	if (lpcbName)
		{
		cbName = sizeof(WCHAR) * *lpcbName;
		szName = lpName ? SzAlloc(cbName) : NULL;
		}
	else
		{
		szName = NULL;
		cbName = 0;
		}

	if (lpcbClass)
		{
		cbClass = sizeof(WCHAR) * (*lpcbClass);
		szClass = lpClass ? SzAlloc(cbClass) : NULL;
		}
	else
		{
		szClass = NULL;
		cbClass = 0;
		}

	if (szName == NULL)
		return(ERROR_BUFFER_OVERFLOW);

	LONG lRet = RegEnumKeyExA(hKey, dwIndex, szName, &cbName, lpReserved,
							  szClass, &cbClass, lpftLastWriteTime );

	if (ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// Get the number of characters instead of number of bytes.
	if (lpcbName)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpName, (LPSTR) szName, *lpcbName);
		if (cbName && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbName = dwNoOfChar;
		}

	if (lpcbClass && lpClass)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpClass, (LPSTR) szClass, *lpcbClass);

		if (cbClass && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbClass = dwNoOfChar;
		}

	return lRet;

}

HANDLE
WINAPI
OCreateFileMappingW(
	HANDLE hFile,
	LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, sz);
}

LRESULT
WINAPI
ODefDlgProcW(
	HWND hDlg,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return DefDlgProcW(hDlg, Msg, wParam, lParam);

	return DefDlgProcA(hDlg, Msg, wParam, lParam);
}

int
WINAPI
OGetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPWSTR  lpLCData,
	int      cchData)
{
	DWORD dwRet;

	if (FWide())
		return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

	if (!cchData || !lpLCData)
		return GetLocaleInfoA(Locale, LCType, NULL, cchData);

	int cchDataAnsi = sizeof(WCHAR) * cchData;
	LPSTR szBuffer = SzAlloc(cchDataAnsi);

	dwRet = GetLocaleInfoA(Locale, LCType, szBuffer, cchDataAnsi);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		return AnsiToUnicode(lpLCData, szBuffer, cchData, dwRet);
		}
	else if (lpLCData && 0 < cchData)
		{
		*lpLCData = L'\0';
		}

	return dwRet;
}

BOOL
WINAPI
OSetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPCWSTR lpLCData)
{
	if (FWide())
		return SetLocaleInfoW(Locale, LCType, lpLCData);
	PreConvert();
	LPSTR sz = Convert(lpLCData);
	if (sz == NULL)
		return(0);

	return SetLocaleInfoA(Locale, LCType, sz);
}

// $UNDONE_POST_98$ Workaround because StgCreateDocfile is not reentrant.
//          We were getting ACCESS DENIED errors when multiple threads opened
//             temp files simultaneously.

//-----------------------------------------------------------------------------
// Name: StgCreateDocfileCriticalSection
//
// Description:
// Used solely by OStgCreateDocfile in order to protect its call to
// StgCreateDocfile from simultaneously entry by multiple threads.
//
//-----------------------------------------------------------------------------
class StgCreateDocfileCriticalSection
{
public:
	StgCreateDocfileCriticalSection() {InitializeCriticalSection(&m_critsec);}
	~StgCreateDocfileCriticalSection() {DeleteCriticalSection(&m_critsec);}
	VOID VEnter() {EnterCriticalSection(&m_critsec);}
	VOID VLeave() {LeaveCriticalSection(&m_critsec);}
private:
	CRITICAL_SECTION m_critsec;
};

#pragma warning(disable: 4717) // IA64 build fix
//-----------------------------------------------------------------------------
// Name: OStgCreateDocfile
//
// Description:
// Wrapper for StgCreateDocfile to protect against reentrancy bug in OLE.
//
// Thread-Safety: Bullet-proof
//
// Return Values: same HRESULT as StgCreateDocfile
//-----------------------------------------------------------------------------
HRESULT
WINAPI
OStgCreateDocfile
(
const WCHAR * pwcsName,
DWORD grfMode,
DWORD reserved,
IStorage ** ppstgOpen
)
{
	static StgCreateDocfileCriticalSection Crit;
	Crit.VEnter();
	HRESULT hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
	Crit.VLeave();
	return hrReturn;
}
#pragma warning(default: 4717) // IA64 build fix

int
WINAPI
OStartDocW
(
HDC hDC,
CONST DOCINFOW * pdiDocW
)
{
	if (FWide())
		return StartDocW(hDC, pdiDocW);

	DOCINFOA diDocA;

	PreConvert();

	diDocA.lpszDocName  = Convert(pdiDocW->lpszDocName);
	diDocA.lpszOutput   = Convert(pdiDocW->lpszOutput);
	diDocA.lpszDatatype = Convert(pdiDocW->lpszDatatype);
	diDocA.cbSize       = sizeof(DOCINFOA);
	diDocA.fwType       = pdiDocW->fwType;

	return StartDocA(hDC, &diDocA);

}

BOOL
WINAPI
OSystemParametersInfoW(
	UINT uiAction,
	UINT uiParam,
	PVOID pvParam,
	UINT fWinIni)
{
	if (FWide())
		return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

	switch (uiAction)
		{   // unsupported actions
		case SPI_GETHIGHCONTRAST:
		case SPI_GETICONMETRICS:
		case SPI_GETICONTITLELOGFONT:
		case SPI_GETNONCLIENTMETRICS:
		case SPI_GETSERIALKEYS:
		case SPI_GETSOUNDSENTRY:

		case SPI_SETDESKWALLPAPER:
		case SPI_SETHIGHCONTRAST:
		case SPI_SETICONMETRICS:
		case SPI_SETICONTITLELOGFONT:
		case SPI_SETNONCLIENTMETRICS:
		case SPI_SETSERIALKEYS:
		case SPI_SETSOUNDSENTRY:
			AssertFail("No Unicode Wrapper Available for Win32 API - SystemParametersInfoW");
			return 0;
		};
	return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);
}

LPWSTR
WINAPI
OCharNextW(
LPCWSTR lpsz)
{
	if ( FWide() )
		return CharNextW( lpsz );

	if (*lpsz == L'\0')
		{
		return const_cast<LPWSTR>(lpsz);
		}

	return const_cast<LPWSTR>(lpsz + 1);
}


#ifdef DEBUG
BOOL
APIENTRY
OAbortSystemShutdownW(
	LPWSTR lpMachineName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AbortSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OAccessCheckAndAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	DWORD DesiredAccess,
	PGENERIC_MAPPING GenericMapping,
	BOOL ObjectCreation,
	LPDWORD GrantedAccess,
	LPBOOL AccessStatus,
	LPBOOL pfGenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AccessCheckAndAuditAlarmW");
	return 0;
}

int
WINAPI OAddFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFontResourceW");
	return 0;
}

BOOL
WINAPI
OAddFormW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFormW");
	return 0;
}

BOOL
WINAPI
OAddJobW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pData,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddJobW");
	return 0;
}

BOOL
WINAPI
OAddMonitorW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddMonitorW");
	return 0;
}

BOOL
WINAPI
OAddPortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPortW");
	return 0;
}

HANDLE
WINAPI
OAddPrinterW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPrinter
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterW");
	return 0;
}

BOOL
WINAPI
OAddPrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterConnectionW");
	return 0;
}

BOOL
WINAPI
OAddPrinterDriverW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pDriverInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OAddPrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPathName,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProcessorW");
	return 0;
}

BOOL
WINAPI
OAddPrintProvidorW(
	LPWSTR  pName,
	DWORD    level,
	LPBYTE   pProvidorInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProvidorW");
	return 0;
}

LONG
WINAPI
OAdvancedDocumentPropertiesW(
	HWND    hWnd,
	HANDLE  hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AdvancedDocumentPropertiesW");
	return 0;
}

MMRESULT WINAPI OauxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - auxGetDevCapsW");
	return 0;
}

BOOL
WINAPI
OBackupEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BackupEventLogW");
	return 0;
}

HANDLE
WINAPI
OBeginUpdateResourceW(
	LPCWSTR pFileName,
	BOOL bDeleteExistingResources
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BeginUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBW(
	LPCWSTR lpDef,
	LPDCB lpDCB
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBAndTimeoutsW(
	LPCWSTR lpDef,
	LPDCB lpDCB,
	LPCOMMTIMEOUTS lpCommTimeouts
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBAndTimeoutsW");
	return 0;
}

BOOL
WINAPI
OCallMsgFilterW(
	LPMSG lpMsg,
	int nCode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallMsgFilterW");
	return 0;
}

BOOL
WINAPI
OCallNamedPipeW(
	LPCWSTR lpNamedPipeName,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesRead,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallNamedPipeW");
	return 0;
}

LONG
WINAPI
OChangeDisplaySettingsW(
	LPDEVMODEW lpDevMode,
	DWORD dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeDisplaySettingsW");
	return 0;
}

BOOL
WINAPI
OChangeMenuW(
	HMENU hMenu,
	UINT cmd,
	LPCWSTR lpszNewItem,
	UINT cmdInsert,
	UINT flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeMenuW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OChangeServiceConfigW(
	SC_HANDLE    hService,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword,
	LPCWSTR     lpDisplayName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeServiceConfigW");
	return 0;
}
#endif

BOOL
WINAPI
OCharToOemBuffW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharToOemBuffW");
	return 0;
}

DWORD
WINAPI
OCharUpperBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharUpperBuffW");
	return 0;
}

BOOL
WINAPI
OChooseColorW(
	LPCHOOSECOLORW lpcc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseColorW");
	return 0;
}

BOOL
APIENTRY OChooseFontW(LPCHOOSEFONTW pchfw)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseFontW");
	return 0;
}

BOOL
WINAPI
OClearEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ClearEventLogW");
	return 0;
}

BOOL
WINAPI
OCommConfigDialogW(
	LPCWSTR lpszName,
	HWND hWnd,
	LPCOMMCONFIG lpCC
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CommConfigDialogW");
	return 0;
}

int
WINAPI
OCompareStringW(
	LCID     Locale,
	DWORD    dwCmpFlags,
	LPCWSTR lpString1,
	int      cchCount1,
	LPCWSTR lpString2,
	int      cchCount2)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CompareStringW");
	return 0;
}

BOOL
WINAPI
OConfigurePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ConfigurePortW");
	return 0;
}

int
WINAPI
OCopyAcceleratorTableW(
	HACCEL hAccelSrc,
	LPACCEL lpAccelDst,
	int cAccelEntries)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyAcceleratorTableW");
	return 0;
}

HENHMETAFILE
WINAPI
OCopyEnhMetaFileW(HENHMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyEnhMetaFileW");
	return 0;
}

HMETAFILE
WINAPI
OCopyMetaFileW(HMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyMetaFileW");
	return 0;
}

HACCEL
WINAPI
OCreateAcceleratorTableW(
	LPACCEL, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateAcceleratorTableW");
	return 0;
}

WINAPI
OCreateColorSpaceW(LPLOGCOLORSPACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateColorSpaceW");
	return 0;
}

HDC
WINAPI
OCreateDCW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDCW");
	return 0;
}

HDESK
WINAPI
OCreateDesktopW(
	LPWSTR lpszDesktop,
	LPWSTR lpszDevice,
	LPDEVMODEW pDevmode,
	DWORD dwFlags,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDesktopW");
	return 0;
}

HWND
WINAPI
OCreateDialogIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW lpTemplate,
	HWND hWndParent,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogIndirectParamW");
	return 0;
}

HWND
WINAPI
OCreateDialogParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogParamW");
	return 0;
}

HDC
WINAPI
OCreateICW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpdvmInit)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateICW");
	return 0;
}

HANDLE
WINAPI
OCreateMailslotW(
	LPCWSTR lpName,
	DWORD nMaxMessageSize,
	DWORD lReadTimeout,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMailslotW");
	return 0;
}

HANDLE
WINAPI
OCreateMutexW(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMutexW");
	return 0;
}

HANDLE
WINAPI
OCreateNamedPipeW(
	LPCWSTR lpName,
	DWORD dwOpenMode,
	DWORD dwPipeMode,
	DWORD nMaxInstances,
	DWORD nOutBufferSize,
	DWORD nInBufferSize,
	DWORD nDefaultTimeOut,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateNamedPipeW");
	return 0;
}

BOOL
WINAPI
OCreateProcessW(
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessW");
	return 0;
}

BOOL
WINAPI
OCreateProcessAsUserW (
	HANDLE hToken,
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessAsUserW");
	return 0;
}

HPROPSHEETPAGE
WINAPI
OCreatePropertySheetPageW(
	LPCPROPSHEETPAGEW lpcpsp
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreatePropertySheetPageW");
	return 0;
}

BOOL
WINAPI
OCreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateScalableFontResourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OCreateServiceW(
	SC_HANDLE    hSCManager,
	LPCWSTR     lpServiceName,
	LPCWSTR     lpDisplayName,
	DWORD        dwDesiredAccess,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateServiceW");
	return 0;
}
#endif

HWND WINAPI OCreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateStatusWindowW");
	return 0;
}

HWINSTA
WINAPI
OCreateWindowStationW(
	LPWSTR lpwinsta,
	DWORD dwReserved,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateWindowStationW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ODceErrorInqTextW (
	IN RPC_STATUS RpcStatus,
	OUT unsigned short __RPC_FAR * ErrorText
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DceErrorInqTextW");
	return 0;
}

BOOL
WINAPI
ODefineDosDeviceW(
	DWORD dwFlags,
	LPCWSTR lpDeviceName,
	LPCWSTR lpTargetPath
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DefineDosDeviceW");
	return 0;
}

BOOL
WINAPI
ODeleteFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteFormW");
	return 0;
}

BOOL
WINAPI
ODeleteMonitorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteMonitorW");
	return 0;
}

BOOL
WINAPI
ODeletePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePortW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterConnectionW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterDriverW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProcessorW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProvidorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProvidorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProvidorW");
	return 0;
}

int
WINAPI
ODeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
								LPWSTR, CONST DEVMODEW *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeviceCapabilitiesW");
	return 0;
}

int
WINAPI
ODlgDirListW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDListBox,
	int nIDStaticPath,
	UINT uFileType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListW");
	return 0;
}

int
WINAPI
ODlgDirListComboBoxW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDComboBox,
	int nIDStaticPath,
	UINT uFiletype)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListComboBoxW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectComboBoxExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDComboBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectComboBoxExW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDListBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectExW");
	return 0;
}

DWORD
WINAPI
ODocumentPropertiesW(
	HWND      hWnd,
	HANDLE    hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput,
	DWORD     fMode
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DocumentPropertiesW");
	return 0;
}

DWORD
APIENTRY
ODoEnvironmentSubstW(LPWSTR szString, UINT cbString)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DoEnvironmentSubstW");
	return 0;
}

UINT
APIENTRY
ODragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DragQueryFileW");
	return 0;
}

BOOL
WINAPI
ODrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DrawStateW");
	return 0;
}

BOOL
WINAPI
OEndUpdateResourceW(
	HANDLE      hUpdate,
	BOOL        fDiscard
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EndUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OEnumCalendarInfoW(
	CALINFO_ENUMPROCW lpCalInfoEnumProc,
	LCID              Locale,
	CALID             Calendar,
	CALTYPE           CalType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumCalendarInfoW");
	return 0;
}

BOOL
WINAPI
OEnumDateFormatsW(
	DATEFMT_ENUMPROCW lpDateFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDateFormatsW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumDependentServicesW(
	SC_HANDLE               hService,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDependentServicesW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumDesktopsW(
	HWINSTA hwinsta,
	DESKTOPENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDesktopsW");
	return 0;
}

BOOL
WINAPI
OEnumDisplaySettingsW(
	LPCWSTR lpszDeviceName,
	DWORD iModeNum,
	LPDEVMODEW lpDevMode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDisplaySettingsW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesExW");
	return 0;
}

int
WINAPI
OEnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontsW");
	return 0;
}

BOOL
WINAPI
OEnumFormsW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFormsW");
	return 0;
}

WINAPI
OEnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumICMProfilesW");
	return 0;
}

BOOL
WINAPI
OEnumJobsW(
	HANDLE  hPrinter,
	DWORD   FirstJob,
	DWORD   NoJobs,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumJobsW");
	return 0;
}

BOOL
WINAPI
OEnumMonitorsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumMonitorsW");
	return 0;
}

BOOL
WINAPI
OEnumPortsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPorts,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPortsW");
	return 0;
}

BOOL
WINAPI
OEnumPrinterDriversW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrinterDriversW");
	return 0;
}

BOOL
WINAPI
OEnumPrintersW(
	DWORD   Flags,
	LPWSTR   Name,
	DWORD   Level,
	LPBYTE  pPrinterEnum,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintersW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorDatatypesW(
	LPWSTR   pName,
	LPWSTR   pPrintProcessorName,
	DWORD   Level,
	LPBYTE  pDatatypes,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorDatatypesW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorsW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorsW");
	return 0;
}

int
WINAPI
OEnumPropsW(
	HWND hWnd,
	PROPENUMPROCW lpEnumFunc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsW");
	return 0;
}

int
WINAPI
OEnumPropsExW(
	HWND hWnd,
	PROPENUMPROCEXW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsExW");
	return 0;
}

INT
APIENTRY
OEnumProtocolsW (
	IN     LPINT           lpiProtocols,
	IN OUT LPVOID          lpProtocolBuffer,
	IN OUT LPDWORD         lpdwBufferLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumProtocolsW");
	return 0;
}

BOOL
WINAPI
OEnumResourceLanguagesW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	ENUMRESLANGPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceLanguagesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceNamesW(
	HMODULE hModule,
	LPCWSTR lpType,
	ENUMRESNAMEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceNamesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceTypesW(
	HMODULE hModule,
	ENUMRESTYPEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceTypesW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumServicesStatusW(
	SC_HANDLE               hSCManager,
	DWORD                   dwServiceType,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned,
	LPDWORD                 lpResumeHandle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumServicesStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumSystemCodePagesW(
	CODEPAGE_ENUMPROCW lpCodePageEnumProc,
	DWORD              dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemCodePagesW");
	return 0;
}

BOOL
WINAPI
OEnumSystemLocalesW(
	LOCALE_ENUMPROCW lpLocaleEnumProc,
	DWORD            dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemLocalesW");
	return 0;
}

BOOL
WINAPI
OEnumTimeFormatsW(
	TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumTimeFormatsW");
	return 0;
}

BOOL
WINAPI
OEnumWindowStationsW(
	WINSTAENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumWindowStationsW");
	return 0;
}

HICON
APIENTRY
OExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractAssociatedIconW");
	return 0;
}

HICON
APIENTRY
OExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconW");
	return 0;
}


UINT
WINAPI
OExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconExW");
	return 0;
}

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtTextOutW");
	return 0;
}
*/

BOOL
WINAPI
OFillConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	WCHAR  cCharacter,
	DWORD  nLength,
	COORD  dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FillConsoleOutputCharacterW");
	return 0;
}

LPWSTR
APIENTRY
OFindEnvironmentStringW(LPWSTR szEnvVar)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindEnvironmentStringW");
	return 0;
}

HINSTANCE
APIENTRY
OFindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindExecutableW");
	return 0;
}

HRSRC
WINAPI
OFindResourceExW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	WORD    wLanguage
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindResourceExW");
	return 0;
}

APIENTRY
OFindTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindTextW");
	return 0;
}

HWND
WINAPI
OFindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindWindowExW");
	return 0;
}

int
WINAPI
OFoldStringW(
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FoldStringW");
	return 0;
}

BOOL
WINAPI
OGetBinaryTypeW(
	LPCWSTR lpApplicationName,
	LPDWORD lpBinaryType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetBinaryTypeW");
	return 0;
}

DWORD
WINAPI
OGetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharacterPlacementW");
	return 0;
}

BOOL
WINAPI
OGetCharWidth32W(HDC, UINT, UINT, LPINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharWidth32W");
	return 0;
}

LPWSTR
WINAPI
OGetCommandLineW(
	VOID
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCommandLineW");
	return 0;
}

DWORD
WINAPI
OGetCompressedFileSizeW(
	LPCWSTR lpFileName,
	LPDWORD lpFileSizeHigh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCompressedFileSizeW");
	return 0;
}

BOOL
WINAPI
OGetComputerNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetComputerNameW");
	return 0;
}

DWORD
WINAPI
OGetConsoleTitleW(
	LPWSTR lpConsoleTitle,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetConsoleTitleW");
	return 0;
}

int
WINAPI
OGetCurrencyFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST CURRENCYFMTW *lpFormat,
	LPWSTR  lpCurrencyStr,
	int      cchCurrency)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCurrencyFormatW");
	return 0;
}

int
WINAPI
OGetDateFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpDate,
	LPCWSTR lpFormat,
	LPWSTR  lpDateStr,
	int      cchDate)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDateFormatW");
	return 0;
}

BOOL
WINAPI
OGetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	LPDWORD lpdwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OGetDiskFreeSpaceW(
	LPCWSTR lpRootPathName,
	LPDWORD lpSectorsPerCluster,
	LPDWORD lpBytesPerSector,
	LPDWORD lpNumberOfFreeClusters,
	LPDWORD lpTotalNumberOfClusters
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDiskFreeSpaceW");
	return 0;
}

UINT
WINAPI
OGetDriveTypeW(
	LPCWSTR lpRootPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDriveTypeW");
	return 0;
}

HENHMETAFILE
WINAPI
OGetEnhMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileW");
	return 0;
}

UINT
WINAPI
OGetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileDescriptionW");
	return 0;
}

DWORD
WINAPI
OGetEnvironmentVariableW(
	LPCWSTR lpName,
	LPWSTR lpBuffer,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnvironmentVariableW");
	return 0;
}

INT
APIENTRY
OGetExpandedNameW(
	LPWSTR,
	LPWSTR
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetExpandedNameW");
	return 0;
}

BOOL
WINAPI
OGetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION RequestedInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	DWORD nLength,
	LPDWORD lpnLengthNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileSecurityW");
	return 0;
}

short
WINAPI
OGetFileTitleW
(
LPCWSTR pwszFile,
LPWSTR pwszOut,
WORD w
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileTitleW");
	return 0;
}

BOOL
WINAPI
OGetFileVersionInfoW(
	LPWSTR lpszFile,
	DWORD dwHandle,
	DWORD cbBuf,
	LPVOID lpvData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoW");
	return 0;
}

DWORD
WINAPI
OGetFileVersionInfoSizeW(
	LPWSTR lpszFile,
	LPDWORD lpdwHandle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoSizeW");
	return 0;
}

BOOL
WINAPI
OGetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFormW");
	return 0;
}

WINAPI OGetICMProfileW(HDC,LPDWORD,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetICMProfileW");
	return 0;
}

BOOL
WINAPI
OGetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetJobW");
	return 0;
}

BOOL
WINAPI
OGetKeyboardLayoutNameW(
	LPWSTR pwszKLID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyboardLayoutNameW");
	return 0;
}

WINAPI OGetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogColorSpaceW");
	return 0;
}

DWORD
WINAPI
OGetLogicalDriveStringsW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogicalDriveStringsW");
	return 0;
}

BOOL
WINAPI
OGetMenuItemInfoW(
	HMENU,
	UINT,
	BOOL,
	LPMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuItemInfoW");
	return 0;
}

HMETAFILE   WINAPI OGetMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMetaFileW");
	return 0;
}

INT
APIENTRY
OGetNameByTypeW (
	IN     LPGUID          lpServiceType,
	IN OUT LPWSTR         lpServiceName,
	IN     DWORD           dwNameLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNameByTypeW");
	return 0;
}

BOOL
WINAPI
OGetNamedPipeHandleStateW(
	HANDLE hNamedPipe,
	LPDWORD lpState,
	LPDWORD lpCurInstances,
	LPDWORD lpMaxCollectionCount,
	LPDWORD lpCollectDataTimeout,
	LPWSTR lpUserName,
	DWORD nMaxUserNameSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNamedPipeHandleStateW");
	return 0;
}

int
WINAPI
OGetNumberFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST NUMBERFMTW *lpFormat,
	LPWSTR  lpNumberStr,
	int      cchNumber)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNumberFormatW");
	return 0;
}

APIENTRY
OGetOpenFileNameW(
LPOPENFILENAMEW lpofn
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetOpenFileNameW");
	return 0;
}

BOOL
WINAPI
OGetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterW");
	return 0;
}

DWORD
WINAPI
OGetPrinterDataW(
	HANDLE   hPrinter,
	LPWSTR    pValueName,
	LPDWORD  pType,
	LPBYTE   pData,
	DWORD    nSize,
	LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverW(
	HANDLE  hPrinter,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverDirectory,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverDirectoryW");
	return 0;
}

BOOL
WINAPI
OGetPrintProcessorDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrintProcessorDirectoryW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionNamesW(
	LPWSTR lpszReturnBuffer,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionNamesW");
	return 0;
}

BOOL
WINAPI
OGetPrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileStructW");
	return 0;
}

DWORD
WINAPI
OGetProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileStringW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OGetServiceDisplayNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpServiceName,
	LPWSTR                 lpDisplayName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceDisplayNameW");
	return 0;
}

BOOL
WINAPI
OGetServiceKeyNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpDisplayName,
	LPWSTR                 lpServiceName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceKeyNameW");
	return 0;
}
#endif

APIENTRY
OGetSaveFileNameW(LPOPENFILENAMEW lpofn)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSaveFileNameW");
	return 0;
}

DWORD
WINAPI
OGetShortPathNameW(
	LPCWSTR lpszLongPath,
	LPWSTR  lpszShortPath,
	DWORD    cchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetShortPathNameW");
	return 0;
}

VOID
WINAPI
OGetStartupInfoW(
	LPSTARTUPINFOW lpStartupInfo
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStartupInfoW");
	return;
}

BOOL
WINAPI
OGetStringTypeExW(
	LCID     Locale,
	DWORD    dwInfoType,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWORD   lpCharType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStringTypeExW");
	return 0;
}

UINT
WINAPI
OGetSystemDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSystemDirectoryW");
	return 0;
}

int
WINAPI
OGetTimeFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpTime,
	LPCWSTR lpFormat,
	LPWSTR  lpTimeStr,
	int      cchTime)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTimeFormatW");
	return 0;
}

INT
APIENTRY
OGetTypeByNameW (
	IN     LPWSTR         lpServiceName,
	IN OUT LPGUID          lpServiceType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTypeByNameW");
	return 0;
}

BOOL
WINAPI
OGetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength,
	LPDWORD lpnLengthNeeded)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetUserObjectInformationW");
	return 0;
}

UINT
WINAPI
OGetWindowsDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetWindowsDirectoryW");
	return 0;
}

ATOM
WINAPI
OGlobalFindAtomW(
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GlobalFindAtomW");
	return 0;
}

RPC_STATUS RPC_ENTRY
OI_RpcServerUnregisterEndpointW (
	IN unsigned short * Protseq,
	IN unsigned short * Endpoint
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - I_RpcServerUnregisterEndpointW");
	return 0;
}

HIMAGELIST
WINAPI
OImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImageList_LoadImageW");
	return 0;
}

WINAPI
OImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmConfigureIMEW");
	return 0;
}

WINAPI
OImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEnumRegisterWordW");
	return 0;
}

WINAPI
OImmEscapeW(HKL, HIMC, UINT, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEscapeW");
	return 0;
}

WINAPI
OImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListW");
	return 0;
}

WINAPI
OImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListCountW");
	return 0;
}

WINAPI
OImmGetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionFontW");
	return 0;
}

WINAPI
OImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionStringW");
	return 0;
}

WINAPI
OImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetConversionListW");
	return 0;
}

WINAPI
OImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetDescriptionW");
	return 0;
}

WINAPI
OImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetGuideLineW");
	return 0;
}

WINAPI
OImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetIMEFileNameW");
	return 0;
}

WINAPI
OImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetRegisterWordStyleW");
	return 0;
}

WINAPI
OImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmInstallIMEW");
	return 0;
}

WINAPI
OImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmIsUIMessageW");
	return 0;
}

WINAPI
OImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmRegisterWordW");
	return 0;
}

WINAPI
OImmSetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionFontW");
	return 0;
}

WINAPI
OImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionStringW");
	return 0;
}

WINAPI
OImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmUnregisterWordW");
	return 0;
}

BOOL
APIENTRY
OInitiateSystemShutdownW(
	LPWSTR lpMachineName,
	LPWSTR lpMessage,
	DWORD dwTimeout,
	BOOL bForceAppsClosed,
	BOOL bRebootAfterShutdown
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InitiateSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OInsertMenuItemW(
	HMENU,
	UINT,
	BOOL,
	LPCMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InsertMenuItemW");
	return 0;
}

BOOL
WINAPI
OIsCharLowerW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharLowerW");
	return 0;
}

BOOL
WINAPI
OIsCharUpperW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharUpperW");
	return 0;
}

MMRESULT
WINAPI
OjoyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - joyGetDevCapsW");
	return 0;
}

HCURSOR
WINAPI
OLoadCursorFromFileW(
	LPCWSTR    lpFileName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadCursorFromFileW");
	return 0;
}

HKL
WINAPI
OLoadKeyboardLayoutW(
	LPCWSTR pwszKLID,
	UINT Flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadKeyboardLayoutW");
	return 0;
}

BOOL
WINAPI
OLogonUserW (
	LPWSTR lpszUsername,
	LPWSTR lpszDomain,
	LPWSTR lpszPassword,
	DWORD dwLogonType,
	DWORD dwLogonProvider,
	PHANDLE phToken
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LogonUserW");
	return 0;
}

INT
APIENTRY
OLZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LZOpenFileW");
	return 0;
}

UINT
WINAPI
OMapVirtualKeyExW(
	UINT uCode,
	UINT uMapType,
	HKL dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MapVirtualKeyExW");
	return 0;
}

HRESULT
WINAPI
OMIMEAssociationDialogW(HWND hwndParent,
									   DWORD dwInFlags,
									   PCWSTR pcszFile,
									   PCWSTR pcszMIMEContentType,
									   PWSTR pszAppBuf,
									   UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MIMEAssociationDialogW");
	return 0;
}

DWORD
APIENTRY
OMultinetGetConnectionPerformanceW(
		LPNETRESOURCEW lpNetResource,
		LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MultinetGetConnectionPerformanceW");
	return 0;
}

BOOL
WINAPI
OObjectCloseAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	BOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectCloseAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectOpenAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	DWORD GrantedAccess,
	PPRIVILEGE_SET Privileges,
	BOOL ObjectCreation,
	BOOL AccessGranted,
	LPBOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectOpenAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectPrivilegeAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectPrivilegeAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OOemToCharBuffW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OemToCharBuffW");
	return 0;
}

HANDLE
WINAPI
OOpenBackupEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenBackupEventLogW");
	return 0;
}

HDESK
WINAPI
OOpenDesktopW(
	LPWSTR lpszDesktop,
	DWORD dwFlags,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenDesktopW");
	return 0;
}

HANDLE
WINAPI
OOpenEventW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventW");
	return 0;
}

HANDLE
WINAPI
OOpenEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventLogW");
	return 0;
}

HANDLE
WINAPI
OOpenFileMappingW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenFileMappingW");
	return 0;
}

HANDLE
WINAPI
OOpenMutexW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenMutexW");
	return 0;
}

BOOL
WINAPI
OOpenPrinterW(
	LPWSTR    pPrinterName,
	LPHANDLE phPrinter,
	LPPRINTER_DEFAULTSW pDefault
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenSCManagerW(
	LPCWSTR lpMachineName,
	LPCWSTR lpDatabaseName,
	DWORD   dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSCManagerW");
	return 0;
}
#endif

HANDLE
WINAPI
OOpenSemaphoreW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSemaphoreW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenServiceW(
	SC_HANDLE   hSCManager,
	LPCWSTR    lpServiceName,
	DWORD       dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenServiceW");
	return 0;
}
#endif

HWINSTA
WINAPI
OOpenWindowStationW(
	LPWSTR lpszWinSta,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenWindowStationW");
	return 0;
}

APIENTRY OPageSetupDlgW( LPPAGESETUPDLGW )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PageSetupDlgW");
	return 0;
}

BOOL
WINAPI
OPeekConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PeekConsoleInputW");
	return 0;
}

BOOL
WINAPI
OPolyTextOutW(HDC, CONST POLYTEXTW *, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PolyTextOutW");
	return 0;
}

APIENTRY
OPrintDlgW(LPPRINTDLGW lppd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrintDlgW");
	return 0;
}

DWORD
WINAPI
OPrinterMessageBoxW(
	HANDLE  hPrinter,
	DWORD   Error,
	HWND    hWnd,
	LPWSTR   pText,
	LPWSTR   pCaption,
	DWORD   dwType
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrinterMessageBoxW");
	return 0;
}

BOOL
WINAPI
OPrivilegedServiceAuditAlarmW (
	LPCWSTR SubsystemName,
	LPCWSTR ServiceName,
	HANDLE ClientToken,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrivilegedServiceAuditAlarmW");
	return 0;
}

int
WINAPI
OPropertySheetW(
	LPCPROPSHEETHEADERW lpcpsh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PropertySheetW");
	return 0;
}

DWORD
WINAPI
OQueryDosDeviceW(
	LPCWSTR lpDeviceName,
	LPWSTR lpTargetPath,
	DWORD ucchMax
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryDosDeviceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OQueryServiceConfigW(
	SC_HANDLE               hService,
	LPQUERY_SERVICE_CONFIGW lpServiceConfig,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceConfigW");
	return 0;
}

BOOL
WINAPI
OQueryServiceLockStatusW(
	SC_HANDLE                       hSCManager,
	LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
	DWORD                           cbBufSize,
	LPDWORD                         pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceLockStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OReadConsoleW(
	HANDLE hConsoleInput,
	LPVOID lpBuffer,
	DWORD nNumberOfCharsToRead,
	LPDWORD lpNumberOfCharsRead,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleW");
	return 0;
}

BOOL
WINAPI
OReadConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleInputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputW(
	HANDLE hConsoleOutput,
	PCHAR_INFO lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpReadRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPWSTR lpCharacter,
	DWORD nLength,
	COORD dwReadCoord,
	LPDWORD lpNumberOfCharsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OReadEventLogW (
	 HANDLE     hEventLog,
	 DWORD      dwReadFlags,
	 DWORD      dwRecordOffset,
	 LPVOID     lpBuffer,
	 DWORD      nNumberOfBytesToRead,
	 DWORD      *pnBytesRead,
	 DWORD      *pnMinNumberOfBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadEventLogW");
	return 0;
}

LONG
APIENTRY
ORegConnectRegistryW (
	LPWSTR lpMachineName,
	HKEY hKey,
	PHKEY phkResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegConnectRegistryW");
	return 0;
}

HANDLE
WINAPI
ORegisterEventSourceW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterEventSourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SERVICE_STATUS_HANDLE
WINAPI
ORegisterServiceCtrlHandlerW(
	LPCWSTR             lpServiceName,
	LPHANDLER_FUNCTION   lpHandlerProc
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterServiceCtrlHandlerW");
	return 0;
}
#endif

LONG
APIENTRY
ORegLoadKeyW (
	HKEY    hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegLoadKeyW");
	return 0;
}

LONG
APIENTRY
ORegQueryMultipleValuesW (
	HKEY hKey,
	PVALENTW val_list,
	DWORD num_vals,
	LPWSTR lpValueBuf,
	LPDWORD ldwTotsize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegQueryMultipleValuesW");
	return 0;
}

LONG
APIENTRY
ORegReplaceKeyW (
	HKEY     hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpNewFile,
	LPCWSTR  lpOldFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegReplaceKeyW");
	return 0;
}

LONG
APIENTRY
ORegRestoreKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	DWORD   dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegRestoreKeyW");
	return 0;
}

LONG
APIENTRY
ORegSaveKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegSaveKeyW");
	return 0;
}

LONG
APIENTRY
ORegUnLoadKeyW (
	HKEY    hKey,
	LPCWSTR lpSubKey
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegUnLoadKeyW");
	return 0;
}

BOOL
WINAPI
ORemoveDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveDirectoryW");
	return 0;
}

BOOL
WINAPI
ORemoveFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveFontResourceW");
	return 0;
}

APIENTRY
OReplaceTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReplaceTextW");
	return 0;
}

BOOL
WINAPI
OReportEventW (
	 HANDLE     hEventLog,
	 WORD       wType,
	 WORD       wCategory,
	 DWORD      dwEventID,
	 PSID       lpUserSid,
	 WORD       wNumStrings,
	 DWORD      dwDataSize,
	 LPCWSTR   *lpStrings,
	 LPVOID     lpRawData
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReportEventW");
	return 0;
}

HDC
WINAPI
OResetDCW(
	HDC hdc,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetDCW");
	return 0;
}

BOOL
WINAPI
OResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetPrinterW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingFromStringBindingW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingFromStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingInqAuthClientW (
	IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
	OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingInqAuthClientW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingToStringBindingW (
	IN RPC_BINDING_HANDLE Binding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingToStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcEpRegisterNoReplaceW (
	IN RPC_IF_HANDLE IfSpec,
	IN RPC_BINDING_VECTOR * BindingVector,
	IN UUID_VECTOR * UuidVector OPTIONAL,
	IN unsigned short  * Annotation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcEpRegisterNoReplaceW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtEpEltInqNextW (
	IN RPC_EP_INQ_HANDLE InquiryContext,
	OUT RPC_IF_ID __RPC_FAR * IfId,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
	OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtEpEltInqNextW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtInqServerPrincNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtInqServerPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkInqProtseqsW (
	OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkInqProtseqsW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkIsProtseqValidW (
	IN unsigned short __RPC_FAR * Protseq
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkIsProtseqValidW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNsBindingInqEntryNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long EntryNameSyntax,
	OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNsBindingInqEntryNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcProtseqVectorFreeW (
	IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcProtseqVectorFreeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerInqDefaultPrincNameW (
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerInqDefaultPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqEpW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN unsigned short __RPC_FAR * Endpoint,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqEpW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqIfW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN RPC_IF_HANDLE IfSpec,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqIfW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingComposeW (
	IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
	IN unsigned short __RPC_FAR * Protseq OPTIONAL,
	IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
	IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
	IN unsigned short __RPC_FAR * Options OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingComposeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingParseW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingParseW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringFreeW (
	IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringFreeW");
	return 0;
}

BOOL
WINAPI
OScrollConsoleScreenBufferW(
	HANDLE hConsoleOutput,
	CONST SMALL_RECT *lpScrollRectangle,
	CONST SMALL_RECT *lpClipRectangle,
	COORD dwDestinationOrigin,
	CONST CHAR_INFO *lpFill
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ScrollConsoleScreenBufferW");
	return 0;
}

DWORD
WINAPI
OSearchPathW(
	LPCWSTR lpPath,
	LPCWSTR lpFileName,
	LPCWSTR lpExtension,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SearchPathW");
	return 0;
}

BOOL
WINAPI
OSendMessageCallbackW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	SENDASYNCPROC lpResultCallBack,
	DWORD dwData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageCallbackW");
	return 0;
}

LRESULT
WINAPI
OSendMessageTimeoutW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	UINT fuFlags,
	UINT uTimeout,
	LPDWORD lpdwResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageTimeoutW");
	return 0;
}

BOOL
WINAPI
OSetComputerNameW (
	LPCWSTR lpComputerName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetComputerNameW");
	return 0;
}

BOOL
WINAPI
OSetConsoleTitleW(
	LPCWSTR lpConsoleTitle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetConsoleTitleW");
	return 0;
}

BOOL
WINAPI
OSetCurrentDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetCurrentDirectoryW");
	return 0;
}

BOOL
WINAPI
OSetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	DWORD dwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OSetEnvironmentVariableW(
	LPCWSTR lpName,
	LPCWSTR lpValue
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetEnvironmentVariableW");
	return 0;
}

BOOL
WINAPI
OSetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFileSecurityW");
	return 0;
}

BOOL
WINAPI
OSetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFormW");
	return 0;
}

WINAPI
OSetICMProfileW(HDC,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetICMProfileW");
	return 0;
}

BOOL
WINAPI
OSetJobW(
	HANDLE  hPrinter,
	DWORD   JobId,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetJobW");
	return 0;
}

BOOL
WINAPI
OSetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterW");
	return 0;
}

DWORD
WINAPI
OSetPrinterDataW(
	HANDLE  hPrinter,
	LPWSTR   pValueName,
	DWORD   Type,
	LPBYTE  pData,
	DWORD   cbData
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OSetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetUserObjectInformationW");
	return 0;
}

BOOL
WINAPI
OSetVolumeLabelW(
	LPCWSTR lpRootPathName,
	LPCWSTR lpVolumeName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetVolumeLabelW");
	return 0;
}

HHOOK
WINAPI
OSetWindowsHookW(
	int nFilterType,
	HOOKPROC pfnFilterProc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetWindowsHookW");
	return 0;
}

LPITEMIDLIST
WINAPI
OSHBrowseForFolderW(
	LPBROWSEINFO lpbi)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHBrowseForFolderW");
	return 0;
}

BOOL
WINAPI
OShell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - Shell_NotifyIconW");
	return 0;
}

INT
APIENTRY
OShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellAboutW");
	return 0;
}

HINSTANCE
APIENTRY
OShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteW");
	return 0;
}

BOOL
WINAPI
OShellExecuteExW(
	LPSHELLEXECUTEINFOW lpExecInfo)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteExW");
	return 0;
}


int
WINAPI
OSHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHFileOperationW");
	return 0;
}

DWORD
WINAPI
OSHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetFileInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
							 BOOL FAR * pfMustCopy, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetNewLinkInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetPathFromIDListW(
	LPCITEMIDLIST pidl,
	LPTSTR pszPath)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetPathFromIDListW");
	return 0;
}

BOOL
WINAPI
OsndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - sndPlaySoundW");
	return 0;
}

DWORD
WINAPI
OStartDocPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pDocInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartDocPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OStartServiceW(
	SC_HANDLE            hService,
	DWORD                dwNumServiceArgs,
	LPCWSTR             *lpServiceArgVectors
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceW");
	return 0;
}

BOOL
WINAPI
OStartServiceCtrlDispatcherW(
	LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceCtrlDispatcherW");
	return 0;
}
#endif

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OTextOutW(HDC, int, int, LPCWSTR, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TextOutW");
	return 0;
}
*/

HRESULT
WINAPI
OTranslateURLW(PCWSTR pcszURL,
										 DWORD dwInFlags,
										 PWSTR *ppszTranslatedURL)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TranslateURLW");
	return 0;
}

WINAPI
OUpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UpdateICMRegKeyW");
	return 0;
}

HRESULT
WINAPI
OURLAssociationDialogW(HWND hwndParent,
												 DWORD dwInFlags,
												 PCWSTR pcszFile,
												 PCWSTR pcszURL,
												 PWSTR pszAppBuf,
												 UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - URLAssociationDialogW");
	return 0;
}

/* client/server */
RPC_STATUS RPC_ENTRY
OUuidFromStringW (
	IN unsigned short __RPC_FAR * StringUuid,
	OUT UUID __RPC_FAR * Uuid
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UuidFromStringW");
	return 0;
}

DWORD
APIENTRY
OVerFindFileW(
		DWORD uFlags,
		LPWSTR szFileName,
		LPWSTR szWinDir,
		LPWSTR szAppDir,
		LPWSTR szCurDir,
		PUINT lpuCurDirLen,
		LPWSTR szDestDir,
		PUINT lpuDestDirLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerFindFileW");
	return 0;
}

DWORD
APIENTRY
OVerInstallFileW(
		DWORD uFlags,
		LPWSTR szSrcFileName,
		LPWSTR szDestFileName,
		LPWSTR szSrcDir,
		LPWSTR szDestDir,
		LPWSTR szCurDir,
		LPWSTR szTmpFile,
		PUINT lpuTmpFileLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerInstallFileW");
	return 0;
}

DWORD
APIENTRY
OVerLanguageNameW(
		DWORD wLang,
		LPWSTR szLang,
		DWORD nSize
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerLanguageNameW");
	return 0;
}

BOOL
WINAPI
OVerQueryValueW(
	const LPVOID pBlock,
	LPWSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLerr)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerQueryValueW");
	return 0;
}

WINAPI
OVkKeyScanExW(
	WCHAR  ch,
	HKL   dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VkKeyScanExW");
	return 0;
}

BOOL
WINAPI
OWaitNamedPipeW(
	LPCWSTR lpNamedPipeName,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WaitNamedPipeW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetErrorTextW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetErrorTextW");
	return 0;
}

BOOL
WINAPI
OwglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontBitmapsW");
	return 0;
}

BOOL
WINAPI
OwglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
										   FLOAT, int, LPGLYPHMETRICSFLOAT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontOutlinesW");
	return 0;
}

void
WINAPI
OWinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WinExecErrorW");
	return;
}

DWORD
APIENTRY
OWNetAddConnectionW(
	 LPCWSTR   lpRemoteName,
	 LPCWSTR   lpPassword,
	 LPCWSTR   lpLocalName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection2W(
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection3W(
	 HWND           hwndOwner,
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection3W");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnectionW(
	 LPCWSTR lpName,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnection2W(
	 LPCWSTR lpName,
	 DWORD    dwFlags,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetConnectionDialog1W(
	LPCONNECTDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetConnectionDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetDisconnectDialog1W(
	LPDISCDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetDisconnectDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetEnumResourceW(
	 HANDLE  hEnum,
	 LPDWORD lpcCount,
	 LPVOID  lpBuffer,
	 LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetEnumResourceW");
	return 0;
}

DWORD
APIENTRY
OWNetGetConnectionW(
	 LPCWSTR lpLocalName,
	 LPWSTR  lpRemoteName,
	 LPDWORD  lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetGetLastErrorW(
	 LPDWORD    lpError,
	 LPWSTR    lpErrorBuf,
	 DWORD      nErrorBufSize,
	 LPWSTR    lpNameBuf,
	 DWORD      nNameBufSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetLastErrorW");
	return 0;
}

DWORD
APIENTRY
OWNetGetNetworkInformationW(
	LPCWSTR          lpProvider,
	LPNETINFOSTRUCT   lpNetInfoStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetNetworkInformationW");
	return 0;
}

DWORD
APIENTRY
OWNetGetProviderNameW(
	DWORD   dwNetType,
	LPWSTR lpProviderName,
	LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetProviderNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUniversalNameW(
	 LPCWSTR lpLocalPath,
	 DWORD    dwInfoLevel,
	 LPVOID   lpBuffer,
	 LPDWORD  lpBufferSize
	 )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUniversalNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUserW(
	 LPCWSTR  lpName,
	 LPWSTR   lpUserName,
	 LPDWORD   lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUserW");
	return 0;
}

DWORD
APIENTRY
OWNetOpenEnumW(
	 DWORD          dwScope,
	 DWORD          dwType,
	 DWORD          dwUsage,
	 LPNETRESOURCEW lpNetResource,
	 LPHANDLE       lphEnum
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetOpenEnumW");
	return 0;
}

DWORD
APIENTRY
OWNetSetConnectionW(
	LPCWSTR    lpName,
	DWORD       dwProperties,
	LPVOID      pvValues
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetSetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetUseConnectionW(
	HWND            hwndOwner,
	LPNETRESOURCEW  lpNetResource,
	LPCWSTR        lpUserID,
	LPCWSTR        lpPassword,
	DWORD           dwFlags,
	LPWSTR         lpAccessName,
	LPDWORD         lpBufferSize,
	LPDWORD         lpResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetUseConnectionW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleW(
	HANDLE hConsoleOutput,
	CONST VOID *lpBuffer,
	DWORD nNumberOfCharsToWrite,
	LPDWORD lpNumberOfCharsWritten,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleInputW(
	HANDLE hConsoleInput,
	CONST INPUT_RECORD *lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleInputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputW(
	HANDLE hConsoleOutput,
	CONST CHAR_INFO *lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpWriteRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPCWSTR lpCharacter,
	DWORD nLength,
	COORD dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileStructW");
	return 0;
}

BOOL
WINAPI
OWriteProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWriteProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileStringW");
	return 0;
}

int
WINAPI
OwvsprintfW(
	LPWSTR,
	LPCWSTR,
	va_list arglist)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wvsprintfW");
	return 0;
}

DWORD
WINAPI
ODdeQueryStringW(
	DWORD idInst,
	HSZ hsz,
	LPWSTR psz,
	DWORD cchMax,
	int iCodePage)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DdeQueryStringW");
	return 0;
}

int WINAPI
OGetClipboardFormatNameW(
	UINT format,
	LPWSTR pwsz,
	int cchMaxCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetClipboardFormatNameW");
	return 0;
}

int
WINAPI
OGetKeyNameTextW(
	LONG lParam,
	LPWSTR lpString,
	int nSize)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyNameTextW");
	return 0;
}

int
WINAPI
OGetMenuStringW(
	HMENU hMenu,
	UINT uIDItem,
	LPWSTR lpString,
	int nMaxCount,
	UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

int
WINAPI
OGetTextFaceW(
	HDC    hdc,
	int    cch,
	LPWSTR lpFaceName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

#endif    //ifdef DEBUG

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\win95wrp.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.h
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

#ifndef __WIN95WRP_CPP__

#ifndef __WIN95WRP_H__
#define __WIN95WRP_H__

extern "C"{

BOOL WINAPI OAppendMenuW(HMENU hMenu, UINT uFlags, UINT uIDnewItem, LPCWSTR lpnewItem);
LRESULT WINAPI OCallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI OCharLowerBuffW(LPWSTR lpsz, DWORD cchLength);
LPWSTR WINAPI OCharLowerW(LPWSTR lpsz);
LPWSTR WINAPI OCharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
BOOL WINAPI OCharToOemW(LPCWSTR lpszSrc, LPSTR lpszDst);
LPWSTR WINAPI OCharUpperW(LPWSTR lpsz);
BOOL WINAPI OCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
BOOL WINAPI OCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL WINAPI OCreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateEnhMetaFileW(HDC hdc, LPCWSTR lpFileName, CONST RECT *lpRect, LPCWSTR lpDescription);
HANDLE WINAPI OCreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
HANDLE WINAPI OCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
HFONT WINAPI OCreateFontIndirectW(CONST LOGFONTW * plfw);
HFONT OCreateFontW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
HWND WINAPI OCreateMDIWindowW(LPWSTR lpClassName, LPWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
HDC WINAPI OCreateMetaFileW(LPCWSTR lpstr);
HANDLE WINAPI OCreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
HWND WINAPI OCreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
HSZ WINAPI ODdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
UINT WINAPI ODdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
LRESULT WINAPI ODefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI ODeleteFileW(LPCWSTR pwsz);
LRESULT WINAPI ODialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODispatchMessageW(CONST MSG *lpMsg);
int WINAPI ODrawTextW(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
int WINAPI ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
DWORD WINAPI OExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
VOID WINAPI OFatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
HANDLE WINAPI OFindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
HANDLE WINAPI OFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
BOOL WINAPI OFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
HRSRC WINAPI OFindResourceW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);
HWND WINAPI OFindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
DWORD WINAPI OFormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
BOOL APIENTRY OGetCharABCWidthsFloatW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABCFLOAT lpABC);
BOOL APIENTRY OGetCharABCWidthsW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABC lpABC);
BOOL APIENTRY OGetCharWidthFloatW(HDC hdc, UINT iFirstChar, UINT iLastChar, PFLOAT pBuffer);
BOOL WINAPI OGetCharWidthW(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
BOOL WINAPI OGetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);
BOOL WINAPI OGetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSEXW lpWndClass);
DWORD WINAPI OGetClassLongW(HWND hWnd, int nIndex);
DWORD WINAPI OSetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
int WINAPI OGetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
DWORD WINAPI OGetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
UINT WINAPI OGetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
DWORD WINAPI OGetFileAttributesW(LPCWSTR lpFileName);
DWORD WINAPI OGetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD WINAPI OGetGlyphOutlineW(HDC hdc, UINT uChar, UINT uFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpvBuffer, CONST MAT2 *lpmat2);
DWORD WINAPI OGetKerningPairsW(HDC hdc, DWORD nNumPairs, LPKERNINGPAIR lpkrnpair);
BOOL WINAPI OGetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DWORD WINAPI OGetModuleFileNameW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);
HMODULE WINAPI OGetModuleHandleW(LPCWSTR lpModuleName);
UINT APIENTRY OGetOutlineTextMetricsW(HDC hdc, UINT cbData, LPOUTLINETEXTMETRICW lpOTM);
UINT WINAPI OGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
DWORD WINAPI OGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
int WINAPI OGetObjectW(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);
UINT WINAPI OGetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
HANDLE WINAPI OGetPropW(HWND hWnd, LPCWSTR lpString);
DWORD WINAPI OGetTabbedTextExtentW(HDC hDC, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions);
UINT WINAPI OGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
DWORD WINAPI OGetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
BOOL APIENTRY OGetTextExtentPoint32W(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentPointW(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentExPointW(HDC hdc, LPCWSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE pSize);
LONG WINAPI OGetWindowLongW(HWND hWnd, int nIndex);
BOOL WINAPI OGetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
BOOL WINAPI OGetUserNameW(LPWSTR lpBuffer, LPDWORD nSize);
BOOL WINAPI OGetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
int WINAPI OGetWindowTextLengthW(HWND hWnd);
int WINAPI OGetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
ATOM WINAPI OGlobalAddAtomW(LPCWSTR lpString);
UINT WINAPI OGlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL WINAPI OGrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
BOOL WINAPI OInsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OIsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
BOOL WINAPI OIsCharAlphaNumericW(WCHAR wch);
BOOL WINAPI OIsCharAlphaW(WCHAR wch);
BOOL WINAPI OIsDialogMessageW(HWND hDlg, LPMSG lpMsg);
int WINAPI OLCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
HACCEL WINAPI OLoadAcceleratorsW(HINSTANCE hInst, LPCWSTR lpTableName);
HBITMAP WINAPI OLoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
HCURSOR WINAPI OLoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
HICON WINAPI OLoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
HINSTANCE WINAPI OLoadLibraryW(LPCWSTR pwszFileName);
HMODULE WINAPI OLoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
HMENU WINAPI OLoadMenuIndirectW(CONST MENUTEMPLATEW *lpMenuTemplate);
HMENU WINAPI OLoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
int WINAPI OLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);
LPWSTR WINAPI OlstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
int WINAPI OlstrlenW(LPCWSTR lpString);
UINT WINAPI OMapVirtualKeyW(UINT uCode, UINT uMapType);
int WINAPI OMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
int WINAPI OMessageBoxIndirectW(LPMSGBOXPARAMSW lpmbp);
BOOL WINAPI OModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OMoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
BOOL WINAPI OMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
HANDLE WINAPI OLoadImageW(HINSTANCE hinst, LPCWSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
BOOL WINAPI OOemToCharW(LPCSTR lpszSrc, LPWSTR lpszDst);
VOID WINAPI OOutputDebugStringW(LPCWSTR lpOutputString);
BOOL WINAPI OPeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
BOOL WINAPI OPostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OPostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
LONG APIENTRY ORegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG APIENTRY ORegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
LONG APIENTRY ORegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
LONG APIENTRY ORegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);
LONG APIENTRY ORegDeleteKeyW(HKEY hKey, LPCWSTR pwszSubKey);
LONG APIENTRY ORegDeleteValueW(HKEY hKey, LPWSTR lpValueName);
ATOM WINAPI ORegisterClassW(CONST WNDCLASSW *lpWndClass);
ATOM WINAPI ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass);
BOOL WINAPI OUnregisterClassW(LPCTSTR  lpClassName, HINSTANCE  hInstance);
UINT WINAPI ORegisterClipboardFormatW(LPCWSTR lpszFormat);
UINT WINAPI ORegisterWindowMessageW(LPCWSTR lpString);
LONG APIENTRY ORegOpenKeyExW(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LONG APIENTRY ORegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
LONG APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue, PLONG lpcbValue);
LONG APIENTRY ORegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE* lpData, DWORD cbData);
LONG APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
LONG APIENTRY ORegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HANDLE WINAPI ORemovePropW(HWND hWnd, LPCWSTR lpString);
LRESULT WINAPI OSendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI OSendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
BOOL WINAPI OSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
BOOL WINAPI OSetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
BOOL WINAPI OSetMenuItemInfoW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW lpcmii);
LONG WINAPI OSetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong); 
HHOOK WINAPI OSetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
BOOL WINAPI OSetWindowTextW(HWND hWnd, LPCWSTR lpString);
LONG WINAPI OTabbedTextOutW(HDC hDC, int X, int Y, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
int WINAPI OTranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
SHORT WINAPI OVkKeyScanW(WCHAR ch);
BOOL WINAPI OWinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, DWORD dwData);
BOOL WINAPI OWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
int WINAPIV OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);
BOOL WINAPI OGetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
LONG APIENTRY ORegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
HANDLE WINAPI OCreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
LRESULT WINAPI ODefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI OGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
BOOL WINAPI OSetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
HRESULT WINAPI OStgCreateDocfile(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, IStorage ** ppstgOpen);
int WINAPI OStartDocW(HDC hDC, CONST DOCINFOW * pdiDocW);
BOOL WINAPI OSystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
LPWSTR WINAPI OCharNextW(LPCWSTR lpsz);

#ifdef DEBUG
int WINAPI ODlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
int WINAPI ODlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
BOOL WINAPI ODlgDirSelectComboBoxExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDComboBox);
BOOL WINAPI ODlgDirSelectExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDListBox);
#endif

} // extern "C"

#define AppendMenuW OAppendMenuW
#define CallWindowProcW OCallWindowProcW
#define CharLowerBuffW OCharLowerBuffW
#define CharLowerW OCharLowerW
#define CharNextW OCharNextW
#define CharPrevW OCharPrevW
#define CharToOemW OCharToOemW
#define CharUpperW OCharUpperW
#define CopyFileW OCopyFileW
#define CreateDirectoryExW OCreateDirectoryExW
#define CreateDirectoryW OCreateDirectoryW
#define CreateEnhMetaFileW OCreateEnhMetaFileW
#define CreateEventW OCreateEventW
#define CreateFileMappingW OCreateFileMappingW
#define CreateFileW OCreateFileW
#define CreateFontIndirectW OCreateFontIndirectW
#define CreateFontW OCreateFontW
#define CreateMDIWindowW OCreateMDIWindowW
#define CreateMetaFileW OCreateMetaFileW
#define CreateSemaphoreW OCreateSemaphoreW
#define CreateWindowExW OCreateWindowExW
#define DdeCreateStringHandleW ODdeCreateStringHandleW
#define DdeInitializeW ODdeInitializeW
#define DefFrameProcW ODefFrameProcW
#define DefMDIChildProcW ODefMDIChildProcW
#define DefWindowProcW ODefWindowProcW
#define DeleteFileW ODeleteFileW
#define DialogBoxIndirectParamW ODialogBoxIndirectParamW
#define DialogBoxParamW ODialogBoxParamW
#define DispatchMessageW ODispatchMessageW
#define DrawTextExW ODrawTextExW
#define DrawTextW ODrawTextW
#define ExpandEnvironmentStringsW OExpandEnvironmentStringsW
#define FatalAppExitW OFatalAppExitW
#define FindFirstChangeNotificationW OFindFirstChangeNotificationW
#define FindFirstFileW OFindFirstFileW
#define FindNextFileW OFindNextFileW
#define FindResourceW OFindResourceW
#define FindWindowW OFindWindowW
#define FormatMessageW OFormatMessageW
#define GetCharABCWidthsFloatW OGetCharABCWidthsFloatW
#define GetCharABCWidthsW OGetCharABCWidthsW
#define GetCharWidthFloatW OGetCharWidthFloatW
#define GetCharWidthW OGetCharWidthW
#define GetClassInfoW OGetClassInfoW
#define GetClassInfoExW OGetClassInfoExW
#define GetClassLongW OGetClassLongW
#define GetClassNameW OGetClassNameW
#define GetCurrentDirectoryW OGetCurrentDirectoryW
#define GetDlgItemTextW OGetDlgItemTextW
#define GetFileAttributesW OGetFileAttributesW
#define GetFullPathNameW OGetFullPathNameW
#define GetGlyphOutlineW OGetGlyphOutlineW
#define GetKerningPairsW OGetKerningPairsW
#define GetLocaleInfoW OGetLocaleInfoW
#define GetMessageW OGetMessageW
#define GetModuleFileNameW OGetModuleFileNameW
#define GetModuleHandleW OGetModuleHandleW
#define GetObjectW OGetObjectW
#define GetOutlineTextMetricsW OGetOutlineTextMetricsW
#define GetPrivateProfileIntW OGetPrivateProfileIntW
#define GetPrivateProfileStringW OGetPrivateProfileStringW
#define GetProfileIntW OGetProfileIntW
#define GetPropW OGetPropW
#define GetTabbedTextExtentW OGetTabbedTextExtentW
#define GetTempFileNameW OGetTempFileNameW
#define GetTempPathW OGetTempPathW
#define GetTextExtentPoint32W OGetTextExtentPoint32W
#define GetTextExtentPointW OGetTextExtentPointW
#define GetTextExtentExPointW OGetTextExtentExPointW
#define GetTextMetricsW OGetTextMetricsW
#define GetUserNameW OGetUserNameW
#define GetVersionExW OGetVersionExW
#define GetVolumeInformationW OGetVolumeInformationW
#define GetWindowLongW OGetWindowLongW
#define GetWindowTextLengthW OGetWindowTextLengthW
#define GetWindowTextW OGetWindowTextW
#define GlobalAddAtomW OGlobalAddAtomW
#define GlobalGetAtomNameW OGlobalGetAtomNameW
#define GrayStringW OGrayStringW
#define InsertMenuW OInsertMenuW
#define IsBadStringPtrW OIsBadStringPtrW
#define IsCharAlphaNumericW OIsCharAlphaNumericW
#define IsCharAlphaW OIsCharAlphaW
#define IsDialogMessageW OIsDialogMessageW
#define LCMapStringW OLCMapStringW
#define LoadAcceleratorsW OLoadAcceleratorsW
#define LoadBitmapW OLoadBitmapW
#define LoadCursorW OLoadCursorW
#define LoadIconW OLoadIconW
#define LoadImageW OLoadImageW
#define LoadLibraryExW OLoadLibraryExW
#define LoadLibraryW OLoadLibraryW
#define LoadMenuIndirectW OLoadMenuIndirectW
#define LoadMenuW OLoadMenuW
#define LoadStringW OLoadStringW
#define lstrcatW OlstrcatW
#define lstrcmpiW OlstrcmpiW
#define lstrcmpW OlstrcmpW
#define lstrcpynW OlstrcpynW
#define lstrcpyW OlstrcpyW
#define lstrlenW OlstrlenW
#define MapVirtualKeyW OMapVirtualKeyW
#define MessageBoxW OMessageBoxW
#define MessageBoxIndirectW OMessageBoxIndirectW
#define ModifyMenuW OModifyMenuW
#define MoveFileExW OMoveFileExW
#define MoveFileW OMoveFileW
#define OemToCharW OOemToCharW
#define OutputDebugStringW OOutputDebugStringW
#define PeekMessageW OPeekMessageW
#define PostMessageW OPostMessageW
#define PostThreadMessageW OPostThreadMessageW
#define RegCreateKeyExW ORegCreateKeyExW
#define RegCreateKeyW ORegCreateKeyW
#define RegDeleteKeyW ORegDeleteKeyW
#define RegDeleteValueW ORegDeleteValueW
#define RegEnumKeyW ORegEnumKeyW
#define RegEnumValueW ORegEnumValueW
#define RegEnumKeyExW ORegEnumKeyExW
#define RegisterClassW ORegisterClassW
#define RegisterClassExW ORegisterClassExW
#define RegisterClipboardFormatW ORegisterClipboardFormatW
#define RegisterWindowMessageW ORegisterWindowMessageW
#define RegOpenKeyExW ORegOpenKeyExW
#define RegOpenKeyW ORegOpenKeyW
#define RegQueryInfoKeyW ORegQueryInfoKeyW
#define RegQueryValueExW ORegQueryValueExW
#define RegQueryValueW ORegQueryValueW
#define RegSetValueExW ORegSetValueExW
#define RegSetValueW ORegSetValueW
#define RemovePropW ORemovePropW
#define SendDlgItemMessageW OSendDlgItemMessageW
#define SendMessageW OSendMessageW
#define SendNotifyMessageW OSendNotifyMessageW
#define SetDlgItemTextW OSetDlgItemTextW
#define SetFileAttributesW OSetFileAttributesW
#define SetLocaleInfoW OSetLocaleInfoW
#define SetMenuItemInfoW OSetMenuItemInfoW
#define SetPropW OSetPropW
#define SetWindowLongW OSetWindowLongW
#define SetWindowsHookExW OSetWindowsHookExW
#define SetWindowTextW OSetWindowTextW
#define StartDocW OStartDocW
#define StgCreateDocfile OStgCreateDocfile
#define SystemParametersInfoW OSystemParametersInfoW
#define TabbedTextOutW OTabbedTextOutW
#define TranslateAcceleratorW OTranslateAcceleratorW
#define UnregisterClassW OUnregisterClassW
#define VkKeyScanW OVkKeyScanW
#define WinHelpW OWinHelpW
#define WritePrivateProfileStringW OWritePrivateProfileStringW
#define wsprintfW OwsprintfW
 
// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#define AbortSystemShutdownW OAbortSystemShutdownW
#define AccessCheckAndAuditAlarmW OAccessCheckAndAuditAlarmW
#define AddFontResourceW OAddFontResourceW
#define AddFormW OAddFormW
#define AddJobW OAddJobW
#define AddMonitorW OAddMonitorW
#define AddPortW OAddPortW
#define AddPrinterConnectionW OAddPrinterConnectionW
#define AddPrinterDriverW OAddPrinterDriverW
#define AddPrinterW OAddPrinterW
#define AddPrintProcessorW OAddPrintProcessorW
#define AddPrintProvidorW OAddPrintProvidorW
#define AdvancedDocumentPropertiesW OAdvancedDocumentPropertiesW
#define auxGetDevCapsW OauxGetDevCapsW
#define BackupEventLogW OBackupEventLogW
#define BeginUpdateResourceW OBeginUpdateResourceW
#define BuildCommDCBAndTimeoutsW OBuildCommDCBAndTimeoutsW
#define BuildCommDCBW OBuildCommDCBW
#define CallMsgFilterW OCallMsgFilterW
#define CallNamedPipeW OCallNamedPipeW
#define ChangeDisplaySettingsW OChangeDisplaySettingsW
#define ChangeMenuW OChangeMenuW
#define CharToOemBuffW OCharToOemBuffW
#define CharUpperBuffW OCharUpperBuffW
#define ChooseColorW OChooseColorW
#define ChooseFontW OChooseFontW
#define ClearEventLogW OClearEventLogW
#define CommConfigDialogW OCommConfigDialogW
#define CompareStringW OCompareStringW
#define ConfigurePortW OConfigurePortW
#define CopyAcceleratorTableW OCopyAcceleratorTableW
#define CopyEnhMetaFileW OCopyEnhMetaFileW
#define CopyMetaFileW OCopyMetaFileW
#define CreateAcceleratorTableW OCreateAcceleratorTableW
#define CreateColorSpaceW OCreateColorSpaceW
#define CreateDCW OCreateDCW
#define CreateDesktopW OCreateDesktopW
#define CreateDialogIndirectParamW OCreateDialogIndirectParamW
#define CreateDialogParamW OCreateDialogParamW
#define CreateICW OCreateICW
#define CreateMailslotW OCreateMailslotW
#define CreateMutexW OCreateMutexW
#define CreateNamedPipeW OCreateNamedPipeW
#define CreateProcessW OCreateProcessW
#define CreateProcessAsUserW OCreateProcessAsUserW
#define CreatePropertySheetPageW OCreatePropertySheetPageW
#define CreateScalableFontResourceW OCreateScalableFontResourceW
#define CreateStatusWindowW OCreateStatusWindowW
#define CreateWindowStationW OCreateWindowStationW
#define DceErrorInqTextW ODceErrorInqTextW
#define DdeQueryStringW   ODdeQueryStringW
#define DefDlgProcW ODefDlgProcW
#define DefineDosDeviceW ODefineDosDeviceW
#define DeleteFormW ODeleteFormW
#define DeleteMonitorW ODeleteMonitorW
#define DeletePortW ODeletePortW
#define DeletePrinterConnectionW ODeletePrinterConnectionW
#define DeletePrinterDriverW ODeletePrinterDriverW
#define DeletePrintProcessorW ODeletePrintProcessorW
#define DeletePrintProvidorW ODeletePrintProvidorW
#define DeviceCapabilitiesW ODeviceCapabilitiesW
#define DlgDirListComboBoxW ODlgDirListComboBoxW
#define DlgDirListW ODlgDirListW
#define DlgDirSelectComboBoxExW ODlgDirSelectComboBoxExW
#define DlgDirSelectExW ODlgDirSelectExW
#define DocumentPropertiesW ODocumentPropertiesW
#define DoEnvironmentSubstW ODoEnvironmentSubstW
#define DragQueryFileW ODragQueryFileW
#define DrawStateW ODrawStateW
#define EndUpdateResourceW OEndUpdateResourceW
#define EnumCalendarInfoW OEnumCalendarInfoW
#define EnumDateFormatsW OEnumDateFormatsW
#define EnumDesktopsW OEnumDesktopsW
#define EnumDisplaySettingsW OEnumDisplaySettingsW
#define EnumFontFamiliesExW OEnumFontFamiliesExW
#define EnumFontFamiliesW OEnumFontFamiliesW
#define EnumFontsW OEnumFontsW
#define EnumFormsW OEnumFormsW
#define EnumICMProfilesW OEnumICMProfilesW
#define EnumJobsW OEnumJobsW
#define EnumMonitorsW OEnumMonitorsW
#define EnumPortsW OEnumPortsW
#define EnumPrinterDriversW OEnumPrinterDriversW
#define EnumPrintersW OEnumPrintersW
#define EnumPrintProcessorDatatypesW OEnumPrintProcessorDatatypesW
#define EnumPrintProcessorsW OEnumPrintProcessorsW
#define EnumPropsExW OEnumPropsExW
#define EnumPropsW OEnumPropsW
#define EnumProtocolsW OEnumProtocolsW
#define EnumResourceLanguagesW OEnumResourceLanguagesW
#define EnumResourceNamesW OEnumResourceNamesW
#define EnumResourceTypesW OEnumResourceTypesW
#define EnumSystemCodePagesW OEnumSystemCodePagesW
#define EnumSystemLocalesW OEnumSystemLocalesW
#define EnumTimeFormatsW OEnumTimeFormatsW
#define EnumWindowStationsW OEnumWindowStationsW
#define ExtractAssociatedIconW OExtractAssociatedIconW
#define ExtractIconW OExtractIconW
#define ExtractIconExW OExtractIconExW
#define FillConsoleOutputCharacterW OFillConsoleOutputCharacterW
#define FindEnvironmentStringW OFindEnvironmentStringW
#define FindExecutableW OFindExecutableW
#define FindResourceExW OFindResourceExW
#define FindTextW OFindTextW
#define FindWindowExW OFindWindowExW
#define FoldStringW OFoldStringW
#define GetBinaryTypeW OGetBinaryTypeW
#define GetCharacterPlacementW OGetCharacterPlacementW
#define GetCharWidth32W OGetCharWidth32W
#define GetCommandLineW OGetCommandLineW
#define GetClipboardFormatNameW OGetClipboardFormatNameW
#define GetCompressedFileSizeW OGetCompressedFileSizeW
#define GetComputerNameW OGetComputerNameW
#define GetConsoleTitleW OGetConsoleTitleW
#define GetCurrencyFormatW OGetCurrencyFormatW
#define GetDateFormatW OGetDateFormatW
#define GetDefaultCommConfigW OGetDefaultCommConfigW
#define GetDiskFreeSpaceW OGetDiskFreeSpaceW
#define GetDriveTypeW OGetDriveTypeW
#define GetEnhMetaFileDescriptionW OGetEnhMetaFileDescriptionW
#define GetEnhMetaFileW OGetEnhMetaFileW
#define GetEnvironmentVariableW OGetEnvironmentVariableW
#define GetExpandedNameW OGetExpandedNameW
#define GetFileSecurityW OGetFileSecurityW
#define GetFileTitleW OGetFileTitleW
#define GetFileVersionInfoW OGetFileVersionInfoW
#define GetFileVersionInfoSizeW OGetFileVersionInfoSizeW
#define GetFormW OGetFormW
#define GetICMProfileW OGetICMProfileW
#define GetJobW OGetJobW
#define GetKeyboardLayoutNameW OGetKeyboardLayoutNameW
#define GetKeyNameTextW OGetKeyNameTextW
#define GetLogColorSpaceW OGetLogColorSpaceW
#define GetLogicalDriveStringsW OGetLogicalDriveStringsW
#define GetMenuItemInfoW OGetMenuItemInfoW
#define GetMenuStringW OGetMenuStringW
#define GetMetaFileW OGetMetaFileW
#define GetNameByTypeW OGetNameByTypeW
#define GetNamedPipeHandleStateW OGetNamedPipeHandleStateW
#define GetNumberFormatW OGetNumberFormatW
#define GetOpenFileNameW OGetOpenFileNameW
#define GetPrinterW OGetPrinterW
#define GetPrinterDataW OGetPrinterDataW
#define GetPrinterDriverDirectoryW OGetPrinterDriverDirectoryW
#define GetPrinterDriverW OGetPrinterDriverW
#define GetPrintProcessorDirectoryW OGetPrintProcessorDirectoryW
#define GetPrivateProfileSectionNamesW OGetPrivateProfileSectionNamesW
#define GetPrivateProfileSectionW OGetPrivateProfileSectionW
#define GetPrivateProfileStructW OGetPrivateProfileStructW
#define GetProfileSectionW OGetProfileSectionW
#define GetProfileStringW OGetProfileStringW
#define GetSaveFileNameW OGetSaveFileNameW
#define GetShortPathNameW OGetShortPathNameW
#define GetStartupInfoW OGetStartupInfoW
#define GetStringTypeExW OGetStringTypeExW
#define GetSystemDirectoryW OGetSystemDirectoryW
#define GetTextFaceW OGetTextFaceW
#define GetTimeFormatW OGetTimeFormatW
#define GetTypeByNameW OGetTypeByNameW
#define GetUserObjectInformationW OGetUserObjectInformationW
#define GetWindowsDirectoryW OGetWindowsDirectoryW
#define GlobalFindAtomW OGlobalFindAtomW
#define ImageList_LoadImageW OImageList_LoadImageW
#define ImmConfigureIMEW OImmConfigureIMEW
#define ImmEnumRegisterWordW OImmEnumRegisterWordW
#define ImmEscapeW OImmEscapeW
#define ImmGetCandidateListCountW OImmGetCandidateListCountW
#define ImmGetCandidateListW OImmGetCandidateListW
#define ImmGetCompositionFontW OImmGetCompositionFontW
#define ImmGetCompositionStringW OImmGetCompositionStringW
#define ImmGetConversionListW OImmGetConversionListW
#define ImmGetDescriptionW OImmGetDescriptionW
#define ImmGetGuideLineW OImmGetGuideLineW
#define ImmGetIMEFileNameW OImmGetIMEFileNameW
#define ImmGetRegisterWordStyleW OImmGetRegisterWordStyleW
#define ImmInstallIMEW OImmInstallIMEW
#define ImmIsUIMessageW OImmIsUIMessageW
#define ImmRegisterWordW OImmRegisterWordW
#define ImmSetCompositionFontW OImmSetCompositionFontW
#define ImmSetCompositionStringW OImmSetCompositionStringW
#define ImmUnregisterWordW OImmUnregisterWordW
#define InitiateSystemShutdownW OInitiateSystemShutdownW
#define InsertMenuItemW OInsertMenuItemW
#define IsCharLowerW OIsCharLowerW
#define IsCharUpperW OIsCharUpperW
#define I_RpcServerUnregisterEndpointW OI_RpcServerUnregisterEndpointW
#define joyGetDevCapsW OjoyGetDevCapsW
#define LoadCursorFromFileW OLoadCursorFromFileW
#define LoadKeyboardLayoutW OLoadKeyboardLayoutW
#define LogonUserW OLogonUserW
#define LZOpenFileW OLZOpenFileW
#define MapVirtualKeyExW OMapVirtualKeyExW
#define MIMEAssociationDialogW OMIMEAssociationDialogW
#define MultinetGetConnectionPerformanceW OMultinetGetConnectionPerformanceW
#define ObjectCloseAuditAlarmW OObjectCloseAuditAlarmW
#define ObjectOpenAuditAlarmW OObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarmW OObjectPrivilegeAuditAlarmW
#define OemToCharBuffW OOemToCharBuffW
#define OpenBackupEventLogW OOpenBackupEventLogW
#define OpenDesktopW OOpenDesktopW
#define OpenEventLogW OOpenEventLogW
#define OpenEventW OOpenEventW
#define OpenFileMappingW OOpenFileMappingW
#define OpenMutexW OOpenMutexW
#define OpenPrinterW OOpenPrinterW
#define OpenSemaphoreW OOpenSemaphoreW
#define OpenWindowStationW OOpenWindowStationW
#define PageSetupDlgW OPageSetupDlgW
#define PeekConsoleInputW OPeekConsoleInputW
#define PolyTextOutW OPolyTextOutW
#define PrintDlgW OPrintDlgW
#define PrinterMessageBoxW OPrinterMessageBoxW
#define PrivilegedServiceAuditAlarmW OPrivilegedServiceAuditAlarmW
#define PropertySheetW OPropertySheetW
#define QueryDosDeviceW OQueryDosDeviceW
#define ReadConsoleInputW OReadConsoleInputW
#define ReadConsoleOutputCharacterW OReadConsoleOutputCharacterW
#define ReadConsoleOutputW OReadConsoleOutputW
#define ReadConsoleW OReadConsoleW
#define ReadEventLogW OReadEventLogW
#define RegConnectRegistryW ORegConnectRegistryW
#define RegisterEventSourceW ORegisterEventSourceW
#define RegLoadKeyW ORegLoadKeyW
#define RegQueryMultipleValuesW ORegQueryMultipleValuesW
#define RegReplaceKeyW ORegReplaceKeyW
#define RegRestoreKeyW ORegRestoreKeyW
#define RegSaveKeyW ORegSaveKeyW
#define RegUnLoadKeyW ORegUnLoadKeyW
#define RemoveDirectoryW ORemoveDirectoryW
#define RemoveFontResourceW ORemoveFontResourceW
#define ReplaceTextW OReplaceTextW
#define ReportEventW OReportEventW
#define ResetDCW OResetDCW
#define ResetPrinterW OResetPrinterW
#define RpcBindingFromStringBindingW ORpcBindingFromStringBindingW
#define RpcBindingInqAuthClientW ORpcBindingInqAuthClientW
#define RpcBindingToStringBindingW ORpcBindingToStringBindingW
#define RpcEpRegisterNoReplaceW ORpcEpRegisterNoReplaceW
#define RpcMgmtEpEltInqNextW ORpcMgmtEpEltInqNextW
#define RpcMgmtInqServerPrincNameW ORpcMgmtInqServerPrincNameW
#define RpcNetworkInqProtseqsW ORpcNetworkInqProtseqsW
#define RpcNetworkIsProtseqValidW ORpcNetworkIsProtseqValidW
#define RpcNsBindingInqEntryNameW ORpcNsBindingInqEntryNameW
#define RpcProtseqVectorFreeW ORpcProtseqVectorFreeW
#define RpcServerInqDefaultPrincNameW ORpcServerInqDefaultPrincNameW
#define RpcServerUseProtseqEpW ORpcServerUseProtseqEpW
#define RpcServerUseProtseqIfW ORpcServerUseProtseqIfW
#define RpcServerUseProtseqW ORpcServerUseProtseqW
#define RpcStringBindingComposeW ORpcStringBindingComposeW
#define RpcStringBindingParseW ORpcStringBindingParseW
#define RpcStringFreeW ORpcStringFreeW
#define ScrollConsoleScreenBufferW OScrollConsoleScreenBufferW
#define SearchPathW OSearchPathW
#define SendMessageCallbackW OSendMessageCallbackW
#define SendMessageTimeoutW OSendMessageTimeoutW
#define SetClassLongW OSetClassLongW
#define SetComputerNameW OSetComputerNameW
#define SetConsoleTitleW OSetConsoleTitleW
#define SetCurrentDirectoryW OSetCurrentDirectoryW
#define SetDefaultCommConfigW OSetDefaultCommConfigW
#define SetEnvironmentVariableW OSetEnvironmentVariableW
#define SetFileSecurityW OSetFileSecurityW
#define SetFormW OSetFormW
#define SetICMProfileW OSetICMProfileW
#define SetJobW OSetJobW
#define SetPrinterDataW OSetPrinterDataW
#define SetPrinterW OSetPrinterW
#define SetUserObjectInformationW OSetUserObjectInformationW
#define SetVolumeLabelW OSetVolumeLabelW
#define SetWindowsHookW OSetWindowsHookW
#define SHBrowseForFolderW OSHBrowseForFolderW
#define Shell_NotifyIconW OShell_NotifyIconW
#define ShellAboutW OShellAboutW
#define ShellExecuteW OShellExecuteW
#define ShellExecuteExW OShellExecuteExW
#define SHFileOperationW OSHFileOperationW
#define SHGetFileInfoW OSHGetFileInfoW
#define SHGetNewLinkInfoW OSHGetNewLinkInfoW
#define SHGetPathFromIDListW OSHGetPathFromIDListW
#define sndPlaySoundW OsndPlaySoundW
#define StartDocPrinterW OStartDocPrinterW
#define StgCreateDocfile OStgCreateDocfile
#define TranslateURLW OTranslateURLW
#define UpdateICMRegKeyW OUpdateICMRegKeyW
#define URLAssociationDialogW OURLAssociationDialogW
#define UuidFromStringW OUuidFromStringW
#define VerFindFileW OVerFindFileW
#define VerInstallFileW OVerInstallFileW
#define VerLanguageNameW OVerLanguageNameW
#define VerQueryValueW OVerQueryValueW
#define VkKeyScanExW OVkKeyScanExW
#define WaitNamedPipeW OWaitNamedPipeW
#define waveInGetDevCapsW OwaveInGetDevCapsW
#define waveInGetErrorTextW OwaveInGetErrorTextW
#define waveOutGetDevCapsW OwaveOutGetDevCapsW
#define waveOutGetErrorTextW OwaveOutGetErrorTextW
#define wglUseFontBitmapsW OwglUseFontBitmapsW
#define wglUseFontOutlinesW OwglUseFontOutlinesW
#define WinExecErrorW OWinExecErrorW
#define WNetAddConnection2W OWNetAddConnection2W
#define WNetAddConnection3W OWNetAddConnection3W
#define WNetAddConnectionW OWNetAddConnectionW
#define WNetCancelConnection2W OWNetCancelConnection2W
#define WNetCancelConnectionW OWNetCancelConnectionW
#define WNetConnectionDialog1W OWNetConnectionDialog1W
#define WNetDisconnectDialog1W OWNetDisconnectDialog1W
#define WNetEnumResourceW OWNetEnumResourceW
#define WNetGetConnectionW OWNetGetConnectionW
#define WNetGetLastErrorW OWNetGetLastErrorW
#define WNetGetNetworkInformationW OWNetGetNetworkInformationW
#define WNetGetProviderNameW OWNetGetProviderNameW
#define WNetGetUniversalNameW OWNetGetUniversalNameW
#define WNetGetUserW OWNetGetUserW
#define WNetOpenEnumW OWNetOpenEnumW
#define WNetSetConnectionW OWNetSetConnectionW
#define WNetUseConnectionW OWNetUseConnectionW
#define WriteConsoleInputW OWriteConsoleInputW
#define WriteConsoleOutputCharacterW OWriteConsoleOutputCharacterW
#define WriteConsoleOutputW OWriteConsoleOutputW
#define WriteConsoleW OWriteConsoleW
#define WritePrivateProfileSectionW OWritePrivateProfileSectionW
#define WritePrivateProfileStructW OWritePrivateProfileStructW
#define WriteProfileSectionW OWriteProfileSectionW
#define WriteProfileStringW OWriteProfileStringW
#define wvsprintfW OwvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_H__

#else // __WIN95WRP_CPP__

#undef AppendMenuW
#undef CallWindowProcW
#undef CharLowerBuffW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharToOemW
#undef CharUpperW
#undef CopyFileW
#undef CreateDirectoryExW
#undef CreateDirectoryW
#undef CreateEnhMetaFileW
#undef CreateEventW
#undef CreateFileMappingW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateFontW
#undef CreateMDIWindowW
#undef CreateMetaFileW
#undef CreateSemaphoreW
#undef CreateWindowExW
#undef DdeCreateStringHandleW
#undef DdeInitializeW
#undef DefFrameProcW
#undef DefMDIChildProcW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxIndirectParamW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DrawTextExW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FatalAppExitW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FindNextFileW
#undef FindResourceW
#undef FindWindowW
#undef FormatMessageW
#undef GetCharABCWidthsFloatW
#undef GetCharABCWidthsW
#undef GetCharWidthFloatW
#undef GetCharWidthW
#undef GetClassInfoW
#undef GetClassInfoExW
#undef GetClassLongW
#undef GetClassNameW
#undef GetCurrentDirectoryW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetFullPathNameW
#undef GetGlyphOutlineW
#undef GetKerningPairsW
#undef GetLocaleInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetModuleHandleW
#undef GetObjectW
#undef GetOutlineTextMetricsW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetPropW
#undef GetTabbedTextExtentW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTextExtentPointW
#undef GetTextExtentExPointW
#undef GetTextMetricsW
#undef GetUserNameW
#undef GetVersionExW
#undef GetVolumeInformationW
#undef GetWindowLongW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef GlobalAddAtomW
#undef GlobalGetAtomNameW
#undef GrayStringW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharAlphaNumericW
#undef IsCharAlphaW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadBitmapW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryExW
#undef LoadLibraryW
#undef LoadMenuIndirectW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef lstrlenW
#undef MapVirtualKeyW
#undef MessageBoxW
#undef MessageBoxIndirectW
#undef ModifyMenuW
#undef MoveFileExW
#undef MoveFileW
#undef OemToCharW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef PostThreadMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyW
#undef RegEnumValueW
#undef RegEnumKeyExW
#undef RegisterClassW
#undef RegisterClassExW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegOpenKeyW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef RemovePropW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SendNotifyMessageW
#undef SetDlgItemTextW
#undef SetFileAttributesW
#undef SetLocaleInfoW
#undef SetMenuItemInfoW
#undef SetPropW
#undef SetWindowLongW
#undef SetWindowsHookExW
#undef SetWindowTextW
#undef StartDocW
#undef StgCreateDocfileW
#undef SystemParametersInfoW
#undef TabbedTextOutW
#undef TranslateAcceleratorW
#undef UnregisterClassW
#undef VkKeyScanW
#undef WinHelpW
#undef WritePrivateProfileStringW
#undef wsprintfW
 
// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#undef AbortSystemShutdownW
#undef AccessCheckAndAuditAlarmW
#undef AddFontResourceW
#undef AddFormW
#undef AddJobW
#undef AddMonitorW
#undef AddPortW
#undef AddPrinterConnectionW
#undef AddPrinterDriverW
#undef AddPrinterW
#undef AddPrintProcessorW
#undef AddPrintProvidorW
#undef AdvancedDocumentPropertiesW
#undef auxGetDevCapsW
#undef BackupEventLogW
#undef BeginUpdateResourceW
#undef BuildCommDCBAndTimeoutsW
#undef BuildCommDCBW
#undef CallMsgFilterW
#undef CallNamedPipeW
#undef ChangeDisplaySettingsW
#undef ChangeMenuW
#undef CharToOemBuffW
#undef CharUpperBuffW
#undef ChooseColorW
#undef ChooseFontW
#undef ClearEventLogW
#undef CommConfigDialogW
#undef CompareStringW
#undef ConfigurePortW
#undef CopyAcceleratorTableW
#undef CopyEnhMetaFileW
#undef CopyMetaFileW
#undef CreateAcceleratorTableW
#undef CreateColorSpaceW
#undef CreateDCW
#undef CreateDesktopW
#undef CreateDialogIndirectParamW
#undef CreateDialogParamW
#undef CreateICW
#undef CreateMailslotW
#undef CreateMutexW
#undef CreateNamedPipeW
#undef CreateProcessW
#undef CreateProcessAsUserW
#undef CreatePropertySheetPageW
#undef CreateScalableFontResourceW
#undef CreateStatusWindowW
#undef CreateWindowStationW
#undef DceErrorInqTextW
#undef DdeQueryStringW
#undef DefDlgProcW
#undef undefDosDeviceW
#undef DeleteFormW
#undef DeleteMonitorW
#undef DeletePortW
#undef DeletePrinterConnectionW
#undef DeletePrinterDriverW
#undef DeletePrintProcessorW
#undef DeletePrintProvidorW
#undef DeviceCapabilitiesW
#undef DlgDirListComboBoxW
#undef DlgDirListW
#undef DlgDirSelectComboBoxExW
#undef DlgDirSelectExW
#undef DocumentPropertiesW
#undef DoEnvironmentSubstW
#undef DragQueryFileW
#undef DrawStateW
#undef EndUpdateResourceW
#undef EnumCalendarInfoW
#undef EnumDateFormatsW
#undef EnumDesktopsW
#undef EnumDisplaySettingsW
#undef EnumFontFamiliesExW
#undef EnumFontFamiliesW
#undef EnumFontsW
#undef EnumFormsW
#undef EnumICMProfilesW
#undef EnumJobsW
#undef EnumMonitorsW
#undef EnumPortsW
#undef EnumPrinterDriversW
#undef EnumPrintersW
#undef EnumPrintProcessorDatatypesW
#undef EnumPrintProcessorsW
#undef EnumPropsExW
#undef EnumPropsW
#undef EnumProtocolsW
#undef EnumResourceLanguagesW
#undef EnumResourceNamesW
#undef EnumResourceTypesW
#undef EnumSystemCodePagesW
#undef EnumSystemLocalesW
#undef EnumTimeFormatsW
#undef EnumWindowStationsW
#undef ExtractAssociatedIconW
#undef ExtractIconW
#undef ExtractIconExW
#undef FillConsoleOutputCharacterW
#undef FindEnvironmentStringW
#undef FindExecutableW
#undef FindResourceExW
#undef FindTextW
#undef FindWindowExW
#undef FoldStringW
#undef GetBinaryTypeW
#undef GetCharacterPlacementW
#undef GetCharWidth32W
#undef GetCommandLineW
#undef GetClipboardFormatNameW
#undef GetCompressedFileSizeW
#undef GetComputerNameW
#undef GetConsoleTitleW
#undef GetCurrencyFormatW
#undef GetDateFormatW
#undef GetDefaultCommConfigW
#undef GetDiskFreeSpaceW
#undef GetDriveTypeW
#undef GetEnhMetaFileDescriptionW
#undef GetEnhMetaFileW
#undef GetEnvironmentVariableW
#undef GetExpandedNameW
#undef GetFileSecurityW
#undef GetFileTitleW
#undef GetFileVersionInfoW
#undef GetFileVersionInfoSizeW
#undef GetFormW
#undef GetICMProfileW
#undef GetJobW
#undef GetKeyboardLayoutNameW
#undef GetKeyNameTextW
#undef GetLogColorSpaceW
#undef GetLogicalDriveStringsW
#undef GetMenuItemInfoW
#undef GetMenuStringW
#undef GetMetaFileW
#undef GetNameByTypeW
#undef GetNamedPipeHandleStateW
#undef GetNumberFormatW
#undef GetOpenFileNameW
#undef GetPrinterW
#undef GetPrinterDataW
#undef GetPrinterDriverDirectoryW
#undef GetPrinterDriverW
#undef GetPrintProcessorDirectoryW
#undef GetPrivateProfileSectionNamesW
#undef GetPrivateProfileSectionW
#undef GetPrivateProfileStructW
#undef GetProfileSectionW
#undef GetProfileStringW
#undef GetSaveFileNameW
#undef GetShortPathNameW
#undef GetStartupInfoW
#undef GetStringTypeExW
#undef GetSystemDirectoryW
#undef GetTextFaceW
#undef GetTimeFormatW
#undef GetTypeByNameW
#undef GetUserObjectInformationW
#undef GetWindowsDirectoryW
#undef GlobalFindAtomW
#undef ImageList_LoadImageW
#undef ImmConfigureIMEW
#undef ImmEnumRegisterWordW
#undef ImmEscapeW
#undef ImmGetCandidateListCountW
#undef ImmGetCandidateListW
#undef ImmGetCompositionFontW
#undef ImmGetCompositionStringW
#undef ImmGetConversionListW
#undef ImmGetDescriptionW
#undef ImmGetGuideLineW
#undef ImmGetIMEFileNameW
#undef ImmGetRegisterWordStyleW
#undef ImmInstallIMEW
#undef ImmIsUIMessageW
#undef ImmRegisterWordW
#undef ImmSetCompositionFontW
#undef ImmSetCompositionStringW
#undef ImmUnregisterWordW
#undef InitiateSystemShutdownW
#undef InsertMenuItemW
#undef IsCharLowerW
#undef IsCharUpperW
#undef I_RpcServerUnregisterEndpointW
#undef joyGetDevCapsW
#undef LoadCursorFromFileW
#undef LoadKeyboardLayoutW
#undef LogonUserW
#undef LZOpenFileW
#undef MapVirtualKeyExW
#undef MIMEAssociationDialogW
#undef MultinetGetConnectionPerformanceW
#undef ObjectCloseAuditAlarmW
#undef ObjectOpenAuditAlarmW
#undef ObjectPrivilegeAuditAlarmW
#undef OemToCharBuffW
#undef OpenBackupEventLogW
#undef OpenDesktopW
#undef OpenEventLogW
#undef OpenEventW
#undef OpenFileMappingW
#undef OpenMutexW
#undef OpenPrinterW
#undef OpenSemaphoreW
#undef OpenWindowStationW
#undef PageSetupDlgW
#undef PeekConsoleInputW
#undef PolyTextOutW
#undef PrintDlgW
#undef PrinterMessageBoxW
#undef PrivilegedServiceAuditAlarmW
#undef PropertySheetW
#undef QueryDosDeviceW
#undef ReadConsoleInputW
#undef ReadConsoleOutputCharacterW
#undef ReadConsoleOutputW
#undef ReadConsoleW
#undef ReadEventLogW
#undef RegConnectRegistryW
#undef RegisterEventSourceW
#undef RegLoadKeyW
#undef RegQueryMultipleValuesW
#undef RegReplaceKeyW
#undef RegRestoreKeyW
#undef RegSaveKeyW
#undef RegUnLoadKeyW
#undef RemoveDirectoryW
#undef RemoveFontResourceW
#undef ReplaceTextW
#undef ReportEventW
#undef ResetDCW
#undef ResetPrinterW
#undef RpcBindingFromStringBindingW
#undef RpcBindingInqAuthClientW
#undef RpcBindingToStringBindingW
#undef RpcEpRegisterNoReplaceW
#undef RpcMgmtEpEltInqNextW
#undef RpcMgmtInqServerPrincNameW
#undef RpcNetworkInqProtseqsW
#undef RpcNetworkIsProtseqValidW
#undef RpcNsBindingInqEntryNameW
#undef RpcProtseqVectorFreeW
#undef RpcServerInqDefaultPrincNameW
#undef RpcServerUseProtseqEpW
#undef RpcServerUseProtseqIfW
#undef RpcServerUseProtseqW
#undef RpcStringBindingComposeW
#undef RpcStringBindingParseW
#undef RpcStringFreeW
#undef ScrollConsoleScreenBufferW
#undef SearchPathW
#undef SendMessageCallbackW
#undef SendMessageTimeoutW
#undef SetClassLongW
#undef SetComputerNameW
#undef SetConsoleTitleW
#undef SetCurrentDirectoryW
#undef SetDefaultCommConfigW
#undef SetEnvironmentVariableW
#undef SetFileSecurityW
#undef SetFormW
#undef SetICMProfileW
#undef SetJobW
#undef SetPrinterDataW
#undef SetPrinterW
#undef SetUserObjectInformationW
#undef SetVolumeLabelW
#undef SetWindowsHookW
#undef SHBrowseForFolderW
#undef Shell_NotifyIconW
#undef ShellAboutW
#undef ShellExecuteW
#undef ShellExecuteExW
#undef SHFileOperationW
#undef SHGetFileInfoW
#undef SHGetNewLinkInfoW
#undef SHGetPathFromIDListW
#undef sndPlaySoundW
#undef StartDocPrinterW
#undef StgCreateDocfileW
#undef TranslateURLW
#undef UpdateICMRegKeyW
#undef URLAssociationDialogW
#undef UuidFromStringW
#undef VerFindFileW
#undef VerInstallFileW
#undef VerLanguageNameW
#undef VerQueryValueW
#undef VkKeyScanExW
#undef WaitNamedPipeW
#undef waveInGetDevCapsW
#undef waveInGetErrorTextW
#undef waveOutGetDevCapsW
#undef waveOutGetErrorTextW
#undef wglUseFontBitmapsW
#undef wglUseFontOutlinesW
#undef WinExecErrorW
#undef WNetAddConnection2W
#undef WNetAddConnection3W
#undef WNetAddConnectionW
#undef WNetCancelConnection2W
#undef WNetCancelConnectionW
#undef WNetConnectionDialog1W
#undef WNetDisconnectDialog1W
#undef WNetEnumResourceW
#undef WNetGetConnectionW
#undef WNetGetLastErrorW
#undef WNetGetNetworkInformationW
#undef WNetGetProviderNameW
#undef WNetGetUniversalNameW
#undef WNetGetUserW
#undef WNetOpenEnumW
#undef WNetSetConnectionW
#undef WNetUseConnectionW
#undef WriteConsoleInputW
#undef WriteConsoleOutputCharacterW
#undef WriteConsoleOutputW
#undef WriteConsoleW
#undef WritePrivateProfileSectionW
#undef WritePrivateProfileStructW
#undef WriteProfileSectionW
#undef WriteProfileStringW
#undef wvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\zorder.cpp ===
//------------------------------------------------------------------------------
// zorder.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     V-BMohan
//
// History
//      8-15-97     created     (ThomasOl)
//     10-31-97     rewritten   (V-BMohan)
//
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <stdlib.h>

//#include "mfcincl.h"
#include "triedit.h"
#include "document.h"
#include "zorder.h"
#include "dispatch.h"

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CompareProc
//
// Compare the Z-order of the two items (which must be CZOrder pointers)
// and return:
//
//      -1 if the Z-order of item 1 preceeds that of item 2
//       1 if the Z-order of item 1 succeeds or is the same as that of item 2
//

int CTriEditDocument::CompareProc(const void *arg1, const void *arg2)
{
    CZOrder* pcz1 = (CZOrder*)arg1;
    CZOrder* pcz2 = (CZOrder*)arg2;

    _ASSERTE(pcz1 != NULL);
    _ASSERTE(pcz2 != NULL);
    if (pcz1->m_zOrder < pcz2->m_zOrder)
        return -1;
    else
    if (pcz1->m_zOrder > pcz2->m_zOrder)
        return 1;

    // if arg1's Z-order is qual to arg2's zorder then return a one 
    // instead of a zero  so that the qsort function treats it as 
    // arg1's Z-Order > arg2's Z-order and keeps arg1 in top of the
    // sort order. 
    // 
    // This actually helps us to sort elements in such a  way that among
    // the elements having the same Z-order the recently created one will be
    // in top of the order. This way we make sure that when propagating
    // Z-order it doesn't affect the existing Z-order appearance of the
    // elements.
    return 1; 
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsEqualZIndex
//
// Given a sorted array of CZorder objects and the number of elements
// in the array, return TRUE if any two consecutive objects have the
// same Z-order. Return FALSE if this is not the case.
//

BOOL CTriEditDocument::IsEqualZIndex(CZOrder* pczOrder, LONG lIndex)
{
    for (LONG lLoop = 0; lLoop < (lIndex - 1); ++lLoop)
    {
        if (pczOrder[lLoop].m_zOrder == pczOrder[lLoop+1].m_zOrder)
            return TRUE;
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetZIndex
//
// Fetch the Z-order value from the given HTML element and return
// it under *plZindex. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::GetZIndex(IHTMLElement* pihtmlElement, LONG* plZindex)
{
    HRESULT hr;
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT var;

    _ASSERTE(pihtmlElement);
    _ASSERTE(plZindex);
    hr = pihtmlElement->get_style(&pihtmlStyle);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlStyle);

    if (SUCCEEDED(hr) && pihtmlStyle)
    {
        VariantInit(&var);
        hr = pihtmlStyle->get_zIndex(&var);
        hr = VariantChangeType(&var, &var, 0, VT_I4);

        if (SUCCEEDED(hr))
        {
            *plZindex = var.lVal;
        }
    }

    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetZIndex
//
// Set the Z-order of the given HTML element as indicated. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::SetZIndex(IHTMLElement* pihtmlElement, LONG lZindex)
{
    HRESULT hr;
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT var;

    _ASSERTE(pihtmlElement);
    
    hr = pihtmlElement->get_style(&pihtmlStyle);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlStyle);

    if (SUCCEEDED(hr) && pihtmlStyle)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = lZindex;
        hr = pihtmlStyle->put_zIndex(var);
        _ASSERTE(SUCCEEDED(hr));
    }

    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::AssignZIndex
//
// Set the Z-order of the given HTML element according to the index mode:
//
//      SEND_BACKWARD
//      SEND_FORWARD
//      SEND_TO_BACK
//      SEND_TO_FRONT
//      SEND_BEHIND_1D
//      SEND_FRONT_1D
//      MADE_ABSOLUTE
//
// The Z-order of the element's sibling will be adjusted as necessary
// in order to keep them unique. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::AssignZIndex(IHTMLElement* pihtmlElement, int nZIndexMode)
{
    HRESULT hr = E_FAIL;
    IHTMLElementCollection* pihtmlCollection = NULL;
    IHTMLElement* pihtmlElementTemp = NULL;
    IHTMLElement* pihtmlElementParent = NULL;
    LONG iIndex, lLoop;
	LONG lZindex = 0;
    LONG lSourceIndexTemp, lSourceIndexElement, lSourceIndexParent;
    LONG cElements = 0;
    BOOL f2d = FALSE;
    BOOL f2dCapable = FALSE;
    BOOL fZeroIndex = FALSE;
    BOOL fSorted = FALSE;
    BOOL fZIndexNegative = FALSE; // FALSE means we need to deal with
			    	  // elements having +ve Z-INDEX and
                                  // vice versa.
    CZOrder* pczOrder=NULL;
    
    _ASSERTE(pihtmlElement);

    if ( !pihtmlElement)
    {
        return E_FAIL;
    }

    hr = pihtmlElement->get_offsetParent(&pihtmlElementParent);

    if (FAILED(hr) || !pihtmlElementParent)
    {
        return E_FAIL;
    }

    // we get the source index of the passed element's parent to
    // be used in the following for loop to identify the elements
    // belonging to this parent.
    
    hr = pihtmlElementParent->get_sourceIndex(&lSourceIndexParent);
    SAFERELEASE(pihtmlElementParent);
    _ASSERTE(SUCCEEDED(hr) && (lSourceIndexParent != -1));
    if (FAILED(hr) || (lSourceIndexParent == -1))
    {
        return E_FAIL;
    }

    // we get the source index of the element to be used in the
    // following for loop to identify the current element in
    // the collection.

    hr = pihtmlElement->get_sourceIndex(&lSourceIndexElement);

    _ASSERTE(SUCCEEDED(hr) && (lSourceIndexElement != -1));
    if (FAILED(hr) || (lSourceIndexElement == -1))
    {
        return E_FAIL;
    }

    hr = GetZIndex(pihtmlElement, &lZindex);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
    {
        return E_FAIL;
    }

    if (lZindex < 0) 
    {
        if (nZIndexMode == SEND_BEHIND_1D)    // If Z-order is negative then
                                              // its already behind 1D.
        {                                     // hence return. 
            return S_OK;
        }
        else if(nZIndexMode != SEND_FRONT_1D) 
        {
            fZIndexNegative = TRUE; // If the passed element has negative
                                    // Z-order and if mode is anything
        }                           // other than send front then we
                                    // need to deal only with negative
                                    // elements.
    }
    else
    {
        if (nZIndexMode == SEND_FRONT_1D)     // If Z-order is positive then
                                              // its already in front of 1D
        {                                     // hence return.
            if (lZindex > 0)
                return S_OK;
        }
        else if(nZIndexMode == SEND_BEHIND_1D)
        {
            fZIndexNegative = TRUE; // If the passed element has positive
                                    // Z-order and if mode is send behind
        }                           // then we need to deal only with
                                    // negative elements.
    }

    hr = GetAllCollection(&pihtmlCollection);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlCollection);

    if (FAILED(hr) || !pihtmlCollection)    // If we dont have a collection
                                            // then exit
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pihtmlCollection->get_length(&cElements);  // Get number of elements
                                                    // in the collection
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(cElements > 0);

    if ( FAILED(hr) || cElements <= 0 )     
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pczOrder = new CZOrder[cElements];      // Allocate an array of CZOrder
                                            // big enough for all

    if (!pczOrder)                          
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Now we collect all elements which are children of the parent of
    // the element passed to this function, including the passed element
    // itself.

    for (lLoop=0, iIndex=0; lLoop < cElements; lLoop++)
    {
        hr = GetCollectionElement(pihtmlCollection, lLoop, &pihtmlElementTemp); 
        _ASSERTE(SUCCEEDED(hr));
        _ASSERTE(pihtmlElementTemp);

        if (FAILED(hr) || !pihtmlElementTemp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = Is2DCapable(pihtmlElementTemp, &f2dCapable);

        if (FAILED(hr))
            goto Cleanup;

        if (f2dCapable) 
        {
            hr = Is2DElement(pihtmlElementTemp, &f2d);

            if (FAILED(hr))
                goto Cleanup;

            if (f2d) // If the element is a 2D element
            {   
                hr = pihtmlElementTemp->get_offsetParent(&pihtmlElementParent);
                _ASSERTE(SUCCEEDED(hr));
                _ASSERTE(pihtmlElementParent);

                if (FAILED(hr) || !pihtmlElementParent)
                    goto Cleanup;

                hr = pihtmlElementParent->get_sourceIndex(&lSourceIndexTemp);
                SAFERELEASE(pihtmlElementParent);
                _ASSERTE(SUCCEEDED(hr) && lSourceIndexElement != -1);

                if (FAILED(hr) || (lSourceIndexTemp == -1))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // Is it a child of the same parent as that of the
                // parent of the element passed to this function?

                if (lSourceIndexTemp == lSourceIndexParent) 
                {
                     hr = GetZIndex(pihtmlElementTemp, &lZindex);
                    _ASSERTE(SUCCEEDED(hr));

                    if (FAILED(hr))
                        goto Cleanup;

                    if (lZindex == 0)
                    {
                        hr = pihtmlElementTemp->get_sourceIndex(&lSourceIndexTemp);
    
                        if (FAILED(hr) || (lSourceIndexTemp == -1))
                        {
                            hr = E_FAIL;
                            goto Cleanup;
                        }

                        // General scenario is that we set fZeroIndex to
                        // TRUE when we encounter a child with no Z-order
                        // index.
                        // 
                        // So that after we have collected all the children
                        // we could assign Z-order to all the children.
                        //
                        // However, when this function is called after
                        // making a 2D element we need to ensure that we
                        // don't set fZeroIndex to TRUE when the current
                        // child is the one which is made absolute, hence
                        // the following check.
                
                        if (!((lSourceIndexTemp == lSourceIndexElement) &&
                              (nZIndexMode == MADE_ABSOLUTE)))
                            fZeroIndex = TRUE;
                    }
                                 
                    if (fZIndexNegative)
                    {
                        if (lZindex < 0) // Collect only children with
                                         // negative Z-order index.
                        {
                            CZOrder z(pihtmlElementTemp, lZindex);
                            pczOrder[iIndex++] = z;
                        }
                    }
                    else
                    {
                        if (lZindex >= 0) // collect only children with
                                          // positive or no Z-order index.
                        {
                            CZOrder z(pihtmlElementTemp, lZindex);
                            pczOrder[iIndex++] = z;
                        }
                    }

                }
                
            }

        }
        
        SAFERELEASE(pihtmlElementTemp);
    }

    // If we have at least one child with no Z-order index and if we are
    // dealing with an element with a positive Z-order index, then we
    // assign new Z-order indexes to all the children collected above.

    if (fZeroIndex && !fZIndexNegative)
    {
        LONG lZOrder = ZINDEX_BASE;

        for ( lLoop = 0; lLoop < iIndex; lLoop++, lZOrder++)
        {
            if (pczOrder[lLoop].m_zOrder != 0)
            {
                // Maintain the existing Z-order index
                pczOrder[lLoop].m_zOrder += (iIndex+ZINDEX_BASE); 
            }
            else
            {
               pczOrder[lLoop].m_zOrder += lZOrder;
            }
            
        }
        
        if (iIndex > 1) 
        {
            // Wwe have at least two children; sort by Zorder index,
            // and propagate starting from ZINDEX_BASE.
            qsort( (LPVOID)pczOrder, iIndex, sizeof(CZOrder), CompareProc);
            hr = PropagateZIndex(pczOrder, iIndex);
            _ASSERTE(SUCCEEDED(hr));

            if (FAILED(hr))
                goto Cleanup;
            fSorted = TRUE;
        }

        
    }

    // If we have at least two children and not already sorted then sort
    // by Z-order index.
    if ((iIndex > 1) && !fSorted) 
        qsort( (LPVOID)pczOrder, iIndex, sizeof(CZOrder), CompareProc);

    if (IsEqualZIndex(pczOrder, iIndex))
    {
        hr = PropagateZIndex(pczOrder, iIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

    if ((nZIndexMode == MADE_ABSOLUTE) ||
        (nZIndexMode == SEND_TO_FRONT) ||
        (nZIndexMode == SEND_BEHIND_1D))
    {
        LONG lZIndex;
        LONG lmaxZIndex = pczOrder[iIndex - 1].m_zOrder;

        if (fZIndexNegative)
        {
            if (iIndex == 0) // If we have no children with negative
                             // Z-order index.
            {
                hr = SetZIndex(pihtmlElement, -ZINDEX_BASE);
                goto Cleanup;
            }
            else 
            {
                // when we are dealing with elements with negative Z-order
                // we need to ensure that the maximum Z-order index (to be
                // assigned to the current element) can never become
                // greater than or equal to 0. If so then propagate
                // the Z-order index starting from ZINDEX_BASE.

                if ((lmaxZIndex + 1) >=0) 
                {
                    hr = PropagateZIndex(pczOrder, iIndex, fZIndexNegative);

                    if (FAILED(hr))
                        goto Cleanup;
                }
    
                lmaxZIndex = pczOrder[iIndex - 1].m_zOrder;
            }
        }

        if(SUCCEEDED(hr = GetZIndex(pihtmlElement, &lZIndex)))
        {
            if(lZIndex != lmaxZIndex) 
            {
                // The current element is not the top most element
                hr = SetZIndex(pihtmlElement, lmaxZIndex+1);
                _ASSERTE(SUCCEEDED(hr));
            }
            else if(lmaxZIndex == 0) 
            {
                // if the current element has no Z-order index
                hr = SetZIndex(pihtmlElement, ZINDEX_BASE);
                _ASSERTE(SUCCEEDED(hr));
            }
        }
    }
    else if ((nZIndexMode == SEND_BACKWARD) || (nZIndexMode == SEND_FORWARD))
    {
        LONG lPrevOrNextZIndex;
        LONG lIndexBuf = iIndex;

        hr = GetZIndex(pihtmlElement, &lPrevOrNextZIndex);
        
        if (FAILED(hr))
            goto Cleanup;

        if (iIndex == 1)
            goto Cleanup;
        
        while(--iIndex>=0)
        {
            if  (pczOrder[iIndex].m_zOrder == lPrevOrNextZIndex)
            {
        
                if (nZIndexMode == SEND_BACKWARD)
                {
                    if ( (iIndex - 1) < 0)
                        // The element already has the lowest Z-order index
                        // so exit.
                        goto Cleanup;
                    else
                        iIndex--;  
                }
                else
                {
                    if ((iIndex + 1) == lIndexBuf)
                        // The element already has the highest Z-order index
                        // so exit.
                        goto Cleanup;
                    else
                        iIndex++;
                }

                hr = SetZIndex(pihtmlElement, pczOrder[iIndex].m_zOrder);
                _ASSERTE(SUCCEEDED(hr));
                    
                if (FAILED(hr))
                    goto Cleanup;
                    
                hr = SetZIndex(pczOrder[iIndex].m_pihtmlElement, lPrevOrNextZIndex);
                _ASSERTE(SUCCEEDED(hr));
                    
                if (FAILED(hr))
                    goto Cleanup;

                break;
            }

        }

    }
    else if((nZIndexMode == SEND_TO_BACK) || (nZIndexMode == SEND_FRONT_1D)) 
    {
        LONG lZIndex;
        LONG lminZIndex = pczOrder[0].m_zOrder;

        if (iIndex == 0) 
        {
            // We have no children with a positive Z-order index
            hr = SetZIndex(pihtmlElement, ZINDEX_BASE);
            goto Cleanup;
        }

        if (!fZIndexNegative)
        {
            // When we are dealing with elements with positive Z-order
            // index, we need to ensure that the minimum Z-order index
            // (to be assigned to the current element) should never become
            // less than or equal to 0. If so then propagate the
            // Z-order index starting from ZINDEX_BASE.

            if ((lminZIndex - 1) <= 0) 
            {
                hr = PropagateZIndex(pczOrder, iIndex);
    
                if (FAILED(hr))
                    goto Cleanup;
            }

            lminZIndex = pczOrder[0].m_zOrder;
        }

        if(SUCCEEDED(hr = GetZIndex(pihtmlElement, &lZIndex)))
        {
            if(lZIndex != lminZIndex)
            {
                // The current element is not the bottom most element
                hr = SetZIndex(pihtmlElement, lminZIndex - 1);
                _ASSERTE(SUCCEEDED(hr));
            }
        }
    }
       
    if (SUCCEEDED(hr))
    {
        RECT rcElement;

        if (SUCCEEDED(GetElementPosition(pihtmlElement, &rcElement)))
        {
             InflateRect(&rcElement, ELEMENT_GRAB_SIZE, ELEMENT_GRAB_SIZE);
             if( SUCCEEDED(GetTridentWindow()))
             {
                 _ASSERTE(m_hwndTrident);
                 InvalidateRect(m_hwndTrident,&rcElement, FALSE);
             }
        }
    }
       
Cleanup:

    if (pczOrder)
        delete [] pczOrder;
    SAFERELEASE(pihtmlElementTemp);
    SAFERELEASE(pihtmlElementParent);
    SAFERELEASE(pihtmlCollection);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::PropagateZIndex
//
// Set the Z-order index for each element in the given array. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::PropagateZIndex(CZOrder* pczOrder, LONG lZIndex, BOOL fZIndexNegative)
{
    HRESULT hr = S_OK; // init
    LONG lLoop;
    LONG lZOrder;

    // if fZIndexNegative is true means that we have a collection of
    // negative ZOrder elements and hence the initial ZOrder needs to
    // be ZINDEX_BASE + number of elments in the array.

    lZOrder = fZIndexNegative ? -(ZINDEX_BASE+lZIndex) : ZINDEX_BASE;

    for ( lLoop = 0; lLoop < lZIndex; lLoop++, lZOrder+=1)
    {
        hr = SetZIndex(pczOrder[lLoop].m_pihtmlElement, lZOrder);
        _ASSERTE(SUCCEEDED(hr));
    
        if (FAILED(hr))
            return hr;

        pczOrder[lLoop].m_zOrder = lZOrder;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\types\stub.cxx ===
#define _KERNEL32_
#include <w4warn.h>
#include <windows.h>
#include <w4warn.h>

// Hack to ensure pdlparse will build on pass0 of the NT build.
// Basically, no library can be referenced except msvcrt.lib because
// on a true clean build of NT, there are no libraries except the
// CRT's until after pass 1 is finished.

extern "C" void __stdcall Sleep(unsigned long) {}
extern "C" DWORD __stdcall GetVersion(void) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\athena.inc ===
#  ATHENA.INC
#
#  -- root include file for the athena project.  should be !included
#     before any macros are set, etc, with the exception of ATHROOT,
#     which is required here
#
#  History:
#     12-Oct-96  Created by Erik Neuenschwander (t-erikne)

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
!if $(WIN64)
WINVER_VERSION=0x0500
!else
WINVER_VERSION=0x0400
!endif

_WIN32_IE=0x560

LINK_LIB_IGNORE=4049,4217

#ALT_PROJECT_TARGET=athena
!if "$(BUILD_PRODUCT)" == "NT"
BINPLACE_PLACEFILE=$(ATHROOT)\ntplace.txt
!endif

# Root dir for WAB include paths
WABROOT=$(ATHROOT)\wabw

# Target platform for BBT'd binaries
BBT_TARGET=win95

# $(SHELL_INC_PATH) is needed for shlguidp.h
INCLUDES=$(ATHROOT)\public\inc;$(ATHROOT)\public\inc\$(O);$(ATHROOT)\external\inc;$(ATHROOT)\inc;$(ATHROOT)\inc\$(O);$(BASEDIR)\private\inc;$(SHELL_INC_PATH)

# treat warnings as errors
MSC_WARNING_LEVEL=/W3 /WX

# NOTE: the NT_BUILD below is a temp hack to allow old headers
# to function correctly with split windows headers

C_DEFINES=$(C_DEFINES) -DSTRICT -DNT_BUILD -DNASHVILLE -DUSE_MIRRORING

# Note this is only here so we can do OE5 Beta 2 coding  using the 
# iedev IE5 Beta 1 tree.  It will be removed after IE5 forks for Beta 1
# Disable Shell Debug macros as our names collide
C_DEFINES=$(C_DEFINES) -DOE5_BETA2 -DDONT_WANT_SHELLDEBUG -DHM_GROUP_SYNCING

# !if "$(SMIME)" == "V3"
# SMIME build is default build now
C_DEFINES=$(C_DEFINES) -DSMIME_V3 -DCMS_PKCS7 -DCMSG_ENVELOPED_ENCODE_INFO_HAS_CMS_FIELDS
SMIMEV3=1
# !endif

!ifdef ATHBROWSE
BROWSER_INFO=1
BSCMAKE_FLAGS=/n /nologo
!endif

!if !$(FREEBUILD)
!if defined(FULL_DEBUG)
LINKER_NOICF=1
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif
!endif

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

# Needed to prevent spurious BUILD warnings about missing include files
CONDITIONAL_INCLUDES=\
    winwlm.h    \
    macwin32.h  \
    macpub.h    \
    macapi.h    \
    macname1.h  \
    macname2.h  \
    macocidl.h  \
    rpcerr.h    \
    rpcmac.h    \
    events.h    \
    types.h     \
    macos\resource.h    \
    macos\dialogs.h     \
    macos\events.h      \
    macos\types.h       \
    fragload.h  \
    files.h     \
    osutils.h   \
    gestaltequ.h\
    errors.h    \
    aliases.h   \
    lowmem.h    \
    mimetype.h  \
    ver.h       \
    comctlie.h  \
    regmsg16.h  \
    win16x.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\types\makefile.inc ===
.SUFFIXES: .pdl .hdl .asc .nf

PERFFLAGS=

TOOLS_PLATFORM=

!if "$(PROCESSOR_ARCHITECTURE)" == "IA64"
TOOLS_PLATFORM=ia64
!else if "$(PROCESSOR_ARCHITECTURE)" == "AMD64"
TOOLS_PLATFORM=amd64
!else
TOOLS_PLATFORM=i386
!endif

!if $(IA64)
PDL_ARCH=win64
!else
PDL_ARCH=i386
!endif

PDLPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\pdlparse.exe
ASCPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\ascparse.exe
NFPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\nfparse.exe
TLDIFF=$(ROOT)\btools\bin\i386\tldiff.bat
TLVIEWER=$(ROOT)\btools\bin\i386\tlviewer.exe

{$(ROOT)\src\site\types}.pdl{$O}.pdl:
    copy $< $@

{$(ROOT)\src\other\htmldlg}.pdl{$O}.pdl:
    copy $< $@

{$(ROOT)\src\core\types}.pdl{$O}.pdl:
    copy $< $@

.pdl.hdl:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<< /Tc $< | $(PDLPARSE) <<
$(CPPXX: =
)
<<NOKEEP
- $(MAKEDIR)\$O\$(@B) $(@B).pdl $(MAKEDIR)\$O
<<NOKEEP
    -del $(MAKEDIR)\$(O)LOG

# Headers we need.

$O\versstr.h: $(ROOT)\src\f3\include\versstr.h
    copy $** $@

$O\f3ctx.h: $(ROOT)\external\inc\f3ctx.h
    copy $** $@

$O\coredisp.h: $(ROOT)\src\core\include\coredisp.h
    copy $** $@

$O\mshtmdid.h : $(DISPID_FILES)
    echo. >$O\mshtmdid.h
    !type $** >>$O\mshtmdid.h

$O\funcsig.cxx : $O\funcsig.dat
    echo Processing funcsig.dat...
    $(PDLPARSE) /G $(PDL_ARCH) $(O)

$O\mshtmtmp.idl : mshtmpre.idl $(IDL_FILES) mshtmpst.idl
    echo. >$O\mshtmtmp.idl
    !type $** >>$O\mshtmtmp.idl
    echo. >>$O\mshtmtmp.idl

$O\mshtml.idl : $O\mshtmtmp.idl $O\behavior.idl
    echo. >$O\mshtml.idl
    !type $** >>$O\mshtml.idl
    echo  } >>$O\mshtml.idl
    echo. >>$O\mshtml.idl

$(_NTBINDIR)\inetcore\published\inc\mshtml.idl : $O\mshtml.idl
!ifndef NOPASS0
    call comphtml $O\mshtml.idl $(_NTBINDIR)\inetcore\published\inc\mshtml.idl $O\mshtml_i.c $(_NTBINDIR)\inetcore\published\inc\$O\mshtml_i.c
!else
    @echo.
!endif

$O\mshtml.out: $O\mshtml.tlb
   $(TLVIEWER) $O\mshtml.tlb $O\mshtml.out
   -del /q tlviewer.o

$O\errors.out: $O\mshtml.out mshtml.ref
    !set CURFILE=$O\mshtml.out
    !set REFFILE=mshtml.ref
    !set OBJ_DIR=$(_OBJ_DIR)\$(TOOLS_PLATFORM)
    !set TLBNAME=mshtml.tlb
    !set BADTLBNAME=mshtml.bad
    !set BTOOLSBIN=$(ROOT)\btools\bin\i386
    $(TLDIFF)

$O\interned.idl : interpre.idl $O\internal.idl interpst.idl
    echo. >$O\interned.idl
    !type $** >>$O\interned.idl
    echo. >>$O\interned.idl

$(_NTBINDIR)\inetcore\published\inc\interned.idl : $O\interned.idl
!ifndef NOPASS0
    call comphtml $O\interned.idl $(_NTBINDIR)\inetcore\published\inc\interned.idl
!else
    @echo.
!endif

$(_NTBINDIR)\inetcore\published\inc\mshtmdid.h : $O\mshtmdid.h
!ifndef NOPASS0
    call comphtml $O\mshtmdid.h $(_NTBINDIR)\inetcore\published\inc\mshtmdid.h
!else
    @echo.
!endif

$O\mshtml.tlb : $O\mshtml.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\mshtml_p.c \
    -iid $O\mshtml_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\mshtml.h \
    -tlb $(O)\mshtml.tlb \
    $(C_DEFINES) \
    $(MIDL_OPTIMIZATION) \
    $O\mshtml.idl

!if [@mkdir $(_OBJ_DIR)]
!endif

!if [@mkdir $(O)]
!endif

$(HDL_FILES) : $(PDLPARSE)

{$(ROOT)\src\site\types}.asc{$O}.asc:
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP $< > $@

.asc.h:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    $(ASCPARSE) $< $@

$(HSC_FILES) : $(ASCPARSE)

{$(ROOT)\src\site\types}.nf{$O}.nf:
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP $< > $@

.nf.h:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    $(NFPARSE) $< $@

$(HNF_FILES) : $(NFPARSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\acctreg.h ===
#ifndef __ACCTREG_H
#define __ACCTREG_H

class CAcctReg :
    public IDispatch
{
public:
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    CAcctReg();
    ~CAcctReg();

private:
    ULONG       m_cRef;
};


#endif //__ACCTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\dllmain.h ===
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

extern ULONG       g_cRefDll;
extern HINSTANCE   g_hInst;

ULONG DllAddRef(void);
ULONG DllRelease(void);

#endif //__DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\acctreg.cpp ===
#include <windows.h>
#include <wininet.h>
#include <shlwapi.h>
#include <icwacct.h>
#include "dllmain.h"
#include "acctreg.h"

#define ARRAYSIZE(_exp_) (sizeof(_exp_) / sizeof(_exp_[0]))

CAcctReg::CAcctReg()
{
    m_cRef = 1;
    DllAddRef();
}


CAcctReg::~CAcctReg()
{
    DllRelease();
}

ULONG CAcctReg::AddRef(void)
{
    return ++m_cRef; 
}

ULONG CAcctReg::Release(void)
{ 
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CAcctReg::QueryInterface(REFIID riid, void **ppvObject)
{
    if(!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IDispatch))
        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CAcctReg::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CAcctReg::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CAcctReg::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    if (cNames == 1 && lstrcmpW(rgszNames[0], L"register") == 0)
        {
        rgdispid[0] = 666;  
        return S_OK;
        }

    return E_NOTIMPL;
}

HRESULT RegisterAccounts(LPSTR pszFile)
    {
    HRESULT hr;
    HINSTANCE hinst;
    HKEY hkey;
    char szDll[MAX_PATH], szExpand[MAX_PATH];
    LPSTR psz;
    DWORD cb, type;
    PFNCREATEACCOUNTSFROMFILE pfn;

    hr = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Account Manager", 0, KEY_QUERY_VALUE, &hkey))
        {
        cb = sizeof(szDll);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, "DllPath", NULL, &type, (LPBYTE)szDll, &cb))
            {
            if (type == REG_EXPAND_SZ)
                {
                ExpandEnvironmentStrings(szDll, szExpand, ARRAYSIZE(szExpand));
                psz = szExpand;
                }
            else
                {
                psz = szDll;
                }

            hinst = LoadLibrary(psz);
            if (hinst != NULL)
                {
                pfn = (PFNCREATEACCOUNTSFROMFILE)GetProcAddress(hinst, "CreateAccountsFromFile");
                if (pfn != NULL)
                    {
                    hr = pfn(pszFile, 0);
                    }

                FreeLibrary(hinst);
                }
            }

        RegCloseKey(hkey);
        }

    return(hr);
    }

#define CBBUFFER 1024

BOOL CreateLocalFile(HINTERNET hfile, LPCSTR pszFile)
    {
    BOOL fRet;
    HANDLE hfileLocal;
    LPBYTE pb;
    DWORD dw, dwT;

    fRet = FALSE;

    pb = (LPBYTE)malloc(CBBUFFER);
    if (pb != NULL)
        {
        hfileLocal = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hfileLocal != INVALID_HANDLE_VALUE)
            {
            while (InternetReadFile(hfile, pb, CBBUFFER, &dw))
                {
                if (dw == 0)
                    {
                    fRet = TRUE;
                    break;
                    }

                if (!WriteFile(hfileLocal, pb, dw, &dwT, NULL))
                    break;
                }

            CloseHandle(hfileLocal);

            if (!fRet)
                DeleteFile(pszFile);
            }

        free(pb);
        }

    return(fRet);
    }

HRESULT CAcctReg::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;
    HINTERNET hnet, hfile;
    LPSTR pszSrc, pszFile;
    char szPath[MAX_PATH], szDest[MAX_PATH];
    int cch;
    DWORD dw;

    if (dispidMember == 666 &&
        pdispparams->cArgs == 1 &&
        pdispparams->rgvarg[0].vt == VT_BSTR &&
        pdispparams->rgvarg[0].bstrVal)
        {
        hr = E_FAIL;

        cch = WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].bstrVal, -1, NULL, 0, NULL, NULL);
        cch++;
        pszSrc = (LPSTR)malloc(cch);
        if (pszSrc != NULL)
            {
            WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].bstrVal, -1, pszSrc, cch, NULL, NULL);

            if (GetTempPath(sizeof(szPath), szPath) &&
                GetTempFileName(szPath, "ins", 0, szDest) != 0)
                {
                hnet = InternetOpen("Outlook Express", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
                if (hnet != NULL)
                    {
                    hfile = InternetOpenUrl(hnet, pszSrc, NULL, 0, INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0);
                    if (hfile != NULL)
                        {
                        if (CreateLocalFile(hfile, szDest))
                            {
                            hr = RegisterAccounts(szDest);
                            DeleteFile(szDest);
                            }

                        InternetCloseHandle(hfile);
                        }

                    InternetCloseHandle(hnet);
                    }
                }

            free(pszSrc);
            }

        return(S_OK);
        }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// --------------------------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include "dllmain.h"
#include "acctreg.h"
#include "guids.h"

////////////////////////////////////////////////////////////////////////
//
//  IClassFactory implementation
//
////////////////////////////////////////////////////////////////////////
class CClassFactory : public IClassFactory
{
public:
    CClassFactory(REFCLSID clsid) : m_cRef(1), m_clsid(clsid) { DllAddRef(); }
    ~CClassFactory() { DllRelease(); }

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IClassFactory
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *punkOuter, REFIID riid, LPVOID *ppv);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

private:
    UINT    m_cRef;
    CLSID   m_clsid;
};


HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    if (!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
        {
        *ppvObject = (IClassFactory *)this;
        }
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CClassFactory::AddRef(void)
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CClassFactory::Release(void)
{
    if (--m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, LPVOID *ppv)
{
    HRESULT     hr;

    if (!ppv)
        return E_INVALIDARG;

    *ppv = NULL;  // assume error

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;       // don't support aggregation


    if (IsEqualCLSID(m_clsid, CLSID_AcctReg))
        {
        // make sure we're the IMsgBox class factory
        CAcctReg *pAcctReg;

        if (pAcctReg = new CAcctReg())
            {
            hr = pAcctReg->QueryInterface(riid, ppv);
            // Note that the Release member will free the object, if QueryInterface
            // failed.
            pAcctReg->Release();
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    return hr;
}

HRESULT STDMETHODCALLTYPE CClassFactory::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}




// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    HRESULT     hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    if (IsEqualCLSID(rclsid, CLSID_AcctReg))
        {
        // caller want the class factory that can handout msgbox
        // objects...
        CClassFactory *pcf = new CClassFactory(rclsid);
        
        if (pcf)
            {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
            }
        else
            hr = E_OUTOFMEMORY;    
        }
    else
        hr = CLASS_E_CLASSNOTAVAILABLE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\guids.h ===
#ifndef __GUIDS_H
#define __GUIDS_H

// {FBABBCE1-DEFB-11d1-AAA0-006097D474C4}
DEFINE_GUID(CLSID_AcctReg, 0xfbabbce1, 0xdefb, 0x11d1, 0xaa, 0xa0, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

#endif //__GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\dllmain.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <advpub.h>
#include "dllmain.h"
#include "acctreg.h"

#define ARRAYSIZE(_exp_) (sizeof(_exp_) / sizeof(_exp_[0]))

CRITICAL_SECTION    g_csDllMain={0};

ULONG               g_cRefDll=0;
HINSTANCE           g_hInst=NULL;


void InitGlobalVars(void)
{
    InitializeCriticalSection(&g_csDllMain);
}

void FreeGlobalVars(void)
{
    DeleteCriticalSection(&g_csDllMain);
}

 
// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    // Set global instance handle
	    g_hInst = hInst;

		// Initialize Global Variables
		InitGlobalVars();

        // we don't care about thread-attach notifications, so
        // diable them, This is mondo-more efficient for creating
        // threads
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
		FreeGlobalVars();
	    break;
    }
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&g_cRefDll);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement((LPLONG)&g_cRefDll);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// 
// Ole will hit this now and again to see if it can free up our library
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
    
    EnterCriticalSection(&g_csDllMain);
    hr = g_cRefDll ? S_FALSE : S_OK;
    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb)
{
    LPVOID  lpv;

    lpv = malloc(cb);

    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
void __cdecl operator delete(LPVOID pv)
{
    free(pv);
}

HRESULT CallRegInstall(HINSTANCE hInst, LPCSTR pszSection)
{    
    HRESULT     hr = E_FAIL;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szDll[MAX_PATH];
    int         cch;
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    OSVERSIONINFO verinfo;        // Version Check

    hAdvPack = LoadLibraryA("advpack.dll");
    if (NULL == hAdvPack)
        return(E_FAIL);

    // Get our location
    GetModuleFileName(hInst, szDll, ARRAYSIZE(szDll));

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
        goto exit;

    // Setup special registration stuff
    // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
    stReg.cEntries = 0;
    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
    seReg[stReg.cEntries].pszValue = szDll;
    stReg.cEntries++;    
    stReg.pse = seReg;

    // Call the self-reg routine
    hr = pfnri(hInst, pszSection, &stReg);

exit:
    // Cleanup
    FreeLibrary(hAdvPack);

    return(hr);
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // Register my self
    hr = CallRegInstall(g_hInst, "Reg");

    return(hr);
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(g_hInst, "UnReg");

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctres\res.inc ===
ATHROOT=..
R=$(ATHROOT)\mailnews
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_MSOEAPI_ -D_WINDLL
WIN32_IE_VERSION=0x0500

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\msoeres; \
    $(R)\inc; \
    $(R)\common; \
    $(R)\shell; \
    $(R)\objectdb; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\rules; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\view; \
    $(R)\imap; \
    $(R)\bactrl; \
    $(R)\extinc; \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common; \
    $(BASEDIR)\public\sdk\inc\atl21; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctreg\initguid.cpp ===
#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include "guids.h"

// we need to get the variables for the CLSID_ and IID_ compiled into our datasegment.
// we include initguid.h which defines a preprocessor variable which when it loads imsgbox.h
// will unwrap the DEFINE_GUID macro such that the variables are declared.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\acctres\makefile.inc ===
ATHENA_RC_DEPENDS = server.dlg	    \
		    wizard.dlg	    \
		    folders.bmp     \
		    globe.bmp	    \
		    icw.bmp	    \
		    wizard.bmp	    \
		    ldap2.ico	    \
		    mailsvr.ico     \
		    ..\msoeacct\resource.h

$O\msoeres.res : $(ATHENA_RC_DEPENDS)

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\autodiscbase.cpp ===
/*****************************************************************************\
    FILE: AutoDiscBase.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include <crypto\md5.h>

#include "AutoDiscover.h"
#include "INStoXML.h"


//#define SZ_WININET_AGENT_AUTO_DISCOVER      TEXT("Microsoft(r) Windows(tm) Account AutoDiscovery Agent")
#define SZ_WININET_AGENT_AUTO_DISCOVER      TEXT("Mozilla/4.0 (compatible; MSIE.5.01; Windows.NT.5.0)")

// BUGBUG: Ditch default.asp
#define SZ_ADSERVER_XMLFILE                    "/AutoDiscover/default.xml"

#define SZ_PATH_AUTODISCOVERY       L"AutoDiscovery"
#define SZ_FILEEXTENSION            L".xml"
#define SZ_TEMPEXTENSION            L".tmp"


// this is how long we wait for the UI thread to create the progress hwnd before giving up
#define WAIT_AUTODISCOVERY_STARTUP_HWND 10*1000 // ten seconds

// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601
#define SECONDS_IN_ONE_DAY         (60/*seconds*/ * 60/*minutes*/ * 24/*hrs*/)                                    

//===========================
// *** Class Internals & Helpers ***
//===========================

HRESULT GetTempPathHr(IN DWORD cchSize, IN LPTSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD cchSizeNeeded = GetTempPath(cchSize, pszPath);

    if ((0 == cchSizeNeeded) || (cchSizeNeeded > cchSize))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT GetTempFileNameHr(IN LPCTSTR lpPathName, IN LPCTSTR lpPrefixString, IN UINT uUnique, IN LPTSTR lpTempFileName)
{
    if (0 == GetTempFileName(lpPathName, lpPrefixString, uUnique, lpTempFileName))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


HRESULT CreateXMLTempFile(IN BSTR bstrXML, IN LPTSTR pszPath, IN DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];
    HRESULT hr = GetTempPathHr(ARRAYSIZE(szTemp), szTemp);

    AssertMsg((MAX_PATH <= cchSize), "You need to be at least MAX_PATH.  Required by GetTempFileName()");
    if (SUCCEEDED(hr))
    {
        hr = GetTempFileNameHr(szTemp, TEXT("AD_"), 0, pszPath);
        if (SUCCEEDED(hr))
        {
            HANDLE hFile;

            hr = CreateFileHrWrap(pszPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);
            if (SUCCEEDED(hr))
            {
                LPSTR pszAnsiXML = AllocStringFromBStr(bstrXML);
                if (pszAnsiXML)
                {
                    DWORD cchWritten;

                    hr = WriteFileWrap(hFile, pszAnsiXML, (lstrlenA(pszAnsiXML) + 1), &cchWritten, NULL);
                    LocalFree(pszAnsiXML);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                CloseHandle(hFile);
            }

            if (FAILED(hr))
            {
                DeleteFile(pszPath);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will see if pbstrXML is valid AutoDiscovery XML or is 
    in the .INS/.ISP format that can be converted to valid XML.  It will then look
    for a redirect URL and return on if one exists.
\*****************************************************************************/
HRESULT CAccountDiscoveryBase::_VerifyValidXMLResponse(IN BSTR * pbstrXML, IN LPWSTR pszRedirURL, IN DWORD cchSize)
{
    IXMLDOMDocument * pXMLDOMDoc;
    bool fConverted = false;
    HRESULT hr = XMLDOMFromBStr(*pbstrXML, &pXMLDOMDoc);
    TCHAR szPath[MAX_PATH];

    pszRedirURL[0] = 0;
    if (FAILED(hr))
    {
        // It may have failed if it was an .INS or .ISP formatted
        // file.  Since we need to be compatible with these
        // file formats, check for it and convert it if it
        // is in that format.
        hr = CreateXMLTempFile(*pbstrXML, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            fConverted = true;
            if (IsINSFile(szPath))
            {
                hr = ConvertINSToXML(szPath);
                if (SUCCEEDED(hr))
                {
                    hr = XMLDOMFromFile(szPath, &pXMLDOMDoc);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IXMLDOMElement * pXMLElementMessage = NULL;

        hr = pXMLDOMDoc->get_documentElement(&pXMLElementMessage);
        if (S_FALSE == hr)
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        else if (SUCCEEDED(hr))
        {
            // This is only valid XML if the root tag is "AUTODISCOVERY".
            // The case is not important.
            hr = XMLElem_VerifyTagName(pXMLElementMessage, SZ_XMLELEMENT_AUTODISCOVERY);
            if (SUCCEEDED(hr))
            {
                // Now we are in search for a redirect URL.
                IXMLDOMNode * pXMLReponse;

                // Enter the <RESPONSE> tag.
                if (SUCCEEDED(XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_RESPONSE, &pXMLReponse)))
                {
                    IXMLDOMElement * pXMLElementMessage;

                    if (SUCCEEDED(pXMLReponse->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElementMessage))))
                    {
                        IXMLDOMNodeList * pNodeListAccounts;

                        // Iterate thru the list of <ACCOUNT> tags...
                        if (SUCCEEDED(XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_ACCOUNT, &pNodeListAccounts)))
                        {
                            DWORD dwIndex = 0;
                            IXMLDOMNode * pXMLNodeAccount = NULL;

                            // We are going to look thru each one for one of them with <TYPE>email</TYPE>
                            while (S_OK == XMLNodeList_GetChild(pNodeListAccounts, dwIndex, &pXMLNodeAccount))
                            {
                                // FUTURE: We could support redirects or error messages here depending on
                                //       <ACTION> redirect | message </ACTION>
                                if (XML_IsChildTagTextEqual(pXMLNodeAccount, SZ_XMLELEMENT_TYPE, SZ_XMLTEXT_EMAIL) &&
                                    XML_IsChildTagTextEqual(pXMLNodeAccount, SZ_XMLELEMENT_ACTION, SZ_XMLTEXT_REDIRECT))
                                {
                                    CComBSTR bstrRedirURL;

                                    // This file may or may not settings to contact the server.  However in either case
                                    // it may contain an INFOURL tag.  If it does, then the URL in side will point to a 
                                    // web page.
                                    // <INFOURL> xxx </INFOURL>
                                    if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLNodeAccount, SZ_XMLELEMENT_REDIRURL, &bstrRedirURL)))
                                    {
                                        StrCpyNW(pszRedirURL, bstrRedirURL, cchSize);
                                        break;
                                    }
                                }

                                // No, so keep looking.
                                ATOMICRELEASE(pXMLNodeAccount);
                                dwIndex++;
                            }

                            ATOMICRELEASE(pXMLNodeAccount);
                            pNodeListAccounts->Release();
                        }

                        pXMLElementMessage->Release();
                    }

                    pXMLReponse->Release();
                }
            }

            pXMLElementMessage->Release();
        }

        if (true == fConverted)
        {
            if (SUCCEEDED(hr))
            {
                // It only succeeded after the conversion, so we need to move the
                // XML from the temp file to pbstrXML.
                SysFreeString(*pbstrXML);
                *pbstrXML = NULL;

                hr = XMLBStrFromDOM(pXMLDOMDoc, pbstrXML);
            }
        }

        pXMLDOMDoc->Release();
    }

    if (true == fConverted)
    {
        DeleteFile(szPath);
    }

    return hr;
}


typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibraryA(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCEA(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_NO_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileNameA(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        if (PathRemoveFileSpecA(szPath) && PathAppendA(szPath, szDllName))
        {
            hInst = LoadLibraryA(szPath);
        }
    }

    return hInst;
}


#define SZ_DLL_OE_ACCTRES_DLL           "acctres.dll"
HRESULT CAccountDiscoveryBase::_SendStatusMessage(UINT nStringID, LPCWSTR pwzArg)
{
    HRESULT hr = S_OK;

    if (m_hwndAsync && IsWindow(m_hwndAsync))
    {
        WCHAR szMessage[MAX_URL_STRING*3];
        WCHAR szTemplate[MAX_URL_STRING*3];

        // Our DLL has these message.
        LoadString(HINST_THISDLL, nStringID, szTemplate, ARRAYSIZE(szTemplate));

        HINSTANCE hInstOE = LoadLangDll(GetModuleHandleA(NULL), SZ_DLL_OE_ACCTRES_DLL, IsOSNT());
        if (hInstOE)
        {
            // We prefer to get the string from OE because it will be localized based on the installed
            // language.
            LoadString(hInstOE, nStringID, szTemplate, ARRAYSIZE(szTemplate));
            FreeLibrary(hInstOE);
        }

        if (pwzArg)
        {
            wnsprintfW(szMessage, ARRAYSIZE(szMessage), szTemplate, pwzArg);
        }
        else
        {
            StrCpyN(szMessage, szTemplate, ARRAYSIZE(szMessage));
        }

        DWORD cchSize = (lstrlenW(szMessage) + 1);
        LPWSTR pszString = (LPWSTR) LocalAlloc(LPTR, cchSize * sizeof(szMessage[0]));
        if (pszString)
        {
            StrCpyN(pszString, szMessage, cchSize);
            PostMessage(m_hwndAsync, (m_wMsgAsync + 1), (WPARAM)pszString, (LPARAM)0);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_UrlToComponents(IN LPCWSTR pszURL, IN BOOL * pfHTTPS, IN LPWSTR pszDomain, IN DWORD cchSize, IN LPSTR pszURLPath, IN DWORD cchSizeURLPath)
{
    HRESULT hr = S_OK;
    WCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    WCHAR szURLPath[INTERNET_MAX_PATH_LENGTH];
    URL_COMPONENTS urlComponents = {0};

    urlComponents.dwStructSize = sizeof(urlComponents);
    urlComponents.lpszScheme = szScheme;
    urlComponents.dwSchemeLength = ARRAYSIZE(szScheme);
    urlComponents.lpszHostName = pszDomain;
    urlComponents.dwHostNameLength = cchSize;
    urlComponents.lpszUrlPath = szURLPath;
    urlComponents.dwUrlPathLength = ARRAYSIZE(szURLPath);

    *pfHTTPS = ((INTERNET_SCHEME_HTTPS == urlComponents.nScheme) ? TRUE : FALSE);
    if (!InternetCrackUrlW(pszURL, 0, 0, &urlComponents))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        SHUnicodeToAnsi(szURLPath, pszURLPath, cchSizeURLPath);
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_GetInfoFromDomain(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BOOL fHTTPS, IN BOOL fPost, IN LPCSTR pszURLPath, OUT BSTR * pbstrXML)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD cbToSend = (lstrlenW(bstrXMLRequest));
    LPSTR pszPostData = (LPSTR) LocalAlloc(LPTR, (cbToSend + 1) * sizeof(bstrXMLRequest[0]));
    TCHAR szRedirectURL[MAX_URL_STRING];

    szRedirectURL[0] = 0;
    if (pszPostData)
    {
        HINTERNET hInternetHTTPConnect = NULL;

        SHUnicodeToAnsi(bstrXMLRequest, pszPostData, (cbToSend + 1));
        _SendStatusMessage(IDS_STATUS_CONNECTING_TO, pwzDomain);

        // We may want to use INTERNET_FLAG_KEEP_CONNECTION.
        hr = InternetConnectWrap(m_hInternetSession, FALSE, pwzDomain, (fHTTPS ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT),
                            NULL, NULL, INTERNET_SERVICE_HTTP, 0, NULL, &hInternetHTTPConnect);
        if (SUCCEEDED(hr))
        {
            HINTERNET hInternetHTTPRequest = NULL;
            DWORD cbBytesRead;

            // NOTE: The web server may want to redirect to an https URL for additional security.
            //       We need to pass the INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS to HttpOpenRequest
            //       or HttpSendRequest() will fail with ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR

            // NOTE: We may need to split the URL into lpszReferer + lpszObjectName.
            hr = HttpOpenRequestWrap(hInternetHTTPConnect, (fPost ? SZ_HTTP_VERB_POST : NULL), pszURLPath, HTTP_VERSIONA, 
                        /*pszReferer*/ NULL, NULL, INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS, NULL, &cbBytesRead, &hInternetHTTPRequest);
            if (SUCCEEDED(hr))
            {
                hr = HttpSendRequestWrap(hInternetHTTPRequest, NULL,  0, (fPost ? pszPostData : NULL), (fPost ? cbToSend : 0));
                if (SUCCEEDED(hr))
                {
                    _SendStatusMessage(IDS_STATUS_DOWNLOADING, pwzDomain);
                    hr = InternetReadIntoBSTR(hInternetHTTPRequest, pbstrXML);
                    if (SUCCEEDED(hr))
                    {
                        hr = _VerifyValidXMLResponse(pbstrXML, szRedirectURL, ARRAYSIZE(szRedirectURL));
                        if (FAILED(hr))
                        {
                            SysFreeString(*pbstrXML);
                            *pbstrXML = NULL;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = InternetCloseHandleWrap(hInternetHTTPRequest);
                    }
                    else
                    {
                        InternetCloseHandleWrap(hInternetHTTPRequest);
                    }
                }

                InternetCloseHandleWrap(hInternetHTTPRequest);
            }

            InternetCloseHandleWrap(hInternetHTTPConnect);
        }

        LocalFree(pszPostData);
    }

    // Did the caller want to redirect to another server?
    if (szRedirectURL[0])
    {
        // Yes, so do that now via recursion.
        WCHAR szDomain[INTERNET_MAX_HOST_NAME_LENGTH];
        CHAR szURLPath[INTERNET_MAX_PATH_LENGTH];

        SysFreeString(*pbstrXML);
        *pbstrXML = NULL;

        hr = _UrlToComponents(szRedirectURL, &fHTTPS, szDomain, ARRAYSIZE(szDomain), szURLPath, ARRAYSIZE(szURLPath));
        if (SUCCEEDED(hr))
        {
            hr = _GetInfoFromDomain(bstrXMLRequest, bstrEmail, szDomain, fHTTPS, TRUE, szURLPath, pbstrXML);
        }
    }

    return hr;
}


#define SZ_XML_NOTFOUNDRESULTS              L"<?xml version=\"1.0\"?><AUTODISCOVERY><NOFOUND /></AUTODISCOVERY>"

HRESULT CAccountDiscoveryBase::_GetInfoFromDomainWithSubdirAndCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags, IN LPCSTR pszURLPath)
{
    HRESULT hr;
    WCHAR wzCacheURL[INTERNET_MAX_HOST_NAME_LENGTH];

    if (dwFlags & ADDN_SKIP_CACHEDRESULTS)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = _CheckInCacheAndAddHash(pwzDomain, bstrEmail, pszURLPath, wzCacheURL, ARRAYSIZE(wzCacheURL), bstrXMLRequest, pbstrXML);
    }

    if (FAILED(hr))
    {
        hr = _GetInfoFromDomain(bstrXMLRequest, bstrEmail, pwzDomain, FALSE, FALSE, pszURLPath, pbstrXML);
        if (SUCCEEDED(hr))
        {
            // Put the data into the cache for the next time.
            _CacheResults(wzCacheURL, *pbstrXML);
        }
        else
        {
            // We want to make a blank entry so we don't keep hitting the server
            _CacheResults(wzCacheURL, SZ_XML_NOTFOUNDRESULTS);
        }
    }

    // Did we find a blank entry?
    if (SUCCEEDED(hr) && pbstrXML && *pbstrXML && !StrCmpIW(*pbstrXML, SZ_XML_NOTFOUNDRESULTS))
    {
        // Yes, so we didn't get a successful results, so fail.
        // This way we will try other sources.
        hr = E_FAIL;
        SysFreeString(*pbstrXML);
        *pbstrXML = NULL;
    }

    return hr;
}


BOOL IsExpired(FILETIME ftExpireTime)
{
    BOOL fIsExpired = TRUE;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &ftCurrentTime);

    // It is not expired if the current time is before the expired time.
    if (-1 == CompareFileTime(&ftCurrentTime, &ftExpireTime))
    {
        fIsExpired = FALSE;
    }

    return fIsExpired;
}


#define SZ_HASHSTR_HEADER               L"MD5"
HRESULT GenerateHashStr(IN LPCWSTR pwzHashData, IN LPWSTR pwzHashStr, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    MD5_CTX md5;
    DWORD * pdwHashChunk = (DWORD *)&md5.digest;

    MD5Init(&md5);
    MD5Update(&md5, (const unsigned char *) pwzHashData, (lstrlenW(pwzHashData) * sizeof(OLECHAR)));
    MD5Final(&md5);

    StrCpyNW(pwzHashStr, SZ_HASHSTR_HEADER, cchSize);

    // Break the hash into 64 bit chunks and turn them into strings.
    // pwzHashStr will then contain the header and each chunk concatinated.
    for (int nIndex = 0; nIndex < (sizeof(md5.digest) / sizeof(*pdwHashChunk)); nIndex++)
    {
        WCHAR szNumber[MAX_PATH];
        
        wnsprintfW(szNumber, ARRAYSIZE(szNumber), L"%08lX", pdwHashChunk[nIndex]);
        StrCatBuffW(pwzHashStr, szNumber, cchSize);
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_CheckInCacheAndAddHash(IN LPCWSTR pwzDomain, IN BSTR bstrEmail, IN LPCSTR pszSubdir, IN LPWSTR pwzCacheURL, IN DWORD cchSize, IN BSTR bstrXMLRequest, OUT BSTR * pbstrXML)
{
    WCHAR szHash[MAX_PATH];

    // We add the MD5 of the XML request to the URL so that the different XML requests to the
    // same server are cached separately
    GenerateHashStr(bstrXMLRequest, szHash, ARRAYSIZE(szHash));
    wnsprintfW(pwzCacheURL, cchSize, L"http://%ls.%ls%hs/%ls.xml", szHash, pwzDomain, pszSubdir, bstrEmail);

    return _CheckInCache(pwzCacheURL, pbstrXML);
}


HRESULT CAccountDiscoveryBase::_CheckInCache(IN LPWSTR pwzCacheURL, OUT BSTR * pbstrXML)
{
    HINTERNET hOpenUrlSession;
    DWORD cbSize = (sizeof(INTERNET_CACHE_ENTRY_INFO) + 4048);
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, cbSize);
    HRESULT hr = E_FAIL;

    if (lpCacheEntryInfo)
    {
        // HACKHACK: I wish InternetOpenUrlWrap() would respect the INTERNET_FLAG_FROM_CACHE flag but
        //   it doesn't.  Therefore I call GetUrlCacheEntryInfo() to check and check the expired
        //   myself.
        lpCacheEntryInfo->dwStructSize = cbSize;
        if (GetUrlCacheEntryInfo(pwzCacheURL, lpCacheEntryInfo, &cbSize))
        {
            if (!IsExpired(lpCacheEntryInfo->ExpireTime))
            {
                hr = InternetOpenUrlWrap(m_hInternetSession, pwzCacheURL, NULL, 0, INTERNET_FLAG_FROM_CACHE, NULL, &hOpenUrlSession);
                if (SUCCEEDED(hr))
                {
                    hr = InternetReadIntoBSTR(hOpenUrlSession, pbstrXML);
                    InternetCloseHandleWrap(hOpenUrlSession);
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        LocalFree(lpCacheEntryInfo);
    }

    return hr;
}


#define AUTODISC_EXPIRE_TIME        7 /*days*/

HRESULT GetModifiedAndExpiredDates(IN FILETIME * pftExpireTime, IN FILETIME * pftLastModifiedTime)
{
    SYSTEMTIME stCurrentUTC;
    ULARGE_INTEGER uliTimeMath;
    ULARGE_INTEGER uliExpireTime;

    GetSystemTime(&stCurrentUTC);
    SystemTimeToFileTime(&stCurrentUTC, pftLastModifiedTime);

    *pftExpireTime = *pftLastModifiedTime;
    uliTimeMath.HighPart = pftExpireTime->dwHighDateTime;
    uliTimeMath.LowPart = pftExpireTime->dwLowDateTime;

    uliExpireTime.QuadPart = 1000000; // One Second; 
    uliExpireTime.QuadPart *= (SECONDS_IN_ONE_DAY * AUTODISC_EXPIRE_TIME);

    uliTimeMath.QuadPart += uliExpireTime.QuadPart;
    pftExpireTime->dwHighDateTime = uliTimeMath.HighPart;
    pftExpireTime->dwLowDateTime = uliTimeMath.LowPart;

    return S_OK;
}


HRESULT CAccountDiscoveryBase::_CacheResults(IN LPCWSTR pwzCacheURL, IN BSTR bstrXML)
{
    HRESULT hr = S_OK;
    WCHAR wzPath[MAX_PATH];

    hr = CreateUrlCacheEntryWrap(pwzCacheURL, (lstrlenW(bstrXML) + 1), L"xml", wzPath, 0);
    if (SUCCEEDED(hr))
    {
        HANDLE hFile;

        hr = CreateFileHrWrap(wzPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);
        if (SUCCEEDED(hr))
        {
            LPSTR pszAnsiXML = AllocStringFromBStr(bstrXML);
            if (pszAnsiXML)
            {
                DWORD cchWritten;

                hr = WriteFileWrap(hFile, pszAnsiXML, (lstrlenA(pszAnsiXML) + 1), &cchWritten, NULL);
                LocalFree(pszAnsiXML);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            CloseHandle(hFile);
            if (SUCCEEDED(hr))
            {
                FILETIME ftExpireTime;
                FILETIME ftLastModifiedTime;

                GetModifiedAndExpiredDates(&ftExpireTime, &ftLastModifiedTime);
                hr = CommitUrlCacheEntryWrap(pwzCacheURL, wzPath, ftExpireTime, ftLastModifiedTime, NORMAL_CACHE_ENTRY, NULL, 0, NULL, pwzCacheURL);
            }
        }
    }

    return hr;
}


LPCWSTR _GetNextDomain(IN LPCWSTR pwszDomain)
{
    LPCWSTR pwzNext = NULL;
    
    pwszDomain = StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR);
    if (pwszDomain) // We did find the next one.
    {
        pwszDomain = CharNext(pwszDomain);  // Skip past '.'

        if (StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR)) // is this the primary domain "com"?
        {
            // No, so that's good. Because we can't search for JoeUser@com.
            pwzNext = pwszDomain;
        }
    }

    return pwzNext;
}


#define SZ_HTTP_SCHEME              L"http://"
HRESULT GetDomainFromURL(IN LPCWSTR pwzURL, IN LPWSTR pwzDomain, IN int cchSize)
{
    StrCpyNW(pwzDomain, pwzURL, cchSize);

    if (!StrCmpNIW(SZ_HTTP_SCHEME, pwzDomain, (ARRAYSIZE(SZ_HTTP_SCHEME) - 1)))
    {
        StrCpyNW(pwzDomain, &pwzURL[(ARRAYSIZE(SZ_HTTP_SCHEME) - 1)], cchSize);

        LPWSTR pszRemovePath = StrChrW(pwzDomain, L'/');
        if (pszRemovePath)
        {
            pszRemovePath[0] = 0;
        }
    }

    return S_OK;
}


HRESULT CAccountDiscoveryBase::_UseOptimizedService(IN LPCWSTR pwzServiceURL, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags)
{
    WCHAR szURL[MAX_URL_STRING];
    HINTERNET hOpenUrlSession;

    wnsprintfW(szURL, ARRAYSIZE(szURL), L"%lsDomain=%ls", pwzServiceURL, pwzDomain);

    HRESULT hr = _CheckInCache(szURL, pbstrXML);
    if (FAILED(hr))
    {
        WCHAR szDomain[MAX_PATH];

        if (SUCCEEDED(GetDomainFromURL(szURL, szDomain, ARRAYSIZE(szDomain))))
        {
            _SendStatusMessage(IDS_STATUS_CONNECTING_TO, szDomain);
        }

        // NOTE: The web server may want to redirect to an https URL for additional security.
        //       We need to pass the INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS to HttpOpenRequest
        //       or HttpSendRequest() will fail with ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR

        // INTERNET_FLAG_IGNORE_CERT_CN_INVALID is another option we may want to use.
        hr = InternetOpenUrlWrap(m_hInternetSession, szURL, NULL, 0, INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS, NULL, &hOpenUrlSession);
        if (SUCCEEDED(hr))
        {
            hr = InternetReadIntoBSTR(hOpenUrlSession, pbstrXML);
            if (SUCCEEDED(hr))
            {
                DWORD cbSize = (sizeof(INTERNET_CACHE_ENTRY_INFO) + 4048);
                LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, cbSize);
                HRESULT hr = E_FAIL;

                if (lpCacheEntryInfo)
                {
                    lpCacheEntryInfo->dwStructSize = cbSize;
                    if (GetUrlCacheEntryInfo(szURL, lpCacheEntryInfo, &cbSize))
                    {
                        lpCacheEntryInfo->CacheEntryType |= CACHE_ENTRY_EXPTIME_FC;
                        GetModifiedAndExpiredDates(&(lpCacheEntryInfo->ExpireTime), &(lpCacheEntryInfo->LastModifiedTime));
                        SetUrlCacheEntryInfo(szURL, lpCacheEntryInfo, (CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC));
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    LocalFree(lpCacheEntryInfo);
                }
            }
            InternetCloseHandleWrap(hOpenUrlSession);
        }
    }

    return hr;
}


// We turn this off because JoshCo said that it would make
// it hard to turn it into an international standard.
// There are cases where user@organization.co.uk may trust
// organization.co.uk but not co.uk.
//#define FEATURE_WALK_UP_DOMAIN

HRESULT CAccountDiscoveryBase::_GetInfo(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN BSTR * pbstrXML, IN DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;
    LPCWSTR pwszDomain = StrChrW(bstrEmail, CH_EMAIL_AT);

    if (pwszDomain)
    {
        pwszDomain = CharNext(pwszDomain);  // Skip past the '@'
        IAutoDiscoveryProvider * pProviders;

        hr = _getPrimaryProviders(bstrEmail, &pProviders);
        if (SUCCEEDED(hr))
        {
            long nTotal = 0;
            VARIANT varIndex;
        
            varIndex.vt = VT_I4;

            hr = pProviders->get_length(&nTotal);
            hr = E_FAIL;
            for (varIndex.lVal = 0; FAILED(hr) && (varIndex.lVal < nTotal); varIndex.lVal++)
            {
                CComBSTR bstrDomain;

                hr = pProviders->get_item(varIndex, &bstrDomain);
                if (SUCCEEDED(hr))
                {
                    hr = _GetInfoFromDomainWithSubdirAndCacheCheck(bstrXMLRequest, bstrEmail, bstrDomain, pbstrXML, dwFlags, SZ_ADSERVER_XMLFILE);
                }
            }

            pProviders->Release();
        }

        // Do we still need to find the settings and should we fall back
        // to trying public internet servers that can try to find the email mappings?
        // We also only want to try one of the public servers if the domain is not an internet
        // domain because we don't want to send intranet email server names outside of
        // the corp-net to public servers.  We detect intranet type servers by the lack
        // of a 'period' in the name.  For Example: JustUser@internetemailserver vs
        // JoeUser@theISP.com.
        if (FAILED(hr) && (ADDN_CONFIGURE_EMAIL_FALLBACK & dwFlags) &&
            (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_TEST_INTRANETS, FALSE, /*default:*/FALSE) ||
                StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR)))
        {
            hr = _getSecondaryProviders(bstrEmail, &pProviders, dwFlags);
            if (SUCCEEDED(hr))
            {
                long nTotal = 0;
                VARIANT varIndex;
        
                varIndex.vt = VT_I4;

                hr = pProviders->get_length(&nTotal);
                hr = E_FAIL;
                for (varIndex.lVal = 0; FAILED(hr) && (varIndex.lVal < nTotal); varIndex.lVal++)
                {
                    CComBSTR bstrURL;

                    hr = pProviders->get_item(varIndex, &bstrURL);
                    if (SUCCEEDED(hr))
                    {
                        hr = _UseOptimizedService(bstrURL, pwszDomain, pbstrXML, dwFlags);
                    }
                }

                pProviders->Release();
            }
        }
    }

    return hr;
}


// We turn this off because JoshCo said that it would make
// it hard to turn it into an international standard.
// There are cases where user@organization.co.uk may trust
// organization.co.uk but not co.uk.
//#define FEATURE_WALK_UP_DOMAIN

HRESULT CAccountDiscoveryBase::_getPrimaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    HRESULT hr = E_INVALIDARG;

    if (ppProviders)
    {
        *ppProviders = NULL;
        if (!m_hdpaPrimary && pwzEmailAddress)
        {
            LPCWSTR pwszDomain = StrChrW(pwzEmailAddress, CH_EMAIL_AT);
            if (pwszDomain)
            {
                pwszDomain = CharNext(pwszDomain);  // Skip past the "@"
                if (pwszDomain[0])
                {
                    // While we still have a domain and it's at least a second level domain...
                    if (pwszDomain)
                    {
                        WCHAR wzDomain[INTERNET_MAX_HOST_NAME_LENGTH];

                        // First we try "AutoDiscovery.<domainname>".  That way, if admins receive a large amount
                        // of traffic, they can change their DNS to have a "AutoDiscovery" alias that points to
                        // a web server of their choosing to handle this traffic.
                        wnsprintfW(wzDomain, ARRAYSIZE(wzDomain), L"autodiscover.%ls", pwszDomain);
                        if (SUCCEEDED(AddHDPA_StrDup(wzDomain, &m_hdpaPrimary)))
                        {
                            // Add ballback server here.  If the administrators don't want to do all the work
                            // of having another machine or creating a DNS alias, we will try the main server.
                            AddHDPA_StrDup(pwszDomain, &m_hdpaPrimary);
                        }
                    }
                }
            }
        }

        if (m_hdpaPrimary)
        {
            hr = CADProviders_CreateInstance(m_hdpaPrimary, SAFECAST(this, IObjectWithSite *), ppProviders);
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_getSecondaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders, IN DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (ppProviders)
    {
        *ppProviders = NULL;
        if (!m_hdpaSecondary && pwzEmailAddress)
        {
            LPCWSTR pwszDomain = StrChrW(pwzEmailAddress, CH_EMAIL_AT);
            if (pwszDomain)
            {
                pwszDomain = CharNext(pwszDomain);  // Skip past the "@"
                if (pwszDomain[0])
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

                    BOOL fUseGlobalService = SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_SERVICES_POLICY, FALSE, /*default:*/TRUE);
                    if (fUseGlobalService)
                    {
                        // If this policy is set, then we only want to use the Global Service for certain (i.e. Microsoft Owned)
                        // domains.  If people don't feel confortable with us providing settings for non-Microsoft
                        // email providers, then we can turn this on and only provide them for Microsoft providers.
                        if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_MS_ONLY_ADDRESSES, FALSE, /*default:*/FALSE))
                        {
                            fUseGlobalService = SHRegGetBoolUSValue(SZ_REGKEY_SERVICESALLOWLIST, pwszDomain, FALSE, /*default:*/FALSE);
                        }
                    }

                    if (fUseGlobalService)
                    {
                        HKEY hKey;
                        DWORD dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SZ_REGKEY_GLOBALSERVICES, 0, KEY_READ, &hKey);

                        if (ERROR_SUCCESS == dwError)
                        {
                            WCHAR szServiceURL[MAX_PATH];
                            int nIndex = 0;

                            do
                            {
                                WCHAR szValue[MAX_PATH];
                                DWORD cchValueSize = ARRAYSIZE(szValue);
                                DWORD dwType = REG_SZ;
                                DWORD cbDataSize = sizeof(szServiceURL);

                                dwError = RegEnumValueW(hKey, nIndex, szValue, &cchValueSize, NULL, &dwType, (unsigned char *)szServiceURL, &cbDataSize);
                                if (ERROR_SUCCESS == dwError)
                                {
                                    // FEATURE_OPTIMIZED_SERVICE: We can either pass the entire XML request or just put the domain name
                                    //    in the QueryString.  The QueryString is faster for the server and they can optimize by using it.
                                    AddHDPA_StrDup(szServiceURL, &m_hdpaSecondary);
                                }
                                else
                                {
                                    break;
                                }

                                nIndex++;
                            }
                            while (1);

                            RegCloseKey(hKey);
                        }
                    }
                }
            }
        }

        if (m_hdpaSecondary)
        {
            hr = CADProviders_CreateInstance(m_hdpaSecondary, SAFECAST(this, IObjectWithSite *), ppProviders);
        }
    }


    return hr;
}


HRESULT CAccountDiscoveryBase::_PerformAutoDiscovery(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    HRESULT hr = E_INVALIDARG;

    *ppXMLResponse = NULL;
    if (bstrEmailAddress)
    {
        hr = InternetOpenWrap(SZ_WININET_AGENT_AUTO_DISCOVER, PRE_CONFIG_INTERNET_ACCESS, NULL, NULL, 0, &m_hInternetSession);
        if (SUCCEEDED(hr))
        {
            BSTR bstrXML;

            hr = _GetInfo(bstrXMLRequest, bstrEmailAddress, &bstrXML, dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = XMLDOMFromBStr(bstrXML, ppXMLResponse);
                SysFreeString(bstrXML);
            }

            InternetCloseHandleWrap(m_hInternetSession);
            m_hInternetSession = NULL;
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_InternalDiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    HRESULT hr = E_INVALIDARG;

    *ppXMLResponse = NULL;
    if (bstrEmailAddress)
    {
        // Does the caller want this done async?
        if (m_hwndAsync)
        {
            // No, so cache the params so we can use them when async.
            SysFreeString(m_bstrEmailAsync);
            hr = HrSysAllocString(bstrEmailAddress, &m_bstrEmailAsync);
            if (SUCCEEDED(hr))
            {
                SysFreeString(m_bstrXMLRequest);
                hr = HrSysAllocString(bstrXMLRequest, &m_bstrXMLRequest);
                if (SUCCEEDED(hr))
                {
                    DWORD idThread;

                    m_dwFlagsAsync = dwFlags;

                    AddRef();
                    HANDLE hThread = CreateThread(NULL, 0, CAccountDiscoveryBase::AutoDiscoveryUIThreadProc, this, 0, &idThread);
                    if (hThread)
                    {
                        // We wait WAIT_AUTODISCOVERY_STARTUP_HWND for the new thread to create the COM object
                        if (m_hCreatedBackgroundTask)
                        {
                            DWORD dwRet = WaitForSingleObject(m_hCreatedBackgroundTask, WAIT_AUTODISCOVERY_STARTUP_HWND);
                            ASSERT(dwRet != WAIT_TIMEOUT);
                        }

                        hr = m_hrSuccess;
                        CloseHandle(hThread);
                    }
                    else
                    {
                        Release();
                    }
                }
            }
        }
        else
        {
            // Yes.
            hr = _PerformAutoDiscovery(bstrEmailAddress, dwFlags, bstrXMLRequest, ppXMLResponse);
        }
    }

    return hr;
}


DWORD CAccountDiscoveryBase::_AutoDiscoveryUIThreadProc(void)
{
    m_hrSuccess = CoInitialize(NULL);

    // We need to make sure that the API is installed and
    // accessible before we can continue.
    if (SUCCEEDED(m_hrSuccess))
    {
        IXMLDOMDocument * pXMLResponse;
        BSTR bstrXMLResponse = NULL;

        // Signal the main thread that we have successfully started
        if (m_hCreatedBackgroundTask)
            SetEvent(m_hCreatedBackgroundTask);

        // we give up the remainder of our timeslice here so that our parent thread has time to run
        // and will notice that we have signaled the m_hCreatedBackgroundTask event and can therefore return
        Sleep(0);

        m_hrSuccess = _PerformAutoDiscovery(m_bstrEmailAsync, m_dwFlagsAsync, m_bstrXMLRequest, &pXMLResponse);
        if (SUCCEEDED(m_hrSuccess))
        {
            m_hrSuccess = XMLBStrFromDOM(pXMLResponse, &bstrXMLResponse);
            pXMLResponse->Release();
        }

        _AsyncParseResponse(bstrXMLResponse);
        
        // Whether we succeeded or failed, inform the caller of our results.
        if (IsWindow(m_hwndAsync))
        {
            PostMessage(m_hwndAsync, m_wMsgAsync, m_hrSuccess, (LPARAM)bstrXMLResponse);
        }
        else
        {
            SysFreeString(bstrXMLResponse);
        }

        CoUninitialize();
    }
    else
    {
        // Signal the main thread that they can wake up to find that we
        // failed to start the async operation.
        if (m_hCreatedBackgroundTask)
            SetEvent(m_hCreatedBackgroundTask);
    }

    Release();
    return 0;
}


HRESULT CAccountDiscoveryBase::_WorkAsync(IN HWND hwnd, IN UINT wMsg)
{
    m_hwndAsync = hwnd;
    m_wMsgAsync = wMsg;

    return S_OK;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAccountDiscoveryBase::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CAccountDiscoveryBase::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CAccountDiscoveryBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAccountDiscoveryBase, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CAccountDiscoveryBase::CAccountDiscoveryBase() : m_cRef(1)
{
    // DllAddRef();  // Done by our inheriting class

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hInternetSession);
    ASSERT(!m_hwndAsync);
    ASSERT(!m_wMsgAsync);
    ASSERT(!m_dwFlagsAsync);
    ASSERT(!m_bstrEmailAsync);
    ASSERT(!m_bstrXMLRequest);
    ASSERT(S_OK == m_hrSuccess);
    ASSERT(!m_hdpaPrimary);
    ASSERT(!m_hdpaSecondary);

    // We use this event to signal the primary thread that the hwnd was created on the UI thread.
    m_hCreatedBackgroundTask = CreateEvent(NULL, FALSE, FALSE, NULL); 
}


CAccountDiscoveryBase::~CAccountDiscoveryBase()
{
    SysFreeString(m_bstrEmailAsync);
    SysFreeString(m_bstrXMLRequest);

    if (m_hCreatedBackgroundTask)
        CloseHandle(m_hCreatedBackgroundTask);

    if (m_hdpaPrimary)
    {
        DPA_DestroyCallback(m_hdpaPrimary, DPALocalFree_Callback, NULL);
    }

    if (m_hdpaSecondary)
    {
        DPA_DestroyCallback(m_hdpaSecondary, DPALocalFree_Callback, NULL);
    }

    //DllRelease();  // Done by our inheriting class
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\acemail.cpp ===
/*****************************************************************************\
    FILE: ACEmail.cpp

    DESCRIPTION:
        This file implements AutoComplete for Email Addresses.

    BryanSt 3/1/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"

#define MAX_EMAIL_MRU_SIZE          100



class CACLEmail
                : public IEnumString
                , public IACList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand) {return E_NOTIMPL;}

private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLEmail(LPCTSTR pszMRURegKey);
    ~CACLEmail(void);

    HRESULT AddEmail(IN LPCWSTR pszEmailAddress);

    // Instance creator
    friend HRESULT CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);
    friend HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress);

    // Private variables
    DWORD           m_cRef;      // COM reference count
    DWORD           m_nMRUIndex; // Current Index into MRU

    DWORD           m_dwRunMRUIndex; // Index into the Run MRU.
    DWORD           m_dwRunMRUSize;
    HANDLE          m_hMRURun;
};




//===========================
// *** IEnumString Interface ***
//===========================
HRESULT CACLEmail::Reset(void)
{
    HRESULT hr = S_OK;
    m_nMRUIndex = 0;
    m_dwRunMRUIndex = 0;

    return hr;
}


HRESULT CACLEmail::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    TCHAR szMRUEntry[MAX_URL_STRING+1];
    LPWSTR pwzMRUEntry = NULL;

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    if (!rgelt)
        return S_FALSE;

    *rgelt = 0;
    if (m_dwRunMRUIndex >= m_dwRunMRUSize)
        hr = S_FALSE;  // No more.
    else
    {
        if (m_hMRURun && EnumMRUList(m_hMRURun, m_dwRunMRUIndex++, szMRUEntry, ARRAYSIZE(szMRUEntry)) > 0)
        {
            hr = S_OK;
        }
        else
            hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        DWORD cchSize = lstrlen(szMRUEntry)+1;
        //
        // Allocate a return buffer (caller will free it).
        //
        pwzMRUEntry = (LPOLESTR)CoTaskMemAlloc(cchSize * sizeof(pwzMRUEntry[0]));
        if (pwzMRUEntry)
        {
            //
            // Convert the display name into an OLESTR.
            //
#ifdef UNICODE
            StrCpyN(pwzMRUEntry, szMRUEntry, cchSize);
#else   // ANSI
            MultiByteToWideChar(CP_ACP, 0, szMRUEntry, -1, pwzMRUEntry, cchSize);
#endif  // ANSI
            rgelt[0] = pwzMRUEntry;
            *pceltFetched = 1;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CACLEmail::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLEmail, IEnumString),
        QITABENT(CACLEmail, IACList),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             


ULONG CACLEmail::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}


ULONG CACLEmail::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}



//===========================
// *** Class Methods ***
//===========================
HRESULT CACLEmail::AddEmail(IN LPCWSTR pszEmailAddress)
{
    HRESULT hr = S_OK;

    if (-1 == AddMRUStringW(m_hMRURun, pszEmailAddress))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


CACLEmail::CACLEmail(LPCTSTR pszMRURegKey)
{
    DllAddRef();

    // Require object to be in heap and Zero-Inited
    ASSERT(!m_nMRUIndex);
    ASSERT(!m_dwRunMRUIndex);
    ASSERT(!m_hMRURun);

    MRUINFO mi =  {
        sizeof(MRUINFO),
        MAX_EMAIL_MRU_SIZE,
        MRU_CACHEWRITE,
        HKEY_CURRENT_USER,
        SZ_REGKEY_EMAIL_MRU,
        NULL        // NOTE: use default string compare
                    // since this is a GLOBAL MRU
    };

    m_hMRURun = CreateMRUList(&mi);
    if (m_hMRURun)
        m_dwRunMRUSize = EnumMRUList(m_hMRURun, -1, NULL, 0);

    m_cRef = 1;
}


CACLEmail::~CACLEmail()
{
    if (m_hMRURun)
        FreeMRUList(m_hMRURun);

    DllRelease();
}





/****************************************************\
    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  This will point to either the MRU for
    a browser or for a non-browser (Start->Run or
    the AddressBar in the Taskbar or floating) depending
    on the pszMRU parameter.
\****************************************************/
HRESULT CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    CACLEmail *paclSF = new CACLEmail(NULL);
    if (paclSF)
    {
        hr = paclSF->QueryInterface(riid, ppvObj);
        paclSF->Release();
    }
    else
    {
        *ppvObj = NULL;
    }

    return hr;
}


HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    CACLEmail *paclSF = new CACLEmail(NULL);
    if (paclSF)
    {
        hr = paclSF->AddEmail(pszEmailAddress);
        paclSF->Release();
    }

    return hr;
}



#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")
#define BOOL_NOT_SET                        0x00000005
DWORD _UpdateAutoCompleteFlags(void)
{
    DWORD dwACOptions = 0;

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


// TODO: Move this functionality to SHAutoComplete when it's ready.
STDAPI AddEmailAutoComplete(HWND hwndEdit)
{
    IUnknown * punkACL = NULL;
    DWORD dwACOptions = _UpdateAutoCompleteFlags();
    HRESULT hr = CACLEmail_CreateInstance(NULL, IID_PPV_ARG(IUnknown, &punkACL));

    if (punkACL)    // May fail on low memory.
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))   // May fail because of out of memory
        {
            if (SHPinDllOfCLSID(&CLSID_ACListISF) &&
                SHPinDllOfCLSID(&CLSID_AutoComplete))
            {
                hr = pac->Init(hwndEdit, punkACL, NULL, NULL);
                pac->SetOptions(dwACOptions);
            }
            else
            {
                hr = E_FAIL;
            }
            pac->Release();
        }

        punkACL->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\autodiscmail.cpp ===
/*****************************************************************************\
    FILE: AutoDiscMail.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscovered account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"
#include "MailProtocol.h"


// TODO: Add " xmlns="http://bryanst2-email/dtd/AutoDiscovery" to XML"
#define XML_POST_REQUEST                    L"<?xml version=\"1.0\"?>\r\n" \
                                             L"<" SZ_XMLELEMENT_AUTODISCOVERY L">\r\n" \
                                               L"<" SZ_XMLELEMENT_REQUEST L">\r\n" \
                                                 L"<" SZ_XMLELEMENT_ACCOUNT L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_TYPE L">" SZ_XMLTEXT_EMAIL L"</" SZ_XMLELEMENT_TYPE L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_VERSION L">0.1</" SZ_XMLELEMENT_VERSION L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_RESPONSEVER L">0.1</" SZ_XMLELEMENT_RESPONSEVER L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_LANG L">en</" SZ_XMLELEMENT_LANG L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_EMAIL L">%ls</" SZ_XMLELEMENT_EMAIL L">\r\n" \
                                                 L"</" SZ_XMLELEMENT_ACCOUNT L">\r\n" \
                                               L"</" SZ_XMLELEMENT_REQUEST L">\r\n" \
                                             L"</" SZ_XMLELEMENT_AUTODISCOVERY L">\r\n"

#define STR_AT_EMAIL                        TEXT("Email")


typedef struct tagPROTOCOL_ENTRY
{
    BSTR bstrProtocolName;
    IMailProtocolADEntry * pMailProtocol;
} PROTOCOL_ENTRY;


class CMailAccountDiscovery     : public CAccountDiscoveryBase
                                , public CImpIDispatch
                                , public IMailAutoDiscovery
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CAccountDiscoveryBase::AddRef();}
    virtual STDMETHODIMP_(ULONG) Release(void) {return CAccountDiscoveryBase::Release();}

    // *** IMailAutoDiscovery ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_InfoURL(OUT BSTR * pbstrURL);
    virtual STDMETHODIMP get_PreferedProtocolType(OUT BSTR * pbstrProtocolType);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IMailProtocolADEntry ** ppMailProtocol);
    virtual STDMETHODIMP get_XML(OUT IXMLDOMDocument ** ppXMLDoc);
    virtual STDMETHODIMP put_XML(IN IXMLDOMDocument * pXMLDoc);

    virtual STDMETHODIMP getPrimaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP getSecondaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP DiscoverMail(IN BSTR bstrEmailAddress);
    virtual STDMETHODIMP PurgeCache(void);
    virtual STDMETHODIMP WorkAsync(IN HWND hwnd, IN UINT wMsg) {return _WorkAsync(hwnd, wMsg);}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CMailAccountDiscovery();
    virtual ~CMailAccountDiscovery(void);

    HRESULT _GetUsersDisplayName(IN IXMLDOMElement * pXMLElementMessage);
    HRESULT _GetInfoURL(IN IXMLDOMNode * pXMLAccountNode);
    HRESULT _Initialize(IN IXMLDOMElement * pXMLElementMessage);
    HRESULT _FreeProtocolList(void);
    HRESULT _CreateProtocolEntry(IN IXMLDOMNode * pXMLNodeProtocol);

    HRESULT _GenerateXMLRequest(IN BSTR bstrEmailAddress, OUT BSTR * pbstrXMLRequest);
    HRESULT _ParseResponse(void);
    STDMETHODIMP _AsyncParseResponse(BSTR bstrEmail);   // Override base class implementation
    HRESULT _AsyncPrep(void);

    // Private Member Variables
    int                     m_cRef;

    bool                    m_fDiscovered;
    BSTR                    m_bstrUserDisplayName;  // OPTIONAL: User's Display Name from server.
    BSTR                    m_bstrInfoURL;          // OPTIONAL: An URL pointing to a web page describing information about the e-mail server or accessing e-mail.
    IXMLDOMNode *           m_pXMLNodeAccount;      // Node to section of XML with <ACCOUT> <TYPE>email</TYPE> ... </ACCOUNT>
    IXMLDOMDocument *       m_pXMLDocResponse;      // The XML document
    BSTR                    m_bstrResponse;         // Cached XML response until the main thread can parse in the async case.
    HDSA                    m_hdsaProtocols;        // PROTOCOL_ENTRY structs, containing IMailAutoDiscoveryProtocol *.

    // Friend Functions
    friend HRESULT CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};



#define SZ_FILEEXTENSION            L".xml"

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CMailAccountDiscovery::_GetUsersDisplayName(IN IXMLDOMElement * pXMLElementMessage)
{
    IXMLDOMNode * pNodeUser;
    HRESULT hr = XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_USER, &pNodeUser);

    if (m_bstrUserDisplayName)
    {
        SysFreeString(m_bstrUserDisplayName);
        m_bstrUserDisplayName = NULL;
    }

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetChildTagTextValue(pNodeUser, SZ_XMLELEMENT_DISPLAYNAME, &m_bstrUserDisplayName);
        pNodeUser->Release();
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_GetInfoURL(IN IXMLDOMNode * pXMLAccountNode)
{
    if (m_bstrInfoURL)
    {
        SysFreeString(m_bstrInfoURL);
        m_bstrInfoURL = NULL;
    }

    return XMLNode_GetChildTagTextValue(pXMLAccountNode, SZ_XMLELEMENT_INFOURL, &m_bstrInfoURL);
}


HRESULT CMailAccountDiscovery::_Initialize(IN IXMLDOMElement * pXMLElementMessage)
{
    // This is only valid XML if the root tag is "AUTODISCOVERY".
    // The case is not important.
    // If it isn't we need to reject this return value.
    // This happens most often when the URL fails to load
    // because the server doesn't exist and the Web Proxy
    // returns the error value wrapped in a web page.
    HRESULT hr = XMLElem_VerifyTagName(pXMLElementMessage, SZ_XMLELEMENT_AUTODISCOVERY);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pXMLReponse;

        // We don't care if this is failes because the server isn't obligated to 
        // provide:
        // <USER> <DISPLAYNAME> xxx </DISPLAYNAME> </USER>
        _GetUsersDisplayName(pXMLElementMessage);

        // Enter the <RESPONSE> tag.
        hr = XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_RESPONSE, &pXMLReponse);
        if (SUCCEEDED(hr))
        {
            IXMLDOMElement * pXMLElementMessage;

            hr = pXMLReponse->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElementMessage));
            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeList * pNodeListAccounts;

                // Iterate thru the list of <ACCOUNT> tags...
                hr = XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_ACCOUNT, &pNodeListAccounts);
                if (SUCCEEDED(hr))
                {
                    DWORD dwIndex = 0;

                    // We are going to look thru each one for one of them with <TYPE>email</TYPE>
                    while (S_OK == (hr = XMLNodeList_GetChild(pNodeListAccounts, dwIndex, &m_pXMLNodeAccount)))
                    {
                        // FUTURE: We could support redirects or error messages here depending on
                        //       <ACTION> redirect | message </ACTION>
                        if (XML_IsChildTagTextEqual(m_pXMLNodeAccount, SZ_XMLELEMENT_TYPE, SZ_XMLTEXT_EMAIL))
                        {
                            // This file may or may not settings to contact the server.  However in either case
                            // it may contain an INFOURL tag.  If it does, then the URL in side will point to a 
                            // web page.
                            // <INFOURL> xxx </INFOURL>
                            _GetInfoURL(m_pXMLNodeAccount);

                            if (XML_IsChildTagTextEqual(m_pXMLNodeAccount, SZ_XMLELEMENT_ACTION, SZ_XMLTEXT_SETTINGS))
                            {
                                break;
                            }
                        }

                        // No, so keep looking.
                        ATOMICRELEASE(m_pXMLNodeAccount);
                        dwIndex++;
                    }

                    pNodeListAccounts->Release();
                }

                pXMLElementMessage->Release();
            }

            pXMLReponse->Release();
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_GenerateXMLRequest(IN BSTR bstrEmailAddress, OUT BSTR * pbstrXMLRequest)
{
    HRESULT hr;
    WCHAR wzXML[4096];

    wnsprintfW(wzXML, ARRAYSIZE(wzXML), XML_POST_REQUEST, bstrEmailAddress);
    hr = HrSysAllocStringW(wzXML, pbstrXMLRequest);

    return hr;
}


HRESULT CMailAccountDiscovery::_CreateProtocolEntry(IN IXMLDOMNode * pXMLNodeProtocol)
{
    BSTR bstrProtocolType;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_TYPE, &bstrProtocolType);

    if (SUCCEEDED(hr))
    {
        IMailProtocolADEntry * pMailProtocol;

        hr = CMailProtocol_CreateInstance(pXMLNodeProtocol, &pMailProtocol);
        if (SUCCEEDED(hr))
        {
            PROTOCOL_ENTRY protocolEntry;

            protocolEntry.bstrProtocolName = bstrProtocolType;
            protocolEntry.pMailProtocol = pMailProtocol;
        
            if (-1 != DSA_InsertItem(m_hdsaProtocols, DA_LAST, &protocolEntry))
            {
                // We succeeded, so transfer owner ship of the items to the structure.
                bstrProtocolType = NULL;
                pMailProtocol = NULL;
            }
            else
            {
                hr = E_FAIL;
            }

            ATOMICRELEASE(pMailProtocol);
        }

        SysFreeString(bstrProtocolType);
    }

    return hr;
}

HRESULT CMailAccountDiscovery::_ParseResponse(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pXMLDocResponse)
    {
        IXMLDOMElement * pXMLElementMessage = NULL;
        hr = m_pXMLDocResponse->get_documentElement(&pXMLElementMessage);

        if (S_FALSE == hr)
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        else if (SUCCEEDED(hr))
        {
            hr = _Initialize(pXMLElementMessage);
            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeList * pNodeListProtocols;

                // Iterate thru the list of <ACCOUNT> tags...
                hr = XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_PROTOCOL, &pNodeListProtocols);
                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode * pXMLNodeProtocol;
                    DWORD dwIndex;

                    for (dwIndex = 0; (S_OK == (hr = XMLNodeList_GetChild(pNodeListProtocols, dwIndex, &pXMLNodeProtocol))); dwIndex++)
                    {
                        hr = _CreateProtocolEntry(pXMLNodeProtocol);
                        pXMLNodeProtocol->Release();
                    }

                    long nCount;

                    if (SUCCEEDED(get_length(&nCount)) && (nCount > 0))
                    {
                        hr = S_OK;
                    }

                    pNodeListProtocols->Release();
                }
            }

            pXMLElementMessage->Release();
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_FreeProtocolList(void)
{
    if (m_hdsaProtocols)
    {
        for (int nIndex = 0; nIndex < DSA_GetItemCount(m_hdsaProtocols); nIndex++)
        {
            PROTOCOL_ENTRY * pProtocolStruct = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, nIndex);

            if (pProtocolStruct)
            {
                SysFreeString(pProtocolStruct->bstrProtocolName);
                ATOMICRELEASE(pProtocolStruct->pMailProtocol);
            }
        }
        
        DSA_DeleteAllItems(m_hdsaProtocols);
    }

    return S_OK;
}


//===========================
// *** IMailAutoDiscovery Interface ***
//===========================
HRESULT CMailAccountDiscovery::get_DisplayName(OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            if (m_bstrUserDisplayName)
            {
                hr = HrSysAllocString(m_bstrUserDisplayName, pbstr);
            }
            else
            {
                *pbstr = NULL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_InfoURL(OUT BSTR * pbstrURL)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrURL)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            if (m_bstrInfoURL)
            {
                hr = HrSysAllocString(m_bstrInfoURL, pbstrURL);
            }
            else
            {
                *pbstrURL = NULL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_PreferedProtocolType(OUT BSTR * pbstrProtocolType)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pbstrProtocolType)
    {
        *pbstrProtocolType = NULL;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            if (m_hdsaProtocols && (0 < DSA_GetItemCount(m_hdsaProtocols)))
            {
                PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, 0);

                if (pProtocolEntry && pProtocolEntry->bstrProtocolName)
                {
                    hr = HrSysAllocString(pProtocolEntry->bstrProtocolName, pbstrProtocolType);
                }
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength)
    {
        *pnLength = 0;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            *pnLength = (long) DSA_GetItemCount(m_hdsaProtocols);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_item(IN VARIANT varIndex, OUT IMailProtocolADEntry ** ppMailProtocol)
{
    HRESULT hr = E_INVALIDARG;

    if (ppMailProtocol)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            long nCount = 0;

            get_length(&nCount);
            *ppMailProtocol = NULL;
            hr = E_FAIL;

            // This is sortof gross, but if we are passed a pointer to another variant, simply
            // update our copy here...
            if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
                varIndex = *(varIndex.pvarVal);

            switch (varIndex.vt)
            {
            case VT_I2:
                varIndex.lVal = (long)varIndex.iVal;
                // And fall through...

            case VT_I4:
                if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && (0 < DSA_GetItemCount(m_hdsaProtocols)))
                {
                    PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, varIndex.lVal);

                    if (pProtocolEntry && pProtocolEntry->pMailProtocol)
                    {
                        hr = pProtocolEntry->pMailProtocol->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
                    }
                }
            break;
            case VT_BSTR:
            {
                long nIndex;

                for (nIndex = 0; nIndex < nCount; nIndex++)
                {
                    PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, nIndex);

                    if (pProtocolEntry && pProtocolEntry->pMailProtocol && pProtocolEntry->bstrProtocolName &&
                        !StrCmpIW(pProtocolEntry->bstrProtocolName, varIndex.bstrVal))
                    {
                        hr = pProtocolEntry->pMailProtocol->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
                        break;
                    }
                }
            }
            break;

            default:
                hr = E_NOTIMPL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_XML(OUT IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_INVALIDARG;

    if (ppXMLDoc && m_pXMLDocResponse)
    {
        *ppXMLDoc = NULL;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            hr = m_pXMLDocResponse->QueryInterface(IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::put_XML(IN IXMLDOMDocument * pXMLDoc)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


HRESULT _IsValidEmailAddress(IN BSTR bstrEmailAddress)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrEmailAddress && bstrEmailAddress[0])
    {
        if (NULL != StrChrW(bstrEmailAddress, CH_EMAIL_AT))
        {
            // Ok, we found a '@' so it's valid.
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::getPrimaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    return _getPrimaryProviders(bstrEmailAddress, ppProviders);
}


HRESULT CMailAccountDiscovery::getSecondaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    return _getSecondaryProviders(bstrEmailAddress, ppProviders, (ADDN_DEFAULT | ADDN_CONFIGURE_EMAIL_FALLBACK | ADDN_FILTER_EMAIL));
}


HRESULT CMailAccountDiscovery::DiscoverMail(IN BSTR bstrEmailAddress)
{
    HRESULT hr = _IsValidEmailAddress(bstrEmailAddress);

    if (SUCCEEDED(hr))
    {
        BSTR bstrXMLRequest;

        hr = _GenerateXMLRequest(bstrEmailAddress, &bstrXMLRequest);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pXMLDocResponse);
            ATOMICRELEASE(m_pXMLNodeAccount);
            SysFreeString(m_bstrResponse);
            m_bstrResponse = NULL;

            _FreeProtocolList();
            hr = _InternalDiscoverNow(bstrEmailAddress, (ADDN_DEFAULT | ADDN_CONFIGURE_EMAIL_FALLBACK | ADDN_FILTER_EMAIL), bstrXMLRequest, &m_pXMLDocResponse);
            if (SUCCEEDED(hr) && !m_hwndAsync)  // If we aren't async, parse now.
            {
                hr = _ParseResponse();
                if (SUCCEEDED(hr))
                {
                    m_fDiscovered = true;
                }
            }

            SysFreeString(bstrXMLRequest);
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_AsyncParseResponse(BSTR bstrEmail)
{
    return HrSysAllocString(bstrEmail, &m_bstrResponse);
}


HRESULT CMailAccountDiscovery::_AsyncPrep(void)
{
    HRESULT hr = S_OK;

    // Now that we are back on the main thread.  See if we
    // need to turn the XML response back into a real COM object
    // for the user to read.
    if (m_hwndAsync && !m_pXMLDocResponse)    // Are we async?  And have we not yet parsed the response
    {
        hr = XMLDOMFromBStr(m_bstrResponse, &m_pXMLDocResponse);
        if (SUCCEEDED(hr))
        {
            hr = _ParseResponse();
            if (SUCCEEDED(hr))
            {
                m_fDiscovered = true;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::PurgeCache(void)
{
    HRESULT hr = E_INVALIDARG;

    // TODO:
    _FreeProtocolList();
    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================


//===========================
// *** Class Methods ***
//===========================
HRESULT CMailAccountDiscovery::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CMailAccountDiscovery, IMailAutoDiscovery),
        QITABENT(CMailAccountDiscovery, IDispatch),
        { 0 },
    };

    hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        hr = CAccountDiscoveryBase::QueryInterface(riid, ppvObj);
    }

    return hr;
}


CMailAccountDiscovery::CMailAccountDiscovery() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IMailAutoDiscovery)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pXMLDocResponse);
    ASSERT(!m_pXMLNodeAccount);
    ASSERT(!m_bstrUserDisplayName);
    ASSERT(!m_bstrInfoURL);
    ASSERT(!m_bstrResponse);

    m_hdsaProtocols = DSA_Create(sizeof(PROTOCOL_ENTRY), 1);
    m_fDiscovered = false;
}


CMailAccountDiscovery::~CMailAccountDiscovery()
{
    ATOMICRELEASE(m_pXMLNodeAccount);
    ATOMICRELEASE(m_pXMLDocResponse);
    SysFreeString(m_bstrUserDisplayName);
    SysFreeString(m_bstrInfoURL);
    SysFreeString(m_bstrResponse);

    _FreeProtocolList();
    DSA_DeleteAllItems(m_hdsaProtocols);
    m_hdsaProtocols = NULL;

    DllRelease();
}


HRESULT CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        if (ppvObj)
        {
            CMailAccountDiscovery * pThis = new CMailAccountDiscovery();
            if (pThis)
            {
                hr = pThis->QueryInterface(riid, ppvObj);
                pThis->Release();
            }
            else
            {
                *ppvObj = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    return hr;
}

















//===========================
// *** IAutoDiscoveryProvider Interface ***
//===========================
HRESULT CADProviders::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength && m_hdpa)
    {
        *pnLength = (long) DSA_GetItemCount(m_hdpa);
        hr = S_OK;
    }

    return hr;
}


HRESULT CADProviders::get_item(IN VARIANT varIndex, OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        long nCount = 0;

        get_length(&nCount);
        *pbstr = NULL;

        hr = E_FAIL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && (0 < DSA_GetItemCount(m_hdpa)))
            {
                if (m_hdpa)
                {
                    LPCWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpa, varIndex.lVal);

                    if (pszFilename)
                    {
                        hr = HrSysAllocString(pszFilename, pbstr);
                    }
                }
            }
        break;
        case VT_BSTR:
            hr = E_NOTIMPL;
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CADProviders::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CADProviders::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CADProviders::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CADProviders, IAutoDiscoveryProvider),
        QITABENT(CADProviders, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CADProviders::CADProviders(IN HDPA hdpa, IN IUnknown * punkParent) : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IAutoDiscoveryProvider), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);
    ASSERT(!m_punkParent);

    m_hdpa = hdpa;
    IUnknown_Set((IUnknown **)&m_punkParent, punkParent);
}


CADProviders::~CADProviders()
{
    IUnknown_Set((IUnknown **)&m_punkParent, NULL);

    DllRelease();
}


HRESULT CADProviders_CreateInstance(IN HDPA hdpa, IN IUnknown * punkParent, OUT IAutoDiscoveryProvider ** ppProvider)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;

    if (ppProvider)
    {
        CADProviders * pThis = new CADProviders(hdpa, punkParent);
        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAutoDiscoveryProvider, ppProvider));
            pThis->Release();
        }
        else
        {
            *ppProvider = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\autodiscover.h ===
/*****************************************************************************\
    FILE: AutoDiscover.h

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_AUTODISCOVER
#define _FILE_H_AUTODISCOVER

#include <cowsite.h>
#include <atlbase.h>

class CAccountDiscoveryBase : public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    virtual STDMETHODIMP _InternalDiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    virtual STDMETHODIMP _WorkAsync(IN HWND hwnd, IN UINT wMsg);

protected:
    CAccountDiscoveryBase();
    virtual ~CAccountDiscoveryBase(void);

    HRESULT _GetInfo(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _GetInfoFromDomain(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BOOL fHTTPs, IN BOOL fPost, IN LPCSTR pszURLPath, IN BSTR * pbstrXML);
    HRESULT _GetInfoFromDomainWithCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _UseOptimizedService(IN LPCWSTR pwzServiceURL, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _VerifyValidXMLResponse(IN BSTR * pbstrXML, IN LPWSTR pszRedirURL, IN DWORD cchSize);
    HRESULT _CheckInCache(IN LPWSTR pwzCacheURL, OUT BSTR * pbstrXML);
    HRESULT _CheckInCacheAndAddHash(IN LPCWSTR pwzDomain, IN BSTR bstrEmail, IN LPCSTR pszSubdir, IN LPWSTR pwzCacheURL, IN DWORD cchSize, IN BSTR bstrXMLRequest, OUT BSTR * pbstrXML);
    HRESULT _CacheResults(IN LPCWSTR pwzCacheURL, IN BSTR bstrXML);
    HRESULT _PerformAutoDiscovery(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    HRESULT _SendStatusMessage(UINT nStringID, LPCWSTR pwzArg);
    HRESULT _GetInfoFromDomainWithSubdirAndCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags, IN LPCSTR pszURLPath);
    HRESULT _UrlToComponents(IN LPCWSTR pszURL, IN BOOL * pfHTTPS, IN LPWSTR pszDomain, IN DWORD cchSize, IN LPSTR pszURLPath, IN DWORD cchSizeURLPath);

    virtual STDMETHODIMP _AsyncParseResponse(BSTR bstrEmail) {return S_OK;}

    virtual STDMETHODIMP _getPrimaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP _getSecondaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders, IN DWORD dwFlags);

    DWORD _AutoDiscoveryUIThreadProc(void);
    static DWORD CALLBACK AutoDiscoveryUIThreadProc(LPVOID pvThis) { return ((CAccountDiscoveryBase *) pvThis)->_AutoDiscoveryUIThreadProc(); };

    // Private Member Variables
    int                     m_cRef;

    HINTERNET               m_hInternetSession;

    // Async State
    HWND                    m_hwndAsync;
    UINT                    m_wMsgAsync;
    DWORD                   m_dwFlagsAsync;
    BSTR                    m_bstrEmailAsync;
    BSTR                    m_bstrXMLRequest;
    HANDLE                  m_hCreatedBackgroundTask;    // Handle to wait for background thread to start up.
    HRESULT                 m_hrSuccess;                 // Did the AutoDiscovery process succeed?

    HDPA                    m_hdpaPrimary;               // The Servers to contact.  Contains LPCWSTRs
    HDPA                    m_hdpaSecondary;             // The Servers to contact.  Contains LPCWSTRs
};





class CADProviders              : public CImpIDispatch
                                , public IAutoDiscoveryProvider
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAutoDiscoveryProvider ***
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT BSTR * pbstr);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CADProviders(IN HDPA hdpa, IN IUnknown * punkParent);
    virtual ~CADProviders(void);

    // Private Member Variables
    int                     m_cRef;

    HDPA                    m_hdpa;            // This contains LPWSTRs that contain servers
    IUnknown *              m_punkParent;      // We hold on to this guy to keep m_hdpa alive

    // Private Member Functions

    // Friend Functions
    friend HRESULT CADProviders_CreateInstance(IN HDPA hdpa, IN IUnknown * punkParent, OUT IAutoDiscoveryProvider ** ppProvider);
};



#endif // _FILE_H_AUTODISCOVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\cobjsafe.cpp ===
#include "priv.h"

#include <comcat.h>
#include <hliface.h>
#include <mshtml.h>
#include <objsafe.h>
#include <perhist.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_ALWAYS, "MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_ALWAYS, "MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\classfactory.cpp ===
/*****************************************************************************\
    FILE: classfactory.cpp

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "autodiscovery.h"
#include "objcache.h"
#include "mailbox.h"


/*****************************************************************************
 *
 *  CClassFactory
 *
 *
 *****************************************************************************/

class CClassFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CClassFactory(REFCLSID rclsid);
    ~CClassFactory(void);

    // Friend Functions
    friend HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *  IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CClassFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppvObj)
    {
        if (!punkOuter)
        {
            hr = E_NOINTERFACE;
        }
        else
        {   // Does anybody support aggregation any more?
            hr = ResultFromScode(CLASS_E_NOAGGREGATION);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  IClassFactory::LockServer
 *
 *  Locking the server is identical to
 *  creating an object and not releasing it until you want to unlock
 *  the server.
 *
 *****************************************************************************/

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *  CClassFactory_Create
 *
 *****************************************************************************/

/****************************************************\
    Constructor
\****************************************************/
CClassFactory::CClassFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CClassFactory::~CClassFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CClassFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CClassFactory::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_WMOTHER, "CClassFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CClassFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\autodiscover.cpp ===
/*****************************************************************************\
    FILE: AutoDiscover.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "AutoDiscover.h"



class CAccountDiscovery : public CImpIDispatch
                        , public CAccountDiscoveryBase
                        , public IAccountDiscovery
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CAccountDiscoveryBase::AddRef();}
    virtual STDMETHODIMP_(ULONG) Release(void) {return CAccountDiscoveryBase::Release();}

    // *** IAccountDiscovery ***
    virtual STDMETHODIMP DiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    virtual STDMETHODIMP WorkAsync(IN HWND hwnd, IN UINT wMsg) {return _WorkAsync(hwnd, wMsg);}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

protected:
    CAccountDiscovery();
    virtual ~CAccountDiscovery(void);

    // Friend Functions
    friend HRESULT CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};



//===========================
// *** IAccountDiscovery Interface ***
//===========================
HRESULT CAccountDiscovery::DiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    return CAccountDiscoveryBase::_InternalDiscoverNow(bstrEmailAddress, dwFlags, bstrXMLRequest, ppXMLResponse);
}



HRESULT CAccountDiscovery::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAccountDiscovery, IAccountDiscovery),
        QITABENT(CAccountDiscovery, IDispatch),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        hr = CAccountDiscoveryBase::QueryInterface(riid, ppvObj);
    }

    return hr;
}


CAccountDiscovery::CAccountDiscovery() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IAccountDiscovery)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
}


CAccountDiscovery::~CAccountDiscovery()
{
    DllRelease();
}


HRESULT CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        CAccountDiscovery * pmf = new CAccountDiscovery();
        if (pmf)
        {
            hr = pmf->QueryInterface(riid, ppvObj);
            pmf->Release();
        }
        else
        {
            *ppvObj = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\cobjsafe.h ===
#ifndef _COBJSAFE_H_
#define _COBJSAFE_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    CObjectSafety() : _dwSafetyOptions(0) { }

    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif // _COBJSAFE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\cowsite.cpp ===
#include "priv.h"
#pragma hdrstop

#include "cowsite.h"

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include <wininet.h>
#include <winineti.h>

#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "AUTODISC"
#define SZ_MODULE           "AUTODISC"
#define DECLARE_DEBUG

void AssertMsg(BOOL fCondition, LPCSTR pszMessage, ...)
{
    ASSERT(fCondition);
}

void TraceMsg(DWORD dwFlags, LPCSTR pszMessage, ...)
{
}

#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define DECL_CRTFREE.
// (CPP_FUNCTIONS is the old name.)
//

#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

#ifndef UNIX

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (LPVOID)LocalAlloc(LPTR, nSize);
}

void  __cdecl operator delete(void *pv)
{
    //delete and LocalFree both handle NULL, others don't
    //If changed to GlobalFree or HeapFree - must check for NULL here
    LocalFree((HLOCAL)pv);
}
#endif

extern "C" int __cdecl _purecall(void) 
{
#ifdef ASSERT_MSG
    ASSERT_MSG(0, "purecall() hit");
#endif

#ifdef DEBUG
    DebugBreak();
#endif // DEBUG

    return 0;
}

#endif  // DECL_CRTFREE


#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dllload.cpp ===
#include "priv.h"
#include <wininet.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 


/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (HIWORD(pszProc)) {
        StrCpyNA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wnsprintfA(szProcD, ARRAYSIZE(szProcD), "(ordinal %d)", LOWORD(pszProc));
    }
#endif // DEBUG
    // If it's already loaded, return.
    if (*ppfn) {
    return;
    }

    if (*phinst == NULL) {
#ifdef DEBUG
    TraceMsg(TF_WMOTHER, "DLLLOAD: Loading %s for the first time for %s", pszDLL, szProcD);
    
    if (g_dwBreakFlags & 0x00000080)
    {
        DebugBreak();
    }
#endif // DEBUG
    *phinst = LoadLibraryA(pszDLL);
    if (*phinst == NULL) {
        return;
    }
    }

#ifdef DEBUG
    TraceMsg(TF_WMOTHER, "DLLLOAD: GetProc'ing %s from %s for the first time", pszDLL, szProcD);
#endif // DEBUG
    *ppfn = GetProcAddress(*phinst, pszProc);
}

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    _GetProcFromDLL(phinst, pszDLL, ppfn, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_MAP_HRESULT(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, HRESULT, _fnpriv, _fn, _args, _nargs, E_FAIL)
#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}


//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}



/**********************************************************************/
/**********************************************************************/
#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dllmain.cpp ===
/*****************************************************************************\
    FILE: dllmain.cpp

    DESCRIPTION:
       Power Toy to add encryption option to Context menus in the shell.  This
    file will take care of the DLL lifetime.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "objcache.h"

/*****************************************************************************
 *
 *  Dynamic Globals.  There should be as few of these as possible.
 *
 *  All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;           // Global reference count
CRITICAL_SECTION g_csDll;   // The shared critical section


#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_MsgListView, CMsgListView)
END_OBJECT_MAP()

/*****************************************************************************
 *
 *  DllAddRef / DllRelease
 *
 *  Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  DllGetClassObject
 *
 *  OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *  The artificial refcount inside DllGetClassObject helps to
 *  avoid the race condition described in DllCanUnloadNow.  It's
 *  not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_FAIL;

    return hres;
}

/*****************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  OLE entry point.  Fail iff there are outstanding refs.
 *
 *  There is an unavoidable race condition between DllCanUnloadNow
 *  and the creation of a new IClassFactory:  Between the time we
 *  return from DllCanUnloadNow() and the caller inspects the value,
 *  another thread in the same process may decide to call
 *  DllGetClassObject, thus suddenly creating an object in this DLL
 *  when there previously was none.
 *
 *  It is the caller's responsibility to prepare for this possibility;
 *  there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    if (S_OK == hres)
    {
        hres = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    TraceMsg(TF_WMOTHER, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}

/*
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
const LPCTSTR c_rgszClasses[] = {
//    g_cszPopServiceWndClass
};

//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))
*/

/*****************************************************************************
 *
 *  Entry32
 *
 *  DLL entry point.
 *
 *  BUGBUG -- On a thread detach, must check if the thread owns any
 *  global timeouts.  If so, we must transfer the timeout to another
 *  thread or something.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef DEBUG
            CcshellGetDebugFlags();
#endif

            InitializeCriticalSection(&g_csDll);
            InitializeCriticalSection(&g_hCachedObjectSection);

            g_hinst = hinst;
//            _Module.Init(ObjectMap, hinst, &LIBID_AutoDiscovery);
            DisableThreadLibraryCalls(hinst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
//            _Module.Term();

//            UnregisterWindowClasses();
//            PurgeObjectCache();
            DeleteCriticalSection(&g_hCachedObjectSection);

            DeleteCriticalSection(&g_csDll);
            break;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#pragma warning (disable:4096)      // '__cdecl' must be used with '...'
#pragma warning (disable:4201)      // nonstandard extension used : nameless struct/union
#pragma warning (disable:4115)      // named type definition in parentheses

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_qwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern ULONGLONG g_qwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_LEAKS            0x80000000      // Break on detecting a leak

// Trace flags for g_qwTraceFlags
#define TF_ALWAYS           0xFFFFFFFFFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_MEMUSAGE                       0x0000000100000000      
#define TF_KEEP_ALLOCATION_STACKS         0x0000000200000000      
// (Upper 28 bits reserved for custom use per-module)

#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

// Old, archaic debug flags.  
// APPCOMPAT (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                _asm int 3                              \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
        } while (gAlwaysAssert);                        \
    }
#else
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                DebugBreak();                           \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
            __endexcept                                 \
        } while (gAlwaysAssert);                        \
    }
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);


void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_qwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_qwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

UINT GetStack(UINT nDepth, CHAR *szBuffer, UINT nBufferLength);
void CDECL CcshellDebugMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(ULONGLONG flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(ULONGLONG flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg

#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// APPCOMPAT (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dpa.h ===
#ifndef GUARD_D70787804D9C11d28784F6E920524153
#define GUARD_D70787804D9C11d28784F6E920524153

#include "comctrlp.h"

//  The Ex versions of EnumCallback, DestroyCallback, Sort, Search, etc.
//  do stricter type checking to make sure that the reference data /
//  parameter matches both on the calling side and the callback side.


template <class T> class CDPA
{

public:
    // Typedefs
    typedef int (CALLBACK *_PFNDPAENUMCALLBACK)(T *p, LPVOID pData);
    typedef int (CALLBACK *_PFNDPACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDPA() {}
    CDPA(HDPA hdpa) {m_hdpa = hdpa;}

    HDPA GetHDPA() {return m_hdpa;}
    void SetHDPA(const HDPA hdpa) {m_hdpa = hdpa;}

    operator bool () { return m_hdpa != NULL; }

    BOOL    Create(int cItemGrow)
    {return (m_hdpa = DPA_Create(cItemGrow)) != NULL;}

    BOOL    CreateEx(int cpGrow, HANDLE hheap)
    {return (m_hdpa = DPA_CreateEx(cpGrow, hheap)) != NULL;}

    BOOL    Destroy()
    {return DPA_Destroy(m_hdpa);}

    HDPA    Clone(HDPA hdpaNew)
    {return DPA_Clone(m_hdpa, hdpaNew);}

    T*      GetPtr(INT_PTR i)
    {return (T*) DPA_GetPtr(m_hdpa, i);}

    int     GetPtrIndex(T* p)
    {return DPA_GetPtrIndex(m_hdpa, (LPVOID) p);}

    BOOL    Grow(int cp)
    {return DPA_Grow(m_hdpa, cp);}

    BOOL    SetPtr(int i, T* p)
    {return DPA_SetPtr(m_hdpa, i, (LPVOID) p);}

    int     InsertPtr(int i, T* p)
    {return DPA_InsertPtr(m_hdpa, i, (LPVOID) p);}

    T*      DeletePtr(int i)
    {return (T*) DPA_DeletePtr(m_hdpa, i);}

    BOOL    DeleteAllPtrs()
    {return DPA_DeleteAllPtrs(m_hdpa);}

    void    EnumCallback(_PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
    {DPA_EnumCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {EnumCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    void    DestroyCallback(_PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
    {DPA_DestroyCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    int     GetPtrCount()
    {return DPA_GetPtrCount(m_hdpa);}

    T*      GetPtrPtr()
    {return (T*)DPA_GetPtrPtr(m_hdpa);}

    T*&     FastGetPtr(int i)
    {return (T*&)DPA_FastGetPtr(m_hdpa, i);}
    
    int     AppendPtr(T* pitem)
    {return DPA_AppendPtr(m_hdpa, (LPVOID) pitem);}

#ifdef __IStream_INTERFACE_DEFINED__
    HRESULT LoadStream(PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData)
    {return DPA_LoadStream(&m_hdpa, pfn, pstream, pvInstData);}

    HRESULT SaveStream(PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData)
    {return DPA_SaveStream(m_hdpa, pfn, pstream, pvInstData);}
#endif

    BOOL    Sort(_PFNDPACOMPARE pfnCompare, LPARAM lParam)
    {return DPA_Sort(m_hdpa, (PFNDPACOMPARE)pfnCompare, lParam);}

    template<class T2>
    BOOL    SortEx(int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam), T2 lParam)
    {return Sort((_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam));}

    // Merge not supported through this object; use DPA_Merge

    int     Search(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options)
    {return DPA_Search(m_hdpa, (LPVOID) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options);}

    template<class T2>
    int     SearchEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options)
    {return Search(pFind, iStart, (_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam), options);}
    
    int     SortedInsertPtr(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options, T* pitem)
    {return DPA_SortedInsertPtr(m_hdpa, (LPVOID) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options, (LPVOID) pitem);}

    template<class T2>
    int     SortedInsertPtrEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options, T* pitem)
    {return SortedInsertPtr(pFind, iStart, (_PFNDPACOMPARE)pfnCompare,
                    reinterpret_cast<LPARAM>(lParam), options, pitem);}

private:
    HDPA m_hdpa;
};

template <class T> class CDSA
{
public:
    // Typedefs
    typedef int (CALLBACK *_PFNDSAENUMCALLBACK)(T *p, LPVOID pData);
    typedef int (CALLBACK *_PFNDSACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDSA() {}
    CDSA(HDSA hdsa) {m_hdsa = hdsa;}

    HDSA GetHDSA() {return m_hdsa;}
    void SetHDSA(const HDSA hdsa) {m_hdsa = hdsa;}

    operator bool () { return m_hdsa != NULL; }

    BOOL    Create(int cItemGrow)
    {return (m_hdsa = DSA_Create(sizeof(T), cItemGrow)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DSA_Destroy(m_hdsa); m_hdsa = NULL; return fRet;}

    BOOL    GetItem(int i, T* pitem)
    {return DSA_GetItem(m_hdsa, i, (LPVOID)pitem);}

    T*      GetItemPtr(int i)
    {return (T*)DSA_GetItemPtr(m_hdsa, i);}

    BOOL    SetItem(int i, T* pitem)
    {return DSA_SetItem(m_hdsa, i, (LPVOID)pitem);}

    int     InsertItem(int i, T* pitem)
    {return DSA_InsertItem(m_hdsa, i, (LPVOID)pitem);}

    BOOL    DeleteItem(int i)
    {return DSA_DeleteItem(m_hdsa, i);}

    BOOL    DeleteAllItems()
    {return DSA_DeleteAllItems(m_hdsa);}

    void    EnumCallback(_PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
    {DSA_EnumCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {EnumCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    void    DestroyCallback(_PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
    {DSA_DestroyCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData); m_hdsa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    int     GetItemCount()
    {return DSA_GetItemCount(m_hdsa);}

    int     AppendItem(T* pitem)
    {return DSA_AppendItem(m_hdsa, (LPVOID)pitem);}

private:
    HDSA m_hdsa;
};


#endif // !GUARD_D70787804D9C11d28784F6E920524153
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <autodiscovery.h>       // For LIBID_AutoDiscovery

// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return fResult;
}



HRESULT MyRegTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];
#ifdef UNICODE
    WCHAR   *pwsz = szTmp; 
#else
    WCHAR   pwsz[MAX_PATH];
#endif

    // Load and register our type library.
    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));
#ifndef UNICODE
    if (SHAnsiToUnicode(szTmp, pwsz, MAX_PATH)) 
#endif
    {
        hr = LoadTypeLib(pwsz, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library as we had some old junk that
            // was registered by a previous version of OleAut32, which is now causing
            // the current version to not work on NT...
            UnregisterTypeLibrary(&LIBID_AutoDiscovery);
            hr = RegisterTypeLib(pTypeLib, pwsz, NULL);

            if (FAILED(hr))
            {
                TraceMsg(TF_ALWAYS, "AUTODISC: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_ALWAYS, "AUTODISC: LoadTypeLib failed (%x)", hr);
        }
    } 
#ifndef UNICODE
    else {
        hr = E_FAIL;
    }
#endif

    return hr;
}



/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "NO_LONGER_USED", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            szIEPath[0] = 0;
            hr = pfnri(HINST_THISDLL, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("DLL_RegInstall");

#ifdef FEATURE_MAILBOX
    hr = CallRegInstall("DLL_RegInstallMailBox");
#else // FEATURE_MAILBOX
    CallRegInstall("DLL_RegUnInstallMailBox");
#endif // FEATURE_MAILBOX

    MyRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("DLL_RegUnInstall");
    CallRegInstall("DLL_RegUnInstallMailBox");
    UnregisterTypeLibrary(&LIBID_AutoDiscovery);

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.


    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "priv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\emailassoc.h ===
/*****************************************************************************\
    FILE: EmailAssoc.h

    DESCRIPTION:
        This file implements email to application associations.

    BryanSt 3/14/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EMAIL_ASSOCIATIONS_H
#define _EMAIL_ASSOCIATIONS_H
#ifdef FEATURE_EMAILASSOCIATIONS

#include "dllload.h"



//////////////////////////////////////
// EmailAccount
//////////////////////////////////////
HRESULT EmailAssoc_CreateEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey);
HRESULT EmailAssoc_OpenEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey);
HRESULT EmailAssoc_GetEmailAccountProtocol(IN HKEY hkey, IN LPWSTR pszProtocol, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountProtocol(IN HKEY hkey, IN LPCWSTR pszProtocol);
HRESULT EmailAssoc_GetEmailAccountWebURL(IN HKEY hkey, IN LPWSTR pszURL, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountWebURL(IN HKEY hkey, IN LPCWSTR pszURL);
HRESULT EmailAssoc_GetEmailAccountPreferredApp(IN HKEY hkey, IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountPreferredApp(IN HKEY hkey, IN LPCWSTR pszMailApp);
HRESULT EmailAssoc_GetDefaultEmailAccount(IN LPWSTR pszProtocol, IN DWORD cchSize);
HRESULT EmailAssoc_SetDefaultEmailAccount(IN LPCWSTR pszProtocol);


//////////////////////////////////////
// MailApp
//////////////////////////////////////
HRESULT EmailAssoc_GetDefaultMailApp(IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetDefaultMailApp(IN LPCWSTR pszMailApp);
HRESULT EmailAssoc_OpenMailApp(IN LPCWSTR pszMailApp, OUT HKEY * phkey);
HRESULT EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize);
HRESULT EmailAssoc_GetAppCmdLine(IN HKEY hkey, IN LPTSTR pszCmdLine, IN DWORD cchSize);
HRESULT EmailAssoc_GetIconPath(IN HKEY hkey, IN LPTSTR pszIconPath, IN DWORD cchSize);
HRESULT EmailAssoc_GetFirstMailAppForProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize);

BOOL EmailAssoc_DoesMailAppSupportProtocol(IN LPCWSTR pszMailApp, IN LPCWSTR pszProtocol);
HRESULT EmailAssoc_InstallLegacyMailAppAssociations(void);


//////////////////////////////////////
// Other
//////////////////////////////////////
HRESULT EmailAssoc_CreateWebAssociation(IN LPCWSTR pszEmail, IN IMailProtocolADEntry * pMailProtocol);
HRESULT EmailAssoc_GetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp);
HRESULT EmailAssoc_CreateStandardsBaseAssociation(IN LPCTSTR pszEmail, IN LPCTSTR pszProtocol);


#endif // FEATURE_EMAILASSOCIATIONS
#endif // _EMAIL_ASSOCIATIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\fromshell.h ===
/*****************************************************************************\
    FILE: fromshell.h

    DESCRIPTION:
        These declarations are from Copied Shell\{inc,lib}\ files.  I need
    to fork these since I moved out of the shell tree.

    BryanSt 4/10/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FROMSHELL_H
#define _FROMSHELL_H


// These declarations are from Copied Shell\{inc,lib}\ files
// ATOMICRELEASE
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#endif
#endif //ATOMICRELEASE



// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE


typedef UINT FAR *LPUINT;

// The following are declarations AutoDiscovery lost when it left the
// shell tree.
#define TF_ALWAYS                   0xFFFFFFFF

void TraceMsg(DWORD dwFlags, LPCSTR pszMessage, ...);
void AssertMsg(BOOL fCondition, LPCSTR pszMessage, ...);


//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

#define IN
#define OUT

#define ASSERT(condition)


// Convert an array name (A) to a generic count (c).
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// General flag macros
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


#define RECTWIDTH(rc)          ((rc).right - (rc).left)
#define RECTHEIGHT(rc)         ((rc).bottom - (rc).top)

#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG

#define HRESULT_TO_SCRIPT(hr)   ((S_OK == (hr)) ? S_OK : S_FALSE)
#define SUCCEEDED_SCRIPT(hr)    (S_OK == (hr))
#define FAILED_SCRIPT(hr)       (S_OK != (hr))
#define SCRIPT_TO_HRESULT(hr)   (((S_OK != (hr)) && (SUCCEEDED((hr)))) ? E_FAIL : hr)


////////////////
//  Critical section stuff
//
//  Helper macros that give nice debug support
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG






/////////////////////////////////////////////////////////////
// Are these even needed?
/////////////////////////////////////////////////////////////
#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif // OLD_HLIFACE

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)


#ifdef SAFERELEASE
#undef SAFERELEASE
#endif // SAFERELEASE
#define SAFERELEASE(p) ATOMICRELEASE(p)


#define IsInRange               InRange

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#ifdef  UNICODE
   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;
#endif /* UNICODE */


#endif // _FROMSHELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of type library
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid,
    USHORT wVerMajor, USHORT wVerMinor, 
    REFGUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid);
        virtual ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        REFIID      m_riid;
        REFGUID     m_libid;
        USHORT      m_wVerMajor;
        USHORT      m_wVerMinor;

        ITypeInfo  *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\dspsprt.cpp ===
#include "priv.h"
#pragma hdrstop

#include "dspsprt.h"

#define TF_IDISPATCH 0

EXTERN_C HINSTANCE g_hinst;

CImpIDispatch::CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid) :
    m_libid(libid), m_wVerMajor(wVerMajor), m_wVerMinor(wVerMinor), m_riid(riid), m_pITINeutral(NULL)
{
    ASSERT(NULL == m_pITINeutral);
}

CImpIDispatch::~CImpIDispatch(void)
{
    ATOMICRELEASE(m_pITINeutral);
}

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 1;
    return S_OK;
}

// helper function for pulling ITypeInfo out of our typelib
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, 
                            REFGUID uuid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;        // assume failure

    ITypeLib *pITypeLib;
    HRESULT hr;
    USHORT wResID;

    if (!IsEqualGUID(libid, GUID_NULL))
    {
        // The type libraries are registered under 0 (neutral),
        // 7 (German), and 9 (English) with no specific sub-
        // language, which would make them 407 or 409 and such.
        // If you are sensitive to sub-languages, then use the
        // full LCID instead of just the LANGID as done here.
#ifdef DEBUG
        hr = E_FAIL;    // force load through GetModuleFileName(), to get fusion 1.0 support
#else
        hr = LoadRegTypeLib(libid, wVerMajor, wVerMinor, PRIMARYLANGID(lcid), &pITypeLib);
#endif
        wResID = 0;
    }
    else
    {
        // If libid is GUID_NULL, then get type lib from module and use wVerMajor as
        // the resource ID (0 means use first type lib resource).
        pITypeLib = NULL;
        hr = E_FAIL;
        wResID = wVerMajor;
    }

    // If LoadRegTypeLib fails, try loading directly with LoadTypeLib.
    if (FAILED(hr) && g_hinst)
    {
        WCHAR wszPath[MAX_PATH];
        GetModuleFileNameWrapW(g_hinst, wszPath, ARRAYSIZE(wszPath));
        // Append resource ID to path, if specified.
        if (wResID)
        {
            WCHAR wszResStr[10];
            wnsprintfW(wszResStr, ARRAYSIZE(wszResStr), L"\\%d", wResID);
            StrCatBuffW(wszPath, wszResStr, ARRAYSIZE(wszPath));
        }
        
        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr = LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Got the type lib, get type info for the interface we want.
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }
    return hr;
}


STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;

    if (0 != itInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ITypeInfo **ppITI = &m_pITINeutral; // our cached typeinfo

    // Load a type lib if we don't have the information already.
    if (NULL == *ppITI)
    {
        ITypeInfo *pITIDisp;
        HRESULT hr = GetTypeInfoFromLibId(lcid, m_libid, m_wVerMajor, m_wVerMinor, m_riid, &pITIDisp);
        if (SUCCEEDED(hr))
        {
            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HREFTYPE hrefType;
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    (*ppITI)->AddRef();
    *ppITypeInfo = *ppITI;
    return S_OK;
}

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    ITypeInfo *pTI;
    HRESULT hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

#ifdef DEBUG
    TCHAR szParam[MAX_PATH] = TEXT("");
    if (cNames >= 1)
        SHUnicodeToTChar(*rgszNames, szParam, ARRAYSIZE(szParam));

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif
    return hr;
}

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid, 
                                   LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, 
                                   VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE; // riid is supposed to be IID_NULL always

    IDispatch *pdisp;
    HRESULT hr = QueryInterface(m_riid, (void **)&pdisp);
    if (SUCCEEDED(hr))
    {
        //Get the ITypeInfo for lcid
        ITypeInfo *pTI;
        hr = GetTypeInfo(0, lcid, &pTI);
        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0, NULL);  //Clear exceptions
    
            // This is exactly what DispInvoke does--so skip the overhead.
            hr = pTI->Invoke(pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
        pdisp->Release();
    }
    return hr;
}

void CImpIDispatch::Exception(WORD wException)
{
    ASSERT(FALSE); // No one should call this yet
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\emailassoc.cpp ===
/*****************************************************************************\
    FILE: EmailAssoc.cpp

    DESCRIPTION:
        This file implements email to application associations.

    BryanSt 3/14/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>
#include <limits.h>         // INT_MAX
#include <commctrl.h>       // Str_SetPtr

#include "EmailAssoc.h"     // 

#ifdef FEATURE_EMAILASSOCIATIONS


todo; // Move this into AutoDiscovery.idl when we support the feature.
/*
    interface IEmailAssociations;

    cpp_quote("#ifndef __LPEMAILASSOCIATIONS_DEFINED")
    cpp_quote("#define __LPEMAILASSOCIATIONS_DEFINED")

    cpp_quote("//===================================================================")
    cpp_quote("//DESCRIPTION:")
    cpp_quote("//===================================================================")
    [
        object,
        oleautomation,
        dual,
        nonextensible,
        uuid(2154A5C4-9090-4746-A580-BF650D2404F6),        // IID_IEmailAssociations
    ]
    interface IEmailAssociations : IDispatch
    {
        //------------------------------------------------------------------
        // Pointer to an interface of this type
        //------------------------------------------------------------------
        typedef [unique] IEmailAssociations *LPEMAILASSOCIATIONS;      // For C callers

        //------------------------------------------------------------------
        // Properties
        //------------------------------------------------------------------
        [id(DISPIDAD_LENGTH), propget, SZ_DISPIDAD_GETLENGTH, displaybind, bindable] HRESULT length([retval, out] long * pnLength);
        [id(DISPIDAD_ITEM), propget, SZ_DISPIDAD_GETITEM, displaybind, bindable] HRESULT item([in] long nIndex,[retval, out] BSTR * pbstrEmailAddress);

        //------------------------------------------------------------------
        // Methods
        //------------------------------------------------------------------
    }
    cpp_quote("#endif //  __LPEMAILASSOCIATIONS_DEFINED")

    //----------------------------------------------------------------------
    // AutoDiscover Accounts Class
    //----------------------------------------------------------------------
    [
        uuid(CE682BA0-C554-43f7-99C6-2F00FE46C8BC),     // CLSID_EmailAssociations
        helpstring("Neptune AutoDiscover Accounts Class"),
    ]
    coclass EmailAssociations
    {
        [default] interface IEmailAssociations;
    };
*/


class CEmailAssociations : public CImpIDispatch
                        , public CObjectWithSite
                        , public IEmailAssociations
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEmailAssociations ***
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN long nIndex, OUT BSTR * pbstrEmailAddress);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

protected:
    CEmailAssociations();
    virtual ~CEmailAssociations(void);

    // Private Member Variables
    int                     m_cRef;
    LPWSTR                  m_pszDefault;
    HKEY                    m_hkey;


    // Private Member Functions
    HRESULT _getHkey(void);

    // Friend Functions
    friend HRESULT CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};


//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CEmailAssociations::_getHkey(void)
{
    HRESULT hr = S_OK;

    if (!m_hkey)
    {
        DWORD dwError = RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, 0, KEY_READ, &m_hkey);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//===========================
// *** IEmailAssociations Interface ***
//===========================
HRESULT CEmailAssociations::get_length(OUT long * pnLength)
{
    HRESULT hr = _getHkey();

    if (SUCCEEDED(hr))
    {
        DWORD dwError = RegQueryInfoKey(m_hkey, NULL, NULL, 0, (ULONG *) pnLength, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT CEmailAssociations::get_item(IN long nIndex, OUT BSTR * pbstrEmailAddress)
{
    HRESULT hr = _getHkey();

    *pbstrEmailAddress = NULL;
    if (SUCCEEDED(hr))
    {
        if (0 == nIndex)
        {
            if (!m_pszDefault)
            {
                TCHAR szCurrent[MAX_EMAIL_ADDRESSS];
                DWORD cb = sizeof(szCurrent);

                // We always hand out the default key for index == 0.
                DWORD dwError = RegQueryValueEx(m_hkey, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb);
                hr = HRESULT_FROM_WIN32(dwError);
                if (SUCCEEDED(hr))
                {
                    Str_SetPtr(&m_pszDefault, szCurrent);
                }
            }

            if (m_pszDefault)
            {
                hr = HrSysAllocString(m_pszDefault, pbstrEmailAddress);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            TCHAR szKeyName[MAX_PATH];
            FILETIME ftLastWriteTime;
            long nCurrent;              // Index counter
            DWORD cbSize;
            DWORD dwError;

            // populate the list
            for(nCurrent = 0;
                cbSize = ARRAYSIZE(szKeyName), dwError = RegEnumKeyEx(m_hkey, nCurrent, szKeyName, &cbSize, NULL, NULL, NULL, &ftLastWriteTime),
                    hr = HRESULT_FROM_WIN32(dwError), SUCCEEDED(hr);
                nCurrent++)
            {
                hr = E_FAIL;

                // Is this the default key?
                if (!StrCmpI(szKeyName, m_pszDefault))
                {
                    // Yes, so skip this index because we already returned it for slot zero (0).
                    nIndex++;
                }
                else
                {
                    if (nIndex == (nCurrent + 1))     // Is this the one the user wanted.
                    {
                        hr = HrSysAllocString(szKeyName, pbstrEmailAddress);
                        break;
                    }
                }
            }  // for
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
HRESULT CEmailAssociations::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEmailAssociations, IEmailAssociations),
        QITABENT(CEmailAssociations, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(DWORD) CEmailAssociations::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CEmailAssociations::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}




//===========================
// *** Class Methods ***
//===========================
CEmailAssociations::CEmailAssociations() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IEmailAssociations)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_pszDefault = NULL;
    m_hkey = NULL;

    m_cRef = 1;
}


CEmailAssociations::~CEmailAssociations()
{
    Str_SetPtr(&m_pszDefault, NULL);
    if (m_hkey)
    {
        RegCloseKey(m_hkey);
    }

    DllRelease();
}


HRESULT CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        CEmailAssociations * pmf = new CEmailAssociations();
        if (pmf)
        {
            hr = pmf->QueryInterface(riid, ppvObj);
            pmf->Release();
        }
        else
        {
            *ppvObj = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}






//////////////////////////////////////
// EmailAccount
// 
// In these cases, HKEY points to:
// HKCU, "Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>"
// 
//////////////////////////////////////
HRESULT EmailAssoc_CreateEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey)
{
    HRESULT hr;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_EXPLOREREMAIL, pszEmailAddress);
    DWORD dwError = RegCreateKeyW(HKEY_CURRENT_USER, wzRegKey, phkey);

    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        hr = EmailAssoc_GetDefaultEmailAccount(wzRegKey, ARRAYSIZE(wzRegKey));
        if (FAILED(hr))
        {
            // We don't have a default email account, so let's set this one.
            hr = EmailAssoc_SetDefaultEmailAccount(pszEmailAddress);
        }
    }

    return hr;
}


HRESULT EmailAssoc_OpenEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_EXPLOREREMAIL, pszEmailAddress);
    DWORD dwError = RegOpenKeyW(HKEY_CURRENT_USER, wzRegKey, phkey);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountProtocol(IN HKEY hkey, IN LPWSTR pszProtocol, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszProtocol[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHGetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, &dwType, (void *)pszProtocol, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountProtocol(IN HKEY hkey, IN LPCWSTR pszProtocol)
{
    DWORD cbSize = ((lstrlenW(pszProtocol) + 1) * sizeof(pszProtocol[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, REG_SZ, (void *)pszProtocol, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountWebURL(IN HKEY hkey, IN LPWSTR pszURL, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszURL[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHGetValueW(hkey, SZ_REGVALUE_MAILPROTOCOLS L"\\" SZ_REGVALUE_WEB, SZ_REGVALUE_URL, &dwType, (void *)pszURL, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountWebURL(IN HKEY hkey, IN LPCWSTR pszURL)
{
    DWORD cbSize = ((lstrlenW(pszURL) + 1) * sizeof(pszURL[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHSetValueW(hkey, SZ_REGVALUE_MAILPROTOCOLS L"\\" SZ_REGVALUE_WEB, SZ_REGVALUE_URL, REG_SZ, (void *)pszURL, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountPreferredApp(IN HKEY hkey, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","Preferred App"="<MailApp | AppID>"
    DWORD dwError = SHGetValueW(hkey, NULL, SZ_REGVALUE_PREFERREDAPP, &dwType, (void *)pszMailApp, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountPreferredApp(IN HKEY hkey, IN LPCWSTR pszMailApp)
{
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    // Set HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","Preferred App"="<MailApp | AppID>"
    DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_PREFERREDAPP, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetDefaultEmailAccount(IN LPWSTR pszProtocol, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszProtocol[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\","(default)"="<Default Email Account>"
    DWORD dwError = SHGetValueW(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, NULL, &dwType, (void *)pszProtocol, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetDefaultEmailAccount(IN LPCWSTR pszProtocol)
{
    DWORD cbSize = ((lstrlenW(pszProtocol) + 1) * sizeof(pszProtocol[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\","(default)"="<Default Email Account>"
    DWORD dwError = SHSetValueW(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, NULL, REG_SZ, (void *)pszProtocol, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}





//////////////////////////////////////
// MailApp
// 
// In these cases, HKEY points to:
// HKLM, "Software\Clients\Mail\<MailApp>"
// 
//////////////////////////////////////
HRESULT EmailAssoc_GetDefaultMailApp(IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));

    // Get HKLM,"Software\Clients\Mail","(default)"="<MailApp>"
    DWORD dwError = SHGetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, NULL, &dwType, (void *)pszMailApp, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetDefaultMailApp(IN LPCWSTR pszMailApp)
{
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    // Set HKLM,"Software\Clients\Mail","(default)"="<MailApp>"
    DWORD dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, NULL, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_OpenMailApp(IN LPCWSTR pszMailApp, OUT HKEY * phkey)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILCLIENTS, pszMailApp);

    // TODO: We may want to support HKCU based "Clients\Mail".
    DWORD dwError = RegOpenKeyW(HKEY_LOCAL_MACHINE, wzRegKey, phkey);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszAppPath[0]));
    TCHAR szCmdLine[MAX_PATH];

    szCmdLine[0] = 0;   // This is optional

    // TODO: put our values under a "AutoDiscovery" key.
    DWORD dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILPATH, &dwType, (void *)pszAppPath, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (FAILED(hr))
    {
        // TODO: Use IQueryAssociations to load the string.  Then use ShellExecuteEx() with the "Open"
        //  verb so we let them load the "Shell\Open\Command" heirarchy.

        // Fall back to HKLM, "Software\Clients\Mail\<AppName>\Shell\Open\Command, "(default)"
        cbSize = (cchSize * sizeof(pszAppPath[0]));
        dwError = SHGetValue(hkey, SZ_REGKEY_SHELLOPENCMD, NULL, &dwType, (void *)pszAppPath, &cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            PathRemoveArgs(pszAppPath);
            PathUnquoteSpaces(pszAppPath);
        }
    }

    return hr;
}


HRESULT EmailAssoc_GetAppCmdLine(IN HKEY hkey, IN LPTSTR pszCmdLine, IN DWORD cchSize)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwType;
    DWORD cbSize = sizeof(szPath);
    TCHAR szCmdLine[MAX_PATH];

    szCmdLine[0] = 0;   // This is optional

    // TODO: put our values under a "AutoDiscovery" key.
    DWORD dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILPATH, &dwType, (void *)szPath, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        cbSize = (cchSize * sizeof(pszCmdLine[0]));
        dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILCMDLINE, &dwType, (void *)pszCmdLine, &cbSize);
    }
    else
    {
        // TODO: Use IQueryAssociations to load the string.  Then use ShellExecuteEx() with the "Open"
        //  verb so we let them load the "Shell\Open\Command" heirarchy.

        // Fall back to HKLM, "Software\Clients\Mail\<AppName>\Shell\Open\Command, "(default)"
        cbSize = sizeof(szPath);
        dwError = SHGetValue(hkey, SZ_REGKEY_SHELLOPENCMD, NULL, &dwType, (void *)szPath, &cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            LPTSTR pszTempCmdLine = PathGetArgs(szPath);

            if (pszCmdLine)
            {
                StrCpyN(pszCmdLine, pszTempCmdLine, cchSize);
            }
            else
            {
                StrCpyN(pszCmdLine, TEXT(""), cchSize);
                hr = S_FALSE;
            }
        }
    }

    return hr;
}


HRESULT EmailAssoc_GetIconPath(IN HKEY hkey, IN LPTSTR pszIconPath, IN DWORD cchSize)
{
    HRESULT hr = EmailAssoc_GetAppPath(hkey, pszIconPath, cchSize);

    if (SUCCEEDED(hr))
    {
        // Get the path we will use for the icon.

        if (PathFindFileName(pszIconPath) && !StrCmpI(PathFindFileName(pszIconPath), TEXT("rundll32.exe")))
        {
            // The icon path is "Rundll32.exe" which will actually run their dll.
            // We will want to use the cmdline instead.

            hr = EmailAssoc_GetAppCmdLine(hkey, pszIconPath, cchSize);
            if (StrChr(pszIconPath, CH_COMMA))
            {
                StrChr(pszIconPath, CH_COMMA)[0] = 0; // Remove the function name.
            }

            PathUnquoteSpaces(pszIconPath);
        }
    }

    return hr;
}


BOOL EmailAssoc_DoesMailAppSupportProtocol(IN LPCWSTR pszMailApp, IN LPCWSTR pszProtocol)
{
    BOOL fSupports = FALSE;
    DWORD dwType;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
    WCHAR wzTemp[MAX_PATH];
    DWORD cbSize = sizeof(wzTemp);

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    // This key is used if the customer wants to force different apps per protocol.
    DWORD dwError = SHGetValueW(HKEY_CLASSES_ROOT, wzRegKey, pszMailApp, &dwType, (void *)wzTemp, &cbSize);
    if (ERROR_SUCCESS == dwError)
    {
        fSupports = TRUE;
    }

    return fSupports;
}


HRESULT EmailAssoc_GetFirstMailAppForProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    HRESULT hr;
    HKEY hkey;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, pszProtocol);
    DWORD dwError = RegOpenKey(HKEY_CLASSES_ROOT, wzRegKey, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        WCHAR wzTemp[MAX_PATH];
        DWORD cbSizeTemp = sizeof(wzTemp);
        DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));
        DWORD dwType;

        // Read HKCR,"MailTransport\<Protocol>\Apps","<The First Value>"="<AppName | AppID>"
        dwError = SHEnumValueW(hkey, 0, pszMailApp, &cbSize, &dwType, (void *)wzTemp, &cbSizeTemp);
        hr = HRESULT_FROM_WIN32(dwError);

        RegCloseKey(hkey);
    }

    return hr;
}






//////////////////////////////////////
// Other
//////////////////////////////////////
HRESULT EmailAssoc_CreateWebAssociation(IN LPCTSTR pszEmail, IN IMailProtocolADEntry * pMailProtocol)
{
    BSTR bstrWebBaseEmailURL;
    HRESULT hr = pMailProtocol->get_ServerName(&bstrWebBaseEmailURL);

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = EmailAssoc_CreateEmailAccount(pszEmail, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = EmailAssoc_SetEmailAccountWebURL(hkey, bstrWebBaseEmailURL);
            if (SUCCEEDED(hr))
            {
                hr = EmailAssoc_SetEmailAccountProtocol(hkey, SZ_REGDATA_WEB);
            }

            RegCloseKey(hkey);
        }

        SysFreeString(bstrWebBaseEmailURL);
    }

    return hr;
}


HRESULT EmailAssoc_CreateStandardsBaseAssociation(IN LPCTSTR pszEmail, IN LPCTSTR pszProtocol)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_CreateEmailAccount(pszEmail, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
        DWORD cbSize = ((lstrlenW(L"") + 1) * sizeof(WCHAR));

        wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGVALUE_MAILPROTOCOLS, pszProtocol);

        // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>\MailProtocols\<protocol>","(default)"=""
        DWORD dwError = SHSetValueW(hkey, wzRegKey, NULL, REG_SZ, (void *)L"", cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            WCHAR wzProtocol[MAX_PATH];

            SHTCharToUnicode(pszProtocol, wzProtocol, ARRAYSIZE(wzProtocol));
            cbSize = ((lstrlenW(SZ_REGDATA_WEB) + 1) * sizeof(SZ_REGDATA_WEB[0]));

            // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="<protocol>"
            DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, REG_SZ, (void *)wzProtocol, cbSize);
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT EmailAssoc_GetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    // This key is used if the customer wants to force different apps per protocol.
    DWORD dwError = SHGetValueW(HKEY_CLASSES_ROOT, wzRegKey, NULL, &dwType, (void *)pszMailApp, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (FAILED(hr))
    {
        // The user didn't force an app based on the protocol, so let's try the default app.
        hr = EmailAssoc_GetDefaultMailApp(pszMailApp, cchSize);

        // Lets see if the default email add supports this protocol, because we always want
        // to give preferense to the user's choosen mail app.
        if (FAILED(hr) || !EmailAssoc_DoesMailAppSupportProtocol(pszMailApp, pszProtocol))
        {
            // It doesn't support the protocol, so lets get the first app that does.
            hr = EmailAssoc_GetFirstMailAppForProtocol(pszProtocol, pszMailApp, cchSize);
        }
    }

    return hr;
}


HRESULT EmailAssoc_SetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPCWSTR pszMailApp)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    DWORD dwError = SHSetValueW(HKEY_CLASSES_ROOT, wzRegKey, NULL, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


LPCWSTR g_LegacyAssociations[][2] =
{
    {L"Outlook Express", L"POP3"},
    {L"Outlook Express", L"IMAP"},
    {L"Outlook Express", L"DAVMail"},
    {L"Microsoft Outlook", L"POP3"},
    {L"Microsoft Outlook", L"IMAP"},
    {L"Microsoft Outlook", L"MAPI"},
    {L"Eudora", L"POP3"},
    {L"Eudora", L"IMAP"},
};

// Description:
// This function will look at what applications are installed and setup the appropriate
// legacy email associations.
HRESULT EmailAssoc_InstallLegacyMailAppAssociations(void)
{
    HRESULT hr = S_OK;

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_LegacyAssociations); nIndex++)
    {
        HKEY hkey;

        // Is the app installed?
        hr = EmailAssoc_OpenMailApp(g_LegacyAssociations[nIndex][0], &hkey);
        if (SUCCEEDED(hr))
        {
            // Yes, so let's install the legacy association.

            // TODO: we should use GetFileVersionInfo() and VerQueryValue() to make sure
            //   these are legacy versions.
            //hr = EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize);

            WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

            wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, g_LegacyAssociations[nIndex][1]);
            SHSetValueW(HKEY_CLASSES_ROOT, wzRegKey, g_LegacyAssociations[nIndex][0], REG_SZ, (void *)L"", 4);

            RegCloseKey(hkey);
        }
    }

    return S_OK;        // We succeed any way because we are just trying to upgrade.
}




#endif // FEATURE_EMAILASSOCIATIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#ifndef MYGUIDS_H
#define MYGUIDS_H

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

//EXTERN_C const GUID FAR CLSID_MailBoxDeskBar;

// {ACFEEF34-7453-43ee-A6A6-8A8568FA176B} CLSID_MailBoxDeskBar
DEFINE_GUID(CLSID_MailBoxDeskBar, 0xacfeef34, 0x7453, 0x43ee, 0xa6, 0xa6, 0x8a, 0x85, 0x68, 0xfa, 0x17, 0x6b);

// NOTE: Eventually, we should move this into a \shell\published\inc\shlguid.w and publish it publicly.
// {B96D2802-4B41-4bc7-A6A4-55C5A12268CA}
DEFINE_GUID(CLSID_ACLEmailAddresses, 0xb96d2802, 0x4b41, 0x4bc7, 0xa6, 0xa4, 0x55, 0xc5, 0xa1, 0x22, 0x68, 0xca);

#undef MIDL_DEFINE_GUID

#endif // MYGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\instoxml.cpp ===
/*****************************************************************************\
    FILE: INStoXML.cpp

    DESCRIPTION:
        This code will convert an INS (internet settings) or ISP (Internet
    Service Provider) file to an Account AutoDiscovery XML file.

    BryanSt 11/8/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"

#define XML_POST_REQUEST                    L"<?xml version=\"1.0\"?>\r\n<AUTODISCOVERY Version=\"0.1\">\r\n\t<REQUEST ACCOUNTTYPE=\"EMail\" EMAIL=\"%ls\">\r\n\t</REQUEST>\r\n</AUTODISCOVERY>\r\n"

#define XML_TEMPLATE_DISPNAME               "<USER DISPLAYNAME=\"%ls\" />"
#define XML_TEMPLATE_ACCOUNT                "<?xml version=\"1.0\"?>\r\n<AUTODISCOVERY Version=\"0.1\">\r\n %hs\r\n <ACCOUNT TYPE=\"EMail\" EXPIRE=\"7\">\r\n  <PROTOCOL TYPE=\"POP3\" SERVERNAME=\"%ls\">\r\n   <AUTH>\r\n    <PASSWORD TYPE=\"%ls\" />\r\n   </AUTH>\r\n  </PROTOCOL>\r\n  <PROTOCOL TYPE=\"SMTP\" SERVERNAME=\"%ls\">\r\n   <AUTH>\r\n    <PASSWORD TYPE=\"%ls\" />\r\n   </AUTH>\r\n  </PROTOCOL>\r\n </ACCOUNT>\r\n</AUTODISCOVERY>"

#define STR_SECTION_INET_MAIL               TEXT("Internet_Mail")

#define STR_INIKEY_POP_SERVER               TEXT("POP_Server")
#define STR_INIKEY_POP_NAME                 TEXT("POP_Logon_Name")
#define STR_INIKEY_SMTP_SERVER              TEXT("SMTP_Server")
#define STR_INIKEY_AUTH_TYPE                TEXT("Logon_Using_SPA")
#define STR_INIKEY_EMAIL_NAME               TEXT("Email_Name")          // DisplayName

#define STR_TYPE_POP3                       TEXT("POP3")
#define STR_YES                             TEXT("yes")
#define STR_SPA                             TEXT("SPA")


typedef struct tagAUTODISCOVERYSETTINGS
{
    LPWSTR pwszType;
    LPWSTR pwszPOPServer;
    LPWSTR pwszPOPServerLoginName;
    LPWSTR pwszSMTPServer;
    LPWSTR pwszDisplayName;
    LPWSTR pwszAuthType;
} AUTODISCOVERYSETTINGS;



//===========================
// *** API Internals & Helpers ***
//===========================
HRESULT _GetAutoDiscSettings(LPCWSTR pwszINSFile, AUTODISCOVERYSETTINGS * pads)
{
    WCHAR wzTemp[MAX_URL_STRING];
    HRESULT hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_SERVER, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);

    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszPOPServer = StrDupW(wzTemp);
        hr = ((pads->pwszPOPServer) ? S_OK : E_OUTOFMEMORY);

        if (SUCCEEDED(hr))
        {
            pads->pwszType = StrDupW(STR_TYPE_POP3);
            hr = ((pads->pwszType) ? S_OK : E_OUTOFMEMORY);            
        }
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_NAME, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszPOPServerLoginName = StrDupW(wzTemp);
        hr = ((pads->pwszPOPServerLoginName) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_SMTP_SERVER, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszSMTPServer = StrDupW(wzTemp);
        hr = ((pads->pwszSMTPServer) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_AUTH_TYPE, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0] && StrCmpIW(wzTemp, STR_YES))
    {
        pads->pwszAuthType = StrDupW(STR_SPA);
        hr = ((pads->pwszAuthType) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_EMAIL_NAME, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszDisplayName = StrDupW(wzTemp);
        hr = ((pads->pwszDisplayName) ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT _CreateXMLFromSettings(AUTODISCOVERYSETTINGS * pads, LPSTR * ppszXML)
{
    CHAR szUserTagXML[MAX_URL_STRING];
    CHAR szAccountXML[MAX_URL_STRING * 4];
    HRESULT hr = S_OK;

    szUserTagXML[0] = 0;
    szAccountXML[0] = 0;
    if (pads->pwszDisplayName)
    {
        wnsprintfA(szUserTagXML, ARRAYSIZE(szUserTagXML), XML_TEMPLATE_DISPNAME, pads->pwszDisplayName);
    }

    // TODO: Do we need to add the POP Login Name?
    wnsprintfA(szAccountXML, ARRAYSIZE(szAccountXML), XML_TEMPLATE_ACCOUNT, szUserTagXML, pads->pwszPOPServer, pads->pwszAuthType, pads->pwszSMTPServer, pads->pwszAuthType);
    *ppszXML = StrDupA(szAccountXML);
    hr = ((*ppszXML) ? S_OK : E_OUTOFMEMORY);

    return hr;
}


HRESULT _SaveToFile(LPCWSTR pwszFileName, LPCSTR pszXML)
{
    HANDLE hFile;
    HRESULT hr = CreateFileHrWrap(pwszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);

    if (SUCCEEDED(hr))
    {
        DWORD chFSWritten;

        hr = WriteFileWrap(hFile, pszXML, lstrlenA(pszXML), &chFSWritten, NULL);
        CloseHandle(hFile);
    }

    return hr;
}


HRESULT _FreeAutoDiscSettings(AUTODISCOVERYSETTINGS * pads)
{
    if (pads->pwszType)           LocalFree(pads->pwszType);
    if (pads->pwszPOPServer)      LocalFree(pads->pwszPOPServer);
    if (pads->pwszPOPServerLoginName)   LocalFree(pads->pwszPOPServerLoginName);
    if (pads->pwszSMTPServer)     LocalFree(pads->pwszSMTPServer);
    if (pads->pwszDisplayName)    LocalFree(pads->pwszDisplayName);
    if (pads->pwszAuthType)       LocalFree(pads->pwszAuthType);

    return S_OK;
}



//===========================
// *** APIs ***
//===========================
bool IsINSFile(LPCWSTR pwszINSFile)
{
    WCHAR wzPOPServer[MAX_PATH];
    bool fIsINSFile = false;
    HRESULT hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_SERVER, L"", wzPOPServer, ARRAYSIZE(wzPOPServer), pwszINSFile);

    if (SUCCEEDED(hr) && wzPOPServer[0])
    {
        // We consider this a valid Account AutoDiscovery compatible INS/ISP
        // file if it has:
        // [Internet_Mail]
        // POP_Server=xxxxx

        fIsINSFile = true;
    }

    return fIsINSFile;
}


HRESULT ConvertINSToXML(LPCWSTR pwszINSFile)
{
    AUTODISCOVERYSETTINGS ads = {0};
    HRESULT hr = _GetAutoDiscSettings(pwszINSFile, &ads);

    if (SUCCEEDED(hr))
    {
        LPSTR pszXML;

        hr = _CreateXMLFromSettings(&ads, &pszXML);
        if (SUCCEEDED(hr))
        {
            hr = _SaveToFile(pwszINSFile, pszXML);
            LocalFree(pszXML);
        }

        _FreeAutoDiscSettings(&ads);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mailbox.h ===
/*****************************************************************************\
    FILE: MailBox.h

    DESCRIPTION:
        This file implements defines all the shares components of the MailBox
    feature.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _MAILBOX_H
#define _MAILBOX_H

#include "dllload.h"

#ifdef FEATURE_MAILBOX

// FUTURE:
// 1. Check out aeditbox.cpp, we may want to steal OLECMDID_PASTE for copy/paste
// 2. We may need CAddressEditAccessible to be accessible.

HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress);
STDAPI AddEmailAutoComplete(HWND hwndEdit);

INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);


/**************************************************************************
   CLASS: CMailBoxUI
**************************************************************************/
class CMailBoxUI : public IDockingWindow, 
                  public IInputObject, 
                  public IObjectWithSite
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    //IOleWindow methods
    STDMETHOD (GetWindow)(HWND*);
    STDMETHOD (ContextSensitiveHelp)(BOOL);

    //IDockingWindow methods
    STDMETHOD (ShowDW)(BOOL fShow);
    STDMETHOD (CloseDW)(DWORD dwReserved);
    STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

    //IInputObject methods
    STDMETHOD (UIActivateIO)(BOOL, LPMSG);
    STDMETHOD (HasFocusIO)(void);
    STDMETHOD (TranslateAcceleratorIO)(LPMSG);

    //IObjectWithSite methods
    STDMETHOD (SetSite)(IUnknown*);
    STDMETHOD (GetSite)(REFIID, LPVOID*);

    HRESULT CreateWindowMB(HWND hwndParent, HWND * phwndMailBoxUI);
    HRESULT CloseWindowMB(void);

    HRESULT GetEditboxWindow(HWND * phwndEdit);
    CMailBoxUI();
    ~CMailBoxUI();

private:
    // Private Member Variables
    DWORD m_cRef;

    IInputObjectSite *m_pSite;

    HWND m_hwndMailBoxUI;                   // The hwnd containing the editbox and the "Go" button.
    HWND m_hwndEditBox;                     // The editbox hwnd.
    HWND m_hwndGoButton;                    // The Go button hwnd.
    HIMAGELIST m_himlDefault;               // default gray-scale go button
    HIMAGELIST m_himlHot;                   // color go button

    HRESULT _CreateEditWindow(void);
    HRESULT _OnSetSize(void);

    // Private Member Functions
    LRESULT _OnKillFocus(void);
    LRESULT _OnSetFocus(void);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL _OnNotify(LPNMHDR pnm);            // Return TRUE if the message was handled.
    LRESULT _EditMailBoxSubClassWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL * pfHandled);

    HRESULT _RegisterWindow(void);
    HRESULT _CreateGoWindow(void);
    HRESULT _OnExecuteGetEmail(LPCTSTR pszEmailAddress);

    static LRESULT CALLBACK MailBoxUIWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK EditMailBoxSubClassWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
};


/***************
TODO List: Wizard (Progress & Choose App)
15. Write caching code so we don't display the progress dialog when we already know the info.
4. Write "Choose App" Page.
3. Special Case AOL.
4. Cache for 1 month.
7. Support the no-dial up case.  Is that how we handle the off-line case?


TODO List: ActiveX Control
1. Create it.
2. Write State Logic (First Time, More than 1 email Address, Options, etc.)
3. Do we want to use balloons instead?


TODO List: Associations
1. Write Interface to register
2. Pre-Populate popular Apps
3. Get MSN working.
4. Add UI to change from default.
5. Rev server to support a second protocol type.


TODO List: OE The App
11. Rev OE to have an "-email" flag to autoconfigure.
16. Add the Please Wait Animation
17. Change it to use the interface to do the async work.
18. Meet with outlook.
19. Test with Eudora, Netscape, Lotus Notes.


TODO List: Email Associations Dialog
1. Add Another "Choose Default Mail Client".
2. Let the user change Apps


TODO List: DeskBar
5. Try adding icon to "Get E-mail" deskbar toolbar.
7. Support <ESC> to undo changes.
8. Set WordBreakProc so the user can CTRL-<Arrow> between "." and "@".


TODO List: Other




DONE:
2. Persist Last Entry
5. Fix font.
6. Make Return/Enter invoke [Go] button.
1. AutoComplete Email Addresses.
10. Launch new process to do the work
1. Design UI
2. Write Wizard


================================
BUGS: 
BUGS: Wizard (Progress & Choose App)
6. We may need to UTF8 encode the string when passing it to the command line so it will support cross codepage strings.
8. Find out what type of bitmap to use. (On top or on Left?)
9. Get the finished button to work correctly.
10. Timing: Hide wizard for 2 seconds and then show for at least 4.
11. Get last page to change "Next" to "Finished".
12. Copy NetPlWiz's code to create an Icon in the tab order.
14. Replace wizard's side graphic with one that includes an email message.

BUGS: OE The App
13. Make OE respect the flag if it already has any account.  But we need to check if this specific one exists.
14. Make OE work where it will pull up the app and open the accouts page.
15. Make the waiting wizard appear for at least 2-3 seconds(?)

BUGS: DeskBar
3. Resize Doesn't work when floating.
4. Test state when moving between bars.
7. Make editbox only as tall as it needs to be.
8. On focus, select all text.
9. Make the size correct when it's the first bar and docked to the bottom.
12. The editbox should be taller in the deskbar. (Same size as combobox)
1. Support Copy/Paste
2. Support Accessible so screen readers can read the content of the editbox.

*/

#endif // FEATURE_MAILBOX
#endif // _MAILBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\instoxml.h ===
/*****************************************************************************\
    FILE: INStoXML.h

    DESCRIPTION:
        This code will convert an INS (internet settings) or ISP (Internet
    Service Provider) file to an Account AutoDiscovery XML file.

    BryanSt 11/8/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/


//===========================
// *** APIs ***
//===========================
bool IsINSFile(LPCWSTR pwszINSFile);
HRESULT ConvertINSToXML(LPCWSTR pwszINSFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mailbox.cpp ===
/*****************************************************************************\
    FILE: MailBox.cpp

    DESCRIPTION:
        This file implements the logic of the MailBox feature.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>
#include <limits.h>         // INT_MAX
#include <commctrl.h>       // Str_SetPtr

#include "wizard.h"
#include "MailBox.h"
#include "emailassoc.h"

#ifdef FEATURE_MAILBOX
#define WM_AUTODISCOVERY_FINISHED               (WM_USER + 1)

// These are the wizard control IDs for the Back, Next, and Finished buttons.
#define IDD_WIZARD_BACK_BUTTON                0x3023
#define IDD_WIZARD_NEXT_BUTTON                0x3024
#define IDD_WIZARD_FINISH_BUTTON              0x3025



/**************************************************************************
   CLASS: CMailBoxProcess
**************************************************************************/
class CMailBoxProcess : public IUnknown
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    HRESULT ParseCmdLine(LPTSTR lpCmdLine);
    HRESULT Run(void);

    CMailBoxProcess();
    ~CMailBoxProcess();

private:
    // Private Member Variables
    DWORD m_cRef;

    TCHAR m_szEmailAddress[MAX_EMAIL_ADDRESSS];
    TCHAR m_szNextText[MAX_PATH];
    BOOL m_fAutoDiscoveryFailed;            // Did the AutoDiscovery process fail?
    LPTSTR m_pszMailApp;                    // Which app was chosen?
    LPTSTR m_pszURL;                        // Which URL should be used to read mail?
    HWND m_hwndDialog;
    HRESULT m_hr;
    IMailAutoDiscovery * m_pMailAutoDiscovery;
    BOOL m_fGetDefaultAccount;              // If yes, open to wizard page asking for email address.
    BOOL m_fShowGetEmailAddressPage;        // Do we want to show the get email address wizard page?
    BOOL m_fCreateNewEmailAccount;          // Does the user want to create a new email account (like on one of the free email servers: hotmail, yahoo, etc.)

    // Private Member Functions
    HRESULT _DisplayDialogAndAutoDiscover(void);
    HRESULT _OpenWebBasedEmail(HKEY hkey);
    HRESULT _OpenExeBasedEmailApp(IN LPCWSTR pszMailApp);
    HRESULT _OpenProprietaryEmailApp(IN BSTR bstrProtocol, IN IMailProtocolADEntry * pMailProtocol);
    HRESULT _OpenEmailApp(void);
    HRESULT _RestoreNextButton(void);
    HRESULT _FillListWithApps(HWND hwndList);
    HRESULT _OnGetDispInfo(LV_DISPINFO * pDispInfo, bool fUnicode);
    HRESULT _OnChooseAppListFocus(void);
    HRESULT _OnChooseAppURLFocus(void);
    HRESULT _OnAppListSelection(LPNMLISTVIEW pListview);

    INT_PTR _MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnInit(HWND hDlg);
    INT_PTR _OnInitChooseApp(HWND hDlg);
    INT_PTR _OnUserCancelled(void);
    INT_PTR _OnFinished(HRESULT hr, BSTR bstrXML);
    INT_PTR _OnGetEmailAddressNext(void);
    INT_PTR _OnCommand(WPARAM wParam, LPARAM lParam);
    INT_PTR _OnFinishedManualAssociate(void);

    friend INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

typedef struct tagEMAILCLIENT
{
    LPTSTR pszFriendlyName;
    LPTSTR pszPath;
    LPTSTR pszCmdLine;
    LPTSTR pszIconPath;
    LPTSTR pszEmailApp;
} EMAILCLIENT;





//===========================
// *** Class Internals & Helpers ***
//===========================
BOOL IsWhitespace(TCHAR Char)
{
    return ((Char == TEXT(' ')) || (Char == TEXT('\t')));
}


LPTSTR APIENTRY SkipWhite(LPTSTR pszString)
{
  while (pszString[0] && IsWhitespace(pszString[0]))
  {
      pszString = CharNext(pszString);
  }

  return pszString;
}


BOOL IsFlagSpecified(IN LPCTSTR pwzFlag, IN LPCTSTR pszArg)
{
    BOOL fIsFlagSpecified = FALSE;

    if ((TEXT('/') == pszArg[0]) ||
        (TEXT('-') == pszArg[0]))
    {
        if ((0 == StrCmpI(pwzFlag, &pszArg[1])) ||
            ((0 == StrCmpNI(pwzFlag, &pszArg[1], lstrlen(pwzFlag))) &&
             (IsWhitespace(pszArg[lstrlen(pwzFlag) + 1])) ) )
        {
            fIsFlagSpecified = TRUE;
        }
    }

    return fIsFlagSpecified;
}


LPTSTR GetNextArgument(LPTSTR pszCmdLine)
{
    pszCmdLine = StrChr(pszCmdLine, TEXT(' '));

    if (pszCmdLine)
    {
        pszCmdLine = SkipWhite(pszCmdLine);
    }

    return pszCmdLine;
}


void FreeEmailClient(EMAILCLIENT * pEmailClient)
{
    if (pEmailClient)
    {
        Str_SetPtr(&pEmailClient->pszFriendlyName, NULL);
        Str_SetPtr(&pEmailClient->pszPath, NULL);
        Str_SetPtr(&pEmailClient->pszCmdLine, NULL);
        Str_SetPtr(&pEmailClient->pszIconPath, NULL);
        Str_SetPtr(&pEmailClient->pszEmailApp, NULL);

        LocalFree(pEmailClient);
    }
}


HRESULT CMailBoxProcess::_DisplayDialogAndAutoDiscover(void)
{
    HWND hwndParent = NULL; // Do we need a parent?

    ATOMICRELEASE(m_pMailAutoDiscovery);
    m_fShowGetEmailAddressPage = (m_szEmailAddress[0] ? FALSE : TRUE);
    DisplayMailBoxWizard((LPARAM)this, m_fShowGetEmailAddressPage);

    HRESULT hr = m_hr;
    if (SUCCEEDED(hr))
    {
        // Create account.
        hr = E_FAIL;
        long nSize;

        // Loop thru the list looking for the first instance of a protocol
        // that we support.
        if (m_pMailAutoDiscovery)
        {
            hr = m_pMailAutoDiscovery->get_length(&nSize);
            if (SUCCEEDED(hr))
            {
                VARIANT varIndex;
                IMailProtocolADEntry * pMailProtocol = NULL;

                hr = E_FAIL;
                varIndex.vt = VT_I4;

                for (long nIndex = 0; (nIndex < nSize); nIndex++)
                {
                    varIndex.lVal = nIndex;
                    if (SUCCEEDED(m_pMailAutoDiscovery->get_item(varIndex, &pMailProtocol)))
                    {
                        BSTR bstrProtocol;
                        hr = pMailProtocol->get_Protocol(&bstrProtocol);

                        if (SUCCEEDED(hr))
                        {
                            // Is this protocol one of the ones we support?
                            if (!StrCmpIW(bstrProtocol, STR_PT_WEBBASED))
                            {
                                SysFreeString(bstrProtocol);
                                hr = EmailAssoc_CreateWebAssociation(m_szEmailAddress, pMailProtocol);
                                break;
                            }

                            // Is this protocol one of the ones we support?
                            if (!StrCmpIW(bstrProtocol, STR_PT_POP) || 
                                !StrCmpIW(bstrProtocol, STR_PT_IMAP) || 
                                !StrCmpIW(bstrProtocol, STR_PT_DAVMAIL))
                            {
                                hr = EmailAssoc_CreateStandardsBaseAssociation(m_szEmailAddress, bstrProtocol);
                                if (SUCCEEDED(hr))
                                {
                                    SysFreeString(bstrProtocol);
                                    break;
                                }
                            }

                            hr = _OpenProprietaryEmailApp(bstrProtocol, pMailProtocol);
                            SysFreeString(bstrProtocol);
                            if (SUCCEEDED(hr))
                            {
                                break;
                            }
                        }

                        ATOMICRELEASE(pMailProtocol);
                    }
                }

                ATOMICRELEASE(pMailProtocol);
            }
        }

        // We may have failed up until now because AutoDiscovery failed or was skipped,
        // but the user may have selected an app from the list.
        if (FAILED(hr))
        {
            if (m_pszMailApp)
            {
                HKEY hkey;

                hr = EmailAssoc_CreateEmailAccount(m_szEmailAddress, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = EmailAssoc_SetEmailAccountPreferredApp(hkey, m_pszMailApp);
                    RegCloseKey(hkey);
                }
            }
            else if (m_pszURL && m_pszURL[0])
            {
                HKEY hkey;

                hr = EmailAssoc_CreateEmailAccount(m_szEmailAddress, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = EmailAssoc_SetEmailAccountProtocol(hkey, SZ_REGDATA_WEB);
                    if (SUCCEEDED(hr))
                    {
                        hr = EmailAssoc_SetEmailAccountWebURL(hkey, m_pszURL);
                    }

                    RegCloseKey(hkey);
                }
            }
        }
    }

    return hr;
}


INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_MailBoxProgressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CMailBoxProcess::_MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        fHandled = _OnInit(hDlg);
        break;

    case WM_AUTODISCOVERY_FINISHED:
        fHandled = _OnFinished((HRESULT)wParam, (BSTR)lParam);
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case LVN_GETDISPINFO:
            wMsg++;
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), ((TRUE == m_fShowGetEmailAddressPage) ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_NEXT));
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZBACK:
            fHandled = TRUE; // Return zero to allow the user to go to the next page.
            break;

        case PSN_WIZNEXT:
            m_hr = S_FALSE;
            _RestoreNextButton();
            fHandled = 0; // Return zero to allow the user to go to the next page.
            break;

        case PSN_QUERYCANCEL:
            _OnUserCancelled();
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
    }

    default:
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d) WM_NOTIFY", wMsg);
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_ChooseAppDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CMailBoxProcess::_OnChooseAppURLFocus(void)
{
    HWND hwndURLEditbox = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_WEBURL_EDIT);

    // Something happened to cause to have us shift into the "Other:" case.
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO, BST_CHECKED);   // Uncheck the Web radio button
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_OTHERAPP_RADIO, BST_UNCHECKED);   // Uncheck the Web radio button

    SetFocus(hwndURLEditbox);
    return S_OK;
}


INT_PTR CMailBoxProcess::_OnFinishedManualAssociate(void)
{
    // TODO: Only succeed the finished part if something is selected in the app list.
    //    Also gray out the button.
    m_hr = S_OK;

    // Did the user manually configure via "Web" or an app?
    
    if (IsDlgButtonChecked(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO))
    {
        // Web.  So save the URL.
        TCHAR szURL[MAX_URL_STRING];

        GetWindowText(GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_WEBURL_EDIT), szURL, ARRAYSIZE(szURL));
        Str_SetPtr(&m_pszURL, szURL);
        Str_SetPtr(&m_pszMailApp, NULL);
    }

    return FALSE; // FALSE mean means allow it to close. TRUE means keep it open.
}

HRESULT CMailBoxProcess::_OnAppListSelection(LPNMLISTVIEW pListview)
{
    LPTSTR pszNewApp = NULL;        // None selected.

    // The user choose from the list.  So store the name of the app
    if (pListview && (-1 != pListview->iItem))
    {
        HWND hwndList = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_APPLIST);
        LVITEM pItem = {0};

        pItem.iItem = pListview->iItem;
        pItem.iSubItem = pListview->iSubItem;
        pItem.mask = LVIF_PARAM;

        if (ListView_GetItem(hwndList, &pItem))
        {
            EMAILCLIENT * pEmailClient = (EMAILCLIENT *) pItem.lParam;

            if (pEmailClient)
            {
                pszNewApp = pEmailClient->pszEmailApp;
            }
        }
    }

    Str_SetPtr(&m_pszMailApp, pszNewApp);
    return S_OK;
}


HRESULT CMailBoxProcess::_OnChooseAppListFocus(void)
{
    HWND hwndAppList = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_APPLIST);

    // Something happened to cause to have us shift into the "Other:" case.
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO, BST_UNCHECKED);   // Uncheck the Web radio button
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_OTHERAPP_RADIO, BST_CHECKED);   // Uncheck the Web radio button

    SetFocus(hwndAppList);
    return S_OK;
}


INT_PTR CMailBoxProcess::_ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        fHandled = _OnInitChooseApp(hDlg);
        PropSheet_SetWizButtons(GetParent(hDlg), ((TRUE == m_fShowGetEmailAddressPage) ? (PSWIZB_BACK | PSWIZB_FINISH) : PSWIZB_FINISH));
        break;

    case WM_COMMAND:
        fHandled = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        int idEvent = pnmh->code;

        switch (idEvent)
        {
        case LVN_GETDISPINFOA:
            _OnGetDispInfo((LV_DISPINFO *)lParam, false);
            break;

        case LVN_GETDISPINFOW:
            _OnGetDispInfo((LV_DISPINFO *)lParam, true);
            break;

        case LVN_DELETEITEM:
            if (lParam)
            {
                FreeEmailClient((EMAILCLIENT *) ((NM_LISTVIEW *)lParam)->lParam);
            }
            break;

        case LVN_ITEMCHANGED:
            _OnChooseAppListFocus();
            _OnAppListSelection((LPNMLISTVIEW) lParam); // Keep track of the last selected item.
            break;

        case LVN_ITEMACTIVATE:
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_BACK | PSWIZB_FINISH));
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZBACK:
            // Set the prev. page to show
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) 0);
            fHandled = -1;
            break;

        case PSN_WIZFINISH:
            fHandled = _OnFinishedManualAssociate();
            break;

        case PSN_QUERYCANCEL:
            m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
// TODO: 
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_ChooseAppDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
        break;
    }

    default:
        fHandled = FALSE;   // Not handled
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_ChooseAppDialogProc(wMsg = %d)", wMsg);
        break;
    }

    return fHandled;
}


HRESULT CMailBoxProcess::_RestoreNextButton(void)
{
    HWND hwndNextButton = GetDlgItem(GetParent(m_hwndDialog), IDD_WIZARD_NEXT_BUTTON);

    if (hwndNextButton && m_szNextText[0])
    {
        SetWindowText(hwndNextButton, m_szNextText);
    }

    return S_OK;
}


INT_PTR CMailBoxProcess::_OnInit(HWND hDlg)
{
    BOOL fHandled = FALSE;   // Not handled
    HWND hwndWizard = GetParent(hDlg);
    TCHAR szSkipButton[MAX_PATH];
    HWND hwndNextButton = GetDlgItem(GetParent(hDlg), IDD_WIZARD_NEXT_BUTTON);

    m_hwndDialog = hDlg;
    if (hwndNextButton &&
        GetWindowText(hwndNextButton, m_szNextText, ARRAYSIZE(m_szNextText)))
    {
        // First, change the "Next" button into "Skip"
        // Save the text on the next button before we rename it.
        LoadString(HINST_THISDLL, IDS_SKIP_BUTTON, szSkipButton, ARRAYSIZE(szSkipButton));
        // Set the next text.
        SetWindowText(hwndNextButton, szSkipButton);
    }

    // Set Animation.
    HWND hwndAnimation = GetDlgItem(hDlg, IDC_AUTODISCOVERY_ANIMATION);
    if (hwndAnimation)
    {
        Animate_OpenEx(hwndAnimation, HINST_THISDLL, IDA_DOWNLOADINGSETTINGS);
    }

    // Start the background task.
    m_hr = CMailAccountDiscovery_CreateInstance(NULL, IID_PPV_ARG(IMailAutoDiscovery, &m_pMailAutoDiscovery));
    if (SUCCEEDED(m_hr))
    {
        m_hr = m_pMailAutoDiscovery->WorkAsync(hDlg, WM_AUTODISCOVERY_FINISHED);
        if (SUCCEEDED(m_hr))
        {
            m_hr = m_pMailAutoDiscovery->DiscoverMail(m_szEmailAddress);
        }
    }

    if (FAILED(m_hr))
    {
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD wMsg = HIWORD(wParam);
    WORD idCtrl = LOWORD(wParam);

    switch (idCtrl)
    {
        case IDC_CHOOSEAPP_WEBURL_EDIT:
            switch (wMsg)
            {
                case EN_SETFOCUS:
                case STN_CLICKED:
                    _OnChooseAppURLFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        case IDC_CHOOSEAPP_WEB_RADIO:
            switch (wMsg)
            {
                case BN_CLICKED:
                    _OnChooseAppURLFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        case IDC_CHOOSEAPP_OTHERAPP_RADIO:
            switch (wMsg)
            {
                case BN_CLICKED:
                    _OnChooseAppListFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        default:
            //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
            break;
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnInitChooseApp(HWND hDlg)
{
    BOOL fHandled = FALSE;   // Not handled
    HWND hwndWizard = GetParent(hDlg);
    HWND hwndURLEditbox = GetDlgItem(hDlg, IDC_CHOOSEAPP_WEBURL_EDIT);

    m_hwndDialog = hDlg;
    // TODO: 2) Handle someone changing the combox box.

    LPCTSTR pszDomain = StrChr(m_szEmailAddress, CH_EMAIL_AT);
    if (pszDomain)
    {
        TCHAR szDesc[MAX_URL_STRING];

        pszDomain = CharNext(pszDomain);    // Skip past the "@"
        // Update the description on the dialog if the download failed.
        if (m_fAutoDiscoveryFailed)
        {
            TCHAR szTemplate[MAX_URL_STRING];

            LoadString(HINST_THISDLL, IDS_CHOOSEAPP_FAILED_RESULTS, szTemplate, ARRAYSIZE(szTemplate));
            wnsprintf(szDesc, ARRAYSIZE(szDesc), szTemplate, pszDomain);
            SetWindowText(GetDlgItem(hDlg, IDC_CHOOSEAPP_DESC), szDesc);
        }

        wnsprintf(szDesc, ARRAYSIZE(szDesc), TEXT("http://www.%s/"), pszDomain);
        SetWindowText(hwndURLEditbox, szDesc);
    }

    // Populate the List of Apps
    HWND hwndList = GetDlgItem(hDlg, IDC_CHOOSEAPP_APPLIST);

    if (hwndList)
    {
        HIMAGELIST himlLarge;
        HIMAGELIST himlSmall;

        if (Shell_GetImageLists(&himlLarge, &himlSmall))
        {
            RECT rc;
            LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};

            ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
            ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);

            GetWindowRect(hwndList, &rc);
            col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL) - (4 * GetSystemMetrics(SM_CXEDGE));
            ListView_InsertColumn(hwndList, 0, &col);

            _FillListWithApps(hwndList);
// TODO: 1) On select in the list, force "Other:" to be checked.  2) If editbox changes, set "Web:"
        }
    }

    // Choose the Web Radio button because that will be the default.
    // (Most email systems tend to use web based)
    _OnChooseAppURLFocus();
    Edit_SetSel(hwndURLEditbox, 0, -1);

    return fHandled;
}


HRESULT _AddEmailClientToList(HWND hwndList, HKEY hkey, LPCTSTR pszMailApp, LPCTSTR pszFriendlyName)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = EmailAssoc_GetAppPath(hkey, szPath, ARRAYSIZE(szPath));

    if (SUCCEEDED(hr))
    {
        TCHAR szCmdLine[MAX_PATH];
        
        hr = EmailAssoc_GetAppCmdLine(hkey, szCmdLine, ARRAYSIZE(szCmdLine));
        if (SUCCEEDED(hr))
        {
            // Get the path we will use for the icon.
            TCHAR szIconPath[MAX_PATH];

            hr = EmailAssoc_GetIconPath(hkey, szIconPath, ARRAYSIZE(szIconPath));
            if (SUCCEEDED(hr))
            {
                EMAILCLIENT * pEmailClient = (EMAILCLIENT *) LocalAlloc(LPTR, sizeof(*pEmailClient));

                if (pEmailClient)
                {
                    if (PathFileExists(szIconPath))
                    {
                        // TODO: Add a separate reg value for icon in the new case.
                        Str_SetPtr(&pEmailClient->pszIconPath, szIconPath);
                    }

                    // TODO: We may want to use the dll's version resource because it
                    //   has a product description which may be localized.
                    Str_SetPtr(&pEmailClient->pszFriendlyName, pszFriendlyName);
                    Str_SetPtr(&pEmailClient->pszEmailApp, pszMailApp);
                    if (pEmailClient->pszFriendlyName)
                    {
                        Str_SetPtr(&pEmailClient->pszPath, szPath);
                        if (pEmailClient->pszPath)
                        {
                            if (szCmdLine[0])
                            {
                                Str_SetPtr(&pEmailClient->pszCmdLine, szCmdLine);
                            }

                            LV_ITEM item = {0};

                            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                            item.iItem = INT_MAX;
                            item.iSubItem = 0;
                            item.state = 0;
                            item.iImage = I_IMAGECALLBACK;
                            item.pszText = pEmailClient->pszFriendlyName;
                            item.lParam = (LPARAM)pEmailClient;

                            if (-1 == ListView_InsertItem(hwndList, &item))
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (FAILED(hr))
                    {
                        FreeEmailClient(pEmailClient);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}


HRESULT CMailBoxProcess::_FillListWithApps(HWND hwndList)
{
    HRESULT hr = S_OK;
    HKEY hkey;

    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, 0, KEY_READ, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        TCHAR szFriendlyName[MAX_PATH];
        TCHAR szKeyName[MAX_PATH];
        TCHAR szCurrent[MAX_PATH];  // Nuke?
        TCHAR szFriendlyCurrent[MAX_PATH];
        FILETIME ftLastWriteTime;
        DWORD nIndex;              // Index counter
        DWORD cb;
        DWORD nSelected = 0;

        // find the currently selected client
        cb = sizeof(szCurrent);
        dwError = RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb);
        hr = HRESULT_FROM_WIN32(dwError);
        if (FAILED(hr))
        {
            // if not found then blank the friendly name and keyname.
            szCurrent[0] = 0;
            szFriendlyCurrent[0] = 0;
        }

        // populate the list
        for(nIndex = 0;
            cb = ARRAYSIZE(szKeyName), dwError = RegEnumKeyEx(hkey, nIndex, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime), hr = HRESULT_FROM_WIN32(dwError), SUCCEEDED(hr);
            nIndex++)
        {
            HKEY hkeyClient;

            // get the friendly name of the client
            dwError = RegOpenKeyEx(hkey, szKeyName, 0, KEY_READ, &hkeyClient);
            hr = HRESULT_FROM_WIN32(dwError);
            if (SUCCEEDED(hr))
            {
                cb = sizeof(szFriendlyName);

                dwError = RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb);
                hr = HRESULT_FROM_WIN32(dwError);
                if (SUCCEEDED(hr))
                {
                    hr = _AddEmailClientToList(hwndList, hkeyClient, szKeyName, szFriendlyName);

                    // check to see if it's the current default
                    if (!StrCmp(szKeyName, szCurrent))
                    {
                        // save its the friendly name which we'll use later to
                        // select the current client and what index it is.
                        StrCpyN(szFriendlyCurrent, szFriendlyName, ARRAYSIZE(szFriendlyCurrent));
                        nSelected = nIndex;
                    }
                }

                // close key
                RegCloseKey(hkeyClient);
            }

        }   // for

        //  use a custom sort to delay the friendly names being used
//        ListView_SortItems(hwndList, _CompareApps, 0);

        // Lets select the appropriate entre.
        ListView_SetItemState(hwndList, nSelected, LVNI_FOCUSED, LVNI_SELECTED);

        // close the keys
        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OnGetDispInfo(LV_DISPINFO * pDispInfo, bool fUnicode)
{
    HRESULT hr = S_OK;

    if (pDispInfo && pDispInfo->item.mask & LVIF_IMAGE)
    {
        EMAILCLIENT * pEmailClient = (EMAILCLIENT *) pDispInfo->item.lParam;

        if (pEmailClient)
        {
            pDispInfo->item.iImage = -1;

            if (pEmailClient->pszIconPath)
            {
                pDispInfo->item.iImage = Shell_GetCachedImageIndex(pEmailClient->pszIconPath, 0, 0);
            }

            if (-1 == pDispInfo->item.iImage)
            {
                pDispInfo->item.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_APPLICATION, 0);
            }

            if (-1 != pDispInfo->item.iImage)
            {
                pDispInfo->item.mask = LVIF_IMAGE;
            }
        }
    }

    return hr;
}


INT_PTR CMailBoxProcess::_OnUserCancelled(void)
{
    m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // Means user cancelled
    _RestoreNextButton();

    return FALSE;   // Not handled
}



INT_PTR CMailBoxProcess::_OnFinished(HRESULT hr, BSTR bstrXML)
{
    SysFreeString(bstrXML);

    _RestoreNextButton();

    m_hr = hr;   // whatever the success value was...
    if (S_OK == m_hr)
    {
        // We succeeded so we can end the dialog
        PropSheet_PressButton(GetParent(m_hwndDialog), PSBTN_FINISH);
    }
    else
    {
        // The results came back but we can't continue.  So advance
        // to the Choose App page.
        m_fAutoDiscoveryFailed = TRUE;
        PropSheet_PressButton(GetParent(m_hwndDialog), PSBTN_NEXT);
    }

    return TRUE;   // handled
}


INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_GetEmailAddressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CMailBoxProcess::_GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        m_hwndDialog = hDlg;
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZNEXT:
            fHandled = _OnGetEmailAddressNext();
            break;

        case PSN_QUERYCANCEL:
            m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // Means user cancelled
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
    }

    default:
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d) WM_NOTIFY", wMsg);
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnGetEmailAddressNext(void)
{
    BOOL fCancel = TRUE;

    GetWindowText(GetDlgItem(m_hwndDialog, IDC_GETEMAILADDRESS_EDIT), m_szEmailAddress, ARRAYSIZE(m_szEmailAddress));
    if (m_szEmailAddress[0] && StrChr(m_szEmailAddress, CH_EMAIL_AT))
    {
        // Looks valid to me.
        fCancel = 0;

        // TODO: Add more verification code
    }

    return fCancel; // 0 mean means allow it to close. TRUE means keep it open.
}


HRESULT CMailBoxProcess::_OpenEmailApp(void)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_OpenEmailAccount(m_szEmailAddress, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR wzPreferredApp[MAX_PATH];

        // Did the user customize the app for this Email address? (Default is no)
        hr = EmailAssoc_GetEmailAccountPreferredApp(hkey, wzPreferredApp, ARRAYSIZE(wzPreferredApp));
        if (SUCCEEDED(hr))
        {
            // Yes, so let's launch that app.
            hr = _OpenExeBasedEmailApp(wzPreferredApp);
        }
        else
        {
            WCHAR wzProtocol[MAX_PATH];

            hr = EmailAssoc_GetEmailAccountProtocol(hkey, wzProtocol, ARRAYSIZE(wzProtocol));
            if (SUCCEEDED(hr))
            {
                // No, but that's fine because it's the default.
                if (!StrCmpIW(wzProtocol, SZ_REGDATA_WEB))
                {
                    hr = _OpenWebBasedEmail(hkey);
                }
                else
                {
                    hr = EmailAssoc_GetEmailAccountGetAppFromProtocol(wzProtocol, wzPreferredApp, ARRAYSIZE(wzPreferredApp));
                    if (SUCCEEDED(hr))
                    {
                        hr = _OpenExeBasedEmailApp(wzPreferredApp);
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenWebBasedEmail(HKEY hkey)
{
    WCHAR wzURL[MAX_URL_STRING];
    HRESULT hr = EmailAssoc_GetEmailAccountWebURL(hkey, wzURL, ARRAYSIZE(wzURL));

    if (0 == wzURL[0])
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // TODO: In the future, we can get more information from get_PostHTML().  With
        //     that information, we can either:
        // 1. Do an HTTP POST with header data that will simmulate logging into the server.
        //    This is good except that we need the password.
        // 2. We can put form value/data pair information into an pidl created from the URL.
        //    We can then have the browser pull this information out and pre-populate form
        //    items.  This will pre-populate the "User:" form item.  This way the user
        //    only needs to enter their password.
        hr = HrShellExecute(NULL, NULL, wzURL, NULL, NULL, SW_SHOW);
        if (SUCCEEDED(hr))
        {
            AddEmailToAutoComplete(m_szEmailAddress);
        }
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenExeBasedEmailApp(IN LPCWSTR pszMailApp)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_OpenMailApp(pszMailApp, &hkey);

    // TODO: Call _InstallLegacyAssociations() to make sure the associations are correct.
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_URL_STRING];

        hr = EmailAssoc_GetAppPath(hkey, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            TCHAR szCmdLine[MAX_URL_STRING];

            szCmdLine[0] = 0;
            if (SUCCEEDED(EmailAssoc_GetAppCmdLine(hkey, szCmdLine, ARRAYSIZE(szCmdLine))) &&  // optional
                !StrStrI(SZ_TOKEN_EMAILADDRESS, szCmdLine))
            {
                // They have a cmdline and they want us to replace a token.
                StrReplaceToken(SZ_TOKEN_EMAILADDRESS, m_szEmailAddress, szCmdLine, ARRAYSIZE(szCmdLine));
            }

            hr = HrShellExecute(NULL, NULL, szPath, (szCmdLine[0] ? szCmdLine : NULL), NULL, SW_SHOW);
            if (SUCCEEDED(hr))
            {
                AddEmailToAutoComplete(m_szEmailAddress);
            }
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenProprietaryEmailApp(BSTR bstrProtocol, IMailProtocolADEntry * pMailProtocol)
{
    HRESULT hr = E_FAIL;

    // TODO:
    MessageBox(NULL, TEXT("Open Proprietary Email App here.  We look up in the registry for these types of apps.  AOL, MSN, Compuserv are examples."), TEXT("Looser"), MB_OK);

    return hr;
}





//===========================
// *** Public Methods ***
//===========================
HRESULT CMailBoxProcess::ParseCmdLine(LPTSTR pszCmdLine)
{
    // We don't treat quote sections as blocks.
    PathUnquoteSpaces(pszCmdLine);

    while (pszCmdLine && pszCmdLine[0])
    {
        if (IsFlagSpecified(TEXT("email"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            if (pszCmdLine)
            {
                if ((TEXT('/') == pszCmdLine[0]) || (TEXT('-') == pszCmdLine[0]))
                {
                }
                else
                {
                    LPTSTR pszEndOfEmailAddress = StrChr(pszCmdLine, TEXT(' '));
                    SIZE_T cchSizeToCopy = ARRAYSIZE(m_szEmailAddress);

                    if (pszEndOfEmailAddress && (cchSizeToCopy > (SIZE_T)(pszEndOfEmailAddress - pszCmdLine)))
                    {
                        cchSizeToCopy = (pszEndOfEmailAddress - pszCmdLine) + 1;
                    }

                    StrCpyN(m_szEmailAddress, pszCmdLine, (int)cchSizeToCopy);
                    pszCmdLine = GetNextArgument(pszCmdLine);
                }
            }
            continue;
        }

        if (IsFlagSpecified(TEXT("GetDefaultAccount"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            m_fGetDefaultAccount = TRUE;
            continue;
        }

        if (IsFlagSpecified(TEXT("CreateNewEmailAccount"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            m_fCreateNewEmailAccount = TRUE;
            continue;
        }

        pszCmdLine = GetNextArgument(pszCmdLine);
    }

    return S_OK;
}


HRESULT CMailBoxProcess::Run(void)
{
    HRESULT hr = CoInitialize(0);

    if (SUCCEEDED(hr))
    {
        if (TRUE == m_fCreateNewEmailAccount)
        {
            // TODO: look in the registry for the default email account and
            //   copy it into m_szEmailAddress.
            MessageBox(NULL, TEXT("Create New Email Account"), TEXT("TODO: Add code here."), MB_OK);
        }
        else
        {
            if (TRUE == m_fGetDefaultAccount)
            {
                // If the caller wants to use the default email address, then look in the registry
                // for it and use that address.
                if (FAILED(EmailAssoc_GetDefaultEmailAccount(m_szEmailAddress, ARRAYSIZE(m_szEmailAddress))))
                {
                    m_szEmailAddress[0] = 0;
                }
            }

            // Legacy email applications didn't install email associations, so we
            // do that for them now.
            EmailAssoc_InstallLegacyMailAppAssociations();

            if (m_szEmailAddress[0])
            {
                // Since we know the email address, try to open it now.
                // (We will see if the associations are installed)
                hr = _OpenEmailApp();
            }
            else
            {
                hr = E_FAIL;
            }

            if (FAILED(hr))
            {
                hr = _DisplayDialogAndAutoDiscover();
                if (SUCCEEDED(hr))  // If we got the protocol, then open the app
                {
                    hr = _OpenEmailApp();
                }

                ATOMICRELEASE(m_pMailAutoDiscovery);
            }
        }
    }
    else
    {
            CoUninitialize();
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxProcess::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CMailBoxProcess, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxProcess::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxProcess::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
CMailBoxProcess::CMailBoxProcess()
{
    DllAddRef();

    m_szNextText[0] = 0;
    m_szEmailAddress[0] = 0;
    m_fAutoDiscoveryFailed = FALSE;
    m_hwndDialog = NULL;
    m_pMailAutoDiscovery = NULL;
    m_pszMailApp = NULL;
    m_pszURL = NULL;

    m_fGetDefaultAccount = FALSE;
    m_fShowGetEmailAddressPage = FALSE;
    m_fCreateNewEmailAccount = FALSE;

    _InitComCtl32();    // So we can use the ICC_ANIMATE_CLASS common controls.

    m_cRef = 1;
}

CMailBoxProcess::~CMailBoxProcess()
{
    ATOMICRELEASE(m_pMailAutoDiscovery);
    Str_SetPtr(&m_pszMailApp, NULL);
    Str_SetPtr(&m_pszURL, NULL);

    DllRelease();
}







//===========================
// *** Non-Class Functons ***
//===========================
int AutoDiscoverAndOpenEmail(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_EMAIL_ADDRESSS];

    szCmdLine[0] = 0;
    if (lpCmdLine)
    {
        // TODO: Either support Unicode or tounel thru UTF8
        SHAnsiToTChar((LPCSTR)lpCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    }

    CMailBoxProcess mailboxProcess;

    if (SUCCEEDED(mailboxProcess.ParseCmdLine(szCmdLine)))
    {
        mailboxProcess.Run();
    }

    return 0;
}



#else // FEATURE_MAILBOX
int AutoDiscoverAndOpenEmail(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    return 0;
}

#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mailprotocol.h ===
/*****************************************************************************\
    FILE: MailProtocol.h

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 2/15/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_MAILPROTOCOL
#define _FILE_H_MAILPROTOCOL

#include <cowsite.h>
#include <atlbase.h>

HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol);


class CMailProtocol             : public CImpIDispatch
                                , public IMailProtocolADEntry
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IMailProtocolADEntry ***
    virtual STDMETHODIMP get_Protocol(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_ServerName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_ServerPort(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_LoginName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_PostHTML(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_UseSSL(OUT VARIANT_BOOL * pfUseSSL);
    virtual STDMETHODIMP get_IsAuthRequired(OUT VARIANT_BOOL * pfIsAuthRequired);
    virtual STDMETHODIMP get_UseSPA(OUT VARIANT_BOOL * pfUseSPA);
    virtual STDMETHODIMP get_SMTPUsesPOP3Auth(OUT VARIANT_BOOL * pfUsePOP3Auth);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CMailProtocol();
    virtual ~CMailProtocol(void);

    HRESULT _Parse(IN IXMLDOMNode * pXMLNodeProtocol);


    // Private Member Variables
    int                     m_cRef;

    BSTR                    m_bstrProtocol;
    BSTR                    m_bstrServerName;
    BSTR                    m_bstrServerPort;
    BSTR                    m_bstrLoginName;
    BSTR                    m_bstrPostXML;
    BOOL                    m_fUseSSL;
    BOOL                    m_fRequiresAuth;            // Mainly for SMTP.  Is Authentication required to connect to the server?
    BOOL                    m_fUseSPA;
    BOOL                    m_fUsePOPAuth;              // Get the auth settings from the POP protocol?
    

    // Friend Functions
    friend HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol);
};


#endif // _FILE_H_MAILPROTOCOL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\makefile.inc ===
!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

!if !defined(CLEANINF)
# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)
!endif

resource.rc : $(SDK_LIB_PATH)\AutoDiscovery.tlb $(O)\selfreg.inf


$(O)\selfreg.inf : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mailboxui.cpp ===
/*****************************************************************************\
    FILE: MailBoxUI.cpp

    DESCRIPTION:
        This file implements the UI of the MailBox feature.  This UI is presented
    in a window.  Other components can put that window in the Desktop Toolbar
    or in an ActiveX Control to be displayed on the desktop HTML.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"


#ifdef FEATURE_MAILBOX


//===========================
// *** Class Internals & Helpers ***
//===========================

#ifdef UNICODE
#define MAILBOXUI_CLASS_NAME              TEXT("MailBoxUI ToolbarW")
#else // UNICODE
#define MAILBOXUI_CLASS_NAME              TEXT("MailBoxUI ToolbarA")
#endif // UNICODE

HRESULT CMailBoxUI::_RegisterWindow(void)
{
    HRESULT hr = S_OK;
    WNDCLASS wc;

    //If the window class has not been registered, then do so.
    if (!GetClassInfo(HINST_THISDLL, MAILBOXUI_CLASS_NAME, &wc))
    {
        ZeroMemory(&wc, sizeof(wc));
        wc.style          = CS_GLOBALCLASS | CS_PARENTDC; // parentdc for perf
        wc.lpfnWndProc    = MailBoxUIWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;
        wc.hInstance      = g_hinst;
        wc.hIcon          = NULL;
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH) (1+COLOR_BTNFACE);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = MAILBOXUI_CLASS_NAME;
  
        if (!RegisterClass(&wc))
        {
            hr = E_FAIL;    // If RegisterClass fails, CreateWindow below will fail.
        }
    }

    return hr;
}


HRESULT CMailBoxUI::_CreateEditWindow(void)
{
    HRESULT hr = S_OK;
    DWORD dwType;
    TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];
    DWORD cbEmailAddress = sizeof(szEmailAddress);

    m_hwndEditBox = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("EDIT"), NULL, 
            (WS_CHILD | WS_TABSTOP | WS_VISIBLE | ES_AUTOHSCROLL), 
            2,1, 10, 0x1A, m_hwndMailBoxUI, NULL, HINST_THISDLL, (void*) this);

    if (m_hwndEditBox)
    {
        // We need to change the font to the Windows Shell Dlg font, 8
        HFONT hFont = (HFONT)(INT_PTR)SendMessage(GetParent(m_hwndMailBoxUI), WM_GETFONT, 0, 0L);
        if (hFont)
        {
            FORWARD_WM_SETFONT(m_hwndEditBox, hFont, FALSE, SendMessage);
        }

        szEmailAddress[0] = 0;
        DWORD dwError = SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS,
            &dwType, (void *)szEmailAddress, &cbEmailAddress);

        SetWindowText(m_hwndEditBox, szEmailAddress);

        // We want to subclass the window to capture Return/Enter.
        // There needs to be an easier way.
        SetWindowSubclass(m_hwndEditBox, EditMailBoxSubClassWndProc, 0, (DWORD_PTR)this);

        AddEmailAutoComplete(m_hwndEditBox);    // I love AutoComplete.
    }

    return hr;
}


LRESULT CMailBoxUI::_EditMailBoxSubClassWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL * pfHandled)
{
    LRESULT lResult = 0;

    switch (uMsg)
    {
    case WM_KEYUP:
        if (wParam == VK_RETURN)
        {
            TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];

            GetWindowText(m_hwndEditBox, szEmailAddress, ARRAYSIZE(szEmailAddress));
            if (SUCCEEDED(_OnExecuteGetEmail(szEmailAddress)))
            {
                // eat the enter/return key because we handled it.
                lResult = DLGC_WANTALLKEYS;
            }
        }
        break;
    }

    return lResult;
}


LRESULT CALLBACK CMailBoxUI::EditMailBoxSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CMailBoxUI * pMailBoxUI = (CMailBoxUI *)dwRefData;
    BOOL fHandled = FALSE;
    LRESULT lResult = 0;

    ASSERT(pMailBoxUI);
    if (pMailBoxUI)
    {
        lResult = pMailBoxUI->_EditMailBoxSubClassWndProc(uMsg, wParam, lParam, &fHandled);
    }

    if (!fHandled)
    {
        lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


HRESULT CMailBoxUI::_CreateGoWindow(void)
{
    HRESULT hr = S_OK;

    if (SHRegGetBoolUSValue(SZ_REGKEY_IEMAIN, SZ_REGVALUE_USE_GOBUTTON, FALSE, /*default*/TRUE))
    {
        AssertMsg(!m_hwndGoButton, "Why is the go button already created? -BryanSt");

        hr = E_FAIL;
        COLORREF crMask = RGB(255, 0, 255);
        if (m_himlDefault == NULL)
        {
            m_himlDefault = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GO), 16, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
        if (m_himlHot == NULL)
        {
            m_himlHot  = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GOHOT), 16, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }

        // If we have the image lists, go ahead and create the toolbar control for the go button
        if (m_himlDefault && m_himlHot)
        {
            // Create the toolbar control for the go button
            m_hwndGoButton = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                    WS_CHILD | TBSTYLE_FLAT |
                                    TBSTYLE_TOOLTIPS |
                                    TBSTYLE_LIST |
                                    WS_CLIPCHILDREN |
                                    WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                    CCS_NORESIZE,
                                    0, 0, 0, 0, m_hwndMailBoxUI, NULL, HINST_THISDLL, NULL);
        }

        if (m_hwndGoButton)
        {
            // Init the toolbar control
            SendMessage(m_hwndGoButton, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
            SendMessage(m_hwndGoButton, TB_SETMAXTEXTROWS, 1, 0L);
            SendMessage(m_hwndGoButton, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, 500));
            SendMessage(m_hwndGoButton, TB_SETIMAGELIST, 0, (LPARAM)m_himlDefault);
            SendMessage(m_hwndGoButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHot);

            LRESULT nRet = SendMessage(m_hwndGoButton, TB_ADDSTRING, (WPARAM)HINST_THISDLL, (LPARAM)IDS_MAILBOXUI_GOBUTTON_LABEL);
            ASSERT(nRet == 0);

            static const TBBUTTON tbb[] =
            {
                {0, 1, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0},
            };
            SendMessage(m_hwndGoButton, TB_ADDBUTTONS, ARRAYSIZE(tbb), (LPARAM)tbb);

            ShowWindow(m_hwndGoButton, SW_SHOW);
            hr = _OnSetSize();
        }
    }

    return hr;
}


HRESULT CMailBoxUI::_OnExecuteGetEmail(LPCTSTR pszEmailAddress)
{
    HRESULT hr = E_INVALIDARG;

    if (pszEmailAddress)
    {
        // Make sure the email address is valid.  If it isn't, then we should
        // Display a warning.
        if (!pszEmailAddress[0] || !StrChr(pszEmailAddress, CH_EMAIL_AT))
        {
            // Display a message box for now.
            // TOOD: Change this to a nice balloon in the future.
            TCHAR szErrorMessage[500];
            TCHAR szErrorTemplate[500];
            TCHAR szTitle[MAX_PATH];

            LoadStringW(HINST_THISDLL, IDS_MAILBOXUI_ERR_INVALID_EMAILADDR_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadStringW(HINST_THISDLL, IDS_MAILBOXUI_ERR_INVALID_EMAILADDR, szErrorTemplate, ARRAYSIZE(szErrorTemplate));
            wnsprintf(szErrorMessage, ARRAYSIZE(szErrorMessage), szErrorTemplate, pszEmailAddress);

            MessageBox(m_hwndMailBoxUI, szErrorMessage, szTitle, (MB_OK | MB_ICONHAND));
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate that we already displayed an error message.
        }
        else
        {
            // We will have this happen in a new process so we can be async
            // and to ensure that there is -zero- possibility to cause
            // instability in the shell.

            // We do this by creating a "rundll32.exe" process and have it call
            // us back by supplying the following command line arguments:
            // "<DllPath>\AutoDisc.dll,AutoDiscoverAndOpenEmail "-email <EmailAddressHere>""
            TCHAR szPath[MAX_PATH];

            if (GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath)))
            {
                TCHAR szCmdLine[MAX_URL_STRING];
                TCHAR szProcess[MAX_PATH];

#ifndef TESTING_IN_SAME_DIR
                StrCpyN(szProcess, TEXT("rundll32.exe"), ARRAYSIZE(szProcess));
#else // TESTING_IN_SAME_DIR
                GetCurrentDirectory(ARRAYSIZE(szProcess), szProcess);
                PathAppend(szProcess, TEXT("rundll32.exe"));
                if (!PathFileExists(szProcess))
                {
                    StrCpyN(szProcess, TEXT("rundll32.exe"), ARRAYSIZE(szProcess));
                }
#endif // TESTING_IN_SAME_DIR

                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s,AutoDiscoverAndOpenEmail -email %s"), szPath, pszEmailAddress);

                ULARGE_INTEGER uiResult;
                uiResult.QuadPart = (ULONGLONG) ShellExecute(NULL, NULL, TEXT("rundll32.exe"), szCmdLine, NULL, SW_SHOW);
                if (32 < uiResult.QuadPart)
                {
                    AddEmailToAutoComplete(pszEmailAddress);

                    uiResult.LowPart = ERROR_SUCCESS;
                }

                hr = HRESULT_FROM_WIN32(uiResult.LowPart);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return hr;
}


#define SIZEPX_ABOVEBELOW_EDITBOX        1
#define SIZEPX_LEFTRIGHT_EDITBOX         2

HRESULT CMailBoxUI::_OnSetSize(void)
{
    if (m_hwndEditBox && m_hwndGoButton)
    {
        // TODO: Get button size and then move it into position.  Including shrinking
        //    the editbox.
        RECT rcWindowSize;
        RECT rcGoWidth;

        GetClientRect(m_hwndMailBoxUI, &rcWindowSize);
        SendMessage(m_hwndGoButton, TB_GETITEMRECT, 0, (LPARAM)&rcGoWidth);
        
        SetWindowPos(m_hwndEditBox, NULL, SIZEPX_LEFTRIGHT_EDITBOX, SIZEPX_ABOVEBELOW_EDITBOX, RECTWIDTH(rcWindowSize)-RECTWIDTH(rcGoWidth)-(3 * SIZEPX_LEFTRIGHT_EDITBOX), 
                    RECTHEIGHT(rcWindowSize)-SIZEPX_ABOVEBELOW_EDITBOX, (SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER));
        SetWindowPos(m_hwndGoButton, NULL, RECTWIDTH(rcWindowSize)-SIZEPX_LEFTRIGHT_EDITBOX-RECTWIDTH(rcGoWidth), SIZEPX_ABOVEBELOW_EDITBOX,
                    RECTWIDTH(rcGoWidth), RECTHEIGHT(rcWindowSize)-(2*SIZEPX_ABOVEBELOW_EDITBOX), (SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER));
    }

    return S_OK;
}


LRESULT CALLBACK CMailBoxUI::MailBoxUIWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CMailBoxUI  *pThis = (CMailBoxUI*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMessage)
    {
    case WM_NCCREATE:
    {
        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;
        pThis = (CMailBoxUI*)(pcs->lpCreateParams);
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
        return TRUE;
    }

    case WM_COMMAND:
        return pThis->_OnCommand(wParam, lParam);

    case WM_SETFOCUS:
        TraceMsg(0, "  Main MailBoxUIWndProc got focus", 0);
        return pThis->_OnSetFocus();

    case WM_NOTIFY:
        if (pThis->_OnNotify((LPNMHDR)lParam))
        {
            return 0;
        }
        break;

    case WM_KILLFOCUS:
        TraceMsg(0, "  Main MailBoxUIWndProc lost focus", 0);
        return pThis->_OnKillFocus();

    case WM_WINDOWPOSCHANGING:
        if (pThis)
        {
            pThis->_OnSetSize();
        }
        return 0;
    case WM_SIZE:
        if (pThis)
        {
            pThis->_OnSetSize();
        }
        return 0;
    default:
        TraceMsg(TF_ALWAYS, "in MailBoxUIWndProc() uMessage=%#08lx", uMessage);
        break;
   }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}


LRESULT CMailBoxUI::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (HIWORD(wParam))
    {
        case EN_SETFOCUS:
            TraceMsg(0, "  Main MailBoxUIWndProc got EN_SETFOCUS", 0);
            _OnSetFocus();
            break;
        case EN_KILLFOCUS:
            TraceMsg(0, "  Main MailBoxUIWndProc got EN_KILLFOCUS", 0);
            _OnKillFocus();
            break;
        case STN_CLICKED:
            break;
        default:
            TraceMsg(TF_ALWAYS, "in CMailBoxUI::_OnCommand() HIWORD(wParam)=%#08lx", HIWORD(wParam));
            break;
    }
    return 0;
}


BOOL CMailBoxUI::_OnNotify(LPNMHDR pnm)
{
    if (pnm->hwndFrom == m_hwndGoButton)
    {
        switch (pnm->code)
        {
        case NM_CLICK:
            // Simulate an enter key press in the combobox
            SendMessage(m_hwndEditBox, WM_KEYDOWN, VK_RETURN, 0);
            SendMessage(m_hwndEditBox, WM_KEYUP, VK_RETURN, 0);
            break;
        }
    }

    return FALSE;   // We want the caller to still treat this as unhandled.
}


LRESULT CMailBoxUI::_OnSetFocus(void)
{
    // BUGBUG: should be IUnknown, but thats not working.  nb IDeskBand is the first iface, so ok
    //inform the input object site that the focus has changed
    if (m_pSite)
        m_pSite->OnFocusChangeIS((IDeskBand*)this, TRUE);

    return 0;
}

LRESULT CMailBoxUI::_OnKillFocus(void)
{
    // BUGBUG: should be IUnknown, but thats not working.  nb IDeskBand is the first iface, so ok
    //inform the input object site that the focus has changed
    if (m_pSite)
        m_pSite->OnFocusChangeIS((IDeskBand*)this, FALSE);

    return 0;
}



//===========================
// *** Public Methods ***
//===========================
HRESULT CMailBoxUI::CreateWindowMB(HWND hwndParent, HWND * phwndMailBoxUI)
{
    HRESULT hr = _RegisterWindow();

    if (!phwndMailBoxUI)
    {
        return E_INVALIDARG;
    }

    AssertMsg((NULL == m_hwndMailBoxUI), "Why is m_hwndMailBoxUI NULL? -BryanSt");

    // Can't create a child window without a parent.
    if (SUCCEEDED(hr) && !m_hwndMailBoxUI)
    {
        RECT  rc;

        GetClientRect(hwndParent, &rc);

        // TODO: Calc the real good size
        rc.bottom = rc.top - 0x1A;

        // Create the container window.
        m_hwndMailBoxUI = CreateWindowEx(0,
                     MAILBOXUI_CLASS_NAME,
                     NULL,
                     WS_CHILD | WS_CLIPSIBLINGS,
                     rc.left,
                     rc.top,
                     rc.right - rc.left,
                     rc.bottom - rc.top,
                     hwndParent,
                     NULL,
                     HINST_THISDLL,
                     (void*)this);

        if (m_hwndMailBoxUI)
        {
            hr = _CreateEditWindow();
            if (SUCCEEDED(hr))
            {
                hr = _CreateGoWindow();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        *phwndMailBoxUI = m_hwndMailBoxUI;
    }

    return hr;
}


HRESULT CMailBoxUI::CloseWindowMB(void)
{
    HRESULT hr = S_OK;
    TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];
    DWORD cbEmailAddress = sizeof(cbEmailAddress);

    if (GetWindowText(m_hwndEditBox, szEmailAddress, ARRAYSIZE(szEmailAddress)))
    {
        // Save the Email Address.
        DWORD dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS,
            REG_SZ, (void *)szEmailAddress, ((lstrlen(szEmailAddress) + 1) * sizeof(szEmailAddress[0])));
    }

    RemoveWindowSubclass(m_hwndEditBox, EditMailBoxSubClassWndProc, 0);
    DestroyWindow(m_hwndEditBox);
    m_hwndEditBox = NULL;

    DestroyWindow(m_hwndGoButton);
    m_hwndGoButton = NULL;

    DestroyWindow(m_hwndMailBoxUI);
    m_hwndMailBoxUI = NULL;

    return hr;
}


//===========================
// *** IOleWindow Interface ***
//===========================
STDMETHODIMP CMailBoxUI::GetWindow(HWND *phWnd)
{
    *phWnd = m_hwndMailBoxUI;
    return S_OK;
}

STDMETHODIMP CMailBoxUI::ContextSensitiveHelp(BOOL fEnterMode)
{
    // TODO: Add help here.
    return S_OK;
}


//===========================
// *** IDockingWindow Interface ***
//===========================
STDMETHODIMP CMailBoxUI::ShowDW(BOOL fShow)
{
    TraceMsg(0, "::ShowDW %x", fShow);
    if (m_hwndMailBoxUI)
    {
        if (fShow)
            ShowWindow(m_hwndMailBoxUI, SW_SHOW);
        else
            ShowWindow(m_hwndMailBoxUI, SW_HIDE);
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP CMailBoxUI::CloseDW(DWORD dwReserved)
{
    TraceMsg(0, "::CloseDW", 0);
    ShowDW(FALSE);

    return S_OK;
}

STDMETHODIMP CMailBoxUI::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkSite, BOOL fReserved)
{
    // This method is never called for Band Objects.
    return E_NOTIMPL;
}


//===========================
// *** IInputObject Interface ***
//===========================
STDMETHODIMP CMailBoxUI::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(0, "::UIActivateIO %x", fActivate);
    if (fActivate)
        SetFocus(m_hwndEditBox);
    return S_OK;
}


STDMETHODIMP CMailBoxUI::HasFocusIO(void)
{
// If this window or one of its decendants has the focus, return S_OK. Return 
//  S_FALSE if we don't have the focus.
    TraceMsg(0, "::HasFocusIO", NULL);
    HWND hwnd = GetFocus();
    if (hwnd && ((hwnd == m_hwndMailBoxUI) ||
        (GetParent(hwnd) == m_hwndMailBoxUI) ||
        (GetParent(GetParent(hwnd)) == m_hwndMailBoxUI)))
    {
        return S_OK;
    }

    return S_FALSE;
}


STDMETHODIMP CMailBoxUI::TranslateAcceleratorIO(LPMSG pMsg)
{
    // If the accelerator is translated, return S_OK or S_FALSE otherwise.
    return S_FALSE;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
STDMETHODIMP CMailBoxUI::SetSite(IUnknown* punkSite)
{
    IUnknown_Set((IUnknown **) &m_pSite, punkSite);
    return ((m_pSite && punkSite) ? S_OK : ((!m_pSite && !punkSite) ? S_OK : E_FAIL));
}

STDMETHODIMP CMailBoxUI::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    *ppvReturn = NULL;

    if (m_pSite)
        return m_pSite->QueryInterface(riid, ppvReturn);

    return E_FAIL;
}





//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxUI::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMailBoxUI, IOleWindow),
        QITABENT(CMailBoxUI, IDockingWindow),
        QITABENT(CMailBoxUI, IInputObject),
        QITABENT(CMailBoxUI, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxUI::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxUI::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
HRESULT CMailBoxUI::GetEditboxWindow(HWND * phwndEdit)
{
    HRESULT hr = E_FAIL;

    if (m_hwndEditBox)
    {
        *phwndEdit = m_hwndEditBox;
        hr = S_OK;
    }
    else
    {
        *phwndEdit = NULL;
    }

    return hr;
}


CMailBoxUI::CMailBoxUI()
{
    DllAddRef();

    m_himlDefault = NULL;
    m_himlHot = NULL;
    m_hwndMailBoxUI = NULL;
    m_hwndGoButton = NULL;
    m_hwndEditBox = NULL;
    m_pSite = NULL;

    m_cRef = 1;
}

CMailBoxUI::~CMailBoxUI()
{
    if (m_himlDefault) ImageList_Destroy(m_himlDefault);
    if (m_himlHot)  ImageList_Destroy(m_himlHot);

    ATOMICRELEASE(m_pSite);

    DllRelease();
}










#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mailprotocol.cpp ===
/*****************************************************************************\
    FILE: MailProtocol.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscovered email protocol information.

    BryanSt 2/15/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"
#include "MailProtocol.h"



//===========================
// *** Class Internals & Helpers ***
//===========================

HRESULT _ReturnString(IN BSTR bstrToCopy, OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        if (bstrToCopy)
        {
            hr = HrSysAllocString(bstrToCopy, pbstr);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            *pbstr = NULL;
        }
    }

    return hr;
}


HRESULT CMailProtocol::_Parse(IN IXMLDOMNode * pXMLNodeProtocol)
{
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_SERVER, &m_bstrServerName);

    if (SUCCEEDED(hr))
    {
        BSTR bstr;

        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_TYPE, &m_bstrProtocol);
        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_PORT, &m_bstrServerPort);
        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_LOGINNAME, &m_bstrLoginName);

        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_SSL, &m_fUseSSL);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_AUTHREQUIRED, &m_fRequiresAuth);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_SPA, &m_fUseSPA);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_USEPOPAUTH, &m_fUsePOPAuth);

        if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_POSTHTML, &bstr)))
        {
            UnEscapeHTML(bstr, &m_bstrPostXML);
            SysFreeString(bstr);
        }
    }

    return hr;
}




//===========================
// *** IMailProtocolADEntry Interface ***
//===========================

HRESULT CMailProtocol::get_Protocol(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrProtocol, pbstr);
}


HRESULT CMailProtocol::get_ServerName(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrServerName, pbstr);
}


HRESULT CMailProtocol::get_ServerPort(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrServerPort, pbstr);
}


HRESULT CMailProtocol::get_LoginName(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrLoginName, pbstr);
}


HRESULT CMailProtocol::get_PostHTML(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrPostXML, pbstr);
}


HRESULT CMailProtocol::get_UseSSL(OUT VARIANT_BOOL * pfUseSSL)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUseSSL)
    {
        *pfUseSSL = (m_fUseSSL ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_IsAuthRequired(OUT VARIANT_BOOL * pfIsAuthRequired)
{
    HRESULT hr = E_INVALIDARG;

    if (pfIsAuthRequired)
    {
        *pfIsAuthRequired = (m_fRequiresAuth ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_UseSPA(OUT VARIANT_BOOL * pfUseSPA)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUseSPA)
    {
        *pfUseSPA = (m_fUseSPA ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_SMTPUsesPOP3Auth(OUT VARIANT_BOOL * pfUsePOP3Auth)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUsePOP3Auth)
    {
        *pfUsePOP3Auth = (m_fUsePOPAuth ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CMailProtocol::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CMailProtocol::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CMailProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CMailProtocol, IMailProtocolADEntry),
        QITABENT(CMailProtocol, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CMailProtocol::CMailProtocol() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IMailProtocolADEntry), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_bstrProtocol);
    ASSERT(!m_bstrServerName);
    ASSERT(!m_bstrServerPort);
    ASSERT(!m_bstrLoginName);
    ASSERT(!m_bstrPostXML);
    ASSERT(!m_fUseSSL);
    ASSERT(!m_fRequiresAuth);
    ASSERT(!m_fUseSPA);
    ASSERT(!m_fUsePOPAuth);
}


CMailProtocol::~CMailProtocol()
{
    SysFreeString(m_bstrProtocol);
    SysFreeString(m_bstrServerName);
    SysFreeString(m_bstrServerPort);
    SysFreeString(m_bstrLoginName);
    SysFreeString(m_bstrPostXML);

    DllRelease();
}


HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol)
{
    HRESULT hr = E_INVALIDARG;

    if (pXMLNodeProtocol && ppMailProtocol)
    {
        CMailProtocol * pmf = new CMailProtocol();

        *ppMailProtocol = NULL;
        if (pmf)
        {
            hr = pmf->_Parse(pXMLNodeProtocol);
            if (SUCCEEDED(hr))
            {
                hr = pmf->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
            }

            pmf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\mbdeskbar.cpp ===
/*****************************************************************************\
    FILE: MBDeskBar.cpp

    DESCRIPTION:
        This is the Desktop Toolbar code used to host the "MailBox" feature UI.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"





#ifdef FEATURE_MAILBOX
/**************************************************************************
   CLASS: CMailBoxDeskBand
**************************************************************************/
class CMailBoxDeskBand : public IDeskBand, 
                  public IInputObject, 
                  public IObjectWithSite,
                  public IPersistStream,
                  public IContextMenu
{
public:
   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IOleWindow methods
   STDMETHOD (GetWindow)(HWND*);
   STDMETHOD (ContextSensitiveHelp)(BOOL);

   //IDockingWindow methods
   STDMETHOD (ShowDW)(BOOL fShow);
   STDMETHOD (CloseDW)(DWORD dwReserved);
   STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

   //IDeskBand methods
   STDMETHOD (GetBandInfo)(DWORD, DWORD, DESKBANDINFO*);

   //IInputObject methods
   STDMETHOD (UIActivateIO)(BOOL, LPMSG);
   STDMETHOD (HasFocusIO)(void);
   STDMETHOD (TranslateAcceleratorIO)(LPMSG);

   //IObjectWithSite methods
   STDMETHOD (SetSite)(IUnknown*);
   STDMETHOD (GetSite)(REFIID, LPVOID*);

   //IPersistStream methods
   STDMETHOD (GetClassID)(LPCLSID);
   STDMETHOD (IsDirty)(void);
   STDMETHOD (Load)(LPSTREAM);
   STDMETHOD (Save)(LPSTREAM, BOOL);
   STDMETHOD (GetSizeMax)(ULARGE_INTEGER*);

   //IContextMenu methods
   STDMETHOD (QueryContextMenu)(HMENU, UINT, UINT, UINT, UINT);
   STDMETHOD (InvokeCommand)(LPCMINVOKECOMMANDINFO);
   STDMETHOD (GetCommandString)(UINT_PTR, UINT, LPUINT, LPSTR, UINT);

private:
    CMailBoxDeskBand();
    ~CMailBoxDeskBand();

    // Private Member Variables
    DWORD m_cRef;

	HWND m_hwndParent;                  // The hwnd of the DeskBar (the host with all the bars)
    HWND m_hwndMailBox;                 // The child hwnd that displayed the Label, Editbox, and "Go" button.
    IInputObjectSite *m_pSite;
    CMailBoxUI * m_pMailBoxUI;

    // Private Member Functions
    HRESULT _CreateWindow(void);

	static LRESULT CALLBACK MailBoxDeskBarWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};





//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CMailBoxDeskBand::_CreateWindow(void)
{
    HRESULT hr = S_OK;

    //If the window doesn't exist yet, create it now.
    if (!m_hwndMailBox)
    {
        ATOMICRELEASE(m_pMailBoxUI);

        m_pMailBoxUI = new CMailBoxUI();
        if (m_pMailBoxUI)
        {
            hr = m_pMailBoxUI->CreateWindowMB(m_hwndParent, &m_hwndMailBox);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//===========================
// *** IOleWindow Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::GetWindow(HWND *phWnd)
{
    *phWnd = m_hwndMailBox;
    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::ContextSensitiveHelp(BOOL fEnterMode)
{
    // TODO: Add help here.
    return S_OK;
}


//===========================
// *** IDockingWindow Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::ShowDW(BOOL fShow)
{
    TraceMsg(0, "::ShowDW %x", fShow);
    if (m_hwndMailBox)
    {
        if (fShow)
            ShowWindow(m_hwndMailBox, SW_SHOW);
        else
            ShowWindow(m_hwndMailBox, SW_HIDE);
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP CMailBoxDeskBand::CloseDW(DWORD dwReserved)
{
    TraceMsg(0, "::CloseDW", 0);
    ShowDW(FALSE);

    if (m_pMailBoxUI)
    {
        m_pMailBoxUI->CloseWindowMB();
        ATOMICRELEASE(m_pMailBoxUI);
    }

    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkSite, BOOL fReserved)
{
    // This method is never called for Band Objects.
    return E_NOTIMPL;
}


//===========================
// *** IInputObject Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(0, "::UIActivateIO %x", fActivate);
    if (fActivate)
        SetFocus(m_hwndMailBox);
    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::HasFocusIO(void)
{
// If this window or one of its decendants has the focus, return S_OK. Return 
//  S_FALSE if we don't have the focus.
    TraceMsg(0, "::HasFocusIO", NULL);
    HWND hwnd = GetFocus();
    if (hwnd && ((hwnd == m_hwndMailBox) ||
        (GetParent(hwnd) == m_hwndMailBox) ||
        (GetParent(GetParent(hwnd)) == m_hwndMailBox)))
    {
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CMailBoxDeskBand::TranslateAcceleratorIO(LPMSG pMsg)
{
    // If the accelerator is translated, return S_OK or S_FALSE otherwise.
    return S_FALSE;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::SetSite(IUnknown* punkSite)
{
    HRESULT hr = S_OK;

    //If a site is being held, release it.
    ATOMICRELEASE(m_pSite);

    //If punkSite is not NULL, a new site is being set.
    if (punkSite)
    {
        // Get the parent window.
        m_hwndParent = NULL;
        IUnknown_GetWindow(punkSite, &m_hwndParent);

        if (m_hwndParent)
        {
            hr = _CreateWindow();
            if (SUCCEEDED(hr))
            {
                // Get and keep the IInputObjectSite pointer.
                hr = punkSite->QueryInterface(IID_PPV_ARG(IInputObjectSite, &m_pSite));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CMailBoxDeskBand::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    *ppvReturn = NULL;

    if (m_pSite)
        return m_pSite->QueryInterface(riid, ppvReturn);

    return E_FAIL;
}


//===========================
// *** IDeskBand Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
    if (pdbi)
    {
        if (pdbi->dwMask & DBIM_MINSIZE)
        {
            pdbi->ptMinSize.x = 0;
            pdbi->ptMinSize.y = 0;
        }

        if (pdbi->dwMask & DBIM_MODEFLAGS)
        {
            pdbi->dwModeFlags = DBIMF_FIXEDBMP;
        }

        bool fVertical = (((dwViewMode & (DBIF_VIEWMODE_VERTICAL | DBIF_VIEWMODE_FLOATING)) != 0) ? true : false);
        if (true == fVertical)
        {
            if (pdbi->dwMask & DBIM_MODEFLAGS)
            {
                pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
            }
        }
        else
        {
            if (m_pMailBoxUI)
            {
                HWND hwndEdit;

                if (SUCCEEDED(m_pMailBoxUI->GetEditboxWindow(&hwndEdit)))
                {
                    RECT rcEditbox;

                    // TODO: We need to find the real height of the editbox with
                    //   one row of text plus 2 pixels on top and bottom.
                    GetWindowRect(hwndEdit, &rcEditbox);
                    pdbi->ptMinSize.y = RECTHEIGHT(rcEditbox);

                    // TODO: Find out how to calc the appropriate size of the editbox.
                    pdbi->ptMinSize.y = 0x1A;
                }
            }
        }

        if (pdbi->dwMask & DBIM_MAXSIZE)
        {
            if (true == fVertical)
            {
                pdbi->ptMaxSize.y = -1;
            }
        }

        if (pdbi->dwMask & DBIM_INTEGRAL)
        {
            if (true == fVertical)
            {
                pdbi->ptIntegral.y = 1;
            }
        }

        if (pdbi->dwMask & DBIM_TITLE)
        {
            LoadStringW(HINST_THISDLL, IDS_MAILBOX_DESKBAR_LABEL, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
        }

        if (pdbi->dwMask & DBIM_BKCOLOR)
        {
            //Use the default background color by removing this flag.
            pdbi->dwMask &= ~DBIM_BKCOLOR;
        }

        return S_OK;
    }

    return E_INVALIDARG;
}


//===========================
// *** IPersistStream Interface ***
//===========================
#define MAILBOX_PERSIST_SIGNATURE           0xF0AB8915          // Random signature.
#define MAILBOX_PERSIST_VERSION             0x00000000          // This is version 0.

typedef struct {
    DWORD cbSize;
    DWORD dwSig;                // from MAILBOX_PERSIST_SIGNATURE
    DWORD dwVer;                // from MAILBOX_PERSIST_VERSION
} MAILBOX_PERSISTHEADERSTRUCT;

STDMETHODIMP CMailBoxDeskBand::GetClassID(LPCLSID pClassID)
{
    *pClassID = CLSID_MailBoxDeskBar;
    return S_OK;
}


STDMETHODIMP CMailBoxDeskBand::IsDirty(void)
{
    // We currently never get dirty because we don't have state.
    return S_FALSE;
}


STDMETHODIMP CMailBoxDeskBand::Load(IStream* pStream)
{
    DWORD cbRead;
    MAILBOX_PERSISTHEADERSTRUCT mailboxPersistHeader;
    HRESULT hr = pStream->Read(&mailboxPersistHeader, sizeof(mailboxPersistHeader), &cbRead);

    if (SUCCEEDED(hr) &&
        (sizeof(mailboxPersistHeader) == cbRead) &&
        (MAILBOX_PERSIST_SIGNATURE == mailboxPersistHeader.dwSig) &&
        (mailboxPersistHeader.cbSize > 0))
    {
        void * pPersistHeader = (void *) LocalAlloc(NONZEROLPTR, mailboxPersistHeader.cbSize);

        if (pPersistHeader)
        {
            // We read it simply to support future versions.
            hr = pStream->Read(pPersistHeader, mailboxPersistHeader.cbSize, NULL);
            LocalFree(pPersistHeader);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP CMailBoxDeskBand::Save(IStream* pStream, BOOL fClearDirty)
{
    MAILBOX_PERSISTHEADERSTRUCT mailboxPersistHeader = {0, MAILBOX_PERSIST_SIGNATURE, MAILBOX_PERSIST_VERSION};

//    if (fClearDirty)
//        m_bDirty = FALSE;

    return pStream->Write(&mailboxPersistHeader, sizeof(mailboxPersistHeader), NULL);
}


STDMETHODIMP CMailBoxDeskBand::GetSizeMax(ULARGE_INTEGER *pul)
{
    HRESULT hr = E_INVALIDARG;

    if (pul)
    {
        pul->QuadPart = sizeof(MAILBOX_PERSISTHEADERSTRUCT);
        hr = S_OK;
    }

    return hr;
}


//===========================
// *** IContextMenu Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::QueryContextMenu( HMENU hMenu,
                                          UINT indexMenu,
                                          UINT idCmdFirst,
                                          UINT idCmdLast,
                                          UINT uFlags)
{
    if (CMF_DEFAULTONLY & uFlags)
        return S_OK;

    // We don't currently add any context menu items.
    return S_OK;
}


STDMETHODIMP CMailBoxDeskBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    return E_INVALIDARG;
}


STDMETHODIMP CMailBoxDeskBand::GetCommandString(UINT_PTR idCommand, UINT uFlags, LPUINT lpReserved, LPSTR lpszName, UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMailBoxDeskBand, IOleWindow),
        QITABENT(CMailBoxDeskBand, IDockingWindow),
        QITABENT(CMailBoxDeskBand, IInputObject),
        QITABENT(CMailBoxDeskBand, IObjectWithSite),
        QITABENT(CMailBoxDeskBand, IDeskBand),
        QITABENT(CMailBoxDeskBand, IPersist),
        QITABENT(CMailBoxDeskBand, IPersistStream),
        QITABENT(CMailBoxDeskBand, IContextMenu),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxDeskBand::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxDeskBand::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
CMailBoxDeskBand::CMailBoxDeskBand()
{
    DllAddRef();

    m_pSite = NULL;
    m_pMailBoxUI = NULL;
    
    m_hwndMailBox = NULL;
    m_hwndParent = NULL;
    m_cRef = 1;
}

CMailBoxDeskBand::~CMailBoxDeskBand()
{
    ATOMICRELEASE(m_pSite);
    ATOMICRELEASE(m_pMailBoxUI);

    DllRelease();
}


HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (ppvObj)
    {
        *ppvObj = NULL;
        if (NULL == punkOuter)
        {
            CMailBoxDeskBand * pmf = new CMailBoxDeskBand();
            if (pmf)
            {
                hr = pmf->QueryInterface(riid, ppvObj);
                pmf->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}












#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\objcache.cpp ===
/*****************************************************************************\
    FILE: objcache.cpp

    DESCRIPTION:
        This is a lightweight API that will cache an object so the class factory
    will return the same object each time for every call in this process.  If the
    caller is on another thread, they will get a marshalled stub to the real
    McCoy.
    
    To Add an Object:
    1. classfactory.cpp calls CachedObjClassFactoryCreateInstance().  Add your
       object's CLSID to that if statement for that call.
    2. Copy the section in CachedObjClassFactoryCreateInstance() that looks
       for a CLSID and calls the correct xxx_CreateInstance() method.
    3. Your object's IUnknown::Release() needs to call CachedObjCheckRelease()
       at the top of your Release() method.  It may reduce your m_cRef to 1 so
       it will go to zero after ::Release() decrements it.  The object cache
       will hold two references to the object.  CachedObjCheckRelease() will check
       if the last caller (3rd ref) is releasing, and then it will give up it's 2
       refs and clean up it's internal state.  The Release() then decrements
       the callers ref and it's released because it hit zero.

    BryanSt 12/9/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "objcache.h"

//////////////////////////////////////////////
// Object Caching API
//////////////////////////////////////////////
HDPA g_hdpaObjects = NULL;
CRITICAL_SECTION g_hCachedObjectSection;

typedef struct
{
    CLSID clsid;
    IStream * pStream;
    IUnknown * punk;
    DWORD dwThreadID;
} CACHEDOBJECTS;


STDAPI _GetObjectCacheArray(void)
{
    HRESULT hr = S_OK;

    if (!g_hdpaObjects)
    {
        g_hdpaObjects = DPA_Create(1);
        if (!g_hdpaObjects)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

// This is the number of references that are used by the cache list
// (One for punk & one for pStream).  If we hit this number,
// then there aren't any outstanding refs.
#define REF_RELEASE_POINT    3

int CALLBACK HDPAFindCLSID(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    CLSID * pClsidToFind = (CLSID *)p1;
    CACHEDOBJECTS * pCachedObjects = (CACHEDOBJECTS *)p2;
    int nReturn = 0;

    // Are they of different types?
    if (pCachedObjects->clsid.Data1 < pClsidToFind->Data1) nReturn = -1;
    else if (pCachedObjects->clsid.Data1 > pClsidToFind->Data1) nReturn = 1;
    else if (pCachedObjects->clsid.Data2 < pClsidToFind->Data2) nReturn = -1;
    else if (pCachedObjects->clsid.Data2 > pClsidToFind->Data2) nReturn = 1;
    else if (pCachedObjects->clsid.Data3 < pClsidToFind->Data3) nReturn = -1;
    else if (pCachedObjects->clsid.Data3 > pClsidToFind->Data3) nReturn = 1;
    else if (*(ULONGLONG *)&pCachedObjects->clsid.Data4 < *(ULONGLONG *)&pClsidToFind->Data4) nReturn = -1;
    else if (*(ULONGLONG *)&pCachedObjects->clsid.Data4 > *(ULONGLONG *)&pClsidToFind->Data4) nReturn = 1;

    return nReturn;
}


STDAPI ObjectCache_GetObject(CLSID clsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr = S_OK;

    hr = _GetObjectCacheArray();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

        if (0 <= nIndex)
        {
            CACHEDOBJECTS * pCurrentObject = (CACHEDOBJECTS *) DPA_GetPtr(g_hdpaObjects, nIndex);

            if (pCurrentObject)
            {
                if (GetCurrentThreadId() == pCurrentObject->dwThreadID)
                {
                    // No Marshalling needed.
                    hr = pCurrentObject->punk->QueryInterface(riid, ppvObj);
                }
                else
                {
                    // We do need to marshal it.  So read it out of the stream.
                    // But first we want to store our place in the stream so
                    // we can rewrind for the next schmooo.
                    LARGE_INTEGER liZero;
                    ULARGE_INTEGER uli;

                    liZero.QuadPart = 0;
                    hr = pCurrentObject->pStream->Seek(liZero, STREAM_SEEK_CUR, &uli);
                    if (SUCCEEDED(hr))
                    {
                        LARGE_INTEGER li;
                        
                        li.QuadPart = uli.QuadPart;
                        hr = CoUnmarshalInterface(pCurrentObject->pStream, riid, ppvObj);
                        if (SUCCEEDED(hr))
                        {
                            pCurrentObject->pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        }
                    }

                }
            }
        }
    }

    return hr;
}

// WARNING: DllGetClassObject/CoGetClassObject
//   may be much better to use than rolling our own thread safe
//   code.


STDAPI ObjectCache_SetObject(CLSID clsid, REFIID riid, IUnknown * punk)
{
    HRESULT hr = _GetObjectCacheArray();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

        // If it's not in the list.
        if (0 > nIndex)
        {
            CACHEDOBJECTS * pcoCurrentObject = (CACHEDOBJECTS *) LocalAlloc(LPTR, sizeof(CACHEDOBJECTS));

            if (pcoCurrentObject)
            {
                pcoCurrentObject->dwThreadID = GetCurrentThreadId();
                pcoCurrentObject->clsid = clsid;

                punk->AddRef();     // Ref now equals 2 (The structure will own this ref)
                IStream * pStream = SHCreateMemStream(NULL, 0);
                if (pStream)
                {
                    hr = CoMarshalInterface(pStream, riid, punk, MSHCTX_INPROC, NULL, MSHLFLAGS_NORMAL);
                    if (SUCCEEDED(hr))  // Ref now equals 3
                    {
                        LARGE_INTEGER liZero;

                        // Reset the Stream to the beginning.
                        liZero.QuadPart = 0;
                        hr = pStream->Seek(liZero, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hr))
                        {
                            pcoCurrentObject->punk = punk;
                            pcoCurrentObject->pStream = pStream;

                            if (-1 == DPA_SortedInsertPtr(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, (DPAS_SORTED | DPAS_INSERTBEFORE), pcoCurrentObject))
                            {
                                // It failed.
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                {
                    LocalFree(pcoCurrentObject);
                    punk->Release();
                    ATOMICRELEASE(pStream);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}



STDAPI CachedObjClassFactoryCreateInstance(CLSID clsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr;

    EnterCriticalSection(&g_hCachedObjectSection);
    hr = ObjectCache_GetObject(clsid, riid, ppvObj);
    if (FAILED(hr))
    {
        /*
        if (IsEqualCLSID(clsid, CLSID_MailApp))
        {
            hr = CMailAppOM_CreateInstance(NULL, riid, ppvObj);
        }
*/
        if (SUCCEEDED(hr))
        {
            // ObjectCache_SetObject will fail in some
            // multi-threaded cases.
            hr = ObjectCache_SetObject(clsid, riid, (IUnknown *) *ppvObj);
        }
    }
    LeaveCriticalSection(&g_hCachedObjectSection);

    return hr;
}


int ObjectCache_DestroyCB(LPVOID pv, LPVOID pvData)
{
    CACHEDOBJECTS * pCachedObjects = (CACHEDOBJECTS *)pv;

    AssertMsg((NULL != pCachedObjects), "Why would this be NULL?");
    if (pCachedObjects)
    {
        SAFERELEASE(pCachedObjects->punk);
        SAFERELEASE(pCachedObjects->pStream);
        LocalFree(pCachedObjects);
    }

    return TRUE;
}


STDAPI CachedObjCheckRelease(CLSID clsid, int * pnRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pnRef)
    {
        hr = S_OK;
        if (REF_RELEASE_POINT == *pnRef)
        {
            EnterCriticalSection(&g_hCachedObjectSection);
            if (REF_RELEASE_POINT == *pnRef)
            {
                hr = _GetObjectCacheArray();
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                    int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

                    if (0 <= nIndex)
                    {
                        CACHEDOBJECTS * pCurrentObject = (CACHEDOBJECTS *) DPA_GetPtr(g_hdpaObjects, nIndex);

                        if (pCurrentObject)
                        {
                            // We need to delete the pointer from the array before
                            // we release the object or it will recurse infinitely.
                            // The problem is that when ObjectCache_DestroyCB() releases
                            // the object, the Release() function will call CachedObjCheckRelease().
                            // And since the ref hasn't change -yet-, we need the
                            // search to fail to stop the recursion.
                            DPA_DeletePtr(g_hdpaObjects, nIndex);
                            ObjectCache_DestroyCB(pCurrentObject, NULL);
                        }
                    }
                }
            }
            LeaveCriticalSection(&g_hCachedObjectSection);
        }
    }

    return hr;
}


STDAPI PurgeObjectCache(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_hCachedObjectSection);
    if (g_hdpaObjects)
    {
        DPA_DestroyCallback(g_hdpaObjects, ObjectCache_DestroyCB, NULL);
        g_hdpaObjects = NULL;
    }
    LeaveCriticalSection(&g_hCachedObjectSection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\objctors.h ===
#ifndef _OBJCTORS_H_
#define _OBJCTORS_H_


#endif // ! _OBJCTORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\objcache.h ===
/*****************************************************************************\
    FILE: objcache.h

    DESCRIPTION:
        This is a lightweight API that will cache an object so the class factory
    will return the same object each time for every call in this process.  If the
    caller is on another thread, they will get a marshalled stub to the real
    McCoy.
    
    To Add an Object:
    1. classfactory.cpp calls CachedObjClassFactoryCreateInstance().  Add your
       object's CLSID to that if statement for that call.
    2. Copy the section in CachedObjClassFactoryCreateInstance() that looks
       for a CLSID and calls the correct xxx_CreateInstance() method.
    3. Your object's IUnknown::Release() needs to call CachedObjCheckRelease()
       at the top of your Release() method.  It may reduce your m_cRef to 1 so
       it will go to zero after ::Release() decrements it.  The object cache
       will hold two references to the object.  CachedObjCheckRelease() will check
       if the last caller (3rd ref) is releasing, and then it will give up it's 2
       refs and clean up it's internal state.  The Release() then decrements
       the callers ref and it's released because it hit zero.

    BryanSt 12/9/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef __OBJCACHE_H_
#define __OBJCACHE_H_

//////////////////////////////////////////////
// Object Caching API
//////////////////////////////////////////////
extern CRITICAL_SECTION g_hCachedObjectSection;

STDAPI CachedObjClassFactoryCreateInstance(CLSID clsid, REFIID riid, void ** ppvObj);
STDAPI CachedObjCheckRelease(CLSID clsid, int * pnRef);
STDAPI PurgeObjectCache(void);


#endif //__OBJCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\resource.h ===
/*****************************************************************************\
    FILE: resource.h

    DESCRIPTION:
        Header file for the resource file

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include <commctrl.h>

// String Resource IDs (0x1000 - 0x10000)
#define IDS_MAILBOX_DESKBAR_LABEL                       1000
#define IDS_MAILBOXUI_GOBUTTON_LABEL                    1001
#define IDS_ASSOC_GETEMAILADDRESS                       1002
#define IDS_AUTODISCOVER_WIZARD_CAPTION                 1003
#define IDS_AUTODISCOVER_PROGRESS                       1004
#define IDS_AUTODISCOVER_PROGRESS_SUB                   1005
#define IDS_MANUALLY_CHOOSE_APP                         1006
#define IDS_MANUALLY_CHOOSE_APP_SUB                     1007
#define IDS_SKIP_BUTTON                                 1008
#define IDS_CHOOSEAPP_FAILED_RESULTS                    1009
#define IDS_ASSOC_GETEMAILADDRESS_SUB                   1010


// These are the strings we share with OE's acctres.dll    
#define IDS_STATUS_CONNECTING_TO                        40398
#define IDS_STATUS_DOWNLOADING                          40399

// Error Strings
#define IDS_MAILBOXUI_ERR_INVALID_EMAILADDR             2000
#define IDS_MAILBOXUI_ERR_INVALID_EMAILADDR_TITLE       2001




// Dialogs  (100 - 400)




// Wizard Pages  (401 - 600)
#define IDD_AUTODISCOVER_PROGRESS_PAGE  400
#define IDD_MANUALLY_CHOOSE_APP_PAGE    401
#define IDC_CHOOSEAPP_WEBURL_EDIT       402
#define IDC_CHOOSEAPP_WEB_RADIO         403
#define IDC_CHOOSEAPP_OTHERAPP_RADIO    404
#define IDC_CHOOSEAPP_DESC              405
#define IDC_AUTODISCOVERY_ANIMATION     406
#define IDC_CHOOSEAPP_APPLIST           407

#define IDD_ASSOC_GETEMAILADDRESS_PAGE  408
#define IDC_GETEMAILADDRESS_EDIT        409



// Bitmap Resource IDs (601 - 700)
#define IDB_GO                          601
#define IDB_GOHOT                       602
#define IDB_PSW_BANNER                  603


// Icons IDs (701 - 800)


// AVI Resource IDs (801 - 900)
#define IDA_DOWNLOADINGSETTINGS         801
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\priv.h ===
/*****************************************************************************\
    FILE: priv.h

    DESCRIPTION:
        This is the precompiled header for autodisc.dll.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************\
      Global Includes
\*****************************************************************************/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_DLL
#undef _ATL_DLL_IMPL
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache

#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */


#define POST_IE5_BETA
#include <w95wraps.h>

#include <windows.h>

#include <windowsx.h>

#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

// HACKHACK: For the life of me, I can't get shlwapip.h to include the diffinitions of these.
//    I'm giving up and putting them inline.  __IOleAutomationTypes_INTERFACE_DEFINED__ and
//    __IOleCommandTarget_INTERFACE_DEFINED__ need to be defined, which requires oaidl.h,
//    which requires hlink.h which requires rpcndr.h to come in the right order.  Once I got that
//    far I found it still didn't work and a lot of more stuff is needed.  The problem
//    is that shlwapi (exdisp/dspsprt/expdsprt/cnctnpt) or ATL will provide impls for
//    IConnectionPoint & IConnectionPointContainer, but one will conflict with the other.
LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS * pdispparams);
LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);
LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP, DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);

#include <shellapi.h>
#include "crtfree.h"            // We copied this from \shell\inc\ because it sure is nice to have.

#include <ole2ver.h>
#include <olectl.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <msident.h>
#include <msxml.h>
#include <AutoDiscovery.h>          // For IAutoDiscovery interfaces
#include <dispex.h>                 // IDispatchEx
#include <perhist.h>
#include <regapix.h>


#include <help.h>
#include <multimon.h>
#include <urlhist.h>
#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>
#include <propset.h>        // BUGBUG (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>


#include <shlobjp.h>
#include <fromshell.h>
#include <dspsprt.h>
#include <cowsite.h>
#include <cobjsafe.h>
#include <guids.h>
#include "dpa.h"                // We have a copy of the header since it isn't public

// Trace flags
#define TF_WMAUTODISCOVERY  0x00000100      // AutoDiscovery
#define TF_WMTRANSPORT      0x00000200      // Transport Layer
#define TF_WMOTHER          0x00000400      // Other
#define TF_WMSMTP_CALLBACK  0x00000800      // SMTP Callback



/*****************************************************************************\
   Global Helper Macros/Typedefs
\*****************************************************************************/
EXTERN_C HINSTANCE g_hinst;   // My instance handle
#define HINST_THISDLL g_hinst

#define WizardNext(hwnd, to)          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)to)

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#define CALLWNDPROC WNDPROC

#include "idispids.h"


/*****************************************************************************\
    Global state management.
    DLL reference count, DLL critical section.
\*****************************************************************************/
void DllAddRef(void);
void DllRelease(void);

#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)
typedef void (*LISTPROC)(UINT flm, LPVOID pv);


/*****************************************************************************\
    Local Includes
\*****************************************************************************/
typedef unsigned __int64 QWORD, * LPQWORD;

// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;

#define QW_MAC              0xFFFFFFFFFFFFFFFF

#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define MAX_EMAIL_ADDRESSS              MAX_URL_STRING



//  Features (This is where they are turned on and off)
//#define FEATURE_MAILBOX             // This is the editbox in the shell where an email address can be opened.
//#define FEATURE_EMAILASSOCIATIONS   // This is the API that will track Email Associations.

// Testing Options
#define TESTING_IN_SAME_DIR



// String Constants
// Registry
#define SZ_REGKEY_IDENTITIES        "Identities"
#define SZ_REGKEY_IEMAIN            TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define SZ_REGKEY_OE50_PART2        "Software\\Microsoft\\Outlook Express\\5.0"
#define SZ_REGKEY_INTERNET_ACCT     "Software\\Microsoft\\Internet Account Manager"
#define SZ_REGKEY_ACCOUNTS          "Accounts"
#define SZ_REGKEY_MAILCLIENTS       TEXT("Software\\Clients\\Mail")
#define SZ_REGKEY_EXPLOREREMAIL     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Email")
#define SZ_REGKEY_SHELLOPENCMD      TEXT("Shell\\open\\command")
#define SZ_REGKEY_MAILTRANSPORT     TEXT("MailTransport")

#define SZ_REGVALUE_USE_GOBUTTON    TEXT("ShowGoButton")
#define SZ_REGVALUE_DEFAULT_MAIL_ACCT       "Default Mail Account"
#define SZ_REGVALUE_MAIL_ADDRESS    "SMTP Email Address"
#define SZ_REGVALUE_STOREROOT       "Store Root"
#define SZ_REGVALUE_LASTUSERID      "Last User ID"
#define SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS TEXT("Last MailBox Email address")
#define SZ_REGVALUE_READEMAILPATH   TEXT("ReadEmailPath")
#define SZ_REGVALUE_READEMAILCMDLINE   TEXT("ReadEmailCmdLine")

#define SZ_REGVALUE_WEB             L"WEB"
#define SZ_REGVALUE_URL             L"URL"
#define SZ_REGVALUE_MAILPROTOCOLS   L"MailProtocols"
#define SZ_REGVALUE_MAILPROTOCOL    L"MailProtocol"
#define SZ_REGVALUE_PREFERREDAPP    L"Preferred App"

#define SZ_REGDATA_WEB              L"WEB"

#define SZ_TOKEN_EMAILADDRESS       L"<EmailAddress>"

// Just Works, AutoDiscovery
#define SZ_REGKEY_AUTODISCOVERY     L"Software\\Microsoft\\Windows\\CurrentVersion\\JustWorks\\AutoDiscovery"
#define SZ_REGKEY_GLOBALSERVICES    SZ_REGKEY_AUTODISCOVERY L"\\GlobalServices"
#define SZ_REGKEY_SERVICESALLOWLIST SZ_REGKEY_GLOBALSERVICES L"\\AllowList"
#define SZ_REGKEY_EMAIL_MRU         SZ_REGKEY_AUTODISCOVERY L"\\EmailMRU"

#define SZ_REGVALUE_SERVICES_POLICY L"Use Global Services"      // If FALSE (SZ_REGKEY_AUTODISCOVERY), then the global services won't be used.
#define SZ_REGVALUE_MS_ONLY_ADDRESSES L"Service On List"        // If TRUE (SZ_REGKEY_AUTODISCOVERY), then only use the global services if the email domain is in the list.
#define SZ_REGVALUE_TEST_INTRANETS  L"Test Intranets"           // If TRUE (SZ_REGKEY_AUTODISCOVERY), then we will still hit the secondary servers for intranet email addresses.

// XML Elements
#define SZ_XMLELEMENT_AUTODISCOVERY L"AUTODISCOVERY"

#define SZ_XMLELEMENT_REQUEST       L"REQUEST"
#define SZ_XMLELEMENT_ACCOUNT       L"ACCOUNT"
#define SZ_XMLELEMENT_TYPE          L"TYPE"
#define SZ_XMLELEMENT_VERSION       L"VERSION"
#define SZ_XMLELEMENT_RESPONSEVER   L"RESPONSEVER"
#define SZ_XMLELEMENT_LANG          L"LANG"
#define SZ_XMLELEMENT_EMAIL         L"EMAIL"

#define SZ_XMLELEMENT_RESPONSE      L"RESPONSE"
#define SZ_XMLELEMENT_USER          L"USER"
#define SZ_XMLELEMENT_INFOURL       L"INFOURL"
#define SZ_XMLELEMENT_DISPLAYNAME   L"DISPLAYNAME"
#define SZ_XMLELEMENT_ACTION        L"ACTION"
#define SZ_XMLELEMENT_PROTOCOL      L"PROTOCOL"
#define SZ_XMLELEMENT_SERVER        L"SERVER"
#define SZ_XMLELEMENT_PORT          L"PORT"
#define SZ_XMLELEMENT_LOGINNAME     L"LOGINNAME"
#define SZ_XMLELEMENT_SPA           L"SPA"
#define SZ_XMLELEMENT_SSL           L"SSL"
#define SZ_XMLELEMENT_AUTHREQUIRED  L"AUTHREQUIRED"
#define SZ_XMLELEMENT_USEPOPAUTH    L"USEPOPAUTH"
#define SZ_XMLELEMENT_POSTHTML      L"PostHTML"
#define SZ_XMLELEMENT_REDIRURL      L"URL"

#define SZ_XMLTEXT_EMAIL            L"EMAIL"
#define SZ_XMLTEXT_SETTINGS         L"settings"
#define SZ_XMLTEXT_REDIRECT         L"REDIRECT"






// getXML() Querys & Actions
#define SZ_QUERYDATA_TRUE           L"True"
#define SZ_QUERYDATA_FALSE          L"False"




// AutoDiscovery
#define SZ_SERVERPORT_DEFAULT       L"Default"
#define SZ_HTTP_VERB_POST           "POST"

// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'
#define CH_COMMA                   L','






/*****************************************************************************\
    Local Includes
\*****************************************************************************/
#include "dllload.h"
#include "util.h"


/*****************************************************************************\
    Object Constructors
\*****************************************************************************/
HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
STDAPI CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
STDAPI CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
STDAPI CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);
STDAPI CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#define DECL_CRTFREE
#include <crtfree.h>

#define COMPILE_MULTIMON_STUBS
#include <multimon.h>

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle



#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

//    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


LPSTR AllocStringFromBStr(BSTR bstr)
{
    USES_CONVERSION;        // atlbase.h

    char *a = W2A((bstr ? bstr : L""));
    int len = 1 + lstrlenA(a);

    char *p = (char *)LocalAlloc(LPTR, len);
    if (p)
    {
        StrCpyNA(p, a, len);
    }

    return p;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof(buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyNW(pwszEscapedSequence, &pwszEscapedSequence[2], lstrlen(pwszEscapedSequence)+1);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
\*****************************************************************************/
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}



#define SZ_VALID_XML      L"<?xml"

/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_PPV_ARG(IStream, &pStream)); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeRoot));

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeToAppend));
        if (SUCCEEDED(hr))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDOMDoc));

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppXMLDOMDoc);
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean)
{
    BSTR bstr;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstr);

    if (SUCCEEDED(hr))
    {
        if (!StrCmpIW(bstr, L"on"))
        {
            *pfBoolean = TRUE;
        }
        else
        {
            *pfBoolean = FALSE;
        }

        SysFreeString(bstr);
    }

    return hr;
}


BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText)
{
    BOOL fIsChildTagTextEqual = FALSE;
    BSTR bstrChildText;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstrChildText);

    if (SUCCEEDED(hr))
    {
        // Is this <TYPE>email</TYPE>?
        if (!StrCmpIW(bstrChildText, bstrText))
        {
            // No, so keep looking.
            fIsChildTagTextEqual = TRUE;
        }

        SysFreeString(bstrChildText);
    }

    return fIsChildTagTextEqual;
}




/////////////////////////////////////////////////////////////////////
// Wininet Wrapping Helpers
/////////////////////////////////////////////////////////////////////
#define EMPTYSTR_FOR_NULL(str)      ((!str) ? TEXT("") : (str))

/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but ftp.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetConnect(%#08lx, \"%ls\", \"%ls\", \"%ls\") returned %u. Time=%lums", hInternet, pszServerName, EMPTYSTR_FOR_NULL(pszUserName), EMPTYSTR_FOR_NULL(pszPassword), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phConnectionHandle = HttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferer, lpszAcceptTypes, dwFlags, dwContext);
    if (!*phConnectionHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "HttpOpenRequest(%#08lx, \"%ls\") returned %u. Time=%lums", *phConnectionHandle, lpszVerb, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!HttpSendRequestA(hRequest, lpszHeaders,  dwHeadersLength, lpOptional, dwOptionalLength))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CreateUrlCacheEntry(lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CommitUrlCacheEntryW(lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, lpszOriginalUrl))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}



#define SIZE_COPY_BUFFER                    (32 * 1024)     // 32k

HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML)
{
    BYTE byteBuffer[SIZE_COPY_BUFFER];
    DWORD cbRead = SIZE_COPY_BUFFER;
    DWORD cchSize = 0;
    HRESULT hr = S_OK;

    *pbstrXML = NULL;
    while (SUCCEEDED(hr) && cbRead)
    {
        hr = InternetReadFileWrap(hInternetRead, byteBuffer, sizeof(byteBuffer), &cbRead);
        if (SUCCEEDED(hr) && cbRead)
        {
            BSTR bstrOld = *pbstrXML;
            BSTR bstrEnd;

            // The string may not be terminated.
            byteBuffer[cbRead] = 0;

            cchSize += ARRAYSIZE(byteBuffer);
            *pbstrXML = SysAllocStringLen(NULL, cchSize);
            if (*pbstrXML)
            {
                if (bstrOld)
                {
                    StrCpyN(*pbstrXML, bstrOld, cchSize);
                }
                else
                {
                    (*pbstrXML)[0] = 0;
                }

                bstrEnd = *pbstrXML + lstrlenW(*pbstrXML);
                cchSize -= lstrlenW(*pbstrXML);

                SHAnsiToUnicode((LPCSTR) byteBuffer, bstrEnd, cchSize);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SysFreeString(bstrOld);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////

HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))





// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hres = NOERROR;
    int nSection = 0;         // How many buffer sizes have we copied?
    ULARGE_INTEGER uliNewCompleted;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            if (0 == (nSection % STREAM_PROGRESS_INTERVAL))
            {
                ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart);

                if (ppi->ppd->HasUserCancelled())
                {
                    hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
        }

        hres = pstmFrom->Read(buf, min(cb.LowPart, sizeof(buf)), &cbRead);
        if (FAILED(hres) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hres))
                hres = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hres) || (cbRead == 0))
            break;

        nSection++;
    }

    return hres;
}

/*
// These are needed for COM/COM+ interop

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
        throw _com_error(hr, perrinfo);
}

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
        _com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
        IErrorInfo* perrinfo = NULL;
        if (punk == NULL) {
                goto exeunt;
        }
        ISupportErrorInfo* psei;
        if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
                           (void**)&psei))) {
                goto exeunt;
        }
        HRESULT hrSupportsErrorInfo;
        hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
        psei->Release();
        if (hrSupportsErrorInfo != S_OK) {
                goto exeunt;
        }
        if (GetErrorInfo(0, &perrinfo) != S_OK) {
                perrinfo = NULL;
        }
exeunt:
        _com_raise_error(hr, perrinfo);
}
*/
// needed by smtpserv:

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    StrCpyNA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    StrCpyNA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT)(UINT)(pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT)(UINT)(pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}



// BUGBUG: This makes this object ways safe.  When the MailApps security design is
//    complete, this needs to be removed for the permanate security solution.
HRESULT MarkObjectSafe(IUnknown * punk)
{
    HRESULT hr = S_OK;
    IObjectSafety * pos;

    hr = punk->QueryInterface(IID_PPV_ARG(IObjectSafety, &pos));
    if (SUCCEEDED(hr))
    {
        // BUGBUG: This makes this object ways safe.  When the MailApps security design is
        //    complete, this needs to be removed for the permanate solution.
        pos->SetInterfaceSafetyOptions(IID_IDispatch, (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA), 0);
        pos->Release();
    }

    return hr;
}


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    ULARGE_INTEGER uiResult;

    uiResult.QuadPart = (ULONGLONG) ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    if (32 < uiResult.QuadPart)
    {
        uiResult.LowPart = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(uiResult.LowPart);
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (pszNextToken = StrStrI(pszNextToken, pszToken))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    if (p)
    {
        LocalFree(p);
    }

    return 1;
}


// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    int nSort = 0;      // Default to equal

    if (pvString1 && pvString2)
    {
        nSort = StrCmp((LPCTSTR)pvString1, (LPCTSTR)pvString2);
    }

    return nSort;
}



HRESULT AddHDPA_StrDup(IN LPCWSTR pszString, IN HDPA * phdpa)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!*phdpa)
    {
        *phdpa = DPA_Create(2);
    }

    if (*phdpa)
    {
        LPWSTR pszStringCopy = StrDup(pszString);

        if (pszStringCopy)
        {
            if (-1 == DPA_SortedInsertPtr(*phdpa, pszStringCopy, 0, DPA_StringCompareCB, NULL, DPAS_INSERTBEFORE, pszStringCopy))
            {
                // We failed so free the memory
                LocalFree(pszStringCopy);
            }
            else
            {
                hr = S_OK;
            }
        }
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "dllload.h"
#define HINST_THISDLL       g_hinst


// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
LPSTR AllocStringFromBStr(BSTR bstr);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);
HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean);
BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText);




// Wininet Helpers
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle);
HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength);
HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved);
HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl);
HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);


// File System Helpers
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle);
HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
HRESULT DeleteFileHrWrap(LPCWSTR pszPath);


// DPA Helpers
int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData);
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam);
HRESULT AddHDPA_StrDup(IN LPCWSTR pszString, IN HDPA * phdpa);

// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
HRESULT MarkObjectSafe(IUnknown * punk);
BOOL _InitComCtl32();
DWORD GetOSVer(void);
BOOL IsOSNT(void);





// Other Wrappers
HRESULT HrRewindStream(IStream * pstm);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);




typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi);

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);



#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\wizard.cpp ===
/*****************************************************************************\
    FILE: wizard.cpp

    DESCRIPTION:
        This file implements the wizard used to "AutoDiscover" the data that
    matches an email address to a protocol.  It will also provide other UI
    needed in that process.

    BryanSt 3/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "wizard.h"
#include "mailbox.h"

#ifdef FEATURE_MAILBOX

#define WIZDLG(name, dlgproc, dwFlags)   \
            { MAKEINTRESOURCE(IDD_##name##_PAGE), dlgproc, MAKEINTRESOURCE(IDS_##name##), MAKEINTRESOURCE(IDS_##name##_SUB), dwFlags }

// The wizard pages we are adding
struct
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
}
g_pages[] =
{
    WIZDLG(ASSOC_GETEMAILADDRESS,       GetEmailAddressDialogProc,       0),
    WIZDLG(AUTODISCOVER_PROGRESS,       MailBoxProgressDialogProc,       0),
    WIZDLG(MANUALLY_CHOOSE_APP,         ChooseAppDialogProc,      0),
};


//-----------------------------------------------------------------------------
//  Main entry point used to invoke the wizard.
//-----------------------------------------------------------------------------
/*
static WNDPROC _oldDlgWndProc;

LRESULT CALLBACK _WizardSubWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // on WM_WINDOWPOSCHANGING and the window is moving then lets centre it onto the
    // desktop window.  unfortunately setting the DS_CENTER bit doesn't buy us anything
    // as the wizard is resized after creation.
    //

    if ( uMsg == WM_WINDOWPOSCHANGING )
    {
        LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
        RECT rcDlg, rcDesktop;

        GetWindowRect(hwnd, &rcDlg);
        GetWindowRect(GetDesktopWindow(), &rcDesktop);

        lpwp->x = ((rcDesktop.right-rcDesktop.left)-(rcDlg.right-rcDlg.left))/2;
        lpwp->y = ((rcDesktop.bottom-rcDesktop.top)-(rcDlg.bottom-rcDlg.top))/2;
        lpwp->flags &= ~SWP_NOMOVE;
    }

    return _oldDlgWndProc(hwnd, uMsg, wParam, lParam);        
}
*/


int CALLBACK _PropSheetCB(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
    // in pre-create lets set the window styles accorindlgy
    //      - remove the context menu and system menu
    case PSCB_PRECREATE:
    {
        DLGTEMPLATE *pdlgtmp = (DLGTEMPLATE*)lParam;
        pdlgtmp->style &= ~(DS_CONTEXTHELP|WS_SYSMENU);
        break;
    }

    // we now have a dialog, so lets sub class it so we can stop it being
    // move around.
    case PSCB_INITIALIZED:
    {
        // TODO: David, why do this?
//            if ( g_uWizardIs != NAW_NETID )
//                _oldDlgWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_WizardSubWndProc);

        break;
    }
 
    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case LVN_GETDISPINFO:
            uMsg++;
            break;
        }
    }
    default:
        TraceMsg(TF_ALWAYS, "_PropSheetCB(uMsg = %d)", uMsg);
        break;
    }

    return FALSE;
}


STDAPI DisplayMailBoxWizard(LPARAM lParam, BOOL fShowGetEmailPage)
{
    HWND hwndParent = NULL;
    HRESULT hr = S_OK;
    PROPSHEETHEADER psh = { 0 };
    HPROPSHEETPAGE rghpage[ARRAYSIZE(g_pages)];
    INT_PTR nResult;
    int nCurrentPage;
    int nPages;
    int nFirstPage;

    if (fShowGetEmailPage)
    {
        nFirstPage = 0;
        nPages = ARRAYSIZE(g_pages);
    }
    else
    {
        nFirstPage = 1;
        nPages = ARRAYSIZE(g_pages) - 1;
    }
    
    // build the pages for the wizard.
    for (nCurrentPage = 0; nCurrentPage < ARRAYSIZE(g_pages) ; nCurrentPage++ )
    {                           
        PROPSHEETPAGE psp = { 0 };
        WCHAR szBuffer[MAX_PATH] = { 0 };

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.hInstance = HINST_THISDLL;
        psp.lParam = lParam;
        psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER | g_pages[nCurrentPage + nFirstPage].dwFlags; // Do we want: PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | (PSP_USECALLBACK | )
        psp.pszTemplate = g_pages[nCurrentPage + nFirstPage].idPage;
        psp.pfnDlgProc = g_pages[nCurrentPage + nFirstPage].pDlgProc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_AUTODISCOVER_WIZARD_CAPTION);
        psp.pszHeaderTitle = g_pages[nCurrentPage + nFirstPage].pHeading;
        psp.pszHeaderSubTitle = g_pages[nCurrentPage + nFirstPage].pSubHeading;

        rghpage[nCurrentPage] = CreatePropertySheetPage(&psp);
    }

    // wizard pages are ready, so lets display the wizard.
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.hwndParent = hwndParent;
    psh.hInstance = HINST_THISDLL;

    // TODO: We will want to add this PSH_HASHELP, PSH_USEICONID 
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE | PSH_NOAPPLYNOW | PSH_USECALLBACK;  // PSH_WATERMARK
//    psh.pszbmHeader = MAKEINTRESOURCE(IDB_PSW_BANNER);
//    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_PSW_WATERMARK);
    psh.nPages = nPages;
    psh.phpage = rghpage;
    psh.pfnCallback = _PropSheetCB;

    nResult = PropertySheet(&psh);

    return hr;
}


#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\autodiscovery\client\wizard.h ===
/*****************************************************************************\
    FILE: wizard.h

    DESCRIPTION:
        This file implements the wizard used to "AutoDiscover" the data that
    matches an email address to a protocol.  It will also provide other UI
    needed in that process.

    BryanSt 3/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _WIZARD_H
#define _WIZARD_H
#ifdef FEATURE_MAILBOX


STDAPI DisplayMailBoxWizard(LPARAM lParam, BOOL fShowGetEmailPage);



#endif // FEATURE_MAILBOX
#endif // _WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\certfram.cpp ===
#include        "pch.hxx"
#ifndef WIN16
#include        <commctrl.h>
#endif // !WIN16
#include        "demand.h"

////////////////////////////////////////////////////////

CCertFrame::CCertFrame(PCCERT_CONTEXT pccert) {
        m_pccert = CertDuplicateCertificateContext(pccert);
        m_pcfNext = NULL;
        m_cParents = 0;
        m_dwFlags = 0;
        m_cTrust = 0;
        m_rgTrust = NULL;
        m_fSelfSign = FALSE;
        m_fRootStore = FALSE;
        m_fLeaf = FALSE;
        m_fExpired = FALSE;
    }

CCertFrame::~CCertFrame(void)
{
    int     i;
    CertFreeCertificateContext(m_pccert);
    for (i=0; i<m_cParents; i++) {
        delete m_rgpcfParents[i];
    }
    for (i=0; i<m_cTrust; i++) {
        delete m_rgTrust[i].pbTrustData;
    }
    delete m_rgTrust;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __DEMAND_H
#define __DEMAND_H

#ifndef MAC
//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;
#if 0
// my 1st attempt
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
    BOOL DemandLoad##fnsuffix()                     \
    {                                               \
        BOOL                fRet = TRUE;            \
                                                    \
        Assert(fInit);                              \
        EnterCriticalSection(&cs);                  \
                                                    \
        if (0 == handle)                            \
            {                                       \
            handle = LoadLibrary(#dllname);         \
                                                    \
            if (0 == handle)                        \
                fRet = FALSE;                       \
            else                                    \
                {                                   \
                procaddrlist                        \
                }                                   \
            }                                       \
                                                    \
        LeaveCriticalSection(&cs);                  \
        return fRet;                                \
    }
#endif

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#if 0
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
        BOOL DemandLoad##fnsuffix(void);
#endif

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertDeleteCertificateFromStore,
    (PCCERT_CONTEXT pccert),
    (pccert),
    FALSE, Crypt32)
#define CertDeleteCertificateFromStore VAR_CertDeleteCertificateFromStore

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv,
     DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CryptFormatObject,
    (DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType,
     void * pFormatStruct, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, void * pbFormat, DWORD * pcbFormat),
    (dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct,
     lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat),
    FALSE, Crypt32)
#define CryptFormatObject VAR_CryptFormatObject

LOADER_FUNCTION( DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrW VAR_CertNameToStrW

LOADER_FUNCTION( BOOL, CertStrToNameA,
    (DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved,
     BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved,
     pbEncoded, pcbEncoded, ppszError),
     FALSE, Crypt32)
#define CertStrToNameA VAR_CertStrToNameA

LOADER_FUNCTION( DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz),
    0, Crypt32)
#define CertRDNValueToStrW VAR_CertRDNValueToStrW

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    FALSE, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, CryptUnregisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID),
    (dwEncodingType, pszFuncName, pszOID),
    FALSE, Crypt32)
#define CryptUnregisterOIDFunction VAR_CryptUnregisterOIDFunction

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void * pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    FALSE, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifyCTLUsage,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCTL_USAGE pSubjectUsage, DWORD dwFlags,
     PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
     PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus),
    (dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags,
     pVerifyUsagePara, pVerifyUsageStatus),
    0, Crypt32)
#define CertVerifyCTLUsage VAR_CertVerifyCTLUsage

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext,
     PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertFreeCTLContext,
    (PCCTL_CONTEXT pCtlContext),
    (pCtlContext),
    FALSE, Crypt32)
#define CertFreeCTLContext VAR_CertFreeCTLContext

LOADER_FUNCTION( BOOL, CertAddEncodedCTLToStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded,
     DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded,
     dwAddDisposition, ppCtlContext),
    FALSE, Crypt32)
#define CertAddEncodedCTLToStore VAR_CertAddEncodedCTLToStore

LOADER_FUNCTION( BOOL, CryptMsgEncodeAndSignCTL,
    (DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo,
     DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptMsgEncodeAndSignCTL VAR_CryptMsgEncodeAndSignCTL

LOADER_FUNCTION( PCCTL_CONTEXT, CertFindCTLInStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags,
     DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, dwFindFlags,
     dwFindType, pvFindPara, pPrevCtlContext),
    NULL, Crypt32)
#define CertFindCTLInStore VAR_CertFindCTLInStore

LOADER_FUNCTION( PCCTL_CONTEXT, CryptSignAndEncodeCertificate,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     LPCSTR lpszStructType, const void *pvStructInfo,
     PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
     const void *pvHashAuxInfo, PBYTE pbEncoded, DWORD *pcbEncoded),
    (hCryptProv, dwKeySpec, dwCertEncodingType, lpszStructType,
     pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded,
     pcbEncoded),
    NULL, Crypt32)
#define CryptSignAndEncodeCertificate VAR_CryptSignAndEncodeCertificate

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo,
     BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded,pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptExportPublicKeyInfo,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo),
    (hCryptProv, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo),
    FALSE, Crypt32)
#define CryptExportPublicKeyInfo VAR_CryptExportPublicKeyInfo

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    +1, Crypt32)                // Return AFTER by default
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( PCTL_ENTRY, CertFindSubjectInCTL,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCCTL_CONTEXT pCtlContext, DWORD dwFlags),
    (dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags),
    NULL, Crypt32)
#define CertFindSubjectInCTL VAR_CertFindSubjectInCTL

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION( BOOL, CertGetCertificateChain,
    (
        HCERTCHAINENGINE hChainEngine,
        PCCERT_CONTEXT pCertContext,
        LPFILETIME pTime,
        HCERTSTORE hAdditionalStore,
        PCERT_CHAIN_PARA pChainPara,
        DWORD dwFlags,
        LPVOID pvReserved,
        PCCERT_CHAIN_CONTEXT* ppChainContext
    ),
    (
        hChainEngine,
        pCertContext,
        pTime,
        hAdditionalStore,
        pChainPara,
        dwFlags,
        pvReserved,
        ppChainContext
    ),
    FALSE, Crypt32)
#define CertGetCertificateChain VAR_CertGetCertificateChain

LOADER_FUNCTION( BOOL, CertFreeCertificateChain,
    (
        PCCERT_CHAIN_CONTEXT pChainContext
    ),
    (
        pChainContext
    ),
    FALSE, Crypt32)
#define CertFreeCertificateChain VAR_CertFreeCertificateChain

LOADER_FUNCTION( PCCERT_CHAIN_CONTEXT, CertDuplicateCertificateChain,
    (
        PCCERT_CHAIN_CONTEXT pChainContext
    ),
    (
        pChainContext
    ),
    NULL, Crypt32)
#define CertDuplicateCertificateChain VAR_CertDuplicateCertificateChain

LOADER_FUNCTION( BOOL, CertAddStoreToCollection,
    (
        HCERTSTORE hCollectionStore,
        HCERTSTORE hSiblingStore,
        DWORD dwUpdateFlags,
        DWORD dwPriority
    ),
    (
        hCollectionStore,
        hSiblingStore,
        dwUpdateFlags,
        dwPriority
    ),
    FALSE, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (
        HCERTSTORE hCertStore,
        PCCERT_CONTEXT pCertContext,
        DWORD dwAddDisposition,
        PCCERT_CONTEXT *ppStoreContext
    ),
    (
        hCertStore,
        pCertContext,
        dwAddDisposition,
        ppStoreContext
    ),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( BOOL, CertControlStore,
    (
        HCERTSTORE hCertStore,
        DWORD dwFlags,
        DWORD dwCtrlType,
        void const *pvCtrlPara
    ),
    (
        hCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
    ),
    FALSE, Crypt32)
#define CertControlStore VAR_CertControlStore

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0


/////////////////////////////////////
// CRYPTUI.DLL

BOOL DemandLoadCryptUI(void);
BOOL CryptUIAvailable(void);

#ifdef OLD_STUFF
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;

typedef const struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

typedef const struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

typedef const struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;
#endif


LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificateW,
   (IN PCCRYPTUI_VIEWCERTIFICATE_STRUCTW pCertViewInfo, OUT BOOL *pfPropertiesChanged),
   (pCertViewInfo, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificateW VAR_CryptUIDlgViewCertificateW

LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificateA,
   (IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA pCertViewInfo, OUT BOOL *pfPropertiesChanged),
   (pCertViewInfo, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificateA VAR_CryptUIDlgViewCertificateA


LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificatePropertiesW,
   (IN PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp, OUT BOOL *pfPropertiesChanged),
   (pcsp, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificatePropertiesW VAR_CryptUIDlgViewCertificatePropertiesW

LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificatePropertiesA,
   (IN PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp, OUT BOOL *pfPropertiesChanged),
   (pcsp, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificatePropertiesA VAR_CryptUIDlgViewCertificatePropertiesA


LOADER_FUNCTION(PCCERT_CONTEXT, CryptUIDlgSelectCertificateW,
    (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc),
    (pcsc),
    NULL, CryptUI)
#define CryptUIDlgSelectCertificateW VAR_CryptUIDlgSelectCertificateW

LOADER_FUNCTION(PCCERT_CONTEXT, CryptUIDlgSelectCertificateA,
    (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc),
    (pcsc),
    NULL, CryptUI)
#define CryptUIDlgSelectCertificateA VAR_CryptUIDlgSelectCertificateA

LOADER_FUNCTION( BOOL, CryptInstallDefaultContext,
    (HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara,
     DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext),
    (hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, 
     phDefaultContext),
    FALSE, Crypt32)
#define CryptInstallDefaultContext VAR_CryptInstallDefaultContext

LOADER_FUNCTION( BOOL, CryptUninstallDefaultContext,
    (HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved),
    (hDefaultContext, dwFlags, pvReserved),
    FALSE, Crypt32)
#define CryptUninstallDefaultContext VAR_CryptUninstallDefaultContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0


/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#if 0
LOADER_FUNCTION( BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags),
    (hProv, dwParam, pbData, pdwDataLen, dwFlags),
    FALSE, AdvApi32)
#define CryptGetProvParam VAR_CryptGetProvParam

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptGenKey,
    (HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey),
    (hProv, Algid, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptGenKey VAR_CryptGenKey

LOADER_FUNCTION( BOOL, CryptDestroyKey,
    (HCRYPTKEY hKey),
    (hKey),
    FALSE, AdvApi32)
#define CryptDestroyKey VAR_CryptDestroyKey
#endif // 0


#ifndef WIN16

/////////////////////////////////////
// USER32.DLL

BOOL DemandLoadUser32();

LOADER_FUNCTION( LRESULT, SendDlgItemMessageW,
    (HWND hwnd, int idCtl, UINT msg, WPARAM wparam, LPARAM lparam),
    (hwnd, idCtl, msg, wparam, lparam),
    -1, User32)
#define SendDlgItemMessageW VAR_SendDlgItemMessageW

LOADER_FUNCTION( BOOL, SetDlgItemTextW,
    (HWND hwnd, int idCtl, LPCWSTR psz),
    (hwnd, idCtl, psz),
    FALSE, User32)
#define SetDlgItemTextW VAR_SetDlgItemTextW

LOADER_FUNCTION( UINT, GetDlgItemTextW,
    (HWND hwnd, int idCtl, LPWSTR psz, int nMax),
    (hwnd, idCtl, psz, nMax),
    FALSE, User32)
#define GetDlgItemTextW VAR_GetDlgItemTextW

LOADER_FUNCTION( int, LoadStringW,
    (HINSTANCE hinst, UINT idStr, LPWSTR rgwch, int cwch),
    (hinst, idStr, rgwch, cwch),
    0, User32)
#define LoadStringW VAR_LoadStringW

LOADER_FUNCTION( DWORD, FormatMessageW,
    (DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
     DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize, va_list * args),
    (dwFlags, pbSource, dwMessageId, dwLangId, lpBuffer, nSize, args),
    0, User32)
#define FormatMessageW VAR_FormatMessageW

LOADER_FUNCTION( BOOL, WinHelpW,
    (HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData),
    (hWndMain, szHelp, uCommand, dwData),
    FALSE, User32)
#define WinHelpW VAR_WinHelpW

#endif // !WIN16

#else   // MAC
#define SendDlgItemMessageW MySendDlgItemMessageW
#define SetDlgItemTextW     MySetDlgItemTextW
#define GetDlgItemTextW     MyGetDlgItemTextW
#define LoadStringW         MyLoadStringW
#define FormatMessageW      MyFormatMessageW
#define WinHelpW            MyWinHelpW
#define SendMessageW        SendMessageA
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // !MAC
#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\fineprnt.cpp ===
//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

#include "pch.hxx"
#include "demand.h"

extern HINSTANCE       HinstDll;
#ifndef MAC
extern HMODULE         HmodRichEdit;
#endif  // !MAC

INT_PTR CALLBACK FinePrintDlgProc(HWND hwndDlg, UINT msg,
                               WPARAM wParam, LPARAM lParam)
{
#if 0
    int                 c;
    CERT_VIEWPROPERTIES_STRUCT_W        cvps;
    DWORD               dw;
    int                 i;
    DWORD               iStore;
    LPWSTR              pwsz;
    PCERT_SELECT_STRUCT pcss;
#endif // 0
    BOOL                f;
    PCCERT_CONTEXT      pccert;
    
    switch (msg) {
    case WM_INITDIALOG:
        //  Center the dialog on its parent
        //        CenterThisDialog(hwndDlg);

        //
        pccert = (PCCERT_CONTEXT) lParam;

        FormatSubject(hwndDlg, IDC_ISSUED_TO, pccert);
        FormatIssuer(hwndDlg, IDC_ISSUED_BY, pccert);
        
        //
        //  Setup the CPS if we can find one
        //

        if (FormatCPS(hwndDlg, IDC_TEXT, pccert)) {
            RecognizeURLs(GetDlgItem(hwndDlg, IDC_TEXT));
            SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETEVENTMASK, 0,
                               ENM_LINK);
        }

        //  Grey out the rich edit boxs
        SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_TO, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_BY, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        break;

    case WM_NOTIFY:
        if (((NMHDR FAR *) lParam)->code == EN_LINK) {
            if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN) {
                f = FNoteDlgNotifyLink(hwndDlg, (ENLINK *) lParam, NULL);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, f);
                return f;
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        break;

        //
        //  Use the default handler -- we don't do anything for it
        //
        
    default:
        return FALSE;
    }

    return TRUE;
}                               // FinePrint()


BOOL FinePrint(PCCERT_CONTEXT pccert, HWND hwndParent)
{
    int         ret;

    //  We use the common controls -- so make sure they have been loaded

#ifndef WIN16
#ifndef MAC
    if (FIsWin95) {
        if (HmodRichEdit == NULL) {
            HmodRichEdit = LoadLibraryA("RichEd32.dll");
            if (HmodRichEdit == NULL) {
                return FALSE;
            }
        }
    }
    else {
        if (HmodRichEdit == NULL) {
            HmodRichEdit = LoadLibrary(L"RichEd32.dll");
            if (HmodRichEdit == NULL) {
                return FALSE;
            }
        }
    }
    //  Now launch the dialog

    if (FIsWin95) {
#endif  // !MAC
        ret = (int) DialogBoxParamA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDD_FINE_PRINT),
                             hwndParent, FinePrintDlgProc,
                             (LPARAM) pccert);
#ifndef MAC
    }
    else {
        ret = (int) DialogBoxParamW(HinstDll, MAKEINTRESOURCE(IDD_FINE_PRINT),
                              hwndParent, FinePrintDlgProc,
                              (LPARAM) pccert);
    }
#endif  // !MAC

#else // WIN16
    if (HmodRichEdit == NULL) {
        HmodRichEdit = LoadLibrary("RichEd.dll");
        if (HmodRichEdit == NULL) {
            return FALSE;
        }
    }
    //  Now launch the dialog

    ret = (int) DialogBoxParam(HinstDll, MAKEINTRESOURCE(IDD_FINE_PRINT),
                          hwndParent, FinePrintDlgProc,
                          (LPARAM) pccert);
#endif // !WIN16

    return (ret == IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\trust.cpp ===
#include        "pch.hxx"

BOOL CertConfigureTrustA(void)
{
    return FALSE;
}

BOOL CertConfigureTrustW(void)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\demand.cpp ===
/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include <pch.hxx>

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

#ifndef MAC
////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn" failed to load");    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }
            

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##varname != NULL);

////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hShell32 = 0;
static HMODULE          s_hCryptUI = 0;
#if 0 // JLS
static HMODULE          s_hShLWAPI = 0;
static HMODULE          s_hURLMon = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hWinINET = 0;
static HMODULE          s_hComctl32 = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hMAPI = 0;
static HMODULE          s_hWSOCK = 0;
static HMODULE          s_hOLEAUT = 0;
static HMODULE          s_hKernel = 0;
#endif // 0 // JLS

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hShell32)
        FreeLibrary(s_hShell32);
    if (s_hCryptUI)
        FreeLibrary(s_hCryptUI);
#if 0 //JLS
    if (s_hShLWAPI)
        FreeLibrary(s_hShLWAPI);
    if (s_hURLMon)
        FreeLibrary(s_hURLMon);
    if (s_hOLEAUT)
        FreeLibrary(s_hOLEAUT);
    if (s_hMAPI)
        FreeLibrary(s_hMAPI);
    if (s_hWSOCK)
        FreeLibrary(s_hWSOCK);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hKernel)
        FreeLibrary(s_hKernel);
#endif // JLS
#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

#if 0 // JLS
////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/
#endif // 0

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt) {
        s_hCrypt = LoadLibraryA("CRYPT32.DLL");
        // AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CryptFormatObject)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrW)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameA)
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrW)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CryptUnregisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertVerifyCTLUsage)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCTLContext)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCTLToStore)
            GET_PROC_ADDR(s_hCrypt, CryptMsgEncodeAndSignCTL)
            GET_PROC_ADDR(s_hCrypt, CertFindCTLInStore)
            GET_PROC_ADDR(s_hCrypt, CryptSignAndEncodeCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CryptExportPublicKeyInfo)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore);
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity);
            GET_PROC_ADDR(s_hCrypt, CertFindSubjectInCTL);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
            GET_PROC_ADDR(s_hCrypt, CryptInstallDefaultContext);
            GET_PROC_ADDR(s_hCrypt, CryptUninstallDefaultContext);
            GET_PROC_ADDR(s_hCrypt, CertDeleteCertificateFromStore);
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore);

            GET_PROC_ADDR(s_hCrypt, CertGetCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore);
            GET_PROC_ADDR(s_hCrypt, CertControlStore);

        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL DemandLoadCryptUI()
{
    static BOOL         fRet = FALSE;
    static BOOL         fAttempt = FALSE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCryptUI && ! fAttempt) {
        s_hCryptUI = LoadLibraryA("CRYPTUI.DLL");
        // AssertSz((BOOL)s_hCryptUI, TEXT("LoadLibrary failed on CRYPTUI.DLL"));

        fAttempt = TRUE;

        if (s_hCryptUI) {
            fRet = TRUE;
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificateW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificateA)

            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificatePropertiesW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificatePropertiesA)

            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgSelectCertificateW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgSelectCertificateA)
#ifdef OLD_STUFF
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgCertMgr)
#endif // OLD_STUFF
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL CryptUIAvailable(void) {
    return(DemandLoadCryptUI());
}


BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibraryA("ADVAPI32.DLL");
        //  AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else {
            if (FIsWin95) {
                VAR_CryptAcquireContextW = MyCryptAcquireContextW;
            }
            else {
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW);
            }
#if 0
            GET_PROC_ADDR(s_hAdvApi, CryptGetProvParam)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            GET_PROC_ADDR(s_hAdvApi, CryptGenKey)
            GET_PROC_ADDR(s_hAdvApi, CryptDestroyKey)
#endif // 0
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#ifndef WIN16

BOOL DemandLoadUser32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
#undef SendDlgitemMessageW
#undef SetDlgItemTextW
#undef GetDlgItemTextW
#undef LoadStringW
#undef FormatMessageW

    if (0 == s_hShell32) {
        if (FIsWin95) {
            VAR_SendDlgItemMessageW = MySendDlgItemMessageW;
            VAR_SetDlgItemTextW = MySetDlgItemTextW;
            VAR_GetDlgItemTextW = MyGetDlgItemTextW;
            VAR_LoadStringW = MyLoadStringW;
            VAR_FormatMessageW = MyFormatMessageW;
            VAR_WinHelpW = MyWinHelpW;
        }
        else {
            s_hShell32 = LoadLibraryA("kernel32.dll");
            GET_PROC_ADDR(s_hShell32, FormatMessageW);
            FreeLibrary(s_hShell32);

            s_hShell32 = LoadLibraryA("USER32.DLL");
            GET_PROC_ADDR(s_hShell32, SendDlgItemMessageW);
            GET_PROC_ADDR(s_hShell32, SetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, GetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, LoadStringW);
            GET_PROC_ADDR(s_hShell32, WinHelpW);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


#endif // !WIN16

#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptdlg.rc
//

// For dialogs, the range of numbers you should use
// are from 130 through 149.
#define IDD_CERTPROP_GENERAL            130
#define IDD_CERTPROP_DETAILS            131
#define IDD_CERTPROP_TRUST              132
#define IDD_CERTPROP_ADVANCED           133
#define IDD_SELECT_DIALOG               134
#define IDD_TRUST                       135
#define IDD_FINE_PRINT                  136
#define IDD_CRYPTUI_CERTPROP_TRUST      137

// For bitmaps, the range of numbers you should use
// are from 300 through 319.
#define IDB_TICK                        300
#define IDB_CROSS                       301
#define IDB_TREE_IMAGES                 302

// For strings, the range of numbers you should use
// are from 3184 through 3503.
#define IDS_GENERAL_TICK                3184
#define IDS_GENERAL_CROSS               3185
#define IDS_GENERAL_INFO                3186
#define IDS_GENERAL_FRIENDLY            3187
#define IDS_ADV_VERSION                 3188
#define IDS_ADV_SER_NUM                 3189
#define IDS_ADV_SIG_ALG                 3190
#define IDS_ADV_ISSUER                  3191
#define IDS_ADV_NOTBEFORE               3192
#define IDS_ADV_NOTAFTER                3193
#define IDS_ADV_SUBJECT                 3194
#define IDS_ADV_PUBKEY                  3195
#define IDS_SELECT_INFO                 3196
#define IDS_DETAIL_VALID_TICK           3197
#define IDS_DETAIL_VALID_CROSS          3198
#define IDS_DETAIL_TRUST_TICK           3199
#define IDS_DETAIL_TRUST_CROSS          3200
#define IDS_WHY_NOT_YET                 3201
#define IDS_WHY_EXPIRED                 3202
#define IDS_WHY_CERT_SIG                3203
#define IDS_WHY_NO_PARENT               3204
#define IDS_WHY_REVOKED                 3205
#define IDS_WHY_KEY_USAGE               3206
#define IDS_WHY_BASIC_CONS              3207
#define IDS_WHY_EXTEND_USE              3208
#define IDS_WHY_NAME_CONST              3209
#define IDS_WHY_NO_CRL                  3210
#define IDS_WHY_CRL_EXPIRED             3211
#define IDS_WHY_CRITICAL_EXT            3212
#define IDS_TRUST_DESC                  3213
#define IDS_GENERAL_DESC                3214
#define IDS_VIEW_TITLE                  3215
#define IDS_VALIDITY_FORMAT             3216
#define IDS_GENERAL_DESC2               3217
#define IDS_GENERAL_DESC3               3218
#define IDS_GENERAL_DESC4               3219
#define IDS_GENERAL_DESC5               3220
#define IDS_GENERAL_DESC6               3221
#define IDS_TRUST_DESC2                 3222
#define IDS_TRUST_DESC3                 3223
#define IDS_TRUST_DESC4                 3224
#define IDS_ROOT_ADD_STRING             3225
#define IDS_ROOT_ADD_TITLE              3226
#define IDS_EMAIL_DESC                  3227

// Added for WXP
#define IDS_WHY_POLICY                  3228


//  Select Certificate control ids
//      Note all of these are also defined in cryptdlg.h --- don't change them.
#define IDC_CS_PROPERTIES               100
#define IDC_CS_FINEPRINT                101
#define IDC_CS_CERTLIST                 102

#define IDC_CS_INFO                     103
#define IDC_CS_VALIDITY                 104
#define IDC_CS_ALGORITHM                105
#define IDC_CS_SERIAL_NUMBER            106
#define IDC_CS_THUMBPRINT               107

//  View Properties Dialog Pages

//  View General Page

#define IDC_CERT_STATUS                 100
#define IDC_CERT_STATUS_IMAGE           101
#define IDC_GENERAL_DESC                102

//  View Details

#define IDC_ISSUED_TO                   100
#define IDC_ISSUED_BY                   101
#define IDC_VIEW_ISSUER                 102
#define IDC_FRIENDLY_NAME               103
#define IDC_VALIDITY                    104
#define IDC_SERIAL_NUMBER               105
#define IDC_ALGORITHM                   106
#define IDC_TRUST_GROUP                 107
#define IDC_IS_TRUSTED                  108
#define IDC_IS_VALID                    109
#define IDC_WHY                         110
#define IDC_THUMBPRINT                  111
#define IDC_TRUST_IMAGE                 112

//  View Trust Page

#define IDC_TRUST_DESC                  100
#define IDC_TRUST_LIST                  101
#define IDC_TRUST_TREE                  102
#define IDC_TRUST_EDIT_GROUP            103
#define IDC_TRUST_NO                    104
#define IDC_TRUST_INHERIT               105
#define IDC_TRUST_YES                   106
#define IDC_TRUST_EDIT                  107
#define IDC_TRUST_VIEW                  108

//

#define IDC_TRUST_ICON                  1004
#define IDC_LIST1                       1014
#define IDC_LIST2                       1015
#define IDC_EDIT1                       1016
#define IDC_PROPERTIES                  1017
#define IDC_CA_CERT_ADD                 1019
#define IDC_CA_CERT_REMOVE              1020
#define IDC_CA_CERT_PROPS               1021
#define IDC_INDIV_CERT_ADD              1022
#define IDC_INDIV_CERT_REMOVE           1023
#define IDC_INDIV_CERT_PROPS            1024
#define IDC_DISTRUST                    1025
#define IDC_CA_CERT_LIST                1026
#define IDC_INDIV_CERT_LIST             1027
#define IDC_FINE_PRINT                  1028
#define IDC_TEXT                        1029
#define IDC_POLICY                      1030
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        3217
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



#define IDH_CS_CERTLIST                 (1000+IDC_CS_CERTLIST)
#define IDH_CS_PROPERTIES               (1000+IDC_CS_CERTLIST)
#define IDH_CS_ALGORITHM                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_STATUS                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_FINEPRINT                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_TEXT                (1000+IDC_CS_CERTLIST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\select.cpp ===
//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

//
//  M00BUG -- Mutli-Select is not implemented
//

#include        "pch.hxx"
#include        "demand.h"


#define REIDK_PRIVATE   TRUE

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

//#include <wchar.h>

#ifdef MAC
#include <stdio.h>
#else   // !MAC
HMODULE         HmodRichEdit = NULL;
#endif  // !MAC
HINSTANCE       HinstDll;
BOOL            FIsWin95 = TRUE;
const HELPMAP RgctxSelect[] = {
    {IDC_CS_CERTLIST,                   IDH_CS_CERTLIST},
    {IDC_CS_PROPERTIES,                 IDH_CS_PROPERTIES},
    {IDC_CS_ALGORITHM,                  IDH_CS_ALGORITHM}};

#ifdef WIN16
#define LPCDLGTEMPLATE_X HGLOBAL
#else
#define LPCDLGTEMPLATE_X LPCDLGTEMPLATE
#endif

//
//  Generic DLL Main function,  we need to get our own hinstance handle.
//
//  We don't need to get thread attaches however.

#ifndef WIN16

#ifdef MAC
BOOL WINAPI FormatPKIXEmailProtection(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/, void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat);

static const CRYPT_OID_FUNC_ENTRY SpcFormatFuncTable[] =
{
    szOID_PKIX_KP_EMAIL_PROTECTION,     FormatPKIXEmailProtection,
};
#define SPC_FORMAT_FUNC_COUNT (sizeof(SpcFormatFuncTable) / sizeof(SpcFormatFuncTable[0]))

BOOL WINAPI CryptDlgASNDllMain(HINSTANCE hInst, ULONG ulReason,
                               LPVOID)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            fRet = CryptInstallOIDFunctionAddress(hInst, X509_ASN_ENCODING,
                                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                                  SPC_FORMAT_FUNC_COUNT,
                                                  SpcFormatFuncTable, 0);
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }
    return fRet;
}
#endif  // MAC


// DLL Entry point

#ifdef MAC
EXTERN_C BOOL WINAPI CryptDlg_DllMain(HANDLE hInst, ULONG ulReason, LPVOID pv)
#else   // !MAC


extern
BOOL
WINAPI
WXP_CertTrustDllMain(
    HINSTANCE hInst,
    ULONG ulReason,
    LPVOID
    );

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulReason, LPVOID pv)
#endif  // MAC
{
    switch( ulReason ) {
    case DLL_PROCESS_ATTACH:
        HinstDll = (HINSTANCE) hInst;

        //  Kill all thread attach and detach messages
        DisableThreadLibraryCalls(HinstDll);

#ifndef MAC
        //  Are we running in Win95 or something equally bad
        FIsWin95 = IsWin95();

        InitDemandLoadedLibs();
#endif  // !MAC
        break;

    case DLL_PROCESS_DETACH:
#ifndef MAC
        FreeDemandLoadedLibs();

        //  If the rich edit dll was loaded, then unload it now
        if (HmodRichEdit != NULL) {
            FreeLibrary(HmodRichEdit);
        }
#endif  // !MAC
        break;
    }
#ifndef MAC
    return WXP_CertTrustDllMain((HINSTANCE) hInst, ulReason, pv);
    
#else   // MAC
    // Handle the ASN OID functions

    return CryptDlgASNDllMain((HINSTANCE)hInst, ulReason, pv);
#endif  // !MAC
}

#else // WIN16

BOOL FAR PASCAL
LibMain (HINSTANCE hDll,
         WORD wDataSeg,
         WORD cbHeapSize,
         LPSTR lpszCmdLine)
{

    HinstDll = (HINSTANCE) hDll;

    InitDemandLoadedLibs();

    // Done
    return TRUE;
}

int CALLBACK WEP(int x)
{

    FreeDemandLoadedLibs();

    //  If the rich edit dll was loaded, then unload it now
    if (HmodRichEdit != NULL) {
        FreeLibrary(HmodRichEdit);
    }

    return 1;
}

#endif // !WIN16

#ifndef WIN16
DWORD ComputeExtent(HWND hwnd, int id)
{
    int         c;
    ULONG       cb;
    ULONG       cbMax = 0;
    DWORD       dwExtent;
    DWORD       dwExtentMax = 0;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    int         i;
    LPWSTR      psz = NULL;
    SIZE        sz;
#ifndef MAC
    TEXTMETRICW tmW={0};
#endif  // !MAC
    TEXTMETRICA tmA={0};

    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);
    if (FIsWin95) {
        GetTextMetricsA(hdc, &tmA);
    }
#ifndef MAC
    else {
        GetTextMetricsW(hdc, &tmW);
    }
#endif  // !MAC

    c = (int) SendDlgItemMessage(hwnd, id, LB_GETCOUNT, 0, 0);
    for (i=0; i<c; i++) {
        cb =  (ULONG) SendDlgItemMessage(hwnd, id, LB_GETTEXTLEN, i, 0);
        if (cb > cbMax) {
            free(psz);
            cbMax = cb + 100;
            psz = (LPWSTR) malloc(cbMax*sizeof(WCHAR));
            if (psz == NULL) {
                break;
            }
        }
#ifndef MAC
        if (FIsWin95) {
#endif  // !MAC
            SendDlgItemMessageA(hwnd, id, LB_GETTEXT, i, (LPARAM) psz);
            GetTextExtentPointA(hdc, (LPSTR) psz, strlen((LPSTR) psz), &sz);
            dwExtent = sz.cx + tmA.tmAveCharWidth;
#ifndef MAC
        }
        else {
            SendDlgItemMessageW(hwnd, id, LB_GETTEXT, i, (LPARAM) psz);
            GetTextExtentPointW(hdc, psz, wcslen(psz), &sz);
            dwExtent = sz.cx + tmW.tmAveCharWidth;
        }
#endif  // !MAC
        if (dwExtent > dwExtentMax) {
            dwExtentMax = dwExtent;
        }
    }

    free(psz);
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return dwExtentMax;
}
#else // WIN16
DWORD ComputeExtent(HWND hwnd, int id)
{
    int         c;
    int         cb;
    int         cbMax = 0;
    DWORD       dwExtent;
    DWORD       dwExtentMax = 0;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    int         i;
    LPWSTR      psz = NULL;
    SIZE        sz;
    TEXTMETRIC  tm;

    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetrics(hdc, &tm);

    c = SendDlgItemMessage(hwnd, id, LB_GETCOUNT, 0, 0);
    for (i=0; i<c; i++) {
        cb = SendDlgItemMessage(hwnd, id, LB_GETTEXTLEN, i, 0);
        if (cb > cbMax) {
            free(psz);
            cbMax = cb + 100;
            psz = (LPWSTR) malloc(cbMax*sizeof(WCHAR));
            if (psz == NULL) {
                break;
            }
        }

        SendDlgItemMessage(hwnd, id, LB_GETTEXT, i, (LONG) psz);
        GetTextExtentPoint(hdc, (LPSTR) psz, strlen((LPSTR) psz), &sz);
        dwExtent = sz.cx + tm.tmAveCharWidth;

        if (dwExtent > dwExtentMax) {
            dwExtentMax = dwExtent;
        }
    }

    free(psz);
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return dwExtentMax;
}
#endif // !WIN16

BOOL FillInFields(HWND hwnd, PCCERT_CONTEXT pccert)
{
    LPWSTR      pwsz;
    WCHAR       rgwch[200];
    LPWSTR      rgpwsz[3];
    rgpwsz[2] = (LPWSTR)-1;               // Sentinal Value

    FormatAlgorithm(hwnd, IDC_CS_ALGORITHM, pccert);
    FormatSerialNo(hwnd, IDC_CS_SERIAL_NUMBER, pccert);
    FormatThumbprint(hwnd, IDC_CS_THUMBPRINT, pccert);
    FormatValidity(hwnd, IDC_CS_VALIDITY, pccert);

    rgpwsz[0] = PrettySubject(pccert);
    rgpwsz[1] = PrettyIssuer(pccert);

    LoadString(HinstDll, IDS_SELECT_INFO, rgwch, ARRAYSIZE(rgwch));
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_STRING |
                  FORMAT_MESSAGE_ARGUMENT_ARRAY, rgwch, 0, 0,
                  (LPWSTR) &pwsz, 0, (va_list *) rgpwsz);

#ifndef WIN16
    TruncateToWindowW(hwnd, IDC_CS_INFO, pwsz);
#else
    TruncateToWindowA(hwnd, IDC_CS_INFO, pwsz);
#endif // !WIN16
    SetDlgItemText(hwnd, IDC_CS_INFO, pwsz);
    free(rgpwsz[0]);
    free(rgpwsz[1]);
    LocalFree((HLOCAL)pwsz);
    return TRUE;
}

INT_PTR CALLBACK SelectCertDlgProc(HWND hwndDlg, UINT msg,
                                WPARAM wParam, LPARAM lParam)
{
    int		            c;
    CTL_USAGE           ctlUsage;
    PCERT_CONTEXT       pcertctx;
    BOOL                f;
    int                 i;
    DWORD               iStore;
    LPWSTR              pwsz;
    PCCERT_CONTEXT      pccert;
    PCERT_SELECT_STRUCT pcss;

    pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    //
    //  If a hook proc has been registered for this dialog, then we need
    //  to call the hook proc.  Notice that if the hook proc returns TRUE
    //  then we don't do normal processing
    //

    if ((pcss != NULL) && (pcss->dwFlags & CSS_ENABLEHOOK) &&
        (pcss->pfnHook != 0)) {
        f = pcss->pfnHook(hwndDlg, msg, wParam, lParam);
        if (f) {
            return f;
        }
    }

    //

    switch (msg) {
    case WM_INITDIALOG:
        //  Center the dialog on its parent
        //        CenterThisDialog(hwndDlg);

        //  Save the pointer to the control structure for later use.
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);

        //
        pcss = (PCERT_SELECT_STRUCT) lParam;

        //
        //  Is there a title to be displayed?
        //

        if (pcss->szTitle != NULL) {
            if (FIsWin95) {
                SendMessageA(hwndDlg, WM_SETTEXT, 0, (LPARAM) pcss->szTitle);
            }
#ifndef WIN16
#ifndef MAC
            else {
                SendMessageW(hwndDlg, WM_SETTEXT, 0, (LPARAM) pcss->szTitle);
            }
#endif  // !MAC
#endif // !WIN16
        }

        //
        //  If we want a help button, then show it
        //

        if (pcss->dwFlags & CSS_SHOW_HELP) {
            ShowWindow(GetDlgItem(hwndDlg, IDHELP), SW_SHOW);
        }

        //
        //  Check to see if the properties button should be suppressed
        //

        if (pcss->dwFlags & CSS_HIDE_PROPERTIES) {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), SW_HIDE);
        }

        //
        //  Let populate the list box, walk through the list of stores
        //      to populate the list
        //

        if (pcss->szPurposeOid != NULL) {
            ctlUsage.cUsageIdentifier = 1;
            ctlUsage.rgpszUsageIdentifier = (LPSTR *) &pcss->szPurposeOid;
        }


        for (iStore = 0; iStore < pcss->cCertStore; iStore++) {
            pccert = NULL;

            if (!pcss->arrayCertStore[iStore])
                continue;

            while (TRUE) {
                //
                //  Get the next certificate in the current store.  If
                //      we are finished then move on to the next store
                //

                if (pcss->szPurposeOid != NULL) {
                    pccert = CertFindCertificateInStore(
                                     pcss->arrayCertStore[iStore],
                                     CRYPT_ASN_ENCODING,
                                     CERT_FIND_OPTIONAL_CTL_USAGE_FLAG,
                                     CERT_FIND_CTL_USAGE, &ctlUsage, pccert);

                }
                else {
                    pccert = CertEnumCertificatesInStore(
                                                  pcss->arrayCertStore[iStore],
                                                  pccert);
                }

                if (pccert == NULL) {
                    break;
                }

                //
                //  Filter the certificate according to the purpse desired
                //

                //
                //  If we have a filter set, then call back and see if
                //      the filter approves the certificate.  If it is not
                //      approved then move onto the next certificate in this
                //      store.
                //

                if (pcss->pfnFilter != NULL) {
                    if (!pcss->pfnFilter(pccert, pcss->lCustData, 0, 0)) {
                        continue;
                    }
                }
                //
                //  If there is no filter function, then kill all V1 certs
                //
                else {
                    if (pccert->pCertInfo->dwVersion < 2) {
                        continue;
                    }
                }

                //
                //  Convert the certificate subject to a name
                //

                pwsz = PrettySubjectIssuer(pccert);

                if (NULL != pwsz) {
                    i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_ADDSTRING, 0,
                                           (LPARAM) pwsz);
                    SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETITEMDATA, i,
                                       (LPARAM) CertDuplicateCertificateContext(pccert));

                    free(pwsz);
                }
            }
        }

        SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETHORIZONTALEXTENT,
                           ComputeExtent(hwndDlg, IDC_CS_CERTLIST), 0);

        c = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCOUNT, 0, 0);
        if (c != 0 && pcss->arrayCertContext[0] != NULL) {
            for (i=0; i<c; i++) {
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);
                if (CertCompareCertificate(X509_ASN_ENCODING,
                                           pcss->arrayCertContext[0]->pCertInfo,
                                           pcertctx->pCertInfo)) {
                    SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETCURSEL,
                                       i, 0);
                    pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST,
                                            LB_GETITEMDATA, i, 0);
                    FillInFields(hwndDlg, pcertctx);
                    break;
                }
            }
        }
        else {
            // no certs at all or no default certificate,
            // so there is no selection in the listbox

            EnableWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CS_FINEPRINT), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
        }

        if ((pcss->dwFlags & CSS_ENABLEHOOK) && (pcss->pfnHook != 0)) {
            f = pcss->pfnHook(hwndDlg, msg, wParam, lParam);
            if (f) {
                return f;
            }
        }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i != LB_ERR) {
                //  Free the old cert if there is one
                if (pcss->arrayCertContext[0] != NULL) {
                    CertFreeCertificateContext(pcss->arrayCertContext[0]);
                }

                //  Get the new cert from the system.
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);

                //  Put the new cert into the location
                pcss->cCertContext = 1;
                pcss->arrayCertContext[0] =
                    CertDuplicateCertificateContext(pcertctx);
            }
            else {
                pcss->cCertContext = 0;
            }
            EndDialog(hwndDlg, IDOK);
            return TRUE;

        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;

        case IDHELP:
            if (FIsWin95) {
                WinHelpA(hwndDlg, (LPSTR) pcss->szHelpFileName,
                         HELP_CONTEXT, pcss->dwHelpId);
            }
#ifndef MAC
            else {
                WinHelp(hwndDlg, pcss->szHelpFileName,
                        HELP_CONTEXT, pcss->dwHelpId);
            }
#endif  // !MAC
            return TRUE;

        case IDC_CS_PROPERTIES:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i == LB_ERR) {
                return TRUE;
            }
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                    i, 0);

            f = TRUE;
            if (FIsWin95) {
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pcertctx;

                pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);
                if (pcss->szPurposeOid != NULL) {
                    cvps.cArrayPurposes = 1;
                    cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
                }

                if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_A) 0)->hprov) {
                    cvps.hprov = pcss->hprov;
                }

                f = CertViewPropertiesA(&cvps);
            }
#ifndef WIN16
#ifndef MAC
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pcertctx;

                pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);
                if (pcss->szPurposeOid != NULL) {
                    cvps.cArrayPurposes = 1;
                    cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
                }
                if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_W) 0)->hprov) {
                    cvps.hprov = pcss->hprov;
                }

                f = CertViewPropertiesW(&cvps);
            }
#endif  // !MAC
#endif  // !WIN16
            if (f) {
                // M00BUG -- repopulate the line.  The friendly name
                //      may have changed.
            }
            return TRUE;

        case IDC_CS_FINEPRINT:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i == LB_ERR) {
                return TRUE;
            }
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                    i, 0);
            FinePrint(pcertctx, hwndDlg);
            return TRUE;

        case IDC_CS_CERTLIST:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCARETINDEX,
                                       0, 0);
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);
                FillInFields(hwndDlg, pcertctx);

                if (!(pcss->dwFlags & CSS_HIDE_PROPERTIES)) {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), TRUE);
                }
                EnableWindow(GetDlgItem(hwndDlg, IDC_CS_FINEPRINT), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            return TRUE;
        }

        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxSelect);
#endif  // !MAC

    case WM_DESTROY:
        c = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA, i, 0);
            CertFreeCertificateContext(pcertctx);
        }
        return FALSE;

        //
        //  Use the default handler -- we don't do anything for it
        //

    default:
        return FALSE;
    }

    return TRUE;
}                               // SelectCertDialogProc()


BOOL WINAPI MyCryptFilter(PCCERT_CONTEXT pccert, BOOL * pfSelect, void * pv)
{
    PCERT_SELECT_STRUCT_W      pcssW = (PCERT_SELECT_STRUCT_W) pv;
    PCERT_EXTENSION            pExt;

    //  Test purpose

    if (pcssW->szPurposeOid != NULL) {
        pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pccert->pCertInfo->cExtension,
                                 pccert->pCertInfo->rgExtension);
        if (pExt != NULL) {
            BOOL                f;
            DWORD               i;
            PCERT_ENHKEY_USAGE  pUsage;

            pUsage = (PCERT_ENHKEY_USAGE) PVCryptDecode(szOID_ENHANCED_KEY_USAGE,
                                                        pExt->Value.cbData,
                                                        pExt->Value.pbData);
            if (pUsage == NULL) {
                return FALSE;
            }

            for (i=0, f=FALSE; i<pUsage->cUsageIdentifier; i++) {
                if (strcmp(pcssW->szPurposeOid, pUsage->rgpszUsageIdentifier[i]) == 0) {
                    break;
                }
            }

            if (i == pUsage->cUsageIdentifier) {
                free(pUsage);
                return FALSE;
            }

            free(pUsage);
        }
    }

    //  Let them filter if they want

    if (pcssW->pfnFilter != NULL) {
        if (!pcssW->pfnFilter(pccert, pcssW->lCustData, 0, 0)) {
            return FALSE;
        }
    }
    else if (pccert->pCertInfo->dwVersion < 2) {
        return FALSE;
    }
    

    if ((pfSelect != NULL) && (pcssW->arrayCertContext[0] != NULL)) {
        *pfSelect = CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                           pcssW->arrayCertContext[0]->pCertInfo);
    }
    return TRUE;
}

BOOL WINAPI MyDisplay(PCCERT_CONTEXT pccert, HWND hwnd, void * pv)
{
    CERT_VIEWPROPERTIES_STRUCT_A        cvps = {0};
    PCERT_SELECT_STRUCT_W               pcss = (PCERT_SELECT_STRUCT_W) pv;

    cvps.dwSize = sizeof(cvps);
    cvps.hwndParent = hwnd;
    cvps.pCertContext = pccert;
    if (pcss->szPurposeOid != NULL) {
        cvps.cArrayPurposes = 1;
        cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
    }
    if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_A) 0)->hprov) {
        cvps.hprov = pcss->hprov;
    }

    CertViewPropertiesA(&cvps);
    return TRUE;
}

BOOL CallCryptUISelect(BOOL fWide, PCERT_SELECT_STRUCT_W pcssW)
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW       cscs = {0};
    PCCERT_CONTEXT                          pccert;

    cscs.dwSize = sizeof(cscs);
    cscs.hwndParent = pcssW->hwndParent;
    // cscs.dwFlags = 0;
    cscs.szTitle = pcssW->szTitle;
    if (pcssW->szPurposeOid != NULL) {
        cscs.dwDontUseColumn = /*CRYPTUI_SELECT_INTENDEDUSE_COLUMN |*/
            CRYPTUI_SELECT_LOCATION_COLUMN;
    }
    else {
        cscs.dwDontUseColumn = CRYPTUI_SELECT_LOCATION_COLUMN;
    }            
    // cscs.szDisplayString = NULL;
    cscs.pFilterCallback = MyCryptFilter;
    cscs.pDisplayCallback = MyDisplay;
    cscs.pvCallbackData = pcssW;
    cscs.cDisplayStores = pcssW->cCertStore;
    cscs.rghDisplayStores = pcssW->arrayCertStore;
    // cscs.cStores = 0;
    // cscs.rghStores = NULL;
    // cscs.cPropSheetPages = 0;
    // cscs.rgPropSheetPages = NULL;

    if (fWide) {
        pccert = CryptUIDlgSelectCertificateW(&cscs);
    }
    else {
        pccert = CryptUIDlgSelectCertificateA((PCRYPTUI_SELECTCERTIFICATE_STRUCTA) &cscs);
    }
    
    if (pccert != NULL) {
        if (pcssW->cCertContext == 1) {
            CertFreeCertificateContext(pcssW->arrayCertContext[0]);
        }
        
        pcssW->cCertContext = 1;
        pcssW->arrayCertContext[0] = pccert;
        return TRUE;
    }
    return FALSE;
}


extern "C" BOOL APIENTRY CertSelectCertificateA(PCERT_SELECT_STRUCT_A pcssA)
{
    if (CryptUIAvailable()) {
        return CallCryptUISelect(FALSE, (PCERT_SELECT_STRUCT_W) pcssA);
    }
    
    HCERTSTORE                  hCertStore = NULL;
    int							ret = FALSE;
    CERT_SELECT_STRUCT_W        cssW = {0};
#ifndef MAC
    int                         cch;
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_LISTVIEW_CLASSES
#ifndef WIN16
          | ICC_NATIVEFNTCTL_CLASS
#endif  // ! WIN16
    };
#endif  // ! MAC

    if (pcssA->cCertStore == 0) {
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   L"MY");
        if (hCertStore == NULL) {
            ret = -1;
            goto Exit;
        }
        pcssA->cCertStore = 1;
        pcssA->arrayCertStore = &hCertStore;
    }
    //
    //  Size of the object must be acceptable in order to copy it over
    //

    if (pcssA->dwSize > sizeof(cssW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (FIsWin95) {
        //
        //  Deal with some DBCS issues
        //

#ifndef MAC
        InitCommonControlsEx(&initcomm);
#endif  // !MAC

        //
        //  Launch the dialog
        //

        if (pcssA->dwFlags & CSS_ENABLETEMPLATEHANDLE) {
            ret = (int) DialogBoxIndirectParamA(pcssA->hInstance,
                                  (LPCDLGTEMPLATE_X) pcssA->pTemplateName,
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
        else if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            ret = (int) DialogBoxParamA(pcssA->hInstance, pcssA->pTemplateName,
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
        else {
            ret = (int) DialogBoxParamA(HinstDll,
                                  (LPSTR) MAKEINTRESOURCE(IDD_SELECT_DIALOG),
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
    }
#if ! defined(WIN16) && ! defined (MAC)
    else {
        //
        //  Do a bulk copy of the passed in structure then we fix up the
        //  individual fields to go from the A to the W version of the structure
        //

        //Assert(pcssA->dwSize <= sizeof(cssW));
        memcpy(&cssW, pcssA, (int)min(pcssA->dwSize, sizeof(cssW)));

        if (pcssA->szTitle != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szTitle, -1,
                                      NULL, 0);
            cssW.szTitle = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.szTitle == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szTitle, -1,
                                (LPWSTR) cssW.szTitle, cch+1);
        }

        if (pcssA->szHelpFileName != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                      pcssA->szHelpFileName, -1, NULL, 0);
            cssW.szHelpFileName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.szHelpFileName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szHelpFileName, -1,
                                (LPWSTR) cssW.szHelpFileName, cch+1);
        }

        if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                      pcssA->pTemplateName, -1, NULL, 0);
            cssW.pTemplateName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.pTemplateName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->pTemplateName, -1,
                                (LPWSTR) cssW.pTemplateName, cch+1);
        }

        //
        //  Call Wide char version of the function now
        //

        ret = CertSelectCertificateW(&cssW);
        pcssA->cCertContext = cssW.cCertContext;


        //
        //  If we allocated buffers to hold data, free them now
        //

ExitW:
        if (cssW.szTitle != NULL) free((LPWSTR) cssW.szTitle);
        if (cssW.szHelpFileName != NULL) free((LPWSTR) cssW.szHelpFileName);
        if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            free((LPWSTR) cssW.pTemplateName);
        }

        //
        //  return the return value of the original function
        //
    }
#endif  // !WIN16 and !MAC

Exit:
    if (hCertStore != NULL) {
        CertCloseStore(hCertStore, 0);
        pcssA->cCertStore = 0;
        pcssA->arrayCertStore = NULL;
    }
    return (ret == IDOK);
}

#ifndef WIN16
#ifndef MAC

BOOL APIENTRY CertSelectCertificateW(PCERT_SELECT_STRUCT_W pcssW)
{
    if (CryptUIAvailable()) {
        return CallCryptUISelect(TRUE, pcssW);
    }
    
    HCERTSTORE                  hCertStore = NULL;
    int		                    ret = FALSE;
#ifndef MAC
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };
#endif  // !MAC

    //
    //  If cCertStore == 0, then default to using the "MY" cert store
    //

    if (pcssW->cCertStore == 0) {
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   L"MY");
        if (hCertStore == NULL) {
            ret = -1;
            goto Exit;
        }
        pcssW->cCertStore = 1;
        pcssW->arrayCertStore = &hCertStore;
    }

    //
    //  Deal with some DBCS issues
    //

    InitCommonControlsEx(&initcomm);

    //
    //  Launch the dialog
    //

    if (pcssW->dwFlags & CSS_ENABLETEMPLATEHANDLE) {
        ret = (int) DialogBoxIndirectParam(pcssW->hInstance,
                                     (LPCDLGTEMPLATE_X) pcssW->pTemplateName,
                                     pcssW->hwndParent, SelectCertDlgProc,
                                     (LPARAM) pcssW);
    }
    else if (pcssW->dwFlags & CSS_ENABLETEMPLATE) {
        ret = (int) DialogBoxParam(pcssW->hInstance, pcssW->pTemplateName,
                             pcssW->hwndParent, SelectCertDlgProc,
                             (LPARAM) pcssW);
    }
    else {
        ret = (int) DialogBoxParam(HinstDll, MAKEINTRESOURCE(IDD_SELECT_DIALOG),
                             pcssW->hwndParent, SelectCertDlgProc,
                             (LPARAM) pcssW);
    }

Exit:
    if (hCertStore != NULL) {
        CertCloseStore(hCertStore, 0);
        pcssW->cCertStore = 0;
        pcssW->arrayCertStore = NULL;
    }

    return (ret == IDOK);
}
#endif  // !MAC
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\internal.h ===
#include "richedit.h"

//////////////////////////////////////////////////////////
#ifdef MAC
#define wszCRLF     L"\n\r"
#define szCRLF      "\n\r"
#define wchCR       L'\n'
#define wchLF       L'\r'
#define chCR        '\n'
#define chLF        '\r'
#else   // !MAC
#ifndef WIN16
#define wszCRLF     L"\r\n"
#define szCRLF      "\r\n"
#define wchCR       L'\r'
#define wchLF       L'\n'
#define chCR        '\r'
#define chLF        '\n'
#else
#define wszCRLF     "\r\n"
#define szCRLF      "\r\n"
#define wchCR       '\r'
#define wchLF       '\n'
#define chCR        '\r'
#define chLF        '\n'
#endif // !WIN16
#endif  // MAC

#ifndef MAC
BOOL IsWin95(void);
#endif  // !MAC
extern BOOL FIsWin95;

#ifndef WIN16

#undef SetWindowLong
#define SetWindowLong SetWindowLongA
#undef GetWindowLong
#define GetWindowLong GetWindowLongA
#undef SetWindowLongPtr
#define SetWindowLongPtr SetWindowLongPtrA
#undef GetWindowLongPtr
#define GetWindowLongPtr GetWindowLongPtrA
#undef SendMessage
#define SendMessage SendMessageA

#else // WIN16

#define TEXTMETRICA TEXTMETRIC
#define TEXTRANGEA TEXTRANGE
#define CHARFORMATA CHARFORMAT
#define PROPSHEETHEADERA PROPSHEETHEADER
#define PROPSHEETPAGEA PROPSHEETPAGE

#define TVN_SELCHANGEDA TVN_SELCHANGED
#define TVM_SETITEMA TVM_SETITEM
#define TVM_GETITEMA TVM_GETITEM

#define GetTextExtentPointA GetTextExtentPoint
#define SetDlgItemTextA SetDlgItemText
#define GetTextMetricsA GetTextMetrics
#define SendDlgItemMessageA SendDlgItemMessage
#define LoadBitmapA LoadBitmap
#define PropertySheetA PropertySheet
#define WinHelpA WinHelp

#endif // !WIN16

LRESULT MySendDlgItemMessageW(HWND hwnd, int id, UINT msg, WPARAM w, LPARAM l);
BOOL MySetDlgItemTextW(HWND hwnd, int id, LPCWSTR pwsz);
UINT MyGetDlgItemTextW(HWND hwnd, int id, LPWSTR pwsz, int nMax);
DWORD MyFormatMessageW(DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
                    DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize,
                    va_list * args);
int MyLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cbBuffer);
#ifndef WIN16
BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#else
BOOL WINAPI MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                          LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#endif // !WIN16
BOOL MyWinHelpW(HWND hWndMain, LPCWSTR szHelp,UINT uCommand, ULONG_PTR dwData);


DWORD TruncateToWindowA(HWND hwndDlg, int id, LPSTR psz);
DWORD TruncateToWindowW(HWND hwndDlg, int id, LPWSTR pwsz);

BOOL FinePrint(PCCERT_CONTEXT pccert, HWND hwndParent);

//
//  Formatting algorithms for the common dialogs
//

BOOL FormatAlgorithm(HWND /*hwnd*/, UINT /*id*/, PCCERT_CONTEXT /*pccert*/);
BOOL FormatBinary(HWND hwnd, UINT id, LPBYTE pb, DWORD cb);
BOOL FormatCPS(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatDate(HWND hwnd, UINT id, FILETIME ft);
BOOL FormatIssuer(HWND hwnd, UINT id, PCCERT_CONTEXT pccert,
                  DWORD dwFlags = CERT_SIMPLE_NAME_STR);
BOOL FormatSerialNo(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatSubject(HWND hwnd, UINT id, PCCERT_CONTEXT pccert,
                   DWORD dwFlags = CERT_SIMPLE_NAME_STR);
BOOL FormatThumbprint(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatValidity(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);

//
//  These routines extract and pretty print fields in the certs.  The
//      routines use crt to allocate and return a buffer
//

LPWSTR PrettySubject(PCCERT_CONTEXT pccert);
LPWSTR PrettyIssuer(PCCERT_CONTEXT pccert);
LPWSTR PrettySubjectIssuer(PCCERT_CONTEXT pccert);

//

LPWSTR FindURL(PCCERT_CONTEXT pccert);
BOOL LoadStringInWindow(HWND hwnd, UINT id, HMODULE hmod, UINT id2);
BOOL LoadStringsInWindow(HWND hwnd, UINT id, HMODULE hmod, UINT *pidStrings);

//

typedef struct {
    DWORD       dw1;
    DWORD       dw2;
} HELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap);

VOID RecognizeURLs(HWND hwndRE);
#ifdef MAC
EXTERN_C BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL);
#else   // !MAC
BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL);
#endif  // MAC


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const MaxCertificateParents = 5;
extern const GUID GuidCertValidate;

LPWSTR FormatValidityFailures(DWORD);

typedef struct {
#ifndef NT5BUILD
    LPSTR       szOid;
#endif  // !NT5BUILD
    DWORD       fRootStore:1;
    DWORD       fExplicitTrust:1;       // This item is explicity Trusted
    DWORD       fExplicitDistrust:1;    // This item is explicity Distructed
    DWORD       fTrust:1;               // Ancestor is explicity Trusted
    DWORD       fDistrust:1;            // Ancestor is explicity Distrusted
    DWORD       fError:1;
    DWORD       newTrust:2;             // 0 - not modified
                                        // 1 - now explicit Distrust
                                        // 2 - now inherit
                                        // 3 - now explicit trust
    DWORD       cbTrustData;
    LPBYTE      pbTrustData;
} STrustDesc;

typedef class CCertFrame * PCCertFrame;

class CCertFrame {
public:
    CCertFrame(PCCERT_CONTEXT pccert);
    ~CCertFrame(void);

    int                 m_fSelfSign:1;          // Is Cert self signed?
    int                 m_fRootStore:1;         // Cert can from a root store
    int                 m_fLeaf:1;              // Leaf Cert
    int                 m_fExpired:1;           // Cert has expired
    PCCERT_CONTEXT      m_pccert;               // Certificate in this frame
    PCCertFrame         m_pcfNext;              //
    DWORD               m_dwFlags;              // Flags from GetIssuer
    int                 m_cParents;             // Count of parents
    PCCertFrame         m_rgpcfParents[MaxCertificateParents];  // Assume there are
                                                // a limited number of parents
                                                // to list
    int                 m_cTrust;               // size of array trust
    STrustDesc *        m_rgTrust;              // Array of trust
};

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD cPurposes, LPSTR * rgszPurposes, HCRYPTPROV,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame * ppcfRoot, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData); // optional: return WinVerifyTrust state handle here

void FreeWVTHandle(HANDLE hWVTState);

BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose);


//////////////////////////////////////////////////////

LPVOID PVCryptDecode(LPCSTR, DWORD, LPBYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\ltrust.cpp ===
#include "pch.hxx"
#ifndef WIN16
#include <wintrust.h>
#endif // !WIN16
#include "demand.h"
#include <stdio.h>

#pragma warning(disable: 4127)          // conditional expression is constant

#ifndef CPD_REVOCATION_CHECK_NONE
#define CPD_REVOCATION_CHECK_NONE                0x00010000
#define CPD_REVOCATION_CHECK_END_CERT            0x00020000
#define CPD_REVOCATION_CHECK_CHAIN               0x00040000
#define CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00080000
#endif
#define CPD_REVOCATION_MASK     (CPD_REVOCATION_CHECK_NONE | \
                                    CPD_REVOCATION_CHECK_END_CERT | \
                                    CPD_REVOCATION_CHECK_CHAIN | \
                                    CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)
                                    
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds
#define FILETIME_SECOND    10000000     // 100ns intervals per second

const char SzOID_CTL_ATTR_YESNO_TRUST[] = szOID_YESNO_TRUST_ATTR;
const char SzOID_KP_CTL_USAGE_SIGNING[] = szOID_KP_CTL_USAGE_SIGNING;
const BYTE RgbTrustYes[] = {2, 1, 1};
const BYTE RgbTrustNo[] = {2, 1, 2};
const BYTE RgbTrustParent[] = {2, 1, 0};
const char SzOID_OLD_CTL_YESNO_TRUST[] = "1.3.6.1.4.1.311.1000.1.1.2";
const char SzTrustListSigner[] = "Trust List Signer";
const char SzTrustDN[] = "cn=%s, cn=Trust List Signer, cn=%s";
const char SzPolicyKey[] = 
    "SOFTWARE\\Microsoft\\Cryptography\\"szCERT_CERTIFICATE_ACTION_VERIFY;
const char SzPolicyData[] = "PolicyFlags";

const DWORD CTL_MODIFY_ERR_NOT_YET_PROCESSED = (DWORD) -1;
extern HINSTANCE        HinstDll;

PCCERT_CONTEXT CreateTrustSigningCert(HWND hwnd, HCERTSTORE hcertstoreRoot, BOOL);

const int       COtherProviders = 2;
#ifndef WIN16
LPWSTR          RgszProvider[] = {
    L"CA", L"MY"
};
#else // WIN16
LPWSTR          RgszProvider[] = {
    "CA", "MY"
};
#endif // !WIN16

#ifdef NT5BUILD

typedef struct {
    DWORD               cbSize;
    DWORD               dwFlags;
    DWORD               cRootStores;
    HCERTSTORE *        rghRootStores;
    DWORD               cTrustStores;
    HCERTSTORE *        rghTrustStores;
    LPCSTR              pszUsageOid;
    HCRYPTDEFAULTCONTEXT hdefaultcontext;        // from CryptInstallDefaultContext
} INTERNAL_DATA, * PINTERNAL_DATA;

const GUID      MyGuid = CERT_CERTIFICATE_ACTION_VERIFY;

#pragma message("Building for NT5")

void FreeWVTHandle(HANDLE hWVTState) {
    if (hWVTState) {
        HRESULT hr;
        WINTRUST_DATA data = {0};

        data.cbStruct = sizeof(WINTRUST_DATA);
        data.pPolicyCallbackData = NULL;
        data.pSIPClientData = NULL;
        data.dwUIChoice = WTD_UI_NONE;
        data.fdwRevocationChecks = WTD_REVOKE_NONE;
        data.dwUnionChoice = WTD_CHOICE_BLOB;
        data.pBlob = NULL;      // &blob;
        data.dwStateAction = WTD_STATEACTION_CLOSE;
        data.hWVTStateData = hWVTState;
        hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    }
}


HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD /*cPurposes*/, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame *  /*ppcf*/, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD                               cbData;
    DWORD                               cCerts = 0;
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};
    DWORD                               dwErrors;
    BOOL                                f;
    HRESULT                             hr;
    int                                 i;
    DWORD                               j;
    PCCERT_CONTEXT *                    rgCerts = NULL;
    DWORD *                             rgdwErrors = NULL;
    DATA_BLOB *                         rgblobTrust = NULL;
    CERT_VERIFY_CERTIFICATE_TRUST       trust;
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;
    if (phReturnStateData) {
        data.dwStateAction = WTD_STATEACTION_VERIFY;
    }

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE) &trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pccertToCheck;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH |
                     CERT_TRUST_PERMIT_MISSING_CRLS |
                     CERT_TRUST_DO_FULL_TRUST | dwControl);
    trust.dwIgnoreErr = dwValidityMask;
    trust.pdwErrors = &dwErrors;
    //    Assert(cPurposes == 1);
    if (rgszPurposes != NULL) {
        trust.pszUsageOid = rgszPurposes[0];
    }
    else {
        trust.pszUsageOid = NULL;
    }
    trust.hprov = hprov;
    trust.cRootStores = cRoots;
    trust.rghstoreRoots = rgRoots;
    trust.cStores = cCAs;
    trust.rghstoreCAs = rgCAs;
    trust.cTrustStores = cTrust;
    trust.rghstoreTrust = rgTrust;
    trust.lCustData = lCustData;
    trust.pfnTrustHelper = pfn;
    trust.pcChain = &cCerts;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;
    trust.prgpbTrustInfo = &rgblobTrust;

    hr = WinVerifyTrust(NULL, (GUID *) &GuidCertValidate, &data);
    if ((TRUST_E_CERT_SIGNATURE == hr) ||
        (CERT_E_REVOKED == hr) ||
        (CERT_E_REVOCATION_FAILURE == hr)) {
        hr = S_OK;
    }
    else if (FAILED(hr)) {
            return hr;
    }
    if (cCerts == 0) {
        return(E_INVALIDARG);
    }

    if (phReturnStateData) {
        *phReturnStateData = data.hWVTStateData;    // Caller must use WinVerifyTrust to free
    }

    //Assert( cCerts <= 20);
    *pcNodes = cCerts;
    for (i=cCerts-1; i >= 0; i--) {
        rgpcfResult[i] = new CCertFrame(rgCerts[i]);

        if(!rgpcfResult[i])
        {
            hr=E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpcfResult[i]->m_dwFlags = rgdwErrors[i];
        if (rgszPurposes == NULL) {
            continue;
        }
        rgpcfResult[i]->m_cTrust = 1;
        rgpcfResult[i]->m_rgTrust = new STrustDesc[1];
        memset(rgpcfResult[i]->m_rgTrust, 0, sizeof(STrustDesc));

        //
        //  We are going to fill in the trust information which we use
        //  to fill in the fields of the dialog box.
        //
        //  Start with the question of the cert being self signed
        //

        rgpcfResult[i]->m_fSelfSign = WTHelperCertIsSelfSigned(X509_ASN_ENCODING, rgCerts[i]->pCertInfo);

        //
        //  We may or may not have trust data information returned, we now
        //      build up the trust info for a single cert
        //
        //  If we don't have any explicit data, then we just chain the data
        //      down from the next level up.
        //

        if (rgblobTrust[i].cbData == 0) {
            //        chain:
            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;

            //
            //  We return a special code to say that we found it in the root store
            //

            rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore =
                (rgblobTrust[i].pbData == (LPBYTE) 1);

            if (i != (int) (cCerts-1)) {
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
            } else {
                //  Oops -- there is no level up one, so just make some
                //      good defaults
                //
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
            }
        }
        else {
            //
            //

            f = CryptDecodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                  rgblobTrust[i].pbData, rgblobTrust[i].cbData,
                                  0, NULL, &cbData);
            if (!f || (cbData == 0)) {
            chain:
                rgpcfResult[i]->m_fRootStore = FALSE;
                rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
                rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;
                if (i != (int) (cCerts-1)) {
                    rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                    rgpcfResult[i]->m_rgTrust[0].fDistrust = rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
                }
                else {
                    rgpcfResult[i]->m_rgTrust[0].fTrust = FALSE;
                    rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
                }
            }
            else {
                PCRYPT_ATTRIBUTES       pattrs;

                pattrs = (PCRYPT_ATTRIBUTES) malloc(cbData);
                if (pattrs == NULL) {
                    goto chain;
                }

                CryptDecodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                  rgblobTrust[i].pbData, rgblobTrust[i].cbData,
                                  0, pattrs, &cbData);

                for (j=0; j<pattrs->cAttr; j++) {
                    if ((strcmp(pattrs->rgAttr[j].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
                        (strcmp(pattrs->rgAttr[j].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) 
                    {

                        pVal = &(pattrs->rgAttr[j].rgValue[0]);

                        if ((pVal->cbData == sizeof(RgbTrustYes)) &&
                            (memcmp(pVal->pbData,
                                    RgbTrustYes, sizeof(RgbTrustYes)) == 0)) {
                            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = TRUE;
                            rgpcfResult[i]->m_rgTrust[0].fTrust = TRUE;
                            break;
                        }
                        else if ((pVal->cbData == sizeof(RgbTrustNo)) &&
                                 (memcmp(pVal->pbData,
                                    RgbTrustNo, sizeof(RgbTrustNo)) == 0)) {
                            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = TRUE;
                            rgpcfResult[i]->m_rgTrust[0].fDistrust= TRUE;
                            break;
                        }
                        else if ((pVal->cbData == sizeof(RgbTrustParent)) &&
                                 (memcmp(pVal->pbData,
                                    RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                            goto chain;
                        }
                        else {
                            goto chain;
                        }
                    }
                }
                if (j == pattrs->cAttr) {
                    goto chain;
                }
            }
        }
    }

    //
    //  Clean up all returned values
    //

ExitHere:
    if (rgCerts != NULL) {
        //bobn If the loop has been broken because "new" failed, free what we allocated so far...
        for ((hr==E_OUTOFMEMORY?i++:i=0); i< (int) cCerts; i++) {
            //@ REVIEW check CertFreeCertificateContext to see if it will accept a null pointer
            //if it will, we can remove the E_OUTOFMEMORY test above.
            CertFreeCertificateContext(rgCerts[i]);
            }
        LocalFree(rgCerts);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrust != NULL) {
        for (i=0; i<(int) cCerts; i++) {
            if (rgblobTrust[i].cbData > 0) {
                LocalFree(rgblobTrust[i].pbData);
            }
        }
        LocalFree(rgblobTrust);
    }

    return hr;
}


HRESULT CertTrustInit(PCRYPT_PROVIDER_DATA pdata)
{
    DWORD                               cbSize;
    DWORD                               dwPolicy = 0;
    DWORD                               dwType;
    HKEY                                hkPolicy;
    HCERTSTORE                          hstore;
    DWORD                               i;
    PCERT_VERIFY_CERTIFICATE_TRUST      pcerttrust;
    CRYPT_PROVIDER_PRIVDATA             privdata;
    PINTERNAL_DATA                      pmydata;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //

    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        return(E_FAIL);
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    pcerttrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pdata->pWintrustData->pBlob->pbMemObject;
    if ((pcerttrust == NULL) ||
        (pcerttrust->cbSize < sizeof(*pcerttrust))) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    if (pdata->dwError != 0) {
        return S_FALSE;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_CERTCHKPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            return S_FALSE;
        }
    }

    //
    //  Allocate the space to hold the internal data we use to talk to ourselfs with
    //

    cbSize = sizeof(INTERNAL_DATA) + (pcerttrust->cRootStores + 1 +
                                      pcerttrust->cTrustStores + 1)  * sizeof(HCERTSTORE);
    pmydata = (PINTERNAL_DATA)pdata->psPfns->pfnAlloc(cbSize);
    if (! pmydata) {
        return(E_OUTOFMEMORY);
    }
    memset(pmydata, 0, sizeof(*pmydata));
    pmydata->cbSize = sizeof(*pmydata);
    pmydata->rghRootStores = (HCERTSTORE *) (((LPBYTE) pmydata) + sizeof(*pmydata));
    pmydata->rghTrustStores = &pmydata->rghRootStores[pcerttrust->cRootStores+1];

    privdata.cbStruct = sizeof(privdata);
    memcpy(&privdata.gProviderID, &MyGuid, sizeof(GUID));
    privdata.cbProvData = cbSize;
    privdata.pvProvData = pmydata;

    pdata->psPfns->pfnAddPrivData2Chain(pdata, &privdata);

    pmydata->pszUsageOid = pcerttrust->pszUsageOid;
    pmydata->dwFlags = pcerttrust->dwFlags;

    //
    //  Set the restriction OID back into the full provider information to
    //  make sure chaining is correct
    //

    pdata->pszUsageOID = pcerttrust->pszUsageOid;

    //
    //  Retrieve the default revocation check from the policy flags in the
    //  registry.
    //

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey, 0, KEY_READ,
                      &hkPolicy) == ERROR_SUCCESS) {
        cbSize = sizeof(dwPolicy);
        if ((ERROR_SUCCESS != RegQueryValueExA(hkPolicy,
                                               SzPolicyData, 
                                               0, &dwType,
                                               (LPBYTE)&dwPolicy,
                                               &cbSize)) ||
            (REG_DWORD != dwType)) {
            dwPolicy = 0;
        }                        
        RegCloseKey(hkPolicy);
    }

    //
    //  Set the default revocation check level
    //

    if (dwPolicy & ACTION_REVOCATION_DEFAULT_ONLINE) {
        // Allow full online revocation checking

        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_CHAIN;
    }
    else if (dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE) {
        // Allow local revocation checks only, do not hit the network

        // NOTE: Currently not supported by NT Crypto, default to none

        //Assert(!dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE)
        
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    else {
        // For backwards compatibility default to no revocation

        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }

    // 
    //  Update the revocation state based on what the user has specifically
    //  requested.
    //

    if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_ONLINE) {
        // Allow full online revocation checking

        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_CHAIN;
    }
    else if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_CACHE) {
        // Allow local revocation checks only, do not hit the network.

        // NOTE: Currently not supported by NT, for now we just ignore
        //  the revocakation
        
        // Assert(!pcerttrust->dwFlags & CRYPTDLG_REVOCATION_CACHE);
        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    else if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_NONE) {
        // Allow full online revocation checking

        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    
    //
    //  Set the default crypt provider so we can make sure that ours is used
    //

    if (pcerttrust->hprov != NULL) {
        if (!CryptInstallDefaultContext(pcerttrust->hprov, 
                                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                                        szOID_OIWSEC_md5RSA, 0, NULL,
                                        &pmydata->hdefaultcontext)) {
            return S_FALSE;
        }
                                       
    }

    //
    //  Setup the stores to be used by the search step.
    //
    //  Root ("God") stores
    //

    if (pcerttrust->cRootStores != 0) {
        for (i=0; i<pcerttrust->cRootStores; i++) {
            if (!pdata->psPfns->pfnAddStore2Chain(pdata,
                                                  pcerttrust->rghstoreRoots[i])) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
            pmydata->rghRootStores[i] = CertDuplicateStore(pcerttrust->rghstoreRoots[i]);
        }
        pmydata->cRootStores = i;
    }
    else {
        hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                               pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               L"Root");
        if (hstore == NULL) {
            pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
            return S_FALSE;
        }
        if (!pdata->psPfns->pfnAddStore2Chain(pdata, hstore)) {
            CertCloseStore(hstore, 0);
            pmydata->rghRootStores[0] = CertDuplicateStore(pcerttrust->rghstoreRoots[i]);
            return S_FALSE;
        }
        pmydata->rghRootStores[0] = CertDuplicateStore(hstore);
        pmydata->cRootStores = 1;
        CertCloseStore(hstore, 0);
    }

    //  "Trust" stores

    if (pcerttrust->cTrustStores != 0) {
        for (i=0; i<pcerttrust->cTrustStores; i++) {
            pmydata->rghTrustStores[i] = CertDuplicateStore(pcerttrust->rghstoreTrust[i]);
        }
        pmydata->cTrustStores = i;
    }
    else {
        hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                               pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               L"Trust");
        if (hstore == NULL) {
            pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
            return S_FALSE;
        }
        pmydata->rghTrustStores[0] = CertDuplicateStore(hstore);
        pmydata->cTrustStores = 1;
        CertCloseStore(hstore, 0);
    }

    //  "CA" stores


    if (pcerttrust->cStores != 0) {
        for (i=0; i<pcerttrust->cStores; i++) {
            if (!pdata->psPfns->pfnAddStore2Chain(pdata,
                                                  pcerttrust->rghstoreCAs[i])) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
        }
    }

    if ((pcerttrust->cStores == 0) ||
        (pcerttrust->dwFlags & CERT_TRUST_ADD_CERT_STORES)) {
        for (i=0; i<COtherProviders; i++) {
            hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                                   CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                   RgszProvider[i]);
            if (hstore == NULL) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
                return S_FALSE;
            }
            if (!pdata->psPfns->pfnAddStore2Chain(pdata, hstore)) {
                CertCloseStore(hstore, 0);
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
            CertCloseStore(hstore, 0);
        }
    }

    //
    //  We have exactly one signature object to be added in, that is the certificate
    //  that we are going to verify.
    //

    CRYPT_PROVIDER_SGNR         sgnr;

    memset(&sgnr, 0, sizeof(sgnr));
    sgnr.cbStruct = sizeof(sgnr);
    GetSystemTimeAsFileTime(&sgnr.sftVerifyAsOf);
    //    memcpy(&sgnr.sftVerifyAsOf, &pcerttrust->pccert->pCertInfo->NotBefore,
    //           sizeof(FILETIME));
    // sgnr.csCertChain = 0;
    // sgnr.pasCertChain = NULL;
    // sgnr.dwSignerType = 0;
    // sgnr.psSigner = NULL;
    // sgnr.dwError = 0;
    // sgnr.csCounterSigners = 0;
    // sgnr.pasCounterSigners = NULL;

    if (!pdata->psPfns->pfnAddSgnr2Chain(pdata, FALSE, 0, &sgnr)) {
        pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
        return S_FALSE;
    }

    if (!pdata->psPfns->pfnAddCert2Chain(pdata, 0, FALSE, 0, pcerttrust->pccert)) {
        pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
        return S_FALSE;
    }

    return S_OK;
}


#ifdef DEBUG
void DebugFileTime(FILETIME ft) {
    SYSTEMTIME st = {0};
    TCHAR szBuffer[256];

    FileTimeToSystemTime(&ft, &st);
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), L"%02d/%02d/%04d  %02d:%02d:%02d\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
    OutputDebugString(szBuffer);
}
#endif


LONG CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset) {
    LONG lRet;
    FILETIME ftNow;
    FILETIME ftDelta;
    __int64  i64Delta;
    __int64  i64Offset;

    lRet = CertVerifyTimeValidity(pTimeToVerify, pCertInfo);

    if (lRet < 0) {
        if (! pTimeToVerify) {
            // Get the current time in filetime format so we can add the offset
            GetSystemTimeAsFileTime(&ftNow);
            pTimeToVerify = &ftNow;
        }

#ifdef DEBUG
        DebugFileTime(*pTimeToVerify);
#endif

        i64Delta = pTimeToVerify->dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += pTimeToVerify->dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= ulOffset;
        i64Delta += i64Offset;

        ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

#ifdef DEBUG
        DebugFileTime(ftDelta);
#endif

        lRet = CertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

    return(lRet);
}


////    FCheckCTLCert
//
//  Description:
//      This function is called when we find a CTL signed by a certificate.  At this
//      point we are going to check to see if we believe in the cert which was
//      used to sign the CTL.
//
//      We know that the certificate was already one of the ROOT stores and is
//      therefore explicity trusted as this is enforced by the caller.
//

BOOL FCheckCTLCert(PCCERT_CONTEXT pccert)
{
    DWORD               cbData;
    BOOL                f;
    FILETIME            ftZero;
    DWORD               i;
    PCERT_ENHKEY_USAGE  pUsage;

    memset(&ftZero, 0, sizeof(ftZero));

    //
    //  Start by checking the time validity of the cert.  We are going to
    //  allow two special cases as well as the time being valid.
    //
    //  1.  The start and end time are the same -- and indication that we
    //          made this in an earlier incarnation, or
    //  2.  The end time is 0.
    //

    if ((memcmp(&pccert->pCertInfo->NotBefore, &pccert->pCertInfo->NotAfter,
               sizeof(FILETIME)) == 0) ||
         memcmp(&pccert->pCertInfo->NotAfter, &ftZero, sizeof(FILETIME)) == 0) {
        DWORD           err;
        HCERTSTORE      hcertstore;
        HKEY            hkey;
        PCCERT_CONTEXT  pccertNew;
        PCCERT_CONTEXT  pccertOld;

        err = RegOpenKeyExA(HKEY_CURRENT_USER,
                            "Software\\Microsoft\\SystemCertificates\\ROOT",
                            0, KEY_ALL_ACCESS, &hkey);
        hcertstore = CertOpenStore(CERT_STORE_PROV_REG, X509_ASN_ENCODING,
                                   NULL, 0, hkey);
        if (hcertstore != NULL) {
            pccertOld = CertGetSubjectCertificateFromStore(hcertstore,
                                  X509_ASN_ENCODING, pccert->pCertInfo);
            pccertNew = CreateTrustSigningCert(NULL, hcertstore, FALSE);
            CertFreeCertificateContext(pccertNew);

            if (pccertOld != NULL) {
                CertDeleteCertificateFromStore(pccertOld);
            }
            CertCloseStore(hcertstore, 0);
        }
        RegCloseKey(hkey);
    }
    else if (CertVerifyTimeValidityWithDelta(NULL, pccert->pCertInfo,
                                             TIME_DELTA_SECONDS) != 0) {
        return FALSE;
    }

    //
    //  Must have a correct enhanced key usage to be viable.
    //
    //  Crack the usage on the cert

    f = CertGetEnhancedKeyUsage(pccert, 0, NULL, &cbData);
    if (!f || (cbData == 0)) {
        return FALSE;
    }

    pUsage = (PCERT_ENHKEY_USAGE) malloc(cbData);
    if (pUsage == NULL) {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage(pccert, 0, pUsage, &cbData)) {
        free(pUsage);
        return FALSE;
    }

    //
    //  Look for the CTL_USAGE_SIGNING purpose on the cert.  If its not there
    //  then we don't allow it to be used.
    //

    for (i=0; i<pUsage->cUsageIdentifier; i++) {
        if (strcmp(pUsage->rgpszUsageIdentifier[i],
                   szOID_KP_CTL_USAGE_SIGNING) == 0) {
            break;
        }
    }
    if (i == pUsage->cUsageIdentifier) {
        free(pUsage);
        return FALSE;
    }
    free(pUsage);

    //
    //  Add any other tests.
    //

    return TRUE;
}

////    CertTrustCertPolicy
//
//   Description:
//      This code looks for trust information and puts it into the certificate
//      chain.  The behavior that we follow is going to depend on what type of
//      searching we are going to look for.
//
//      If we are just looking for trust, then we follow up the CTL looking for
//      trust information.
//

BOOL CertTrustCertPolicy(PCRYPT_PROVIDER_DATA pdata, DWORD, BOOL, DWORD)
{
    DWORD                       cb;
    BOOL                        f;
    BOOL                        fContinue = TRUE;
    DWORD                       i;
    CTL_VERIFY_USAGE_STATUS     vus;
    CTL_VERIFY_USAGE_PARA       vup;
    PCCTL_CONTEXT               pctlTrust = NULL;
    PCRYPT_PROVIDER_CERT        ptcert;
    CTL_USAGE                   ctlusage;
    PCCERT_CONTEXT              pccert = NULL;
    PCRYPT_PROVIDER_SGNR        psigner;
    PINTERNAL_DATA              pmydata;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    BYTE                        rgbHash[20];
    CRYPT_HASH_BLOB             blob;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //


    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        fContinue = FALSE;
        goto Exit;
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        fContinue = FALSE;
        goto Exit;
    }

    //
    //  Look to see if we already have an error to deal with
    //

    if (pdata->dwError != 0) {
        fContinue = FALSE;
        goto Exit;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_CERTCHKPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            fContinue = FALSE;
            goto Exit;
        }
    }

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata)
        pmydata = (PINTERNAL_DATA)pprivdata->pvProvData;
    else
    {
        fContinue = FALSE;
        goto Exit;
    }


    //
    //  We only work with a single signer --

    psigner = WTHelperGetProvSignerFromChain(pdata, 0, FALSE, 0);
    if (psigner == NULL)
    {
        fContinue = FALSE;
        goto Exit;
    }

    //
    //  Extract the certificate at the top of the stack
    //

    ptcert = WTHelperGetProvCertFromChain(psigner, psigner->csCertChain-1);

    //
    //  Does this certificate meet the definitions of "TRUSTED".
    //
    //  Definition #1.  It exists in a Root store
    //

    blob.cbData = sizeof(rgbHash);
    blob.pbData = rgbHash;
    cb = sizeof(rgbHash);
    CertGetCertificateContextProperty(ptcert->pCert, CERT_SHA1_HASH_PROP_ID,
                                      rgbHash, &cb);
    for (i=0; i<pmydata->cRootStores; i++) {
        pccert = CertFindCertificateInStore(pmydata->rghRootStores[i], X509_ASN_ENCODING,
                                            0, CERT_FIND_SHA1_HASH, &blob, NULL);
        if (pccert != NULL) {
            ptcert->fTrustedRoot = TRUE;
            fContinue = FALSE;
            goto Exit;
        }
    }

    //
    //  Build up the structures we will use to do a search in the
    //  trust stores
    //

    memset(&ctlusage, 0, sizeof(ctlusage));
    ctlusage.cUsageIdentifier = 1;
    ctlusage.rgpszUsageIdentifier = (LPSTR *) &pmydata->pszUsageOid;

    memset(&vup, 0, sizeof(vup));
    vup.cbSize = sizeof(vup);
    vup.cCtlStore = pmydata->cTrustStores;
    vup.rghCtlStore = pmydata->rghTrustStores;
    vup.cSignerStore = pmydata->cRootStores;
    vup.rghSignerStore = pmydata->rghRootStores;

    memset(&vus, 0, sizeof(vus));
    vus.cbSize = sizeof(vus);
    vus.ppCtl = &pctlTrust;
    vus.ppSigner = &pccert;

    //
    //  Now search for the CTL on this certificate,  if we don't find anything then
    //  we return TRUE to state that we want the search to continue
    //
    //

    f = CertVerifyCTLUsage(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                           (LPVOID) ptcert->pCert, &ctlusage,
                           CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG |
                           CERT_VERIFY_NO_TIME_CHECK_FLAG |
                           CERT_VERIFY_TRUSTED_SIGNERS_FLAG, &vup, &vus);

    if (!f) {
        goto Exit;
    }

    //
    //  We found a CTL for this certificate.  First step is to see if the signing
    //  certificate is one which we can respect.  We know that the cert is in
    //  a root store, since we told the system it could only accept root store
    //  certs
    //

    if (!FCheckCTLCert(pccert)) {
        f = FALSE;
        goto Exit;
    }

    //  OK -- the signing cert passed it sanity check -- so see if the CTL contains
    //  relevent information or is just a "keep looking" CTL.
    //

    ptcert->pTrustListContext = (PCTL_CONTEXT) pctlTrust;
    pctlTrust = NULL;

    //
    //   We we are trying to do a full trust verification, then we need to
    //  just skip to the next cert without bothering to look at the ctl
    //

    if (pmydata->dwFlags & CERT_TRUST_DO_FULL_SEARCH) {
        goto Exit;
    }

    //
    //  Look to see if this is a "pass" item.  If it is then we need to
    //  continue looking, if it is not then we have reached the
    //  decision point
    //

    PCTL_ENTRY  pentry;
    pentry = &ptcert->pTrustListContext->pCtlInfo->rgCTLEntry[vus.dwCtlEntryIndex];
    for (i=0; i<pentry->cAttribute; i++) {
        if ((strcmp(pentry->rgAttribute[i].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
            (strcmp(pentry->rgAttribute[i].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) {
            if ((pentry->rgAttribute[i].rgValue[0].cbData == sizeof(RgbTrustParent)) &&
                (memcmp(pentry->rgAttribute[i].rgValue[0].pbData,
                        RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                //  Defer to parent
                goto Exit;
            }
            //
            //  We have the decision point, push the signer onto the the stack
            //

            fContinue = !!(pmydata->dwFlags & CERT_TRUST_DO_FULL_TRUST);
            goto Exit;
        }

    }

Exit:
    if (pccert != NULL) CertFreeCertificateContext(pccert);
    if (pctlTrust != NULL) CertFreeCTLContext(pctlTrust);
    return fContinue;
}

////    HrCheckPolicies
//
//  Description:
//      Given an array of certificates, figure out what errors we have
//
//      We enforce the following set of extensions
//
//      enhancedKeyUsage
//      basicConstraints
//      keyUsage
//      nameConstraints
//

HRESULT HrCheckPolicies(PCRYPT_PROVIDER_SGNR psigner, DWORD cChain,
                        DWORD * rgdwErrors, LPCSTR pszUsage)
{
    DWORD                       cbData;
    DWORD                       cExt;
    DWORD                       dwPolicy = 0;
    DWORD                       dwType;
    HKEY                        hkPolicy;
    DWORD                       i;
    DWORD                       iCert;
    DWORD                       iExt;
    PCRYPT_PROVIDER_CERT        ptcert;
    PCERT_EXTENSION             rgExt;
    
    // Retrieve policy information from the registry
    
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey, 0, KEY_READ,
        &hkPolicy) == ERROR_SUCCESS) {
        cbData = sizeof(dwPolicy);
        if ((ERROR_SUCCESS != RegQueryValueExA(hkPolicy,
            SzPolicyData, 
            0, &dwType,
            (LPBYTE)&dwPolicy,
            &cbData)) ||
            (REG_DWORD != dwType)) {
            dwPolicy = 0;
        }                        
        RegCloseKey(hkPolicy);
    }
    
    // Check the policy on each cert in the chain
    
    for (iCert=0; iCert<cChain; iCert++) {
        //
        //  Get the next cert to examine
        //
        
        ptcert = WTHelperGetProvCertFromChain(psigner, iCert);
        
        //
        //  Setup to process the certs extensions
        //
        
        if (!ptcert || !(ptcert->pCert) || !(ptcert->pCert->pCertInfo))
            continue;

        cExt = ptcert->pCert->pCertInfo->cExtension;
        rgExt = ptcert->pCert->pCertInfo->rgExtension;
        
        //
        //  Process the extensions
        //
        
ProcessExtensions:
        for (iExt=0; iExt<cExt; iExt++) {
            if (strcmp(rgExt[iExt].pszObjId, szOID_ENHANCED_KEY_USAGE) == 0) {
                if (pszUsage == NULL) {
                    continue;
                }
                PCERT_ENHKEY_USAGE      pUsage;
                pUsage = (PCERT_ENHKEY_USAGE) PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((pUsage == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
                    continue;
                }
                
                if(pUsage)
                {
                    for (i=0; i<pUsage->cUsageIdentifier; i++) {
                        if (strcmp(pUsage->rgpszUsageIdentifier[i], pszUsage) == 0) {
                            break;
                        }
                    }
                    if (i == pUsage->cUsageIdentifier) {
                        rgdwErrors[iCert] |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
                    }
                    
                    free(pUsage);
                }
            }
            else if (strcmp(rgExt[iExt].pszObjId, szOID_BASIC_CONSTRAINTS2) == 0) {
                PCERT_BASIC_CONSTRAINTS2_INFO   p;
                
                // If Basic Constraints is not marked critical (in opposition
                //  to PKIX) we allow the administrator to overrule our 
                //  processing to deal with bad NT CertSrv SP1 hierarchies
                //  used with Exchange KMS.
                
                if ((dwPolicy & POLICY_IGNORE_NON_CRITICAL_BC) &&
                    !(rgExt[iExt].fCritical)) {
                    continue;
                }
                
                // Verify the basic constraint extension
                
                p = (PCERT_BASIC_CONSTRAINTS2_INFO)
                    PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((p == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
                    continue;
                }
                
                if(p)
                {
                    if ((!p->fCA) && (iCert > 0) && (iCert < cChain-1)) {
                        rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    }
                    
                    if (p->fPathLenConstraint) {
                        if (p->dwPathLenConstraint+1 < iCert) {
                            rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                        }
                    }
                    
                    free(p);
                }
            }
            else if (strcmp(rgExt[iExt].pszObjId, szOID_KEY_USAGE) == 0) {
                PCERT_KEY_ATTRIBUTES_INFO    p;
                p = (PCERT_KEY_ATTRIBUTES_INFO)
                    PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((p == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
                    continue;
                }
                
                if(p)
                {
                    if (p->IntendedKeyUsage.cbData >= 1) {
                        if (iCert != 0) {
#if 0
                            if (!((*p->IntendedKeyUsage.pbData) & CERT_KEY_CERT_SIGN_KEY_USAGE)) {
                                rgdwErrors[iCert] |= CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
                            }
#endif // 0
                        }
                    }
                    free(p);
                }
            }
            else if ((strcmp(rgExt[iExt].pszObjId, szOID_SUBJECT_ALT_NAME2) == 0) ||
            (strcmp(rgExt[iExt].pszObjId, szOID_CRL_DIST_POINTS) == 0)/* ||
                                                                      (strcmp(rgExt[iExt].pszObjId, szOID_CERT_POLICIES) == 0) ||
                                                                      (strcmp(rgExt[iExt].pszObjId, "2.5.29.30") == 0) ||
                                                                      (strcmp(rgExt[iExt].pszObjId, "2.5.29.36") == 0)*/) {
                                                                      ;
            }
            else if (rgExt[iExt].fCritical) {
                rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
            }
        }
        
        //
        //  If we have a CTL for this cert, and we have not already done so
        //      then process the extensions that it has.
        //
        
        if ((ptcert->pTrustListContext != NULL) &&
            (rgExt != ptcert->pTrustListContext->pCtlInfo->rgExtension)) {
            cExt = ptcert->pTrustListContext->pCtlInfo->cExtension;
            rgExt = ptcert->pTrustListContext->pCtlInfo->rgExtension;
            goto ProcessExtensions;
        }
        
        //
        //  Need to support turn off of certificates
        //
        
        if (CertGetEnhancedKeyUsage(ptcert->pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
            NULL, &cbData)) {
            BOOL                fFound = FALSE;
            PCERT_ENHKEY_USAGE  pUsage;
            pUsage = (PCERT_ENHKEY_USAGE) malloc(cbData);
            CertGetEnhancedKeyUsage(ptcert->pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pUsage, &cbData);
            
            for (i=0; i<pUsage->cUsageIdentifier; i++) {
                if ((pszUsage != NULL) &&
                    strcmp(pUsage->rgpszUsageIdentifier[i], pszUsage) == 0) {
                    fFound = TRUE;
                }
                else if (strcmp(pUsage->rgpszUsageIdentifier[i], szOID_YESNO_TRUST_ATTR) == 0) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    break;
                }
            }
            
            if ((pszUsage != NULL) && !fFound) {
                rgdwErrors[iCert] |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
            }
            
            free(pUsage);
        }
        
        //
        //  If we jump past a CTL, then we need to change our purpose
        //
        
        if (ptcert->pCtlContext != NULL) {
            pszUsage = SzOID_KP_CTL_USAGE_SIGNING;
        }
    }
    return S_OK;
}

//// GetErrorFromCert
//
//   Description:
//      Get the internal error from the provider certificate
//
DWORD GetErrorFromCert(PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    //
    // if this is true then the cert is OK
    //
    if ((pCryptProviderCert->dwError == 0)                              &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG)        &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME)       &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (!pCryptProviderCert->fIsCyclic))
    {
        return 0;
    }


    if (pCryptProviderCert->dwError == CERT_E_REVOKED)
    {
        return CERT_VALIDITY_CERTIFICATE_REVOKED;
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOCATION_FAILURE)
    {
        return CERT_VALIDITY_NO_CRL_FOUND;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG) ||
             (pCryptProviderCert->dwError == TRUST_E_CERT_SIGNATURE))
    {
        return CERT_VALIDITY_SIGNATURE_FAILS;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME) ||
             (pCryptProviderCert->dwError == CERT_E_EXPIRED))
    {
        return CERT_VALIDITY_AFTER_END;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST) ||
             (pCryptProviderCert->dwError == CERT_E_VALIDITYPERIODNESTING))
    {         
        return CERT_VALIDITY_PERIOD_NESTING_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_WRONG_USAGE)
    {
        return CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
    }
    else if (pCryptProviderCert->dwError == TRUST_E_BASIC_CONSTRAINTS)
    {
        return CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_PURPOSE)
    {
        return CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_CHAINING)
    {
        return CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
    }
    else if (pCryptProviderCert->dwError == TRUST_E_EXPLICIT_DISTRUST)
    {
        return CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
    }
    else if (pCryptProviderCert->fIsCyclic)
    {
        return CERT_VALIDITY_ISSUER_INVALID;
    }
    else
    {
        //
        // this is not an error we know about, so call return general error
        //
        return CERT_VALIDITY_OTHER_ERROR;
    }

}

//// MapErrorToTrustError
//
//   Description:
//      Map the internal error value to a WINTRUST recognized value.
//      The CryptUI dialogs recognize these values:
//          CERT_E_UNTRUSTEDROOT
//          CERT_E_REVOKED
//          TRUST_E_CERT_SIGNATURE
//          CERT_E_EXPIRED
//          CERT_E_VALIDITYPERIODNESTING
//          CERT_E_WRONG_USAGE
//          TRUST_E_BASIC_CONSTRAINTS
//          CERT_E_PURPOSE
//          CERT_E_REVOCATION_FAILURE
//          CERT_E_CHAINING  - this is set if a full chain cannot be built
//
//
HRESULT MapErrorToTrustError(DWORD dwInternalError) {
    HRESULT hrWinTrustError = S_OK;

    // Look at them in decreasing order of importance
    if (dwInternalError) {
        if (dwInternalError & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            hrWinTrustError = /*TRUST_E_EXPLICIT_DISTRUST*/ 0x800B0111;
        } else if (dwInternalError & CERT_VALIDITY_SIGNATURE_FAILS) {
            hrWinTrustError = TRUST_E_CERT_SIGNATURE;
        } else if (dwInternalError & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            hrWinTrustError = CERT_E_REVOKED;
        } else if (dwInternalError & CERT_VALIDITY_BEFORE_START || dwInternalError & CERT_VALIDITY_AFTER_END) {
            hrWinTrustError = CERT_E_EXPIRED;
        } else if (dwInternalError & CERT_VALIDITY_ISSUER_DISTRUST) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwInternalError & CERT_VALIDITY_ISSUER_INVALID) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwInternalError & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
            hrWinTrustError = CERT_E_CHAINING;
        } else if (dwInternalError & CERT_VALIDITY_NO_CRL_FOUND) {
            hrWinTrustError = CERT_E_REVOCATION_FAILURE;
        } else if (dwInternalError & CERT_VALIDITY_PERIOD_NESTING_FAILURE) {
            hrWinTrustError = CERT_E_VALIDITYPERIODNESTING;
        } else if (dwInternalError & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
            hrWinTrustError = CERT_E_WRONG_USAGE;
        } else if (dwInternalError & CERT_VALIDITY_OTHER_ERROR) {
            hrWinTrustError = TRUST_E_FAIL;     // BUGBUG: Will this give a good error?;
        } else if (dwInternalError & CERT_VALIDITY_NO_TRUST_DATA) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else {
            hrWinTrustError = TRUST_E_FAIL;     // BUGBUG: Will this give a good error?;
        }
    }

    // CERT_E_UNTRUSTEDROOT
    // CERT_E_REVOKED
    // TRUST_E_CERT_SIGNATURE
    // CERT_E_EXPIRED
    // X CERT_E_VALIDITYPERIODNESTING
    // X CERT_E_WRONG_USAGE
    // TRUST_E_BASIC_CONSTRAINTS
    // CERT_E_PURPOSE
    // CERT_E_REVOCATION_FAILURE    What is this?
    // CERT_E_CHAINING  - this is set if a full chain cannot be built


    return(hrWinTrustError);
}



////    CertTrustFinalPolicy
//
//  Description:
//      This code does the enforcement of all restrictions on the certificate
//      chain that we understand.
//

HRESULT CertTrustFinalPolicy(PCRYPT_PROVIDER_DATA pdata)
{
    int                         cChain = 0;
    DWORD                       dwFlags;
    FILETIME                    ftZero = {0, 0};
    HRESULT                     hr;
    HRESULT                     hrStepError = S_OK;
    int                         i;
    DWORD                       j;
    PCERT_VERIFY_CERTIFICATE_TRUST pcerttrust;
    PINTERNAL_DATA              pmydata;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    PCRYPT_PROVIDER_SGNR        psigner;
    PCRYPT_PROVIDER_CERT        ptcert = NULL;
    PCRYPT_PROVIDER_CERT        ptcertIssuer;
    DATA_BLOB *                 rgblobTrustInfo = NULL;
    LPBYTE                      rgbTrust = NULL;
    DWORD *                     rgdwErrors = NULL;
    PCCERT_CONTEXT *            rgpccertChain = NULL;
    int                         iExplicitlyTrusted;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //


    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    pcerttrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pdata->pWintrustData->pBlob->pbMemObject;
    if ((pcerttrust == NULL) ||
        (pcerttrust->cbSize < sizeof(*pcerttrust))) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata == NULL) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    pmydata = (PINTERNAL_DATA) pprivdata->pvProvData;

    //
    //  Check for an existing error -- If so then skip to any UI
    //

    if (pdata->dwError != 0) {
        hr = pdata->dwError;
        goto XXX;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_POLICYPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            // for these errors we still want to continue processing
            if ((TRUST_E_CERT_SIGNATURE == pdata->padwTrustStepErrors[i]) ||
                (CERT_E_REVOKED == pdata->padwTrustStepErrors[i]) ||
                (CERT_E_REVOCATION_FAILURE == pdata->padwTrustStepErrors[i])) {
                hrStepError = pdata->padwTrustStepErrors[i];
            }
            else {
                hr = pdata->padwTrustStepErrors[i];
                goto XXX;
            }
        }
    }

    //
    //  We only work with a single signer --

    psigner = WTHelperGetProvSignerFromChain(pdata, 0, FALSE, 0);
    if (psigner == NULL) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    //
    //   If we are not getting a full chain, then build up the set of
    //  certs and pass it to the validator
    //

    if (!(pmydata->dwFlags & CERT_TRUST_DO_FULL_SEARCH)) {

    }

    //
    //  We are going to compute some return values at this point
    //  either a full chain or a full chain with complete trust.
    //
    //  Allocate space to return the chain of certs back to the caller.
    //  We allocate space for the full chain, even though we may not
    //  actually use it.
    //

    cChain = psigner->csCertChain;

    rgpccertChain = (PCCERT_CONTEXT *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                  cChain * sizeof(PCCERT_CONTEXT));
    rgdwErrors = (DWORD *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain * sizeof(DWORD));
    rgblobTrustInfo = (DATA_BLOB *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain * sizeof(DATA_BLOB));
    rgbTrust = (BYTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain*sizeof(BLOB));

    if ((rgpccertChain == NULL) || (rgdwErrors == NULL) ||
        (rgblobTrustInfo == NULL) || (rgbTrust == NULL)) {
        hr = E_OUTOFMEMORY;
        goto XXX;
    }

    //
    //  Build the first set of returned values.  At this
    //  point we are creating the arrays to return both
    //  the relevent trust information and the chain of
    //  certificates in
    //

    for (i=0; i<cChain; i++) {
        //
        //  Start by duplicating the certificate into the return
        //      location
        //

        ptcert = WTHelperGetProvCertFromChain(psigner, i);
        rgpccertChain[i] = CertDuplicateCertificateContext(ptcert->pCert);
        if (i < cChain-1) {
            ptcertIssuer = WTHelperGetProvCertFromChain(psigner, i+1);
        }
        else {
            ptcertIssuer = NULL;
            if (!ptcert->fSelfSigned) {
                rgdwErrors[i] |= CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
            }
        }

        //
        //  Check for some simple items
        //

        dwFlags = CertVerifyTimeValidityWithDelta(NULL, 
                                                  ptcert->pCert->pCertInfo, 
                                                  TIME_DELTA_SECONDS);
        if (((LONG)dwFlags) < 0) {
            rgdwErrors[i] |= CERT_VALIDITY_BEFORE_START;
        }
        else if (dwFlags > 0) {
            if (!ptcert->fTrustListSignerCert ||
                memcmp(&ptcert->pCert->pCertInfo->NotAfter, &ftZero, 
                       sizeof(ftZero)) != 0) {
                rgdwErrors[i] |= CERT_VALIDITY_AFTER_END;
            }
            else {
                if (!(ptcert->dwConfidence & CERT_CONFIDENCE_TIME)) {
                    ptcert->dwConfidence |= CERT_CONFIDENCE_TIME;
                }            
                if (ptcert->dwError == CERT_E_EXPIRED) {
                    ptcert->dwError = S_OK;
                }
           }
        }

        //
        // Check for error in Certificate
        //
        rgdwErrors[i] |= GetErrorFromCert(ptcert);

        //
        //  If we find an issuer, then lets go after the questions we have
        //      about CRLs.
        //
        //  Question -- do we get everything here?  How do we know if the
        //      CRL is out of date.
        //

        if ((ptcertIssuer != NULL) && (ptcert->pCtlContext == NULL)) {
            dwFlags = CERT_STORE_SIGNATURE_FLAG;
            if ((pdata->dwProvFlags & CPD_REVOCATION_CHECK_NONE) ||
                (psigner->pChainContext == NULL))
                dwFlags |= CERT_STORE_REVOCATION_FLAG;
            if (CertVerifySubjectCertificateContext(ptcert->pCert, ptcertIssuer->pCert, &dwFlags) &&
                (dwFlags != 0)) {
                if (dwFlags & CERT_STORE_SIGNATURE_FLAG) {
                    rgdwErrors[i] |= CERT_VALIDITY_SIGNATURE_FAILS;
                }
                if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                    if (dwFlags & CERT_STORE_NO_CRL_FLAG) {
                        rgdwErrors[i] |= CERT_VALIDITY_NO_CRL_FOUND;
                    }
                    else {
                        rgdwErrors[i] |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                    }
                }
            }

            // If both CRL not found and revoked are set, choose the most
            //  conservative state- the cert is revoked.
            
            if ((CERT_VALIDITY_NO_CRL_FOUND & rgdwErrors[i]) &&
                (CERT_VALIDITY_CERTIFICATE_REVOKED & rgdwErrors[i])) {
                rgdwErrors[i] &= ~CERT_VALIDITY_NO_CRL_FOUND;
            }                
        }

        //
        //
        //

        if (ptcert->fTrustedRoot) {
            rgblobTrustInfo[i].cbData = 0;
            rgblobTrustInfo[i].pbData = (LPBYTE) 1;
            rgbTrust[i] = 1;
        }
        else if (ptcert->pTrustListContext != NULL) {
            CRYPT_ATTRIBUTES    attrs;
            DWORD               cbData;
            BOOL                f;
            LPBYTE              pb;
            PCTL_ENTRY          pctlentry;

            pctlentry = CertFindSubjectInCTL(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                                             (LPVOID) ptcert->pCert, ptcert->pTrustListContext,
                                             0);
            attrs.cAttr = pctlentry->cAttribute;
            attrs.rgAttr = pctlentry->rgAttribute;

            for (j=0; j<attrs.cAttr; j++) {
                if ((strcmp(attrs.rgAttr[j].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
                    (strcmp(attrs.rgAttr[j].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) {

                    if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustYes)) &&
                        (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                RgbTrustYes, sizeof(RgbTrustYes)) == 0)) {
                        rgbTrust[i] = 2;
                        break;
                    }
                    else if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustNo)) &&
                             (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                     RgbTrustNo, sizeof(RgbTrustNo)) == 0)) {
                        rgdwErrors[i] |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
                        rgbTrust[i] = (BYTE) -1;
                        break;
                    }
                    else if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustParent)) &&
                             (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                     RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                        rgbTrust[i] = 0;
                        break;
                    }
                    else {
                        rgdwErrors[i] |= CERT_VALIDITY_NO_TRUST_DATA;
                        rgbTrust[i] = (BYTE) -2;
                        break;
                    }
                }
            }
            if (j == attrs.cAttr) {
                rgbTrust[i] = 0;
            }

            f = CryptEncodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                              &attrs, NULL, &cbData);
            if (f && (cbData != 0)) {
                pb = (LPBYTE) LocalAlloc(LMEM_FIXED, cbData);
                if (pb != NULL) {
                    f = CryptEncodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                          &attrs, pb, &cbData);
                    rgblobTrustInfo[i].cbData = cbData;
                    rgblobTrustInfo[i].pbData = pb;
                }
            }
        }
    }

    //
    //
    //

    DWORD       rgiCert[32];
    for (i=0; i<cChain; i++) {
        rgiCert[i] = i;
    }

    //
    //   Apply policies to it
    //

    hr = HrCheckPolicies(psigner, cChain, rgdwErrors, pcerttrust->pszUsageOid);
    if (FAILED(hr)) {
        goto XXX;
    }

    //
    //  Mask out the bits which the caller says are un-important
    //

    if (pcerttrust->pdwErrors != NULL) {
        *pcerttrust->pdwErrors = 0;
    }

    // Find the lowest index explicitly trusted cert in chain
    iExplicitlyTrusted = cChain;    // > index of root cert
    for (i = 0; i < cChain; i++) {
        if (rgbTrust[i] == 2) {
            iExplicitlyTrusted = i;
            break;
        }
    }

    for (i=cChain-1; i>=0; i--) {
        //
        //  Build a better idea of basic trust
        //

        switch (rgbTrust[i]) {
            //  We are explicity trusted -- clear out any trust errors which may
            //  have been located for this certificate  They are no longer
            //  relevent.
        case 1:         // Explicitly trusted (root)
        case 2:         // Explicitly trusted (CTL)
            rgdwErrors[i] &= ~(CERT_VALIDITY_MASK_TRUST |
                               CERT_VALIDITY_CERTIFICATE_REVOKED);
            break;

        case -2:        // Unknown CTL data
        case -1:        // Explicitly distrusted (CTL)
            rgdwErrors[i] |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
            break;

        case 0:         // Chain trusted (CTL or no CTL)
            if (i == cChain-1) {
                rgdwErrors[i] |= CERT_VALIDITY_NO_TRUST_DATA;
            }
            break;
        }

        rgdwErrors[i] &= ~pcerttrust->dwIgnoreErr;

        if (i > 0) {
            if (rgdwErrors[i] & CERT_VALIDITY_MASK_VALIDITY) {
                rgdwErrors[i-1] |= CERT_VALIDITY_ISSUER_INVALID;
            }
            if (rgdwErrors[i] & CERT_VALIDITY_MASK_TRUST) {
                rgdwErrors[i-1] |= CERT_VALIDITY_ISSUER_DISTRUST;
            }
        }

        if (pcerttrust->pdwErrors != NULL) {
            DWORD dwThisTrust = rgdwErrors[i];

            if (i >= iExplicitlyTrusted) {
                // If we have an explicitly trusted cert or one of it's issuer's,
                // we assume trust all the way up the chain.
                dwThisTrust &= ~(CERT_VALIDITY_MASK_TRUST | CERT_VALIDITY_CERTIFICATE_REVOKED);
            }

            *pcerttrust->pdwErrors |= dwThisTrust;
        }

        // Set the trust state for this chain cert
        if (WVT_ISINSTRUCT(CRYPT_PROVIDER_CERT, ptcert->cbStruct, dwError)) {
            ptcert = WTHelperGetProvCertFromChain(psigner, i);
            ptcert->dwError = (DWORD)MapErrorToTrustError(rgdwErrors[i]);
        }
    }

    if (rgdwErrors[0] != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    if (WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, dwFinalError)) {
        pdata->dwFinalError = (DWORD)MapErrorToTrustError(rgdwErrors[0]);

        if (pdata->dwFinalError) {
           // Assert(hr != S_OK);
        }
    }

    //
    //  We have succeded and are finished.
    //  Setup the return values
    //

    if (pcerttrust->pcChain != NULL) {
        *pcerttrust->pcChain = cChain;
    }
    if (pcerttrust->prgChain != NULL) {
        *pcerttrust->prgChain = rgpccertChain;
        rgpccertChain = NULL;
    }
    if (pcerttrust->prgdwErrors != NULL) {
        *pcerttrust->prgdwErrors = rgdwErrors;
        rgdwErrors = NULL;
    }
    if (pcerttrust->prgpbTrustInfo != NULL) {
        *pcerttrust->prgpbTrustInfo = rgblobTrustInfo;
        rgblobTrustInfo = NULL;
    }

XXX:
    if (rgpccertChain != NULL) {
        for (i=0; i<cChain; i++) {
            CertFreeCertificateContext(rgpccertChain[i]);
            }
        LocalFree(rgpccertChain);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrustInfo != NULL) {
        for (i=0; i<cChain; i++) {
            if (rgblobTrustInfo[i].cbData > 0) {
                LocalFree(rgblobTrustInfo[i].pbData);
            }
        }
        LocalFree(rgblobTrustInfo);
    }
    if (rgbTrust != NULL) LocalFree(rgbTrust);
    // If everything worked then reurn any step error we ignored
    if (FAILED(hrStepError) && SUCCEEDED(hr))
        hr = hrStepError;
    return hr;
}

////    CertTrustCleanup
//
//  Description:
//      This code knows how to cleanup all allocated data we have.
//

HRESULT CertTrustCleanup(PCRYPT_PROVIDER_DATA pdata)
{
    DWORD                       i;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    PINTERNAL_DATA              pmydata;

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata == NULL) {
        return S_OK;
    }

    pmydata = (PINTERNAL_DATA) pprivdata->pvProvData;

    //
    //  Release all of the stores we have cached here
    //

    for (i=0; i<pmydata->cRootStores; i++) {
        CertCloseStore(pmydata->rghRootStores[i], 0);
    }

    for (i=0; i<pmydata->cTrustStores; i++) {
        CertCloseStore(pmydata->rghTrustStores[i], 0);
    }

    //
    //  If we installed a default crypt context, uninstall it now
    //

    i = CryptUninstallDefaultContext(pmydata->hdefaultcontext, 0, NULL);
    // Assert(i == TRUE);

    return S_OK;
}


#else  // !NT5BUILD
#pragma message("Building for IE")

////    HrCheckTrust
//
//  Description:
//

HRESULT HrCheckTrust(PCCertFrame  pcf, int iTrust)
{
    HRESULT     hr;
    HRESULT     hrRet = S_OK;
    int         i;

    //
    //  If this node has trust information on it, then compute the trust at this
    //  point.  If we either succeed or fail then return the indication.
    //

    if ((pcf->m_rgTrust != NULL) && (pcf->m_rgTrust[iTrust].szOid != NULL)) {
        if (pcf->m_fRootStore) {
            pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
            pcf->m_rgTrust[iTrust].fTrust = TRUE;
            return S_OK;
        }
        if ((strcmp(pcf->m_rgTrust[iTrust].szOid, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
            (strcmp(pcf->m_rgTrust[iTrust].szOid, SzOID_OLD_CTL_YESNO_TRUST) == 0)){
            if ((pcf->m_rgTrust[iTrust].cbTrustData == 3) &&
                memcmp(pcf->m_rgTrust[iTrust].pbTrustData, RgbTrustYes, 3) == 0) {
                pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
                pcf->m_rgTrust[iTrust].fTrust = TRUE;
                return S_OK;
            }
            else if ((pcf->m_rgTrust[iTrust].cbTrustData == 3) &&
                     memcmp(pcf->m_rgTrust[iTrust].pbTrustData,
                            RgbTrustParent, 3) == 0) {
                //  Need to ceck with the parent to find out what is going on.
            }
            else {
                // Assume it must be RgbTrustNo
                pcf->m_rgTrust[iTrust].fExplicitDistrust = TRUE;
                pcf->m_rgTrust[iTrust].fDistrust = TRUE;
                return S_FALSE;
            }
        }
        else {
            pcf->m_rgTrust[iTrust].fError = TRUE;
            return S_FALSE;
        }
    }

    if (pcf->m_fRootStore) {
        pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
        pcf->m_rgTrust[iTrust].fTrust = TRUE;
        return S_OK;
    }

    //
    //  We are marked as inherit -- so start asking all of our parents
    //

    if (pcf->m_cParents == 0) {
        // No parents -- so not trusted.
        hrRet = S_FALSE;
    }
    else {
        for (i=0; i<pcf->m_cParents; i++) {
            hr = HrCheckTrust(pcf->m_rgpcfParents[i], iTrust);
            if (FAILED(hr)) {
                pcf->m_rgTrust[iTrust].fError = TRUE;
                return hr;
            }
            pcf->m_rgTrust[iTrust].fTrust = pcf->m_rgpcfParents[i]->m_rgTrust[iTrust].fTrust;
            pcf->m_rgTrust[iTrust].fDistrust = pcf->m_rgpcfParents[i]->m_rgTrust[iTrust].fDistrust;
            if (hr != S_OK) {
                hrRet = S_FALSE;
            }
        }
    }

    return hrRet;
}

////    HrCheckValidity
//
//  Description:
//      This function will walk through the tree of certificates looking
//      for the invalid certificates.  It masks in the fact that the issuer
//      certificate is invalid as necessary

HRESULT HrCheckValidity(PCCertFrame  pcf)
{
    HRESULT     hr;
    int         i;

    //
    //  If we do not have an issuer certificate, then our parent cannot possibly
    //  be invalid
    //

    if (pcf->m_cParents > 0) {
        for (i=0; i<pcf->m_cParents; i++) {
            hr = HrCheckValidity(pcf->m_rgpcfParents[i]);
            // Assert(SUCCEEDED(hr));
            if (hr != S_OK) {
                pcf->m_dwFlags |= CERT_VALIDITY_ISSUER_INVALID;
                return hr;
            }
        }
    }
    return (pcf->m_dwFlags == 0) ? S_OK : S_FALSE;
}

////    HrPerformUserCheck
//

HRESULT HrPerformUserCheck(PCCertFrame  pcf, BOOL fComplete,
                           DWORD * pcNodes, int iDepth, PCCertFrame * rgpcf)
{
    int iTrust = 0;

    //
    //  We can only deal with up to 20-nodes in the chain of trust
    //

    if (iDepth == 20) {
        return E_OUTOFMEMORY;
    }

    //
    //  Put our node in so we can do array process checking
    //

    rgpcf[iDepth] = pcf;

    //
    //  Handle the case where we don't have a trust usage
    //  User should still have a chance to invalidate the cert
    //

    if (NULL == pcf->m_rgTrust) {
        if (pcf->m_cParents != 0) {
            return HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                           iDepth+1, rgpcf);
        }
        *pcNodes = iDepth+1;
        return S_OK;
    }

    //
    //  If trust is really bad -- don't bother asking, just fail
    //

    if (pcf->m_rgTrust[iTrust].fError) {
        return E_FAIL;
    }

    //
    //  See what the trust on this node is, if we explicity trust the node
    //  then ask the user his option on the entire array
    //

    if (pcf->m_rgTrust[iTrust].fExplicitTrust) {
        if (fComplete && (pcf->m_cParents != 0)) {
            HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                               iDepth+1, rgpcf);
        }
        else {
            //  M00TODO Insert check to the user's function at this point

            //  Found nirvana
            *pcNodes = iDepth+1;
        }
        return S_OK;
    }

    if ((pcf->m_rgTrust[iTrust].fExplicitDistrust) ||
        (pcf->m_rgTrust[iTrust].fDistrust)) {
        if (fComplete && (pcf->m_cParents != 0)) {
            HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                               iDepth+1, rgpcf);
        }
        else {
            //  I don't think we should be here -- but the result is a NO trust
            //      decision
            *pcNodes = iDepth+1;
        }
        return S_FALSE;
    }

    //
    //  If we get here -- we should have inheritence trust.  Continue
    //  walking up the tree and make sure
    //

    if (pcf->m_cParents == 0) {
        *pcNodes = iDepth+1;
        return S_FALSE;
    }

    // M00BUG -- need to check multliple parents?

    return HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                              iDepth+1, rgpcf);
}

////    HrDoTrustWork
//
//  Description:
//      This function does the core code of determining if a certificate
//      can be trusted.  This needs to be moved to a WinTrust provider in
//      the near future.
//

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD cPurposes, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER /*pfn*/, DWORD /*lCustData*/,
                      PCCertFrame *  ppcf, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD               dwFlags;
    HRESULT             hr;
    HCERTSTORE          hstoreRoot=NULL;
    HCERTSTORE          hstoreTrust=NULL;
    DWORD               i;
    int                 iParent;
    PCCERT_CONTEXT      pccert;
    PCCERT_CONTEXT      pccert2;
    PCCertFrame         pcf;
    PCCertFrame         pcf2;
    PCCertFrame         pcf3;
    PCCertFrame         pcfLeaf = NULL;
    HCERTSTORE          rghcertstore[COtherProviders+30] = {NULL};


    Assert(!phReturnStateData); // How would I support this without the WinVerifyTrust call?
    //
    //   We may need to open some stores at this point.  Check to see if we do
    //  and open new stores as required.
    //

    //  Check for Root stores

    if (cRoots == 0) {
#ifndef WIN16
        hstoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                        hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                        L"Root");
#else
        hstoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                        hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                        "Root");
#endif // !WIN16
        if (hstoreRoot == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        cRoots = 1;
        rgRoots = &hstoreRoot;
    }

    //  Check for Trust stores

    if (cTrust == 0) {
#ifndef WIN16
        hstoreTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                    hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                    L"Trust");
#else
        hstoreTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                    hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                    "Trust");
#endif // !WIN16
        if (hstoreTrust == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        cTrust = 1;
        rgTrust = &hstoreTrust;
    }

    //  Check for Random CA stores

    for (i=0; i<cCAs; i++) {
        rghcertstore[i] = CertDuplicateStore(rgCAs[i]);
    }

    if ((cCAs == 0) || (dwControl & CM_ADD_CERT_STORES)) {
        for (i=0; i<COtherProviders; i++) {
            rghcertstore[cCAs] = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                     hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                     RgszProvider[i]);
            if (rghcertstore[cCAs] == NULL) {
                hr = E_FAIL;
                goto ExitHere;
            }
            cCAs += 1;
        }
    }

    rgCAs = rghcertstore;

    //
    //  Find the graph of issuer nodes
    //

    pcfLeaf = new CCertFrame(pccertToCheck);

    if(!pcfLeaf)
    {
        hr=E_OUTOFMEMORY;
        goto ExitHere;
    }

    //
    //  Process every certificate that we found in the ancestor graph
    //

    for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
        //
        //  Check the time validity on the certificate
        //

        i = CertVerifyTimeValidityWithDelta(NULL, pcf->m_pccert->pCertInfo, TIME_DELTA_SECONDS);
        if (((LONG)i) < 0) {
            pcf->m_dwFlags |= CERT_VALIDITY_BEFORE_START;
        }
        else if (i > 0) {
            pcf->m_dwFlags |= CERT_VALIDITY_AFTER_END;
        }

        //
        //  For Every Certificate Store we are going to search
        //

        for (i=0; i<cCAs+cRoots; i++) {
            pccert2 = NULL;
            do {
                //
                //  Ask the store to find the next cert for us to examine
                //

                dwFlags = (CERT_STORE_SIGNATURE_FLAG |
                           CERT_STORE_REVOCATION_FLAG);
                pccert = CertGetIssuerCertificateFromStore(
                                i < cRoots ? rgRoots[i] : rgCAs[i-cRoots],
                                pcf->m_pccert, pccert2,
                                &dwFlags);

                //
                //  If no cert is found, then we should move to the next store
                //

                if (pccert == NULL) {
                    //  Check to see if this cert was self-signed
                    if (GetLastError() == CRYPT_E_SELF_SIGNED) {
                        pcf->m_fSelfSign = TRUE;
                    }
                    break;
                }

                //
                //  Deterimine all of the failue modes for the certificate
                //      validity.
                //
                //  Start by looking for the ones that WinCrypt gives to
                //      us for free.
                //

                if (dwFlags != 0) {
                    if (dwFlags & CERT_STORE_SIGNATURE_FLAG) {
                        pcf->m_dwFlags |= CERT_VALIDITY_SIGNATURE_FAILS;
                    }
                    if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                        if (dwFlags & CERT_STORE_NO_CRL_FLAG) {
                            pcf->m_dwFlags |= CERT_VALIDITY_NO_CRL_FOUND;
                        }
                        else {
                            pcf->m_dwFlags |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                        }
                    }
                }

                //
                //  Setup to find the next possible parent, we may continue out
                //      of the loop at a later time
                //

                pccert2 = pccert;

                //
                //  Check to see this cert is already a found parent of the
                //      current node
                //

                for (iParent = 0; iParent < pcf->m_cParents; iParent++) {
                    if (CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                 pcf->m_rgpcfParents[iParent]->m_pccert->pCertInfo)){
                        break;
                    }
                }

                if (iParent != pcf->m_cParents) {
                    //  Duplicate found -- go to next possible parent
                    continue;
                }

                if (iParent == MaxCertificateParents) {
                    //  To many parents -- go to next possible parent
                    continue;
                }

                //
                //  Build a node to hold the cert we found and shove it onto the
                //      end of the list.  We want to eleminate work so combine
                //      the same nodes if found.
                //

                for (pcf3 = pcf2 = pcfLeaf; pcf2 != NULL;
                     pcf3 = pcf2, pcf2 = pcf2->m_pcfNext) {
                    if (CertCompareCertificate(X509_ASN_ENCODING,
                                               pccert->pCertInfo,
                                               pcf2->m_pccert->pCertInfo)) {
                        break;
                    }
                }
                if (pcf2 == NULL) {
                    pcf3->m_pcfNext = new CCertFrame(pccert);
                    if (pcf3->m_pcfNext == NULL) {
                        //  Out of memory during processing -- do the best one
                        //      can to deal with it.
                        continue;
                    }

                    //
                    //  Add in the parent to the structure
                    //

                    pcf->m_rgpcfParents[pcf->m_cParents++] = pcf3->m_pcfNext;
                    if (i < cRoots) {
                        pcf3->m_pcfNext->m_fRootStore = TRUE;
                    }
                }
            } while (pccert2 != NULL);
        }
    }

    //
    //  Nix off errors the caller wants us to ignore
    //

    for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
        pcf->m_dwFlags &= dwValidityMask;
    }

    //
    //   Need to check the complete set of validity on all certificates.
    //

    hr = HrCheckValidity(pcfLeaf);
    if (FAILED(hr)) {
        goto ExitHere;
    }

    //
    //  If there are validity problems with the root cert, and we are not
    //  asked to do a compelete check.  We are done and the operation was
    //  not successful.
    //

    if ((pcfLeaf->m_dwFlags != 0) && !(dwControl & CERT_TRUST_DO_FULL_SEARCH)) {
        hr = S_FALSE;
        *ppcf = pcfLeaf;
        pcfLeaf = NULL; // don't want it freed

        // BUGBUG: should we return at least the root in the chain var?
        *pcNodes = 0;
        goto ExitHere;
    }

    //
    //  Ok -- we have the graph of roots, now lets start looking for all of the
    //          different possible trust problems
    //

    if (cPurposes)
        {
        CTL_VERIFY_USAGE_PARA       vup;
        memset(&vup, 0, sizeof(vup));
        vup.cbSize = sizeof(vup);
        vup.cCtlStore = cTrust;
        vup.rghCtlStore = rgTrust;          // "TRUST"
        vup.cSignerStore = cRoots;
        vup.rghSignerStore = rgRoots;       // "Roots"

        CTL_VERIFY_USAGE_STATUS     vus;
        PCCTL_CONTEXT               pctlTrust;

        pctlTrust = NULL;

        memset(&vus, 0, sizeof(vus));
        vus.cbSize = sizeof(vus);
        vus.ppCtl = &pctlTrust;

        for (i=0; i<cPurposes; i++) {
            CTL_USAGE       ctlusage;
            BOOL            f;

            ctlusage.cUsageIdentifier = 1;
            ctlusage.rgpszUsageIdentifier = &rgszPurposes[i];

            for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
                if (pcf->m_rgTrust == NULL) {
                    pcf->m_rgTrust = new STrustDesc[cPurposes];
                    if (pcf->m_rgTrust == NULL) {
                        continue;
                    }
                    memset(pcf->m_rgTrust, 0, cPurposes * sizeof(STrustDesc));
                }

                if (pcf->m_fRootStore) {
                    continue;
                }

                f = CertVerifyCTLUsage(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                                       (LPVOID) pcf->m_pccert, &ctlusage,
                                       CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG |
                                       CERT_VERIFY_NO_TIME_CHECK_FLAG |
                                       CERT_VERIFY_TRUSTED_SIGNERS_FLAG, &vup, &vus);
                if (f) {
                    PCTL_ENTRY      pentry;
                    pentry = &pctlTrust->pCtlInfo->rgCTLEntry[vus.dwCtlEntryIndex];
                    pcf->m_rgTrust[i].szOid = _strdup(pentry->rgAttribute[0].pszObjId);
                    // Assert(pentry->rgAttribute[0].cAttr == 1);
                    pcf->m_rgTrust[i].cbTrustData =
                        pentry->rgAttribute[0].rgValue[0].cbData;
                    pcf->m_rgTrust[i].pbTrustData =
                        (LPBYTE) malloc(pcf->m_rgTrust[i].cbTrustData);
                    memcpy(pcf->m_rgTrust[i].pbTrustData,
                           pentry->rgAttribute[0].rgValue[0].pbData,
                           pentry->rgAttribute[0].rgValue[0].cbData);
                }
            }
        }

        //
        //  We have all of the data needed to make a trust decision.  See if we
        //  do trust
        //

        if (cPurposes == 1) {
            hr = HrCheckTrust(pcfLeaf, 0);
            if (FAILED(hr)) {
                goto ExitHere;
            }
            if ((hr == S_FALSE) && !(dwControl & CERT_TRUST_DO_FULL_SEARCH)) {
                *pcNodes = 0;
                pcfLeaf->m_dwFlags |= (CERT_VALIDITY_NO_TRUST_DATA & dwValidityMask);
                *ppcf = pcfLeaf;
                pcfLeaf = NULL;
                goto ExitHere;
            }
        }
        else {
            for (i=0; i<cPurposes; i++) {
                HrCheckTrust(pcfLeaf, i);
            }
        }
    }

    //
    //  Now let the user have his crack at the tree and build the final
    //  trust path at the same time.  If the user did not provide a check
    //  function then all certs are acceptable
    //

    hr = HrPerformUserCheck(pcfLeaf, TRUE, pcNodes, 0, rgpcfResult);
    if (FAILED(hr)) {
        goto ExitHere;
    }

    *ppcf = pcfLeaf;
    pcfLeaf = NULL;

    //
    //  We jump here on a failure and fall in on success.  Clean up the items we
    //  have created.
    //

ExitHere:
    if (hstoreRoot && rgRoots == &hstoreRoot) {
        CertCloseStore(hstoreRoot, 0);
    }

    if (hstoreTrust && rgTrust == &hstoreTrust) {
        CertCloseStore(hstoreTrust, 0);
    }

    if (rgCAs == rghcertstore) {
        for (i=0; i<cCAs; i++) {
            if (rgCAs[i] != NULL) {
                CertCloseStore(rgCAs[i], 0);
            }
        }
    }

    if (pcfLeaf != NULL) {
        delete pcfLeaf;
    }

    return hr;
}




////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//   TRUST PROVIDER INTERFACE
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

VOID ClientUnload(LPVOID /*pTrustProviderInfo*/)
{
    ;
}

VOID SubmitCertificate(LPWIN_CERTIFICATE /*pCert*/)
{
    ;
}

////    VerifyTrust
//
//  Description:
//      This is the core program in a trust system.
//

HRESULT WINAPI VerifyTrust(HWND /*hwnd*/, GUID * pguid, LPVOID pv)
{
    DWORD                       cFrames;
    HRESULT                     hr;
    DWORD                       i;
    PCCertFrame                 pcfLeaf = NULL;
    PCERT_VERIFY_CERTIFICATE_TRUST  pinfo = (PCERT_VERIFY_CERTIFICATE_TRUST) pv;
    DWORD *                     rgdwErrors = NULL;
    LPBYTE *                    rgpbTrust = NULL;
    PCCERT_CONTEXT *            rgpccert = NULL;
    PCCertFrame                 rgpcf[20];

    //
    //  Ensuer that we got called appropriately for our data
    //

    if (memcmp(pguid, &GuidCertValidate, sizeof(GuidCertValidate)) != 0) {
        return E_FAIL;
    }

    //
    //  Make sure we have some data to play with
    //

    if ((pinfo->cbSize != sizeof(*pinfo)) || (pinfo->pccert == NULL)) {
        return E_INVALIDARG;
    }

    //
    //  Call the core trust routine to do all of the intersting work
    //

    hr = HrDoTrustWork(pinfo->pccert, pinfo->dwFlags, ~(pinfo->dwIgnoreErr),
                       (pinfo->pszUsageOid != NULL ? 1 : 0),
                       &pinfo->pszUsageOid, pinfo->hprov,
                       pinfo->cRootStores, pinfo->rghstoreRoots,
                       pinfo->cStores, pinfo->rghstoreCAs,
                       pinfo->cTrustStores, pinfo->rghstoreTrust,
                       pinfo->pfnTrustHelper, pinfo->lCustData, &pcfLeaf,
                       &cFrames, rgpcf, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  We succeeded in getting some type of answer from the trust system, so
    //  format and return answers if any are requested.
    //

    if (pinfo->pdwErrors != NULL) {
        *pinfo->pdwErrors = pcfLeaf->m_dwFlags;
    }

    if (pinfo->pcChain != NULL) {
        *pinfo->pcChain = cFrames;
    }

    if (pinfo->prgChain != NULL) {
        rgpccert = (PCCERT_CONTEXT*) LocalAlloc(LMEM_FIXED,
                                                cFrames * sizeof(PCCERT_CONTEXT));
        if (rgpccert == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        for (i=0; i<cFrames; i++) {
            rgpccert[i] = CertDuplicateCertificateContext(rgpcf[i]->m_pccert);
        }
    }

    if (pinfo->prgdwErrors != NULL) {
        rgdwErrors = (DWORD *) LocalAlloc(LMEM_FIXED,
                                         (*pinfo->pcChain)*sizeof(DWORD));
        if (rgdwErrors == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        for (i=0; i<cFrames; i++) {
            rgdwErrors[i] = rgpcf[i]->m_dwFlags;
        }
    }

    if (pinfo->prgpbTrustInfo != NULL) {
        rgpbTrust = (LPBYTE *) LocalAlloc(LMEM_FIXED,
                                          (*pinfo->pcChain)*sizeof(LPBYTE));
        if (rgpbTrust == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpbTrust[0] = NULL;
    }

ExitHere:
    if (FAILED(hr)) {
#ifndef WIN16
        if (rgpccert != NULL) LocalFree(rgpccert);
        if (rgpbTrust != NULL) LocalFree(rgpbTrust);
        if (rgdwErrors != NULL) LocalFree(rgdwErrors);
#else
        if (rgpccert != NULL) LocalFree((HLOCAL)rgpccert);
        if (rgpbTrust != NULL) LocalFree((HLOCAL)rgpbTrust);
        if (rgdwErrors != NULL) LocalFree((HLOCAL)rgdwErrors);
#endif // !WIN16
    }
    else {
        if (rgpccert != NULL) *pinfo->prgChain = rgpccert;
        if (rgdwErrors != NULL) *pinfo->prgdwErrors = rgdwErrors;
        if (rgpbTrust != NULL) *pinfo->prgpbTrustInfo = (DATA_BLOB *) rgpbTrust;
    }

    delete pcfLeaf;

    return hr;
}

extern const GUID rgguidActions[];

#if !defined(WIN16) && !defined(MAC)
WINTRUST_PROVIDER_CLIENT_SERVICES WinTrustProviderClientServices = {
    ClientUnload, VerifyTrust, SubmitCertificate
};

const WINTRUST_PROVIDER_CLIENT_INFO ProvInfo = {
    WIN_TRUST_REVISION_1_0, &WinTrustProviderClientServices,
    1, (GUID *) &GuidCertValidate
};

////    WinTrustProviderClientInitialize
//
//  Description:
//      Client initialization routine.  Called by WinTrust when the dll
//      is loaded.
//
//  Parameters:
//      dwWinTrustRevision - Provides revision information
//      lpWinTrustInfo - Provides a list of services available to the
//                      trust provider from WinTrust
//      lpProvidername - Supplies a null terminated string representing the
//                      provider's name.  Shouldb passed back to WinTrust
//                      when required without modification.
//      lpTrustProviderInfo - Used to return trust provider information.
//
//  Returns:
//      TRUE on success and FALSE on failure.  Must set last error on failure.
//

BOOL WINAPI WinTrustProviderClientInitialize(DWORD /*dwWinTrustRevision*/,
                                LPWINTRUST_CLIENT_TP_INFO /*pWinTrustInfo*/,
                                LPWSTR /*lpProviderName*/,
                                LPWINTRUST_PROVIDER_CLIENT_INFO * ppTrustProvInfo)
{
    *ppTrustProvInfo = (LPWINTRUST_PROVIDER_CLIENT_INFO) &ProvInfo;
    return TRUE;
}
#endif // !WIN16 && !MAC
#endif // NT5BUILD

LPWSTR FormatValidityFailures(DWORD dwFlags)
{
    DWORD       cch = 0;
    LPWSTR      pwsz = NULL;
    WCHAR       rgwch[200];

    if (dwFlags == 0) {
        return NULL;
    }

    cch = 100;
    pwsz = (LPWSTR) malloc(cch*sizeof(WCHAR));
    if (pwsz == NULL) {
        return NULL;
    }
    if (dwFlags & CERT_VALIDITY_BEFORE_START) {
        LoadString(HinstDll, IDS_WHY_NOT_YET, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        StrCpyNW(pwsz, rgwch, cch);
    } else {
        StrCpyNW(pwsz, L"", cch);
    }

    if (dwFlags & CERT_VALIDITY_AFTER_END) {
        LoadString(HinstDll, IDS_WHY_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_SIGNATURE_FAILS) {
        LoadString(HinstDll, IDS_WHY_CERT_SIG, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
        LoadString(HinstDll, IDS_WHY_NO_PARENT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NO_CRL_FOUND) {
        LoadString(HinstDll, IDS_WHY_NO_CRL, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_CERTIFICATE_REVOKED) {
        LoadString(HinstDll, IDS_WHY_REVOKED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_CRL_OUT_OF_DATE) {
        LoadString(HinstDll, IDS_WHY_CRL_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_KEY_USAGE_EXT_FAILURE) {
        LoadString(HinstDll, IDS_WHY_KEY_USAGE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
        LoadString(HinstDll, IDS_WHY_EXTEND_USE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
        LoadString(HinstDll, IDS_WHY_NAME_CONST, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION) {
        LoadString(HinstDll, IDS_WHY_CRITICAL_EXT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwsz = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    return pwsz;
}

//////////////////////////////////////////////////////////////////////////////////


HRESULT CTLModifyHelper(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND /*hwnd*/,
                                      HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    DWORD               cb;
    DWORD               cbData;
    DWORD               cbOut;
    CTL_INFO            ctlInfo;
    CTL_USAGE           ctlUsage;
    DWORD               dwOne = 1;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr = S_OK;
    DWORD               i;
    int                 iCert;
    LPBYTE              pbEncode = NULL;
    LPBYTE              pbHash;
    PCCTL_CONTEXT       pcctl = NULL;
    PCRYPT_KEY_PROV_INFO pprovinfo = NULL;
    CTL_ENTRY *         rgctlEntry = NULL;

    //
    //  Build the attributes blob which says that we actually trust/distrust a certificate.
    //

    CRYPT_ATTRIBUTE         attributeYes;
    CRYPT_ATTR_BLOB         attrBlobYes;
    CRYPT_ATTRIBUTE         attributeNo;
    CRYPT_ATTR_BLOB         attrBlobNo;
    CRYPT_ATTRIBUTE         attributeParent;
    CRYPT_ATTR_BLOB         attrBlobParent;

    attributeYes.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeYes.cValue = 1;
    attributeYes.rgValue = &attrBlobYes;

    attrBlobYes.cbData = sizeof(RgbTrustYes);                // MUST BE ASN
    attrBlobYes.pbData = (LPBYTE) RgbTrustYes;

    attributeNo.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeNo.cValue = 1;
    attributeNo.rgValue = &attrBlobNo;

    attrBlobNo.cbData = sizeof(RgbTrustNo);                // MUST BE ASN
    attrBlobNo.pbData = (LPBYTE) RgbTrustNo;

    attributeParent.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeParent.cValue = 1;
    attributeParent.rgValue = &attrBlobParent;

    attrBlobParent.cbData = sizeof(RgbTrustParent);        // MUST BE ASN
    attrBlobParent.pbData = (LPBYTE) RgbTrustParent;

    //
    //  Get the crypt provider for the certificate we are going to use in the trust
    //

    if (!CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                           NULL, &cbData)) {
        hr = E_FAIL;
        goto Exit;
    }

    pprovinfo = (PCRYPT_KEY_PROV_INFO) malloc(cbData);
    CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                      pprovinfo, &cbData);

    if (!CryptAcquireContextW(&hprov, pprovinfo->pwszContainerName,
                              pprovinfo->pwszProvName,
                              pprovinfo->dwProvType, 0)) {
        hr = GetLastError();
        goto Exit;
    }

    //
    //  We have a certificate and a provider to use for signing purposes.
    //  Look for a possible CTL to be emended by us.
    //

    //
    //  Search for a CTL signed by this cert and for the requested usage
    //

    CTL_FIND_USAGE_PARA         ctlFind;
    ctlFind.cbSize = sizeof(ctlFind);
    ctlFind.SubjectUsage.cUsageIdentifier = 1;
    ctlFind.SubjectUsage.rgpszUsageIdentifier = (LPSTR *) &szPurpose;
    ctlFind.ListIdentifier.cbData = 0;
    ctlFind.ListIdentifier.pbData = 0;
    ctlFind.pSigner = pccertSigner->pCertInfo;

    pcctl = CertFindCTLInStore(hcertstorTrust, X509_ASN_ENCODING, 0,
                               CTL_FIND_USAGE, &ctlFind, NULL);
    if (pcctl == NULL) {
        //
        //  No CTL currently exists, so build one from scratch
        //

        //
        //  Allocate space to hold the CTL entries
        //
        //      size = (sizeof CTL_ENTRY + sizeof of SHA1 hash) * # certs to add
        //

        cb = cCertsToModify * (sizeof(CTL_ENTRY) + 20);
        rgctlEntry = (PCTL_ENTRY) malloc(cb);
        memset(rgctlEntry, 0, cb);
        pbHash = ((LPBYTE) rgctlEntry) + (cCertsToModify * sizeof(CTL_ENTRY));

        //
        //  Get the identifier for each of the certs and setup the Trust List
        //      entry for each of the certs.  Note that they all point
        //      to the same attribute, this is possible since we are going to
        //      have the exact same amount of trust on each cert -- YES!!!! --
        //

        for (iCert = 0; iCert < cCertsToModify; iCert++, pbHash += 20) {
            rgctlEntry[iCert].SubjectIdentifier.cbData = 20;
            rgctlEntry[iCert].SubjectIdentifier.pbData = pbHash;
            rgctlEntry[iCert].cAttribute = 1;

            cb = 20;
            CertGetCertificateContextProperty(rgCertMods[iCert].pccert,
                                              CERT_SHA1_HASH_PROP_ID, pbHash, &cb);
            rgCertMods[iCert].dwError = 0;

            switch (rgCertMods[iCert].dwOperation) {
            case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                rgctlEntry[iCert].rgAttribute = &attributeYes;
                break;

            case CTL_MODIFY_REQUEST_REMOVE:
                rgctlEntry[iCert].rgAttribute = &attributeParent;
                break;

            case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                rgctlEntry[iCert].rgAttribute = &attributeNo;
                break;

            default:
                rgCertMods[iCert].dwError = (DWORD) E_FAIL;
                iCert -= 1;             // Don't include this one
                break;
            }

        }

        //
        //  Now setup the the overall structure of the Trust List for later
        //      encoding and signing.
        //

        ctlUsage.cUsageIdentifier = 1;
        ctlUsage.rgpszUsageIdentifier = (LPSTR *) &szPurpose;

        memset(&ctlInfo, 0, sizeof(ctlInfo));
        ctlInfo.dwVersion = 0;
        ctlInfo.SubjectUsage = ctlUsage;
        // ctlInfo.ListIdentifier = 0;
        ctlInfo.SequenceNumber.cbData = sizeof(dwOne);
        ctlInfo.SequenceNumber.pbData = (LPBYTE) &dwOne;
        GetSystemTimeAsFileTime(&ctlInfo.ThisUpdate);
        // ctlInfo.NextUpdate = 0;
        ctlInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
        // ctlInfo.SubjectAlgorithm.Parameters.cbData = 0;
        ctlInfo.cCTLEntry = cCertsToModify;
        ctlInfo.rgCTLEntry = rgctlEntry;
        // ctlInfo.cExtension = 0;
        // ctlInfo.rgExtension = NULL;

    }
    else {
        BOOL    fRewrite;

        memcpy(&ctlInfo, pcctl->pCtlInfo, sizeof(ctlInfo));

        //
        //  We found a CTL with the right usage, now lets see if we need to add
        //      certificate to it.
        //
        //  Start by assuming that we will need to add to the CTL so allocate
        //      space to hold the new set of Trust Entries
        //

        cb = (pcctl->pCtlInfo->cCTLEntry * sizeof(CTL_ENTRY) +
              cCertsToModify * (sizeof(CTL_ENTRY) + 20));
        rgctlEntry = (PCTL_ENTRY) malloc(cb);
        memset(rgctlEntry, 0, cb);
        pbHash = (((LPBYTE) rgctlEntry) +
                  (cCertsToModify + pcctl->pCtlInfo->cCTLEntry) * sizeof(CTL_ENTRY));
        memcpy(rgctlEntry, pcctl->pCtlInfo->rgCTLEntry,
               pcctl->pCtlInfo->cCTLEntry * sizeof(CTL_ENTRY));
        ctlInfo.rgCTLEntry = rgctlEntry;

        //
        //  For each certificate, see if the certificate is already in the list
        //      and append it to the end if it isn't
        //

        fRewrite = FALSE;
        for (iCert = 0; iCert < cCertsToModify; iCert++) {
            rgCertMods[iCert].dwError = 0;

            cb = 20;
            CertGetCertificateContextProperty(rgCertMods[iCert].pccert,
                                              CERT_SHA1_HASH_PROP_ID, pbHash, &cb);

            for (i=0; i<pcctl->pCtlInfo->cCTLEntry; i++) {
                if (memcmp(pbHash, rgctlEntry[i].SubjectIdentifier.pbData, 20) == 0){
                    break;
                }
            }

            //
            //  If we did not find a matching item, then add a new one to the
            //  end of the list
            //
            if (i == pcctl->pCtlInfo->cCTLEntry) {
                rgctlEntry[i].SubjectIdentifier.cbData = 20;
                rgctlEntry[i].SubjectIdentifier.pbData = pbHash;
                rgctlEntry[i].cAttribute = 1;

                pbHash += 20;
                ctlInfo.cCTLEntry += 1;
                fRewrite = TRUE;


                switch (rgCertMods[iCert].dwOperation) {
                case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeYes;
                    break;

                case CTL_MODIFY_REQUEST_REMOVE:
                    rgctlEntry[i].rgAttribute = &attributeParent;
                    break;

                case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeNo;
                    break;

                default:
                    rgCertMods[i].dwError = (DWORD) E_FAIL;
                    ctlInfo.cCTLEntry -= 1;           // Don't include this one
                    break;
                }
            }
            //
            //  If we did find a matching, then put the new attribute into the
            //  list (may replace trust with distrust)
            //
            else {
                switch (rgCertMods[iCert].dwOperation) {
                case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeYes;
                    break;

                case CTL_MODIFY_REQUEST_REMOVE:
                    rgctlEntry[i].rgAttribute = &attributeParent;
                    break;

                default:
                case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeNo;
                    break;
                }
                fRewrite = TRUE;
            }
        }

        //
        //  Nothing to be added at this time -- exit and say success
        //

        if (!fRewrite) {
            hr = S_OK;
            goto Exit;
        }

        //
        //   Increment the sequence number
        //
        // M00MAC -- this may be cheating, however I think that we can use it
        //      one the mac without change, I don't really care that the sequence
        //      is understandable at this point, as long as it does sequence.
        //

        dwOne = 0;
        memcpy(&dwOne, ctlInfo.SequenceNumber.pbData,
               ctlInfo.SequenceNumber.cbData);
        dwOne += 1;

        ctlInfo.SequenceNumber.cbData = sizeof(dwOne);
        ctlInfo.SequenceNumber.pbData = (LPBYTE) &dwOne;
    }

    //
    //  OK --- We have the basic information built up for a Cert Trust List,
    //  now we just need to encode and sign the blasted thing
    //

    CMSG_SIGNER_ENCODE_INFO signer1;
    memset(&signer1, 0, sizeof(signer1));
    signer1.cbSize = sizeof(signer1);
    signer1.pCertInfo = pccertSigner->pCertInfo;
    signer1.hCryptProv = hprov;
    signer1.dwKeySpec = AT_SIGNATURE;
    signer1.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    // signer1.HashAlgorithm.Parameters.cbData = 0;
    // signer1.pvHashAuxInfo = 0;
    // signer1.cAuthAttrib = 0;
    // signer1.cUnauthAttr = 0;

    CMSG_SIGNED_ENCODE_INFO signinfo;
    memset(&signinfo, 0, sizeof(signinfo));
    signinfo.cbSize = sizeof(signinfo);
    signinfo.cSigners = 1;
    signinfo.rgSigners = &signer1;
    signinfo.cCertEncoded = 0;
    signinfo.cCrlEncoded = 0;

    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING, &ctlInfo, &signinfo,
                                  0, NULL, &cbOut)) {
        hr = GetLastError();
        goto Exit;
    }

    pbEncode = (LPBYTE) malloc(cbOut);
    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING, &ctlInfo, &signinfo,
                                  0, pbEncode, &cbOut)) {
        hr = GetLastError();
        goto Exit;
    }

    //
    // Now put it into the trust store
    //

    if (!CertAddEncodedCTLToStore(hcertstorTrust, PKCS_7_ASN_ENCODING,
                                  pbEncode, cbOut,
                                  CERT_STORE_ADD_REPLACE_EXISTING, NULL)) {
        //
        // If we fail, and we in debug mode then create an output file so
        //      we can figure out what we did wrong.
        //

#ifdef DEBUG
        HANDLE      hfile;

        hfile = CreateFileA("c:\\output.t", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            0, 0);
        WriteFile(hfile, pbEncode, cbOut, &cb, NULL);
        CloseHandle(hfile);
#endif // DEBUG

        hr = GetLastError();
        goto Exit;
    }

    //
    //  We succeeded in the operation
    //

    hr = S_OK;

    //
    //  A single point of clean up and exit for everything.
    //
Exit:
    if (rgctlEntry != NULL) free(rgctlEntry);
    if (pprovinfo != NULL) free(pprovinfo);
    if (pcctl != NULL) CertFreeCTLContext(pcctl);
    if (pbEncode != NULL) free(pbEncode);
    if (hprov != NULL) CryptReleaseContext(hprov, 0);

    if (SUCCEEDED(hr) && (hr != S_OK)) hr = E_FAIL;
    return hr;
}

PCCERT_CONTEXT CreateTrustSigningCert(HWND hwnd, HCERTSTORE hcertstoreRoot,
                                      BOOL fDialog)
{
    BYTE                bSerialNumber = 1;
    DWORD               cb;
    CERT_INFO           certInfo;
    DWORD               dw;
    HCRYPTKEY           hkey;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr = S_OK;
    CERT_NAME_BLOB      nameblob = {0, NULL};
    LPBYTE              pbEncode = NULL;
    PCCERT_CONTEXT      pccert = NULL;
    PCERT_PUBLIC_KEY_INFO pkeyinfo = NULL;
    CRYPT_KEY_PROV_INFO provinfo;
    LPSTR               psz;
    char                rgchTitle[256];
    char                rgchMsg[256];
    char                rgch[256];
    char                rgch1[256];
    char                rgch2[256];
    CERT_EXTENSION      rgExt[1] = {0};
    SYSTEMTIME          st;


    //
    //  We always use RSA base for this purpose.  We should never run
    //  across a system where rsabase does not exist.
    //
    //  We assume that we need to create a new keyset and fallback to
    //  openning the existing keyset in the event that it already exists
    //

    if (!CryptAcquireContextA(&hprov, SzTrustListSigner, NULL, PROV_RSA_FULL, 0)) {
        hr = GetLastError();
        if ((hr != NTE_NOT_FOUND) && (hr != NTE_BAD_KEYSET)) {
            goto ExitHere;
        }
        hr = S_OK;
        if (!CryptAcquireContextA(&hprov, SzTrustListSigner, NULL, PROV_RSA_FULL,
                                  CRYPT_NEWKEYSET)) {
            hr = GetLastError();
            goto ExitHere;
        }
    }

    //
    //  Now we need to create the signing key in the keyset.  Again
    //  we assume that we just created the keyset so we attempt to create
    //  the key in all cases.  Note we don't need to open the key in the
    //  event we fail to create it as we never directly use it.
    //
    //  Since we want security.  We first try for a 1024-bit key before
    //  using the default (usually 512-bit) size.
    //

    if (!CryptGetUserKey(hprov, AT_SIGNATURE, &hkey)) {
        dw = MAKELONG(0, 1024);
    retry_keygen:
        if (!CryptGenKey(hprov, AT_SIGNATURE, 0, &hkey)) {
#ifndef WIN16
            hr = ::GetLastError();
#else
            hr = GetLastError();
#endif // !WIN16
            if ((hr == ERROR_INVALID_PARAMETER) && (dw != 0)) {
                dw = 0;
                goto retry_keygen;
            }
            if (hr != NTE_EXISTS) {
                goto ExitHere;
            }
        }
    }
    CryptDestroyKey(hkey);

    //
    //  Now we need to create a certificate which corresponds to the
    //  signing key we just created.
    //
    //  Start by creating the DN to be stored in the certificate.  The
    //  DN we are going to use is of the following format.
    //
    //  cn=<machine name>/cn=Trust List Signer/cn=<user name>
    //
    //  We make the simplifying assumption that neither machine names
    //  or user names can contain commas.
    //

    dw = sizeof(rgch1);
    GetUserNameA(rgch1, &dw);
    dw = sizeof(rgch2);
    GetComputerNameA(rgch2, &dw);
    wnsprintf(rgch, ARRAYSIZE(rgch), SzTrustDN, rgch2, rgch1);

    if (!CertStrToNameA(X509_ASN_ENCODING, rgch,
                        CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, NULL,
                        NULL, &cb, NULL)) {
        hr = E_FAIL;
        goto ExitHere;
    }

    nameblob.pbData = (LPBYTE) malloc(cb);
    nameblob.cbData = cb;
    CertStrToNameA(X509_ASN_ENCODING, rgch,
                   CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, NULL,
                   nameblob.pbData, &nameblob.cbData, NULL);

    //
    //  Extract the public portion of the signing key and ASN encode it
    //

    if (!CryptExportPublicKeyInfo(hprov, AT_SIGNATURE, X509_ASN_ENCODING,
                                  NULL, &cb)) {
        goto ExitHere;
    }
    pkeyinfo = (PCERT_PUBLIC_KEY_INFO) malloc(cb);
    if (!CryptExportPublicKeyInfo(hprov, AT_SIGNATURE, X509_ASN_ENCODING,
                                  pkeyinfo, &cb)) {
        goto ExitHere;
    }

    //
    //  We are going to sign the certificate using SHA-1/RSA
    //

    CRYPT_ALGORITHM_IDENTIFIER      sigalg;
    memset(&sigalg, 0, sizeof(sigalg));
    sigalg.pszObjId = szOID_OIWSEC_sha1RSASign;
    // sigalg.Parameters.cbData = 0;
    // sigalg.Parameters.pbData = NULL;

    //
    //  We are putting one critical section on the extension. Enhanced
    //  key usage is CTL signing.  Note that this is the only use that
    //  we are going to allow for this key.
    //

    rgExt[0].pszObjId = szOID_ENHANCED_KEY_USAGE;
    rgExt[0].fCritical = TRUE;

    CTL_USAGE       ctlUsage2;
    ctlUsage2.cUsageIdentifier = 1;
    ctlUsage2.rgpszUsageIdentifier = &psz;
    psz = (LPSTR) SzOID_KP_CTL_USAGE_SIGNING;

    CryptEncodeObject(X509_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &ctlUsage2,
                      NULL, &cb);
    rgExt[0].Value.pbData = (LPBYTE) malloc(cb);
    rgExt[0].Value.cbData = cb;
    CryptEncodeObject(X509_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &ctlUsage2,
                      rgExt[0].Value.pbData, &rgExt[0].Value.cbData);


    //
    //  Now we can setup the rest of the certifiate information and
    //  encode it.
    //

    memset(&certInfo, 0, sizeof(certInfo));
    // certInfo.dwVersion = 0;
    certInfo.SerialNumber.cbData = 1;
    certInfo.SerialNumber.pbData = &bSerialNumber;
    certInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    // certInfo.SignatureAlgorithm.Parameter.cbData = 0;
    // certInfo.SignatureAlgorithm.Parameter.pbData = NULL;
    certInfo.Issuer = nameblob;
    GetSystemTimeAsFileTime(&certInfo.NotBefore);
    //    certInfo.NotAfter = certInfo.NotBefore;
    // M00BUG -- must increase the NotAfter date by some amount.
    FileTimeToSystemTime(&certInfo.NotBefore, &st);
    st.wYear += 50;
    SystemTimeToFileTime(&st, &certInfo.NotAfter);
    certInfo.Subject = nameblob;
    certInfo.SubjectPublicKeyInfo = *pkeyinfo;
    // certInfo.IssuerUniqueId = ;
    // certInfo.SubjectUniqueId = ;
    certInfo.cExtension = 1;
    certInfo.rgExtension = rgExt;

    if (!CryptSignAndEncodeCertificate(hprov, AT_SIGNATURE,
                                       X509_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED, &certInfo,
                                       &sigalg, NULL, NULL, &cb)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    pbEncode = (LPBYTE) malloc(cb);
    if (!CryptSignAndEncodeCertificate(hprov, AT_SIGNATURE,
                                       X509_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED, &certInfo,
                                       &sigalg, NULL, pbEncode, &cb)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    //
    //  M00TODO Print the GOD IS ABOUT TO STRIKE message
    //

    if (fDialog) {
        LoadStringA(HinstDll, IDS_ROOT_ADD_STRING, rgchMsg,
                    sizeof(rgchMsg)/sizeof(rgchMsg[0]));
        LoadStringA(HinstDll, IDS_ROOT_ADD_TITLE, rgchTitle,
                    sizeof(rgchTitle)/sizeof(rgchTitle[0]));
        MessageBoxA(hwnd, rgchMsg, rgchTitle, MB_APPLMODAL | MB_OK |
                    MB_ICONINFORMATION);
    }

    //
    //  Now we have warned the user, save our new cert in the root store
    //

    if (!CertAddEncodedCertificateToStore(hcertstoreRoot, X509_ASN_ENCODING,
                                          pbEncode, cb,
                                          CERT_STORE_ADD_REPLACE_EXISTING,
                                          &pccert)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    //
    //  Set the key-info property on the store so we can reference it later
    //

    memset(&provinfo, 0, sizeof(provinfo));
#ifndef WIN16
    provinfo.pwszContainerName = L"Trust List Signer";
#else
    provinfo.pwszContainerName = "Trust List Signer";
#endif // !WIN16
    // provinfo.pwszProvName = NULL;
    provinfo.dwProvType = PROV_RSA_FULL;
    // provinfo.dwFlags = 0;
    // provinfo.cProvParam = 0;
    provinfo.dwKeySpec = AT_SIGNATURE;

    CertSetCertificateContextProperty(pccert, CERT_KEY_PROV_INFO_PROP_ID,
                                      0, &provinfo);

ExitHere:
    if (hprov != NULL) CryptReleaseContext(hprov, 0);
    if (nameblob.pbData != NULL) free(nameblob.pbData);
    if (pkeyinfo != NULL) free(pkeyinfo);
    if (rgExt[0].Value.pbData != NULL) free(rgExt[0].Value.pbData);
    if (pbEncode != NULL) free(pbEncode);
    if (FAILED(hr) && (pccert != NULL)) {
        CertFreeCertificateContext(pccert);
        pccert = NULL;
    }
    return pccert;
}


////    CertModifyCertificatesToTrust
//
//  Description:
//      This routine is used to build the Certificate Trust List for
//      a purpose.  It is possible that we will need to create the root
//      signing key for this.
//

HRESULT CertModifyCertificatesToTrust(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND hwnd, HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    HCERTSTORE          hcertstorRoot = NULL;
    HRESULT     hr = E_FAIL;
    int         i;

    //
    // Some quick parameter checking
    //

    if (szPurpose == NULL) {
        return E_INVALIDARG;
    }

    //
    //  Add a reference to the cert store, so we can just release it on exit.
    //

    if (hcertstorTrust != NULL) {
        CertDuplicateStore(hcertstorTrust);
    }
    if (pccertSigner != NULL) {
        CertDuplicateCertificateContext(pccertSigner);
    }

    //
    //  Open a trust store if we don't have one yet.
    //

    if (hcertstorTrust == NULL) {
#ifndef WIN16
        hcertstorTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       L"Trust");
#else
        hcertstorTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       "Trust");
#endif // !WIN16
        if (hcertstorTrust == NULL) {
            hr = GetLastError();
            goto ExitHere;
        }
    }

    //
    //  Clear out errors and mark each item as not yet processed
    //

    for (i=0; i<cCertsToModify; i++) {
        rgCertMods[i].dwError = CTL_MODIFY_ERR_NOT_YET_PROCESSED;
    }

    //
    //  If we were given a specific cert to sign with, then call the helper routine with
    //  that specific certificate
    //

    if (pccertSigner != NULL) {
        hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd, hcertstorTrust,
                             pccertSigner);
    }
    else {
        DWORD           cbData;
        CTL_USAGE       ctlUsage;
        BOOL            fSomeCertFound;
        LPSTR           psz;

        //
        //  Walk through the list of certificates in the root store testing againist each
        //      valid cert for trust signing abilities and key material
        //

        //
        //  Open the root store, this is the only place we can store a signing
        //      cert that we can fully trust.  The gods have decreed that items
        //      in this store cannot be corrupted or modified without user
        //      consent.
        //      Note: the previous statement is propaganda and should not be taken
        //      as having any relationship to the truth.
        //

#ifndef WIN16
        hcertstorRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"Root");
#else
        hcertstorRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      "Root");
#endif // !WIN16
        if (hcertstorRoot == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        //
        //  To be accepted, the cert must have the ability to sign trust lists
        //  and have key material
        //

        ctlUsage.cUsageIdentifier = 1;
        ctlUsage.rgpszUsageIdentifier = &psz;
        psz = (LPSTR) SzOID_KP_CTL_USAGE_SIGNING;
        fSomeCertFound = FALSE;

        while (TRUE) {
            pccertSigner = CertFindCertificateInStore(hcertstorRoot, X509_ASN_ENCODING,
                                                0, CERT_FIND_CTL_USAGE, &ctlUsage,
                                                pccertSigner);
            if (pccertSigner == NULL) {
                //  No certs found
                break;
            }

            //
            //  The certificate must also have an associated set of key provider
            //  information, or we must reject it.

            if (CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                                  NULL, &cbData) && (cbData > 0)) {
                fSomeCertFound = TRUE;
                hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd,
                                     hcertstorTrust, pccertSigner);
            }
        }

        if (!fSomeCertFound) {
            pccertSigner = CreateTrustSigningCert(hwnd, hcertstorRoot, TRUE);
            if (pccertSigner != NULL) {
                hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd,
                                     hcertstorTrust, pccertSigner);
            }
            else {
                hr = E_FAIL;
                goto ExitHere;
            }
        }

    }

    //
    //  Check for errors returned
    //

    for (i=0; i<cCertsToModify; i++) {
        if (rgCertMods[i].dwError == CTL_MODIFY_ERR_NOT_YET_PROCESSED) {
            rgCertMods[i].dwError = (DWORD) E_FAIL;
        }
        if (FAILED(rgCertMods[i].dwError)) {
            hr = S_FALSE;
        }
    }

    ExitHere:
    //
    //  Release the items we have created
    //

    if (hcertstorTrust != NULL) CertCloseStore(hcertstorTrust, 0);
    if (pccertSigner != NULL) CertFreeCertificateContext(pccertSigner);
    if (hcertstorRoot != NULL) CertCloseStore(hcertstorRoot, 0);

    return hr;
}

BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose)
{
    HRESULT     hr;
    CTL_MODIFY_REQUEST  certmod;

    certmod.pccert = pccert;
    certmod.dwOperation = dwNewTrust;

    hr = CertModifyCertificatesToTrust(1, &certmod, szPurpose, hwnd, NULL, NULL);
    return (hr == S_OK) && (certmod.dwError == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\util.cpp ===
#include        "pch.hxx"
#include        "demand.h"
#include        <string.h>
#include        <shellapi.h>
#include        <commctrl.h>
#include        <limits.h>

//WIn64 macros
#ifdef _WIN64
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#else //!WIN64
#define LcbAlignLcb(lcb)	(lcb)
#define PbAlignPb(pb)		(pb)
#define MyPbAlignPb(pb)		(pb)
#endif 

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

#define szOID_MICROSOFT_Encryption_Key_Preference "1.3.6.1.4.1.311.16.4"
typedef struct {
    DWORD               unused;
    CERT_NAME_BLOB      Issuer;
    CRYPT_INTEGER_BLOB  SerialNumber;
} CRYPT_RECIPIENT_ID, * PCRYPT_RECIPIENT_ID;

#if 0
//  From mssip.h

//  SPC_LINK_STRUCT
//  pvStructInfo points to SPC_LINK.
//
typedef BYTE SPC_UUID[16];
typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID    ClassId;
    CRYPT_DATA_BLOB   SerializedData;
} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;


typedef struct _SPC_LINK
{
    DWORD dwLinkChoice;
    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };
} SPC_LINK, *PSPC_LINK;

#define SPC_URL_LINK_CHOICE         1
#define SPC_MONIKER_LINK_CHOICE     2
#define SPC_FILE_LINK_CHOICE        3
#endif
#ifndef WIN16
#include        "wintrust.h"
#endif // !WIN16
#ifdef MAC
#include        <stdio.h>

EXTERN_C INT CALLBACK CreateDate(LPSYSTEMTIME lpst, CHAR * szOutStr, BOOL fNoYear);
EXTERN_C INT CreateTime(LPSYSTEMTIME lpst, CHAR *szOutStr, BOOL fNoSeconds);
HRESULT TdxFormatMessageVa (IN LPCSTR rgchFormat, OUT CHAR * rgchBuffer, OUT ULONG * pucReqSize, va_list marker);

#endif  // MAC

extern HINSTANCE        HinstDll;

/////////////////////////////////////////////////////////

#ifndef MAC
BOOL IsWin95()
{
    BOOL        f;
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);
    f = GetVersionExA(&ver);
    return !f || (ver.dwPlatformId == 1);
}
#endif  // !MAC

#ifndef WIN16
LRESULT MySendDlgItemMessageW(HWND hwnd, int id, UINT msg, WPARAM w, LPARAM l)
{
    char                rgch[4096];
    LPTV_INSERTSTRUCTW   ptvinsW;
    TV_INSERTSTRUCTA     tvins;

    if (msg == LB_ADDSTRING) {
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR) l, -1, rgch, sizeof(rgch),
                            NULL, NULL);
        l = (LPARAM) rgch;
    }
    else if (msg == TVM_INSERTITEMW) {
        msg = TVM_INSERTITEMA;
        ptvinsW = (LPTV_INSERTSTRUCTW) l;
        memcpy(&tvins, ptvinsW, sizeof(tvins));
        WideCharToMultiByte(CP_ACP, 0, ptvinsW->item.pszText, -1, rgch,
                            sizeof(rgch), NULL, NULL);
        tvins.item.pszText = rgch;
        l = (LPARAM) &tvins;
    }

    return SendDlgItemMessageA(hwnd, id, msg, w, l);
}

BOOL MySetDlgItemTextW(HWND hwnd, int id, LPCWSTR pwsz)
{
    char        rgch[4096];

    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, rgch, sizeof(rgch), NULL, NULL);
    return SetDlgItemTextA(hwnd, id, rgch);
}

UINT MyGetDlgItemTextW(HWND hwnd, int id, LPWSTR pwsz, int nMax)
{
    UINT        cch;
    char        rgch[4096];
    cch = GetDlgItemTextA(hwnd, id, rgch, ARRAYSIZE(rgch)-1);
    rgch[cch+1] = 0;

    cch = MultiByteToWideChar(CP_ACP, 0, rgch, cch+1, pwsz, nMax);

    return cch;
}

DWORD MyFormatMessageW(DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
                    DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize,
                    va_list * args)
{
    DWORD       cch;
    int         i;
    LPSTR       pchDest;
    DWORD_PTR * pdw;
    LPWSTR      pwchOut;
    char        rgchSource[128];
    DWORD_PTR   rgdwArgs[10];
    int         cArgs = 10;
#ifdef MAC
    HRESULT     hr;
#endif  // MAC

    if (!(dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY)) {
#ifdef DEBUG
        DebugBreak();
#endif // DEBUG
        return 0;
    }

    //
    //  We need to figure out how many arguments are in the array.
    //  All Arrays are to be terminated by -1 in order for this to work.
    //

    pdw = (DWORD_PTR *) args;
    for (i=0; i<cArgs; i++) {
        if (pdw[i] == 0xffffffff) {
            cArgs = i-1;
            break;
        }
        if (pdw[i] <= 0xffff) {
            rgdwArgs[i] = pdw[i];
        }
        else {
            cch = wcslen((LPWSTR) pdw[i]);
            rgdwArgs[i] = (DWORD_PTR) malloc((cch+1));
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR) pdw[i], -1,
                                (LPSTR) rgdwArgs[i], cch+1, NULL, NULL);
        }
    }

    if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR) pbSource, -1,
                            rgchSource, sizeof(rgchSource), NULL, NULL);
        pbSource = rgchSource;
    }
#ifdef MAC
    dwLangId;       // Unused
    dwMessageId;    // Unused

    hr = TdxFormatMessageVa ((LPCSTR) pbSource, NULL, &cch, (va_list) rgdwArgs);
    if (FAILED(hr))
    {
        return 0;
    }

    pchDest = (LPSTR) LocalAlloc(LMEM_FIXED, cch + 1);
    if (NULL == pchDest)
    {
        return 0;
    }

    hr = TdxFormatMessageVa ((LPCSTR) pbSource, pchDest, &cch, (va_list) rgdwArgs);
    if (FAILED(hr))
    {
        LocalFree(pchDest);
        return 0;
    }
#else   // !MAC
    cch = FormatMessageA(dwFlags | FORMAT_MESSAGE_ALLOCATE_BUFFER, pbSource,
                         dwMessageId, dwLangId, (LPSTR) &pchDest, 0,
                         (va_list *) rgdwArgs);
#endif  // MAC

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, NULL, 0);
        pwchOut = (LPWSTR) LocalAlloc(LMEM_FIXED, (cch+1)*sizeof(WCHAR));
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, pwchOut, cch);
        *((LPWSTR *) lpBuffer) = pwchOut;
    }
    else {
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, lpBuffer, nSize);
    }

    for (i=0; i<cArgs; i++) {
        if (rgdwArgs[i] > 0xffff) {
            free((LPVOID) rgdwArgs[i]);
        }
    }
    LocalFree(pchDest);

    return cch;
}

int MyLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cbBuffer)
{
    DWORD       cch;
    char        rgch[256];

#ifndef MAC
    if (!FIsWin95) {
        return LoadStringW(hInstance, uID, lpBuffer, cbBuffer);
    }
#endif  // !MAC

    cch = LoadStringA(hInstance, uID, rgch, sizeof(rgch));
    cch = MultiByteToWideChar(CP_ACP, 0, rgch, -1, lpBuffer, cbBuffer);
    return cch;
}

#endif // !WIN16

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL) {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, ARRAYSIZE(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
    }
    if (pszProvider != NULL) {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, ARRAYSIZE(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
    }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer, (LPCSTR) pszProvider,
                                dwProvType, dwFlags);
}

BOOL MyWinHelpW(HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData)
{
    char        rgch[4096];

    WideCharToMultiByte(CP_ACP, 0, szHelp, -1, rgch, ARRAYSIZE(rgch), NULL, NULL);
    return WinHelpA(hWndMain, rgch, uCommand, dwData);
}

////////////////////////////////////////////////////////////////

DWORD TruncateToWindowA(HWND hwndDlg, int id, LPSTR psz)
{
    int         cch = strlen(psz);
    int         cchMax;
    int         cchMid;
    int         cchMin;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    HWND        hwnd;
    SIZE        siz;
    SIZE        sizDots;
    RECT        rt;
    TEXTMETRICA tmA;

    hwnd = GetDlgItem(hwndDlg, id);
    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    if (NULL == hfontNew) {
        goto Error;
    }

    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetricsA(hdc, &tmA);
    GetWindowRect(hwnd, &rt);
    rt.right -= rt.left;
    GetTextExtentPointA(hdc, psz, cch, &siz);
    if (rt.right < siz.cx) {

        GetTextExtentPointA(hdc, "...", 3, &sizDots);
        rt.right -= sizDots.cx;

        for (cchMin=0, cchMax=cch, cchMid = (cchMin + cchMax + 1)/2;
             cchMin < cchMax;
             cchMid = (cchMin + cchMax + 1)/2) {
            GetTextExtentPointA(hdc, psz, cchMid, &siz);
            if (rt.right == siz.cx) {
                break;
            }
            else if (rt.right > siz.cx) {
                cchMin = cchMid;
            }
            else {
                cchMax = cchMid-1;
            }
        }

        // Make certain that we don't overflow the buffer.
        if (cchMin + 3 > cch) {     // 3 = number of characters in "...".
            cchMin = cch - 3;
        }
        StrCpyNA(&psz[cchMin], "...", cch+1-cchMin);
    }

    SelectObject(hdc, hfontOld);

Error:
    ReleaseDC(hwnd, hdc);

    return TRUE;
}

DWORD TruncateToWindowW(HWND hwndDlg, int id, WCHAR * pwsz)
{
    if (FIsWin95) {
        DWORD   cch;
        char    rgch[4096];

        cch = wcslen(pwsz)+1;
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, rgch, sizeof(rgch), NULL, NULL);
        TruncateToWindowA(hwndDlg, id, rgch);
        MultiByteToWideChar(CP_ACP, 0, rgch, -1, pwsz, cch);
        return TRUE;
    }
#ifndef WIN16
#ifndef MAC
    int         cch = wcslen(pwsz);
    int         cchMax;
    int         cchMid;
    int         cchMin;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    HWND        hwnd;
    SIZE        siz;
    SIZE        sizDots;
    RECT        rt;
    TEXTMETRICW tmW;

    hwnd = GetDlgItem(hwndDlg, id);
    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetricsW(hdc, &tmW);
    GetWindowRect(hwnd, &rt);
    rt.right -= rt.left;
    GetTextExtentPointW(hdc, pwsz, cch, &siz);
    if (rt.right < siz.cx) {

        GetTextExtentPointW(hdc, L"...", 3, &sizDots);
        rt.right -= sizDots.cx;

        for (cchMin=0, cchMax=cch, cchMid = (cchMin + cchMax + 1)/2;
             cchMin < cchMax;
             cchMid = (cchMin + cchMax + 1)/2) {
            GetTextExtentPointW(hdc, pwsz, cchMid, &siz);
            if (rt.right == siz.cx) {
                break;
            }
            else if (rt.right > siz.cx) {
                cchMin = cchMid;
            }
            else {
                cchMax = cchMid-1;
            }
        }

        // Make certain that we don't overflow the buffer.
        if (cchMin + 3 > cch) {     // 3 = number of characters in L"...".
            cchMin = cch - 3;
        }
        StrCpyNW(&pwsz[cchMin], L"...", cch+1-cchMin);
    }

    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);
#endif  // !MAC
#endif // !WIN16

    return TRUE;
}

////////////////////////////////////////////////////////////////////



#if 0
//  From authcode.h

//+-------------------------------------------------------------------------
//  SPC_SP_AGENCY_INFO_STRUCT
//  pvStructInfo points to SPC_SP_AGENCY_INFO.
//
typedef struct _SPC_IMAGE {
    PSPC_LINK             pImageLink;
    CRYPT_DATA_BLOB       Bitmap;
    CRYPT_DATA_BLOB       Metafile;
    CRYPT_DATA_BLOB       EnhancedMetafile;
    CRYPT_DATA_BLOB       GifFile;
} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO {
    PSPC_LINK       pPolicyInformation;
    LPWSTR          pwszPolicyDisplayText;
    PSPC_IMAGE      pLogoImage;
    PSPC_LINK       pLogoLink;
} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;
#endif // 0

///////////////////////////////////////////////////////

BOOL LoadStringInWindow(HWND hwnd, UINT idCtrl, HMODULE hmod, UINT idString)
{
    WCHAR       rgwch[1024];

    if (FIsWin95) {
        LoadStringA(hmod, idString, (LPSTR) rgwch, sizeof(rgwch));

        SetDlgItemTextA(hwnd, idCtrl, (LPSTR)rgwch);
    }
#ifndef WIN16
#ifndef MAC
    else {
        LoadStringW(hmod, idString, rgwch, sizeof(rgwch)/sizeof(rgwch[0]));

        SetDlgItemText(hwnd, idCtrl, rgwch);
    }
#endif  // !MAC
#endif  // !WIN16

    return TRUE;
}

BOOL LoadStringsInWindow(HWND hwnd, UINT idCtrl, HMODULE hmod, UINT *pidStrings)
{
    BOOL    fRet = FALSE;

    if (FIsWin95) {
        UINT        cchOut;
        UINT        cbOut;
        CHAR *      pszOut;

        cbOut = 1024 * sizeof(CHAR);
        pszOut = (CHAR *) malloc(cbOut);
        if (NULL == pszOut) {
            goto ret;
        }

        for (*pszOut = '\0', cchOut = 1; *pidStrings != UINT_MAX; pidStrings++) {
            UINT        cchBuff;
            CHAR        rgchBuff[1024];

            cchBuff = LoadStringA(hmod, *pidStrings, rgchBuff, sizeof(rgchBuff));
            if (0 == cchBuff) {
                goto ErrorA;
            }

            cchOut += cchBuff;

            if (cchOut > (cbOut / sizeof(CHAR))) {
                CHAR *      pszNew;

                cbOut *= 2;

                pszNew = (CHAR *) realloc(pszOut, cbOut);
                if (NULL == pszNew) {
                    goto ErrorA;
                }

                pszOut = pszNew;
            }

            StrCatBuffA(pszOut, rgchBuff, cbOut/sizeof(CHAR));
        }

        SetDlgItemTextA(hwnd, idCtrl, pszOut);
        fRet = TRUE;
ErrorA:
        free(pszOut);
    }
#if !defined( MAC ) && !defined( WIN16 )
    else {
        UINT        cwchOut;
        UINT        cbOut;
        WCHAR *     pwszOut;

        cbOut = 1024 * sizeof(WCHAR);
        pwszOut = (WCHAR *) malloc(cbOut);
        if (NULL == pwszOut) {
            goto ret;
        }

        for (*pwszOut = L'\0', cwchOut = 1; *pidStrings != UINT_MAX; pidStrings++) {
            UINT        cwchBuff;
            WCHAR       rgwchBuff[1024];

            cwchBuff = LoadStringW(hmod, *pidStrings, rgwchBuff, sizeof(rgwchBuff) / sizeof(WCHAR));
            if (0 == cwchBuff) {
                goto ErrorW;
            }

            cwchOut += cwchBuff;

            if (cwchOut > (cbOut / sizeof(WCHAR))) {
                WCHAR *      pwszNew;

                cbOut *= 2;

                pwszNew = (WCHAR *) realloc(pwszOut, cbOut);
                if (NULL == pwszNew) {
                    goto ErrorW;
                }

                pwszOut = pwszNew;
            }

            StrCatBuffW(pwszOut, rgwchBuff,cbOut/sizeof(WCHAR));
        }

        SetDlgItemTextW(hwnd, idCtrl, pwszOut);
        fRet = TRUE;
ErrorW:
        free(pwszOut);
    }
#endif  // !MAC && !WIN16
ret:
    return fRet;
}
///////////////////////////////////////////////////////

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const CHAR      RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                             '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};


#if 0
LPWSTR FindURL(PCCERT_CONTEXT pccert)
{
    DWORD                       cbInfo;
    PCERT_EXTENSION             pExt;
    PSPC_SP_AGENCY_INFO         pInfo;
    LPWSTR                      pwsz;


    pExt = CertFindExtension("1.3.6.1.4.311.2.1.10", pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension);
    if (pExt == NULL) {
        return NULL;
    }

    CryptDecodeObject(X509_ASN_ENCODING, (LPCSTR) 2000, pExt->Value.pbData, pExt->Value.cbData, 0, NULL, &cbInfo);
    if (cbInfo == 0) {
        return NULL;
    }
    pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo);
    if (!CryptDecodeObject(X509_ASN_ENCODING,  (LPCSTR) 2000, pExt->Value.pbData, pExt->Value.cbData, 0, pInfo, &cbInfo)) {
        free (pInfo);
        return NULL;
    }

    if (pInfo->pPolicyInformation->dwLinkChoice != SPC_URL_LINK_CHOICE) {
        free (pInfo);
        return NULL;
    }

#ifndef WIN16
    pwsz = _wcsdup(pInfo->pPolicyInformation->pwszUrl);
#else
    pwsz = _strdup(pInfo->pPolicyInformation->pwszUrl);
#endif // !WIN16
    free (pInfo);
    return pwsz;
}
#endif // 0


BOOL FormatAlgorithm(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    int       cch;
    LPWSTR    pszMsg;
    LPSTR     psz = pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    LPWSTR    pwsz;
    DWORD_PTR rgdw[3];
#ifdef MAC
    CHAR      rgch[17];
#endif  // MAC
    WCHAR     rgwch[17];
    rgdw[2] = (DWORD) -1;               // Sentinal Value

    rgdw[1] = pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData * 8;

    if (strcmp(psz, szOID_RSA_RSA) == 0) {
        rgdw[0] = (DWORD_PTR) L"RSA";
        rgdw[1] &= 0xffffff80;          // M00BUG

#ifdef MAC
        wnsprintf(rgch, ARRAYSIZE(rgch), "%d", rgdw[1]);

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, rgwch, sizeof(rgwch) / sizeof(rgwch[0]));
#else   // !MAC
#ifndef WIN16
        _ltow((LONG) rgdw[1], rgwch, 10);
#else
        _ltoa(rgdw[1], rgwch, 10);
#endif // !WIN16
#endif  // MAC
        rgdw[1] = (DWORD_PTR) rgwch;
    }
    else {
        cch = strlen(psz)+1;
        pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
        if (pwsz == NULL) {
            return FALSE;
        }

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, cch, pwsz, cch+1);
        SetDlgItemText(hwnd, id, pwsz);
        free(pwsz);
        return TRUE;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  L"%1 (%2 bits)", 0, 0, (LPWSTR) &pszMsg, 0, (va_list *) rgdw);

    SetDlgItemText(hwnd, id, pszMsg);
#ifndef WIN16
    LocalFree((LPVOID) pszMsg);
#else
    LocalFree((HLOCAL) pszMsg);
#endif // !WIN16
    return TRUE;
}

BOOL FormatBinary(HWND hwnd, UINT id, LPBYTE pb, DWORD cb)
{
    DWORD                 i;
    LPWSTR                pwch;

    pwch = (LPWSTR) malloc( (cb*2+1)*sizeof(WCHAR));
    if (pwch == NULL) {
        return FALSE;
    }

    for (i=0; i < cb; i++, pb++) {
        pwch[i*2] = RgwchHex[(*pb & 0xf0) >> 4];
        pwch[i*2+1] = RgwchHex[*pb & 0x0f];
    }
    pwch[i*2] = 0;

    SetDlgItemText(hwnd, id, pwch);
    free(pwch);
    return TRUE;
}

////    FormatCPS
//
//  Description:
//      Look for a Certificate Policy Statment in the certificate.
//      We recognize as CPSs the following items:
//      1.  What ever PKIX comes up with
//      2.  The magic Verisign one
//

BOOL FormatCPS(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD               cb;
    BOOL                f;
    PCERT_EXTENSION     pExt;
    LPWSTR              pwsz;

    pExt = CertFindExtension("2.5.29.32", pccert->pCertInfo->cExtension,
                             pccert->pCertInfo->rgExtension);
    if (pExt != NULL) {
        cb = 0;
        f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL, pExt->pszObjId,
                              pExt->Value.pbData, pExt->Value.cbData, 0, &cb);
        if (f && (cb > 0)) {
            pwsz = (LPWSTR) malloc(cb * sizeof(WCHAR));
            CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL, pExt->pszObjId,
                              pExt->Value.pbData, pExt->Value.cbData,
                              pwsz, &cb);
            SetDlgItemText(hwnd, id, pwsz);

            free(pwsz);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL FormatDate(HWND hwnd, UINT id, FILETIME ft)
{
    int                 cch;
    int                 cch2;
    LPWSTR              pwsz;
    SYSTEMTIME          st;
#ifdef MAC
    CHAR                rgch[256];
#else   // !MAC
    LPSTR               psz;
#endif  // MAC

    if (!FileTimeToSystemTime(&ft, &st)) {
        return FALSE;
    }

#ifdef MAC
    cch = CreateDate(&st, rgch, FALSE);
    pwsz = (LPWSTR) malloc((cch + 2)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }
    cch2 = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, pwsz, cch + 2);
    if (0 == cch2)
    {
        free(pwsz);
        return FALSE;
    }
    pwsz[cch2++] = L' ';

    cch = CreateTime(&st, rgch, FALSE);
    pwsz = (LPWSTR) realloc(pwsz, (cch + cch2 + 1)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }
    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, pwsz + cch2, cch + 1);
    if (0 == cch)
    {
        free(pwsz);
        return FALSE;
    }
    SetDlgItemText(hwnd, id, pwsz);

#else   // !MAC
    if (FIsWin95) {
        cch = (GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
               GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) + 5);

        psz = (LPSTR) malloc(cch+5);
        if (psz == NULL) {
            return FALSE;
        }

        cch2 = GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, psz, cch);
        cch2 -= 1;
        psz[cch2++] = ' ';

        GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL,
                       &psz[cch2], cch-cch2);
        SetDlgItemTextA(hwnd, id, psz);
        free(psz);
        return TRUE;
    }

    cch = (GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) + 5);

    pwsz = (LPWSTR) malloc((cch+5)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }

    cch2 = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, pwsz, cch);
    cch2 -= 1;
    pwsz[cch2++] = ' ';

    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, &pwsz[cch2], cch-cch2);

#ifndef WIN16
    SetDlgItemTextW(hwnd, id, pwsz);
#else
    SetDlgItemText(hwnd, id, pwsz);
#endif // !WIN16
#endif  // MAC


    free(pwsz);
    return TRUE;
}

BOOL FormatIssuer(HWND hwnd, UINT id, PCCERT_CONTEXT pccert, DWORD dwFlags)
{
    DWORD       cch;
    LPWSTR      psz;

    cch = CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                         dwFlags | CERT_NAME_STR_CRLF_FLAG,
                         NULL, 0);
    psz = (LPWSTR) malloc(cch*sizeof(TCHAR));
    CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                   dwFlags | CERT_NAME_STR_CRLF_FLAG,
                   psz, cch);
    SetDlgItemText(hwnd, id, psz);
    free(psz);
    return TRUE;
}

BOOL FormatSerialNo(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD                 i;
    CRYPT_INTEGER_BLOB *  pblob;
    LPBYTE                pb;
    WCHAR                 rgwch[128];

    pblob = &pccert->pCertInfo->SerialNumber;
    for (i=0, pb = &pblob->pbData[pblob->cbData-1];
         i < pblob->cbData; i++, pb--) {
        rgwch[i*2] = RgwchHex[(*pb & 0xf0) >> 4];
        rgwch[i*2+1] = RgwchHex[*pb & 0x0f];
    }
    rgwch[i*2] = 0;

    TruncateToWindowW(hwnd, id, rgwch);
    SetDlgItemText(hwnd, id, rgwch);
    return TRUE;
}

BOOL FormatSubject(HWND hwnd, UINT id, PCCERT_CONTEXT pccert, DWORD dwFlags)
{
    DWORD       cch;
    LPWSTR      psz;

    cch = CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                         dwFlags | CERT_NAME_STR_CRLF_FLAG,
                         NULL, 0);
    psz = (LPWSTR) malloc(cch*sizeof(WCHAR));
    CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                   dwFlags | CERT_NAME_STR_CRLF_FLAG,
                   psz, cch);
    SetDlgItemText(hwnd, id, psz);
    free(psz);
    return TRUE;
}

BOOL FormatThumbprint(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD       cb;
    DWORD       i;
    BYTE        rgb[20];
    WCHAR       rgwch[61];
    WCHAR *     pwch;

    cb = sizeof(rgb);
    if (!CertGetCertificateContextProperty(pccert, CERT_MD5_HASH_PROP_ID,
                                           rgb, &cb)) {
        return FALSE;
    }

    for (i=0, pwch = rgwch; i<cb; i++, pwch += 2) {
        pwch[0] = RgwchHex[(rgb[i] & 0xf0) >> 4];
        pwch[1] = RgwchHex[rgb[i] & 0x0f];
        if (((i % 4) == 3) && (i != cb-1)) {
            pwch[2] = ':';
            pwch++;
        }
    }
    *pwch = 0;

    TruncateToWindowW(hwnd, id, rgwch);
    SetDlgItemText(hwnd, id, rgwch);
    return TRUE;
}

BOOL FormatValidity(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD_PTR           rgdw[3];
    WCHAR               rgwchFormat[128];
    WCHAR               rgwchNotAfter[128];
    WCHAR               rgwchNotBefore[128];
    WCHAR               rgwchValidity[256];
    SYSTEMTIME          stNotAfter;
    SYSTEMTIME          stNotBefore;
    rgdw[2] = (DWORD) -1;               // Sentinal Value

    FileTimeToSystemTime(&pccert->pCertInfo->NotBefore, &stNotBefore);
    FileTimeToSystemTime(&pccert->pCertInfo->NotAfter, &stNotAfter);

    if (FIsWin95) {
        LoadStringA(HinstDll, IDS_VALIDITY_FORMAT,
                    (LPSTR) rgwchFormat, sizeof(rgwchFormat));
#ifdef MAC
        CreateDate(&stNotBefore, (LPSTR) rgwchNotBefore, FALSE);
        CreateDate(&stNotAfter, (LPSTR) rgwchNotAfter, FALSE);


        _snprintf((LPSTR) rgwchValidity, sizeof(rgwchNotAfter),
                  (LPSTR) rgwchFormat, rgwchNotBefore, rgwchNotAfter);
#else   // !MAC
        GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotBefore,
                      NULL, (LPSTR) rgwchNotBefore, sizeof(rgwchNotBefore));
        GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotAfter,
                      NULL, (LPSTR) rgwchNotAfter, sizeof(rgwchNotAfter));

        rgdw[0] = (DWORD_PTR) rgwchNotBefore;
        rgdw[1] = (DWORD_PTR) rgwchNotAfter;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       rgwchFormat, 0,  0,
                       (LPSTR) rgwchValidity, sizeof(rgwchValidity),
                       (va_list *) rgdw);
#endif  // MAC

        SetDlgItemTextA(hwnd, id, (LPSTR) rgwchValidity);
        return TRUE;
    }
#ifndef MAC
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotBefore,
                  NULL, rgwchNotBefore, sizeof(rgwchNotBefore)/sizeof(WCHAR));
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotAfter,
                  NULL, rgwchNotAfter, sizeof(rgwchNotAfter)/sizeof(WCHAR));
    LoadString(HinstDll, IDS_VALIDITY_FORMAT, rgwchFormat,
               sizeof(rgwchFormat)/sizeof(WCHAR));

    rgdw[0] = (DWORD_PTR) rgwchNotBefore;
    rgdw[1] = (DWORD_PTR) rgwchNotAfter;

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  rgwchFormat, 0,  0,
                  rgwchValidity, sizeof(rgwchValidity)/sizeof(WCHAR),
                  (va_list *) rgdw);

    SetDlgItemText(hwnd, id, rgwchValidity);
#endif  // !MAC
    return TRUE;
}


////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//  Find the szOID_COMMON_NAME extension.
//
//  If found, allocates and converts to a WCHAR string
//
//  Returned WCHAR string needs to be CoTaskMemFree'ed.
//--------------------------------------------------------------------------
static LPWSTR GetCommonNameExtension(
    IN PCCERT_CONTEXT pCert
    )
{
    LPWSTR pwsz = NULL;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_NAME_VALUE pNameValue = NULL;
    PCERT_EXTENSION pExt;

    pExt = CertFindExtension(
        szOID_COMMON_NAME,
        pCertInfo->cExtension,
        pCertInfo->rgExtension
        );
    if (pExt) {
        DWORD cbInfo = 0;
        PCERT_RDN_VALUE_BLOB pValue;
        DWORD dwValueType;
        DWORD cwsz;

        CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_NAME_VALUE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            NULL,                   // pNameValue
            &cbInfo
            );
        if (cbInfo == 0) goto CommonReturn;
        if (NULL == (pNameValue = (PCERT_NAME_VALUE) /*CoTaskMemAlloc(cbInfo)))*/ malloc(cbInfo)))
            goto CommonReturn;
        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_NAME_VALUE,
                pExt->Value.pbData,
                pExt->Value.cbData,
                0,                              // dwFlags
                pNameValue,
                &cbInfo)) goto CommonReturn;
        dwValueType = pNameValue->dwValueType;
        pValue = &pNameValue->Value;

        cwsz = CertRDNValueToStrW(
            dwValueType,
            pValue,
            NULL,               // pwsz
            0                   // cwsz
            );
        if (cwsz > 1) {
            pwsz = (LPWSTR) /*CoTaskMemAlloc(cwsz * sizeof(WCHAR))*/ malloc(cwsz*sizeof(WCHAR));
            if (pwsz)
                CertRDNValueToStrW(
                    dwValueType,
                    pValue,
                    pwsz,
                    cwsz
                    );
        }
    }

CommonReturn:
    if (pNameValue)
        /* CoTaskMemFree(pNameValue);*/ free(pNameValue);

    return pwsz;
}

//+-------------------------------------------------------------------------
//  Searches the name attributes for the first specified ObjId.
//
//  If found, allocates and converts to a WCHAR string
//
//  Returned WCHAR string needs to be CoTaskMemFree'ed.
//--------------------------------------------------------------------------
static LPWSTR GetRDNAttrWStr(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_BLOB pNameBlob
    )
{
    LPWSTR pwsz = NULL;
    PCERT_NAME_INFO pNameInfo = NULL;
    PCERT_RDN_ATTR pRDNAttr;
    DWORD cbInfo = 0;

    CryptDecodeObject(
        X509_ASN_ENCODING,
        X509_NAME,
        pNameBlob->pbData,
        pNameBlob->cbData,
        0,                      // dwFlags
        NULL,                   // pNameInfo
        &cbInfo
        );
    if (cbInfo == 0) goto CommonReturn;
    if (NULL == (pNameInfo = (PCERT_NAME_INFO) /*CoTaskMemAlloc(cbInfo)*/ malloc(cbInfo)))
        goto CommonReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_NAME,
            pNameBlob->pbData,
            pNameBlob->cbData,
            0,                              // dwFlags
            pNameInfo,
            &cbInfo)) goto CommonReturn;
    pRDNAttr = CertFindRDNAttr(pszObjId, pNameInfo);
    if (pRDNAttr) {
        PCERT_RDN_VALUE_BLOB pValue = &pRDNAttr->Value;
        DWORD dwValueType = pRDNAttr->dwValueType;
        DWORD cwsz;
        cwsz = CertRDNValueToStrW(
            dwValueType,
            pValue,
            NULL,               // pwsz
            0                   // cwsz
            );
        if (cwsz > 1) {
            pwsz = (LPWSTR) /*CoTaskMemAlloc(cwsz * sizeof(WCHAR))*/ malloc(cwsz * sizeof(WCHAR));
            if (pwsz)
                CertRDNValueToStrW(
                    dwValueType,
                    pValue,
                    pwsz,
                    cwsz
                    );
        }
    }

CommonReturn:
    if (pNameInfo)
        /*CoTaskMemFree(pNameInfo);*/ free(pNameInfo);

    return pwsz;
}


LPWSTR PrettySubject(PCCERT_CONTEXT pccert)
{
    DWORD       cb;
    DWORD       cch;
    BOOL        f;
    LPWSTR      pwsz;

    //
    //  If the user has put a friendly name onto a certificate, then we
    //  should display that as the pretty name for the certificate.
    //

    f = CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                          NULL, &cb);
    // cb includes terminating NULL
    if (f && (cb > sizeof(TCHAR))) {
        pwsz = (LPWSTR) malloc(cb);
        if (NULL != pwsz) {
            CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                              pwsz, &cb);
            return pwsz;
        }
    }

    pwsz = GetCommonNameExtension(pccert);
    if (pwsz != NULL) {
        return pwsz;
    }
    pwsz = GetRDNAttrWStr(szOID_COMMON_NAME, &pccert->pCertInfo->Subject);
    if (pwsz != NULL) {
        return pwsz;
    }

    pwsz = GetRDNAttrWStr(szOID_RSA_emailAddr, &pccert->pCertInfo->Subject);
    if (pwsz != NULL) {
        return pwsz;
    }

    cch = CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                        CERT_SIMPLE_NAME_STR, NULL, 0);
    pwsz = (LPTSTR) malloc(cch*sizeof(TCHAR));
    if (pwsz != NULL) {
        CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                            CERT_SIMPLE_NAME_STR, pwsz, cch);
    }

    return pwsz;

}

LPWSTR PrettyIssuer(PCCERT_CONTEXT pccert)
{
    DWORD       cch;
    LPWSTR      pwsz;

    //    pwsz = GetCommonNameExtension(pccert);
    //    if (pwsz != NULL) {
    //        return pwsz;
    //    }
    pwsz = GetRDNAttrWStr(szOID_COMMON_NAME, &pccert->pCertInfo->Issuer);
    if (pwsz != NULL) {
        return pwsz;
    }

    cch = CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                        CERT_SIMPLE_NAME_STR, NULL, 0);
    pwsz = (LPTSTR) malloc(cch*sizeof(TCHAR));
    CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                        CERT_SIMPLE_NAME_STR, pwsz, cch);
    return pwsz;
}

LPWSTR PrettySubjectIssuer(PCCERT_CONTEXT pccert)
{
    int         cwsz;
    LPWSTR      pwsz;
    LPWSTR      pwszIssuer;
    LPWSTR      pwszSubject;

    pwszSubject = PrettySubject(pccert);
    if (NULL == pwszSubject) {
        return NULL;
    }

    pwszIssuer = PrettyIssuer(pccert);
    if (NULL == pwszIssuer) {
        free(pwszSubject);
        return NULL;
    }

    cwsz = wcslen(pwszSubject) + wcslen(pwszIssuer) + 20;
    pwsz = (LPWSTR) malloc(cwsz*sizeof(WCHAR));

    StrCpyNW(pwsz, pwszSubject, cwsz);
#ifndef WIN16
    StrCatBuffW(pwsz, L" (", cwsz);
    StrCatBuffW(pwsz, pwszIssuer, cwsz);
    StrCatBuffW(pwsz, L")", cwsz);
#else
    StrCatBuffW(pwsz, " (", cwsz);
    StrCatBuffW(pwsz, pwszIssuer, cwsz);
    StrCatBuffW(pwsz, ")", cwsz);
#endif

    free(pwszSubject);
    free(pwszIssuer);
    return pwsz;
}


#ifndef MAC
BOOL OnContextHelp(HWND /*hwnd*/, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP) {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW) {   // must be for a control
#ifndef WIN16
            WinHelp ((HWND)lphi->hItemHandle, L"iexplore.hlp", HELP_WM_HELP,
                     (ULONG_PTR)(LPVOID)rgCtxMap);
#else
            WinHelp ((HWND)lphi->hItemHandle, "iexplore.hlp", HELP_WM_HELP,
                     (ULONG_PTR)(LPVOID)rgCtxMap);
#endif // !WIN16
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU) {
#ifndef WIN16
        WinHelp ((HWND) wParam, L"iexplore.hlp", HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPVOID)rgCtxMap);
#else
        WinHelp ((HWND) wParam, "iexplore.hlp", HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPVOID)rgCtxMap);
#endif // !WIN16
        return (TRUE);
    }

    return FALSE;
}
#endif // MAC


/////////////////////////////////////////////////////////////////////////

////    GetFriendlyNameOfCertA
//
//  Description:
//      This routine is an exported routine which can be used to get
//      a friendly name from a certificate.  The function uses the
//      buffer supplied by the caller to store the formated name in.
//      This is the ANSI half of the function pair.
//

DWORD GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pch, DWORD cch)
{
    DWORD       cch2;
    LPWSTR      pwsz;

    //
    //  Now do the normal pretty printing functionality.  This allocates and
    //  returns a buffer to the caller (us).
    //

    pwsz = PrettySubject(pccert);
    if (NULL == pwsz) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    //   Convert the returned string from a Unicode string to an ANSI string
    //

    cch2 = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);

    if ((pch != NULL) && (cch2 <= cch)) {
        cch2 = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pch, cch, NULL, NULL);
    }
    else if (pch != NULL) {
        SetLastError(ERROR_MORE_DATA);
    }

    free(pwsz);
    return cch2;
}

////    GetFriendlyNameOfCertW
//
//  Description:
//      This routine is an exported routine which can be used to get
//      a friendly name from a certificate.  The function uses the
//      buffer supplied by the caller to store the formated name in.
//      This is the UNICODE half of the function pair.
//

DWORD GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pwch, DWORD cwch)
{
    DWORD       cwch2;
    LPWSTR      pwsz;

    //
    //  Now do the normal pretty printing functionality.  This allocates and
    //  returns a buffer to the caller (us).
    //

    pwsz = PrettySubject(pccert);
    if (NULL == pwsz) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    cwch2 = wcslen(pwsz) + 1;

    //
    //  Duplicate the string into the provided buffer.
    //

    if ((pwch != NULL) && (cwch2 <= cwch)) {
        StrCpyNW(pwch, pwsz, cwch);
    }
    else if (pwch != NULL) {
        SetLastError(ERROR_MORE_DATA);
    }

    free(pwsz);
    return cwch2;
}


const BYTE mpchfLegalForURL[] =
{
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 0
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 16
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x11, 0x00, 0x11,   0x01, 0x01, 0x01, 0x01,	// 32
    0x01, 0x11, 0x01, 0x01,   0x11, 0x01, 0x11, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 48
    0x01, 0x01, 0x11, 0x01,   0x00, 0x01, 0x00, 0x11,


    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 64
    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 80
    0x01, 0x01, 0x01, 0x00,   0x01, 0x00, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 96
    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 112
    0x01, 0x01, 0x01, 0x00,   0x01, 0x00, 0x11, 0x00,


    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 128
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 144
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 160
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 176
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,


    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 192
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 208
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 224
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 240
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,
};

const char szURLSep[] = ":";
const char szURLCloseBrace[] = ">";
const char chURLOpenBrace = '<';

// ordered by match probability and string length

const char g_szURLDefaultPrefixs[] =
        "http"   "\0"
        "file"   "\0"
        "ftp"    "\0"
        "news"   "\0"
        "mailto" "\0"
        "https"  "\0"
        "gopher" "\0"
        "telnet" "\0"
        "nntp"   "\0"
        "wais"   "\0"
        "prospero\0\0";

LPSTR g_pszURLPrefixs = (LPSTR) g_szURLDefaultPrefixs;

#define cchURLPrefixMost 28

BOOL g_fLoadBrowserRegistry = 1;
TCHAR   g_szBrowser[MAX_PATH];
COLORREF        g_crLink = RGB(0, 0, 255);

/*
 *  NoteRecognizeURLs
 *
 *  Purpose:
 *      Change the charformat of text in the richedit control
 *      for text that begins with http: ftp: or other.
 *
 *  Arguments:
 *      HWND        			A handle to the richedit control
 *		fLoadBrowserRegistry	Should we read the registry ?
 *
 *  Returns:
 *      VOID        That would be nothing
 *
 *  Notes:
 *
 *      g_fLoadBrowserRegistry must be true on the first call
 *      this may change g_szBrowser, g_crLink, and or g_pszURLPrefixs
 *      g_pszURLPrefixs must equal g_szURLDefaultPrefixs, and must not be NULL
 *
 *      if g_szBrowser, the path to the browser, is not found in the registry,
 *      it will be defaulted to one of three things: !, url.dll, or iexplore
 *
 */

VOID RecognizeURLs(HWND hwndRE)
{
    int isz;
    LONG cchBrace;
    LONG cpBraceSearch;
    LONG cpMatch;
    LONG cpSep;
    LONG cpEnd;
    LPSTR pch;
    CHARRANGE chrgSave;
    FINDTEXTEX ft;
    TEXTRANGEA tr;
    CHARFORMATA cf;
    char szBuff[MAX_PATH]; // szBuff must be at least cchURLPrefixMost
    LPSTR szT;
    LPARAM lNotifSuppression;

#if MAX_PATH < cchURLPrefixMost
#error MAX_PATH < cchURLPrefixMost
#endif

    if (g_fLoadBrowserRegistry) {
        //        INT cch; // signed to compare against 0

        // hopefully we will not have to re-read
        // from the registry again, but a winini change
        // will force another read - see mlview shell.c

        g_fLoadBrowserRegistry = 0;

#if 0
        // if they change the default charformat
        // compute the hex stored color ref

        cch = GetMailRegistryString(imkeyURLColor, NULL, g_szBrowser, sizeof(g_szBrowser));
        if (cch > 0) {
            LPTSTR psz = g_szBrowser;

            g_crLink = 0;
            for (; cch > 0; --cch, psz++) {
                g_crLink *= 16;
                if (*psz <= '9')
                    g_crLink += *psz - TEXT('0');
                else if (*psz <= 'F')
                    g_crLink += *psz - TEXT('A') + 10;
                else
                    g_crLink += *psz - TEXT('a') + 10;
            }
        }
#endif // 0

#if 0
        // grab the path to their browser, and
        // set the disable flag if appropriate

        cch = GetMailRegistryString(imkeyBrowser, NULL, g_szBrowser, sizeof(g_szBrowser));
        if (cch <= 0) {
#endif // 0
#ifndef MAC
            StrCpyN(g_szBrowser, TEXT("c:\\inetsrv\\iexplore\\iexplore.exe"), ARRAYSIZE(g_szBrowser));
#else	// MAC
            StrCpyN(g_szBrowser, TEXT(":MSIE:APPL"), ARRAYSIZE(g_szBrowser));
#endif	// !MAC			
#if 0
        }
#endif // 0
    }

    // Prepare a few local variables for use

    szT = szBuff;
    cf.cbSize = sizeof(cf);
    ft.chrg.cpMin = 0;
    ft.chrg.cpMax = -1;              // search the entire message body
    ft.lpstrText = (LPTSTR) szURLSep; // for a colon
    tr.lpstrText = szBuff;
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_LINK;
    cf.dwEffects = 0;
    cpBraceSearch = 0;

    SendMessage(hwndRE, EM_EXGETSEL, 0, (LPARAM) &chrgSave);
    SendMessage(hwndRE, EM_HIDESELECTION, TRUE, FALSE);

    lNotifSuppression = SendMessage(hwndRE,EM_GETEVENTMASK,0,0);
    SendMessage(hwndRE, EM_SETEVENTMASK, (WPARAM) 0, 0);

    // remove existing link bits so that the user does not
    // get hosed when he/she saves text that was mistakenly marked
    // as linked ... gee, this SCF_ALL flag is a big perf win

    SendMessage(hwndRE, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &cf);

    // loop all the way to the bottom of the note
    // one iteration per find of a potential match
    // when we locate a colon

    for (;;) {
        LONG cpLast = 0;

        // find the colon

        cpSep = (LONG) SendMessage(hwndRE, EM_FINDTEXTEX, 0, (LPARAM) &ft);
        if (cpSep < 0)
            break;
        cpEnd = ft.chrgText.cpMax;
        ft.chrg.cpMin = cpEnd;

        // make sure the word to the left of the colon
        // is present and of a reasonable size

        cpMatch = (LONG) SendMessage(hwndRE, EM_FINDWORDBREAK, WB_MOVEWORDLEFT, ft.chrgText.cpMin);
        if (cpMatch == cpSep)
            continue;

        // sender of message is just being a jerk
        // so, do a quick check to avoid pathological cases

        if (cpMatch < cpSep - cchURLPrefixMost) {
            ft.chrg.cpMin = (LONG) SendMessage(hwndRE, EM_FINDWORDBREAK, WB_MOVEWORDRIGHT, cpSep);
            //            Assert(ft.chrg.cpMin > cpSep);
            continue;
        }

        // pull the text of the keyword out into szBuff
        // to compare against our word list ... also grab
        // the character to the left in case we are
        // enclosed in matching braces

        cchBrace = 0;
        tr.chrg.cpMin = cpMatch - cchBrace;
        tr.chrg.cpMax = cpSep;
        if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr))
            goto end;

        // compare to each word in our list

        for (isz = 0; g_pszURLPrefixs[isz]; isz+=lstrlenA(g_pszURLPrefixs+isz)+1) {
            if (0 == lstrcmpiA(szBuff + cchBrace, &g_pszURLPrefixs[isz]))
                goto match;
        }
        continue;

    match:
        ft.chrgText.cpMin = cpMatch;
        cpLast = cpEnd; // assume that we will stop after the colon

        // check to see if this is the brace character

        if (cchBrace && chURLOpenBrace == szBuff[0]) {
            FINDTEXTEX ft;
            LONG cpBraceClose;

            ft.chrg.cpMin = max(cpEnd, cpBraceSearch);
            ft.chrg.cpMax = cpEnd + MAX_PATH;
            ft.lpstrText = (LPTSTR) szURLCloseBrace;

            cpBraceClose = (LONG) SendMessage(hwndRE, EM_FINDTEXTEX, 0, (LPARAM) &ft);
            if (cpBraceClose >= 0) {
                tr.chrg.cpMin = cpEnd;
                tr.chrg.cpMax = cpEnd + 1;
                if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr) || ' ' == szBuff[0])
                    goto end;

                cpLast = cpEnd = ft.chrgText.cpMin;
                cpBraceSearch = cpLast + 1;
                goto end;
            }
            else {
                cpBraceSearch = ft.chrg.cpMax;
            }
        }

        // loop through chunks of the URL in
        // steps of sizeof(szBuff) looking for a terminator
        // set cpLast to the last terminator byte that is legal according to us

        for (;;) {
            tr.chrg.cpMin = cpLast = cpEnd;
            tr.chrg.cpMax = cpEnd + sizeof(szBuff) - 1;
            if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr))
                goto end;

            for (pch = szBuff; *pch; pch++, cpEnd++) {
                const BYTE fb = mpchfLegalForURL[*pch];
#ifdef DBCS
                if (!fb || FGLeadByte(*pch))
#else	// DBCS
                    if (!fb)
#endif	// DBCS
                        {
                            goto end;
                        }
                if(!(fb & 0x10)) {
                    cpLast = cpEnd + 1;
                }
            }
        }

    end:
        if (cpLast == cpSep + 1) // hmmm... just "http:" then terminator
            continue;            // must have argument to be legal

        // select the entire URL including the http colon,
        // mark it as linked, and change the charformat if appropriate

        ft.chrgText.cpMax = cpLast;
        SendMessage(hwndRE, EM_EXSETSEL, 0, (LPARAM) &ft.chrgText);
        cf.dwMask = CFM_LINK | CFM_UNDERLINE | CFM_COLOR;
        if (((LONG)g_crLink) < 0)
            cf.dwMask &= ~CFM_UNDERLINE;   /* high bit turns off underline */
        if (((LONG)g_crLink) & 0x40000000)
            cf.dwMask &= ~CFM_COLOR;       /* next bit turns off color */
        cf.dwEffects = CFE_LINK | CFE_UNDERLINE;
        cf.crTextColor = g_crLink;
        SendMessage(hwndRE, EM_SETCHARFORMAT, SCF_SELECTION,
                    (LPARAM) &cf);

        // no need to re-search through the URL
        // so, just advance past the last totally cool URL character

        ft.chrg.cpMin = cpLast + 1;

    }   // end loop through richedit text

    SendMessage(hwndRE, EM_EXSETSEL, 0, (LPARAM) &chrgSave);
    SendMessage(hwndRE, EM_HIDESELECTION, FALSE, FALSE);
    SendMessage(hwndRE, EM_SETEVENTMASK, (WPARAM) 0, (LPARAM) lNotifSuppression);
    return;
}


#ifndef MAC
/*
 *	FNoteDlgNotifyLink
 *
 *	Purpose:
 *		Handle the user clicking on a link
 *
 *	Arguments:
 *		hwndDlg			Parent dialog
 *		penlink			Link notification structure
 *		szURL			URL to launch
 *
 *	Returns:
 *		BOOL			TRUE if we processed message, else FALSE
 */

BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL)
{
    //    BOOL fShift;
    LONG cch, cchBuffer;
    TEXTRANGEA tr;
    char szCmd[2*MAX_PATH + 2];
#ifdef MAC
    BOOL fPickedBrowser = FALSE;
#endif	
    HCURSOR hcursor;

    // eat the double click - just activate on single click

    if (WM_LBUTTONDBLCLK == penlink->msg) {
        return TRUE;
    }

    // if we got this far, we are enabled so assert that the path
    // does not explicitly say we should be disabled

    // below this point, we return true meaning that
    // we handled this message, and richedit should do nothing

    hcursor = SetCursor(LoadCursorA(NULL, (LPSTR) IDC_WAIT));

#ifndef MAC
    // prepare szCmd for use as the parameter to execution
    //    AssertSz(sizeof(szCmd) > sizeof(g_szBrowser), "cat may overwrite");
    wnsprintfA(szCmd, ARRAYSIZE(szCmd), "%s ", g_szBrowser);
    cch = lstrlenA(szCmd);
    tr.chrg.cpMin = penlink->chrg.cpMin;
    tr.chrg.cpMax = min((LONG) (tr.chrg.cpMin + sizeof(szCmd) - cch - 1), penlink->chrg.cpMax);
    cchBuffer = ARRAYSIZE(szCmd) - cch;
    tr.lpstrText = &szCmd[cch];
#else
    cch = 0;
    szCmd[0] = TEXT('\0');
    tr.chrg.cpMin = penlink->chrg.cpMin;
    tr.chrg.cpMax = min((LONG) (tr.chrg.cpMin + sizeof(szCmd) - cch - 1), penlink->chrg.cpMax);
    cchBuffer = ARRAYSIZE(szCmd) - cch;
    tr.lpstrText = szCmd;
#endif	

    // add the web path to the command line

    if (szURL) {
        cch = lstrlenA(szURL);
        StrCpyNA(tr.lpstrText, szURL, cchBuffer);
    }
    else {
        cch = (LONG) SendMessage(penlink->nmhdr.hwndFrom, EM_GETTEXTRANGE, 0, (LPARAM) &tr);
    }
	
    if (cch > 0)
#ifndef MAC
	{
            HINSTANCE hinst;
            UINT ui;

#if defined(WIN32) && !defined(MAC)
            SetProcessWorkingSetSize(GetCurrentProcess(), 0xffffffff, 0xffffffff);
#endif	
            // execute the browser, however the current operating system wants to ...
            hinst = ShellExecuteA(hwndDlg, NULL, tr.lpstrText, NULL, NULL, SW_SHOWNORMAL);
            if ((UINT_PTR) hinst > 32) {
                SetCursor(hcursor);
                return TRUE;
            }

            // the operating system failed to launch the browser, let me try ...
            ui = WinExec(szCmd, SW_SHOW);
            if (ui < 32) {
                // perhaps they moved or deleted their executable regardless
                // of the error, we will just browse for a path
                // this is currently by design

                MessageBeep(MB_OK);
                SetCursor(hcursor);
                return FALSE;
            }
		
	}
    SetCursor(hcursor);
    return TRUE;
#else	// MAC
    {
        HWND                hwndActive;
        ProcessSerialNumber psn;
        AppleEvent			aeEvent = { 0 };
        AppleEvent          aeReply = { 0 };
        AEAddressDesc		aedAddr = { 0 };
        AEEventClass        aecOpenURL = 'WWW!';
        AEEventID           aeidOpenURL = 'OURL';
        OSErr				errLaunch = icPrefNotFoundErr;
        OSType				ostBrowser;
        OSType				ostType;
        SCODE				sc = S_OK;
        TCHAR               szCaption[MAX_PATH];

        // Prompt the user to see if we can open the URL safely

        hwndActive = GetActiveWindow();
        if (!GetWindowText(hwndActive, szCaption,
                           (sizeof(szCaption) / sizeof(TCHAR)))) {
            szCaption[0] = TEXT('\0');
        }
        if (!FIsSafeURL(hwndActive, tr.lpstrText, szCaption)) {
            goto Exit;
        }

        // See if we have an Internet Config instance

        if (INST(picinstIConfig) != NULL) {
            ICAppSpec       icappHelper = { 0 };
            ICAttr          icattr;
            LONG            lSize;
            Str255          strHelper = kICHelper;
            TCHAR*          pchHelper;
            TCHAR*          pchURL;

            // Locate the end of the Helper string and add the protocol
            //  from the URL

            pchHelper = strHelper + (sizeof(kICHelper) - 1);
            pchURL = tr.lpstrText;
            while ((*pchURL != TEXT('\0')) && (*pchURL != TEXT(':'))) {
                *pchHelper = *pchURL;
                pchURL++;
                pchHelper++;
                strHelper[0]++;
            }

            // Call Internet Config to see if we have a helper for this
            //  protocol defined

            lSize = sizeof(ICAppSpec);
            errLaunch = (OSErr)ICGetPref(INST(picinstIConfig), strHelper,
                                         &icattr, (LPBYTE)&icappHelper,
                                         &lSize);
            if (errLaunch == noErr) {
                // Got a helper application, extract the information needed
                //  to launch the correct helper with a GURL event

                ostBrowser = icappHelper.fCreator;
                aecOpenURL = 'GURL';
                aeidOpenURL = 'GURL';
            }
        }

        // If we do not have an error at this point that means that Internet
        //  Config found the helper.  Otherwise, we need to look in the
        //  standard preferences for the browser.

        if (errLaunch != noErr) {
            // Create a Mac OSType from the browser string

            if (!FMacSignatureFromMacInfo(g_szBrowser, NULL, &ostBrowser,
                                          &ostType)) {
                goto Exit;
            }
        }

        // If Exchange is the designated helper we want to avoid the expense
        //  of using AppleEvents

        if (ostBrowser != 'EXCH') {
            // Set up the AppleEvent

    	    errLaunch = AECreateDesc(typeApplSignature, &ostBrowser,
                                     sizeof(OSType), &aedAddr);
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }

            // Create the AppleEvent to send to the web browser

            errLaunch = AECreateAppleEvent(aecOpenURL, aeidOpenURL, &aedAddr,
                                           kAutoGenerateReturnID,
                                           kAnyTransactionID, &aeEvent);
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }

            // Add the URL as the direct parameter

            errLaunch = AEPutParamPtr(&aeEvent, keyDirectObject, typeChar,
                                      tr.lpstrText, _tcslen(tr.lpstrText));
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }
    	
            // Get a running instance of the browser so that we have something
            //	to actually process our event and send it the open command.

            errLaunch = ErrLaunchCreatorEx(ostBrowser,
                                           launchContinue | launchUseMinimum,
                                           &aeEvent,
                                           kAEWaitReply | kAEAlwaysInteract,
                                           &aeReply, NULL, &psn);
            if (errLaunch != noErr) {
#if 0
                // If we could not launch the browser because it was not
                //  found, we need to try and choose a browser to use,
                //  otherwise we just ignore the error and fail gracefully.

                if ((errLaunch == fnfErr) && (!fPickedBrowser)) {
                    fPickedBrowser = TRUE;
    	            SetCursor(hcursor);
                    goto pick;
                }
#endif // 0
                goto CleanupAEvent;
            }

            ErrSetFrontProcess(&psn);
    		
        CleanupAEvent:
            AEDisposeDesc(&aeEvent);
            AEDisposeDesc(&aeReply);
            AEDisposeDesc(&aedAddr);
        }
        else {
            LPIEDATA        pieData = NULL;
            LPTSTR          pszURL = NULL;
            LONG            iProtocol;
            ULONG	    	cchText;

            // Allocate a buffer to store the URL in

            cchText = _tcslen(tr.lpstrText)+1;
            pszURL = PvAlloc((cchText * sizeof(TCHAR)),
                             fZeroFill);
            if (pszURL == NULL) {
                goto CleanupIEData;
            }
            StrCpyN(pszURL, tr.lpstrText, cchText);

            // Make sure this is a protocol supported by Exchange

            for (iProtocol = 0; iProtocol < g_lNumIESupProtocols; iProtocol++) {
                if (_tcsncmp(pszURL, g_iesupMac[iProtocol].szProtocol,
                             _tcslen(g_iesupMac[iProtocol].szProtocol)) == 0) {
                    // Found a match

                    break;
                }
            }

            if (iProtocol == g_lNumIESupProtocols) {
                // No match found

                goto CleanupIEData;
            }
		
            // Create the appropriate IEDATA structure

            pieData = PvAlloc(sizeof(IEDATA), fZeroFill);
            if (pieData == NULL) {
                goto CleanupIEData;
            }
            pieData->szURL = pszURL;
            pieData->idxProtocol = iProtocol;

            // Post an internal message to ourselves to actually do the
            //  processing

            PostMessage(INST(hwndCentral), EXIE_OPENURL, 0, (LPARAM)pieData);
            goto Exit;

        CleanupIEData:
            if (pszURL != NULL) {
                FreePv(pszURL);
            }
            if (pieData != NULL) {
                FreePv(pieData);
            }
        }
    }
	
Exit:	
    SetCursor(hcursor);
    return TRUE;
#endif	// !MAC
}
#endif  // !MAC

/////////////////////////////////////////////////////////////////////////
//
//   This code provides the first cut of the Verisign Cert Policy Statement
//      implemenation code.   This should be replaced in the next version by
//      the correct version of this code.  It is suppose to read a multi-
//      language file and pick up the correct version according to
//      the machine's lanaguage
//

#ifndef WIN16

WCHAR   RgwchVerisign[] =
L"This certificate incorporates by reference, and its use is strictly subject "
L"to, the VeriSign Certification Practice Statement (CPS), available in the "
L"VeriSign repository at: https://www.verisign.com by E-mail at "
L"CPS-requests@verisign.com; or by mail at VeriSign, Inc., 1390 Shorebird "
L"Way, Mountain View, CA 94043 USA Copyright (c)1997 VeriSign, Inc.  All "
L"Rights Reserved. CERTAIN WARRANTIES DISCLAIMED AND LIABILITY LIMITED.\n"
L"\n"
L"WARNING: USE OF THIS CERTIFICATE IS STRICTLY SUBJECT TO THE VERISIGN "
L"CERTIFICATION PRACTICE STATEMENT.  THE ISSUING AUTHORITY DISCLAIMS CERTAIN "
L"IMPLIED AND EXPRESS WARRANTIES, INCLUDING WARRANTIES OF MERCHANTABILITY OR "
L"FITNESS FOR A PARTICULAR PURPOSE, AND WILL NOT BE LIABLE FOR CONSEQUENTIAL, "
L"PUNITIVE, AND CERTAIN OTHER DAMAGES. SEE THE CPS FOR DETAILS.\n"
L"\n"
L"Contents of the VeriSign registered nonverifiedSubjectAttribute extension "
L"value shall not be considered as information confirmed by the IA.";

#else

WCHAR   RgwchVerisign[] =
"This certificate incorporates by reference, and its use is strictly subject "
"to, the VeriSign Certification Practice Statement (CPS), available in the "
"VeriSign repository at: https://www.verisign.com; by E-mail at "
"CPS-requests@verisign.com; or by mail at VeriSign, Inc., 1390 Shorebird "
"Way, Mountain View, CA 94043 USA Copyright (c)1997 VeriSign, Inc.  All "
"Rights Reserved. CERTAIN WARRANTIES DISCLAIMED AND LIABILITY LIMITED.\n"
"\n"
"WARNING: USE OF THIS CERTIFICATE IS STRICTLY SUBJECT TO THE VERISIGN "
"CERTIFICATION PRACTICE STATEMENT.  THE ISSUING AUTHORITY DISCLAIMS CERTAIN "
"IMPLIED AND EXPRESS WARRANTIES, INCLUDING WARRANTIES OF MERCHANTABILITY OR "
"FITNESS FOR A PARTICULAR PURPOSE, AND WILL NOT BE LIABLE FOR CONSEQUENTIAL, "
"PUNITIVE, AND CERTAIN OTHER DAMAGES. SEE THE CPS FOR DETAILS.\n"
"\n"
"Contents of the VeriSign registered nonverifiedSubjectAttribute extension "
"value shall not be considered as information confirmed by the IA.";

#endif // !WIN16

BOOL WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/, DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/, LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat)
{
    if (pbFormat == NULL) {
        *pcbFormat = sizeof(RgwchVerisign);
        return TRUE;
    }

    if (*pcbFormat < sizeof(RgwchVerisign)) {
        *pcbFormat = sizeof(RgwchVerisign);
        return FALSE;
    }

    memcpy(pbFormat, RgwchVerisign, sizeof(RgwchVerisign));
    return TRUE;
}

BOOL WINAPI FormatPKIXEmailProtection(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/, DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/, LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat)
{
    DWORD       cch;
    WCHAR       rgwch[256];

    cch = LoadString(HinstDll, IDS_EMAIL_DESC, rgwch, sizeof(rgwch)/sizeof(WCHAR));

    if (pbFormat == NULL) {
        *pcbFormat = (cch+1)*sizeof(WCHAR);
        return TRUE;
    }

    if (*pcbFormat < (cch+1)*sizeof(WCHAR)) {
        *pcbFormat = (cch+1)*sizeof(WCHAR);
        return FALSE;
    }

    memcpy(pbFormat, rgwch, (cch+1)*sizeof(WCHAR));
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//   This is an encoder which should really be in crypt32 -- however I don't
//      want to force a drop of crypt32 just to get it.
//

BOOL WINAPI
EncodeAttrSequence(DWORD /*dwType*/, LPCSTR /*lpszStructType*/,
                   const void * pv, LPBYTE pbEncode, DWORD * pcbEncode)
{
    DWORD                       cb;
    DWORD                       dw;
    BOOL                        fRet;
    DWORD                       i;
    PCRYPT_ATTRIBUTES           pattrs = (PCRYPT_ATTRIBUTES) pv;
    LPBYTE                      pb = NULL;
    CRYPT_SEQUENCE_OF_ANY       seq = {0};
    UNALIGNED void * pAttr = NULL;
    //
    //  Allocate something to hold the result of each attribute's encoding
    //

    seq.rgValue = (PCRYPT_DER_BLOB) malloc(pattrs->cAttr *
                                           sizeof(CRYPT_DER_BLOB));
    if (seq.rgValue == NULL) {
        dw = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    //
    //  Now encode each of the attributes in turn
    //

    for (i=0; i<pattrs->cAttr; i++) {

        pAttr =((UNALIGNED void *) &(pattrs->rgAttr[i]));

        if (!CryptEncodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pAttr, NULL, &cb) || (cb == 0)) {
            fRet = FALSE;
            goto Clean;
        }

        pb = (LPBYTE) malloc(LcbAlignLcb(cb));
        if (!CryptEncodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pAttr, pb, &cb)) {
            fRet = FALSE;
            goto Clean;
        }

        seq.cValue = i+1;
        seq.rgValue[i].cbData = cb;
        seq.rgValue[i].pbData = pb;
        pb = NULL;
    }

    //
    //  Now lets encode the sequence
    //

    fRet = CryptEncodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                             &seq, pbEncode, pcbEncode);

Clean:
    for (i=0; i<seq.cValue; i++) free(seq.rgValue[i].pbData);
    if (seq.rgValue != NULL) free(seq.rgValue);
    if (pb != NULL) free(pb);
    return fRet;

ErrorExit:
    SetLastError(dw);
    fRet = FALSE;
    goto Clean;
}

BOOL WINAPI
DecodeAttrSequence(DWORD /*dwType*/, LPCSTR /*lpszStructType*/,
                   const BYTE * pbEncoded, DWORD cbEncoded,
                   DWORD /*dwFlags*/, void * pvStruct,
                   DWORD * pcbStruct)
{
    DWORD                       cb;
    DWORD                       cbMax = 0;
    DWORD                       cbOut;
    BOOL                        fRet = FALSE;
    DWORD                       i;
    DWORD                       i1;
    PCRYPT_ATTRIBUTE            pattr = NULL;
    PCRYPT_ATTRIBUTES           pattrs = (PCRYPT_ATTRIBUTES) pvStruct;
    LPBYTE                      pbOut = NULL;
    PCRYPT_SEQUENCE_OF_ANY      pseq = NULL;
#ifdef _WIN64
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;
#endif

    //
    //  Decode the top level sequence
    //

    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                           pbEncoded, cbEncoded, 0, NULL, &cb)) {
        goto Exit;
    }

    pseq = (PCRYPT_SEQUENCE_OF_ANY) malloc(cb);
    if (pseq == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                           pbEncoded, cbEncoded, 0, pseq, &cb)) {
        goto Exit;
    }

    //
    //  Decode each attribute for length
    //

    cbOut = sizeof(CRYPT_ATTRIBUTES);

    for (i=0; i<pseq->cValue; i++) {
        if (!CryptDecodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pseq->rgValue[i].pbData,
                               pseq->rgValue[i].cbData, 0, NULL, &cb)) {
            fRet = FALSE;
            goto Exit;
        }
        cb = LcbAlignLcb(cb);
        if (cb > cbMax) cbMax = cb;
        cbOut += cb;
    }

    if (pvStruct == NULL) {
        *pcbStruct = cbOut;
        fRet = TRUE;
        goto Exit;
    }

    if (*pcbStruct < cbOut) {
        *pcbStruct = cbOut;
        SetLastError(ERROR_MORE_DATA);
        goto Exit;
    }

    //
    //  Now we are going to actually try and compute the real data.
    //
    //  First we need a buffer to put each attribute in as we are looking at it
    //

    pattr = (PCRYPT_ATTRIBUTE) malloc(LcbAlignLcb(cbMax));
    if (pattr == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    pattrs->cAttr = pseq->cValue;
    pattrs->rgAttr = (PCRYPT_ATTRIBUTE) (((LPBYTE) pvStruct) +
                                         sizeof(CRYPT_ATTRIBUTES));

    pbOut = ((LPBYTE) pvStruct + LcbAlignLcb(sizeof(CRYPT_ATTRIBUTES) +
             pseq->cValue * sizeof(CRYPT_ATTRIBUTE)));

    for (i=0; i<pseq->cValue; i++) {
        //
        //  Decode one attribute
        //

        cb = cbMax;
        if (!CryptDecodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pseq->rgValue[i].pbData, pseq->rgValue[i].cbData,
                               0, pattr, &cb)) {
            goto Exit;
        }

        //
        //  Copy to real output buffer
        //

        pattrs->rgAttr[i].pszObjId = (LPSTR) pbOut;
        cb = lstrlenA(pattr->pszObjId) + 1;
        memcpy(pbOut, pattr->pszObjId, cb);

        pbOut += LcbAlignLcb(cb);

        pattrs->rgAttr[i].cValue = pattr->cValue;
        pattrs->rgAttr[i].rgValue = (PCRYPT_ATTR_BLOB) pbOut;
        pbOut += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB) * pattr->cValue);

        for (i1=0; i1<pattr->cValue; i1++) {
#ifndef _WIN64
            pattrs->rgAttr[i].rgValue[i1].cbData = pattr->rgValue[i1].cbData;
            pattrs->rgAttr[i].rgValue[i1].pbData = pbOut;
#else
            pVal = &(pattrs->rgAttr[i].rgValue[i1]);
            pVal->cbData = pattr->rgValue[i1].cbData;
            pVal->pbData = pbOut;
#endif //_WIN64
            memcpy(pbOut, pattr->rgValue[i1].pbData, pattr->rgValue[i1].cbData);
            pbOut += LcbAlignLcb(pattr->rgValue[i1].cbData);
        }
    }


    fRet = TRUE;
Exit:
    if (pattr != NULL) free(pattr);
    if (pseq != NULL) free(pseq);
    return fRet;
}

//      OIDs    1.3.6.1.4.1.311.16.4

BOOL WINAPI EncodeRecipientID(DWORD dwType, LPCSTR /*lpszStructType*/,
                              const void * pv, LPBYTE pbEncode, 
                              DWORD * pcbEncode)
{
    DWORD                       cbInt;
    BOOL                        f;
    LPBYTE                      pbInt = NULL;
    CRYPT_RECIPIENT_ID *        prid = (CRYPT_RECIPIENT_ID *) pv;
    CRYPT_DER_BLOB              rgValue[2];
    CRYPT_SEQUENCE_OF_ANY       seq = {0, rgValue};

    if (prid->unused != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    f = CryptEncodeObject(dwType, X509_MULTI_BYTE_INTEGER, 
                          &prid->SerialNumber, NULL, &cbInt);
    if (!f) goto ExitHere;

    pbInt = (LPBYTE) malloc(cbInt);
    if (pbInt == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        f = FALSE;
        goto ExitHere;
    }

    f = CryptEncodeObject(dwType, X509_MULTI_BYTE_INTEGER, 
                          &prid->SerialNumber, pbInt, &cbInt);
        
    seq.cValue = 2;
    seq.rgValue[0].cbData = prid->Issuer.cbData;
    seq.rgValue[0].pbData = prid->Issuer.pbData;

    seq.rgValue[1].cbData = cbInt;
    seq.rgValue[1].pbData = pbInt;

    f = CryptEncodeObject(dwType, X509_SEQUENCE_OF_ANY, &seq,
                          pbEncode, pcbEncode);

ExitHere:
    if (pbInt != NULL) free(pbInt);
    return f;
        
}

BOOL WINAPI DecodeRecipientID(DWORD dwType, LPCSTR /*lpszStructType*/,
                              const BYTE * pbEncoded, DWORD cbEncoded,
                              DWORD dwFlags, void * pvStruct, DWORD * pcbStruct)
{
    DWORD                       cb;
    DWORD                       cbOut;
    BOOL                        fRet = FALSE;
    CRYPT_INTEGER_BLOB *        pInt = NULL;
    CRYPT_RECIPIENT_ID *        prid = (CRYPT_RECIPIENT_ID *) pvStruct;
    CRYPT_SEQUENCE_OF_ANY *     pseq = NULL;

    //  Decode the top level sequence first

    fRet = CryptDecodeObjectEx(dwType, X509_SEQUENCE_OF_ANY, pbEncoded, 
                            cbEncoded, dwFlags | CRYPT_ENCODE_ALLOC_FLAG, 
                            NULL, &pseq, &cb);
    if (!fRet) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    //    Assert(pseq->cValue == 2);

    //  Decode integer
    fRet = CryptDecodeObjectEx(dwType, X509_MULTI_BYTE_INTEGER,
                               pseq->rgValue[1].pbData, pseq->rgValue[1].cbData,
                               dwFlags | CRYPT_ENCODE_ALLOC_FLAG, NULL,
                               &pInt, &cb);
    if (!fRet) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    
    //  Compute length needed for the return value

    cbOut = (sizeof(CRYPT_RECIPIENT_ID) + pseq->rgValue[0].cbData +
             pInt->cbData);
    if ((*pcbStruct < cbOut) || (pvStruct == NULL)) {
        *pcbStruct = cbOut;
        SetLastError(ERROR_MORE_DATA);
        fRet = (pvStruct == NULL);
        goto Exit;
    }

    //  Now copy the data over

    prid->unused = 0;
    prid->Issuer.cbData = pseq->rgValue[0].cbData;
    prid->Issuer.pbData = sizeof(*prid) + (LPBYTE) prid;
    memcpy(prid->Issuer.pbData, pseq->rgValue[0].pbData, prid->Issuer.cbData);

    prid->SerialNumber.cbData = pInt->cbData;
    prid->SerialNumber.pbData = prid->Issuer.pbData + prid->Issuer.cbData;
    memcpy(prid->SerialNumber.pbData, pInt->pbData, pInt->cbData);

    fRet = TRUE;
    
Exit:
    if (pInt != NULL) LocalFree(pInt);
    if (pseq != NULL) LocalFree(pseq);
    return fRet;
}

////////////////////////////////////////////////////////////////////////////

extern const GUID rgguidActions[] = {
    CERT_CERTIFICATE_ACTION_VERIFY
};

#define REGSTR_PATH_SERVICES    "System\\CurrentControlSet\\Services"

#ifdef NT5BUILD
#else  // NT5BUILD
const char      SzRegPath[] = REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Email Trust";
const char      SzActionIds[] = "$ActionIDs";
const char      SzDllName[] = "$DLL";
#endif // !NT5BUILD

extern const GUID GuidCertValidate = CERT_CERTIFICATE_ACTION_VERIFY;


#ifndef MAC
STDAPI DllRegisterServer(void)
{
#ifdef NT5BUILD
    HRESULT     hr = S_OK;
#else  // !NT5BUILD
    DWORD       dwDisposition;
    HKEY        hkey;
    UINT        cchSystemDir;
    BOOL        fIsWinNt = FALSE;       // M00BUG
    HRESULT     hr = S_OK;
    LPSTR       psz;
    CHAR        rgchLibName[] = "cryptdlg.dll";
    CHAR        rgchPathName[MAX_PATH + sizeof(rgchLibName)];
#endif // NT5BUILD


    //
    //  First we register the funny one time function which is currently
    //  hard-coded to go to a fixed verisign statement.  This should be removed
    //  if we can get a general purpose one running.
    //

#ifndef WIN16
    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  "2.5.29.32",
                                  L"cryptdlg.dll",
                                  "FormatVerisignExtension")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  szOID_PKIX_KP_EMAIL_PROTECTION,
                                  L"cryptdlg.dll",
                                  "FormatPKIXEmailProtection")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  L"cryptdlg.dll",
                                  "EncodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  L"cryptdlg.dll",
                                  "DecodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING, 
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  szOID_MICROSOFT_Encryption_Key_Preference,
                                  L"cryptdlg.dll", "EncodeRecipientID")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING, 
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  szOID_MICROSOFT_Encryption_Key_Preference,
                                  L"cryptdlg.dll", "DecodeRecipientID")) {
        return E_FAIL;
    }

#else
    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  "2.5.29.32",
                                  "cryptdlg.dll",
                                  "FormatVerisignExtension")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  szOID_PKIX_KP_EMAIL_PROTECTION,
                                  "cryptdlg.dll",
                                  "FormatPKIXEmailProtection")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  "cryptdlg.dll",
                                  "EncodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  "cryptdlg.dll",
                                  "DecodeAttrSequence")) {
        return E_FAIL;
    }
#endif // !WIN16


#ifdef NT5BUILD
    CRYPT_REGISTER_ACTIONID     regdata;
    regdata.cbStruct = sizeof(regdata);
    regdata.sInitProvider.cbStruct = sizeof(regdata.sInitProvider);
    regdata.sInitProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sInitProvider.pwszFunctionName = L"CertTrustInit";

    regdata.sObjectProvider.cbStruct = sizeof(regdata.sObjectProvider);
    regdata.sObjectProvider.pwszDLLName = NULL;
    regdata.sObjectProvider.pwszFunctionName = NULL;

    regdata.sSignatureProvider.cbStruct = sizeof(regdata.sSignatureProvider);
    regdata.sSignatureProvider.pwszDLLName = NULL;
    regdata.sSignatureProvider.pwszFunctionName = NULL;

    regdata.sCertificateProvider.cbStruct = sizeof(regdata.sCertificateProvider);
    regdata.sCertificateProvider.pwszDLLName = WT_PROVIDER_DLL_NAME;
    regdata.sCertificateProvider.pwszFunctionName = WT_PROVIDER_CERTTRUST_FUNCTION;

    regdata.sCertificatePolicyProvider.cbStruct = sizeof(regdata.sCertificatePolicyProvider);
    regdata.sCertificatePolicyProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sCertificatePolicyProvider.pwszFunctionName = L"CertTrustCertPolicy";

    regdata.sFinalPolicyProvider.cbStruct = sizeof(regdata.sFinalPolicyProvider);
    regdata.sFinalPolicyProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sFinalPolicyProvider.pwszFunctionName = L"CertTrustFinalPolicy";

    regdata.sTestPolicyProvider.cbStruct = sizeof(regdata.sTestPolicyProvider);
    regdata.sTestPolicyProvider.pwszDLLName = NULL;
    regdata.sTestPolicyProvider.pwszFunctionName = NULL;

    regdata.sCleanupProvider.cbStruct = sizeof(regdata.sCleanupProvider);
    regdata.sCleanupProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sCleanupProvider.pwszFunctionName = L"CertTrustCleanup";

    WintrustAddActionID((GUID *) &GuidCertValidate, 0, &regdata);
#else  // !NT5BUILD
    //
    //  Next register the fact that we are also a wintrust provider for
    //  validating certificates
    //

    hr = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SzRegPath, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                         &hkey, &dwDisposition);
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }

    // BUGBUG Win95 does not support REG_EXPAND_SZ, so we must do it
    if (fIsWinNt) {
        psz = "%SystemRoot%\\system32\\cryptdlg.dll";
    }
    else {
        //  Compose the path as <system_dir>\cryptdlg.dll
#ifndef WIN16
        cchSystemDir = GetSystemDirectoryA(rgchPathName, MAX_PATH);
#else
        cchSystemDir = GetSystemDirectory(rgchPathName, MAX_PATH);
#endif // !WIN16
        if (cchSystemDir == 0) {
            hr = E_FAIL;
            goto RetHere;
        }
        else if (cchSystemDir > MAX_PATH) {
            hr = ERROR_INSUFFICIENT_BUFFER;
            goto RetHere;
        }

        rgchPathName[cchSystemDir] = '\\';      // system dir can't be a root
        StrCpyN(&rgchPathName[cchSystemDir+1], rgchLibName, ARRAYSIZE(rgchPathName)-(cchSystemDir+1));
        psz = rgchPathName;
    }

#ifndef WIN16
    hr = RegSetValueExA(hkey, SzDllName, 0, fIsWinNt ? REG_EXPAND_SZ : REG_SZ,
                        (LPBYTE) psz, strlen(psz)+1);
#else
    hr = RegSetValueExA(hkey, SzDllName, 0, REG_SZ, (LPBYTE) psz, strlen(psz)+1);
#endif // !WIN16
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }

    hr = RegSetValueExA(hkey, SzActionIds, 0, REG_BINARY,
                        (LPBYTE) rgguidActions, sizeof(rgguidActions));
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }


RetHere:
    // NB - Don't do RegCloseKey on these hkey's since we want to be small
    //      and this code is only ever called by REGSRV32.EXE, so we don't
    //      care about a minor leak.

#endif // NT5BUILD
    return hr;
}

STDAPI DllUnregisterServer(void)
{
#ifndef NT5BUILD
    DWORD       dw;
    HKEY        hkey;
#endif // NT5BUILD
    HRESULT     hr = S_OK;

    //
    //  Unregister the formatting routine we wrote
    //

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_FORMAT_OBJECT_FUNC,
                                    "2.5.29.32")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_FORMAT_OBJECT_FUNC,
                                    szOID_PKIX_KP_EMAIL_PROTECTION)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                    "1.3.6.1.4.1.311.16.1.1")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                    "1.3.6.1.4.1.311.16.1.1")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                    szOID_MICROSOFT_Encryption_Key_Preference)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                    szOID_MICROSOFT_Encryption_Key_Preference)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }


#ifdef NT5BUILD
    WintrustRemoveActionID((GUID *) &GuidCertValidate);
#else  // !NT5BUILD
    //
    //  Now unregister the WinTrust provider
    //

    hr = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SzRegPath, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw);
    if (FAILED(hr)) {
        goto RetHere;
    }

    RegDeleteValueA(hkey, SzDllName);
    RegDeleteValueA(hkey, SzActionIds);


RetHere:
    // NB - Don't do RegCloseKey on these hkey's since we want to be small
    //      and this code is only ever called by REGSRV32.EXE, so we don't
    //      care about a minor leak.
#endif // NT5BUILD

    return hr;
}
#else   // MAC

/***
*wchar_t *wcsstr(string1, string2) - search for string2 in string1
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl WchCryptDlgWcsStr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                while ( *s1 && *s2 && !(*s1-*s2) )
                        s1++, s2++;

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}
#endif  // !MAC


///////////////////////////////////////////////////////////////////////

LPVOID PVCryptDecode(LPCSTR szOid, DWORD cbEncode, LPBYTE pbEncode)
{
    DWORD       cbData;
    BOOL        f;
    LPVOID      pv;

    f = CryptDecodeObject(X509_ASN_ENCODING, szOid, pbEncode, cbEncode,
                          0, NULL, &cbData);
    if (!f) {
        return NULL;
    }

    pv = malloc(cbData);
    if (pv == NULL) {
        return NULL;
    }

    f = CryptDecodeObject(X509_ASN_ENCODING, szOid, pbEncode, cbEncode,
                          0, pv, &cbData);
    if (!f) {
        free(pv);
        return NULL;
    }

    return pv;
}

void * __cdecl operator new(size_t cb )
{
    LPVOID  lpv = 0;

    lpv = malloc(cb);
    if (lpv)
    {
        memset(lpv, 0, cb);
    }
    return lpv;
}

void __cdecl operator delete(LPVOID pv )
{
    free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\build\makefile.inc ===
$O\directdb.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\build\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\wxptrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       wxptrust.cpp
//
//  Contents:   Windows XP version of the Outlook WinVerify Trust Provider
//
//  Functions:  WXP_CertTrustDllMain
//              CertTrustInit
//              CertTrustCertPolicy     - shouldn't be called
//              CertTrustFinalPolicy
//              CertTrustCleanup        - shouldn't be called
//
//              CertModifyCertificatesToTrust
//              FModifyTrust
//              FreeWVTHandle
//              HrDoTrustWork
//              FormatValidityFailures
//
//  History:    11-Feb-2001 philh      created (rewrite to use chain APIs)
//
//--------------------------------------------------------------------------
#include "pch.hxx"
#include <wintrust.h>
#include "demand.h"
#include <stdio.h>

// The following should be moved to cryptdlg.h

#define CERT_VALIDITY_POLICY_FAILURE            0x00001000
#define CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE 0x00002000

const char SzPolicyKey[] = 
    "SOFTWARE\\Microsoft\\Cryptography\\" szCERT_CERTIFICATE_ACTION_VERIFY;
const char SzPolicyData[] = "PolicyFlags";
const char SzUrlRetrievalTimeoutData[] = "UrlRetrievalTimeout"; // milliseconds


#define EXPLICIT_TRUST_NONE     0
#define EXPLICIT_TRUST_YES      1
#define EXPLICIT_TRUST_NO       2

#define MAX_HASH_LEN            20
#define MIN_HASH_LEN            16


// ExplictTrust is encoded as a SEQUENCE OF Attribues. We are only
// interested in encoding one attribute with one value. We will only change
// the last byte. It contains the trust value. It can be: 0-NONE, 1-YES, 2-NO.
const BYTE rgbEncodedExplictTrust[] = {
    0x30, 0x13,             // SEQUENCE OF
      0x30, 0x11,           //   SEQUENCE
        0x06, 0x0a,         //     OID: 1.3.6.1.4.1.311.10.4.1
          0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x04, 0x01,
        0x31, 0x03,         //     SET OF
          0x02, 0x01, 0x00  //       INTEGER: 0-NONE, 1-YES, 2-NO
};

HINSTANCE g_hCertTrustInst;
HCERTSTORE g_hStoreTrustedPeople;
HCERTSTORE g_hStoreDisallowed;

// Cached Chain. We remember the last built chain context and try to re-use.
// Outlook calls us 2 or 3 times to build a chain for the same certificate
// context.
CRITICAL_SECTION g_CachedChainCriticalSection;
DWORD g_dwCachedCreateChainFlags;
PCCERT_CHAIN_CONTEXT g_pCachedChainContext;
FILETIME g_ftCachedChain;

#define CACHED_CHAIN_SECONDS_DURATION   30

BOOL
WINAPI
WXP_CertTrustDllMain(
    HINSTANCE hInst,
    ULONG ulReason,
    LPVOID
    )
{
    BOOL fResult = TRUE;

    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            g_hCertTrustInst = hInst;

            __try {
                InitializeCriticalSection(&g_CachedChainCriticalSection);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(GetExceptionCode());
                fResult = FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_hStoreTrustedPeople)
                CertCloseStore(g_hStoreTrustedPeople, 0);
            if (g_hStoreDisallowed)
                CertCloseStore(g_hStoreDisallowed, 0);

            if (g_pCachedChainContext)
                CertFreeCertificateChain(g_pCachedChainContext);
            DeleteCriticalSection(&g_CachedChainCriticalSection);
            break;
        case DLL_THREAD_DETACH:
        default:
            break;
    }
    
    return fResult;
}

HCERTSTORE
I_OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    hStore = *phStoreCache;
    if (NULL == hStore) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                CERT_STORE_SHARE_CONTEXT_FLAG,
            (const void *) pwszStore
            );

        if (hStore) {
            HCERTSTORE hPrevStore;

            CertControlStore(
                hStore,
                0,                  // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL                // pvCtrlPara
                );

            hPrevStore = InterlockedCompareExchangePointer(
                phStoreCache, hStore, NULL);

            if (hPrevStore) {
                CertCloseStore(hStore, 0);
                hStore = hPrevStore;
            }
        }
    }

    if (hStore)
        hStore = CertDuplicateStore(hStore);

    return hStore;
}

HCERTSTORE
I_OpenTrustedPeopleStore()
{
    return I_OpenCachedHKCUStore(&g_hStoreTrustedPeople, L"TrustedPeople");
}

HCERTSTORE
I_OpenDisallowedStore()
{
    return I_OpenCachedHKCUStore(&g_hStoreDisallowed, L"Disallowed");
}

// We use signature hash. For untrusted, this will find certificates with
// altered signature content.
PCCERT_CONTEXT
I_FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

// Returns:
//   +1 - Cert was successfully deleted
//    0 - Cert wasn't found
//   -1 - Delete failed     (GetLastError() for failure reason)
//
LONG
I_DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    LONG lDelete;
    PCCERT_CONTEXT pOtherCert;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
        return 0;

    // Note, there is a possibility that multiple certs can have
    // the same signature hash. For example, the signature algorithm
    // parameters may have been altered. Change empty NULL : {0x05, 0x00} to
    // empty OCTET : {0x04, 0x00}.
    lDelete = 0;
    pOtherCert = NULL;
    while (pOtherCert = CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            pOtherCert
            )) {
        CertDuplicateCertificateContext(pOtherCert);
        if (CertDeleteCertificateFromStore(pOtherCert)) {
            if (0 == lDelete)
                lDelete = 1;
        } else
            lDelete = -1;
    }

    return lDelete;
}



HRESULT
I_CheckExplicitTrust(
    IN PCCERT_CONTEXT pCert,
    IN LPFILETIME pftCurrent,
    OUT BYTE *pbExplicitTrust
    )
{
    HRESULT hr;
    BYTE bExplicitTrust = EXPLICIT_TRUST_NONE;
    HCERTSTORE hStoreDisallowed = NULL;
    HCERTSTORE hStoreTrustedPeople = NULL;
    PCCERT_CONTEXT pFindCert = NULL;

    hStoreDisallowed = I_OpenDisallowedStore();
    if (NULL == hStoreDisallowed)
        goto OpenDisallowedStoreError;

    pFindCert = I_FindCertificateInOtherStore(hStoreDisallowed, pCert);
    if (pFindCert) {
        bExplicitTrust = EXPLICIT_TRUST_NO;
        goto SuccessReturn;
    }

    hStoreTrustedPeople = I_OpenTrustedPeopleStore();
    if (NULL == hStoreTrustedPeople)
        goto SuccessReturn;

    pFindCert = I_FindCertificateInOtherStore(hStoreTrustedPeople, pCert);
    if (pFindCert) {
        // Must be time valid to trust
        if (0 == CertVerifyTimeValidity(pftCurrent, pCert->pCertInfo))
            bExplicitTrust = EXPLICIT_TRUST_YES;
        else
            // Remove the expired cert. Just in case there are
            // altered certificates having the same signature hash, do
            // the following delete.
            I_DeleteCertificateFromOtherStore(hStoreTrustedPeople, pFindCert);
    }

SuccessReturn:
    hr = S_OK;
CommonReturn:
    if (pFindCert)
        CertFreeCertificateContext(pFindCert);
    if (hStoreDisallowed)
        CertCloseStore(hStoreDisallowed, 0);
    if (hStoreTrustedPeople)
        CertCloseStore(hStoreTrustedPeople, 0);

    *pbExplicitTrust = bExplicitTrust;
    return hr;

OpenDisallowedStoreError:
    // Most likely unable to access
    hr = E_ACCESSDENIED;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Subtract two filetimes and return the number of seconds.
//
//  The second filetime is subtracted from the first. If the first filetime
//  is before the second, then, 0 seconds is returned.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_SubtractFileTimes(
    IN LPFILETIME pftFirst,
    IN LPFILETIME pftSecond
    )
{
    DWORDLONG qwDiff;

    if (0 >= CompareFileTime(pftFirst, pftSecond))
        return 0;

    qwDiff = *(((DWORDLONG UNALIGNED *) pftFirst)) -
        *(((DWORDLONG UNALIGNED *) pftSecond));

    return (DWORD) (qwDiff / 10000000i64);
}

PCCERT_CHAIN_CONTEXT
I_CheckCachedChain(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwCreateChainFlags
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    FILETIME ftCurrent;

    EnterCriticalSection(&g_CachedChainCriticalSection);

    if (NULL == g_pCachedChainContext)
        goto CommonReturn;

    if (g_pCachedChainContext->rgpChain[0]->rgpElement[0]->pCertContext !=
            pCert)
        goto CommonReturn;

    if (dwCreateChainFlags == g_dwCachedCreateChainFlags)
        ;
    else {
        if ((dwCreateChainFlags & g_dwCachedCreateChainFlags) !=
                dwCreateChainFlags)
            goto CommonReturn;

        if (g_pCachedChainContext->TrustStatus.dwErrorStatus &
                (CERT_TRUST_IS_REVOKED | CERT_TRUST_REVOCATION_STATUS_UNKNOWN))
            goto CommonReturn;
    }

    GetSystemTimeAsFileTime(&ftCurrent);
    if (CACHED_CHAIN_SECONDS_DURATION <
            I_SubtractFileTimes(&ftCurrent, &g_ftCachedChain)) {
        CertFreeCertificateChain(g_pCachedChainContext);
        g_pCachedChainContext = NULL;
        goto CommonReturn;
    }

    pChainContext = CertDuplicateCertificateChain(g_pCachedChainContext);
    

CommonReturn:
    LeaveCriticalSection(&g_CachedChainCriticalSection);
    return pChainContext;
}

void
I_SetCachedChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwCreateChainFlags
    )
{
    if (pChainContext->TrustStatus.dwErrorStatus &
            (CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_IS_PARTIAL_CHAIN))
        return;

    EnterCriticalSection(&g_CachedChainCriticalSection);

    if (g_pCachedChainContext)
        CertFreeCertificateChain(g_pCachedChainContext);

    g_pCachedChainContext = CertDuplicateCertificateChain(pChainContext);
    g_dwCachedCreateChainFlags = dwCreateChainFlags;
    GetSystemTimeAsFileTime(&g_ftCachedChain);


    LeaveCriticalSection(&g_CachedChainCriticalSection);
}


// Assumption: the message store is included in the rghstoreCAs array.
// Will ignore the rghstoreRoots and rghstoreTrust store arrays. These
// certs should already be opened and cached in the chain engine.
HCERTSTORE
I_GetChainAdditionalStore(
    IN PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust
    )
{
    if (0 == pCertTrust->cStores)
        return NULL;

    if (1 < pCertTrust->cStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pCertTrust->cStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pCertTrust->rghstoreCAs[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pCertTrust->rghstoreCAs[0]);
}


HRESULT
I_BuildChain(
    IN PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust,
    IN LPFILETIME pftCurrent,
    IN DWORD dwPolicy,
    IN DWORD dwUrlRetrievalTimeout,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    HRESULT hr;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwCreateChainFlags = 0;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore = NULL;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;

    // Update the revocation flags to be used for chain building
    if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_ONLINE) {
        // Allow full online revocation checking
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_CACHE) {
        // Allow local revocation checks only, do not hit the network.
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN |
            CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    } else if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_NONE) {
        ;
    } else if (dwPolicy & ACTION_REVOCATION_DEFAULT_ONLINE) {
        // Allow full online revocation checking
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE) {
        // Allow local revocation checks only, do not hit the network
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN |
            CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }

    // Enable LRU caching of the end certificate. Also, set an upper limit
    // for all CRL URL fetches.
    dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT |
        CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT;

    pChainContext = I_CheckCachedChain(
        pCertTrust->pccert,
        dwCreateChainFlags
        );
    if (NULL != pChainContext)
        goto SuccessReturn;
    
    if (pCertTrust->hprov != NULL) {
        // Set the default crypt provider so we can make sure that ours is used
        if (!CryptInstallDefaultContext(pCertTrust->hprov, 
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                szOID_OIWSEC_md5RSA, 0, NULL, &hDefaultContext))
            goto InstallDefaultContextError;
    }

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (pCertTrust->pszUsageOid && '\0' != pCertTrust->pszUsageOid[0]) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
            &pCertTrust->pszUsageOid;
    }
    ChainPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;

    hAdditionalStore = I_GetChainAdditionalStore(pCertTrust);


    if (!CertGetCertificateChain (
            HCCE_CURRENT_USER,
            pCertTrust->pccert,
            pftCurrent,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            ))
        goto GetChainError;

    I_SetCachedChain(pChainContext, dwCreateChainFlags);

SuccessReturn:
    hr = S_OK;
CommonReturn:
    if (hDefaultContext)
        CryptUninstallDefaultContext(hDefaultContext, 0, NULL);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);

    *ppChainContext = pChainContext;

    return hr;

GetChainError:
InstallDefaultContextError:
    pChainContext = NULL;
    hr = TRUST_E_SYSTEM_ERROR;
    goto CommonReturn;
}

DWORD
I_MapValidityErrorsToTrustError(
    IN DWORD dwErrors
    )
{
    DWORD dwTrustError = S_OK;

    // Look at them in decreasing order of importance
    if (dwErrors) {
        if (dwErrors & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            dwTrustError = TRUST_E_EXPLICIT_DISTRUST;
        } else if (dwErrors & CERT_VALIDITY_SIGNATURE_FAILS) {
            dwTrustError = TRUST_E_CERT_SIGNATURE;
        } else if (dwErrors & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
            dwTrustError = CERT_E_CHAINING;
        } else if (dwErrors & CERT_VALIDITY_NO_TRUST_DATA) {
            dwTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwErrors & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            dwTrustError = CERT_E_REVOKED;
        } else if (dwErrors & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
            dwTrustError = CERT_E_WRONG_USAGE;
        } else if (dwErrors & 
                (CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END)) {
            dwTrustError = CERT_E_EXPIRED;
        } else if (dwErrors & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
            dwTrustError = CERT_E_INVALID_NAME;
        } else if (dwErrors & CERT_VALIDITY_POLICY_FAILURE) {
            dwTrustError = CERT_E_INVALID_POLICY;
        } else if (dwErrors & CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE) {
            dwTrustError = TRUST_E_BASIC_CONSTRAINTS;
        } else if (dwErrors & CERT_VALIDITY_NO_CRL_FOUND) {
            dwTrustError = CERT_E_REVOCATION_FAILURE;
        } else if (dwErrors & (CERT_VALIDITY_ISSUER_INVALID |
                CERT_VALIDITY_ISSUER_DISTRUST)) {
            dwTrustError = CERT_E_UNTRUSTEDROOT;
        } else {
            dwTrustError = TRUST_E_FAIL;
        }
    }

    return dwTrustError;
}

HRESULT
I_UpdateCertProvFromExplicitTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwAllErrors
    )
{
    CRYPT_PROVIDER_SGNR Sgnr;
    PCRYPT_PROVIDER_SGNR pSgnr;
    PCRYPT_PROVIDER_CERT pProvCert;

    memset(&Sgnr, 0, sizeof(Sgnr));
    Sgnr.cbStruct = sizeof(Sgnr);

    if (!pProvData->psPfns->pfnAddSgnr2Chain(
            pProvData,
            FALSE,              // fCounterSigner
            0,                  // idwSigner
            &Sgnr
            ))
        return TRUST_E_SYSTEM_ERROR;

    if (!pProvData->psPfns->pfnAddCert2Chain(
            pProvData,
            0,                  // idxSigner
            FALSE,              // fCounterSigner
            0,                  // idxCounterSigner
            pCert
            ))
        return TRUST_E_SYSTEM_ERROR;

    pSgnr = WTHelperGetProvSignerFromChain(
        pProvData,
        0,                      // idxSigner
        FALSE,                  // fCounterSigner
        0                       // idxCounterSigner
        );
    if (NULL == pSgnr)
        return TRUST_E_SYSTEM_ERROR;

    pProvCert = WTHelperGetProvCertFromChain(
        pSgnr,
        0                       // idxCert
        );
    if (NULL == pProvCert)
        return TRUST_E_SYSTEM_ERROR;

    pSgnr->dwError = pProvCert->dwError =
        I_MapValidityErrorsToTrustError(dwAllErrors);

    // Map to IE4Trust confidence
    pProvCert->dwConfidence |=
        CERT_CONFIDENCE_SIG |
        CERT_CONFIDENCE_TIMENEST |
        CERT_CONFIDENCE_AUTHIDEXT |
        CERT_CONFIDENCE_HYGIENE
        ;

    if (!(dwAllErrors &
            (CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END)))
        pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

    return S_OK;
}

HRESULT
I_UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD cTrustCert,
    IN DWORD rgdwErrors[],
    IN DWORD dwAllErrors
    )
{
    CRYPT_PROVIDER_SGNR Sgnr;
    PCRYPT_PROVIDER_SGNR pSgnr;
    DWORD iTrustCert;
    DWORD i;

    memset(&Sgnr, 0, sizeof(Sgnr));
    Sgnr.cbStruct = sizeof(Sgnr);

    if (!pProvData->psPfns->pfnAddSgnr2Chain(
            pProvData,
            FALSE,              // fCounterSigner
            0,                  // idwSigner
            &Sgnr
            ))
        return TRUST_E_SYSTEM_ERROR;

    pSgnr = WTHelperGetProvSignerFromChain(
        pProvData,
        0,                      // idxSigner
        FALSE,                  // fCounterSigner
        0                       // idxCounterSigner
        );
    if (NULL == pSgnr)
        return TRUST_E_SYSTEM_ERROR;

    pSgnr->pChainContext = CertDuplicateCertificateChain(pChainContext);
    pSgnr->dwError = I_MapValidityErrorsToTrustError(dwAllErrors);

    iTrustCert = 0;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
            DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
            DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
            PCRYPT_PROVIDER_CERT pProvCert;

            if (iTrustCert >= cTrustCert)
                return TRUST_E_SYSTEM_ERROR;

            if (!pProvData->psPfns->pfnAddCert2Chain(
                    pProvData,
                    0,                  // idxSigner
                    FALSE,              // fCounterSigner
                    0,                  // idxCounterSigner
                    pEle->pCertContext
                    ))
                return TRUST_E_SYSTEM_ERROR;

            pProvCert = WTHelperGetProvCertFromChain(
                pSgnr,
                iTrustCert
                );
            if (NULL == pProvCert)
                return TRUST_E_SYSTEM_ERROR;

            //DSIE: 12-Oct-2000 added pChainElement to CRYPT_PROVIDER_CERT.
            if (WVT_ISINSTRUCT(CRYPT_PROVIDER_CERT, pProvCert->cbStruct,
                    pChainElement))
                pProvCert->pChainElement = pEle;

            pProvCert->fSelfSigned =
                0 != (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) &&
                0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID);

            pProvCert->fTrustedRoot =
                pProvCert->fSelfSigned &&
                i == pChainContext->cChain - 1 &&
                j == pChain->cElement - 1 &&
                0 == (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT);


            // First Element in all but the first simple chain
            pProvCert->fTrustListSignerCert = (0 < i && 0 == j);

            pProvCert->fIsCyclic = (0 != (dwEleError & CERT_TRUST_IS_CYCLIC));

            // Map to IE4Trust confidence
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_SIG;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

            // On Sep 10, 1998 Trevor/Brian wanted time nesting checks to
            // be disabled
            // if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_NESTED))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIMENEST;

            if (0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_AUTHIDEXT;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
                    0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_HYGIENE;

            if (pEle->pRevocationInfo) {
                pProvCert->dwRevokedReason =
                    pEle->pRevocationInfo->dwRevocationResult;
            }

            pProvCert->dwError = I_MapValidityErrorsToTrustError(
                rgdwErrors[iTrustCert]);

            // If last element in simple chain, check if it was in a
            // CTL and update CryptProvData if it was.
            if (j == pChain->cElement - 1 && pChain->pTrustListInfo &&
                    pChain->pTrustListInfo->pCtlContext) {
                DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

                // Note, don't need to AddRef since we already hold an
                // AddRef on the ChainContext.
                pProvCert->pCtlContext = pChain->pTrustListInfo->pCtlContext;

                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) {
                    pProvCert->dwCtlError = TRUST_E_CERT_SIGNATURE;
                } else if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
                    pProvCert->dwCtlError = CERT_E_EXPIRED;
                } else if (dwChainError &
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) {
                    pProvCert->dwCtlError = CERT_E_WRONG_USAGE;
                }
            }

            iTrustCert++;
        }
    }

    return S_OK;
}

HRESULT
CertTrustFinalPolicy(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;
    PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust;
    DWORD dwPolicy = 0;
    DWORD dwUrlRetrievalTimeout = 0;
    FILETIME ftCurrent;
    BYTE bExplicitTrust = EXPLICIT_TRUST_NONE;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD cTrustCert = 0;
    PCCERT_CONTEXT *rgpTrustCert = NULL;
    DWORD *rgdwErrors = NULL;
    DATA_BLOB *rgBlobTrustInfo = NULL;
    DWORD dwAllErrors = 0;

    // Verify we are called by a version of WVT having all of the fields we will
    // be using.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError))
        return E_INVALIDARG;

    // Continue checking that we have everything we need.
    if (pProvData->pWintrustData->pBlob->cbStruct <
            sizeof(WINTRUST_BLOB_INFO))
        goto InvalidProvData;

    pCertTrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pProvData->pWintrustData->pBlob->pbMemObject;
    if ((pCertTrust == NULL) ||
            (pCertTrust->cbSize < sizeof(*pCertTrust)))
        goto InvalidProvData;

    // If present, retrieve policy flags and URL retrieval timeout from
    // the registry
    {
        HKEY hKeyPolicy;

        if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey,
                0, KEY_READ, &hKeyPolicy)) {
            DWORD dwType;
            DWORD cbSize;

            cbSize = sizeof(dwPolicy);
            if (ERROR_SUCCESS != RegQueryValueExA(hKeyPolicy, SzPolicyData, 
                    0, &dwType, (LPBYTE) &dwPolicy, &cbSize)
                            || 
                    REG_DWORD != dwType)
                dwPolicy = 0;

            cbSize = sizeof(dwUrlRetrievalTimeout);
            if (ERROR_SUCCESS != RegQueryValueExA(
                    hKeyPolicy, SzUrlRetrievalTimeoutData, 
                    0, &dwType, (LPBYTE) &dwUrlRetrievalTimeout, &cbSize)
                            || 
                    REG_DWORD != dwType)
                dwUrlRetrievalTimeout = 0;

            RegCloseKey(hKeyPolicy);
        }
    }

    // Get current time to be used
    GetSystemTimeAsFileTime(&ftCurrent);

    hr = I_CheckExplicitTrust(
        pCertTrust->pccert,
        &ftCurrent,
        &bExplicitTrust
        );
    if (S_OK != hr)
        goto CheckExplicitTrustError;

    if (EXPLICIT_TRUST_NONE != bExplicitTrust) {
        // No need to build the chain, the trust decision has already been
        // made
        cTrustCert = 1;
    } else {
        DWORD i;

        hr = I_BuildChain(
            pCertTrust,
            &ftCurrent,
            dwPolicy,
            dwUrlRetrievalTimeout,
            &pChainContext
            );
        if (S_OK != hr)
            goto BuildChainError;

        cTrustCert = 0;
        for (i = 0; i < pChainContext->cChain; i++)
            cTrustCert += pChainContext->rgpChain[i]->cElement;

        if (0 == cTrustCert)
            goto InvalidChainContext;
    }

    // Allocate the memory to contain the errors for each cert in the chain
    rgdwErrors = (DWORD *) LocalAlloc(
        LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(DWORD));
    if (NULL == rgdwErrors)
        goto OutOfMemory;

    // If the caller requests the chain certs and/or the encoded trust
    // information, then, allocate the arrays
    if (pCertTrust->prgChain) {
        rgpTrustCert = (PCCERT_CONTEXT *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(PCCERT_CONTEXT));
        if (NULL == rgpTrustCert)
            goto OutOfMemory;
    }

    if (pCertTrust->prgpbTrustInfo) {
        rgBlobTrustInfo = (DATA_BLOB *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(DATA_BLOB));
        if (NULL == rgBlobTrustInfo)
            goto OutOfMemory;
    }

    if (EXPLICIT_TRUST_NONE != bExplicitTrust) {
        // We have a single cert without a chain

        if (rgpTrustCert)
            rgpTrustCert[0] =
                CertDuplicateCertificateContext(pCertTrust->pccert);

        if (rgBlobTrustInfo) {
            // Update the returned encoded trust info

            const DWORD cb = sizeof(rgbEncodedExplictTrust);
            BYTE *pb;

            pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pb)
                goto OutOfMemory;
            memcpy(pb, rgbEncodedExplictTrust, cb);
            pb[cb-1] = bExplicitTrust;
            rgBlobTrustInfo[0].cbData = cb;
            rgBlobTrustInfo[0].pbData = pb;
        }

        if (EXPLICIT_TRUST_YES != bExplicitTrust) {
            LONG lValidity;

            dwAllErrors |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;

            lValidity = CertVerifyTimeValidity(&ftCurrent,
                pCertTrust->pccert->pCertInfo);
            if (0 > lValidity)
                dwAllErrors |= CERT_VALIDITY_BEFORE_START;
            else if (0 < lValidity)
                dwAllErrors |= CERT_VALIDITY_AFTER_END;
        }

        dwAllErrors &= ~pCertTrust->dwIgnoreErr;
        rgdwErrors[0] = dwAllErrors;

        if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
            hr = I_UpdateCertProvFromExplicitTrust(
                pProvData,
                pCertTrust->pccert,
                dwAllErrors
                );
            if (S_OK != hr)
                goto UpdateCertProvFromExplicitTrustError;
        }

    } else {
        DWORD i;
        DWORD iTrustCert = 0;

        // Get the cert trust info from the chain context elements
        for (i = 0; i < pChainContext->cChain; i++) {
            DWORD j;
            PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];
            DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

            for (j = 0; j < pChain->cElement; j++) {
                PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
                DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
                DWORD dwErrors = 0;

                if (iTrustCert >= cTrustCert)
                    goto InvalidChainContext;

                if (0 != dwEleError) {
                    if (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID) {
                        // Check if after or before
                        if (0 > CertVerifyTimeValidity(&ftCurrent,
                                pEle->pCertContext->pCertInfo))
                            dwErrors |= CERT_VALIDITY_BEFORE_START;
                        else
                            dwErrors |= CERT_VALIDITY_AFTER_END;
                    }

                    if (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID)
                        dwErrors |= CERT_VALIDITY_SIGNATURE_FAILS;

                    if (dwEleError & CERT_TRUST_IS_REVOKED) {
                        dwErrors |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                    } else if (dwEleError & CERT_TRUST_IS_OFFLINE_REVOCATION)
                        dwErrors |= CERT_VALIDITY_NO_CRL_FOUND;

                    if (dwEleError & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)
                        dwErrors |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;

                    if (dwEleError &
                            (CERT_TRUST_INVALID_POLICY_CONSTRAINTS |
                                CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY))
                        // We added POLICY_FAILURE on 02-13-01
                        dwErrors |= CERT_VALIDITY_POLICY_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;

                    if (dwEleError & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
                        BOOL fEnableBasicConstraints = TRUE;

                        if (dwPolicy & POLICY_IGNORE_NON_CRITICAL_BC) {
                            // Disable if we don't have a critical extension

                            PCERT_EXTENSION pExt;
                            
                            pExt = CertFindExtension(
                                szOID_BASIC_CONSTRAINTS2,
                                pEle->pCertContext->pCertInfo->cExtension,
                                pEle->pCertContext->pCertInfo->rgExtension
                                );
                            if (NULL == pExt || !pExt->fCritical)
                                fEnableBasicConstraints = FALSE;
                        }

                        if (fEnableBasicConstraints)
                            // We added BASIC_CONSTRAINTS_FAILURE on 02-13-01
                            dwErrors |=
                                CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE |
                                CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    }

                    if (dwEleError & CERT_TRUST_INVALID_EXTENSION)
                        dwErrors |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;

                    if (dwEleError &
                            (CERT_TRUST_INVALID_NAME_CONSTRAINTS |
                                CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT))
                        dwErrors |= CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                }

                if (0 == j) {
                    // End cert
                    if (dwChainError & CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY)
                        // We added POLICY_FAILURE on 02-13-01
                        dwErrors |= CERT_VALIDITY_POLICY_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                }

                if (iTrustCert == cTrustCert - 1) {
                    // Top cert. Should be the root.
                    if (dwChainError & (CERT_TRUST_IS_PARTIAL_CHAIN |
                                CERT_TRUST_IS_CYCLIC))
                        dwErrors |= CERT_VALIDITY_NO_ISSUER_CERT_FOUND |
                            CERT_VALIDITY_NO_TRUST_DATA;
                    else if (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT)
                        dwErrors |= CERT_VALIDITY_NO_TRUST_DATA;
                    else if (NULL != rgBlobTrustInfo)
                        rgBlobTrustInfo[iTrustCert].pbData = (BYTE *) 1;
                }

                dwErrors &= ~pCertTrust->dwIgnoreErr;
                dwAllErrors |= dwErrors;

                rgdwErrors[iTrustCert] = dwErrors;
                if (rgpTrustCert)
                    rgpTrustCert[iTrustCert] =
                        CertDuplicateCertificateContext(pEle->pCertContext);
                iTrustCert++;
            }

            // CTL chain errors
            if (dwChainError &
                    (CERT_TRUST_CTL_IS_NOT_TIME_VALID |
                        CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID |
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)) {
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID)
                    dwAllErrors |= CERT_VALIDITY_AFTER_END;
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)
                    dwAllErrors |= CERT_VALIDITY_SIGNATURE_FAILS;
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)
                    dwAllErrors |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;

                dwAllErrors &= ~pCertTrust->dwIgnoreErr;
            }
        }

        
        if (dwAllErrors) {
            // If the issuer has errors, set an issuer error on the subject
            for (iTrustCert = cTrustCert - 1; iTrustCert > 0; iTrustCert--) {
                if (rgdwErrors[iTrustCert] & CERT_VALIDITY_MASK_VALIDITY)
                    rgdwErrors[iTrustCert - 1] |= CERT_VALIDITY_ISSUER_INVALID;
                if (rgdwErrors[iTrustCert] & CERT_VALIDITY_MASK_TRUST)
                    rgdwErrors[iTrustCert - 1] |= CERT_VALIDITY_ISSUER_DISTRUST;

                rgdwErrors[iTrustCert - 1] &= ~pCertTrust->dwIgnoreErr;
                dwAllErrors |= rgdwErrors[iTrustCert - 1];
            }
        }

        if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
            hr = I_UpdateCertProvChain(
                pProvData,
                pChainContext,
                cTrustCert,
                rgdwErrors,
                dwAllErrors
                );
            if (S_OK != hr)
                goto UpdateCertProvChainError;
        }

    }

    pProvData->dwFinalError = I_MapValidityErrorsToTrustError(dwAllErrors);

    switch (pProvData->dwFinalError) {
        // For backwards compatibility, only the following HRESULTs are
        // returned.
        case S_OK:
//        case TRUST_E_CERT_SIGNATURE:
//        case CERT_E_REVOKED:
//        case CERT_E_REVOCATION_FAILURE:
            hr = pProvData->dwFinalError;
            break;
        default:
            hr = S_FALSE;
    }

    // Update the returned cert trust info

    if (NULL != pCertTrust->pdwErrors) {
        *pCertTrust->pdwErrors = dwAllErrors;
    }

    if (NULL != pCertTrust->pcChain) {
        *pCertTrust->pcChain = cTrustCert;
    }
    if (NULL != pCertTrust->prgChain) {
        *pCertTrust->prgChain = rgpTrustCert;
        rgpTrustCert = NULL;
    }
    if (NULL != pCertTrust->prgdwErrors) {
        *pCertTrust->prgdwErrors = rgdwErrors;
        rgdwErrors = NULL;
    }
    if (NULL != pCertTrust->prgpbTrustInfo) {
        *pCertTrust->prgpbTrustInfo = rgBlobTrustInfo;
        rgBlobTrustInfo = NULL;
    }

CommonReturn:
    if (pChainContext)
        CertFreeCertificateChain(pChainContext);

    if (NULL != rgpTrustCert) {
        DWORD i;

        for (i = 0; i < cTrustCert; i++) {
            if (NULL != rgpTrustCert[i])
                CertFreeCertificateContext(rgpTrustCert[i]);
        }
        LocalFree(rgpTrustCert);
    }

    if (NULL != rgBlobTrustInfo) {
        DWORD i;

        for (i = 0; i < cTrustCert; i++) {
            if (0 < rgBlobTrustInfo[i].cbData)
                LocalFree(rgBlobTrustInfo[i].pbData);
        }
        LocalFree(rgBlobTrustInfo);
    }

    if (NULL != rgdwErrors)
        LocalFree(rgdwErrors);

    return hr;


CheckExplicitTrustError:
BuildChainError:
UpdateCertProvFromExplicitTrustError:
UpdateCertProvChainError:
ErrorReturn:
    if (SUCCEEDED(hr))
        hr = TRUST_E_SYSTEM_ERROR;
    goto CommonReturn;

InvalidProvData:
    hr = E_INVALIDARG;
    goto ErrorReturn;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto ErrorReturn;

InvalidChainContext:
    hr = TRUST_E_SYSTEM_ERROR;
    goto ErrorReturn;
}

HRESULT
CertTrustInit(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    // Verify we are called by a version of WVT having all of the fields we will
    // be using.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError))
        return E_INVALIDARG;

    // We are going to do all of our stuff in the pfFinalPolicy
    // callback.  NULL all of the remaining provider callbacks to
    // inhibit them from being called.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_FUNCTIONS,
            pProvData->psPfns->cbStruct, pfnCleanupPolicy))
        return E_INVALIDARG;

    pProvData->psPfns->pfnObjectTrust = NULL;
    pProvData->psPfns->pfnSignatureTrust = NULL;
    pProvData->psPfns->pfnCertificateTrust = NULL;
    pProvData->psPfns->pfnFinalPolicy = CertTrustFinalPolicy;
    pProvData->psPfns->pfnCertCheckPolicy = NULL;
    pProvData->psPfns->pfnTestFinalPolicy = NULL;
    pProvData->psPfns->pfnCleanupPolicy = NULL;

    return S_OK;
}


// The following function should never be called.
BOOL
CertTrustCertPolicy(PCRYPT_PROVIDER_DATA, DWORD, BOOL, DWORD)
{
    return FALSE;
}

// The following function should never be called.
HRESULT
CertTrustCleanup(PCRYPT_PROVIDER_DATA)
{
    return TRUST_E_FAIL;
}


// In WXP this API was changed not to use CTLs. Instead, the "TrustedPeople" and
// "Disallowed" certificate stores are used.

HRESULT CertModifyCertificatesToTrust(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND hwnd, HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    HRESULT hr = S_OK;
    HCERTSTORE hStoreDisallowed = NULL;
    HCERTSTORE hStoreTrustedPeople = NULL;
    int i;

    hStoreDisallowed = I_OpenDisallowedStore();
    if (NULL == hStoreDisallowed)
        goto OpenDisallowedStoreError;
    hStoreTrustedPeople = I_OpenTrustedPeopleStore();
    if (NULL == hStoreTrustedPeople)
        goto OpenTrustedPeopleStoreError;

    for (i = 0; i < cCertsToModify; i++) {
        PCCERT_CONTEXT pCert = rgCertMods[i].pccert;
        DWORD dwError = S_OK;

        switch(rgCertMods[i].dwOperation) {
            case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreTrustedPeople, pCert))
                    dwError = GetLastError();
                if (!CertAddCertificateContextToStore(
                        hStoreDisallowed,
                        pCert,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        ))
                    dwError = GetLastError();
                break;

            case CTL_MODIFY_REQUEST_REMOVE:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreDisallowed, pCert))
                    dwError = GetLastError();
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreTrustedPeople, pCert))
                    dwError = GetLastError();
                break;

            case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreDisallowed, pCert))
                    dwError = GetLastError();
                if (!CertAddCertificateContextToStore(
                        hStoreTrustedPeople,
                        pCert,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        ))
                    dwError = GetLastError();
                break;

            default:
                dwError = E_INVALIDARG;
        }

        dwError = HRESULT_FROM_WIN32(dwError);
        rgCertMods[i].dwError = dwError;
        if (FAILED(dwError))
            hr = S_FALSE;
    }

CommonReturn:
    if (hStoreDisallowed)
        CertCloseStore(hStoreDisallowed, 0);
    if (hStoreTrustedPeople)
        CertCloseStore(hStoreTrustedPeople, 0);

    return hr;

OpenDisallowedStoreError:
OpenTrustedPeopleStoreError:
    // Most likely unable to access
    hr = E_ACCESSDENIED;
    goto CommonReturn;
}


BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose)
{
    HRESULT     hr;
    CTL_MODIFY_REQUEST  certmod;

    certmod.pccert = pccert;
    certmod.dwOperation = dwNewTrust;

    hr = CertModifyCertificatesToTrust(1, &certmod, szPurpose, hwnd, NULL, NULL);
    return (hr == S_OK) && (certmod.dwError == 0);
}


void FreeWVTHandle(HANDLE hWVTState) {
    if (hWVTState) {
        HRESULT hr;
        WINTRUST_DATA data = {0};

        data.cbStruct = sizeof(WINTRUST_DATA);
        data.pPolicyCallbackData = NULL;
        data.pSIPClientData = NULL;
        data.dwUIChoice = WTD_UI_NONE;
        data.fdwRevocationChecks = WTD_REVOKE_NONE;
        data.dwUnionChoice = WTD_CHOICE_BLOB;
        data.pBlob = NULL;      // &blob;
        data.dwStateAction = WTD_STATEACTION_CLOSE;
        data.hWVTStateData = hWVTState;
        hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    }
}

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD /*cPurposes*/, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame *  /*ppcf*/, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD                               cbData;
    DWORD                               cCerts = 0;
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};
    DWORD                               dwErrors;
    BOOL                                f;
    HRESULT                             hr;
    int                                 i;
    DWORD                               j;
    PCCERT_CONTEXT *                    rgCerts = NULL;
    DWORD *                             rgdwErrors = NULL;
    DATA_BLOB *                         rgblobTrust = NULL;
    CERT_VERIFY_CERTIFICATE_TRUST       trust;
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;

    FILETIME ftCurrent;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;
    if (phReturnStateData) {
        data.dwStateAction = WTD_STATEACTION_VERIFY;
    }

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE) &trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pccertToCheck;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH |
                     CERT_TRUST_PERMIT_MISSING_CRLS |
                     CERT_TRUST_DO_FULL_TRUST | dwControl);
    trust.dwIgnoreErr = dwValidityMask;
    trust.pdwErrors = &dwErrors;
    //    Assert(cPurposes == 1);
    if (rgszPurposes != NULL) {
        trust.pszUsageOid = rgszPurposes[0];
    }
    else {
        trust.pszUsageOid = NULL;
    }
    trust.hprov = hprov;
    trust.cRootStores = cRoots;
    trust.rghstoreRoots = rgRoots;
    trust.cStores = cCAs;
    trust.rghstoreCAs = rgCAs;
    trust.cTrustStores = cTrust;
    trust.rghstoreTrust = rgTrust;
    trust.lCustData = lCustData;
    trust.pfnTrustHelper = pfn;
    trust.pcChain = &cCerts;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;
    trust.prgpbTrustInfo = &rgblobTrust;

    hr = WinVerifyTrust(NULL, (GUID *) &GuidCertValidate, &data);
    if ((TRUST_E_CERT_SIGNATURE == hr) ||
        (CERT_E_REVOKED == hr) ||
        (CERT_E_REVOCATION_FAILURE == hr)) {
        hr = S_OK;
    }
    else if (FAILED(hr)) {
            return hr;
    }
    if (cCerts == 0) {
        return(E_INVALIDARG);
    }

    if (phReturnStateData) {
        *phReturnStateData = data.hWVTStateData;    // Caller must use WinVerifyTrust to free
    }

    GetSystemTimeAsFileTime(&ftCurrent);

    //Assert( cCerts <= 20);
    *pcNodes = cCerts;
    for (i=cCerts-1; i >= 0; i--) {
        rgpcfResult[i] = new CCertFrame(rgCerts[i]);

        if(!rgpcfResult[i])
        {
            hr=E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpcfResult[i]->m_dwFlags = rgdwErrors[i];
        if (rgszPurposes == NULL) {
            continue;
        }
        rgpcfResult[i]->m_cTrust = 1;
        rgpcfResult[i]->m_rgTrust = new STrustDesc[1];
        memset(rgpcfResult[i]->m_rgTrust, 0, sizeof(STrustDesc));

        if (0 == i)
            rgpcfResult[i]->m_fLeaf = TRUE;
        else
            rgpcfResult[i]->m_fLeaf = FALSE;

        if (0 == CertVerifyTimeValidity(&ftCurrent, rgCerts[i]->pCertInfo))
            rgpcfResult[i]->m_fExpired = FALSE;
        else
            rgpcfResult[i]->m_fExpired = TRUE;

        

        //
        //  We are going to fill in the trust information which we use
        //  to fill in the fields of the dialog box.
        //
        //  Start with the question of the cert being self signed
        //

        rgpcfResult[i]->m_fSelfSign = WTHelperCertIsSelfSigned(X509_ASN_ENCODING, rgCerts[i]->pCertInfo);

        //
        //  We may or may not have trust data information returned, we now
        //      build up the trust info for a single cert
        //
        //  If we don't have any explicit data, then we just chain the data
        //      down from the next level up.
        //

        if (rgblobTrust[i].cbData == 0) {
            //        chain:
            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;

            //
            //  We return a special code to say that we found it in the root store
            //

            rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore =
                (rgblobTrust[i].pbData == (LPBYTE) 1);

            if (i != (int) (cCerts-1)) {
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
            } else {
                //  Oops -- there is no level up one, so just make some
                //      good defaults
                //
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
            }
        }
        else {
            // Explicit trust is contained in the last byte
            if (EXPLICIT_TRUST_YES ==
                    rgblobTrust[i].pbData[rgblobTrust[i].cbData - 1]) {
                rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = TRUE;
                rgpcfResult[i]->m_rgTrust[0].fTrust = TRUE;
            } else {
                rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = TRUE;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= TRUE;
            }
        }
    }

    //
    //  Clean up all returned values
    //

ExitHere:
    if (rgCerts != NULL) {
        //bobn If the loop has been broken because "new" failed, free what we allocated so far...
        for ((hr==E_OUTOFMEMORY?i++:i=0); i< (int) cCerts; i++) {
            CertFreeCertificateContext(rgCerts[i]);
        }
        LocalFree(rgCerts);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrust != NULL) {
        for (i=0; i<(int) cCerts; i++) {
            if (rgblobTrust[i].cbData > 0) {
                LocalFree(rgblobTrust[i].pbData);
            }
        }
        LocalFree(rgblobTrust);
    }

    return hr;
}

LPWSTR FormatValidityFailures(DWORD dwFlags)
{
    DWORD       cch = 0;
    LPWSTR      pwsz = NULL;
    LPWSTR      pwszT;
    WCHAR       rgwch[200];

    if (dwFlags == 0) {
        return NULL;
    }

    cch = 100;
    pwsz = (LPWSTR) malloc(cch*sizeof(WCHAR));
    if (pwsz == NULL) {
        return NULL;
    }
    if (dwFlags & CERT_VALIDITY_BEFORE_START) {
        LoadString(g_hCertTrustInst, IDS_WHY_NOT_YET, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        StrCpyNW(pwsz, rgwch, cch);
    } else {
        StrCpyNW(pwsz, L"",cch);
    }

    if (dwFlags & CERT_VALIDITY_AFTER_END) {
        LoadString(g_hCertTrustInst, IDS_WHY_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_SIGNATURE_FAILS) {
        LoadString(g_hCertTrustInst, IDS_WHY_CERT_SIG, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
        LoadString(g_hCertTrustInst, IDS_WHY_NO_PARENT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NO_CRL_FOUND) {
        LoadString(g_hCertTrustInst, IDS_WHY_NO_CRL, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_CERTIFICATE_REVOKED) {
        LoadString(g_hCertTrustInst, IDS_WHY_REVOKED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_CRL_OUT_OF_DATE) {
        LoadString(g_hCertTrustInst, IDS_WHY_CRL_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_EXTEND_USE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_NAME_CONST, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_POLICY_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_POLICY, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    if (dwFlags & CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_BASIC_CONS, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            cch += 200;
            pwszT = (LPWSTR) realloc(pwsz, cch*sizeof(WCHAR));
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0)
            StrCatBuffW(pwsz, wszCRLF, cch);
        StrCatBuffW(pwsz, rgwch, cch);
    }

    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_WINDLL
WIN32_IE_VERSION=0x0500

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(R)\res; \
    $(R)\inc; \
    $(R)\inc\$(O); \
    $(R)\dll; \
    $(R)\engine; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1

PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch

PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\test\test.cpp ===
#include        <windows.h>
#include        <stdio.h>
#include        <cryptdlg.h>

int     IFilter = 0;

BOOL FILTER(PCCERT_CONTEXT pccert, long, DWORD, DWORD)
{
    switch (IFilter) {
    case 1:
        return TRUE;

    case 2:
        return (pccert->pCertInfo->dwVersion == 0);
    }
    return TRUE;
}

void PrintUsage()
{
    printf("test options are:\n");
    printf("    -h      print help\n");
    printf("    -A      open AddressBook cert store\n");
    printf("    -C      open CA cert store\n");
    printf("    -M      open My cert store\n");
    printf("    -R      open ROOT cert store\n");
    printf("    -F#     filter number to apply\n");
    printf("            1 - view all certs\n");
    printf("            2 - view V1 certs only\n");
    printf("    -S<name> open <name> cert store\n");
}

int __cdecl  main(int argc, char * argv[])
{
    BOOL                fWide = FALSE;
    HCERTSTORE          hcertstor = NULL;
    int                 i;
    PCCERT_CONTEXT      pccert = NULL;
    char *              szPurposeOid = "1.3.6.1.5.5.7.3.4";

    for (i=1; i<argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch(argv[i][1]) {
            case 'h':
                PrintUsage();
                exit(0);

            case 'A':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"AddressBook");
                break;

            case 'M':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"My");
                break;

            case 'R':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"ROOT");
                break;

            case 'C':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"CA");
                break;

            case 'F':
                IFilter = atoi(&argv[i][2]);
                break;

            case 'P':
                if (argv[i][2] != 0) {
                    szPurposeOid = &argv[i][2];
                }
                else
                    szPurposeOid = NULL;
                break;

            case 'W':
                fWide = TRUE;
                break;

            default:
                PrintUsage();
                exit(1);
            }
        }
        else {
            PrintUsage();
            exit(1);
        }
    }

    if (hcertstor == NULL) {
        hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                  NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                  L"MY");
    }

    if (fWide) {
        CERT_SELECT_STRUCT_W  css = {0};

        css.dwSize = sizeof(css);
        css.szPurposeOid = szPurposeOid;
        css.hwndParent = NULL;
        css.hInstance = NULL;
        css.pTemplateName = NULL;
        css.dwFlags = CSS_SHOW_HELP;
        css.szTitle = NULL;
        css.cCertStore = 1;
        css.arrayCertStore = &hcertstor;
        css.cCertContext = 0;
        css.arrayCertContext = &pccert;
        css.lCustData = 0;
        css.pfnHook = NULL;
        if (IFilter > 0) {
            css.pfnFilter = FILTER;
        }
        else {
            css.pfnFilter = NULL;
        }
        css.szHelpFileName = L"Help File";
        css.dwHelpId = 100;

        if (CertSelectCertificateW(&css)) {

            CERT_VIEWPROPERTIES_STRUCT_W cvp;
            memset(&cvp, 0, sizeof(cvp));

            cvp.dwSize = sizeof(cvp);
            cvp.pCertContext = pccert;
            cvp.dwFlags |= CM_SHOW_HELP;
            cvp.cArrayPurposes = 1;
            cvp.arrayPurposes = (LPSTR *) &css.szPurposeOid;
            cvp.szHelpFileName = L"Help File";
            cvp.dwHelpId = 100;

            CertViewPropertiesW(&cvp);
        }
    }
    else {
        CERT_SELECT_STRUCT_A  css = {0};

        css.dwSize = sizeof(css);
        css.szPurposeOid = szPurposeOid;
        css.hwndParent = NULL;
        css.hInstance = NULL;
        css.pTemplateName = NULL;
        css.dwFlags = CSS_SHOW_HELP;
        css.szTitle = NULL;
        css.cCertStore = 1;
        css.arrayCertStore = &hcertstor;
        css.cCertContext = 0;
        css.arrayCertContext = &pccert;
        css.lCustData = 0;
        css.pfnHook = NULL;
        if (IFilter > 0) {
            css.pfnFilter = FILTER;
        }
        else {
            css.pfnFilter = NULL;
        }
        css.szHelpFileName = "Help File";
        css.dwHelpId = 100;

        if (CertSelectCertificateA(&css)) {

            CERT_VIEWPROPERTIES_STRUCT_A cvp;
            memset(&cvp, 0, sizeof(cvp));

            cvp.dwSize = sizeof(cvp);
            cvp.pCertContext = pccert;
            cvp.dwFlags |= CM_SHOW_HELP;
            cvp.cArrayPurposes = 1;
            cvp.arrayPurposes = (LPSTR *) &css.szPurposeOid;
            cvp.szHelpFileName = "Help File";
            cvp.dwHelpId = 100;

            CertViewPropertiesA(&cvp);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\cryptdlg\view.cpp ===
#include        "pch.hxx"
#ifndef WIN16
#include        <commctrl.h>
#endif // !WIN16
#include        <stdio.h>
#include        <limits.h>
#ifndef WIN16
#include        "wintrust.h"
#endif // !WIN16
#include        "demand.h"
#include        <iehelpid.h>



#ifndef WIN16
//  Fix a Win95 problem
#undef TVM_SETITEM
#define TVM_SETITEM TVM_SETITEMA
#undef TVM_GETITEM
#define TVM_GETITEM TVM_GETITEMA
#endif // !WIN16

extern HINSTANCE        HinstDll;
#ifndef MAC
extern HMODULE          HmodRichEdit;
#endif  // !MAC
BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp);

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

#define VIEW_HELPER_SENTRY  0x424A4800
typedef struct {
    DWORD                               dwSentry;   // Must be set to value of VIEW_HELPER_SENTRY
    PCERT_VIEWPROPERTIES_STRUCT_W       pcvp;
    DWORD                               ccf;        // Count of frames
    PCCertFrame                         rgpcf[20];  // Array of frames
    HTREEITEM                           hItem;      // Leaf item in trust view
    HANDLE                              hWVTState;  // WinVerifyTrust state handle

    // CryptUI version only
    PCCERT_CONTEXT                      pccert;     // Cert context goes here
    ULONG                               icf;        // index in rgpcf of this cert.
} VIEW_HELPER;

typedef struct {
    DLGPROC                             pfnDlgProc;
    LPARAM                              lParam;
} VIEW_CALLBACK_HELPER;

const HELPMAP RgctxGeneral[] = {
    {IDC_FINE_PRINT,                    IDH_CERTVWPROP_GEN_FINEPRINT}
};

const HELPMAP RgctxDetails[] = {
    {IDC_ISSUED_BY,                     IDH_CERTVWPROP_DET_ISSUER_CERT},
    {IDC_FRIENDLY_NAME,                 IDH_CERTVWPROP_DET_FRIENDLY},
    {IDC_TRUST_IMAGE,                   IDH_CERTVWPROP_DET_STATUS},
    {IDC_IS_TRUSTED,                    IDH_CERTVWPROP_DET_STATUS},
    {IDC_IS_VALID,                      IDH_CERTVWPROP_DET_STATUS}
};


const HELPMAP RgctxTrust[] = {
    {IDC_TRUST_LIST,                    IDH_CERTVWPROP_TRUST_PURPOSE},
    {IDC_TRUST_TREE,                    IDH_CERTVWPROP_TRUST_HIERAR},
    {IDC_TRUST_VIEW,                    IDH_CERTVWPROP_TRUST_VIEWCERT},
    {IDC_TRUST_INHERIT,                 IDH_CERTVWPROP_TRUST_INHERIT},
    {IDC_TRUST_YES,                     IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST},
    {IDC_TRUST_NO,                      IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST}
};

const HELPMAP RgctxAdvanced[] = {
    {IDC_LIST1,                         IDH_CERTVWPROP_ADV_FIELD},
    {IDC_EDIT1,                         IDH_CERTVWPROP_ADV_DETAILS}
};


////////////////////////////////////////////////////////

VIEW_HELPER * GetViewHelperFromPropSheetPage(PROPSHEETPAGE *ps) {
    VIEW_HELPER * pviewhelp;
    ULONG i;

    pviewhelp = (VIEW_HELPER *)(ps->lParam);
    if (pviewhelp->dwSentry != VIEW_HELPER_SENTRY) {
        // Assume that CryptUI has passed us a wrapped lparam/cert pair
        // typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
        //    LPARAM          lParam;
        //    PCCERT_CONTEXT  pCertContext;
        // } CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;

        PCRYPTUI_INITDIALOG_STRUCT pCryptUIInitDialog = (PCRYPTUI_INITDIALOG_STRUCT)pviewhelp;
        pviewhelp = (VIEW_HELPER *)pCryptUIInitDialog->lParam;
        if (pviewhelp->dwSentry != VIEW_HELPER_SENTRY) {
            // Bad lparam
            return(NULL);
        }
        pviewhelp->pccert = pCryptUIInitDialog->pCertContext;

        // Find the correct frame in the array
        pviewhelp->icf = 0;
        for (i = 0; i < pviewhelp->ccf; i++) {
            if (CertCompareCertificate(X509_ASN_ENCODING,
              pviewhelp->rgpcf[i]->m_pccert->pCertInfo, pviewhelp->pccert->pCertInfo)) {
                pviewhelp->icf = i;
                break;
            }
        }
    }
    return(pviewhelp);
}


void ShowHelp(HWND hwnd, VIEW_HELPER * pviewhelp) {
    if (FIsWin95) {
        WinHelpA(hwnd, (LPSTR)pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
          pviewhelp->pcvp->dwHelpId);
    }
#if !defined( MAC ) && !defined( WIN16 )
    else {
        WinHelpW(hwnd, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
          pviewhelp->pcvp->dwHelpId);
    }
#endif  // !MAC && !WIN16
}


INT_PTR CALLBACK ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fTrust;
    HANDLE              hGraphic;
    int                 i1;
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    ENLINK *            penlink;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    WCHAR               rgwch[200];
    LPWSTR              rgpwsz[4];
    UINT                rguiStrings[7];

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        //  Stash the item in the header
        //

        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        //
        //  Pick up and format the general message texts
        //

        rguiStrings[0] = IDS_GENERAL_DESC;
        rguiStrings[1] = IDS_GENERAL_DESC2;
        rguiStrings[2] = IDS_GENERAL_DESC3;
        rguiStrings[3] = IDS_GENERAL_DESC4;
        rguiStrings[4] = IDS_GENERAL_DESC5;
        rguiStrings[5] = IDS_GENERAL_DESC6;
        rguiStrings[6] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_GENERAL_DESC, HinstDll, rguiStrings);

        rgpwsz[0] = PrettySubject(pccert);
        rgpwsz[1] = PrettyIssuer(pccert);
        //        rgpwsz[2] = FindURL(pccert);
        rgpwsz[2] = NULL;
        rgpwsz[3] = (LPWSTR) -1;               // Sentinal Value

        LoadString(HinstDll, IDS_GENERAL_INFO, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY, rgwch,
                      0, 0, (LPWSTR) &pwsz, 0, (va_list *) rgpwsz);

        SetDlgItemText(hwndDlg, IDC_TEXT, pwsz);

        if (rgpwsz[2] != NULL) {
            i1 = (int) (wcsstr(pwsz, rgpwsz[1]) - pwsz);
            if (i1 >= 0) {
                CHARFORMATA  cf = {sizeof(cf), CFM_UNDERLINE | CFM_LINK,
                                   CFE_UNDERLINE | CFE_LINK};
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETSEL,
                                   i1, i1+wcslen(rgpwsz[1]));
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETCHARFORMAT,
                                   SCF_SELECTION, (LPARAM) &cf);
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETEVENTMASK, 0,
                                   ENM_LINK);
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETSEL, 0, 0);
            }
        }

        //  Grey out the rich edit box

        SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));

        //
        //  Now that we have determined what the trust status is, display the
        //      correct string and image
        //

        if (pviewhelp->rgpcf[0]->m_dwFlags == 0) {
            if (pviewhelp->pcvp->cArrayPurposes == 0) {
                fTrust = TRUE;
            }
            else {
                for (i=0, fTrust = TRUE; i<pviewhelp->pcvp->cArrayPurposes; i++) {
                    fTrust &= pviewhelp->rgpcf[0]->m_rgTrust[i].fTrust;
                }
            }
        }
        else {
            fTrust = FALSE;
        }

#ifndef WIN16
        hGraphic = LoadImageA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDB_TICK+!fTrust),
                       IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
#else
        hGraphic = LoadBitmap(HinstDll,
                              (LPSTR) MAKEINTRESOURCE(IDB_TICK+!fTrust));
#endif
        SendDlgItemMessageA(hwndDlg, IDC_CERT_STATUS_IMAGE, STM_SETIMAGE,
                            IMAGE_BITMAP, (LPARAM) hGraphic);
        LoadStringInWindow(hwndDlg, IDC_CERT_STATUS, HinstDll,
                           IDS_GENERAL_TICK + !fTrust);


        //


        //  Free out the buffers
#ifndef WIN16
        LocalFree(pwsz);
#else
        LocalFree((HLOCAL)pwsz);
#endif
        if (rgpwsz[0])
            free(rgpwsz[0]);
        if (rgpwsz[1])
            free(rgpwsz[1]);
        if (rgpwsz[2])
            free(rgpwsz[2]);

        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case EN_LINK:
            penlink = (ENLINK *) lParam;
            if (penlink->msg == WM_LBUTTONUP) {
                break;
            }
            break;

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        if (LOWORD(wParam) == IDC_FINE_PRINT) {
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            FinePrint(pviewhelp->pcvp->pCertContext, hwndDlg);
            return TRUE;
        }
        else if (LOWORD(wParam) == IDHELP) {
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxGeneral);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPT_DATA_BLOB     blob;
    DWORD               cch;
    BOOL                fNotTrust;
    BOOL                fInvalid;
    BOOL                f;
    HANDLE              h;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;

    switch ( msg ) {
    case WM_INITDIALOG:
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);
        pccert = pviewhelp->pcvp->pCertContext;

        FormatSubject(hwndDlg, IDC_ISSUED_TO, pccert);
        FormatIssuer(hwndDlg, IDC_ISSUED_BY, pccert);

        FormatValidity(hwndDlg, IDC_VALIDITY, pccert);
        FormatAlgorithm(hwndDlg, IDC_ALGORITHM, pccert);
        FormatSerialNo(hwndDlg, IDC_SERIAL_NUMBER, pccert);
        FormatThumbprint(hwndDlg, IDC_THUMBPRINT, pccert);

        pwsz = PrettySubject(pccert);
        SetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz);
        free(pwsz);

        if (pviewhelp->pcvp->dwFlags & CM_NO_NAMECHANGE) {
            SendDlgItemMessageA(hwndDlg, IDC_FRIENDLY_NAME, EM_SETREADONLY,
                                1, 0);
        }

        //
        //  Play with the validity and trust items at the bottom of the page.
        //

        fInvalid = (pviewhelp->rgpcf[0]->m_dwFlags != 0);
        if (pviewhelp->rgpcf[0]->m_rgTrust == NULL) {
            fNotTrust = FALSE;
            ShowWindow(GetDlgItem(hwndDlg, IDC_IS_TRUSTED), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_IS_TRUSTED), FALSE);
        }
        else {
            fNotTrust = !pviewhelp->rgpcf[0]->m_rgTrust[0].fTrust;
        }

#ifndef WIN16
        h = LoadImageA(HinstDll,
                       (LPSTR) MAKEINTRESOURCE(IDB_TICK+(fNotTrust||fInvalid)),
                       IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
#else
        h = LoadBitmap(HinstDll,
                       (LPSTR) MAKEINTRESOURCE(IDB_TICK+(fNotTrust||fInvalid)));
#endif
        SendDlgItemMessageA(hwndDlg, IDC_TRUST_IMAGE, STM_SETIMAGE,
                            IMAGE_BITMAP, (LPARAM) h);
        LoadStringInWindow(hwndDlg, IDC_IS_VALID, HinstDll,
                           IDS_DETAIL_VALID_TICK + fInvalid);
        LoadStringInWindow(hwndDlg, IDC_IS_TRUSTED, HinstDll,
                           IDS_DETAIL_TRUST_TICK + fNotTrust);

#ifdef MAC
        if (fInvalid) {
            HWND        hwnd;
            hwnd = CreateWindowA(TOOLTIPS_CLASSA, NULL, TTS_ALWAYSTIP,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                hwndDlg, NULL, HinstDll, NULL);
            TOOLINFO    ti;
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = TTF_SUBCLASS;
            ti.hwnd = hwndDlg;
            ti.hinst = HinstDll;
            GetWindowRect(GetDlgItem(hwndDlg, IDC_TRUST_GROUP), &ti.rect);
            ti.uId = 0;
            ti.lpszText = FormatValidityFailures(pviewhelp->rgpcf[0]->m_dwFlags);
            SendMessageA(hwnd, TTM_ADDTOOL, 0, (LPARAM) &ti);

        }

        if (pviewhelp->ccf < 2) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_VIEW_ISSUER), FALSE);
        }
        SendDlgItemMessageA(hwndDlg, IDC_ISSUED_TO, EM_SETSEL, 0,0);
#else   // !MAC
        if (fInvalid) {
            HWND        hwnd;
            hwnd = CreateWindow(TOOLTIPS_CLASS, NULL, TTS_ALWAYSTIP,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                hwndDlg, NULL, HinstDll, NULL);
            TOOLINFO    ti;
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = TTF_SUBCLASS;
            ti.hwnd = hwndDlg;
            ti.hinst = HinstDll;
            GetWindowRect(GetDlgItem(hwndDlg, IDC_TRUST_GROUP), &ti.rect);
            ti.uId = 0;
            ti.lpszText = FormatValidityFailures(pviewhelp->rgpcf[0]->m_dwFlags);
            SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM) &ti);

        }

        if (pviewhelp->ccf < 2) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_VIEW_ISSUER), FALSE);
        }
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_TO, EM_SETSEL, 0,0);
#endif  // MAC

        SetFocus(GetDlgItem(hwndDlg, IDC_FRIENDLY_NAME));

        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
        return FALSE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //  Only thing to do is to write back the Friendly name
            f = FALSE;
            cch = (DWORD) SendDlgItemMessage(hwndDlg, IDC_FRIENDLY_NAME,
                                     WM_GETTEXTLENGTH, 0, 0);
            if (cch) {
                // Must have a name!
                pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
                if (pwsz) {
                    GetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz, cch+1);

                    pccert = ((VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER))->pcvp->pCertContext;
                    if (pccert) {
                        blob.pbData = (LPBYTE) pwsz;
                        blob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              &blob);
                    }
                    free(pwsz);
                }
            }

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            //  Only thing to do is to write back the Friendly name
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);

#if 0
            pccert = ((VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER))->pcvp->pCertContext;
            pwsz = PrettySubject(pccert);
            SetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz);
            free(pwsz);
#endif // 0
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_FRIENDLY_NAME:
            //  If they edit the friendly name, let us know
            if (HIWORD(wParam) == EN_CHANGE) {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_VIEW_ISSUER:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pviewhelp->rgpcf[1]->m_pccert;

                CertViewPropertiesA(&cvps);
            }
#ifndef WIN16
#ifndef MAC
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pviewhelp->rgpcf[1]->m_pccert;

                CertViewPropertiesW(&cvps);
            }
#endif  // !MAC
#endif // !WIN16
            return TRUE;

        case IDC_WHY:
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxDetails);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageTrust(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    HBITMAP             hBmp;
    HIMAGELIST          hIml;
    HTREEITEM           hItem;
    int                 i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    TV_ITEM             tvi;
    TV_INSERTSTRUCT     tvins;
    UINT                rguiStrings[5];
    WCHAR               rgwch[256];

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        //  Put the long text into the window
        rguiStrings[0] = IDS_TRUST_DESC;
        rguiStrings[1] = IDS_TRUST_DESC2;
        rguiStrings[2] = IDS_TRUST_DESC4;
        rguiStrings[3] = IDS_TRUST_DESC4;
        rguiStrings[4] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_TRUST_DESC, HinstDll, rguiStrings);

        //  Populate the trust line
        if (pviewhelp->pcvp->cArrayPurposes == 1) {
            cb = sizeof(rgwch);
            f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                  pviewhelp->pcvp->arrayPurposes[0],
                                  NULL, 0, rgwch, &cb);
            if (f && (rgwch[0] != 0)) {
                SetDlgItemText(hwndDlg, IDC_TRUST_EDIT, rgwch);
            }
            else {
                SetDlgItemTextA(hwndDlg, IDC_TRUST_EDIT,
                                pviewhelp->pcvp->arrayPurposes[0]);
            }
        }
        else {
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_LIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_EDIT), SW_HIDE);
        }

        //  Build up the image list for the control

        hIml = ImageList_Create(16, 16, FALSE, 6, 0);
        hBmp = LoadBitmapA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDB_TREE_IMAGES));
        ImageList_Add(hIml, hBmp, NULL);
        DeleteObject(hBmp);

        TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hIml, 0);

        //  Populate the tree control

        tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        hItem = TVI_ROOT;

        for (i=pviewhelp->ccf-1; i>= 0; i--) {
            tvins.hParent = hItem;
            tvins.hInsertAfter = TVI_FIRST;
            pwsz = PrettySubject(pviewhelp->rgpcf[i]->m_pccert);
            tvins.item.pszText = pwsz;
            tvins.item.cchTextMax = lstrlen(pwsz);
            if (pviewhelp->rgpcf[i]->m_rgTrust[0].fTrust) {
                tvins.item.iImage = 2;
            }
            else if (pviewhelp->rgpcf[i]->m_rgTrust[0].fDistrust) {
                tvins.item.iImage = 0;
            }
            else {
                tvins.item.iImage = 1;
            }
            if (pviewhelp->rgpcf[i]->m_fSelfSign) {
                tvins.item.iImage += 3;
            }
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (LPARAM) pviewhelp->rgpcf[i]->m_pccert;
            hItem = (HTREEITEM) SendDlgItemMessage(hwndDlg, IDC_TRUST_TREE,
                                                   TVM_INSERTITEM, 0,
                                                   (LPARAM) &tvins);
            if (i != (int) (pviewhelp->ccf-1)) {
                TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                                tvins.hParent, TVE_EXPAND);
            }
        }

        pviewhelp->hItem = hItem;

        //
        //  If the leaf cert is in the root store, then disable all items
        //

        if (pviewhelp->rgpcf[0]->m_fRootStore) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_NO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
        }
        else {
            //
            //  Populate the radio button from the leaf cert
            //

            if (pviewhelp->rgpcf[0]->m_rgTrust[0].fExplicitDistrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_NO, BM_SETCHECK, 1, 0);
            }
            else if (pviewhelp->rgpcf[0]->m_rgTrust[0].fExplicitTrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_YES, BM_SETCHECK, 1, 0);
            }
            else {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_INHERIT, BM_SETCHECK, 1, 0);
                if (pviewhelp->rgpcf[0]->m_fSelfSign) {
                    pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust = 4;
                }
            }

            if (pviewhelp->rgpcf[0]->m_fSelfSign) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
            }
        }
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //
            //  We have been asked to save any changes we have.  The only possible
            //  item that the trust on the leaf has been changed.  Check to see
            //  if this was done and do the appropriate thing
            //

            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust != 0) {
                if (pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust == 4) {
                    f = FALSE;
                }
                else {
                    f = FModifyTrust(hwndDlg, pviewhelp->rgpcf[0]->m_pccert,
                                     pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust,
                                     pviewhelp->pcvp->arrayPurposes[0]);
                }
            }
            else {
                f = TRUE;
            }
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case TVN_SELCHANGEDA:
#ifndef WIN16
        case TVN_SELCHANGEDW:
#endif // !WIN16
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW),
                       ((NM_TREEVIEW *) lParam)->itemNew.hItem != pviewhelp->hItem);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_TRUST_INHERIT:
        case IDC_TRUST_NO:
        case IDC_TRUST_YES:
            //
            //  The explicit trust has been changed for the leaf, make the
            //  appropriate change to the tree control for the modification
            //

            if (HIWORD(wParam) == BN_CLICKED) {
                pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust = (LOWORD(wParam) -
                                                              IDC_TRUST_NO) + 1;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvi.hItem = pviewhelp->hItem;
                if (LOWORD(wParam) == IDC_TRUST_INHERIT) {
                    if (pviewhelp->rgpcf[0]->m_rgTrust[0].fTrust) {
                        tvi.iImage = 2;
                    }
                    else if (pviewhelp->rgpcf[0]->m_rgTrust[0].fDistrust) {
                        tvi.iImage = 0;
                    }
                    else {
                        tvi.iImage = 1;
                    }
                }
                else if (LOWORD(wParam) == IDC_TRUST_YES) {
                    tvi.iImage = 2;
                }
                else {
                    tvi.iImage = 0;
                }
                tvi.iSelectedImage = tvi.iImage;

                TreeView_SetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
            }
            break;

        case IDC_TRUST_VIEW:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));

            tvi.mask = TVIF_HANDLE | TVIF_PARAM;
            tvi.hItem = hItem;
            TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
#ifndef MAC
            if (FIsWin95) {
#endif  // !MAC
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) tvi.lParam;

                i = CertViewPropertiesA(&cvps);
#ifndef MAC
            }
#ifndef WIN16
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) tvi.lParam;

                i = CertViewPropertiesW(&cvps);
            }
#endif // !WIN16
#endif  // !MAC

            //
            if (i) {
                // M00BUG -- must rebuild all trust lists
            }
            return TRUE;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxTrust);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam,
                               LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    DWORD               i;
    PROPSHEETPAGE *     ps;
    PCCERT_CONTEXT      pccert;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    WCHAR               rgwch[200];

    switch ( msg ) {
    case WM_INITDIALOG:
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pccert);

        //
        //  Stick the "normal" items into the list
        //

        for (i=IDS_ADV_VERSION; i<= IDS_ADV_PUBKEY; i++) {
            LoadString(HinstDll, i, rgwch, sizeof(rgwch)/sizeof(WCHAR));
            SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                               (LPARAM) rgwch);
        }

        //
        //  Stick the extensions into the list
        //

        for (i=0; i<pccert->pCertInfo->cExtension; i++) {
            if (FIsWin95) {
                SendDlgItemMessageA(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                              (LPARAM) pccert->pCertInfo->rgExtension[i].pszObjId);
            }
#ifndef MAC
            else {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                    pccert->pCertInfo->rgExtension[i].pszObjId, -1,
                                    rgwch, sizeof(rgwch)/sizeof(WCHAR));
                SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                                   (LPARAM) rgwch);
            }
#endif  // !MAC
        }

        SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_SETCURSEL, 0, 0);
        ViewPageAdvanced(hwndDlg, WM_COMMAND,
                         MAKELONG(IDC_LIST1, LBN_SELCHANGE), 0);

        SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETEVENTMASK, 0, ENM_LINK);
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case EN_LINK:
            if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN) {
                f = FNoteDlgNotifyLink(hwndDlg, (ENLINK *) lParam, NULL);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
                return f;
            }
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_LIST1:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                pccert = (PCERT_CONTEXT) GetWindowLongPtr(hwndDlg, DWLP_USER);

                i = (int) SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_GETCARETINDEX,
                                       0, 0);
                if (i <= IDS_ADV_PUBKEY - IDS_ADV_VERSION) {
                    switch (i + IDS_ADV_VERSION) {
                    case IDS_ADV_VERSION:         // Version
                        rgwch[0] = L'V';
                        rgwch[1] = (WCHAR) ('0' + pccert->pCertInfo->dwVersion+1);
                        rgwch[2] = 0;
                        SetDlgItemText(hwndDlg, IDC_EDIT1, rgwch);
                        break;

                    case IDS_ADV_SER_NUM:       // Serial Number
                        FormatSerialNo(hwndDlg, IDC_EDIT1, pccert);
                        break;

                    case IDS_ADV_SIG_ALG:       // Signature Alg
                        FormatAlgorithm(hwndDlg, IDC_EDIT1, pccert);
                        break;

                    case IDS_ADV_ISSUER:        // Issuer
                        FormatIssuer(hwndDlg, IDC_EDIT1, pccert,
                                     CERT_X500_NAME_STR);
                        break;

                    case IDS_ADV_SUBJECT:       // Subject
                        FormatSubject(hwndDlg, IDC_EDIT1, pccert,
                                      CERT_X500_NAME_STR);
                        break;

                    case IDS_ADV_PUBKEY:        // Public Key
                        FormatBinary(hwndDlg, IDC_EDIT1,
                         pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                         pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);
                        break;

                    case IDS_ADV_NOTBEFORE:     // Effective Date
                        FormatDate(hwndDlg, IDC_EDIT1,
                                   pccert->pCertInfo->NotBefore);
                        break;

                    case IDS_ADV_NOTAFTER:      // Expiration Date
                        FormatDate(hwndDlg, IDC_EDIT1,
                                   pccert->pCertInfo->NotAfter);
                        break;
                    }
                }
                else {
                    i -= (IDS_ADV_PUBKEY - IDS_ADV_VERSION + 1);
                    // Assert( i < pccert->pCertInfo->cExtension );

                    cb = 0;
                    f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                    pccert->pCertInfo->rgExtension[i].pszObjId,
                                    pccert->pCertInfo->rgExtension[i].Value.pbData,
                                    pccert->pCertInfo->rgExtension[i].Value.cbData,
                                    0, &cb);
                    if (f && (cb > 0)) {
                        pwsz = (LPWSTR) malloc(cb * sizeof(WCHAR));
                        pwsz[0] = 0;
                        CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                    pccert->pCertInfo->rgExtension[i].pszObjId,
                                    pccert->pCertInfo->rgExtension[i].Value.pbData,
                                    pccert->pCertInfo->rgExtension[i].Value.cbData,
                                    pwsz, &cb);
                        SetDlgItemText(hwndDlg, IDC_EDIT1, pwsz);

                        RecognizeURLs(GetDlgItem(hwndDlg, IDC_EDIT1));
                        free(pwsz);
                    }
                    else {
                        SetDlgItemTextA(hwndDlg, IDC_EDIT1, "");
                    }
                }
            }
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxAdvanced);
#endif  // !MAC
    }

    return FALSE;
}


INT_PTR CALLBACK ViewPageTrustCryptUI(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    UINT                rguiStrings[5];
    WCHAR               rgwch[256];

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *)lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pviewhelp);

        //  Put the long text into the window
        rguiStrings[0] = IDS_TRUST_DESC;
        rguiStrings[1] = IDS_TRUST_DESC2;
        rguiStrings[2] = IDS_TRUST_DESC4;
        rguiStrings[3] = IDS_TRUST_DESC4;
        rguiStrings[4] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_TRUST_DESC, HinstDll, rguiStrings);

        //  Populate the trust line
        if (pviewhelp->pcvp->cArrayPurposes == 1) {
            cb = sizeof(rgwch);
            f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                  pviewhelp->pcvp->arrayPurposes[0],
                                  NULL, 0, rgwch, &cb);
            if (f && (rgwch[0] != 0)) {
                SetDlgItemText(hwndDlg, IDC_TRUST_EDIT, rgwch);
            }
            else {
                SetDlgItemTextA(hwndDlg, IDC_TRUST_EDIT,
                                pviewhelp->pcvp->arrayPurposes[0]);
            }
        }
        else {
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_LIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_EDIT), SW_HIDE);
        }

        //
        //  If the leaf cert is in the root store, then disable all items
        //
        if (pviewhelp->rgpcf[pviewhelp->icf]->m_fRootStore ||
                !pviewhelp->rgpcf[pviewhelp->icf]->m_fLeaf) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_NO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
        }
        else {
            //
            //  Populate the radio button from the leaf cert
            //

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].fExplicitDistrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_NO, BM_SETCHECK, 1, 0);
            }
            else if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].fExplicitTrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_YES, BM_SETCHECK, 1, 0);
            }
            else {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_INHERIT, BM_SETCHECK, 1, 0);
                if (pviewhelp->rgpcf[pviewhelp->icf]->m_fSelfSign) {
                    pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust = 4;
                }
            }

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_fSelfSign) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
            }

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_fExpired) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            }
        }
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //
            //  We have been asked to save any changes we have.  The only possible
            //  item that the trust on the leaf has been changed.  Check to see
            //  if this was done and do the appropriate thing
            //

            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust != 0) {
                if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust == 4) {
                    f = FALSE;
                }
                else {
                    f = FModifyTrust(hwndDlg, pviewhelp->rgpcf[pviewhelp->icf]->m_pccert,
                                     pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust,
                                     pviewhelp->pcvp->arrayPurposes[0]);
                }
            }
            else {
                f = TRUE;
            }
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_TRUST_INHERIT:
        case IDC_TRUST_NO:
        case IDC_TRUST_YES:
            //
            //  The explicit trust has been changed for the cert.
            //
            if (HIWORD(wParam) == BN_CLICKED) {
                pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);

                pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust = (LOWORD(wParam) - IDC_TRUST_NO) + 1;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxTrust);
#endif  // !MAC
    }

    return FALSE;
}


HRESULT HrDoViewPropsTrustWork(PCERT_VIEWPROPERTIES_STRUCT_W pcvp,
                               VIEW_HELPER * pviewhelp, BOOL fGetState) {
    HRESULT hr;
    CCertFrame * pcfRoot = NULL;

    pviewhelp->pcvp = pcvp;

    //
    //  Lets go out and try to find out what we can on the trust and validity
    //  of this message.   This is done by calling the trust provider that is
    //  around and going to town with it
    //

    hr = HrDoTrustWork(pcvp->pCertContext, 
                       (CERT_TRUST_DO_FULL_SEARCH | 
                            (pcvp->dwFlags & 
                                (CM_ADD_CERT_STORES | ~CM_VIEWFLAGS_MASK))),
// Why would we want to mask out these errors ?????
                       (DWORD) (CERT_VALIDITY_CRL_OUT_OF_DATE |
                                CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION |
                                CERT_VALIDITY_NO_CRL_FOUND // |
                                // CERT_VALIDITY_NO_TRUST_DATA
                        ),

                       pcvp->cArrayPurposes, pcvp->arrayPurposes, pcvp->hprov,
                       pcvp->cRootStores, pcvp->rghstoreRoots,
                       pcvp->cStores, pcvp->rghstoreCAs,
                       pcvp->cTrustStores, pcvp->rghstoreTrust, NULL, 0, &pcfRoot,
                       &pviewhelp->ccf, pviewhelp->rgpcf,
                       fGetState ? &pviewhelp->hWVTState : NULL);

    if (pcfRoot) {
        delete pcfRoot;
    }

    return(hr);
}


BOOL LoadRichEdit(void) {
    //  We use the common controls -- so make sure they have been loaded
    if (HmodRichEdit == NULL) {
        HmodRichEdit = LoadLibraryA("RichEd32.dll");
        if (HmodRichEdit == NULL) {
            return(FALSE);
        }
    }
    return(TRUE);
}


BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp);


INT_PTR CALLBACK CertViewPageSubClassProc(HWND hWndDlg,  UINT nMsg,
                                       WPARAM wParam, LPARAM lParam)
{
    INT_PTR                     iReturn = FALSE;
    CRYPTUI_INITDIALOG_STRUCT*  pcids;
    PROPSHEETPAGEW*             ppsp;
    PROPSHEETPAGEW              pspTemp;
    VIEW_CALLBACK_HELPER*       pviewcbhelp;

    // For WM_INITDIALOG make sure the property sheet gets what it expects
    //  as the lParam

    if (WM_INITDIALOG == nMsg) {
        ppsp = (PROPSHEETPAGE*)lParam;
        pcids = (CRYPTUI_INITDIALOG_STRUCT*)(ppsp->lParam);
        pviewcbhelp = (VIEW_CALLBACK_HELPER*)(pcids->lParam);
        memcpy(&pspTemp, ppsp, sizeof(pspTemp));
        pspTemp.pfnDlgProc = pviewcbhelp->pfnDlgProc;
        pspTemp.lParam = pviewcbhelp->lParam;
        iReturn = pviewcbhelp->pfnDlgProc(hWndDlg, nMsg, wParam, 
                                          (LPARAM)&pspTemp);
        SetWindowLongPtr(hWndDlg, DWLP_DLGPROC, (LONG_PTR)pviewcbhelp->pfnDlgProc);
    }
    return iReturn;
}


BOOL CertViewUI(BOOL fWide, PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    ULONG                               cPages = pcvp->cArrayPropSheetPages + 1;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW     cvcs = {0};
    HRESULT                             hrTrust = E_FAIL;
    DWORD                               i;
    DWORD                               iPage;
    PROPSHEETPAGEW *                    ppsp;
    BOOL                                ret;
    VIEW_HELPER                         viewhelp = {0};
    VIEW_CALLBACK_HELPER*               pviewcbhelp = NULL;
    VIEW_CALLBACK_HELPER*               pviewcbhelp2;

    // Allocate space to hold the property sheet information to hand to 
    //  CryptUI
    
    ppsp = (PROPSHEETPAGEW *) malloc(cPages * sizeof(PROPSHEETPAGEW));

    // CryptUI insists on passing back a CRYPTUI_INITDIALOG_STRUCT when
    //  it calls the property sheet pages which breaks the existing 
    //  CryptDlg implementations.  To get around this we force everything
    //  that says it knows nothing of CryptUI to call through a local DlgProc
    //  first so that we can safely forward the lParam onto the real 
    //  property pages DlgProc.  

    // Allocate space to hold the re-direction information

    if (!(pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM)) {
        pviewcbhelp = (VIEW_CALLBACK_HELPER*)malloc(cPages * 
                                                sizeof(VIEW_CALLBACK_HELPER));
    }                                                

    // Fill out the property sheet information
    
    if ((NULL != ppsp) && 
        ((pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM) || (NULL != pviewcbhelp))) {

        viewhelp.dwSentry = VIEW_HELPER_SENTRY;
        hrTrust = HrDoViewPropsTrustWork(pcvp, &viewhelp, TRUE);

        if (FAILED(hrTrust)) {
            return FALSE;
        }

        if (pcvp->cArrayPurposes == 0) {
            pcvp->dwFlags |= CM_HIDE_TRUSTPAGE;
        }

        memset(ppsp, 0, cPages * sizeof(PROPSHEETPAGEW));
        iPage = 0;
        cPages = 0;
        
        if (!(pcvp->dwFlags & CM_HIDE_TRUSTPAGE)) {
            ppsp[iPage].dwSize = sizeof(ppsp[0]);
            ppsp[iPage].dwFlags = 0;    // fHelp ? PSP_HASHELP : 0;
            ppsp[iPage].hInstance = HinstDll;
            ppsp[iPage].pszTemplate = MAKEINTRESOURCE(IDD_CRYPTUI_CERTPROP_TRUST);
            ppsp[iPage].hIcon = 0;
            ppsp[iPage].pszTitle = NULL;
            ppsp[iPage].pfnDlgProc = ViewPageTrustCryptUI;
            ppsp[iPage].lParam = (LPARAM)&viewhelp;
            ppsp[iPage].pfnCallback = 0;
            ppsp[iPage].pcRefParent = NULL;
            iPage++;
            cPages++;
        }

        //
        //  Copy over the users pages
        //
        if (pcvp->cArrayPropSheetPages) {
            memcpy(&ppsp[iPage], pcvp->arrayPropSheetPages,
                   pcvp->cArrayPropSheetPages * sizeof(PROPSHEETPAGEW));
            cPages += pcvp->cArrayPropSheetPages;                   
        }

        // If the user knows nothing about the CryptUI structures, subclass
        //  the DlgProc so that they get what they expect.
        
        if (!(pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM)) {
            for (pviewcbhelp2 = pviewcbhelp; iPage < cPages;
                 iPage++, pviewcbhelp2++) {
                pviewcbhelp2->pfnDlgProc = ppsp[iPage].pfnDlgProc;
                pviewcbhelp2->lParam = ppsp[iPage].lParam;
                ppsp[iPage].pfnDlgProc = CertViewPageSubClassProc;
                ppsp[iPage].lParam = (LPARAM)pviewcbhelp2;
            }
        }            
    } 
    else {
        // That's an error, but we'll ignore it and just not use them
        cPages = 0;
    }

    cvcs.dwSize = sizeof(cvcs);
    cvcs.hwndParent = pcvp->hwndParent;
    cvcs.dwFlags = CRYPTUI_DISABLE_ADDTOSTORE;
    if (!(pcvp->dwFlags & CM_NO_NAMECHANGE)) {
        cvcs.dwFlags |= CRYPTUI_ENABLE_EDITPROPERTIES;
    }
    cvcs.szTitle = pcvp->szTitle;
    cvcs.pCertContext = pcvp->pCertContext;
    cvcs.cPurposes = pcvp->cArrayPurposes;
    cvcs.rgszPurposes = (LPCSTR *) pcvp->arrayPurposes;
    cvcs.hWVTStateData = viewhelp.hWVTState;
    cvcs.fpCryptProviderDataTrustedUsage = hrTrust;
    // cvcs.idxSigner = 0;
    // cvcs.idxCert = 0;
    // cvcs.fCounterSigner = FALSE;
    // cvcs.idxCounterSigner = 0;
    
    cvcs.cStores = pcvp->cStores;
    cvcs.rghStores = pcvp->rghstoreCAs;
    cvcs.cPropSheetPages = cPages;
    cvcs.rgPropSheetPages = ppsp;

    //  Pages are:
    //  0 - General     - 0
    //  1 - Detail      - 1
    //  2 - Edit Trust  - 0x8000
    //  3 - Advanced    - 2
    switch (pcvp->nStartPage) {
    case 0:
    case 1:
        cvcs.nStartPage = pcvp->nStartPage;
        break;
    case 3:
        cvcs.nStartPage = 2;
	break;
    case 2:
        cvcs.nStartPage = 0x8000;
        break;
    default:
        // Add-on page, set the high bit
        if (pcvp->dwFlags & CM_HIDE_TRUSTPAGE) {
            cvcs.nStartPage = (pcvp->nStartPage - 2) | 0x8000;
        }
        else {
            cvcs.nStartPage = (pcvp->nStartPage - 3) | 0x8000;
        }
        break;
    }

// BUGBUG: CryptUI does not allow for these CryptDlg parameters:
//        pcvp->cRootStores
//        pcvp->rghstoreRoots
//        pcvp->cTrustStores
//        pcvp->rghstoreTrust
//        pcvp->hprov
//        pcvp->lCustData
//        pcvp->szHelpFileName
//        pcvp->szHelpId

    if (fWide) {
        ret = CryptUIDlgViewCertificateW(&cvcs, NULL);
    }
    else {
        ret = CryptUIDlgViewCertificateA((PCRYPTUI_VIEWCERTIFICATE_STRUCTA) &cvcs, NULL);
    }
    FreeWVTHandle(viewhelp.hWVTState);

    if (ppsp) {
        free(ppsp);
    }

    if (pviewcbhelp) {
        free(pviewcbhelp);
    }

    if (viewhelp.rgpcf != NULL) {
        for (i=0; i<viewhelp.ccf; i++) {
            delete viewhelp.rgpcf[i];
        }
    }
    
    return ret;
}

BOOL APIENTRY CertViewPropertiesA(PCERT_VIEWPROPERTIES_STRUCT_A pcvp)
{
    if (CryptUIAvailable()) {
        return CertViewUI(FALSE, (PCERT_VIEWPROPERTIES_STRUCT_W) pcvp);
    }
    

#ifndef MAC
    DWORD       cch;
#endif  // !MAC
    BOOL        ret = FALSE;
    CERT_VIEWPROPERTIES_STRUCT_W        cvpw = {0};

    if (! (LoadRichEdit())) {
        return(FALSE);
    }

    //
    //  Need to do some Wide Charactoring to move to unicode
    //

    memcpy(&cvpw, pcvp, pcvp->dwSize);

#ifndef MAC
    if (!FIsWin95) {
        if (cvpw.szTitle != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szTitle, -1,
                                      NULL, 0);
            cvpw.szTitle = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cvpw.szTitle == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szTitle, -1,
                                (LPWSTR) cvpw.szTitle, cch+1);
        }

        if (cvpw.szHelpFileName != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szHelpFileName, -1,
                                      NULL, 0);
            cvpw.szHelpFileName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cvpw.szHelpFileName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szHelpFileName, -1,
                                (LPWSTR) cvpw.szHelpFileName, cch+1);
        }
    }
#endif  // !MAC

    ret = CertViewPropertiesX(&cvpw);

#ifndef MAC
ExitW:
    if (!FIsWin95)
        {
        if (cvpw.szTitle != NULL) free((LPWSTR) cvpw.szTitle);
        if (cvpw.szHelpFileName != NULL) free((LPWSTR) cvpw.szHelpFileName);
        }
#endif  // !MAC

    return ret;
}


#ifndef WIN16
#ifndef MAC
////    CertViewPropertiesW
//
//  Description:
//      This routine will display the property view dialog for the given
//      certificate
//

BOOL CertViewPropertiesW(PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    if (CryptUIAvailable()) {
        return CertViewUI(TRUE, pcvp);
    }
    
    if (! (LoadRichEdit())) {
        return(FALSE);
    }

    return CertViewPropertiesX(pcvp);
}
#endif  // !MAC
#endif  // !WIN16

BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    int                 cPages = 4;
    BOOL                fHelp;
    BOOL                fRetValue = FALSE;
    HRESULT             hr;
    PROPSHEETPAGE *     ppage = NULL;
    int                 ret;
    WCHAR               rgwch[100];
    VIEW_HELPER         viewhelp = {0};
#ifndef MAC
#ifndef WIN16
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };
#else
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_LISTVIEW_CLASSES
    };
#endif // !WIN16
#endif  // !MAC

    if (pcvp->dwSize < sizeof(CERT_VIEWPROPERTIES_STRUCT_W)) {
        return FALSE;
    }

    viewhelp.dwSentry = VIEW_HELPER_SENTRY;
    //
    hr = HrDoViewPropsTrustWork(pcvp, &viewhelp, FALSE);

    if (FAILED(hr)) {
        return FALSE;
    }

    if (pcvp->cArrayPurposes == 0) {
        pcvp->dwFlags |= CM_HIDE_TRUSTPAGE;
    }

    //

    fHelp = pcvp->dwFlags & CM_SHOW_HELP;

    //
    //  Deal with some DBCS issues
    //
#ifndef MAC
    InitCommonControlsEx(&initcomm);
#endif  // !MAC

    //
    //  Build up the list of pages we are going to use in the dialog
    //

    cPages += pcvp->cArrayPropSheetPages;
    ppage = (PROPSHEETPAGE *) malloc(cPages * sizeof(PROPSHEETPAGE));
    if (ppage == NULL) {
        goto Exit;
    }

    memset(ppage, 0, cPages * sizeof(PROPSHEETPAGE));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = fHelp ? PSP_HASHELP : 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_GENERAL);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    if (!(pcvp->dwFlags & CM_HIDE_DETAILPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_DETAILS);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageDetails;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    if (!(pcvp->dwFlags & CM_HIDE_TRUSTPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_TRUST);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageTrust;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    if (!(pcvp->dwFlags & CM_HIDE_ADVANCEPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_ADVANCED);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageAdvanced;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    //
    //  Copy over the users pages
    //

    memcpy(&ppage[cPages], pcvp->arrayPropSheetPages,
           pcvp->cArrayPropSheetPages * sizeof(PROPSHEETPAGE));
    cPages += pcvp->cArrayPropSheetPages;

#ifndef MAC
    if (FIsWin95) {
#endif  // !MAC
        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = /*sizeof(hdr)*/ 0x28;
        hdr.dwFlags = PSH_PROPSHEETPAGE;
        hdr.hwndParent = pcvp->hwndParent;
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = (LPSTR) pcvp->szTitle;
        }
        else {
            LoadStringA(HinstDll, IDS_VIEW_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = pcvp->nStartPage;
        hdr.ppsp = (PROPSHEETPAGEA *) ppage;
        hdr.pfnCallback = NULL;

        ret = (int) PropertySheetA(&hdr);
#ifndef MAC
    }
#ifndef WIN16
    else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = /*sizeof(hdr)*/ 0x28;
        hdr.dwFlags = PSH_PROPSHEETPAGE;
        hdr.hwndParent = pcvp->hwndParent;
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = pcvp->szTitle;
        }
        else {
            LoadStringW(HinstDll, IDS_VIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = pcvp->nStartPage;
        hdr.ppsp = ppage;
        hdr.pfnCallback = NULL;

        ret = (int) PropertySheetW(&hdr);
    }
#endif  // !WIN16
#endif  // !MAC


    fRetValue = (ret == IDOK);

Exit:
    if (ppage)
        free(ppage);
    return fRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\dll\dllmain.h ===
//--------------------------------------------------------------------------
// Dllmain.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csDBListen;
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern SYSTEM_INFO          g_SystemInfo;
extern BOOL                 g_fIsWinNT;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\dll\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#define DEFINE_STRCONST
#include "strconst.h"
#include "listen.h"
#include "shared.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
CRITICAL_SECTION    g_csDBListen={0};
SYSTEM_INFO         g_SystemInfo={0};
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
IMalloc            *g_pMalloc=NULL;
BOOL                g_fAttached = FALSE;
BOOL                g_fIsWinNT=FALSE;

// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Locals
    OSVERSIONINFO Version;

    // Process Attach
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        // Set g_hInst
        g_hInst = hInst;

        // Get Mall
        CoGetMalloc(1, &g_pMalloc);

        // Set Version
        Version.dwOSVersionInfoSize = sizeof(Version);

        // Get Version
        if (GetVersionEx(&Version) && Version.dwPlatformId == VER_PLATFORM_WIN32_NT)
            g_fIsWinNT = TRUE;
        else
            g_fIsWinNT = FALSE;

        // Initialize Global Critical Sections
        InitializeCriticalSection(&g_csDllMain);
        InitializeCriticalSection(&g_csDBListen);
        g_fAttached =  TRUE;

        // Get System Info
        GetSystemInfo(&g_SystemInfo);

        // Don't tell me about thread attaches/detaches
        SideAssert(DisableThreadLibraryCalls(hInst));
    }

    // Otherwise, process detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Delete Global Critical Sections
        g_fAttached =  FALSE;
        DeleteCriticalSection(&g_csDllMain);
        DeleteCriticalSection(&g_csDBListen);
    }

    // Done
    return(TRUE);
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // Tracing
    TraceCall("DllCanUnloadNow");

    if(!g_fAttached)    // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Can We Unload
    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Trace
    TraceCall("DllRegisterServer");

    // Register
    return(CallRegInstall(g_hInst, g_hInst, c_szReg, NULL));
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    return(CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\dll\factory.cpp ===
//--------------------------------------------------------------------------
// Factory.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "session.h"

//--------------------------------------------------------------------------
// Pretty
//--------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

//--------------------------------------------------------------------------
// Global Object Info Table
//--------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_DatabaseSession,    OBJTYPE1, (PFCREATEINSTANCE)CreateDatabaseSession),
};
                 
//--------------------------------------------------------------------------
// DllGetClassObject
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CClassFactory::CClassFactory
//--------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

//--------------------------------------------------------------------------
// CClassFactory::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// CClassFactory::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

//--------------------------------------------------------------------------
// CClassFactory::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

//--------------------------------------------------------------------------
// CClassFactory::CreateInstance
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

//--------------------------------------------------------------------------
// CClassFactory::LockServer
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\listen.cpp ===
//--------------------------------------------------------------------------
// Listen.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "listen.h"
#include "utility.h"
#include "database.h"

//--------------------------------------------------------------------------
// Strings
//--------------------------------------------------------------------------
const LPSTR g_szDBListenWndProc = "DirectDBListenWndProc";
const LPSTR g_szDBNotifyWndProc = "DirectDBNotifyWndProc";

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// Monitor Kicks in every 30 Seconds
//--------------------------------------------------------------------------
#define IDT_MONITOR                 8567
#define C_MILLISECONDS_MONITOR      (1000 * 10)
#endif

//--------------------------------------------------------------------------
// LISTENTHREADCREATE
//--------------------------------------------------------------------------
typedef struct tagLISTENTHREADCREATE {
    HRESULT             hrResult;
    HANDLE              hEvent;
} LISTENTHREADCREATE, *LPLISTENTHREADCREATE;

//--------------------------------------------------------------------------
// NOTIFYWINDOW
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOW {
    CDatabase          *pDB;
    IDatabaseNotify    *pNotify;
} NOTIFYWINDOW, *LPNOTIFYWINDOW;

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// MONITORENTRY
//--------------------------------------------------------------------------
typedef struct tagMONITORENTRY *LPMONITORENTRY;
typedef struct tagMONITORENTRY {
    CDatabase          *pDB;
    LPMONITORENTRY      pPrevious;
    LPMONITORENTRY      pNext;
} MONITORENTRY;
#endif

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static HWND             g_hwndListen=NULL;
static HANDLE           g_hListenThread=NULL;
static DWORD            g_dwListenThreadId=0;
static LONG             g_cListenRefs=0;

#ifdef BACKGROUND_MONITOR
static DWORD            g_cMonitor=0;
static LPMONITORENTRY   g_pMonitorHead=NULL;
static LPMONITORENTRY   g_pMonitorPoll=NULL;
#endif

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
DWORD ListenThreadEntry(LPDWORD pdwParam);
LRESULT CALLBACK ListenThreadWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK NotifyThunkWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//--------------------------------------------------------------------------
// GetListenWindow
//--------------------------------------------------------------------------
HRESULT GetListenWindow(HWND *phwndListen)
{
    // Trace
    TraceCall("GetListenWindow");

    // Validate Listen Window Handle
    Assert(g_hwndListen && IsWindow(g_hwndListen));

    // Return
    *phwndListen = g_hwndListen;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CreateListenThread
//--------------------------------------------------------------------------
HRESULT CreateListenThread(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LISTENTHREADCREATE  Create={0};

    // Trace
    TraceCall("CreateListenThread");

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Already Running ?
    if (NULL != g_hListenThread)
        goto exit;

    // Initialize
    Create.hrResult = S_OK;

    // Create an Event to synchonize creation
    IF_NULLEXIT(Create.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL));

    // Create the inetmail thread
    IF_NULLEXIT(g_hListenThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ListenThreadEntry, &Create, 0, &g_dwListenThreadId));

    // Wait for StoreCleanupThreadEntry to signal the event
    WaitForSingleObject(Create.hEvent, INFINITE);

    // Failure
    if (FAILED(Create.hrResult))
    {
        // Close
        SafeCloseHandle(g_hListenThread);

        // Reset Globals
        g_dwListenThreadId = 0;

        // Null Window
        g_hwndListen = NULL;

        // Return
        hr = TraceResult(Create.hrResult);

        // Done
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Cleanup
    SafeCloseHandle(Create.hEvent);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ListenThreadAddRef
//--------------------------------------------------------------------------
ULONG ListenThreadAddRef(void)
{
    TraceCall("ListenThreadAddRef");
    return InterlockedIncrement(&g_cListenRefs);
}

//--------------------------------------------------------------------------
// ListenThreadRelease
//--------------------------------------------------------------------------
ULONG ListenThreadRelease(void)
{
    // Trace
    TraceCall("ListenThreadRelease");

    // Decrement
    LONG cRef = InterlockedDecrement(&g_cListenRefs);

    // If still refs, just return
    if (g_cListenRefs > 0)
        return(g_cListenRefs);

    // Invalid Arg
    if (NULL == g_hListenThread)
        goto exit;

    // Assert
    Assert(g_dwListenThreadId && g_hListenThread);

    // Post quit message
    PostThreadMessage(g_dwListenThreadId, WM_QUIT, 0, 0);

    // Wait for event to become signaled
    WaitForSingleObject(g_hListenThread, INFINITE);

    // Validate
    Assert(NULL == g_hwndListen);

    // Close the thread handle
    CloseHandle(g_hListenThread);

    // Reset Globals
    g_hListenThread = NULL;
    g_dwListenThreadId = 0;

    // Un-Register Window Classes
    UnregisterClass(g_szDBListenWndProc, g_hInst);
    UnregisterClass(g_szDBNotifyWndProc, g_hInst);

exit:
    // Done
    return(0);
}

#ifdef BACKGROUND_MONITOR

// --------------------------------------------------------------------------------
// RegisterWithMonitor
// --------------------------------------------------------------------------------
HRESULT RegisterWithMonitor(CDatabase *pDB, LPHMONITORDB phMonitor)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMONITORENTRY      pMonitor=NULL;

    // Trace
    TraceCall("RegisterWithMonitor");

    // Invalid Args
    Assert(pDB && phMonitor);

    // Allocate a new monitor entry
    IF_NULLEXIT(pMonitor = (LPMONITORENTRY)ZeroAllocate(sizeof(MONITORENTRY)));

    // Store the Database
    pMonitor->pDB = pDB;

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Set pNext
    pMonitor->pNext = g_pMonitorHead;

    // pPrevious
    if (g_pMonitorHead)
        g_pMonitorHead->pPrevious = pMonitor;

    // Reset Head
    g_pMonitorHead = pMonitor;

    // Count Number in Monitor
    g_cMonitor++;

    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Return phMonitor
    *phMonitor = (HMONITORDB)pMonitor;

    // Don't Free
    pMonitor = NULL;

exit:
    // Cleanup
    SafeMemFree(pMonitor);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// UnregisterFromMonitor
// --------------------------------------------------------------------------------
HRESULT UnregisterFromMonitor(CDatabase *pDB, LPHMONITORDB phMonitor)
{
    // Locals
    LPMONITORENTRY pMonitor;

    // Trace
    TraceCall("UnregisterFromMonitor");

    // Invalid Args
    Assert(pDB && phMonitor);

    // Nothing ?
    if (NULL == *phMonitor)
        return(S_OK);

    // Set pMonitor
    pMonitor = (LPMONITORENTRY)(*phMonitor);

    // Validate
    Assert(pMonitor->pDB == pDB);

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Fixup Next->Previous
    if (pMonitor->pNext)
    {
        Assert(pMonitor->pNext->pPrevious == pMonitor);
        pMonitor->pNext->pPrevious = pMonitor->pPrevious;
    }

    // Fixup Previous->Next
    if (pMonitor->pPrevious)
    {
        Assert(pMonitor->pPrevious->pNext == pMonitor);
        pMonitor->pPrevious->pNext = pMonitor->pNext;
    }

    // Otherwise, pMonitor must be the head
    else
    {
        // Validate
        Assert(g_pMonitorHead == pMonitor);

        // Set new Head
        g_pMonitorHead = pMonitor->pNext;
    }

    // Adjust g_pMonitorPoll
    if (g_pMonitorPoll == pMonitor)
    {
        // Goto Next
        g_pMonitorPoll = pMonitor->pNext;
    }

    // Count Number in Monitor
    g_cMonitor--;

    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Free pMonitor
    g_pMalloc->Free(pMonitor);

    // Null the Handle
    *phMonitor = NULL;

    // Done
    return(S_OK);
}
#endif

// --------------------------------------------------------------------------------
// ListenThreadEntry
// --------------------------------------------------------------------------------
DWORD ListenThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT                 hr=S_OK;
    MSG                     msg;
    DWORD                   dw;
    DWORD                   cb;
#ifdef BACKGROUND_MONITOR
    UINT_PTR                uTimer;
#endif
    LPLISTENTHREADCREATE    pCreate;

    // Trace
    TraceCall("ListenThreadEntry");

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPLISTENTHREADCREATE)pdwParam;

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szDBListenWndProc, ListenThreadWndProc));

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szDBListenWndProc, NULL, &g_hwndListen));

#ifdef BACKGROUND_MONITOR
    // Start the Montior Timer
    uTimer = SetTimer(g_hwndListen, IDT_MONITOR, C_MILLISECONDS_MONITOR, NULL);

    // Failure
    if (0 == uTimer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }
#endif

    // Success
    pCreate->hrResult = S_OK;

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // Translate the Message
        TranslateMessage(&msg);

        // Dispatch the Message
        DispatchMessage(&msg);
    }

#ifdef BACKGROUND_MONITOR
    // Validate
    IxpAssert(NULL == g_pMonitorHead && 0 == g_cMonitor);
#endif

#if 0
    // If there are still open databases, we need to force close them so that they get closed propertly
    while (g_pMonitorHead)
    {
        // Unregister...
        if (g_pMonitorHead)
        {
            // Delete pDB
            delete g_pMonitorHead->pDB;
        }
    }
#endif

#ifdef BACKGROUND_MONITOR
    // Kill the Timer
    KillTimer(g_hwndListen, uTimer);
#endif

    // Kill the Window
    DestroyWindow(g_hwndListen);

    // Null It Out
    g_hwndListen = NULL;

exit:
    // Failure
    if (FAILED(hr))
    {
        // Set the Failure Code
        pCreate->hrResult = hr;

        // Trigger the Event
        SetEvent(pCreate->hEvent);
    }

    // Done
    return(1);
}

// --------------------------------------------------------------------------------
// CreateNotifyWindow
// --------------------------------------------------------------------------------
HRESULT CreateNotifyWindow(CDatabase *pDB, IDatabaseNotify *pNotify, HWND *phwndThunk)
{
    // Locals
    HRESULT             hr=S_OK;
    NOTIFYWINDOW    WindowInfo={0};

    // Trace
    TraceCall("CreateNotifyWindow");

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szDBNotifyWndProc, NotifyThunkWndProc));

    // Set WindowInfo
    WindowInfo.pDB = pDB;
    WindowInfo.pNotify = pNotify;

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szDBNotifyWndProc, &WindowInfo, phwndThunk));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// ListenThreadWndProc - Used ONLY for Cross-Process Thunking
// --------------------------------------------------------------------------------
LRESULT CALLBACK ListenThreadWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("ListenThreadWndProc");

    // Handle WM_COPYDATA Messages
    if (WM_COPYDATA == msg)
    {
        // Cast the Copy Data Structure
        PCOPYDATASTRUCT pCopyData=(PCOPYDATASTRUCT)lParam;

        // Validate dwData
        Assert(0 == pCopyData->dwData);

        // Cast the pPackage Structure
        LPINVOKEPACKAGE pPackage=(LPINVOKEPACKAGE)pCopyData->lpData;

        // Validate the Size
        Assert(pCopyData->cbData == sizeof(INVOKEPACKAGE));

        // Cast the CDatabase
        CDatabase *pDB=(CDatabase *)pPackage->pDB;

        // Process the Package
        pDB->DoInProcessInvoke(pPackage->tyInvoke);

        // Done
        return 1;
    }

#ifdef BACKGROUND_MONITOR
    // Timer
    else if (WM_TIMER == msg && IDT_MONITOR == wParam)
    {
        // Thread Safety
        EnterCriticalSection(&g_csDBListen);

        // Get pMonitor
        LPMONITORENTRY pMonitor = g_pMonitorPoll ? g_pMonitorPoll : g_pMonitorHead;

        // Set Current
        if (pMonitor)
        {
            // Validate
            Assert(pMonitor->pDB);

            // Background Monitor
            pMonitor->pDB->DoBackgroundMonitor();

            // Set g_pMonitorPoll
            g_pMonitorPoll = pMonitor->pNext;
        }
        
        // Thread Safety
        LeaveCriticalSection(&g_csDBListen);
    }
#endif

    // Deletegate
    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

// --------------------------------------------------------------------------------
// NotifyThunkWndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK NotifyThunkWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPNOTIFYWINDOW  pWindow;

    // Trace
    TraceCall("NotifyThunkWndProc");

    // WM_ONTRANSACTION
    if (WM_ONTRANSACTION == msg)
    {
        // Get Window Info
        pWindow = (LPNOTIFYWINDOW)GetWndThisPtr(hwnd);

        // Deliver the Notification
        pWindow->pNotify->OnTransaction((HTRANSACTION)lParam, (DWORD)wParam, pWindow->pDB);

        // Done
        return(TRUE);
    }

    // Create ?
    else if (WM_CREATE == msg)
    {
        // Create Struct
        LPCREATESTRUCT pCreate = (LPCREATESTRUCT)lParam;

        // Create Params
        LPNOTIFYWINDOW pCreateInfo = (LPNOTIFYWINDOW)pCreate->lpCreateParams;

        // Validate
        Assert(pCreateInfo->pDB && pCreateInfo->pNotify);

        // Allocate NOTIFYWINDOW
        pWindow = (LPNOTIFYWINDOW)ZeroAllocate(sizeof(NOTIFYWINDOW));

        // Failure ?
        if (NULL == pWindow)
            return(-1);

        // Copy the Create Information
        CopyMemory(pWindow, pCreateInfo, sizeof(NOTIFYWINDOW));

        // Store pInfo into this
        SetWndThisPtr(hwnd, pWindow);

        // Done
        return(FALSE);
    }

    // Destroy
    else if (WM_DESTROY == msg)
    {
        // Get Window Info
        pWindow = (LPNOTIFYWINDOW)GetWndThisPtr(hwnd);

        // Free It
        g_pMalloc->Free(pWindow);

        // Store pInfo into this
        SetWndThisPtr(hwnd, NULL);
    }

    // Deletegate
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\database.cpp ===
//--------------------------------------------------------------------------
// Database.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "stream.h"
#include "types.h"
#include "listen.h"
#include "resource.h"
#include "shlwapi.h"
#include "strconst.h"
#include "query.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// Use Heap and/or Cache
//--------------------------------------------------------------------------
//#ifndef DEBUG
#define USEHEAP                 1
#define HEAPCACHE               1
//#endif  // DEBUG

//--------------------------------------------------------------------------
// Storage Block Access Macros
//--------------------------------------------------------------------------
#define PSTRING(_pBlock)        ((LPSTR)((LPBYTE)_pBlock + sizeof(BLOCKHEADER)))
#define PUSERDATA(_pHeader)     (LPBYTE)((LPBYTE)_pHeader + sizeof(TABLEHEADER))

//--------------------------------------------------------------------------
// g_rgcbBlockSize - Block Sizes
//--------------------------------------------------------------------------
const static WORD g_rgcbBlockSize[BLOCK_LAST] = {
    sizeof(RECORDBLOCK),        // BLOCK_RECORD
    sizeof(BLOCKHEADER),        // BLOCK_FILTER
    0,                          // BLOCK_RESERVED1
    sizeof(TRANSACTIONBLOCK),   // BLOCK_TRANSACTION
    sizeof(CHAINBLOCK),         // BLOCK_CHAIN
    sizeof(STREAMBLOCK),        // BLOCK_STREAM
    sizeof(FREEBLOCK),          // BLOCK_FREE
    sizeof(BLOCKHEADER),        // BLOCK_ENDOFPAGE
    0,                          // BLOCK_RESERVED2
    0                           // BLOCK_RESERVED3
};

//--------------------------------------------------------------------------
// ZeroBlock
//--------------------------------------------------------------------------
inline void ZeroBlock(LPBLOCKHEADER pBlock, DWORD cbSize) {
    ZeroMemory((LPBYTE)pBlock + sizeof(BLOCKHEADER), cbSize - sizeof(BLOCKHEADER));
}

//--------------------------------------------------------------------------
// CopyBlock
//--------------------------------------------------------------------------
inline void CopyBlock(LPBLOCKHEADER pDest, LPBLOCKHEADER pSource, DWORD cbSize) {
    CopyMemory((LPBYTE)pDest + sizeof(BLOCKHEADER), (LPBYTE)pSource + sizeof(BLOCKHEADER), cbSize - sizeof(BLOCKHEADER));
}

//--------------------------------------------------------------------------
// SafeFreeBinding
//--------------------------------------------------------------------------
#define SafeFreeBinding(_pBinding) \
    if (_pBinding) { \
        FreeRecord(_pBinding); \
        HeapFree(_pBinding); \
        _pBinding = NULL; \
    } else

//--------------------------------------------------------------------------
// SafeHeapFree
//--------------------------------------------------------------------------
#define SafeHeapFree(_pvBuffer) \
    if (_pvBuffer) { \
        HeapFree(_pvBuffer); \
        _pvBuffer = NULL; \
    } else

//--------------------------------------------------------------------------
// UnmapViewOfFileWithFlush
//--------------------------------------------------------------------------
inline void UnmapViewOfFileWithFlush(BOOL fFlush, LPVOID pView, DWORD cbView) 
{
    // If we have a view
    if (pView) 
    {
        // Flush It ?
        if (fFlush)
        {
            // Flush
            SideAssert(0 != FlushViewOfFile(pView, cbView));
        }

        // UnMap It
        SideAssert(0 != UnmapViewOfFile(pView));
    }
}

//--------------------------------------------------------------------------
// PTagFromOrdinal
//--------------------------------------------------------------------------
inline LPCOLUMNTAG PTagFromOrdinal(LPRECORDMAP pMap, COLUMNORDINAL iColumn)
{
    // Locals
    LONG        lLower=0;
    LONG        lUpper=pMap->cTags-1;
    LONG        lCompare;
    WORD        wMiddle;
    LPCOLUMNTAG pTag;

    // Do binary search / insert
    while (lLower <= lUpper)
    {
        // Set lMiddle
        wMiddle = (WORD)((lLower + lUpper) / 2);

        // Compute middle record to compare against
        pTag = &pMap->prgTag[(WORD)wMiddle];

        // Get string to compare against
        lCompare = (iColumn - pTag->iColumn);

        // If Equal, then were done
        if (lCompare == 0)
            return(pTag);

        // Compute upper and lower 
        if (lCompare > 0)
            lLower = (LONG)(wMiddle + 1);
        else 
            lUpper = (LONG)(wMiddle - 1);
    }       

    // Not Found
    return(NULL);
}

//--------------------------------------------------------------------------
// CDatabase::CDatabase
//--------------------------------------------------------------------------
CDatabase::CDatabase(void)
{
    TraceCall("CDatabase::CDatabase");
    Assert(9404 == sizeof(TABLEHEADER));
    IF_DEBUG(DWORD dw);
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgdwReserved2));
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgIndexInfo));
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgdwReserved3));
    Assert(offsetof(TABLEHEADER, rgdwReserved2) == 444);
    Assert(offsetof(TABLEHEADER, rgIndexInfo) == 8892);
    Assert(offsetof(TABLEHEADER, rgdwReserved3) == 9294);
    m_cRef = 1;
    m_cExtRefs = 0;
    m_pSchema = NULL;
    m_pStorage = NULL;
    m_pShare = NULL;
    m_hMutex = NULL;
    m_pHeader = NULL;
    m_hHeap = NULL;
    m_fDeconstruct = FALSE;
    m_fInMoveFile = FALSE;
    m_fExclusive = FALSE;
    m_dwProcessId = GetCurrentProcessId();
    m_dwQueryVersion = 0;
    m_pExtension = NULL;
    m_pUnkRelease = NULL;
    m_fDirty = FALSE;
#ifdef BACKGROUND_MONITOR
    m_hMonitor = NULL;
#endif
    m_fCompactYield = FALSE;
    ZeroMemory(m_rgpRecycle, sizeof(m_rgpRecycle));
    ZeroMemory(m_rghFilter, sizeof(m_rghFilter));
    InitializeCriticalSection(&m_csHeap);
    IF_DEBUG(m_cbHeapFree = m_cbHeapAlloc = 0);
    ListenThreadAddRef();
    DllAddRef();
}

//--------------------------------------------------------------------------
// CDatabase::~CDatabase
//--------------------------------------------------------------------------
CDatabase::~CDatabase(void)
{
    // Locals
    DWORD cClients=0;
    DWORD i;

    // Trace
    TraceCall("CDatabase::~CDatabase");

    // Release the Extension
    SafeRelease(m_pUnkRelease);

    // Decrement Thread Count
    if (NULL == m_hMutex)
        goto exit;

#ifdef BACKGROUND_MONITOR
    // UnRegister...
    if (m_hMonitor)
    {
        // Unregister
        SideAssert(SUCCEEDED(UnregisterFromMonitor(this, &m_hMonitor)));
    }
#endif

    // Wait for the Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // If I have a m_pShare
    if (m_pStorage)
    {
        // If we have an m_pShare
        if (m_pShare)
        {
            // Decrement the thread Count
            if (m_pHeader && m_pHeader->cActiveThreads > 0)
            {
                // Decrement Thread Count
                m_pHeader->cActiveThreads--;
            }

            // Set State that we are de-constructing
            m_fDeconstruct = TRUE;

            // Remove Client From Array
            SideAssert(SUCCEEDED(_RemoveClientFromArray(m_dwProcessId, (DWORD_PTR)this)));

            // Save Client Count
            cClients = m_pShare->cClients;

            // No more client
            Assert(0 == cClients ? 0 == m_pShare->Rowsets.cUsed : TRUE);
        }

        // _CloseFileViews
        _CloseFileViews(FALSE);

        // Close the File
        SafeCloseHandle(m_pStorage->hMap);

        // Unmap the view of the memory mapped file
        SafeUnmapViewOfFile(m_pShare);

        // Unmap the view of the memory mapped file
        SafeCloseHandle(m_pStorage->hShare);

        // Close the File
        if(m_pStorage->hFile /*&& m_fDirty*/)
        {
            FILETIME systime;
            GetSystemTimeAsFileTime(&systime);
    
            SetFileTime(m_pStorage->hFile, NULL, &systime, &systime);
        }

        SafeCloseHandle(m_pStorage->hFile);

        // Free the mapping name
        SafeMemFree(m_pStorage->pszMap);

        // Free m_pStorage
        SafeMemFree(m_pStorage);
    }

    // Close all the Query Handles
    for (i=0; i<CMAX_INDEXES; i++)
    {
        // Close the Query
        CloseQuery(&m_rghFilter[i], this);
    }

    // Free the Heap Cache
    for (i=0; i<CC_HEAP_BUCKETS; i++)
    {
        // Locals
        LPMEMORYTAG pTag;
        LPVOID      pNext;
        LPVOID      pCurrent=(LPVOID)m_rgpRecycle[i];

        // While we have something to free
        while(pCurrent)
        {
            // Set Tag
            pTag = (LPMEMORYTAG)pCurrent;

            // Debug
            IF_DEBUG(m_cbHeapFree += pTag->cbSize);

            // Save Next
            pNext = pTag->pNext;

            // Free Current
#ifdef USEHEAP
            ::HeapFree(m_hHeap, HEAP_NO_SERIALIZE, pCurrent);
#else
            g_pMalloc->Free(pCurrent);
#endif

            // Set Current
            pCurrent = pNext;
        }

        // Null It
        m_rgpRecycle[i] = NULL;
    }

    // Leaks ?
    Assert(m_cbHeapAlloc == m_cbHeapFree);

    // Release the Heap
    if (m_hHeap)
    {
        // HeapDestroy
        HeapDestroy(m_hHeap);

        // Don't free again
        m_hHeap = NULL;
    }

    // Reset Locals
    m_pSchema = NULL;

    // Release the mutex
    ReleaseMutex(m_hMutex);

    // Close the Table Mutex
    CloseHandle(m_hMutex);

    // Delete Crit Sect.
    DeleteCriticalSection(&m_csHeap);

exit:
    // Release the listen thread
    ListenThreadRelease();

    // Release Dll
    DllRelease();

    // Done
    return;
}

//--------------------------------------------------------------------------
// CDatabase::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabase::AddRef(void)
{
    // Trace
    TraceCall("CDatabase::AddRef");

    // AddRef the Extension...
    if (m_pExtension && NULL == m_pUnkRelease)
    {
        // Keep Track of how many times I have addref'ed the extension
        InterlockedIncrement(&m_cExtRefs);

        // AddRef It
        m_pExtension->AddRef();
    }

    // Increment My Ref Count
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CDatabase::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabase::Release(void)
{
    // Trace
    TraceCall("CDatabase::Release");

    // Release the Extension...
    if (m_pExtension && NULL == m_pUnkRelease && m_cExtRefs > 0)
    {
        // Keep Track of how many times I have addref'ed the extension
        InterlockedDecrement(&m_cExtRefs);

        // AddRef It
        m_pExtension->Release();
    }

    // Do My Release
    LONG cRef = InterlockedDecrement(&m_cRef);

    // If zero, delete
    if (0 == cRef)
        delete this;

    // Return Ref Count
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CDatabase::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CDatabase::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IDatabase *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_CDatabase == riid)
        *ppv = (CDatabase *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Open
//--------------------------------------------------------------------------
HRESULT CDatabase::Open(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszShare=NULL;
    LPWSTR          pszMutex=NULL;
    LPWSTR          pszFilePath=NULL;
    BOOL            fNewShare;
    BOOL            fNewFileMap;
    BOOL            fFileCreated;
    BOOL            fFileCorrupt = FALSE;
    DWORD           cbInitialSize;
    DWORD           cbMinFileSize;
    DWORD           cchFilePath;
    LPCLIENTENTRY   pClient;

    // Trace
    TraceCall("CDatabase::Open");

    // Invalid Args
    Assert(pszFile && pSchema);

    // Already Open ?
    if (m_hMutex)
        return(TraceResult(DB_E_ALREADYOPEN));

    // Get the Full Path
    IF_FAILEXIT(hr = DBGetFullPath(pszFile, &pszFilePath, &cchFilePath));

    // Failure
    if (cchFilePath >= CCHMAX_DB_FILEPATH)
    {
        SafeMemFree(pszFilePath);
        return(TraceResult(E_INVALIDARG));
    }

    // Don't use pszFile again
    pszFile = NULL;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBMutex", &pszMutex));

    // Create the Mutex
    IF_NULLEXIT(m_hMutex = CreateMutexWrapW(NULL, FALSE, pszMutex));

    // Wait for the Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // Create the Heap
    IF_NULLEXIT(m_hHeap = HeapCreate(0, 8096, 0));

    // No Listen Window Yet ?
    IF_FAILEXIT(hr = CreateListenThread());

    // Save the Record Format, this should be global const data, so no need to duplicate it
    m_pSchema = pSchema;
    cbMinFileSize = sizeof(TABLEHEADER) + m_pSchema->cbUserData;

    // Validate
    IF_DEBUG(_DebugValidateRecordFormat());

    // Allocate m_pStorage
    IF_NULLEXIT(m_pStorage = (LPSTORAGEINFO)ZeroAllocate(sizeof(STORAGEINFO)));

    // Exclusive
    m_fExclusive = (ISFLAGSET(dwFlags, OPEN_DATABASE_EXCLUSEIVE) ? TRUE : FALSE);

    // Open the File
    IF_FAILEXIT(hr = DBOpenFile(pszFilePath, ISFLAGSET(dwFlags, OPEN_DATABASE_NOCREATE), m_fExclusive, &fFileCreated, &m_pStorage->hFile));

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBShare", &pszShare));

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));

    // New Share
    if (TRUE == fNewShare)
    {
        // Zero Out m_pShare
        ZeroMemory(m_pShare, sizeof(SHAREDDATABASE));

        // Copy the file name
        StrCpyNW(m_pShare->szFile, pszFilePath, ARRAYSIZE(m_pShare->szFile));

        // Fixup the Query Table Version
        m_pShare->dwQueryVersion = 1;
    }

    // Too Many clients ?
    if (m_pShare->cClients == CMAX_CLIENTS)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Readability
    pClient = &m_pShare->rgClient[m_pShare->cClients];

    // Initialize the Entry
    ZeroMemory(pClient, sizeof(CLIENTENTRY));

    // Get the listen window
    GetListenWindow(&pClient->hwndListen);

    // Register Myself
    pClient->dwProcessId = m_dwProcessId;
    pClient->pDB = (DWORD_PTR)this;

    // Incrment Count
    m_pShare->cClients++;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(m_pShare->szFile, L"_DirectDBFileMap", &m_pStorage->pszMap));

    // Get the file size
    IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &cbInitialSize));

    // If the file is too small to handle the header, then we either have a corrupt file
    // that is way too corrupt to be saved, or we have an invalid file. Take some
    // defensive measures to make sure we can continue
    if (!fFileCreated && (cbInitialSize < cbMinFileSize))
    {
        fFileCorrupt = TRUE;

        // If we can't reset or create, then must exit 
        if (ISFLAGSET(dwFlags, OPEN_DATABASE_NORESET) || ISFLAGSET(dwFlags, OPEN_DATABASE_NOCREATE))
        {
            IF_FAILEXIT(hr = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT));
        }
        // If we can reset, let's make sure the mapping file is the appropriate size
        else
        {
            cbInitialSize = 0;
        }
    }

    // Validate
    Assert(fFileCreated ? 0 == cbInitialSize : TRUE);

    // If zero, must be a new file or corrupt one(lets create with 1 byte header)
    if (0 == cbInitialSize)
    {
        Assert(fFileCorrupt || fFileCreated);

        // Initial Size
        m_pStorage->cbFile = cbMinFileSize;
    }

    // Otherwise, Set m_pStorage->cbFile
    else
        m_pStorage->cbFile = cbInitialSize;

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNewFileMap, &m_pStorage->hMap, NULL));

    // _InitializeFileViews
    IF_FAILEXIT(hr = _InitializeFileViews());

    // New File or corrupt?
    if (fFileCreated || fFileCorrupt)
    {
        // Validate
        Assert ((fFileCreated && fNewFileMap) || fFileCorrupt);

        // Reset Table Header
        IF_FAILEXIT(hr = _ResetTableHeader());
    }

    // Otherwise
    else
    {
        // Adjust pHeader->faNextAllocate for previous versions...
        if (0 == m_pHeader->faNextAllocate)
        {
            // The next storage grow address
            m_pHeader->faNextAllocate = m_pStorage->cbFile;
        }

        // faNextAllocate is Invalid
        else if (m_pHeader->faNextAllocate > m_pStorage->cbFile)
        {
            // Assert
            AssertSz(FALSE, "m_pHeader->faNextAllocate is beyond the end of the file.");

            // The next storage grow address
            m_pHeader->faNextAllocate = m_pStorage->cbFile;

            // Check for Corruption
            m_pHeader->fCorruptCheck = FALSE;
        }
    }

    // Validate File Versions and Signatures
    IF_FAILEXIT(hr = _ValidateFileVersions(dwFlags));

    // Reload query table
    IF_FAILEXIT(hr = _BuildQueryTable());

    // No Indexes, must need to initialize index info
    if (0 == m_pHeader->cIndexes)
    {
        // Copy Primary Index Information...
        CopyMemory(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex, sizeof(TABLEINDEX));

        // We now have one index
        m_pHeader->cIndexes = 1;

        // Validate
        Assert(IINDEX_PRIMARY == m_pHeader->rgiIndex[0] && 0 == m_pHeader->rgcRecords[IINDEX_PRIMARY] && 0 == m_pHeader->rgfaIndex[IINDEX_PRIMARY]);
    }

    // Otherwise, if definition of primary index has changed!!!
    else if (S_FALSE == CompareTableIndexes(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex))
    {
        // Copy Primary Index Information...
        CopyMemory(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex, sizeof(TABLEINDEX));

        // Rebuild the Primary Index...
        IF_FAILEXIT(hr = _RebuildIndex(IINDEX_PRIMARY));
    }

    // New Share
    if (TRUE == fNewFileMap)
    {
        // Don't Free Transact list if transaction block size has changed
        if (m_pHeader->wTransactSize == sizeof(TRANSACTIONBLOCK))
        {
            // Transaction Trail should be free
            _CleanupTransactList();
        }

        // Reset Everything
        m_pHeader->faTransactHead = m_pHeader->faTransactTail = m_pHeader->cTransacts = 0;

        // Set Transaction Block Size
        m_pHeader->wTransactSize = sizeof(TRANSACTIONBLOCK);

        // Bad close ?
        if (m_pHeader->cActiveThreads > 0)
        {
            // Increment Bad Close Count
            m_pHeader->cBadCloses++;

            // Reset Process Count
            m_pHeader->cActiveThreads = 0;
        }
    }

    // Otherwise, if the corrupt bit is set, run the repair code
    if (TRUE == m_pHeader->fCorrupt || FALSE == m_pHeader->fCorruptCheck)
    {
        // Lets validate the tree
        IF_FAILEXIT(hr = _CheckForCorruption());

        // Better not be corrupt
        Assert(FALSE == m_pHeader->fCorrupt);

        // Checked for Corruption
        m_pHeader->fCorruptCheck = TRUE;
    }

    // Initialize Database Extension
    _InitializeExtension(dwFlags, pExtension);

#ifdef BACKGROUND_MONITOR
    // If nomonitor is not set
    if (!ISFLAGSET(dwFlags, OPEN_DATABASE_NOMONITOR))
    {
        // Keep on eye on me...
        IF_FAILEXIT(hr = RegisterWithMonitor(this, &m_hMonitor));
    }
#endif

    // Increment Number of Processes
    m_pHeader->cActiveThreads++;

exit:
    // Release the Mutex
    if (m_hMutex)
        ReleaseMutex(m_hMutex);

    // Cleanup
    SafeMemFree(pszShare);
    SafeMemFree(pszMutex);
    SafeMemFree(pszFilePath);

    // Done
    return(hr);
}

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// CDatabase::DoBackgroundMonitor
//--------------------------------------------------------------------------
HRESULT CDatabase::DoBackgroundMonitor(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPFILEVIEW      pView;
    LPFILEVIEW      pNext;
    BOOL            fUnmapViews=TRUE;

    // bobn, 7/8/99
    // Occasionally, m_pSchema can be invalid due to a race condition in SMAPI
    // We need to protect against that.  We are too close to ship to 
    // find the race condition and re-architect the product to fix completely
    // this corner case.
    if (IsBadReadPtr(m_pSchema, sizeof(TABLESCHEMA)))
        return(TraceResult(E_FAIL));

    // No Mutex
    if (NULL == m_hMutex)
        return(TraceResult(E_FAIL));

    // Leave Spin Lock
    if (WAIT_OBJECT_0 != WaitForSingleObject(m_hMutex, 500))
        return(S_OK);

    // No Header ?
    if (NULL == m_pHeader)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // No Storage
    if (NULL == m_pStorage)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

#if 0
    // Un-map file views ?
    if (0 == m_pStorage->tcMonitor)
    {
        // I will unmap all views
        fUnmapViews = FALSE;
    }
#endif

    // Always Flush the header
    m_fDirty = TRUE;
    if (0 == FlushViewOfFile(m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData))
    {
        hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
        goto exit;
    }

    // Walk through prgView
    for (i=0; i<m_pStorage->cAllocated; i++)
    {
        // Readability
        pView = &m_pStorage->prgView[i];

        // Is Mapped ?
        if (pView->pbView)
        {
            // Flush the header
            if (0 == FlushViewOfFile(pView->pbView, pView->cbView))
            {
                hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
                goto exit;
            }

            // Flush and UnMap the Views...
            if (TRUE == fUnmapViews)
            {
                // Unmap 
                UnmapViewOfFile(pView->pbView);

                // No view
                pView->pbView = NULL;

                // No view
                pView->faView = pView->cbView = 0;
            }
        }
    }

    // Walk through pSpecial
    pView = m_pStorage->pSpecial;

    // While we have a Current
    while (pView)
    {
        // Save pNext
        pNext = pView->pNext;

        // Is Mapped ?
        if (pView->pbView)
        {
            // Flush the header
            if (0 == FlushViewOfFile(pView->pbView, pView->cbView))
            {
                hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
                goto exit;
            }

            // Flush and UnMap the Views...
            if (TRUE == fUnmapViews)
            {
                // Unmap 
                UnmapViewOfFile(pView->pbView);

                // No view
                pView->pbView = NULL;

                // No view
                pView->faView = pView->cbView = 0;

                // Free pView
                HeapFree(pView);
            }
        }

        // Goto Next
        pView = pNext;
    }

    // Reset Head
    if (TRUE == fUnmapViews)
    {
        // No more special views
        m_pStorage->pSpecial = NULL;

        // No more special views
        m_pStorage->cSpecial = 0;

        // No Mapped Views
        m_pStorage->cbMappedViews = 0;

        // No Mapped Special Views
        m_pStorage->cbMappedSpecial = 0;
    }

    // Save tcMonitor
    m_pStorage->tcMonitor = GetTickCount();

exit:
    // Release the Mutex
    ReleaseMutex(m_hMutex);

    // Done
    return(hr);
}
#endif

//--------------------------------------------------------------------------
// CDatabase::_CloseFileViews
//--------------------------------------------------------------------------
HRESULT CDatabase::_CloseFileViews(BOOL fFlush)
{
    // Locals
    LPFILEVIEW  pCurrent;
    LPFILEVIEW  pNext;
    DWORD       i;

    // Trace
    TraceCall("CDatabase::_CloseFileViews");

    // Unmap the view of the header
    UnmapViewOfFileWithFlush(fFlush, m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Walk through prgView
    for (i = 0; i < m_pStorage->cAllocated; i++)
    {
        // Readability
        pCurrent = &m_pStorage->prgView[i];

        // Unmap with possible flush
        UnmapViewOfFileWithFlush(fFlush, pCurrent->pbView, pCurrent->cbView);
    }

    // Free prgView
    SafeHeapFree(m_pStorage->prgView);

    // No Views are mapped
    m_pStorage->cbMappedViews = 0;

    // Zero cAllocate
    m_pStorage->cAllocated = 0;

    // Walk through pSpecial
    pCurrent = m_pStorage->pSpecial;

    // While we have a Current
    while (pCurrent)
    {
        // Save pNext
        pNext = pCurrent->pNext;

        // Unmap the view
        UnmapViewOfFileWithFlush(fFlush, pCurrent->pbView, pCurrent->cbView);

        // Free pCurrent
        HeapFree(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Reset Head
    m_pStorage->pSpecial = NULL;

    // No Special Mapped
    m_pStorage->cbMappedSpecial = 0;

    // No Special
    m_pStorage->cSpecial = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_InitializeFileViews
//--------------------------------------------------------------------------
HRESULT CDatabase::_InitializeFileViews(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faView;
    DWORD           cbView;

    // Trace
    TraceCall("CDatabase::_InitializeFileViews");

    // Validate State
    Assert(NULL == m_pStorage->prgView && NULL == m_pStorage->pSpecial);

    // Set cAllocated
    m_pStorage->cAllocated = (m_pStorage->cbFile / CB_MAPPED_VIEW) + 1;

    // Allocate prgView
    IF_NULLEXIT(m_pStorage->prgView = (LPFILEVIEW)PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(FILEVIEW) * m_pStorage->cAllocated));

    // Set faView
    faView = 0;

    // Set cbView
    cbView = (sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Map m_pHeader into its own view...
    IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &faView, &cbView, (LPVOID *)&m_pHeader));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_InitializeExtension
//--------------------------------------------------------------------------
HRESULT CDatabase::_InitializeExtension(OPENDATABASEFLAGS dwFlags,
    IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CDatabase::_InitializeExtension");

    // Extension Allowed
    if (ISFLAGSET(dwFlags, OPEN_DATABASE_NOEXTENSION))
        goto exit;

    // Doesn't have an extension ?
    if (FALSE == ISFLAGSET(m_pSchema->dwFlags, TSF_HASEXTENSION))
        goto exit;

    // Create the Extension Object
    if (pExtension)
    {
        // Assume It
        m_pExtension = pExtension;

        // Can I add ref it ?
        if (FALSE == ISFLAGSET(dwFlags, OPEN_DATABASE_NOADDREFEXT))
        {
            // Release It
            IF_FAILEXIT(hr = m_pExtension->QueryInterface(IID_IUnknown, (LPVOID *)&m_pUnkRelease));
        }
    }

    // Otherwise, CoCreate... the extension
    else
    {
        // CoCreate the Extension Object
        IF_FAILEXIT(hr = CoCreateInstance(*m_pSchema->pclsidExtension, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseExtension, (LPVOID *)&m_pExtension));

        // Release It
        IF_FAILEXIT(hr = m_pExtension->QueryInterface(IID_IUnknown, (LPVOID *)&m_pUnkRelease));

        // Release m_pExtension
        m_pExtension->Release();
    }

    // Initialize the Extension
    m_pExtension->Initialize(this);

exit:
    // Must have succeeded
    Assert(SUCCEEDED(hr));

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetClientCount
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetClientCount(LPDWORD pcClients)
{
    // Trace
    TraceCall("CDatabase::GetClientCount");

    // Multiple Clients ?
    if (m_pShare)
        *pcClients = m_pShare->cClients;
    else
        *pcClients = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::Lock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Lock(LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            fDecWaiting=FALSE;

    // Trace
    TraceCall("CDatabase::Lock");

    // Initialize
    *phLock = NULL;

    // If Compacting...
    if (TRUE == m_pShare->fCompacting)
    {
        // Increment Waiting for Lock
        InterlockedIncrement(&m_pShare->cWaitingForLock);

        // fDecWaiting
        fDecWaiting = TRUE;
    }

    // Leave Spin Lock
    WaitForSingleObject(m_hMutex, INFINITE);

    // Decrement Waiting for lock ?
    if (fDecWaiting)
    {
        // Increment Waiting for Lock
        InterlockedDecrement(&m_pShare->cWaitingForLock);
    }

    // No Header ?
    if (NULL == m_pHeader)
    {
        // Try to re-open the file
        hr = DoInProcessInvoke(INVOKE_CREATEMAP);

        // Failure
        if (FAILED(hr))
        {
            // Leave Spin Lock
            ReleaseMutex(m_hMutex);

            // Trace
            TraceResult(hr);

            // Done
            goto exit;
        }
    }

    // Extension
    if (m_pExtension)
    {
        // OnLock Extension...
        m_pExtension->OnLock();
    }

    // Check for Corruption...
    if (TRUE == m_pHeader->fCorrupt)
    {
        // Try to Repair Corruption
        hr = _CheckForCorruption();

        // Failure
        if (FAILED(hr))
        {
            // Leave Spin Lock
            ReleaseMutex(m_hMutex);

            // Trace
            TraceResult(hr);

            // Done
            goto exit;
        }
    }

    // Need to reload quieries
    if (m_dwQueryVersion != m_pShare->dwQueryVersion)
    {
        // Reload query table
        IF_FAILEXIT(hr = _BuildQueryTable());
    }

    // Increment Queue Notify count
    m_pShare->cNotifyLock++;

#ifdef BACKGROUND_MONITOR
    // Reset tcMonitor
    m_pStorage->tcMonitor = 0;
#endif

    // Don't Unlock Again
    *phLock = (HLOCK)m_hMutex;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Unlock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Unlock(LPHLOCK phLock)
{
    // Trace
    TraceCall("CDatabase::Unlock");

    // Not Null
    if (*phLock)
    {
        // Extension
        if (m_pExtension)
        {
            // OnUnlock Extension...
            m_pExtension->OnUnlock();
        }

        // Unlock Notify
        m_pShare->cNotifyLock--;

        // If there are still refs, don't send notifications yet...
        if (0 == m_pShare->cNotifyLock && FALSE == m_pHeader->fCorrupt)
        {
            // Dispatch Pending
            _DispatchPendingNotifications();
        }

        // Validate phLock
        Assert(*phLock == (HLOCK)m_hMutex);

        // Leave Spin Lock
        ReleaseMutex(m_hMutex);

        // Don't Unlock Again
        *phLock = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_BuildQueryTable
//--------------------------------------------------------------------------
HRESULT CDatabase::_BuildQueryTable(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    INDEXORDINAL    iIndex;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::_BuildQueryTable");

    // Versions should be different
    Assert(m_dwQueryVersion != m_pShare->dwQueryVersion);

    // Collapse the Ordinal Array
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Set iIndex
        iIndex = m_pHeader->rgiIndex[i];

        // Close the Current Filters
        CloseQuery(&m_rghFilter[iIndex], this);

        // Filter
        if (m_pHeader->rgfaFilter[iIndex])
        {
            // Validate File Address
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex], (LPVOID *)&pBlock));

            // Load the Query String
            if (FAILED(ParseQuery(PSTRING(pBlock), m_pSchema, &m_rghFilter[iIndex], this)))
            {
                // Null
                m_rghFilter[iIndex] = NULL;
            }
        }
    }

    // Save New Version
    m_dwQueryVersion = m_pShare->dwQueryVersion;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ResetTableHeader
//--------------------------------------------------------------------------
HRESULT CDatabase::_ResetTableHeader(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CDatabase::_ResetTableHeader");

    // Zero out the Table Header + UserData
    ZeroMemory(m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Set the File Signature
    m_pHeader->dwSignature = BTREE_SIGNATURE;

    // Set the Major Version
    m_pHeader->dwMajorVersion = BTREE_VERSION;

    // Store the size of the user data
    m_pHeader->cbUserData = m_pSchema->cbUserData;

    // Set faNextAllocate
    m_pHeader->faNextAllocate = sizeof(TABLEHEADER) + m_pSchema->cbUserData;

    // Initialize ID Generator
    m_pHeader->dwNextId = 1;

    // No need to do the corruption check, its a new file...
    m_pHeader->fCorruptCheck = TRUE;

    // Store the clsidExtension
    CopyMemory(&m_pHeader->clsidExtension, m_pSchema->pclsidExtension, sizeof(CLSID));

    // Store the Version
    m_pHeader->dwMinorVersion = m_pSchema->dwMinorVersion;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateFileVersions
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateFileVersions(OPENDATABASEFLAGS dwFlags)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CDatabase::_ValidateFileVersions");

    // Signature better match
    if (m_pHeader->dwSignature != BTREE_SIGNATURE)
    {
        hr = TraceResult(DB_E_INVALIDFILESIGNATURE);
        goto exit;
    }

    // Validate the Major Version
    if (m_pHeader->dwMajorVersion != BTREE_VERSION)
    {
        hr = TraceResult(DB_E_BADMAJORVERSION);
        goto exit;
    }

    // Validate the Minor Version
    if (m_pHeader->dwMinorVersion != m_pSchema->dwMinorVersion)
    {
        hr = TraceResult(DB_E_BADMINORVERSION);
        goto exit;
    }

    // Validate the Minor Version
    if (FALSE == IsEqualCLSID(m_pHeader->clsidExtension, *m_pSchema->pclsidExtension))
    {
        hr = TraceResult(DB_E_BADEXTENSIONCLSID);
        goto exit;
    }

exit:
    // Can I Reset
    if (FALSE == ISFLAGSET(dwFlags, OPEN_DATABASE_NORESET))
    {
        // Failed and reset if bad version ?
        if (FAILED(hr) && ISFLAGSET(m_pSchema->dwFlags, TSF_RESETIFBADVERSION))
        {
            // Reset the Table Header
            hr = _ResetTableHeader();
        }
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::PHeapAllocate
//--------------------------------------------------------------------------
LPVOID CDatabase::PHeapAllocate(DWORD dwFlags, DWORD cbSize)
{
    // Locals
    LPMEMORYTAG pTag;

    // Trace
    TraceCall("CDatabase::PHeapAllocate");

    // Increment the Size Enough to Store a Header
    cbSize += sizeof(MEMORYTAG);

    // Block is a too big to recycle ?
#ifdef HEAPCACHE
    if (cbSize >= CB_MAX_HEAP_BUCKET)
    {
#endif
        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Allocate the Block
#ifdef USEHEAP
        LPVOID pBlock = HeapAlloc(m_hHeap, dwFlags | HEAP_NO_SERIALIZE, cbSize);
#else
        LPVOID pBlock = ZeroAllocate(cbSize);
#endif

        // Debug
        IF_DEBUG(m_cbHeapAlloc += cbSize);

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);

        // Set pTag
        pTag = (LPMEMORYTAG)pBlock;

#ifdef HEAPCACHE
    }

    // Otherwise
    else
    {
        // Compute Free Block Bucket
        WORD iBucket = ((WORD)(cbSize / CB_HEAP_BUCKET));

        // Decrement iBucket ?
        if (0 == (cbSize % CB_HEAP_BUCKET))
        {
            // Previous Bucket
            iBucket--;
        }

        // Adjust cbBlock to fit completly into it's bucket
        cbSize = ((iBucket + 1) * CB_HEAP_BUCKET);

        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Is there a block in this Bucket ?
        if (m_rgpRecycle[iBucket])
        {
            // Use this block
            pTag = (LPMEMORYTAG)m_rgpRecycle[iBucket];

            // Validate Size
            Assert(cbSize == pTag->cbSize);

            // Fixup m_rgpRecycle
            m_rgpRecycle[iBucket] = (LPBYTE)pTag->pNext;

            // Zero
            if (ISFLAGSET(dwFlags, HEAP_ZERO_MEMORY))
            {
                // Zero
                ZeroMemory((LPBYTE)pTag, cbSize);
            }
        }

        // Otherwise, allocate
        else
        {
            // Allocate the Block
#ifdef USEHEAP
            LPVOID pBlock = HeapAlloc(m_hHeap, dwFlags | HEAP_NO_SERIALIZE, cbSize);
#else
            LPVOID pBlock = ZeroAllocate(cbSize);
#endif

            // Debug
            IF_DEBUG(m_cbHeapAlloc += cbSize);

            // Set pTag
            pTag = (LPMEMORYTAG)pBlock;
        }

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);
    }
#endif

    // No pTag
    if (NULL == pTag)
        return(NULL);

    // Fixup the Block Size
    pTag->cbSize = cbSize;

    // Set Signature
    pTag->dwSignature = MEMORY_GUARD_SIGNATURE;

    // Done
    return((LPBYTE)pTag + sizeof(MEMORYTAG));
}

//--------------------------------------------------------------------------
// CDatabase::HeapFree
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::HeapFree(LPVOID pBlock)
{
    // Locals
    LPMEMORYTAG pTag;

    // Trace
    TraceCall("CDatabase::HeapFree");

    // No Buffer
    if (NULL == pBlock)
        return(S_OK);

    // Set pTag
    pTag = (LPMEMORYTAG)((LPBYTE)pBlock - sizeof(MEMORYTAG));

    // Is Valid Block ?
    Assert(pTag->dwSignature == MEMORY_GUARD_SIGNATURE);

    // Block is a too big to recycle ?
#ifdef HEAPCACHE
    if (pTag->cbSize >= CB_MAX_HEAP_BUCKET)
    {
#endif
        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Debug
        IF_DEBUG(m_cbHeapFree += pTag->cbSize);

        // Allocate the Block
#ifdef USEHEAP
        ::HeapFree(m_hHeap, HEAP_NO_SERIALIZE, pTag);
#else
        g_pMalloc->Free(pTag);
#endif

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);

#ifdef HEAPCACHE
    }

    // Otherwise, cache It
    else
    {
        // Compute Free Block Bucket
        WORD iBucket = ((WORD)(pTag->cbSize / CB_HEAP_BUCKET)) - 1;

        // Must be an integral size of a bucket
        Assert((pTag->cbSize % CB_HEAP_BUCKET) == 0);

        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Set Next
        pTag->pNext = m_rgpRecycle[iBucket];

        // Set the Head
        m_rgpRecycle[iBucket] = (LPBYTE)pTag;

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);
    }
#endif

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::GetIndexInfo
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter,
    LPTABLEINDEX pIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::GetIndexInfo");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Collapse the Ordinal Array
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get iIndex
        if (iIndex == m_pHeader->rgiIndex[i])
        {
            // Copy the Index Information
            CopyMemory(pIndex, &m_pHeader->rgIndexInfo[iIndex], sizeof(TABLEINDEX));

            // Get the Filters ?
            if (ppszFilter && m_pHeader->rgfaFilter[iIndex])
            {
                // Corrupt
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex], (LPVOID *)&pBlock));

                // Duplicate
                IF_NULLEXIT(*ppszFilter = DuplicateStringA(PSTRING(pBlock)));
            }

            // Done
            goto exit;
        }
    }

    // Failure
    hr = E_FAIL;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ModifyIndex
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter,
    LPCTABLEINDEX pIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    HQUERY          hFilter=NULL;
    FILEADDRESS     faFilter=0;
    LPBLOCKHEADER   pFilter=NULL;
    BOOL            fFound=FALSE;
    DWORD           i;
    DWORD           cb;
    BOOL            fVersionChange=FALSE;

    // Trace
    TraceCall("CDatabase::ModifyIndex");

    // Invalid Args
    if (IINDEX_PRIMARY == iIndex || iIndex > CMAX_INDEXES || NULL == pIndex || pIndex->cKeys > CMAX_KEYS)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Filter
    if (pszFilter)
    {
        // Parse the Query
        IF_FAILEXIT(hr = ParseQuery(pszFilter, m_pSchema, &hFilter, this));

        // Initialize the String Block
        cb = lstrlen(pszFilter) + 1;

        // Try to Store the Query String
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STRING, cb, (LPVOID *)&pFilter));

        // Write the String
        CopyMemory(PSTRING(pFilter), pszFilter, cb);

        // Set faFilter
        faFilter = pFilter->faBlock;

        // Query Version Change
        fVersionChange = TRUE;
    }

    // Free This Index
    IF_FAILEXIT(hr = DeleteIndex(iIndex));

    // Copy the Index Information
    CopyMemory(&m_pHeader->rgIndexInfo[iIndex], pIndex, sizeof(TABLEINDEX));

    // Filter
    if (hFilter)
    {
        // Validate
        Assert(NULL == m_rghFilter[iIndex] && 0 == m_pHeader->rgfaFilter[iIndex] && hFilter && faFilter);

        // Store the hFilter
        m_rghFilter[iIndex] = hFilter;

        // Don't Free hFilter
        hFilter = NULL;

        // Store filter string address
        m_pHeader->rgfaFilter[iIndex] = faFilter;

        // Don't Free the Filter
        faFilter = 0;
    }

    // Update Query Versions
    if (fVersionChange)
    {
        // Update the Shared Query Version Count
        m_pShare->dwQueryVersion++;

        // I'm Up-to-date
        m_dwQueryVersion = m_pShare->dwQueryVersion;
    }

    // Is iIndex already in rgiIndex ?
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Is this it ?
        if (iIndex == m_pHeader->rgiIndex[i])
        {
            // Its already in there
            fFound = TRUE;

            // Done
            break;
        }
    }

    // No Found
    if (FALSE == fFound)
    {
        // Insert into Index Ordinal Array
        m_pHeader->rgiIndex[m_pHeader->cIndexes] = iIndex;

        // Increment Count
        m_pHeader->cIndexes++;
    }

    // Rebuild the Index
    IF_FAILEXIT(hr = _RebuildIndex(iIndex));

exit:
    // Close Filters
    CloseQuery(&hFilter, this);

    // Free faFilter1
    if (0 != faFilter)
    {
        // Free the block
        SideAssert(SUCCEEDED(_FreeBlock(BLOCK_STRING, faFilter)));
    }

    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteIndex
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DeleteIndex(INDEXORDINAL iIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    BOOL            fFound=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::DeleteIndex");

    // Invalid Args
    if (IINDEX_PRIMARY == iIndex || iIndex > CMAX_INDEXES)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Collapse the Ordinal Array
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Is this the Index to delete ?
        if (m_pHeader->rgiIndex[i] == iIndex)
        {
            // Found
            fFound = TRUE;

            // Collapse the Array
            MoveMemory(&m_pHeader->rgiIndex[i], &m_pHeader->rgiIndex[i + 1], sizeof(INDEXORDINAL) * (m_pHeader->cIndexes - (i + 1)));

            // Decrement Index Count
            m_pHeader->cIndexes--;

            // Done
            break;
        }
    }

    // Not Found
    if (FALSE == fFound)
    {
        // No Filter and no Exception
        Assert(0 == m_pHeader->rgfaFilter[iIndex]);

        // No Filter Handle
        Assert(NULL == m_rghFilter[iIndex]);

        // No Record
        Assert(0 == m_pHeader->rgcRecords[iIndex]);

        // Done
        goto exit;
    }

    // If this Index is Currently In Use...
    if (m_pHeader->rgfaIndex[iIndex])
    {
        // Free This Index
        _FreeIndex(m_pHeader->rgfaIndex[iIndex]);

        // Null It Out
        m_pHeader->rgfaIndex[iIndex] = 0;

        // No Record
        m_pHeader->rgcRecords[iIndex] = 0;
    }

    // Delete Filter
    if (m_pHeader->rgfaFilter[iIndex])
    {
        // Free the Block
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex]));

        // Close the filter handle
        CloseQuery(&m_rghFilter[iIndex], this);

        // Set to NULL
        m_pHeader->rgfaFilter[iIndex] = 0;

        // Update the Shared Query Version Count
        m_pShare->dwQueryVersion++;
    }

    // I'm Up-to-date
    m_dwQueryVersion = m_pShare->dwQueryVersion;

    // Handle Should be closed
    Assert(NULL == m_rghFilter[iIndex]);

    // Send Notifications ?
    if (m_pShare->rgcIndexNotify[iIndex] > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_INDEX_DELETED, iIndex, NULL, 0, 0);
    }

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GenerateId
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GenerateId(LPDWORD pdwId)
{
    // Locals
    HRESULT     hr=S_OK;
    HLOCK       hLock=NULL;

    // Trace
    TraceCall("CDatabase::GenerateId");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Loop Until I create a valid Id ?
    while (1)
    {
        // Increment next id
        m_pHeader->dwNextId++;

        // Invalid Id ?
        if (0 == m_pHeader->dwNextId)
            continue;

        // In Invalid Range
        if (m_pHeader->dwNextId >= RESERVED_ID_MIN && m_pHeader->dwNextId <= RESERVED_ID_MAX)
            continue;

        // Its Good
        break;
    }

    // Set pdwId
    *pdwId = m_pHeader->dwNextId;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetFile
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetFile(LPWSTR *ppszFile)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetFile");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Dupp
    IF_NULLEXIT(*ppszFile = DuplicateStringW(m_pShare->szFile));

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchNotification 
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchNotification(HTRANSACTION hTransaction)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iClient;
    LPCLIENTENTRY       pClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::_DispatchNotification");

    // Walk through the List
    for (iClient=0; iClient<m_pShare->cClients; iClient++)
    {
        // De-reference the client
        pClient = &m_pShare->rgClient[iClient];

        // Loop through cNotify
        for (iRecipient=0; iRecipient<pClient->cRecipients; iRecipient++)
        {
            // De-Ref pEntry
            pRecipient = &pClient->rgRecipient[iRecipient];

            // If the Recipient isn't suspending...
            if (FALSE == pRecipient->fSuspended)
            {
                // Should have a Thunking Window
                Assert(pRecipient->hwndNotify && IsWindow(pRecipient->hwndNotify));

                // Post the Notification
                if (0 == PostMessage(pRecipient->hwndNotify, WM_ONTRANSACTION, (WPARAM)pRecipient->dwCookie, (LPARAM)hTransaction))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DoInProcessInvoke
//--------------------------------------------------------------------------
HRESULT CDatabase::DoInProcessInvoke(INVOKETYPE tyInvoke)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fNew;

    // Trace
    TraceCall("CDatabase::DoInProcessNotify");

    // INVOKE_RELEASEMAP
    if (INVOKE_RELEASEMAP == tyInvoke)
    {
        // Validate
        _CloseFileViews(FALSE);

        // Close the File
        SafeCloseHandle(m_pStorage->hMap);
    }

    // INVOKE_CREATEMAP
    else if (INVOKE_CREATEMAP == tyInvoke)
    {
        // Validation
        Assert(NULL == m_pStorage->hMap);

        // Get the file size
        IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &m_pStorage->cbFile));

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNew, &m_pStorage->hMap, NULL));

        // Initialize File Views
        IF_FAILEXIT(hr = _InitializeFileViews());
    }

    // INVOKE_CLOSEFILE
    else if (INVOKE_CLOSEFILE == tyInvoke)
    {
        // Validate
        _CloseFileViews(TRUE);

        // Close the File
        if(m_pStorage->hFile /*&& m_fDirty*/)
        {
            FILETIME systime;
            GetSystemTimeAsFileTime(&systime);
    
            SetFileTime(m_pStorage->hFile, NULL, &systime, &systime);
        }
        SafeCloseHandle(m_pStorage->hMap);

        // Close the file
        SafeCloseHandle(m_pStorage->hFile);
    }

    // INVOKE_OPENFILE
    else if (INVOKE_OPENFILE == tyInvoke || INVOKE_OPENMOVEDFILE == tyInvoke)
    {
        // Validation
        Assert(NULL == m_pStorage->hFile && NULL == m_pStorage->hMap);

        // Open Moved File ?
        if (INVOKE_OPENMOVEDFILE == tyInvoke)
        {
            // _HandleOpenMovedFile
            IF_FAILEXIT(hr = _HandleOpenMovedFile());
        }

        // Open the File
        IF_FAILEXIT(hr = DBOpenFile(m_pShare->szFile, FALSE, m_fExclusive, &fNew, &m_pStorage->hFile));

        // Better not be new
        Assert(FALSE == fNew);

        // Get the file size
        IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &m_pStorage->cbFile));

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNew, &m_pStorage->hMap, NULL));

        // Initialize File Views
        IF_FAILEXIT(hr = _InitializeFileViews());
    }

    // Uhoh
    else
        AssertSz(FALSE, "Invalid invoke type passed into CDatabase::DoInProcessInvoke");

exit:

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_HandleOpenMovedFile
//--------------------------------------------------------------------------
HRESULT CDatabase::_HandleOpenMovedFile(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszMutex=NULL;
    LPWSTR      pszShare=NULL;
    BOOL        fNewShare;
    WCHAR       szFile[CCHMAX_DB_FILEPATH];

    // Trace
    TraceCall("CDatabase::_HandleOpenMovedFile");

    // Save New File Path
    StrCpyNW(szFile, m_pShare->szFile, ARRAYSIZE(szFile));

    // Free pszMap
    SafeMemFree(m_pStorage->pszMap);

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBFileMap", &m_pStorage->pszMap));

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBMutex", &pszMutex));

    // Close the current mutex
    SafeCloseHandle(m_hMutex);

    // Create the Mutex
    IF_NULLEXIT(m_hMutex = CreateMutexWrapW(NULL, FALSE, pszMutex));

    // If not in move file
    if (FALSE == m_fInMoveFile)
    {
        // Create the Mutex Object
        IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBShare", &pszShare));

        // Unmap the view of the memory mapped file
        SafeUnmapViewOfFile(m_pShare);

        // Unmap the view of the memory mapped file
        SafeCloseHandle(m_pStorage->hShare);

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));
    
        // Better not be new
        Assert(!fNewShare);
    }
    else
        Assert(StrCmpW(szFile, m_pShare->szFile) == 0);
        
exit:
    // Cleanup
    SafeMemFree(pszMutex);
    SafeMemFree(pszShare);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchInvoke
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchInvoke(INVOKETYPE tyInvoke)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iClient=0;
    LPCLIENTENTRY       pClient;
    DWORD_PTR           dwResult;
    DWORD               dwThreadId=GetCurrentThreadId();
    INVOKEPACKAGE       Package;
    COPYDATASTRUCT      CopyData;

    // Trace
    TraceCall("CDatabase::_DispatchInvoke");

    // Set Invoke Type
    Package.tyInvoke = tyInvoke;

    // Walk through the List
    while (iClient < m_pShare->cClients)
    {
        // Readability
        pClient = &m_pShare->rgClient[iClient++];

        // Better have one
        Package.pDB = pClient->pDB;

        // Is this entry in my process ?
        if (m_dwProcessId == pClient->dwProcessId)
        {
            // Do In Process Notification
            CDatabase *pDB = (CDatabase *)pClient->pDB;

            // Do It
            IF_FAILEXIT(hr = pDB->DoInProcessInvoke(tyInvoke));
        }

        // Otherwise, just process the package
        else
        {
            // If the listener is good
            if (pClient->hwndListen && IsWindow(pClient->hwndListen))
            {
                // Initialize copy data struct
                CopyData.dwData = 0;

                // Store the Size of the Package
                CopyData.cbData = sizeof(INVOKEPACKAGE);

                // Store the Package
                CopyData.lpData = &Package;

                // Send It
                if (0 == SendMessageTimeout(pClient->hwndListen, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&CopyData, SMTO_ABORTIFHUNG, 5000, &dwResult))
                {
                    // Remove this client from the list
                    SideAssert(SUCCEEDED(_RemoveClientFromArray(pClient->dwProcessId, pClient->pDB)));

                    // Decrement iClient
                    iClient--;
                }
            }

            // Remove this client
            else
            {
                // Remove this client from the list
                SideAssert(SUCCEEDED(_RemoveClientFromArray(pClient->dwProcessId, pClient->pDB)));

                // Decrement iClient
                iClient--;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RemoveClientFromArray
//--------------------------------------------------------------------------
HRESULT CDatabase::_RemoveClientFromArray(DWORD dwProcessId, 
    DWORD_PTR dwDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    DWORD               cClients=0;
    DWORD               iClient;
    LPCLIENTENTRY       pClient;

    // Trace
    TraceCall("CDatabase::_RemoveClientFromArray");

    // Initialize i
    iClient = 0;

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(dwProcessId, dwDB, &iClient, &pClient));

    // Release Registered Notification Objects
    for (iRecipient=0; iRecipient<pClient->cRecipients; iRecipient++)
    {
        // Readability
        pRecipient = &pClient->rgRecipient[iRecipient];

        // Same Process ?
        if (dwProcessId == m_dwProcessId)
        {
            // Remove and messages from the notificaton queue
            _CloseNotificationWindow(pRecipient);

            // Release ?
            if (TRUE == pRecipient->fRelease)
            {
                // Cast pNotify
                IDatabaseNotify *pNotify = (IDatabaseNotify *)pRecipient->pNotify;

                // Cast to pRecipient
                pNotify->Release();
            }
        }

        // If Not Suspended
        if (FALSE == pRecipient->fSuspended)
        {
            // _AdjustNotifyCounts
            _AdjustNotifyCounts(pRecipient, -1);
        }
    }

    // Remove MySelf
    MoveMemory(&m_pShare->rgClient[iClient], &m_pShare->rgClient[iClient + 1], sizeof(CLIENTENTRY) * (m_pShare->cClients - (iClient + 1)));

    // Decrement Client Count
	m_pShare->cClients--;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CloseNotificationWindow
//--------------------------------------------------------------------------
HRESULT CDatabase::_CloseNotificationWindow(LPNOTIFYRECIPIENT pRecipient)
{
    // Trace
    TraceCall("CDatabase::_CloseNotificationWindow");

    // Kill the Window
    DestroyWindow(pRecipient->hwndNotify);

    // Null it Count
    pRecipient->hwndNotify = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_FindClient
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindClient(DWORD dwProcessId, DWORD_PTR dwDB, 
    LPDWORD piClient,  LPCLIENTENTRY *ppClient)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;

    // Trace
    TraceCall("CDatabase::_FindThisClient");

    // Find myself in the client list
    for (iClient=0; iClient<m_pShare->cClients; iClient++)
    {
        // Readability
        pClient = &m_pShare->rgClient[iClient];

        // Is this me ?
        if (dwProcessId == pClient->dwProcessId && dwDB == pClient->pDB)
        {
            *piClient = iClient;
            *ppClient = pClient;
            goto exit;
        }
    }

    // Not Found
    hr = TraceResult(DB_E_NOTFOUND);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FindNotifyRecipient
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindNotifyRecipient(DWORD iClient, IDatabaseNotify *pNotify,
    LPDWORD piRecipient,  LPNOTIFYRECIPIENT *ppRecipient)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::_FindNotifyRecipient");

    // Readability
    pClient = &m_pShare->rgClient[iClient];

    // Walk through client's registered notification entries
    for (iRecipient = 0; iRecipient < m_pShare->rgClient[iClient].cRecipients; iRecipient++)
    {
        // Readability
        pRecipient = &pClient->rgRecipient[iRecipient];

        // Is this me ?
        if ((DWORD_PTR)pNotify == pRecipient->pNotify)
        {
            // This is It
            *piRecipient = iRecipient;
            *ppRecipient = pRecipient;
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchPendingNotifications
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchPendingNotifications(void)
{
    // Are there pending notifications
    if (m_pShare->faTransactLockHead)
    {
        // Dispatch Invoke
        _DispatchNotification((HTRANSACTION)IntToPtr(m_pShare->faTransactLockHead));

        // Null It Out
        m_pShare->faTransactLockTail = m_pShare->faTransactLockHead = 0;
    }

    // Otherwise, validate
    else
    {
        // Tail must be Null
        Assert(0 == m_pShare->faTransactLockTail);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::DispatchNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DispatchNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;
    MSG                 msg;

    // Trace
    TraceCall("CDatabase::DispatchNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Processing the Pending Notifications for this recipient...
    if (pRecipient->dwThreadId != GetCurrentThreadId())
    {
        Assert(FALSE);
        hr = TraceResult(DB_E_WRONGTHREAD);
        goto exit;
    }

    // Pump Messages
    while (PeekMessage(&msg, pRecipient->hwndNotify, WM_ONTRANSACTION, WM_ONTRANSACTION, PM_REMOVE))
    {
        // Translate the Message
        TranslateMessage(&msg);

        // Dispatch the Message
        DispatchMessage(&msg);
    }

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SuspendNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SuspendNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;
    MSG                 msg;

    // Trace
    TraceCall("CDatabase::SuspendNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // If Not Suspended yet
    if (pRecipient->fSuspended)
        goto exit;

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Processing the Pending Notifications for this recipient...
    if (pRecipient->dwThreadId == GetCurrentThreadId())
    {
        // Pump Messages
        while (PeekMessage(&msg, pRecipient->hwndNotify, WM_ONTRANSACTION, WM_ONTRANSACTION, PM_REMOVE))
        {
            // Translate the Message
            TranslateMessage(&msg);

            // Dispatch the Message
            DispatchMessage(&msg);
        }
    }

    // Otherwise, can't pump out pending notifications...
    else
        Assert(FALSE);

    // Set Suspended
    pRecipient->fSuspended = TRUE;

    // Adjust Notify Counts
    _AdjustNotifyCounts(pRecipient, -1);

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ResumeNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ResumeNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;

    // Trace
    TraceCall("CDatabase::ResumeNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // If Not Suspended yet
    if (FALSE == pRecipient->fSuspended)
        goto exit;

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Remove fSuspended
    pRecipient->fSuspended = FALSE;

    // Adjust Notify Counts
    _AdjustNotifyCounts(pRecipient, 1);

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustNotifyCounts
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustNotifyCounts(LPNOTIFYRECIPIENT pRecipient, 
    LONG lChange)
{
    // Trace
    TraceCall("CDatabase::_AdjustNotifyCounts");

    // Ordinals Only
    if (pRecipient->fOrdinalsOnly)
    {
        // Validate the Count
        Assert((LONG)(m_pShare->cNotifyOrdinalsOnly + lChange) >= 0);

        // Update Ordinals Only Count
        m_pShare->cNotifyOrdinalsOnly += lChange;
    }

    // Otherwise, update notify with data count
    else
    {
        // Validate the Count
        Assert((LONG)(m_pShare->cNotifyWithData + lChange) >= 0);

        // Update
        m_pShare->cNotifyWithData += lChange;
    }

    // Validate the Count
    Assert((LONG)(m_pShare->cNotify + lChange) >= 0);

    // Update Total cNotify
    m_pShare->cNotify += lChange;

    // Validate the Count
    Assert((LONG)(m_pShare->rgcIndexNotify[pRecipient->iIndex] + lChange) >= 0);

    // Decrement Number of Recipients for Index
    m_pShare->rgcIndexNotify[pRecipient->iIndex] += lChange;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::UnregisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UnregisterNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::UnregisterNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto exit;
    }

    // Remove and messages from the notificaton queue
    _CloseNotificationWindow(pRecipient);

    // Release ?
    if (TRUE == pRecipient->fRelease)
    {
        // Cast to pRecipient
        pNotify->Release();
    }

    // If Not Suspended
    if (FALSE == pRecipient->fSuspended)
    {
        // _AdjustNotifyCounts
        _AdjustNotifyCounts(pRecipient, -1);
    }

    // Remove MySelf
    MoveMemory(&pClient->rgRecipient[iRecipient], &pClient->rgRecipient[iRecipient + 1], sizeof(NOTIFYRECIPIENT) * (pClient->cRecipients - (iRecipient + 1)));

    // Decrement Client Count
	pClient->cRecipients--;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::RegisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::RegisterNotify(INDEXORDINAL iIndex,
    REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, 
    IDatabaseNotify *pNotify)

{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;

    // Trace
    TraceCall("CDatabase::RegisterNotify");

    // Invalid Args
    if (NULL == pNotify || iIndex > CMAX_INDEXES)
        return TraceResult(E_INVALIDARG);

    // If Deconstructing, just return
    if (m_fDeconstruct)
        return(S_OK);

    // Thread Safety
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // See if this client is already registered...
    if (SUCCEEDED(_FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient)))
    {
        hr = TraceResult(DB_E_ALREADYREGISTERED);
        goto exit;
    }

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Room for one more
    if (pClient->cRecipients + 1 >= CMAX_RECIPIENTS)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Readability
    pRecipient = &pClient->rgRecipient[pClient->cRecipients];

    // Store the ThreadId
    pRecipient->dwThreadId = GetCurrentThreadId();

    // Save the Cookie
    pRecipient->dwCookie = dwCookie;

    // Get a Thunking Window for that thread
    IF_FAILEXIT(hr = CreateNotifyWindow(this, pNotify, &pRecipient->hwndNotify));

    // Only addref if the client wants me to
    if (!ISFLAGSET(dwFlags, REGISTER_NOTIFY_NOADDREF))
    {
        // AddRef the notification object
        pNotify->AddRef();

        // Release it
        pRecipient->fRelease = TRUE;
    }

    // Register It
    pRecipient->pNotify = (DWORD_PTR)pNotify;

    // Save the Index that they are intereseted in
    pRecipient->iIndex = iIndex;

    // Increment Notify Count
    pClient->cRecipients++;

    // Ordinals Only
    pRecipient->fOrdinalsOnly = (ISFLAGSET(dwFlags, REGISTER_NOTIFY_ORDINALSONLY) ? TRUE : FALSE);

    // _AdjustNotifyCounts
    _AdjustNotifyCounts(pRecipient, 1);

exit:
    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SetStorageSize
//--------------------------------------------------------------------------
HRESULT CDatabase::_SetStorageSize(DWORD cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrCreate;

    // Trace
    TraceCall("CDatabase::_SetStorageSize");

    // Only if sizes are different
    if (cbSize == m_pStorage->cbFile)
        return(S_OK);

    // Do It
    _DispatchInvoke(INVOKE_RELEASEMAP);

    // Set the File Pointer
    if (0xFFFFFFFF == SetFilePointer(m_pStorage->hFile, cbSize, NULL, FILE_BEGIN))
    {
        hr = TraceResult(DB_E_SETFILEPOINTER);
        goto exit;
    }

    // Set End of file
    if (0 == SetEndOfFile(m_pStorage->hFile))
    {
        // Get LastError
        DWORD dwLastError = GetLastError();

        // Access Denied ?
        if (ERROR_ACCESS_DENIED == dwLastError)
        {
            hr = TraceResult(DB_E_ACCESSDENIED);
            goto exit;
        }

        // Otherwise, assume disk is full
        else
        {
            hr = TraceResult(DB_E_DISKFULL);
            goto exit;
        }
    }

exit:
    // Do It
    hrCreate = _DispatchInvoke(INVOKE_CREATEMAP);

    // Done
    return(SUCCEEDED(hr) ? hrCreate : hr);
}

//--------------------------------------------------------------------------
// CDatabase::SetSize
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SetSize(DWORD cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::SetSize");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Size can only be larger than my current size
    if (cbSize < m_pStorage->cbFile)
        goto exit;

    // If the size of the file is currently zero...
    IF_FAILEXIT(hr = _SetStorageSize(cbSize));

exit:
    // Invalid Args
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocatePage
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocatePage(DWORD cbPage, LPFILEADDRESS pfaAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CDatabase::_AllocatePage");

    // Quick Validation
    Assert(m_pHeader->faNextAllocate && m_pHeader->faNextAllocate <= m_pStorage->cbFile);

    // Need to grow the file ?
    if (m_pStorage->cbFile - m_pHeader->faNextAllocate < cbPage)
    {
        // Compute cbNeeded
        DWORD cbNeeded = cbPage - (m_pStorage->cbFile - m_pHeader->faNextAllocate);

        // Grow in at least 64k chunks.
        cbNeeded = max(cbNeeded, 65536);

        // If the size of the file is currently zero...
        IF_FAILEXIT(hr = _SetStorageSize(m_pStorage->cbFile + cbNeeded));
    }

    // Return this address
    *pfaAddress = m_pHeader->faNextAllocate;

    // Adjust faNextAllocate
    m_pHeader->faNextAllocate += cbPage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_MarkBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_MarkBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock,
    DWORD cbBlock, LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    MARKBLOCK       Mark;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::_MarkBlock");

    // Validate
    Assert(cbBlock >= g_rgcbBlockSize[tyBlock]);

    // Set Mark
    Mark.cbBlock = cbBlock;

    // De-Ref the Header
    IF_FAILEXIT(hr = _GetBlock(tyBlock, faBlock, (LPVOID *)&pBlock, &Mark));

    // Zero the Header
    ZeroBlock(pBlock, g_rgcbBlockSize[tyBlock]);

    // Return ppvBlock
    if (ppvBlock)
        *ppvBlock = (LPVOID)pBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateFromPage
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateFromPage(BLOCKTYPE tyBlock, LPALLOCATEPAGE pPage,
    DWORD cbPage, DWORD cbBlock, LPVOID *ppvBlock)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cbLeft;
    FILEADDRESS faBlock;
    DWORD       iBucket;

    // Trace
    TraceCall("CDatabase::_AllocateFromPage");

    // Is Page Valid ?
    if (pPage->faPage + pPage->cbPage > m_pStorage->cbFile)
    {
        // Kill the page
        ZeroMemory(pPage, sizeof(ALLOCATEPAGE));
    }

    // Otherwise
    else
    {
        // Compute cbLeft
        cbLeft = pPage->cbPage - pPage->cbUsed;
    }

    // Requesting a large block
    if (cbBlock > cbPage || (cbLeft > 0 && cbLeft < cbBlock && cbLeft >= CB_MAX_FREE_BUCKET))
    {
        // Allocate space in the file
        IF_FAILEXIT(hr = _AllocatePage(cbBlock, &faBlock));

        // Mark the block
        IF_FAILEXIT(hr = _MarkBlock(tyBlock, faBlock, cbBlock, ppvBlock));
    }

    // Invalid Page ?
    else 
    {
        // Block is too small...
        if (cbLeft > 0 && cbLeft < cbBlock)
        {
            // Must be a BLOCK_RECORD
            Assert(BLOCK_STREAM != tyBlock && BLOCK_CHAIN != tyBlock);

            // Better fit into block
            Assert(cbLeft <= CB_MAX_FREE_BUCKET && cbLeft >= CB_MIN_FREE_BUCKET && (cbLeft % 4) == 0);

            // Mark the block
            IF_FAILEXIT(hr = _MarkBlock(BLOCK_ENDOFPAGE, (pPage->faPage + pPage->cbUsed), cbLeft, NULL));

            // Increment cbAllocated
            m_pHeader->cbAllocated += cbLeft;

            // Increment
            m_pHeader->rgcbAllocated[BLOCK_ENDOFPAGE] += cbLeft;

            // Lets Free This block
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_ENDOFPAGE, (pPage->faPage + pPage->cbUsed)));

            // Nothgin Left
            cbLeft = 0;
        }

        // Use the entire page
        else if (cbLeft != cbBlock && cbLeft - cbBlock < CB_MIN_FREE_BUCKET)
        {
            // Must be a BLOCK_RECORD
            Assert(BLOCK_STREAM != tyBlock && BLOCK_CHAIN != tyBlock);
            
            // Adjust cbBlock
            cbBlock += (cbLeft - cbBlock);
        }

        // Need to allocate a page
        if (0 == pPage->faPage || 0 == cbLeft)
        {
            // Kill the page
            ZeroMemory(pPage, sizeof(ALLOCATEPAGE));

            // Allocate space in the file
            IF_FAILEXIT(hr = _AllocatePage(cbPage, &pPage->faPage));

            // Set cbChainPageLeft
            pPage->cbPage = cbPage;
        }

        // Mark the block
        IF_FAILEXIT(hr = _MarkBlock(tyBlock, (pPage->faPage + pPage->cbUsed), cbBlock, ppvBlock));

        // Set Next Allocation
        pPage->cbUsed += cbBlock;

        // Validate
        Assert(pPage->cbUsed <= pPage->cbPage);
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SetCorrupt
//--------------------------------------------------------------------------
HRESULT CDatabase::_SetCorrupt(BOOL fGoCorrupt, INT nLine, 
    CORRUPTREASON tyReason, BLOCKTYPE tyBlock, FILEADDRESS faExpected, 
    FILEADDRESS faActual, DWORD cbBlock)
{
    // Trace
    TraceCall("CDatabase::_SetCorrupt");

    // Go Corrupt
    if (fGoCorrupt)
    {
        // Store it in the header
        m_pHeader->fCorrupt = TRUE;
    }

    // Done - This is always return to get the calling operation to abort
    return(DB_E_CORRUPT);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateSpecialView
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateSpecialView(FILEADDRESS faView, 
    DWORD cbView, LPFILEVIEW *ppSpecial)
{
    // Locals
    HRESULT     hr=S_OK;
    LPFILEVIEW  pView=NULL;

    // Trace
    TraceCall("CDatabase::_AllocateSpecialView");

    // Try to find existing special view where faView / cbView fits...
    for (pView = m_pStorage->pSpecial; pView != NULL; pView = pView->pNext)
    {
        // Fit into this view ?
        if (faView >= pView->faView && faView + cbView <= pView->faView + pView->cbView)
        {
            // This is good...
            *ppSpecial = pView;

            // Don't Freep
            pView = NULL;

            // Done
            goto exit;
        }
    }

    // Create a Special View
    IF_NULLEXIT(pView = (LPFILEVIEW)PHeapAllocate(0, sizeof(FILEVIEW)));

    // Set faView
    pView->faView = faView;

    // Set cbView
    pView->cbView = cbView;

    // Map the View
    IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

    // Increment Statistic
    m_pStorage->cSpecial++;

    // Increment cbMappedSpecial
    m_pStorage->cbMappedSpecial += pView->cbView;

    // Link pView into Special List
    pView->pNext = m_pStorage->pSpecial;

    // Set pSpecial
    m_pStorage->pSpecial = pView;

    // Set Return
    *ppSpecial = pView;

    // Don't Free It
    pView = NULL;

exit:
    // Cleanup
    SafeHeapFree(pView);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetBlock(BLOCKTYPE tyExpected, FILEADDRESS faBlock,
    LPVOID *ppvBlock, LPMARKBLOCK pMark /* =NULL */, BOOL fGoCorrupt /* TRUE */)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iViewStart;
    DWORD           iViewEnd;
    LPFILEVIEW      pView;
    DWORD           cbBlock;
    LPBLOCKHEADER   pBlock;
    LPFILEVIEW      pSpecial=NULL;

    // Trace
    TraceCall("CDatabase::_CheckBlock");

    // Invalid Args
    IxpAssert(faBlock > 0 && ppvBlock);

    // Storage is Setup ?
    IxpAssert(m_pStorage->hMap && m_pStorage->prgView);

    // faBlock is Out-of-Range
    if (faBlock + sizeof(BLOCKHEADER) >= m_pStorage->cbFile)
    {
        hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_BLOCKSTARTOUTOFRANGE, tyExpected, faBlock, 0xFFFFFFFF, 0xFFFFFFFF);
        goto exit;
    }

    // Determine iView
    iViewStart = (faBlock / CB_MAPPED_VIEW);

    // Set iViewend
    iViewEnd = (faBlock + sizeof(BLOCKHEADER)) / CB_MAPPED_VIEW;

    // If the Header Straddles a view boundary...
    if (iViewStart != iViewEnd)
    {
        // Allocate a Special View
        IF_FAILEXIT(hr = _AllocateSpecialView(faBlock, g_SystemInfo.dwAllocationGranularity, &pSpecial));

        // Set pView
        pView = pSpecial;
    }

    // Otherwise, use a view
    else
    {
        // Validate iView
        IxpAssert(iViewStart < m_pStorage->cAllocated);

        // Readability
        pView = &m_pStorage->prgView[iViewStart];

        // Is this View Mapped yet ?
        if (NULL == pView->pbView)
        {
            // Validate the Entry
            IxpAssert(0 == pView->faView && 0 == pView->cbView && NULL == pView->pNext);

            // Set faView
            pView->faView = (iViewStart * CB_MAPPED_VIEW);

            // Set cbView
            pView->cbView = min(m_pStorage->cbFile - pView->faView, CB_MAPPED_VIEW);

            // Map the View
            IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

            // Increment cbMappedSpecial
            m_pStorage->cbMappedViews += pView->cbView;
        }
    }

    // De-Ref the Block (Offset from start of the view)
    pBlock = (LPBLOCKHEADER)(pView->pbView + (faBlock - pView->faView));

    // Mark the block
    if (pMark)
    {
        // Set the Address
        pBlock->faBlock = faBlock;

        // Set cbBlock
        cbBlock = pMark->cbBlock;

        // Adjust cbSize
        pBlock->cbSize = cbBlock - g_rgcbBlockSize[tyExpected];
    }

    // Otherwise, validate the block
    else 
    {
        // Get Block Size
        cbBlock = pBlock->cbSize + g_rgcbBlockSize[tyExpected];

        // Check the Block Start Address
        if (faBlock != pBlock->faBlock)
        {
            hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_UMATCHINGBLOCKADDRESS, tyExpected, faBlock, pBlock->faBlock, cbBlock);
            goto exit;
        }

        // Size of Block is Out-of-range
        if (pBlock->faBlock + cbBlock > m_pStorage->cbFile)
        {
            hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_BLOCKSIZEOUTOFRANGE, tyExpected, faBlock, pBlock->faBlock, cbBlock);
            goto exit;
        }
    }

    // Compute iViewEnd
    iViewEnd = ((faBlock + cbBlock) / CB_MAPPED_VIEW);

    // Does this block end within the same view, or is the block larger than my view size ?
    if (iViewStart != iViewEnd)
    {
        // If I already allocated a special view...
        if (pSpecial)
        {
            // Validate
            IxpAssert(pView == pSpecial);

            // Does faBlock + cbBlock fit into pSpecial ?
            if ((faBlock - pView->faView) + cbBlock > pView->cbView)
            {
                // Validate
                IxpAssert(pView->pbView);

                // Lets Flush It
                FlushViewOfFile(pView->pbView, 0);

                // Unmap this view
                SafeUnmapViewOfFile(pView->pbView);

                // Decrement cbMappedSpecial
                m_pStorage->cbMappedSpecial -= pView->cbView;

                // Set faView
                pView->faView = faBlock;

                // Set cbView
                pView->cbView = cbBlock;

                // Map the View
                IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

                // Increment cbMappedSpecial
                m_pStorage->cbMappedSpecial += pView->cbView;
            }
        }

        // Otherwise, create a special view
        else
        {
            // Allocate a Special View
            IF_FAILEXIT(hr = _AllocateSpecialView(faBlock, cbBlock, &pSpecial));

            // Set pView
            pView = pSpecial;
        }
    }

    // Validate
    IxpAssert((faBlock - pView->faView) + cbBlock <= pView->cbView);

    // Return the Block (offset from start of block)
    *ppvBlock = (LPVOID)(pView->pbView + (faBlock - pView->faView));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ReuseFixedFreeBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_ReuseFixedFreeBlock(LPFILEADDRESS pfaFreeHead, 
    BLOCKTYPE tyBlock, DWORD cbExpected, LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faHead=(*pfaFreeHead);
    DWORD           cbBlock;
    LPFREEBLOCK     pFree;

    // Is there a free block
    if (0 == faHead)
        return(S_OK);

    // Get the Free Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faHead, (LPVOID *)&pFree));

    // Validate
    Assert(cbExpected == pFree->cbBlock);

    // Set *ppHeader
    *ppvBlock = (LPVOID)pFree;

    // Set the New Head Free Chain Block
    *pfaFreeHead = pFree->faNext;

    // Change the Size
    pFree->cbSize = cbExpected - g_rgcbBlockSize[tyBlock];

    // Mark the Block
    *ppvBlock = (LPVOID)pFree;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateBlock(BLOCKTYPE tyBlock, DWORD cbExtra,
    LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBlock;
    DWORD           iBucket;

    // Trace
    TraceCall("CDatabase::_AllocateBlock");

    // Invalid State
    Assert(ppvBlock && BLOCK_ENDOFPAGE != tyBlock && BLOCK_FREE != tyBlock);

    // Initialize
    *ppvBlock = NULL;

    // Add Space Needed to store tyBlock
    cbBlock = (g_rgcbBlockSize[tyBlock] + cbExtra);

    // Dword Align
    cbBlock += DwordAlign(cbBlock);

    // Allocating a Chain Block ?
    if (BLOCK_CHAIN == tyBlock)
    {
        // Reuse Free Block...
        IF_FAILEXIT(hr = _ReuseFixedFreeBlock(&m_pHeader->faFreeChainBlock, BLOCK_CHAIN, cbBlock, ppvBlock));
    }

    // Allocating a Stream Block ?
    else if (BLOCK_STREAM == tyBlock)
    {
        // Append Stream Block Size
        cbBlock += CB_STREAM_BLOCK;

        // Reuse Free Block...
        IF_FAILEXIT(hr = _ReuseFixedFreeBlock(&m_pHeader->faFreeStreamBlock, BLOCK_STREAM, cbBlock, ppvBlock));
    }

    // Otherwise, allocating a record block
    else if (cbBlock <= CB_MAX_FREE_BUCKET)
    {
        // Adjust cbBlock
        if (cbBlock < CB_MIN_FREE_BUCKET)
            cbBlock = CB_MIN_FREE_BUCKET;

        // Compute Free Block Bucket
        iBucket = ((cbBlock - CB_MIN_FREE_BUCKET) / CB_FREE_BUCKET);

        // Validate
        Assert(iBucket < CC_FREE_BUCKETS);

        // Is there a Free Block in this bucket
        if (m_pHeader->rgfaFreeBlock[iBucket])
        {
            // PopFreeBlock
            _ReuseFixedFreeBlock(&m_pHeader->rgfaFreeBlock[iBucket], tyBlock, cbBlock, ppvBlock);
        }
    }

    // Otherwise
    else
    {
        // Locals
        FILEADDRESS     faCurrent;
        LPFREEBLOCK     pCurrent;
        LPFREEBLOCK     pPrevious=NULL;

        // Adjust cbBlock to the next 1k Boundary
        cbBlock = (((cbBlock / CB_ALIGN_LARGE) + 1) * CB_ALIGN_LARGE);

        // Set faCurrent
        faCurrent = m_pHeader->faFreeLargeBlock;

        // Loop through free large blocks (Sorted from smallest to largest)
        while (faCurrent)
        {
            // Get the Current Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faCurrent, (LPVOID *)&pCurrent));

            // If this block is too small...
            if (cbBlock <= pCurrent->cbBlock)
            {
                // Set Next Free Chain Address
                if (NULL == pPrevious)
                {
                    // Set First Free Chain
                    m_pHeader->faFreeLargeBlock = pCurrent->faNext;
                }

                // Otherwise, relink free chains
                else
                {
                    // Set the next block
                    pPrevious->faNext = pCurrent->faNext;
                }

                // Reset the Block Types
                IF_FAILEXIT(hr = _MarkBlock(tyBlock, faCurrent, cbBlock, ppvBlock));

                // Done
                break;
            }

            // Save Previous
            pPrevious = pCurrent;

            // Set Current
            faCurrent = pCurrent->faNext;
        }
    }

    // Didn't find a block to allocate
    if (0 == *ppvBlock)
    {
        // Is there a page with some space on it...
        if (BLOCK_CHAIN == tyBlock)
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateChain;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(BLOCK_CHAIN, &AllocatePage, CB_CHAIN_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateChain = AllocatePage;
        }

        // Stream Block
        else if (BLOCK_STREAM == tyBlock)
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateStream;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(BLOCK_STREAM, &AllocatePage, CB_STREAM_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateStream = AllocatePage;
        }

        // Record Block
        else
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateRecord;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(tyBlock, &AllocatePage, CB_VARIABLE_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateRecord = AllocatePage;
        }

        // Metrics
        m_pHeader->cbAllocated += cbBlock;
    }

    // Otherwise
    else
    {
        // Metrics
        m_pHeader->cbFreed -= cbBlock;
    }

    // Increment
    m_pHeader->rgcbAllocated[tyBlock] += cbBlock;

exit:
    // We should have found something
    Assert(SUCCEEDED(hr) ? *ppvBlock > 0 : TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeBlock(BLOCKTYPE tyBlock, FILEADDRESS faAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iBucket;
    DWORD           cbBlock;
    LPFREEBLOCK     pFree;

    // Trace
    TraceCall("CDatabase::_FreeBlock");

    // Invalid Args
    Assert(BLOCK_FREE != tyBlock);

    // Never Free faAddress 0?
    if (0 == faAddress)
    {
        Assert(FALSE);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

#ifdef DEBUG
#ifdef FREBLOCK_VALIDATION
    if (BLOCK_RECORD == tyBlock)
        _DebugValidateUnrefedRecord(faAddress);
#endif // FREBLOCK_VALIDATION
#endif // DEBUG

    // Get the Block
    IF_FAILEXIT(hr = _GetBlock(tyBlock, faAddress, (LPVOID *)&pFree));

    // Save Block Size
    cbBlock = pFree->cbSize + g_rgcbBlockSize[tyBlock];

    // Mark Block as Free
    pFree->cbSize = cbBlock - g_rgcbBlockSize[BLOCK_FREE];

    // Set Block Size
    pFree->cbBlock = cbBlock;

    // Initialize
    pFree->faNext = 0;

    // BLOCK_CHAIN
    if (BLOCK_CHAIN == tyBlock)
    {
        // Fill free node header
        pFree->faNext = m_pHeader->faFreeChainBlock;

        // Set new iFreeChain
        m_pHeader->faFreeChainBlock = pFree->faBlock;
    }

    // BLOCK_STREAM
    else if (BLOCK_STREAM == tyBlock)
    {
        // Fill free node header
        pFree->faNext = m_pHeader->faFreeStreamBlock;

        // Set new iFreeChain
        m_pHeader->faFreeStreamBlock = pFree->faBlock;
    }

    // Other types of variable length blocks
    else if (pFree->cbBlock <= CB_MAX_FREE_BUCKET)
    {
        // Validate
        Assert(pFree->cbBlock >= CB_MIN_FREE_BUCKET && (pFree->cbBlock % 4) == 0);

        // Compute Free Block Bucket
        iBucket = ((pFree->cbBlock - CB_MIN_FREE_BUCKET) / CB_FREE_BUCKET);

        // Fill free node header
        pFree->faNext = m_pHeader->rgfaFreeBlock[iBucket];

        // Set new iFreeChain
        m_pHeader->rgfaFreeBlock[iBucket] = pFree->faBlock;
    }

    // Otherwise, freeing a large block
    else
    {
        // Must be an integral size of a a large block
        Assert((pFree->cbBlock % CB_ALIGN_LARGE) == 0);

        // If there are no blocks yet
        if (0 == m_pHeader->faFreeLargeBlock)
        {
            // Set the Head
            m_pHeader->faFreeLargeBlock = pFree->faBlock;
        }

        // Otherwise, link into the sorted list
        else
        {
            // Put this block in sorted order from smallest to the largest...
            FILEADDRESS     faCurrent;
            LPFREEBLOCK     pCurrent;
            LPFREEBLOCK     pPrevious=NULL;

            // Set faCurrent
            faCurrent = m_pHeader->faFreeLargeBlock;

            // Loop through free large blocks (Sorted from smallest to largest)
            while (faCurrent)
            {
                // Get the Current Block
                IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faCurrent, (LPVOID *)&pCurrent));

                // If pBlock is less than pCurrent, then insert after pPreviuos but before pCurrent
                if (pFree->cbBlock <= pCurrent->cbBlock)
                {
                    // Previous
                    if (pPrevious)
                    {
                        // Validate
                        Assert(pPrevious->faNext == faCurrent);

                        // Set Next
                        pPrevious->faNext = pFree->faBlock;
                    }

                    // Otherwise, adjust the head
                    else
                    {
                        // Validate
                        Assert(m_pHeader->faFreeLargeBlock == faCurrent);

                        // Set the Head
                        m_pHeader->faFreeLargeBlock = pFree->faBlock;
                    }

                    // Set pBlock Next
                    pFree->faNext = faCurrent;

                    // Done
                    break;
                }

                // Next Block is Null ?
                else if (0 == pCurrent->faNext)
                {
                    // Append to the End
                    pCurrent->faNext = pFree->faBlock;

                    // Done
                    break;
                }

                // Save Previous
                pPrevious = pCurrent;

                // Set Current
                faCurrent = pCurrent->faNext;
            }
        }
    }

    // Increment
    m_pHeader->rgcbAllocated[tyBlock] -= pFree->cbBlock;

    // Metrics
    m_pHeader->cbFreed += pFree->cbBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetSize
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, 
    LPDWORD pcbFreed, LPDWORD pcbStreams)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetSize");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Return pcbFile
    if (pcbFile)
        *pcbFile = m_pStorage->cbFile;

    // Return pcbAllocated
    if (pcbAllocated)
        *pcbAllocated = m_pHeader->cbAllocated;

    // Return pcbFreed
    if (pcbFreed)
        *pcbFreed = (m_pHeader->cbFreed + (m_pStorage->cbFile - m_pHeader->faNextAllocate));

    // Return pcbStreams
    if (pcbStreams)
        *pcbStreams = m_pHeader->rgcbAllocated[BLOCK_STREAM];

exit:
    // Unlock the Heap
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetRecordCount
//--------------------------------------------------------------------------
HRESULT CDatabase::GetRecordCount(INDEXORDINAL iIndex, ULONG *pcRecords)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // TraceCall
    TraceCall("CDatabase::GetRecordCount");

    // Invalid Args
    Assert(pcRecords && iIndex < CMAX_INDEXES);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Return the Count
    *pcRecords = m_pHeader->rgcRecords[iIndex];

exit:
    // Unlock the Heap
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::UpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UpdateRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrVisible;
    INT             nCompare;
    DWORD           i;
    INDEXORDINAL    iIndex;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    ROWORDINAL      iRow;
    FILEADDRESS     faOldRecord=0;
    FILEADDRESS     faNewRecord=0;
    BYTE            bVersion;
    LPVOID          pBindingOld=NULL;
    LPRECORDBLOCK   pRecord;
    ORDINALLIST     Ordinals;
    LPCHAINBLOCK    pChain;
    RECORDMAP       RecordMap;
    HLOCK           hLock=NULL;
    DWORD           cNotify=0;
    FINDRESULT      rgResult[CMAX_INDEXES];

    // Trace
    TraceCall("CDatabase::UpdateRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Primary Index Can not change
    rgResult[0].fChanged = FALSE;

    // Try to find the existing record
    IF_FAILEXIT(hr = _FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pBinding, &rgResult[0].faChain, &rgResult[0].iNode, &Ordinals.rgiRecord1[IINDEX_PRIMARY]));

    // If not found, you can't update it. Use Insert
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Primary Index Can not change
    rgResult[0].fFound = TRUE;

    // Cast pChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[0].faChain, (LPVOID *)&pChain));

    // De-Reference the Record
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pChain->rgNode[rgResult[0].iNode].faRecord, (LPVOID *)&pRecord));

    // Get the Version
    bVersion = *((BYTE *)((LPBYTE)pBinding + m_pSchema->ofVersion));

    // Version Difference ?
    if (pRecord->bVersion != bVersion)
    {
        hr = TraceResult(DB_E_RECORDVERSIONCHANGED);
        goto exit;
    }

    // More than one index ?
    if (m_pHeader->cIndexes > 1 || m_pExtension)
    {
        // Allocate a Binding
        IF_NULLEXIT(pBindingOld = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Read the Record
        IF_FAILEXIT(hr = _ReadRecord(pRecord->faBlock, pBindingOld));
    }

    // Call Extension
    if (m_pExtension)
    {
        // Extend Record Updates
        m_pExtension->OnRecordUpdate(OPERATION_BEFORE, NULL, pBindingOld, pBinding);
    }

    // Loop through the indexes
    for (i = 1; i < m_pHeader->cIndexes; i++)
    {
        // Get iIndex
        iIndex = m_pHeader->rgiIndex[i];

        // Try to find the existing record
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBindingOld, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex]));

        // If not found, you can't update it. Use Insert
        if (DB_S_FOUND == hr)
        {
            // We Found the Record
            rgResult[i].fFound = TRUE;

            // Did Record's Key Change for this Index ?
            IF_FAILEXIT(hr = _CompareBinding(iIndex, COLUMNS_ALL, pBinding, pRecord->faBlock, &nCompare));

            // Not the Same ?
            if (0 != nCompare)
            {
                // Changed
                rgResult[i].fChanged = TRUE;

                // Otherwise: Decide Where to insert
                IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, &iRow));

                // If pBinding is already in this index, then its going to be a duplicate
                if (DB_S_FOUND == hr)
                {
                    hr = TraceResult(DB_E_DUPLICATE);
                    goto exit;
                }
            }

            // Otherwise, the index hasn't changed
            else
            {
                // Assume the Index is Unchanged
                rgResult[i].fChanged = FALSE;
            }
        }

        // Otherwise, not found
        else
        {
            // This Index Must be Filtered
            Assert(m_rghFilter[iIndex]);

            // Not Found
            rgResult[i].fFound = FALSE;

            // Changed
            rgResult[i].fChanged = TRUE;

            // First Record Never Existed
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;

            // See if the new record already exists in this index
            IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, &iRow));

            // If pBinding is already in this index, then its going to be a duplicate
            if (DB_S_FOUND == hr)
            {
                hr = TraceResult(DB_E_DUPLICATE);
                goto exit;
            }
        }
    }

    // Save the old node
    faOldRecord = pRecord->faBlock;

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Record Shrunk or stayed the same...?
    if (RecordMap.cbData + RecordMap.cbTags <= pRecord->cbSize && 0 == m_pShare->cNotifyWithData)
    {
        // Persist the Record
        IF_FAILEXIT(hr = _SaveRecord(pRecord, &RecordMap, pBinding));

        // Set faNewRecord
        faNewRecord = pRecord->faBlock;

        // Validate the Version
        Assert(bVersion + 1 == pRecord->bVersion || bVersion + 1 == 256);
    }

    // Otherwise, record grew in size
    else
    {
        // Don't Use This Again
        pRecord = NULL;

        // Link the new record into the table
        IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, bVersion, &faNewRecord));
    }

    // Update all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Adjustment for filtered indexes
        hrVisible = _IsVisible(m_rghFilter[iIndex], pBinding);

        // Not Changed ?
        if (S_OK == hrVisible && FALSE == rgResult[i].fChanged && TRUE == rgResult[i].fFound)
        {
            // Record Changed Locations ?
            if (faOldRecord != faNewRecord)
            {
                // Just Update the Address of the New Record
                IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[i].faChain, (LPVOID *)&pChain));

                // Update the Chain
                pChain->rgNode[rgResult[i].iNode].faRecord = faNewRecord;
            }

            // Ordinal is Unchanged
            Ordinals.rgiRecord2[iIndex] = Ordinals.rgiRecord1[iIndex];

            // If Index changed and somebody wanted notifications about this index
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }

        // Otherwise...
        else
        {
            // If the Record was found, delete it
            if (TRUE == rgResult[i].fFound)
            {
                // Delete the Record from the index
                IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, rgResult[i].faChain, rgResult[i].iNode));

                // Adjust Open Rowsets
                _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_DELETE);

                // Update Record Count
                m_pHeader->rgcRecords[iIndex]--;

                // If Index changed and somebody wanted notifications about this index
                cNotify += m_pShare->rgcIndexNotify[iIndex];
            }

            // Visible ?
            if (S_OK == hrVisible)
            {
                // Otherwise: Decide Where to insert
                IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord2[iIndex], &rgResult[i].nCompare));

                // Not Found
                Assert(DB_S_NOTFOUND == hr);

                // Do the Insertion
                IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faNewRecord, &rgResult[i].iNode, rgResult[i].nCompare));

                // Update Record Count
                m_pHeader->rgcRecords[iIndex]++;

                // Adjust iRow
                Ordinals.rgiRecord2[iIndex] += (rgResult[i].iNode + 1);

                // Adjust Open Rowsets
                _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord2[iIndex], OPERATION_INSERT);

                // If Index changed and somebody wanted notifications about this index
                cNotify += m_pShare->rgcIndexNotify[iIndex];
            }

            // Otherwise...
            else
            {
                // Doesn't Exist
                Ordinals.rgiRecord2[iIndex] = INVALID_ROWORDINAL;
            }
        }
    }

    // Send Notifications ?
    if (cNotify > 0)
    {
        // Send Notifications ?
        if (0 == m_pShare->cNotifyWithData)
        {
            // Build the Update Notification Package
            _LogTransaction(TRANSACTION_UPDATE, INVALID_INDEX_ORDINAL, &Ordinals, 0, 0);
        }

        // Otherwise...
        else
        {
            // Must have copied...
            Assert(faOldRecord != faNewRecord);

            // Build the Update Notification Package
            _LogTransaction(TRANSACTION_UPDATE, INVALID_INDEX_ORDINAL, &Ordinals, faOldRecord, faNewRecord);
        }
    }

    // Otherwise, free the old record
    else if (faOldRecord != faNewRecord)
    {
        // De-allocate the record from the file
        IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_UPDATE, faOldRecord));
    }

    // Update the Version
    bVersion++;

    // Store the Version back into the record
    *((WORD *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = bVersion;

    // Version Change
    m_pShare->dwVersion++;

    // Call Extension
    if (m_pExtension)
    {
        // Extend Record Updates
        m_pExtension->OnRecordUpdate(OPERATION_AFTER, &Ordinals, pBindingOld, pBinding);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBindingOld);

    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_LinkRecordIntoTable
//--------------------------------------------------------------------------
HRESULT CDatabase::_LinkRecordIntoTable(LPRECORDMAP pMap, LPVOID pBinding,
    BYTE bVersion, LPFILEADDRESS pfaRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRECORDBLOCK   pCurrent;
    LPRECORDBLOCK   pPrevious;

    // Trace
    TraceCall("CDatabase::_LinkRecordIntoTable");

    // Invalid Args
    Assert(pBinding && pfaRecord);

    // Allocate a block in the file for the record
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_RECORD, pMap->cbData + pMap->cbTags, (LPVOID *)&pCurrent));

    // Set the Version
    pCurrent->bVersion = bVersion;

    // Persist the Record
    IF_FAILEXIT(hr = _SaveRecord(pCurrent, pMap, pBinding));

    // Return *pfaRecord
    *pfaRecord = pCurrent->faBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustParentNodeCount
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustParentNodeCount(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, LONG lCount)
{
    // De-ref
    HRESULT         hr=S_OK;
    LPCHAINBLOCK    pParent;
    LPCHAINBLOCK    pCurrent;

    // Trace
    TraceCall("CDatabase::_AdjustParentNodeCount");

    // Invalid Arg
    Assert(faChain && (1 == lCount || -1 == lCount));

    // Set pCurrent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pCurrent));

    // Goto the Parent...
    while (1)
    {
        // Goto the Parent
        if (0 == pCurrent->faParent)
        {
            // Better be the root
            Assert(pCurrent->faBlock == m_pHeader->rgfaIndex[iIndex] && 0 == pCurrent->iParent);

            // Done
            break;
        }

        // Set pCurrent
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

        // Validate
        Assert(pCurrent->iParent < pParent->cNodes);

        // 0 Node
        if (0 == pCurrent->iParent && pParent->faLeftChain == pCurrent->faBlock)
        {
            // Increment or Decrement Count
            pParent->cLeftNodes += lCount;
        }

        // Otherwise, increment cRightNodes
        else
        {
            // Validate
            Assert(pParent->rgNode[pCurrent->iParent].faRightChain == pCurrent->faBlock);

            // Increment Right Node Count
            pParent->rgNode[pCurrent->iParent].cRightNodes += lCount;
        }

        // Update pCurrent
        pCurrent = pParent;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::LockNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::LockNotify");

    // Invalid Args
    if (NULL == phLock)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *phLock = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Increment Queue Notify count
    m_pShare->cNotifyLock++;

    // Store Some Non-null value
    *phLock = (HLOCK)m_hMutex;

exit:
    // Unlock
    Unlock(&hLock);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::UnlockNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UnlockNotify(LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::UnlockNotify");

    // Invalid Args
    if (NULL == phLock)
        return TraceResult(E_INVALIDARG);

    // Nothing to Unlock?
    if (NULL == *phLock)
        return(S_OK);

    // Store Some Non-null value
    Assert(*phLock == (HLOCK)m_hMutex);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Increment Queue Notify count
    m_pShare->cNotifyLock--;

    // No more Lock
    *phLock = NULL;

    // If there are still refs, don't send notifications yet...
    if (m_pShare->cNotifyLock)
        goto exit;

    // Dispatch Pending Notifications
    _DispatchPendingNotifications();

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetTransaction
//--------------------------------------------------------------------------
HRESULT CDatabase::GetTransaction(LPHTRANSACTION phTransaction, 
    LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, 
    LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPTRANSACTIONBLOCK  pTransaction;
    FILEADDRESS         faTransaction;

    // Trace
    TraceCall("CDatabase::GetTransaction");

    // Validate
    Assert(phTransaction && ptyTransaction && pOrdinals);

    // No Transaction
    if (NULL == *phTransaction)
        return TraceResult(E_INVALIDARG);

    // Setup faTransaction
    faTransaction = (FILEADDRESS)PtrToUlong((*phTransaction));

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Transaction Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, faTransaction, (LPVOID *)&pTransaction));

    // Validate
    IxpAssert(pTransaction->cRefs > 0);

    // Set tyTransaction
    *ptyTransaction = pTransaction->tyTransaction;

    // Copy Index
    *piIndex = pTransaction->iIndex;

    // Copy Ordinals
    CopyMemory(pOrdinals, &pTransaction->Ordinals, sizeof(ORDINALLIST));

    // Set hNext
    (*phTransaction) = (HTRANSACTION)IntToPtr(pTransaction->faNextInBatch);

    // Did the caller want Record 1
    if (pRecord1 && pTransaction->faRecord1)
    {
        // Free pRecord1
        FreeRecord(pRecord1);

        // Read Record 1
        IF_FAILEXIT(hr = _ReadRecord(pTransaction->faRecord1, pRecord1));
    }

    // Read Second Record
    if (pRecord2 && pTransaction->faRecord2)
    {
        // Must be an Update
        Assert(TRANSACTION_UPDATE == pTransaction->tyTransaction);

        // Free pRecord1
        FreeRecord(pRecord2);

        // Read Record 2
        IF_FAILEXIT(hr = _ReadRecord(pTransaction->faRecord2, pRecord2));
    }

    // Decrement Refs on this item
    pTransaction->cRefs--;

    // If hit zero, release it
    if (pTransaction->cRefs > 0)
        goto exit;

    // Free Transact Block
    IF_FAILEXIT(hr = _FreeTransactBlock(pTransaction));

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeTransactBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeTransactBlock(LPTRANSACTIONBLOCK pTransaction)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTRANSACTIONBLOCK  pPrevious;
    LPTRANSACTIONBLOCK  pNext;

    // Trace
    TraceCall("CDatabase::_FreeTransactBlock");

    // Better be Zero
    IxpAssert(0 == pTransaction->cRefs);
    IxpAssert(m_pHeader->cTransacts > 0);

    // Previous ?
    if (pTransaction->faPrevious)
    {
        // Get the Previous
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, pTransaction->faPrevious, (LPVOID *)&pPrevious));

        // Set Previous Next
        pPrevious->faNext = pTransaction->faNext;
    }

    // Otherwise, adjust head
    else
    {
        // Validate
        IxpAssert(pTransaction->faBlock == m_pHeader->faTransactHead);

        // Adjust Head
        m_pHeader->faTransactHead = pTransaction->faNext;
    }

    // Next ?
    if (pTransaction->faNext)
    {
        // Get the Previous
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, pTransaction->faNext, (LPVOID *)&pNext));

        // Set Previous Next
        pNext->faPrevious = pTransaction->faPrevious;
    }

    // Otherwise, adjust head
    else
    {
        // Validate
        IxpAssert(pTransaction->faBlock == m_pHeader->faTransactTail);

        // Adjust Head
        m_pHeader->faTransactTail = pTransaction->faPrevious;
    }

    // Decrement cTransacts
    m_pHeader->cTransacts--;

    // If there is a record 1
    if (pTransaction->faRecord1)
    {
        // TRANSACTION_DELETE gets specail case
        if (TRANSACTION_DELETE == pTransaction->tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, pTransaction->faRecord1));
        }

        // Otherwise, basic freeblock
        else
        {
            // Free Record 1
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, pTransaction->faRecord1));
        }
    }

    // Read Second Record
    if (pTransaction->faRecord2)
    {
        // Read Record 2
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, pTransaction->faRecord2));
    }

    // Free this block
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_TRANSACTION, pTransaction->faBlock));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CleanupTransactList
//--------------------------------------------------------------------------
HRESULT CDatabase::_CleanupTransactList(void)
{
    // Locals
    HRESULT             hr=S_OK;
    FILEADDRESS         faCurrent;
    LPTRANSACTIONBLOCK  pTransaction;

    // Trace
    TraceCall("CDatabase::_CleanupTransactList");

    // Validate
    Assert(0 == m_pHeader->faTransactHead ? 0 == m_pHeader->faTransactTail && 0 == m_pHeader->cTransacts : TRUE);

    // Set faCurrent
    faCurrent = m_pHeader->faTransactHead;

    // While we have a current
    while (faCurrent)
    {
        // Get Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, faCurrent, (LPVOID *)&pTransaction));

        // Set faCurrent
        faCurrent = pTransaction->faNext;

        // Set cRefs to Zero
        pTransaction->cRefs = 0;

        // Free It
        IF_FAILEXIT(hr = _FreeTransactBlock(pTransaction));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CopyRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_CopyRecord(FILEADDRESS faRecord, LPFILEADDRESS pfaCopy)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRECORDBLOCK   pRecordSrc;
    LPRECORDBLOCK   pRecordDst;

    // Trace
    TraceCall("CDatabase::_CopyRecord");

    // Get Soruce
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecordSrc));

    // Allocate a New block
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_RECORD, pRecordSrc->cbSize, (LPVOID *)&pRecordDst));

    // Get Soruce
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecordSrc));

    // Set Version
    pRecordDst->bVersion = pRecordSrc->bVersion;

    // Set cTags
    pRecordDst->cTags = pRecordSrc->cTags;

    // Copy Data
    CopyMemory((LPBYTE)pRecordDst + sizeof(RECORDBLOCK), (LPBYTE)pRecordSrc + sizeof(RECORDBLOCK), pRecordSrc->cbSize);

    // Return Address
    *pfaCopy = pRecordDst->faBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_LogTransaction
//--------------------------------------------------------------------------
HRESULT CDatabase::_LogTransaction(TRANSACTIONTYPE tyTransaction, 
    INDEXORDINAL iIndex, LPORDINALLIST pOrdinals, FILEADDRESS faInRecord1, 
    FILEADDRESS faInRecord2)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTRANSACTIONBLOCK  pTransaction;
    LPTRANSACTIONBLOCK  pTail;
    FILEADDRESS         faRecord1=0;
    FILEADDRESS         faRecord2=0;

    // Trace
    TraceCall("CDatabase::_LogTransaction");

    // Nobody is registered
    if (0 == m_pShare->cNotify)
        return(S_OK);

    // If there are people who actually want some data...
    if (m_pShare->cNotifyWithData > 0)
    {
        // Initialize
        faRecord1 = faInRecord1;
        faRecord2 = faInRecord2;

        // TRANSACTION_INSERT
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Copy Record 2
            IF_FAILEXIT(hr = _CopyRecord(faInRecord1, &faRecord1));
        }

        // TRANSACTION_UPDATE
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Copy Record 2
            IF_FAILEXIT(hr = _CopyRecord(faInRecord2, &faRecord2));
        }
    }

    // Otherwise, free some stuff...
    else if (faInRecord1 > 0)
    {
        // TRANSACTION_DELETE
        if (TRANSACTION_DELETE == tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, faInRecord1));
        }

        // TRANSACTION_UPDATE
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_UPDATE, faInRecord1));
        }
    }

    // Allocate Notification Block
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_TRANSACTION, 0, (LPVOID *)&pTransaction));

    // Set tyTransaction
    pTransaction->tyTransaction = tyTransaction;

    // Set cRefs
    pTransaction->cRefs = (WORD)m_pShare->cNotify;

    // Copy iIndex
    pTransaction->iIndex = iIndex;

    // If there are ordinals
    if (pOrdinals)
    {
        // Save Sequence
        CopyMemory(&pTransaction->Ordinals, pOrdinals, sizeof(ORDINALLIST));
    }

    // Otherwise, fill ordinals with record counts
    else
    {
        // Validate Transaction Type
        Assert(TRANSACTION_INDEX_CHANGED == tyTransaction || TRANSACTION_INDEX_DELETED == tyTransaction || TRANSACTION_COMPACTED == tyTransaction);

        // Save Sequence
        ZeroMemory(&pTransaction->Ordinals, sizeof(ORDINALLIST));
    }

    // Set the Record Addresses
    pTransaction->faRecord1 = faRecord1;
    pTransaction->faRecord2 = faRecord2;

    // Link Into the Transaction List
    pTransaction->faNext = pTransaction->faPrevious = pTransaction->faNextInBatch = 0;

    // No Head yet
    if (0 == m_pHeader->faTransactHead)
    {
        // Set Head and Tail
        m_pHeader->faTransactHead = pTransaction->faBlock;
    }

    // Otherwise, append to tail
    else
    {
        // Get the Transaction Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, m_pHeader->faTransactTail, (LPVOID *)&pTail));

        // Link Into the Transaction List
        pTail->faNext = pTransaction->faBlock;

        // Set Previous
        pTransaction->faPrevious = pTail->faBlock;
    }

    // Set the Tail
    m_pHeader->faTransactTail = pTransaction->faBlock;

    // Increment cTransacts
    m_pHeader->cTransacts++;

    // Are we Queueing Notifications...
    if (0 == m_pShare->cNotifyLock)
    {
        // Validate
        IxpAssert(0 == m_pShare->faTransactLockHead && 0 == m_pShare->faTransactLockTail);

        // Dispatch Invoke
        IF_FAILEXIT(hr = _DispatchNotification((HTRANSACTION)IntToPtr(pTransaction->faBlock)));
    }

    // Otherwise, build the transaction lock list
    else
    {
        // Set LockHead
        if (0 == m_pShare->faTransactLockHead)
        {
            // Set the header of the locked transactions
            m_pShare->faTransactLockHead = pTransaction->faBlock;
        }

        // Otherwise, append to tail
        else
        {
            // Get the Transaction Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, m_pShare->faTransactLockTail, (LPVOID *)&pTail));

            // Link Into the Transaction List
            pTail->faNextInBatch = pTransaction->faBlock;
        }

        // Set the Tail
        m_pShare->faTransactLockTail = pTransaction->faBlock;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustOpenRowsets
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustOpenRowsets(INDEXORDINAL iIndex,
    ROWORDINAL iRow, OPERATIONTYPE tyOperation)
{
    // Locals
    LPROWSETINFO    pRowset;
    DWORD           j;

    // Trace
    TraceCall("CDatabase::_AdjustOpenRowsets");

    // Invalid Args
    Assert(OPERATION_DELETE == tyOperation || OPERATION_INSERT == tyOperation);

    // Update open rowsets
    for (j=0; j<m_pShare->Rowsets.cUsed; j++)
    {
        // Set iRowset
        pRowset = &m_pShare->Rowsets.rgRowset[m_pShare->Rowsets.rgiUsed[j]];

        // Does this rowset reference this index ?
        if (pRowset->iIndex == iIndex)
        {
            // How does the newly insert/deleted record affect the current position of this rowset ?
            if (iRow <= pRowset->iRow)
            {
                // lAdjust is negative
                if (OPERATION_DELETE == tyOperation && pRowset->iRow > 1)
                    pRowset->iRow--;

                // Otherwise, Increment iRow so that we don't duplicate rows...
                else
                    pRowset->iRow += 1;
            }
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::InsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::InsertRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faRecord;
    RECORDMAP       RecordMap;
    DWORD           i;
    DWORD           cNotify=0;
    INDEXORDINAL    iIndex;
    HLOCK           hLock=NULL;
    FINDRESULT      rgResult[CMAX_INDEXES];
    ORDINALLIST     Ordinals;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::InsertRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Watch for Maximum Unique Id ?
    if (0xFFFFFFFF != m_pSchema->ofUniqueId)
    {
        // Get Id
        DWORD dwId = *((DWORD *)((LPBYTE)pBinding + m_pSchema->ofUniqueId));

        // Reset dwNextId if dwId isn't in the invalid range
        if (0 != dwId && dwId > m_pHeader->dwNextId && dwId < RESERVED_ID_MIN)
            m_pHeader->dwNextId = dwId;
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Insert
        m_pExtension->OnRecordInsert(OPERATION_BEFORE, NULL, pBinding);
    }

    // Loop through all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex], &rgResult[i].nCompare));

        // If key already exist, cache list and return
        if (DB_S_FOUND == hr)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }
    }

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Link Record Into the Table
    IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, 0, &faRecord));

    // Version Change
    m_pShare->dwVersion++;

    // Insert into the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Visible in live index
        if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
        {
            // Do the Insertion
            IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faRecord, &rgResult[i].iNode, rgResult[i].nCompare));

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]++;

            // Adjust iRow
            Ordinals.rgiRecord1[iIndex] += (rgResult[i].iNode + 1);

            // AdjustOpenRowsets
            _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_INSERT);

            // Notification Required ?
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }

        // Otherwise, adjust the ordinal to indicate that its not in the index
        else
        {
            // Can't be primary
            Assert(IINDEX_PRIMARY != iIndex);

            // Ordinals.rgiRecord1[iIndex]
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;
        }
    }

    // Set the Version
    *((DWORD *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = 1;

    // Build the Notification Package
    if (cNotify > 0)
    {
        // Build the Package
        _LogTransaction(TRANSACTION_INSERT, INVALID_INDEX_ORDINAL, &Ordinals, faRecord, 0);
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Insert
        m_pExtension->OnRecordInsert(OPERATION_AFTER, &Ordinals, pBinding);
    }

exit:
    // Finish the Operation
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IndexInsertRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_IndexInsertRecord(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, FILEADDRESS faRecord, LPNODEINDEX piNode,
    INT nCompare)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAINNODE       Node={0};
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_IndexInsertRecord");

    // Invalid Args
    Assert(faRecord > 0);
    Assert(nCompare > 0 || nCompare < 0);

    // If we have a root chain, find a place to insert the new record, or see if the record already exists
    if (0 == m_pHeader->rgfaIndex[iIndex])
    {
        // We should not write into 0
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pChain));

        // zero out the block
        ZeroBlock(pChain, sizeof(CHAINBLOCK));

        // Set faStart
        m_pHeader->rgfaIndex[iIndex] = pChain->faBlock;

        // Number of nodes in the chain
        pChain->cNodes = 1;

        // Setup the first node
        pChain->rgNode[0].faRecord = faRecord;

        // Validate piNode
        IxpAssert(*piNode == 0);

        // Return piNode
        *piNode = 0;
    }

    // Otherwise
    else
    {
        // De-ref
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Initialize Node
        Node.faRecord = faRecord;

        // This is very a special increment and has to do with the way a BinarySearch can
        // determine the correct insertion point for a node that did not exist in the 
        // array in which a binary search was performed on.
        if (nCompare > 0)
            (*piNode)++;

        // Expand the Chain
        IF_FAILEXIT(hr = _ExpandChain(pChain, (*piNode)));

        // Copy the Node
        CopyMemory(&pChain->rgNode[(*piNode)], &Node, sizeof(CHAINNODE));

        // If Node is FULL, we must do a split insert
        if (pChain->cNodes > BTREE_ORDER)
        {
            // Split the chain
            IF_FAILEXIT(hr = _SplitChainInsert(iIndex, faChain));
        }

        // Mark Chain as dirty, cause we are about to cache it away
        else
        {
            // Increment Parent Record Count
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faChain, 1));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DeleteRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    FILEADDRESS     faRecord=0;
    LPVOID          pBindingOld=NULL;
    DWORD           cNotify=0;
    FINDRESULT      rgResult[CMAX_INDEXES];
    ORDINALLIST     Ordinals;
    DWORD           i;
    INDEXORDINAL    iIndex;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::DeleteRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Otherwise: Decide Where to insert
    IF_FAILEXIT(hr = _FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pBinding, &rgResult[0].faChain, &rgResult[0].iNode, &Ordinals.rgiRecord1[IINDEX_PRIMARY]));

    // If not found, you can't update it. Use Insert
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Primary Index Can not change
    rgResult[0].fFound = TRUE;

    // Cast pChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[0].faChain, (LPVOID *)&pChain));

    // Set faRecord
    faRecord = pChain->rgNode[rgResult[0].iNode].faRecord;

    // If this was the first index and there are more indexes, then read the origina record so that indexes are updated correctly
    if (m_pHeader->cIndexes > 1 || m_pExtension)
    {
        // Allocate a Record
        IF_NULLEXIT(pBindingOld = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Read the Record
        IF_FAILEXIT(hr = _ReadRecord(faRecord, pBindingOld));
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Delete
        m_pExtension->OnRecordDelete(OPERATION_BEFORE, NULL, pBindingOld);
    }

    // Loop through the indexes
    for (i=1; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBindingOld, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex]));

        // The, record wasn't found, there must be a filter on the index
        if (DB_S_NOTFOUND == hr)
        {
            // Not found
            rgResult[i].fFound = FALSE;

            // Invalid Ordinal
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;
        }

        // Otherwise
        else
        {
            // Found
            rgResult[i].fFound = TRUE;

            // Get the Chain
            Assert(SUCCEEDED(_GetBlock(BLOCK_CHAIN, rgResult[i].faChain, (LPVOID *)&pChain)));

            // Validation
            Assert(faRecord == pChain->rgNode[rgResult[i].iNode].faRecord);
        }
    }

    // Loop through the indexes
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Found ?
        if (rgResult[i].fFound)
        {
            // Lets remove the link from the index first
            IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, rgResult[i].faChain, rgResult[i].iNode));

            // Validate Record Count
            Assert(m_pHeader->rgcRecords[iIndex] > 0);

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]--;

            // AdjustOpenRowsets
            _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_DELETE);

            // Does somebody want a notification about this index ?
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }
    }

    // Notify Somebody ?
    if (cNotify > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_DELETE, INVALID_INDEX_ORDINAL, &Ordinals, faRecord, 0);
    }

    // Otherwise, free the record
    else
    {
        // De-allocate the record from the file
        IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, faRecord));
    }

    // Version Change
    m_pShare->dwVersion++;

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Delete
        m_pExtension->OnRecordDelete(OPERATION_AFTER, &Ordinals, pBindingOld);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBindingOld);

    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::FindRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::FindRecord(INDEXORDINAL iIndex, DWORD cColumns,
    LPVOID pBinding, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    LPCHAINBLOCK    pChain;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::FindRecord");

    // Invalid Args
    Assert(pBinding);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find the Record
    IF_FAILEXIT(hr = _FindRecord(iIndex, cColumns, pBinding, &faChain, &iNode, piRow));

    // If Found, Copy the record
    if (DB_S_FOUND == hr)
    {
        // Get the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Open the Record into pBinding
        IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[iNode].faRecord, pBinding));

        // Found It
        hr = DB_S_FOUND;

        // Done
        goto exit;
    }

    // Not Found
    hr = DB_S_NOTFOUND;

exit:
    // Unlock the index
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetChainByIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetChainByIndex(INDEXORDINAL iIndex, ROWORDINAL iRow,
    LPFILEADDRESS pfaChain, LPNODEINDEX piNode)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    LPCHAINBLOCK    pChain;
    DWORD           cLeftNodes=0;
    NODEINDEX       i;

    // Trace
    TraceCall("CDatabase::_GetChainByIndex");

    // Invalid Args
    Assert(pfaChain && piNode);

    // Initialize
    faChain = m_pHeader->rgfaIndex[iIndex];

    // Loop
    while (faChain)
    {
        // Corrupt
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Are there left nodes ?
        if (pChain->cLeftNodes > 0 && iRow <= (cLeftNodes + pChain->cLeftNodes))
        {
            // Goto the left
            faChain = pChain->faLeftChain;
        }

        // Otherwise...
        else
        {
            // Increment cLeftNodes
            cLeftNodes += pChain->cLeftNodes;

            // Loop throug right chains
            for (i=0; i<pChain->cNodes; i++)
            {
                // Failure
                if (cLeftNodes + 1 == iRow)
                {
                    // We found the Chain
                    *pfaChain = faChain;

                    // Return the Node Index
                    *piNode = i;

                    // Done
                    goto exit;
                }

                // Increment cLeftNodes
                cLeftNodes++;

                // Goto the Right ?
                if (iRow <= (cLeftNodes + pChain->rgNode[i].cRightNodes))
                {
                    // Goto the Right
                    faChain = pChain->rgNode[i].faRightChain;

                    // Break
                    break;
                }

                // First Node ?
                cLeftNodes += pChain->rgNode[i].cRightNodes;
            }

            // Nothing found...
            if (i == pChain->cNodes)
                break;
        }
    }

    // Not Found
    hr = E_FAIL;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CreateRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CreateRowset(INDEXORDINAL iIndex,
    CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWSETORDINAL   iRowset;
    LPROWSETTABLE   pTable;
    LPROWSETINFO    pRowset;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::CreateRowset");

    // Invalid Args
    Assert(iIndex < CMAX_INDEXES && phRowset);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // De-Ref the RowsetTable
    pTable = &m_pShare->Rowsets;

    // Init Rowset Table
    if (FALSE == pTable->fInitialized)
    {
        // Init the rgiFree Array
        for (iRowset=0; iRowset<CMAX_OPEN_ROWSETS; iRowset++)
        {
            // set rgiFree
            pTable->rgiFree[iRowset] = iRowset;

            // Set rgRowset
            pTable->rgRowset[iRowset].iRowset = iRowset;
        }

        // Set cFree
        pTable->cFree = CMAX_OPEN_ROWSETS;

        // Initialized
        pTable->fInitialized = TRUE;
    }

    // No free Rowsets ?
    if (0 == pTable->cFree)
    {
        hr = TraceResult(DB_E_TOOMANYOPENROWSETS);
        goto exit;
    }

    // Get a Free Rowset...
    iRowset = pTable->rgiFree[pTable->cFree - 1];

    // Set phRowset (Need to Add one so that I don't return a NULL
    *phRowset = (HROWSET)IntToPtr(iRowset + 1);

    // Set pRowset...
    pRowset = &pTable->rgRowset[iRowset];

    // Validate iRowset
    Assert(pRowset->iRowset == iRowset);

    // Zero the Roset
    ZeroMemory(pRowset, sizeof(ROWSETINFO));

    // Set iRowset
    pRowset->iRowset = iRowset;

    // set iRow
    pRowset->iRow = 1;

    // Set Index
    pRowset->iIndex = iIndex;

    // Remove iRowset from rgiFree
    pTable->cFree--;

    // Put iRowset into rgiUsed
    pTable->rgiUsed[pTable->cUsed] = iRowset;

    // Increment cUsed
    pTable->cUsed++;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CloseRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CloseRowset(LPHROWSET phRowset)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            i;
    LPROWSETTABLE   pTable;
    HLOCK           hLock=NULL;
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(*phRowset) - 1);
    LPROWSETINFO    pRowset;

    // Nothing ?
    if (NULL == *phRowset)
        return(S_OK);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // De-Ref the RowsetTable
    pTable = &m_pShare->Rowsets;

    // Search rgiUsed
    for (i=0; i<pTable->cUsed; i++)
    {
        // Is this It ?
        if (pTable->rgiUsed[i] == pRowset->iRowset)
        {
            // Remove this Rowset
            MoveMemory(&pTable->rgiUsed[i], &pTable->rgiUsed[i + 1], sizeof(ROWSETORDINAL) * (pTable->cUsed - (i + 1)));

            // Decrement cUsed
            pTable->cUsed--;

            // Put iRowset into the free list
            pTable->rgiFree[pTable->cFree] = pRowset->iRowset;

            // Increment cFree
            pTable->cFree++;

            // Done
            break;
        }
    }

    // Don't Free Again
    *phRowset = NULL;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetRowOrdinal
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetRowOrdinal(INDEXORDINAL iIndex, 
    LPVOID pBinding, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetRowOrdinal");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Arg
    Assert(pBinding && piRow && iIndex < CMAX_INDEXES);

    // Simply do a find record...
    IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, piRow));

    // No Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

exit:
    // Process / Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SeekRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, 
    LONG cRows, LPROWORDINAL piRowNew)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    ROWORDINAL      iRowNew;
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(hRowset) - 1);
    LPROWSETINFO    pRowset;

    // Trace
    TraceCall("CDatabase::SeekRowset");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // If there are no records, then seek operation is meaningless
    if (0 == m_pHeader->rgcRecords[pRowset->iIndex])
    {
        hr = DB_E_NORECORDS;
        goto exit;
    }

    // Seek From Beginning
    if (SEEK_ROWSET_BEGIN == tySeek)
    {
        // Set iRow (and remember 0th row from beginning is row #1)
        iRowNew = (cRows + 1);
    }

    // Seek From Current Position
    else if (SEEK_ROWSET_CURRENT == tySeek)
    {
        // Adjust iRow
        iRowNew = (pRowset->iRow + cRows);
    }

    // SEEK_ROWSET_END
    else if (SEEK_ROWSET_END == tySeek)
    {
        // Adjust iRow
        iRowNew = m_pHeader->rgcRecords[pRowset->iIndex] + cRows;
    }

    // Error
    if (iRowNew > m_pHeader->rgcRecords[pRowset->iIndex] || iRowNew <= 0)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Set New iRow
    pRowset->iRow = iRowNew;

    // Return piRowNew ?
    if (piRowNew)
        *piRowNew = pRowset->iRow;

exit:
    // Process / Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::QueryRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::QueryRowset(HROWSET hRowset, LONG lWanted,
    LPVOID *prgpRecord, LPDWORD pcObtained)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cRead=0;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    LPCHAINBLOCK    pChain;
    DWORD           cWanted=abs(lWanted);
    HLOCK           hLock=NULL;
    LONG            lDirection=(lWanted < 0 ? -1 : 1);
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(hRowset) - 1);
    LPROWSETINFO    pRowset;

    // Trace
    TraceCall("CDatabase::GetRows");

    // Invalid Args
    Assert(prgpRecord && hRowset);

    // Initialize
    if (pcObtained)
        *pcObtained = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // Invalid ?
    if (0 == pRowset->iRow || pRowset->iRow > m_pHeader->rgcRecords[pRowset->iIndex])
    {
        hr = S_FALSE;
        goto exit;
    }

    // While we have a record address
    while (cRead < cWanted)
    {
        // Get the chain from the index
        if (FAILED(_GetChainByIndex(pRowset->iIndex, pRowset->iRow, &faChain, &iNode)))
        {
            // Done
            pRowset->iRow = 0xffffffff;

            // Done
            break;
        }

        // De-reference the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Open the Record into pBinding
        IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[iNode].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

        // Increment cRead
        cRead++;

        // Validate
        Assert(pRowset->iRow > 0 && pRowset->iRow <= m_pHeader->rgcRecords[pRowset->iIndex]);

        // Increment Index
        pRowset->iRow += lDirection;

        // If this is a child chain, I can walk all the nodes
        if (0 == pChain->faLeftChain)
        {
            // Better not have any left nodes
            Assert(0 == pChain->cLeftNodes);

            // Forward ?
            if (lDirection > 0)
            {
                // Loop 
                for (NODEINDEX i=iNode + 1; i<pChain->cNodes && cRead < cWanted; i++)
                {
                    // Better not have a right chain or any right nodes
                    Assert(0 == pChain->rgNode[i].faRightChain && 0 == pChain->rgNode[i].cRightNodes);

                    // Open the Record into pBinding
                    IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[i].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

                    // Increment cRead
                    cRead++;

                    // Increment Index
                    pRowset->iRow += 1;
                }
            }

            // Otherwise, backwards
            else
            {
                // Loop 
                for (LONG i=iNode - 1; i>=0 && cRead < cWanted; i--)
                {
                    // Better not have a right chain or any right nodes
                    Assert(0 == pChain->rgNode[i].faRightChain && 0 == pChain->rgNode[i].cRightNodes);

                    // Open the Record into pBinding
                    IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[i].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

                    // Increment cRead
                    cRead++;

                    // Increment Index
                    pRowset->iRow -= 1;
                }
            }
        }
    }

    // Set pcbObtained
    if (pcObtained)
        *pcObtained = cRead;

    // Set hr
    hr = (cRead > 0) ? S_OK : S_FALSE;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::FreeRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::FreeRecord(LPVOID pBinding)
{
    // Locals
    LPVOID      pFree;

    // Trace
    TraceCall("CDatabase::FreeRecord");

    // Invalid Args
    Assert(pBinding);

    // Get the pointer to free
    pFree = *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory));

    // Not NULL
    if (pFree)
    {
        // Don't Free again
        *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory)) = NULL;

        // Free This
        HeapFree(pFree);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRecordSize
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRecordSize(LPVOID pBinding, LPRECORDMAP pMap)
{
    // Locals
    DWORD           i;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_GetRecordSize");

    // Invalid Args
    Assert(pBinding && pMap);

    // Initialize
    ZeroMemory(pMap, sizeof(RECORDMAP));

    // Walk through the members in the structure
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[i];

        // Is Data Set ?
        if (FALSE == DBTypeIsDefault(pColumn, pBinding))
        {
            // Compute Amount of Data to Store
            pMap->cbData += DBTypeGetSize(pColumn, pBinding);

            // Count Tags
            pMap->cTags++;
            
            // Compute Amount of Tags to Store
            pMap->cbTags += sizeof(COLUMNTAG);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_SaveRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_SaveRecord(LPRECORDBLOCK pRecord, LPRECORDMAP pMap,
    LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    DWORD           cbOffset=0;
    DWORD           cTags=0;
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;

    // Trace
    TraceCall("CDatabase::_SaveRecord");

    // Invalid Args
    Assert(pRecord && pRecord->faBlock > 0 && pBinding);

    // Better have enough space
    Assert(pMap->cbData + pMap->cbTags <= pRecord->cbSize && pMap->cbTags == (pMap->cTags * sizeof(COLUMNTAG)));

    // Set prgTag
    pMap->prgTag = (LPCOLUMNTAG)((LPBYTE)pRecord + sizeof(RECORDBLOCK));

    // Set pbData
    pMap->pbData = (LPBYTE)((LPBYTE)pRecord + sizeof(RECORDBLOCK) + pMap->cbTags);

    // Walk through the members in the structure
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[i];

        // Is Data Set ?
        if (FALSE == DBTypeIsDefault(pColumn, pBinding))
        {
            // Compute Hash
            pTag = &pMap->prgTag[cTags];

            // Set Tag Id
            pTag->iColumn = pColumn->iOrdinal;

            // Assume pTag Doesn't Contain Data
            pTag->fData = 0;

            // Store the Offset
            pTag->Offset = cbOffset;

            // WriteBindTypeData
            cbOffset += DBTypeWriteValue(pColumn, pBinding, pTag, pMap->pbData + cbOffset);

            // Count Tags
            cTags++;

            // Validate
            Assert(cbOffset <= pMap->cbData);

            // Done ?
            if (cTags == pMap->cTags)
            {
                // Should have Wrote Everything
                Assert(cbOffset == pMap->cbData);

                // Done
                break;
            }
        }
    }

    // Increment Record Version
    pRecord->bVersion++;

    // Write the number of columns
    pRecord->cTags = pMap->cTags;

    // Validate
    Assert(cTags == pMap->cTags && pRecord->cTags > 0);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ReadRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_ReadRecord(FILEADDRESS faRecord, LPVOID pBinding,
    BOOL fInternal /* = FALSE */)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbData=NULL;
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;
    WORD            iTag;
    RECORDMAP       Map;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::_ReadRecord");

    // Invalid Args
    Assert(faRecord > 0 && pBinding);

    // Zero pBinding
    ZeroMemory(pBinding, m_pSchema->cbBinding);

    // Bad Chain Node
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecord));

    // Get Record Map
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pRecord, &Map));

    // Not Internal
    if (FALSE == fInternal)
    {
        // Allocate a record
        IF_NULLEXIT(pbData = (LPBYTE)PHeapAllocate(0, Map.cbData));

        // Just read the Record
        CopyMemory(pbData, Map.pbData, Map.cbData);

        // Copy Data From pbData...
        Map.pbData = pbData;
    }

    // Walk through the Tags of the Record
    for (iTag=0; iTag<Map.cTags; iTag++)
    {
        // Readability
        pTag = &Map.prgTag[iTag];

        // Validate the Tag
        if (pTag->iColumn < m_pSchema->cColumns)
        {
            // De-ref the Column
            pColumn = &m_pSchema->prgColumn[pTag->iColumn];

            // Read the Data
            DBTypeReadValue(pColumn, pTag, &Map, pBinding);
        }
    }

    // Store the version of the record into the binding
    *((BYTE *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = pRecord->bVersion;

    // Store a point to the blob and free it later
    *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory)) = (LPVOID)pbData;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::BindRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::BindRecord(LPRECORDMAP pMap, LPVOID pBinding)
{
    // Locals
    WORD            iTag;
    LPCOLUMNTAG     pTag;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::BindRecord");

    // Zero Out the Binding
    ZeroMemory(pBinding, m_pSchema->cbBinding);

    // Walk through the Tags of the Record
    for (iTag=0; iTag<pMap->cTags; iTag++)
    {
        // Readability
        pTag = &pMap->prgTag[iTag];

        // Validate the Tag
        Assert(pTag->iColumn < m_pSchema->cColumns);

        // De-ref the Column
        pColumn = &m_pSchema->prgColumn[pTag->iColumn];

        // Read the Data
        DBTypeReadValue(pColumn, pTag, pMap, pBinding);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_IsVisible (S_OK = Show, S_FALSE = Hide)
//--------------------------------------------------------------------------
HRESULT CDatabase::_IsVisible(HQUERY hQuery, LPVOID pBinding)
{
    // Trace
    TraceCall("CDatabase::_IsVisible");

    // No hQuery, the record must be visible
    if (NULL == hQuery)
        return(S_OK);

    // Evaluate the Query
    return(EvaluateQuery(hQuery, pBinding, m_pSchema, this, m_pExtension));
}

//--------------------------------------------------------------------------
// CDatabase::_CompareBinding
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompareBinding(INDEXORDINAL iIndex, DWORD cColumns, 
    LPVOID pBinding, FILEADDRESS faRecord, INT *pnCompare)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cKeys;
    LPRECORDBLOCK   pBlock;
    RECORDMAP       Map;
    LPCOLUMNTAG     pTag;
    DWORD           iKey;
    LPTABLEINDEX    pIndex;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_CompareBinding");

    // Initialize
    *pnCompare = 1;

    // Get the Right Record Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pBlock));

    // Get the Right Node Data
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &Map));

    // De-Ref the Index
    pIndex = &m_pHeader->rgIndexInfo[iIndex];

    // Compute Number of keys to match (possible partial index search)
    cKeys = min(cColumns, pIndex->cKeys);

    // Loop through the key members
    for (iKey=0; iKey<cKeys; iKey++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[pIndex->rgKey[iKey].iColumn];

        // Get Tag From Column Ordinal
        pTag = PTagFromOrdinal(&Map, pColumn->iOrdinal);

        // Compare Types
        *pnCompare = DBTypeCompareBinding(pColumn, &pIndex->rgKey[iKey], pBinding, pTag, &Map);

        // Done
        if (0 != *pnCompare)
            break;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_PartialIndexCompare
//--------------------------------------------------------------------------
HRESULT CDatabase::_PartialIndexCompare(INDEXORDINAL iIndex, DWORD cColumns, 
    LPVOID pBinding, LPCHAINBLOCK *ppChain, LPNODEINDEX piNode, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWORDINAL      iRow=(piRow ? *piRow : 0xffffffff);
    LONG            iNode=(*piNode);
    LPCHAINBLOCK    pChain=(*ppChain);
    FILEADDRESS     faChain;
    INT             nCompare=0;
    BYTE            fFirstLoop;

    // Trace
    TraceCall("CDatabase::_PartialIndexCompare");

    // Invalid Args
    Assert(pBinding && pChain && piNode && *piNode < pChain->cNodes);

    // Loop
    while (1)
    {
        // Assume no more chains
        faChain = 0;

        // First Loop
        fFirstLoop = TRUE;

        // Loop through Current
        while (1)
        {
            // Validate iNode
            Assert(iNode >= 0 && iNode < BTREE_ORDER);

            // Only do this on every iteration except the first
            if (FALSE == fFirstLoop)
            {
                // Decrement iRow
                iRow -= pChain->rgNode[iNode].cRightNodes;
            }

            // Compare with first node in this chain
            IF_FAILEXIT(hr = _CompareBinding(iIndex, cColumns, pBinding, pChain->rgNode[iNode].faRecord, &nCompare));

            // Validate nCompare
            Assert(0 == nCompare || nCompare > 0);

            // pBinding == Node
            if (0 == nCompare)
            {
                // Set new Found iNode
                *piNode = (NODEINDEX)iNode;

                // Set pFound
                *ppChain = pChain;

                // Update piRow
                if (piRow)
                {
                    // Update piRow
                    (*piRow) = iRow;
                }

                // Should we goto the left ?
                if (0 == iNode)
                {
                    // Set faNextChain
                    faChain = pChain->faLeftChain;

                    // Updating piRow
                    if (piRow)
                    {
                        // Decrement iRow
                        iRow -= pChain->cLeftNodes;

                        // Decrement One More ?
                        iRow--;
                    }

                    // Done
                    break;
                }
            }

            // If pBinding > Node
            else if (nCompare > 0)
            {
                // Set faNextChain
                faChain = pChain->rgNode[iNode].faRightChain;

                // Done
                break;
            }

            // Decrement iNode
            iNode--;

            // Decrement iRow
            iRow--;

            // No Longer the First Loop
            fFirstLoop = FALSE;
        }

        // Done
        if (0 == faChain)
            break;

        // Get the Current Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Reset iNode
        iNode = pChain->cNodes - 1;

        // Update piRow
        if (piRow)
        {
            // Increment piRow with cLeftNodes
            iRow += pChain->cLeftNodes;

            // Include this node
            iRow++;

            // Loop
            for (NODEINDEX i = 1; i <= pChain->cNodes - 1; i++)
            {
                // Increment with cRightNodes
                iRow += pChain->rgNode[i - 1].cRightNodes;

                // Include this node
                iRow++;
            }
        }
    }

#ifdef DEBUG
#ifdef PARTIAL_COMPARE_VALIDATE
    if (piRow)
    {
        ROWORDINAL iOrdinal;
        LPVOID pTmpBind = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding);
        IxpAssert(pTmpBind);
        IxpAssert(SUCCEEDED(_ReadRecord((*ppChain)->rgNode[(*piNode)].faRecord, pTmpBind)));
        IxpAssert(SUCCEEDED(GetRowOrdinal(iIndex, pTmpBind, &iOrdinal)));
        IxpAssert(*piRow == iOrdinal);
        SafeFreeBinding(pTmpBind);
        IxpAssert(SUCCEEDED(_CompareBinding(iIndex, cColumns, pBinding, &(*ppChain)->rgNode[(*piNode)], &nCompare)));
        IxpAssert(0 == nCompare);
    }
#endif
#endif

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FindRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindRecord(INDEXORDINAL iIndex, DWORD cColumns,
    LPVOID pBinding, LPFILEADDRESS pfaChain, LPNODEINDEX piNode, 
    LPROWORDINAL piRow /*=NULL*/, INT *pnCompare /*=NULL*/)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lLower;
    LONG            lUpper;
    LONG            lMiddle=0;
    LONG            lLastMiddle;
    INT             nCompare=-1;
    DWORD           iKey;
    BOOL            fPartial;
    LPCHAINBLOCK    pChain;
    FILEADDRESS     faChain;

    // Trace
    TraceCall("CDatabase::_FindRecord");

    // Invalid Args
    Assert(pBinding && pfaChain && piNode && iIndex < CMAX_INDEXES);

    // Partial Index Search ?
    fPartial = (COLUMNS_ALL == cColumns || cColumns == m_pHeader->rgIndexInfo[iIndex].cKeys) ? FALSE : TRUE;

    // Initialize
    *pfaChain = 0;
    *piNode = 0;

    // Start chain address
    faChain = m_pHeader->rgfaIndex[iIndex];

    // Row Ordinal
    if (piRow)
        *piRow = 0;

    // Loop
    while (faChain)
    {
        // Get the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Set *pfaChain
        *pfaChain = pChain->faBlock;

        // Compute initial upper and lower bounds
        lLower = 0;
        lUpper = pChain->cNodes - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (BYTE)((lLower + lUpper) / 2);

            // Do the Comparison
            IF_FAILEXIT(hr = _CompareBinding(iIndex, cColumns, pBinding, pChain->rgNode[lMiddle].faRecord, &nCompare));

            // Partial Index Searching
            if (0 == nCompare)
            {
                // Validate
                Assert(lMiddle >= 0 && lMiddle <= BTREE_ORDER);

                // Set the found node
                *piNode = (BYTE)lMiddle;

                // Return *pnCompare
                if (pnCompare)
                    *pnCompare = 0;

                // Compute piRow
                if (piRow)
                {
                    // Increment piRow with cLeftNodes
                    (*piRow) += pChain->cLeftNodes;

                    // Include this node
                    (*piRow)++;

                    // Loop
                    for (NODEINDEX iNode=1; iNode<=lMiddle; iNode++)
                    {
                        // Increment with cRightNodes
                        (*piRow) += pChain->rgNode[iNode - 1].cRightNodes;

                        // Include this node
                        (*piRow)++;
                    }
                }

                // Partial Search
                if (fPartial)
                {
                    // Handle Partial Search
                    IF_FAILEXIT(hr = _PartialIndexCompare(iIndex, cColumns, pBinding, &pChain, piNode, piRow));

                    // Set *pfaChain
                    *pfaChain = pChain->faBlock;
                }

                // We found it
                hr = DB_S_FOUND;

                // Done
                goto exit;
            }

            // Save last middle position
            lLastMiddle = lMiddle;

            // Compute upper and lower
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else
                lUpper = lMiddle - 1;
        }

        // No match was found, is lpSearchKey less than last middle ?
        if (nCompare < 0 && 0 == lLastMiddle)
        {
            // Goto the left, there is no need to update piRow
            faChain = pChain->faLeftChain;
        }

        // Otherwise
        else
        {
            // If nCompare is less than zero, then...
            if (nCompare < 0)
                lLastMiddle--;

            // Compute piRow
            if (piRow && pChain->rgNode[lLastMiddle].faRightChain)
            {
                // Increment piRow with cLeftNodes
                (*piRow) += pChain->cLeftNodes;

                // Include this node
                (*piRow)++;

                // Loop
                for (NODEINDEX iNode=1; iNode<=lLastMiddle; iNode++)
                {
                    // Increment with cRightNodes
                    (*piRow) += pChain->rgNode[iNode - 1].cRightNodes;

                    // Include this node
                    (*piRow)++;
                }
            }

            // Goto the Right
            faChain = pChain->rgNode[lLastMiddle].faRightChain;
        }
    }

    // Set piNode
    *piNode = (NODEINDEX)lMiddle;

    // Return *pnCompare
    if (pnCompare)
        *pnCompare = nCompare;

    // We didn't find it
    hr = DB_S_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ExpandChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_ExpandChain(LPCHAINBLOCK pChain, NODEINDEX iNodeBase)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            iNode;
    LPCHAINBLOCK    pRightChain;

    // Trace
    TraceCall("CDatabase::_ExpandChain");

    // Invalid Args
    Assert(pChain && pChain->cNodes > 0 && pChain->cNodes < BTREE_ORDER + 1);
    Assert(iNodeBase <= pChain->cNodes);

    // Loop from iNode to cNodes
    for (iNode = pChain->cNodes - 1; iNode >= iNodeBase; iNode--)
    {
        // Propagate this node up one level
        CopyMemory(&pChain->rgNode[iNode + 1], &pChain->rgNode[iNode], sizeof(CHAINNODE));

        // If there is a right chain
        if (pChain->rgNode[iNode].faRightChain)
        {
            // Get the Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->rgNode[iNode].faRightChain, (LPVOID *)&pRightChain));

            // Validate the current Parent
            Assert(pRightChain->faParent == pChain->faBlock);

            // Validate the current index
            Assert(pRightChain->iParent == iNode);

            // Reset the Parent
            pRightChain->iParent = iNode + 1;
        }
    }

    // Increment Node Count
    pChain->cNodes++;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ChainInsert
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainInsert(INDEXORDINAL iIndex, LPCHAINBLOCK pChain, 
    LPCHAINNODE pNodeLeft, LPNODEINDEX piNodeIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            iNode;
    DWORD           iKey;
    INT             nCompare;
    LPRECORDBLOCK   pBlock;
    LPCHAINNODE     pNodeRight;
    LPCOLUMNTAG     pTagLeft;
    LPCOLUMNTAG     pTagRight;
    RECORDMAP       MapLeft;
    RECORDMAP       MapRight;
    LPTABLEINDEX    pIndex;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_ChainInsert");

    // Invalid Args
    Assert(pChain && pNodeLeft && pChain->cNodes > 0);

    // Get the Record Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pNodeLeft->faRecord, (LPVOID *)&pBlock));

    // Get the Record Map
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &MapLeft));

    // De-Reference the Index
    pIndex = &m_pHeader->rgIndexInfo[iIndex];

    // Insert into chain
    for (iNode = pChain->cNodes - 1; iNode >= 0; iNode--)
    {
        // Set pNodeRight
        pNodeRight = &pChain->rgNode[iNode];

        // Get the Record Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pNodeRight->faRecord, (LPVOID *)&pBlock));

        // Get the Left Node
        IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &MapRight));

        // Loop through the key members
        for (iKey=0; iKey<pIndex->cKeys; iKey++)
        {
            // Readability
            pColumn = &m_pSchema->prgColumn[pIndex->rgKey[iKey].iColumn];

            // Get Left Tag
            pTagLeft = PTagFromOrdinal(&MapLeft, pColumn->iOrdinal);

            // Get the Right Tag
            pTagRight = PTagFromOrdinal(&MapRight, pColumn->iOrdinal);

            // Compare Types
            nCompare = DBTypeCompareRecords(pColumn, &pIndex->rgKey[iKey], pTagLeft, pTagRight, &MapLeft, &MapRight);

            // Done
            if (0 != nCompare)
                break;
        }

        // Insert in this node ?
        if (nCompare >= 0)
            break;
    }

    // Expand the Chain
    IF_FAILEXIT(hr = _ExpandChain(pChain, iNode + 1));

    // Final Insert
    CopyMemory(&pChain->rgNode[iNode + 1], pNodeLeft, sizeof(CHAINNODE));

    // Node
    *piNodeIndex = iNode + 1;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SplitChainInsert
//--------------------------------------------------------------------------
HRESULT CDatabase::_SplitChainInsert(INDEXORDINAL iIndex, FILEADDRESS faSplit)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    NODEINDEX       iNode;
    CHAINBLOCK      Split;
    DWORD           cLeftNodes;
    DWORD           cRightNodes;
    FILEADDRESS     faChain;
    FILEADDRESS     faLeftChain;
    FILEADDRESS     faRightChain;
    LPCHAINBLOCK    pLeft;
    LPCHAINBLOCK    pRight;
    LPCHAINBLOCK    pParent;
    LPCHAINBLOCK    pSplit;

    // Trace
    TraceCall("CDatabase::_SplitChainInsert");

    // Allocate Space for this chain
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pLeft));

    // Set faLeftChain
    faLeftChain = pLeft->faBlock;

    // Zero Allocate
    ZeroBlock(pLeft, sizeof(CHAINBLOCK));

    // Get Split Chain Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faSplit, (LPVOID *)&pSplit));

    // Deref the Chain
    CopyMemory(&Split, pSplit, sizeof(CHAINBLOCK));

    // Set faRigthChain
    faRightChain = faSplit;

    // Get Right Chain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

    // Zero pRight
    ZeroBlock(pRight, sizeof(CHAINBLOCK));

    // Both new child chains will be half filled
    pLeft->cNodes = pRight->cNodes = BTREE_MIN_CAP;

    // Set the Right Chains, left pointer to the middle's right pointer
    pRight->faLeftChain = Split.rgNode[BTREE_MIN_CAP].faRightChain;

    // Adjust faRightChains Parent
    if (pRight->faLeftChain)
    {
        // Locals
        LPCHAINBLOCK pLeftChain;

        // Get Left Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pRight->faLeftChain, (LPVOID *)&pLeftChain));

        // Validate the Current Parent
        Assert(pLeftChain->faParent == pRight->faBlock);

        // Validate the index
        Assert(pLeftChain->iParent == BTREE_MIN_CAP);

        // Reset the Parent Index
        pLeftChain->iParent = 0;
    }

    // Set Left Node Count
    pRight->cLeftNodes = Split.rgNode[BTREE_MIN_CAP].cRightNodes;

    // Set the left chains left chain address to the left chain left chain address
    pLeft->faLeftChain = Split.faLeftChain;

    // Adjust Parents
    if (pLeft->faLeftChain)
    {
        // Locals
        LPCHAINBLOCK pLeftChain;

        // Get Left Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pLeft->faLeftChain, (LPVOID *)&pLeftChain));

        // Validate the index
        Assert(pLeftChain->iParent == 0);

        // Reset faParent
        pLeftChain->faParent = pLeft->faBlock;
    }

    // Set Left Nodes
    pLeft->cLeftNodes = Split.cLeftNodes;

    // Initialize cRightNodes
    cRightNodes = (BTREE_MIN_CAP + pRight->cLeftNodes);

    // Initialize cLeftNodes
    cLeftNodes = (BTREE_MIN_CAP + pLeft->cLeftNodes);

    // This splits the chain
    for (i=0; i<BTREE_MIN_CAP; i++)
    {
        // Copy Right Node
        CopyMemory(&pRight->rgNode[i], &Split.rgNode[i + BTREE_MIN_CAP + 1], sizeof(CHAINNODE));

        // Adjust the Child's iParent ?
        if (pRight->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Left Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pRight->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the Current Parent
            Assert(pRightChain->faParent == pRight->faBlock);

            // Validate the index
            Assert(pRightChain->iParent == i + BTREE_MIN_CAP + 1);

            // Reset the Parent
            pRightChain->iParent = i;
        }

        // Count All Child Nodes on the Right
        cRightNodes += pRight->rgNode[i].cRightNodes;

        // Copy Left Node
        CopyMemory(&pLeft->rgNode[i], &Split.rgNode[i], sizeof(CHAINNODE));

        // If there is a right chain
        if (pLeft->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Left Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pLeft->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the Old Parent
            Assert(pRightChain->faParent == Split.faBlock);

            // Validate the index
            Assert(pRightChain->iParent == i);

            // Reset the Parent
            pRightChain->faParent = pLeft->faBlock;
        }

        // Count All Child Nodes on the Left
        cLeftNodes += pLeft->rgNode[i].cRightNodes;
    }

    // Set the middle nodes right chain address to the right chain's start address
    Split.rgNode[BTREE_MIN_CAP].faRightChain = faRightChain;

    // Set Right Nodes
    Split.rgNode[BTREE_MIN_CAP].cRightNodes = cRightNodes;

    // Done with pLeft and pRight
    pLeft = pRight = NULL;

    // Elevate the middle leaf node - Create new root chain, then were done
    if (0 == Split.faParent)
    {
        // Allocate Space for this chain
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pParent));

        // ZeroInit
        ZeroBlock(pParent, sizeof(CHAINBLOCK));

        // Set Node count
        pParent->cNodes = 1;

        // Set Left Chain
        pParent->faLeftChain = faLeftChain;

        // Set Left Node Count
        pParent->cLeftNodes = cLeftNodes;

        // Copy the Root Node
        CopyMemory(&pParent->rgNode[0], &Split.rgNode[BTREE_MIN_CAP], sizeof(CHAINNODE));

        // New Root Chain Address
        m_pHeader->rgfaIndex[iIndex] = pParent->faBlock;

        // Get pLeft
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faLeftChain, (LPVOID *)&pLeft));

        // Get Right
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

        // Set faLeft's faParent
        pRight->faParent = pLeft->faParent = pParent->faBlock;

        // Set faLeft's iParent
        pRight->iParent = pLeft->iParent = 0;
    }

    // Otherwise, locate chainNodeMiddle's parent chain list!
    else
    {
        // De-Reference
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, Split.faParent, (LPVOID *)&pParent));

        // Insert leaf's middle record into the parent
        IF_FAILEXIT(hr = _ChainInsert(iIndex, pParent, &Split.rgNode[BTREE_MIN_CAP], &iNode));

        // Get pLeft
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faLeftChain, (LPVOID *)&pLeft));

        // Get Right
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

        // Set faLeft's faParent
        pRight->faParent = pLeft->faParent = pParent->faBlock;

        // Update Surrounding Nodes
        if (iNode > 0)
        {
            // Set faRight Chain
            pParent->rgNode[iNode - 1].faRightChain = faLeftChain;

            // Set cRightNodes
            pParent->rgNode[iNode - 1].cRightNodes = cLeftNodes;
        
            // Set faLeft's iParent
            pRight->iParent = (BYTE)iNode;
            
            // Set Left Parent
            pLeft->iParent = iNode - 1;
        }

        // iNode is first node
        else if (iNode == 0)
        {
            // Set faLeftChain
            pParent->faLeftChain = faLeftChain;

            // Set cLeftNodes
            pParent->cLeftNodes = cLeftNodes;

            // Set faLeft's iParent
            pRight->iParent = pLeft->iParent = 0;
        }

        // If Node is FULL, we must do a split insert
        if (pParent->cNodes > BTREE_ORDER)
        {
            // Recursive Split
            IF_FAILEXIT(hr = _SplitChainInsert(iIndex, Split.faParent));
        }

        // Other wise, simply write the updated chain list
        else
        {
            // Increment Parent Record Count
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, Split.faParent, 1));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeRecordStorage
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeRecordStorage(OPERATIONTYPE tyOperation,
    FILEADDRESS faRecord)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               i;
    LPVOID              pBinding=NULL;
    LPCTABLECOLUMN      pColumn;

    // Trace
    TraceCall("CDatabase::_FreeRecordStorage");

    // Invalid Args
    Assert(faRecord > 0);

    // Does the record have streams
    if (OPERATION_DELETE == tyOperation && ISFLAGSET(m_pSchema->dwFlags, TSF_HASSTREAMS))
    {
        // Allocate a Record
        IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Load the Record from the file
        IF_FAILEXIT(hr = _ReadRecord(faRecord, pBinding));

        // Walk through the members in the structure
        for (i=0; i<m_pSchema->cColumns; i++)
        {
            // Readability
            pColumn = &m_pSchema->prgColumn[i];

            // Variable Length Member ?
            if (CDT_STREAM == pColumn->type)
            {
                // Get the Starting address of the stream
                FILEADDRESS faStart = *((FILEADDRESS *)((LPBYTE)pBinding + pColumn->ofBinding));

                // Release Stream Storage...
                if (faStart > 0)
                {
                    // Delete the Stream
                    DeleteStream(faStart);
                }
            }
        }
    }

    // Free the base record
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, faRecord));

exit:
    // Cleanup
    SafeFreeBinding(pBinding);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteStream
//--------------------------------------------------------------------------
HRESULT CDatabase::DeleteStream(FILEADDRESS faStart)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    BOOL            fFound=FALSE;

    // Trace
    TraceCall("CDatabase::DeleteStream");

    // See if this stream is currently open any where...
    if (0 == faStart)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Look for faStart in the stream table
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is this it ?
        if (faStart == m_pShare->rgStream[i].faStart)
        {
            // The Stream Must be Open
            Assert(m_pShare->rgStream[i].cOpenCount > 0);

            // Mark the stream for delete on close
            m_pShare->rgStream[i].fDeleteOnClose = TRUE;

            // Not that I found It
            fFound = TRUE;

            // Done
            break;
        }
    }

    // If we didn't find it, then lets free the storage
    if (FALSE == fFound)
    {
        // Free the Stream Storage
        IF_FAILEXIT(hr = _FreeStreamStorage(faStart));
    }

    // Update the Version
    m_pShare->dwVersion++;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_StreamSychronize
//--------------------------------------------------------------------------
HRESULT CDatabase::_StreamSychronize(CDatabaseStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPOPENSTREAM    pInfo;
    LPSTREAMBLOCK   pBlock;
    DWORD           iBlock=0;
    BOOL            fFound=FALSE;
    IF_DEBUG(DWORD  cbOffset=0;)
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_StreamSychronize");

    // Invalid Args
    Assert(pStream);

    // Get Stream Info
    pInfo = &m_pShare->rgStream[pStream->m_iStream];

    // Validate
    if (pInfo->faStart == pStream->m_faStart)
        goto exit;

    // Set faCurrent
    faCurrent = pInfo->faStart;

    // Loop until I find pStream->m_iCurrent
    while (faCurrent > 0)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Is this It ?
        if (iBlock == pStream->m_iCurrent)
        {
            // We Found It
            fFound = TRUE;

            // Save m_faCurrent
            pStream->m_faCurrent = faCurrent;

            // Validate Size
            Assert(pStream->m_cbCurrent <= pBlock->cbData && cbOffset + pStream->m_cbCurrent == pStream->m_cbOffset);

            // Done
            break;
        }

        // Goto Next
        faCurrent = pBlock->faNext;

        // Increment iBlock
        iBlock++;

        // Increment cbOffset
        IF_DEBUG(cbOffset += pBlock->cbData;)
    }

    // If not found...
    if (FALSE == fFound)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Reset Start Address
    pStream->m_faStart = pInfo->faStart;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamCompareDatabase
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamCompareDatabase(CDatabaseStream *pStream, 
    IDatabase *pDatabase)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLockSrc=NULL;
    HLOCK           hLockDst=NULL;
    CDatabase      *pDB=NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLockSrc));

    // Lock the Dst
    IF_FAILEXIT(hr = pDatabase->Lock(&hLockDst));

    // QI for CDatabase
    IF_FAILEXIT(hr = pDatabase->QueryInterface(IID_CDatabase, (LPVOID *)&pDB));

    // Compare m_pStorage->pszMap
    hr = (0 == StrCmpIW(m_pStorage->pszMap, pDB->m_pStorage->pszMap)) ? S_OK : S_FALSE;

exit:
    // Cleanup
    SafeRelease(pDB);

    // Mutal Exclusion
    Unlock(&hLockSrc);
    pDatabase->Unlock(&hLockDst);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetStreamAddress
//--------------------------------------------------------------------------
HRESULT CDatabase::GetStreamAddress(CDatabaseStream *pStream, 
    LPFILEADDRESS pfaStream)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Get the address
    *pfaStream = pStream->m_faStart;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamRead
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamRead(CDatabaseStream *pStream, LPVOID pvData,
    ULONG cbWanted, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbMap;
    DWORD           cbRead=0;
    DWORD           cbGet;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::_StreamRead");

    // Init pcbRead
    if (pcbRead)
        *pcbRead = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && pvData);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Loop and Read
    while (cbRead < cbWanted)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

        // Time to go to the next block ?
        if (pStream->m_cbCurrent == pBlock->cbData && 0 != pBlock->faNext)
        {
            // Set m_faCurrent
            pStream->m_faCurrent = pBlock->faNext;

            // Increment m_iCurrent
            pStream->m_iCurrent++;

            // Reset offset into current block
            pStream->m_cbCurrent = 0;

            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));
        }

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validate the Offset
        Assert(pStream->m_cbCurrent <= pBlock->cbData);

        // Determine how much we can read from the current block ?
        cbGet = min(cbWanted - cbRead, pBlock->cbData - pStream->m_cbCurrent);

        // Nothing left to get
        if (cbGet == 0)
            break;

        // Read some bytes
        pbMap = ((LPBYTE)pBlock + sizeof(STREAMBLOCK));

        // Copy the Data
        CopyMemory((LPBYTE)pvData + cbRead, pbMap + pStream->m_cbCurrent, cbGet);

        // Increment Amount of Data Read
        cbRead += cbGet;

        // Increment Offset within Current Block
        pStream->m_cbCurrent += cbGet;

        // Global Offset
        pStream->m_cbOffset += cbGet;
    }

    // Init pcbRead
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamWrite
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamWrite(CDatabaseStream *pStream, const void *pvData,
    ULONG cb, ULONG *pcbWrote)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbMap;
    DWORD           cbWrote=0;
    DWORD           cbPut;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamWrite");

    // Init pcbRead
    if (pcbWrote)
        *pcbWrote = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && pStream->m_tyAccess == ACCESS_WRITE && pvData);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Loop and Read
    while (cbWrote < cb)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validation
        Assert(pStream->m_cbCurrent <= pBlock->cbData);

        // Have we written to the end of the current block and there are more blocks
        if (pStream->m_cbCurrent == pBlock->cbSize)
        {
            // Are there more blocks
            if (0 == pBlock->faNext)
            {
                // Locals
                LPSTREAMBLOCK pBlockNew;

                // Allocate a block in the tree
                IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STREAM, 0, (LPVOID *)&pBlockNew));

                // Get the Current Stream Block
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

                // Set the next block address on the current block
                pBlock->faNext = pBlockNew->faBlock;

                // Access the block
                pBlock = pBlockNew;

                // Initial 0 data
                pBlock->cbData = 0;

                // No next block
                pBlock->faNext = 0;
            }

            // Otherwise, move to the next block
            else
            {
                // Save faBlcok
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pBlock->faNext, (LPVOID *)&pBlock));
            }

            // Set m_faCurrent
            pStream->m_faCurrent = pBlock->faBlock;

            // Increment the block index
            pStream->m_iCurrent++;

            // Reset the Current Block Offset
            pStream->m_cbCurrent = 0;

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);
        }

        // Compute how much of the cb we can write
        cbPut = min(cb - cbWrote, pBlock->cbSize - pStream->m_cbCurrent);

        // Read some bytes
        pbMap = ((LPBYTE)pBlock + sizeof(STREAMBLOCK));

        // Check memory
        //Assert(FALSE == IsBadWritePtr(pbMap, cbPut));

        // Check memory
        //Assert(FALSE == IsBadReadPtr((LPBYTE)pvData + cbWrote, cbPut));

        // Copy the Data
        CopyMemory(pbMap + pStream->m_cbCurrent, (LPBYTE)pvData + cbWrote, cbPut);

        // Increment the Offset within the current block
        pStream->m_cbCurrent += cbPut;

        // Increment the Offset within the current block
        pStream->m_cbOffset += cbPut;

        // Increment the Amount that has been wrote
        cbWrote += cbPut;

        // Increment the amount of data in the block only if we are expanding its size
        if (0 == pBlock->faNext && pStream->m_cbCurrent > pBlock->cbData)
        {
            // Set the Amount of Data in this block
            pBlock->cbData = pStream->m_cbCurrent;
        }

        // Otherwise, the block should be full
        else
            Assert(pBlock->cbData == pBlock->cbSize);
    }

    // Init pcbRead
    if (pcbWrote)
        *pcbWrote = cbWrote;

    // Update Version
    m_pShare->dwVersion++;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamSeek
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamSeek(CDatabaseStream *pStream, LARGE_INTEGER liMove,
    DWORD dwOrigin, ULARGE_INTEGER *pulNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbNewOffset;
    LONG            lOffset;
    DWORD           cbSize=0;
    FILEADDRESS     faBlock;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamSeek");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && 0 == liMove.HighPart);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Cast lowpart
    lOffset = (LONG)liMove.LowPart;

    // STREAM_SEEK_CUR
    if (STREAM_SEEK_CUR == dwOrigin)
    {
        // Validate
        if (lOffset < 0 && (DWORD)(0 - lOffset) > pStream->m_cbOffset)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Set new Offset...
        cbNewOffset = (pStream->m_cbOffset + lOffset);
    }

    // STREAM_SEEK_END
    else if (STREAM_SEEK_END == dwOrigin)
    {
        // Compute Size...from current offset
        faBlock = pStream->m_faCurrent;

        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validation
        Assert(pStream->m_cbCurrent <= pBlock->cbData && pStream->m_cbCurrent <= pBlock->cbSize);

        // Set cbSize
        cbSize = pStream->m_cbOffset + (pBlock->cbData - pStream->m_cbCurrent);

        // Goto the next block
        faBlock = pBlock->faNext;

        // While
        while (faBlock > 0)
        {
            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

            // Increment cbSize
            cbSize += pBlock->cbData;

            // Set faBlock
            faBlock = pBlock->faNext;
        }

        // If lOffset is negative and absolutely larger than the size of the stream
        if (lOffset > 0 || (lOffset < 0 && (DWORD)(0 - lOffset) > cbSize))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Save new offset
        cbNewOffset = cbSize + lOffset;
    }

    // STREAM_SEEK_SET
    else
    {
        // Can't be negative
        if (lOffset < 0)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Save new offset
        cbNewOffset = lOffset;
    }

    // Did the offset change
    if (cbNewOffset != pStream->m_cbOffset)
    {
        // Reset Current Position
        pStream->m_faCurrent = pStream->m_faStart;
        pStream->m_cbCurrent = 0;
        pStream->m_iCurrent = 0;
        pStream->m_cbOffset = 0;

        // Initialize the loop
        faBlock = pStream->m_faStart;

        // Lets seek from the start of the stream to the new offset
        while (faBlock > 0)
        {
            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

            // Save some stuff
            pStream->m_faCurrent = pBlock->faBlock;

            // Is this the block we want ?
            if (pStream->m_cbOffset + pBlock->cbData >= cbNewOffset)
            {
                // Compute m_cbCurrent
                pStream->m_cbCurrent = (cbNewOffset - pStream->m_cbOffset);

                // Set m_cbOffset
                pStream->m_cbOffset += pStream->m_cbCurrent;

                // Done
                break;
            }

            // Set m_cbCurrent
            pStream->m_cbCurrent = pBlock->cbData;

            // Increment global offset
            pStream->m_cbOffset += pBlock->cbData;

            // Increment Index
            pStream->m_iCurrent++;

            // Goto Next
            faBlock = pBlock->faNext;
        }
    }

    // Return Position
    if (pulNew)
        pulNew->LowPart = pStream->m_cbOffset;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamGetAddress
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamGetAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStart)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamGetAddress");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Return the Address
    *pfaStart = pStream->m_faStart;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamRelease
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamRelease(CDatabaseStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPOPENSTREAM    pInfo;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamRelease");

    // Invalid Args
    Assert(pStream);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Validate
    Assert(m_pShare->rgStream);

    // Cast iStream
    pInfo = &m_pShare->rgStream[pStream->m_iStream];

    // Better have a reference count
    Assert(pInfo->cOpenCount > 0);

    // Decrement cOpenCount
    pInfo->cOpenCount--;

    // Reset the Lock Count based on the access type
    if (ACCESS_WRITE == pStream->m_tyAccess)
    {
        // Validate the lLock
        Assert(LOCK_VALUE_WRITER == pInfo->lLock && 0 == pInfo->cOpenCount);

        // Set to none
        pInfo->lLock = LOCK_VALUE_NONE;
    }

    // Otherwise, must have been locked for a read
    else
    {
        // Validate
        Assert(ACCESS_READ == pStream->m_tyAccess && pInfo->lLock > 0);

        // Validate Lock count
        pInfo->lLock--;
    }

    // If this was the last reference...
    if (0 == pInfo->cOpenCount)
    {
        // If the stream is marked for deletion
        if (TRUE == pInfo->fDeleteOnClose)
        {
            // Validate Start Address
            Assert(pInfo->faStart > 0);

            // Free the Storage
            IF_FAILEXIT(hr = _FreeStreamStorage(pInfo->faStart));
        }

        // Zero Out This Entry
        ZeroMemory(pInfo, sizeof(OPENSTREAM));
    }

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeStreamStorage
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeStreamStorage(FILEADDRESS faStart)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAMBLOCK   pBlock;
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_FreeStreamStorage");

    // Invalid Args
    Assert(faStart > 0);

    // Initialize Loop
    faCurrent = faStart;

    // Read through all of the blocks (i.e. verify headers and count the number of chains)
    while (faCurrent)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pBlock));

        // Set faCurrent
        faCurrent = pBlock->faNext;

        // Read the header
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_STREAM, pBlock->faBlock));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CreateStream
//--------------------------------------------------------------------------
HRESULT CDatabase::CreateStream(LPFILEADDRESS pfaStream)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faStart=0;
    HLOCK           hLock=NULL;
    LPSTREAMBLOCK   pStream;

    // Trace
    TraceCall("CDatabase::CreateStream");

    // Invalid Arg
    Assert(pfaStream);

    // Initialize
    *pfaStream = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Allocate the first 512 block of the stream
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STREAM, 0, (LPVOID *)&pStream));

    // Write the Initialize Header
    pStream->cbData = 0;
    pStream->faNext = 0;

    // Return the block
    *pfaStream = pStream->faBlock;

    // Modify the Version
    m_pShare->dwVersion++;

exit:
    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CopyStream
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CopyStream(IDatabase *pDatabase, FILEADDRESS faStream,
    LPFILEADDRESS pfaNew)
{
    // Locals
    HRESULT             hr=S_OK;
    FILEADDRESS         faNew=0;
    DWORD               cbRead;
    HLOCK               hLock=NULL;
    BYTE                rgbBuffer[4096];
    IStream            *pStmDst=NULL;
    IStream            *pStmSrc=NULL;

    // Trace
    TraceCall("CDatabase::CopyStream");

    // Invalid Arg
    if (NULL == pDatabase || 0 == faStream || NULL == pfaNew)
        return(TraceResult(E_INVALIDARG));

    // Initialize
    *pfaNew = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Allocate a Stream in the Destination Database
    IF_FAILEXIT(hr = pDatabase->CreateStream(&faNew));

    // Open It Dst
    IF_FAILEXIT(hr = pDatabase->OpenStream(ACCESS_WRITE, faNew, &pStmDst));

    // Open It Src
    IF_FAILEXIT(hr = OpenStream(ACCESS_READ, faStream, &pStmSrc));

    // Read and Write...
    while (1)
    {
        // Read a Block From the Source
        IF_FAILEXIT(hr = pStmSrc->Read(rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
            break;

        // Write It
        IF_FAILEXIT(hr = pStmDst->Write(rgbBuffer, cbRead, NULL));

        // Yield Compacting
        if (m_pShare->fCompacting && m_fCompactYield)
        {
            // Give up a timeslice
            Sleep(0);
        }
    }

    // Comit the Dest
    IF_FAILEXIT(hr = pStmDst->Commit(STGC_DEFAULT));

    // Modify the Version
    *pfaNew = faNew;

    // Don't Free It
    faNew = 0;

exit:
    // Cleanup
    SafeRelease(pStmDst);
    SafeRelease(pStmSrc);

    // Failure
    if (faNew)
    {
        // Delete the Stream
        SideAssert(SUCCEEDED(pDatabase->DeleteStream(faNew)));
    }

    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ChangeStreamLock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPOPENSTREAM        pInfo;
    CDatabaseStream    *pDBStream=NULL;

    // Trace
    TraceCall("CDatabase::ChangeStreamLock");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get Private Stream
    IF_FAILEXIT(hr = pStream->QueryInterface(IID_CDatabaseStream, (LPVOID *)&pDBStream));

    // Get Stream Info
    pInfo = &m_pShare->rgStream[pDBStream->m_iStream];

    // Going to Writer
    if (ACCESS_WRITE == tyAccessNew)
    {
        // Already Locked for Write
        if (LOCK_VALUE_WRITER == pInfo->lLock)
        {
            Assert(ACCESS_WRITE == pDBStream->m_tyAccess);
            goto exit;
        }

        // If more than one reader
        if (pInfo->lLock > 1)
        {
            hr = TraceResult(DB_E_LOCKEDFORREAD);
            goto exit;
        }

        // Change Lock Type
        pInfo->lLock = LOCK_VALUE_WRITER;

        // Write Access
        pDBStream->m_tyAccess = ACCESS_WRITE;
    }

    // Otherwise, change to read...
    else
    {
        // Validate
        Assert(ACCESS_READ == tyAccessNew);

        // If already locked for read
        if (LOCK_VALUE_WRITER != pInfo->lLock)
        {
            Assert(ACCESS_READ == pDBStream->m_tyAccess);
            goto exit;
        }

        // Change to 1 reader
        pInfo->lLock = 1;

        // Read Access
        pDBStream->m_tyAccess = ACCESS_READ;
    }

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Cleanup
    SafeRelease(pDBStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::OpenStream
//--------------------------------------------------------------------------
HRESULT CDatabase::OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart,
    IStream **ppStream)
{
    // Locals
    HRESULT          hr=S_OK;
    STREAMINDEX      i;
    STREAMINDEX      iStream=INVALID_STREAMINDEX;
    STREAMINDEX      iFirstUnused=INVALID_STREAMINDEX;
    LPOPENSTREAM     pInfo;
    HLOCK            hLock=NULL;
    CDatabaseStream *pStream=NULL;

    // Trace
    TraceCall("CDatabase::OpenStream");

    // Invalid Arg
    if (0 == faStart || NULL == ppStream)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Validate
    Assert(m_pShare->rgStream);

    // Does the faStart Stream Exist in my stream table
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is this the stream
        if (faStart == m_pShare->rgStream[i].faStart)
        {
            // This must already be locked for write or read
            Assert(LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock || m_pShare->rgStream[i].lLock > 0);

            // Get Access
            if (ACCESS_WRITE == tyAccess)
            {
                hr = TraceResult(DB_E_LOCKEDFORREAD);
                goto exit;
            }

            // Otheriwise, get read lock
            else
            {
                // If Locked for a write
                if (LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock)
                {
                    hr = TraceResult(DB_E_LOCKEDFORWRITE);
                    goto exit;
                }
            }

            // Set iStream
            iStream = i;

            // Increment Open Count for this stream
            m_pShare->rgStream[i].cOpenCount++;

            // I Must have got a read lock
            Assert(ACCESS_READ == tyAccess && m_pShare->rgStream[i].lLock > 0);

            // Increment Reader Count
            m_pShare->rgStream[i].lLock++;
        }

        // If this entry is unused, lets remember it
        if (FALSE == m_pShare->rgStream[i].fInUse && INVALID_STREAMINDEX == iFirstUnused)
            iFirstUnused = i;
    }

    // If we didn't find faStart in the stream table, append an entry ?
    if (INVALID_STREAMINDEX == iStream)
    {
        // Is there enought space
        if (INVALID_STREAMINDEX == iFirstUnused)
        {
            hr = TraceResult(DB_E_STREAMTABLEFULL);
            goto exit;
        }

        // Set iStream
        iStream = iFirstUnused;

        // Readability
        pInfo = &m_pShare->rgStream[iStream];

        // This entry is now in use
        pInfo->fInUse = TRUE;

        // Register the starting address of this stream
        pInfo->faStart = faStart;

        // Reader or Writer ?
        pInfo->lLock = (ACCESS_WRITE == tyAccess) ? LOCK_VALUE_WRITER : (m_pShare->rgStream[i].lLock + 1);

        // Set Open count
        pInfo->cOpenCount++;
    }

    // Allocate an Object Database Stream
    IF_NULLEXIT(pStream = new CDatabaseStream(this, iStream, tyAccess, faStart));

    // Return
    *ppStream = (IStream *)pStream;
    pStream = NULL;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Cleanup
    SafeRelease(pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CollapseChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_CollapseChain(LPCHAINBLOCK pChain, NODEINDEX iDelete)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;

    // Trace
    TraceCall("CDatabase::_CollapseChain");

    // Simply set node[i] = node[i+1]; cNodes -= 1; Write the Chain !
    for (i=iDelete; i<pChain->cNodes - 1; i++)
    {
        // Copy i + 1 chain node down one
        CopyMemory(&pChain->rgNode[i], &pChain->rgNode[i + 1], sizeof(CHAINNODE));

        // If there is a right chain
        if (pChain->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the current Parent
            Assert(pRightChain->faParent == pChain->faBlock);

            // Validate the current index
            Assert(pRightChain->iParent == i + 1);

            // Reset the Parent
            pRightChain->iParent = i;
        }
    }

    // Decrement count
    pChain->cNodes--;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IndexDeleteRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_IndexDeleteRecord(INDEXORDINAL iIndex, 
    FILEADDRESS faDelete, NODEINDEX iDelete)
{
    // Locals
    HRESULT           hr=S_OK;
    HRESULT           hrIsLeafChain;
    NODEINDEX         i;
    LPCHAINBLOCK      pDelete;
    CHAINSHARETYPE    tyShare;
    CHAINDELETETYPE   tyDelete;
    FILEADDRESS       faShare;
    LPCHAINBLOCK      pSuccessor;
    FILEADDRESS       faRecord;

    // Trace
    TraceCall("CDatabase::_IndexDeleteRecord");

    // Invalid Args
    Assert(iDelete < BTREE_ORDER);

    // Get Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Is this a leaf node
    hrIsLeafChain = _IsLeafChain(pDelete);

    // Case 1: Deleting a leaf node that does not violate the minimum capcity constraint
    if (S_OK == hrIsLeafChain && (pDelete->cNodes - 1 >= BTREE_MIN_CAP || 0 == pDelete->faParent))
    {
        // Collapse the Chain
        _CollapseChain(pDelete, iDelete);

        // Update the Parent Node Count
        IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faDelete, -1));

        // Did we just delete the root chain
        if (0 == pDelete->faParent && 0 == pDelete->cNodes)
        {
            // Add pShare to free list
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faDelete));

            // Update the header, we don't have any more nodes
            m_pHeader->rgfaIndex[iIndex] = 0;
        }
    }

    // Case 2: Deleting from a nonleaf node and replacing that record with a record from a leaf node that does not violate the minimum capacity contstraint.
    else if (S_FALSE == hrIsLeafChain)
    {
        // Get Inorder Successor
        IF_FAILEXIT(hr = _GetInOrderSuccessor(faDelete, iDelete, &pSuccessor));

        // Free Tree Block
        faRecord = pDelete->rgNode[iDelete].faRecord;

        // Free Tree Block
        pDelete->rgNode[iDelete].faRecord = pSuccessor->rgNode[0].faRecord;

        // Delete pSuccessor->rgNode[0] - and the record which we just replaced
        pSuccessor->rgNode[0].faRecord = faRecord;

        // Delete this node
        IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, pSuccessor->faBlock, 0));
    }

    // Case 3: Deleting from a leaf node that causes a minimum capacity constraint violation that can be corrected by redistributing the records with an adjacent sibling node.
    else
    {
        // Decide if I need to do a shared or coalesce type delete
        IF_FAILEXIT(hr = _DecideHowToDelete(&faShare, faDelete, &tyDelete, &tyShare));

        // Collapse the Chain
        _CollapseChain(pDelete, iDelete);

        // If NULL, then do a coalesc
        if (CHAIN_DELETE_SHARE == tyDelete)
        {
            // Adjust the Parent's Parents
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faDelete, -1));

            // Do a shared deleted
            IF_FAILEXIT(hr = _ChainDeleteShare(iIndex, faDelete, faShare, tyShare));
        }

        // Coalesce Type Delete
        else
        {
            // Validate the delete type
            Assert(faShare && CHAIN_DELETE_COALESCE == tyDelete && pDelete->faParent != 0);

            // Adjust the Parent's Parents
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, pDelete->faParent, -1));

            // Do a coalescing delete
            IF_FAILEXIT(hr = _ChainDeleteCoalesce(iIndex, faDelete, faShare, tyShare));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IsLeafChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_IsLeafChain(LPCHAINBLOCK pChain)
{
    // If Left Chain is NULL, then all chains must be null
    return (0 == pChain->faLeftChain) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CDatabase::_ChainDeleteShare
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainDeleteShare(INDEXORDINAL iIndex,
    FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    NODEINDEX       iInsert;
    NODEINDEX       iParent;
    FILEADDRESS     faParentRightChain;
    DWORD           cParentRightNodes;
    DWORD           cCopyNodes;
    LPCHAINBLOCK    pDelete;
    LPCHAINBLOCK    pShare;
    LPCHAINBLOCK    pParent;

    // Trace
    TraceCall("CDatabase::_ChainDeleteShare");

    // Invalid ARgs
    Assert(faDelete && faShare);

    // Get pShare
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faShare, (LPVOID *)&pShare));

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pShare->faParent, (LPVOID *)&pParent));

    // Get pDelete
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Validation
    Assert(pShare->faParent == pDelete->faParent);

    // Setup iParent
    iParent = (CHAIN_SHARE_LEFT == tyShare) ? pDelete->iParent : pShare->iParent;

    // Save Paren't Right Chain, we are going to replace iParent with the last left or first right node
    faParentRightChain = pParent->rgNode[iParent].faRightChain;

    // Save the cParentRightNodes
    cParentRightNodes = pParent->rgNode[iParent].cRightNodes;

    // Insert Parent Node into lpChainFound - Parent Pointers stay the same
    pParent->rgNode[iParent].faRightChain = 0;

    // Reset cRightNodes
    pParent->rgNode[iParent].cRightNodes = 0;

    // Insert the parent node into the chain that we are deleting from
    IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pParent->rgNode[iParent], &iInsert));

    // If promoting from the Left, promote Node: cNodes-1 to parent
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Should have inserted at position zero
        Assert(0 == iInsert);

        // Promote Node: 0 to from the deletion node into the parent node
        pDelete->rgNode[0].faRightChain = pDelete->faLeftChain;

        // Propagate cLeftNodes to cRightNodes
        pDelete->rgNode[0].cRightNodes = pDelete->cLeftNodes;

        // Update Left Chain Address
        pDelete->faLeftChain = pShare->rgNode[pShare->cNodes - 1].faRightChain;

        // Update the left chain's parent
        if (pDelete->faLeftChain)
        {
            // Locals
            LPCHAINBLOCK pLeftChain;

            // Get Left
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->faLeftChain, (LPVOID *)&pLeftChain));

            // Set faParent
            pLeftChain->faParent = pDelete->faBlock;

            // Set iParent
            pLeftChain->iParent = 0;
        }

        // Update Left Chain Node count
        pDelete->cLeftNodes = pShare->rgNode[pShare->cNodes - 1].cRightNodes;

        // Save cCopyNodes
        cCopyNodes = pDelete->cLeftNodes + 1;

        // Copy the node from the left share chain into the parent's spot
        CopyMemory(&pParent->rgNode[iParent], &pShare->rgNode[pShare->cNodes - 1], sizeof(CHAINNODE));

        // Reset the right chain on the parent
        pParent->rgNode[iParent].faRightChain = faParentRightChain;

        // Reset the right node count on the parent
        pParent->rgNode[iParent].cRightNodes = cParentRightNodes;

        // Decrement number of nodes in the share chain
        pShare->cNodes--;
    
        // Special case, pShare is to the left of the first node of the parent chain
        if (0 == iParent)
        {
            // Can not be the left chain, otherwise, we wouldn't be sharing from the right
            Assert(pShare->faBlock == pParent->faLeftChain && pParent->cLeftNodes > cCopyNodes);

            // Decrement Right Node Count
            pParent->cLeftNodes -= cCopyNodes;

            // Increment
            pParent->rgNode[0].cRightNodes += cCopyNodes;
        }

        // Otherwise, Decrement cRightNodes
        else
        {
            // Validate share left chain
            Assert(pShare->faBlock == pParent->rgNode[iParent - 1].faRightChain && pParent->rgNode[iParent - 1].cRightNodes > cCopyNodes);

            // Decrement Right Nodes Count
            pParent->rgNode[iParent - 1].cRightNodes -= cCopyNodes;

            // Validate Right Chain
            Assert(pParent->rgNode[iParent].faRightChain == pDelete->faBlock && iParent == pDelete->iParent && pDelete->iParent < pParent->cNodes);

            // Increment Right Nodes Count
            pParent->rgNode[iParent].cRightNodes += cCopyNodes;
        }
    }

    // Otherwise, share from the right
    else
    {
        // Verify the share type
        Assert(CHAIN_SHARE_RIGHT == tyShare && pDelete->cNodes - 1 == iInsert);

        // Promote Node: 0 to parent
        pDelete->rgNode[pDelete->cNodes - 1].faRightChain = pShare->faLeftChain;

        // Update the Right Chain's Parent
        if (pDelete->rgNode[pDelete->cNodes - 1].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[pDelete->cNodes - 1].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = (pDelete->cNodes - 1);
        }

        // Set cRightNodes Count
        pDelete->rgNode[pDelete->cNodes - 1].cRightNodes = pShare->cLeftNodes;

        // Save cCopyNodes
        cCopyNodes = pDelete->rgNode[pDelete->cNodes - 1].cRightNodes + 1;

        // Tree Shift
        pShare->faLeftChain = pShare->rgNode[0].faRightChain;

        // Tree Shift
        pShare->cLeftNodes = pShare->rgNode[0].cRightNodes;

        // Copy the node from the share chain to the parent
        CopyMemory(&pParent->rgNode[iParent], &pShare->rgNode[0], sizeof(CHAINNODE));

        // Collapse this Chain
        _CollapseChain(pShare, 0);

        // Reset the right chain on the parent
        pParent->rgNode[iParent].faRightChain = faParentRightChain;

        // Reset the right node count on the parent
        pParent->rgNode[iParent].cRightNodes = cParentRightNodes;

        // Special case, pShare is to the left of the first node of the parent chain
        if (0 == iParent)
        {
            // Can not be the left chain, otherwise, we wouldn't be sharing from the right
            Assert(pParent->rgNode[0].faRightChain == pShare->faBlock && pParent->rgNode[0].cRightNodes > cCopyNodes);

            // Decrement Right Node Count
            pParent->rgNode[0].cRightNodes -= cCopyNodes;

            // Validate
            Assert(pParent->faLeftChain == pDelete->faBlock);

            // Increment
            pParent->cLeftNodes += cCopyNodes;
        }

        // Otherwise, Decrement cRightNodes
        else
        {
            // Validate share left chain
            Assert(pShare->faBlock == pParent->rgNode[iParent].faRightChain && pParent->rgNode[iParent].cRightNodes > 0);

            // Decrement Right Node Count
            pParent->rgNode[iParent].cRightNodes -= cCopyNodes;

            // Validate
            Assert(pParent->rgNode[iParent - 1].faRightChain == pDelete->faBlock);

            // Increment Left Sibling
            pParent->rgNode[iParent - 1].cRightNodes += cCopyNodes;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ChainDeleteCoalesce
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainDeleteCoalesce(INDEXORDINAL iIndex,
    FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare)
{
    // Locals
    HRESULT             hr=S_OK;
    NODEINDEX           i;
    NODEINDEX           iInsert;
    NODEINDEX           iParent;
    LPCHAINBLOCK        pParent;
    LPCHAINBLOCK        pDelete;
    LPCHAINBLOCK        pShare;
    FILEADDRESS         faShareAgain;
    CHAINDELETETYPE     tyDelete;
    DWORD               cRightNodes;

    // Trace
    TraceCall("CDatabase::_ChainDeleteCoalesce");

    // Invalid ARgs
    Assert(faDelete && faShare);

    // Get pShare
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faShare, (LPVOID *)&pShare));

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pShare->faParent, (LPVOID *)&pParent));

    // Get pDelete
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Validation
    Assert(pShare->faParent == pDelete->faParent);

    // Setup iParent
    iParent = (CHAIN_SHARE_LEFT == tyShare) ? pDelete->iParent : pShare->iParent;

    // Insert the Parent
    IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pParent->rgNode[iParent], &iInsert));

    // Set newly inserted nodes pointers
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Validate
        Assert(0 == iInsert);

        // Adjust the right Chain
        pDelete->rgNode[0].faRightChain = pDelete->faLeftChain;

        // Adjust the right node count
        pDelete->rgNode[0].cRightNodes = pDelete->cLeftNodes;

        // Adjust the left chain
        pDelete->faLeftChain = pShare->faLeftChain;

        // Update faLeftChain
        if (pDelete->faLeftChain)
        {
            // Locals
            LPCHAINBLOCK pLeftChain;

            // Get Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->faLeftChain, (LPVOID *)&pLeftChain));

            // Set faParent
            pLeftChain->faParent = pDelete->faBlock;

            // Set iParent
            pLeftChain->iParent = 0;
        }

        // Adjust the left chain node count
        pDelete->cLeftNodes = pShare->cLeftNodes;
    }

    // Share from the right
    else
    {
        // Verify Share Type
        Assert(CHAIN_SHARE_RIGHT == tyShare && pDelete->cNodes - 1 == iInsert);

        // Adjust the right chain
        pDelete->rgNode[pDelete->cNodes - 1].faRightChain = pShare->faLeftChain;

        // Update the Right Chain's Parent
        if (pDelete->rgNode[pDelete->cNodes - 1].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get the right chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[pDelete->cNodes - 1].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = (pDelete->cNodes - 1);
        }

        // Adjust the right Node Count
        pDelete->rgNode[pDelete->cNodes - 1].cRightNodes = pShare->cLeftNodes;
    }

    // Combine pShare Nodes into pDelete
    for (i=0; i<pShare->cNodes; i++)
    {
        // Insert the Share
        IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pShare->rgNode[i], &iInsert));

        // Need to update...
        if (pDelete->rgNode[iInsert].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[iInsert].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = iInsert;
        }
    }

    // Don't use pShare any more
    pShare = NULL;

    // We can't possible need pShare anymore since we just copied all of its nodes into pDelete
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faShare));

    // Collapse the Parent chain
    _CollapseChain(pParent, iParent);

    // If Parent is less than zero, then lets hope that it was the root node!
    if (pParent->cNodes == 0)
    {
        // This is a bug
        Assert(0 == pParent->faParent && m_pHeader->rgfaIndex[iIndex] == pParent->faBlock);

        // Add pParent to free list
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, pParent->faBlock));

        // Kill faParent Link
        pDelete->faParent = pDelete->iParent = 0;

        // We have a new root chain
        m_pHeader->rgfaIndex[iIndex] = pDelete->faBlock;

        // No more parent
        goto exit;
    }

    // Compute cRightNodes
    cRightNodes = pDelete->cNodes + pDelete->cLeftNodes;

    // Loop and count all children
    for (i=0; i<pDelete->cNodes; i++)
    {
        // Increment Node Count
        cRightNodes += pDelete->rgNode[i].cRightNodes;
    }

    // Reset new parent to found node
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Readjust new parent node of coalesced chain
        if (iParent > pParent->cNodes - 1)
        {
            // What is happening here
            iParent = pParent->cNodes - 1;
        }

        // We should be replace pShare
        Assert(pParent->rgNode[iParent].faRightChain == faShare);

        // Update Parent for pDelete
        pParent->rgNode[iParent].faRightChain = pDelete->faBlock;

        // Adjust Right Chain's Parent
        if (pParent->rgNode[iParent].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[iParent].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            Assert(pRightChain->faParent == pParent->faBlock);

            // Set the Parent Index
            pRightChain->iParent = iParent;
        }

        // Compute cRightNodes
        pParent->rgNode[iParent].cRightNodes = cRightNodes;
    }

    // Otherwise, adjust for CHAIN_SHARE_RIGHT
    else
    {
        // Validation
        Assert(pDelete->faParent == pParent->faBlock);

        // First Node
        if (0 == iParent)
        {
            // Must be left chain
            Assert(pParent->faLeftChain == pDelete->faBlock);

            // Validate my Parent
            Assert(pDelete->iParent == 0);

            // Set Left Node Count
            pParent->cLeftNodes = cRightNodes;
        }

        // Otherwise
        else
        {
            // Validate iParent
            Assert(pParent->rgNode[iParent - 1].faRightChain == pDelete->faBlock);

            // Validation
            Assert(pDelete->iParent == iParent - 1);

            // Set cRightNodes
            pParent->rgNode[iParent - 1].cRightNodes = cRightNodes;
        }
    }

    // Move up the chain, until lpChainPrev == NULL, lpChainPrev->cNodes can not be less than /2
    if (0 == pParent->faParent)
        goto exit;

    // Min capacity
    if (pParent->cNodes < BTREE_MIN_CAP)
    {
        // Decide if I need to do a shared or coalesce type delete
        IF_FAILEXIT(hr = _DecideHowToDelete(&faShareAgain, pParent->faBlock, &tyDelete, &tyShare));

        // Can't Share, we must coalesc again
        if (CHAIN_DELETE_SHARE == tyDelete)
        {
            // Do a shared delete
            IF_FAILEXIT(hr = _ChainDeleteShare(iIndex, pParent->faBlock, faShareAgain, tyShare));
        }

        // Coalesce type delete
        else
        {
            // Validate
            Assert(faShareAgain && CHAIN_DELETE_COALESCE == tyDelete);

            // Recursive Coalescing
            IF_FAILEXIT(hr = _ChainDeleteCoalesce(iIndex, pParent->faBlock, faShareAgain, tyShare));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DecideHowToDelete
//--------------------------------------------------------------------------
HRESULT CDatabase::_DecideHowToDelete(LPFILEADDRESS pfaShare,
    FILEADDRESS faDelete, CHAINDELETETYPE *ptyDelete, 
    CHAINSHARETYPE *ptyShare)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrRight;
    HRESULT             hrLeft;
    LPCHAINBLOCK        pRight=NULL;
    LPCHAINBLOCK        pLeft=NULL;

    // Trace
    TraceCall("CDatabase::_DecideHowToDelete");

    // Initialize
    *pfaShare = NULL;

    // Get the right sibling
    IF_FAILEXIT(hr = _GetRightSibling(faDelete, &pRight));

    // Set hrRight
    hrRight = hr;

    // Did we get a right parent that has nodes that I can steal from ?
    if (DB_S_FOUND == hrRight && pRight->cNodes - 1 >= BTREE_MIN_CAP)
    {
        // Set Delete Type
        *ptyDelete = CHAIN_DELETE_SHARE;

        // Set Share Type
        *ptyShare = CHAIN_SHARE_RIGHT;

        // Set Share Link
        *pfaShare = pRight->faBlock;
    }
    else
    {
        // Try to get the left sibling
        IF_FAILEXIT(hr = _GetLeftSibling(faDelete, &pLeft));

        // Set hrRight
        hrLeft = hr;

        // Did I get a left sibling that has nodes that I can steal from ?
        if (DB_S_FOUND == hrLeft && pLeft->cNodes - 1 >= BTREE_MIN_CAP)
        {
            // Set Delete Type
            *ptyDelete = CHAIN_DELETE_SHARE;

            // Set Share Type
            *ptyShare = CHAIN_SHARE_LEFT;

            // Set Share Link
            *pfaShare = pLeft->faBlock;
        }
    }

    // Did we find a Share ?
    if (0 == *pfaShare)
    {
        // Were are going to coalesce
        *ptyDelete = CHAIN_DELETE_COALESCE;

        // Coalesce and share from the right?
        if (DB_S_FOUND == hrRight)
        {
            // Set Share Type
            *ptyShare = CHAIN_SHARE_RIGHT;

            // Set Share Link
            *pfaShare = pRight->faBlock;
        }

        // Coalesce and share from the left?
        else
        {
            // Validation
            Assert(DB_S_FOUND == hrLeft);

            // Set Share Type
            *ptyShare = CHAIN_SHARE_LEFT;

            // Set Share Link
            *pfaShare = pLeft->faBlock;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetInOrderSuccessor
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetInOrderSuccessor(FILEADDRESS faStart,
    NODEINDEX iDelete, LPCHAINBLOCK *ppSuccessor)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faCurrent;
    LPCHAINBLOCK    pCurrent;
    LPCHAINBLOCK    pStart;

    // Trace
    TraceCall("CDatabase::_GetInOrderSuccessor");

    // Invalid Args
    Assert(ppSuccessor);

    // Initialize
    *ppSuccessor = NULL;

    // Get Start
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faStart, (LPVOID *)&pStart));

    // Next Chain Address
    faCurrent = pStart->rgNode[iDelete].faRightChain;

    // Can't be zero
    Assert(faCurrent != 0);

    // Go until left chain is -1
    while (faCurrent)
    {
        // Get Current
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

        // If leaf node, then return
        if (S_OK == _IsLeafChain(pCurrent))
        {
            // Set Successor
            *ppSuccessor = pCurrent;

            // Done
            goto exit;
        }

        // Otherwise, goto the left
        faCurrent = pCurrent->faLeftChain;
    }

    // Not Found
    hr = TraceResult(E_FAIL);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetLeftSibling
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetLeftSibling(FILEADDRESS faCurrent,
    LPCHAINBLOCK *ppSibling)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCHAINBLOCK    pCurrent;
    LPCHAINBLOCK    pParent;

    // Trace
    TraceCall("CDatabase::_GetLeftSibling");

    // Invalid Args
    Assert(faCurrent && ppSibling);

    // Get Current
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

    // Get Parent
    Assert(pCurrent->faParent);

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

    // Validate iparent
    Assert(pCurrent->iParent < pParent->cNodes);

    // iParent is zero
    if (0 == pCurrent->iParent)
    {
        // If pCurrent is the faRightChain ?
        if (pCurrent->faBlock != pParent->rgNode[0].faRightChain)
            return(DB_S_NOTFOUND);

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->faLeftChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == 0);
    }

    // iParent is greater than zero ?
    else
    {
        // Validate
        Assert(pParent->rgNode[pCurrent->iParent].faRightChain == pCurrent->faBlock);

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[pCurrent->iParent - 1].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == pCurrent->iParent - 1);
    }

    // Better have a left sibling
    Assert(0 != *ppSibling);

    // Found
    hr = DB_S_FOUND;

exit:
    // Set hr
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRightSibling
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRightSibling(FILEADDRESS faCurrent,
    LPCHAINBLOCK *ppSibling)
{
    // Locals
    HRESULT           hr=S_OK;
    LPCHAINBLOCK      pParent;
    LPCHAINBLOCK      pCurrent;

    // Trace
    TraceCall("CDatabase::_GetRightSibling");

    // Invalid Args
    Assert(faCurrent && ppSibling);

    // Get Current
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

    // Get Parent
    Assert(pCurrent->faParent);

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

    // Validate iparent
    Assert(pCurrent->iParent < pParent->cNodes);

    // iParent is zero
    if (0 == pCurrent->iParent && pCurrent->faBlock == pParent->faLeftChain)
    {
        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[0].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == 0);
    }

    // iParent is greater than zero ?
    else
    {
        // No more Right chains
        if (pCurrent->iParent + 1 == pParent->cNodes)
            return DB_S_NOTFOUND;

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[pCurrent->iParent + 1].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == pCurrent->iParent + 1);
    }

    // Better have a left sibling
    Assert(0 != *ppSibling);

    // Found
    hr = DB_S_FOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetUserData
//--------------------------------------------------------------------------
HRESULT CDatabase::GetUserData(LPVOID pvUserData, 
    ULONG cbUserData)
{
    // Locals
    HRESULT hr=S_OK;
    HLOCK   hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetUserData");

    // Invalid Args
    Assert(pvUserData);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Copy the data
    CopyMemory(pvUserData, PUSERDATA(m_pHeader), cbUserData);

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SetUserData
//--------------------------------------------------------------------------
HRESULT CDatabase::SetUserData(LPVOID pvUserData, 
    ULONG cbUserData)
{
    // Locals
    HRESULT hr=S_OK;
    HLOCK   hLock=NULL;

    // Trace
    TraceCall("CDatabase::SetUserData");

    // Invalid Args
    Assert(pvUserData);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Copy the data
    CopyMemory(PUSERDATA(m_pHeader), pvUserData, cbUserData);

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactMoveRecordStreams
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactMoveRecordStreams(CDatabase *pDstDB,
    LPVOID pBinding)
{
    // Locals
    HRESULT             hr=S_OK;
    COLUMNORDINAL       iColumn;
    FILEADDRESS         faSrcStart;
    FILEADDRESS         faDstStart;
    LPOPENSTREAM        pInfo;
    DWORD               i;

    // Trace
    TraceCall("CDatabase::_CompactMoveRecordStreams");

    // Walk through the format
    for (iColumn=0; iColumn<m_pSchema->cColumns; iColumn++)
    {
        // Is this a stream
        if (CDT_STREAM != m_pSchema->prgColumn[iColumn].type)
            continue;

        // Get the source stream starting address
        faSrcStart = *((FILEADDRESS *)((LPBYTE)pBinding + m_pSchema->prgColumn[iColumn].ofBinding));

        // Is there a stream
        if (0 == faSrcStart)
            continue;

        // Move the Stream
        IF_FAILEXIT(hr = CopyStream((IDatabase *)pDstDB, faSrcStart, &faDstStart));

        // Store the stream address in the record
        *((FILEADDRESS *)((LPBYTE)pBinding + m_pSchema->prgColumn[iColumn].ofBinding)) = faDstStart;

        // Loop through the stream table and adjust the start address of all open streams
        for (i=0; i<CMAX_OPEN_STREAMS; i++)
        {
            // Readability
            pInfo = &m_pShare->rgStream[i];

            // Is In use...
            if (TRUE == pInfo->fInUse && faSrcStart == pInfo->faStart)
            {
                // Change the Address
                pInfo->faMoved = faDstStart;

                // Break;
                break;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactMoveOpenDeletedStreams
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactMoveOpenDeletedStreams(CDatabase *pDstDB)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPOPENSTREAM    pInfo;

    // Trace
    TraceCall("CDatabase::_CompactMoveOpenDeletedStreams");

    // Loop through the stream table and adjust the start address of all open streams
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Readability
        pInfo = &m_pShare->rgStream[i];

        // Is In use...
        if (FALSE == pInfo->fInUse || FALSE == pInfo->fDeleteOnClose)
            continue;

        // Move the Stream
        IF_FAILEXIT(hr = CopyStream((IDatabase *)pDstDB, pInfo->faStart, &pInfo->faMoved));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactTransferFilters
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactTransferFilters(CDatabase *pDstDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    LPBLOCKHEADER       pStringSrc;
    LPBLOCKHEADER       pStringDst;

    // Trace
    TraceCall("CDatabase::_CompactTransferFilters");

    // Must have a Catalog
    Assert(pDstDB->m_pHeader);

    // Zero Out the Query String Addresses
    for (i=0; i<CMAX_INDEXES; i++)
    {
        // Zero Filter1
        pDstDB->m_pHeader->rgfaFilter[i] = 0;

        // Copy Filter1
        if (m_pHeader->rgfaFilter[i] && SUCCEEDED(_GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[i], (LPVOID *)&pStringSrc)))
        {
            // Try to Store the Query String
            IF_FAILEXIT(hr = pDstDB->_AllocateBlock(BLOCK_STRING, pStringSrc->cbSize, (LPVOID *)&pStringDst));

            // Write the String
            CopyMemory(PSTRING(pStringDst), PSTRING(pStringSrc), pStringSrc->cbSize);

            // String the String Address
            pDstDB->m_pHeader->rgfaFilter[i] = pStringDst->faBlock;
        }
    }

    // Change the Version so that it doesn't assert
    pDstDB->m_dwQueryVersion = 0xffffffff;

    // Rebuild the Query Table
    IF_FAILEXIT(hr = pDstDB->_BuildQueryTable());

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactInsertRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactInsertRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    FINDRESULT      rgResult[CMAX_INDEXES];
    INDEXORDINAL    iIndex;
    DWORD           i;
    RECORDMAP       RecordMap;
    FILEADDRESS     faRecord;

    // Trace
    TraceCall("CDatabase::InsertRecord");

    // Invalid Args
    Assert(pBinding);

    // Loop through all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, NULL, &rgResult[i].nCompare));

        // If key already exist, cache list and return
        if (DB_S_FOUND == hr)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }
    }

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Link Record Into the Table
    IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, 0, &faRecord));

    // Version Change
    m_pShare->dwVersion++;

    // Insert into the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Visible in live index
        if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
        {
            // Do the Insertion
            IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faRecord, &rgResult[i].iNode, rgResult[i].nCompare));

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]++;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::MoveFile
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::MoveFile(LPCWSTR pszFile)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPWSTR              pszFilePath=NULL;
    LPWSTR              pszShare=NULL;
    DWORD               cchFilePath;
    HANDLE              hMutex=NULL;
    BOOL                fNeedOpenFile=FALSE;
    BOOL                fNewShare;
    SHAREDDATABASE      Share;

    // Trace
    TraceCall("CDatabase::MoveFile");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // In move File
    m_fInMoveFile = TRUE;

    // Get the Full Path
    IF_FAILEXIT(hr = DBGetFullPath(pszFile, &pszFilePath, &cchFilePath));

    // Don't use pszFile again
    pszFile = NULL;

    // Failure
    if (cchFilePath >= CCHMAX_DB_FILEPATH)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_CLOSEFILE));

    // Need a remap..
    fNeedOpenFile = TRUE;

    // Move the file from the temp location to my current location
    if (0 == MoveFileWrapW(m_pShare->szFile, pszFilePath))
    {
        hr = TraceResult(DB_E_MOVEFILE);
        goto exit;
    }

    // Save the new file path...(other clients will remap to this file...)
    StrCpyNW(m_pShare->szFile, pszFilePath, ARRAYSIZE(m_pShare->szFile));

    // Save the Current Share
    CopyMemory(&Share, m_pShare, sizeof(SHAREDDATABASE));

    // Save Current Mutex
    hMutex = m_hMutex;

    // Clear m_hMutex so that we don't free it
    m_hMutex = NULL;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBShare", &pszShare));

    // Unmap the view of the memory mapped file
    SafeUnmapViewOfFile(m_pShare);

    // Unmap the view of the memory mapped file
    SafeCloseHandle(m_pStorage->hShare);

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));

    // Should be new
    Assert(fNewShare);

    // Save the Current Share
    CopyMemory(m_pShare, &Share, sizeof(SHAREDDATABASE));

    // Get all clients to re-open the new file
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_OPENMOVEDFILE));

    // Validate Mutex Changed
    Assert(m_hMutex && hMutex != m_hMutex);

    // Enter New Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // Fix hLock
    hLock = (HLOCK)m_hMutex;

    // Release hMutex
    ReleaseMutex(hMutex);

    // Free hMutex
    SafeCloseHandle(hMutex);

    // Sucess
    fNeedOpenFile = FALSE;

exit:
    // Not In Move File
    m_fInMoveFile = FALSE;

    // If Need Open File
    if (fNeedOpenFile)
    {
        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);
    }

    // Unlock
    Unlock(&hLock);

    // Cleanup
    SafeMemFree(pszFilePath);
    SafeMemFree(pszShare);
    
    // done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Compact
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    DWORD               dwVersion;
    DWORDLONG           dwlFree;
    DWORD               cDuplicates=0;
    DWORD               cRecords=0;
    DWORD               cbDecrease;
    LPVOID              pBinding=NULL;
    DWORD               dwNextId;
    DWORD               cbWasted;
    HLOCK               hLock=NULL;
    HLOCK               hDstLock=NULL;
    DWORD               cActiveThreads;
    LPWSTR              pszDstFile=NULL;
    HROWSET             hRowset=NULL;
    DWORD               cch;
    CDatabase          *pDstDB=NULL;

    // Trace
    TraceCall("CDatabase::Compact");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // If Compacting...
    if (TRUE == m_pShare->fCompacting)
    {
        // Leave Spin Lock
        Unlock(&hLock);

        // Trace
        return(TraceResult(DB_E_COMPACTING));
    }

    // I am compacting
    m_pShare->fCompacting = TRUE;

    // Yield
    if (ISFLAGSET(dwFlags, COMPACT_YIELD))
    {
        // Yield ?
        m_fCompactYield = TRUE;
    }

    // Get Length
    cch = lstrlenW(m_pShare->szFile);

    //Bug #101511: (erici) Debug shlwapi validates it to MAX_PATH characters 
    if( (cch+15) < MAX_PATH)
    {
        cch = MAX_PATH-15;
    }

    // Create .dbt file
    IF_NULLEXIT(pszDstFile = AllocateStringW(cch + 15));

    // Copy File Name
    StrCpyNW(pszDstFile, m_pShare->szFile, (cch+15));

    // Change the Extension
    PathRenameExtensionW(pszDstFile, L".dbt");

    // Delete that file
    DeleteFileWrapW(pszDstFile);

    // Delete my Current File
    if (PathFileExistsW(pszDstFile))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Loop through the stream table and see if there are any streams open for a write
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is In use...
        if (TRUE == m_pShare->rgStream[i].fInUse && LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock)
        {
            hr = TraceResult(DB_E_COMPACT_PREEMPTED);
            goto exit;
        }
    }

    // If there are pending notifications...
    if (m_pHeader->cTransacts > 0)
    {
        hr = TraceResult(DB_E_DATABASE_CHANGED);
        goto exit;
    }

    // Is there enought disk space where pDstDB is located
    IF_FAILEXIT(hr = GetAvailableDiskSpace(m_pShare->szFile, &dwlFree));

    // Compute cbWasted
    cbWasted = (m_pHeader->cbFreed + (m_pStorage->cbFile - m_pHeader->faNextAllocate));

    // Is there enough disk space ?
    if (dwlFree <= ((DWORDLONG) (m_pStorage->cbFile - cbWasted)))
    {
        hr = TraceResult(DB_E_DISKFULL);
        goto exit;
    }

    // Create the Object Database Object
    IF_NULLEXIT(pDstDB = new CDatabase);

    // Open the Table
    IF_FAILEXIT(hr = pDstDB->Open(pszDstFile, OPEN_DATABASE_NOEXTENSION | OPEN_DATABASE_NOMONITOR, m_pSchema, NULL));

    // Lock the Destination Database
    IF_FAILEXIT(hr = pDstDB->Lock(&hDstLock));

    // Get user info from current tree
    if (m_pSchema->cbUserData)
    {
        // Set the user data
        IF_FAILEXIT(hr = pDstDB->SetUserData(PUSERDATA(m_pHeader), m_pSchema->cbUserData));
    }

    // I'm going to grow the destination to be as big as the current file (I will truncate when finished)
    IF_FAILEXIT(hr = pDstDB->SetSize(m_pStorage->cbFile - cbWasted));

    // Set number of indexes
    pDstDB->m_pHeader->cIndexes = m_pHeader->cIndexes;

    // Copy Index Information...
    CopyMemory((LPBYTE)pDstDB->m_pHeader->rgIndexInfo, (LPBYTE)m_pHeader->rgIndexInfo, sizeof(TABLEINDEX) * CMAX_INDEXES);

    // Copy Index Information...
    CopyMemory((LPBYTE)pDstDB->m_pHeader->rgiIndex, (LPBYTE)m_pHeader->rgiIndex, sizeof(INDEXORDINAL) * CMAX_INDEXES);

    // Transfer Query Table...
    IF_FAILEXIT(hr = _CompactTransferFilters(pDstDB));

    // Allocate a Record
    IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

    // Create a Rowset
    IF_FAILEXIT(hr = CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Save new Version
    dwVersion = m_pShare->dwVersion;

    // While we have a node address
    while (S_OK == QueryRowset(hRowset, 1, (LPVOID *)pBinding, NULL))
    {
        // Can Preempt
        if (ISFLAGSET(dwFlags, COMPACT_PREEMPTABLE) && m_pShare->cWaitingForLock > 0)
        {
            hr = TraceResult(DB_E_COMPACT_PREEMPTED);
            goto exit;
        }

        // If the record has streams
        if (ISFLAGSET(m_pSchema->dwFlags, TSF_HASSTREAMS))
        {
            // Compact Move Record Streams
            IF_FAILEXIT(hr = _CompactMoveRecordStreams(pDstDB, pBinding));
        }

        // Insert Record Into Destination
        hr = pDstDB->_CompactInsertRecord(pBinding);

        // Duplicate
        if (DB_E_DUPLICATE == hr)
        {
            // Trace
            TraceResult(DB_E_DUPLICATE);

            // Reset Hr
            hr = S_OK;

            // Count
            cDuplicates++;
        }

        // Failed ?
        else if (FAILED (hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Count
        cRecords++;

        // Free this Record
        FreeRecord(pBinding);

        // Update the Progress...
        if (pProgress)
        {
            // Call into the progress object
            IF_FAILEXIT(hr = pProgress->Update(1));

            // Version Change ?
            if (dwVersion != m_pShare->dwVersion || m_pHeader->cTransacts > 0)
            {
                hr = TraceResult(DB_E_DATABASE_CHANGED);
                goto exit;
            }
        }

        // Yield
        if (ISFLAGSET(dwFlags, COMPACT_YIELD))
        {
            // this will force this thread to give up a time-slice
            Sleep(0);
        }
    }

    // Duplicates ?
    AssertSz(cDuplicates == 0, "Duplicates were found in the tree. They have been eliminated.");

    // Copy over deleted streams that are currently open...
    IF_FAILEXIT(hr = _CompactMoveOpenDeletedStreams(pDstDB));

    // Number of records better be equal
    AssertSz(cRecords == m_pHeader->rgcRecords[0], "Un-expected number of records compacted");

    // Save dwNextId
    dwNextId = m_pHeader->dwNextId;

    // Save Active Threads
    cActiveThreads = m_pHeader->cActiveThreads;

    // Compute amount to decrease the file by
    cbDecrease = (pDstDB->m_pStorage->cbFile - pDstDB->m_pHeader->faNextAllocate);

    // Reduce the Size of myself...
    IF_FAILEXIT(hr = pDstDB->_SetStorageSize(pDstDB->m_pStorage->cbFile - cbDecrease));

    // Unlock the file
    pDstDB->Unlock(&hDstLock);

    // Release pDstDB
    SafeRelease(pDstDB);

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_CLOSEFILE));

    // Delete my Current File
    if (0 == DeleteFileWrapW(m_pShare->szFile))
    {
        // Failure
        hr = TraceResult(E_FAIL);

        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);

        // Done
        goto exit;
    }

    // Move the file from the temp location to my current location
    if (0 == MoveFileWrapW(pszDstFile, m_pShare->szFile))
    {
        // Trace
        hr = TraceResult(DB_E_MOVEFILE);

        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);

        // Done
        goto exit;
    }

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_OPENFILE));

    // Reset Active Thread Count
    m_pHeader->cActiveThreads = cActiveThreads;

    // Reset dwNextId
    m_pHeader->dwNextId = dwNextId;

    // Reset Notification Queue
    Assert(0 == m_pHeader->faTransactHead && 0 == m_pHeader->faTransactTail);

    // Reset Transaction List
    m_pHeader->faTransactHead = m_pHeader->faTransactTail = m_pHeader->cTransacts = 0;

    // Reset Share Transacts
    m_pShare->faTransactLockHead = m_pShare->faTransactLockTail = 0;

    // Loop through the stream table and adjust the start address of all open streams
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is In use...
        if (TRUE == m_pShare->rgStream[i].fInUse)
        {
            // Change the Address
            m_pShare->rgStream[i].faStart = m_pShare->rgStream[i].faMoved;
        }
    }

    // Build the Update Notification Package
    _LogTransaction(TRANSACTION_COMPACTED, INVALID_INDEX_ORDINAL, NULL, 0, 0);

exit:
    // Close my rowset
    CloseRowset(&hRowset);

    // Release Dst Lock
    if (pDstDB && hDstLock)
        pDstDB->Unlock(&hDstLock);

    // Release the memory mapped pointers
    SafeRelease(pDstDB);

    // Free the Record
    SafeFreeBinding(pBinding);

    // No Longer compacting
    m_pShare->fCompacting = FALSE;

    // Delete pszDstFile
    if (pszDstFile)
    {
        // Delete the file
        DeleteFileWrapW(pszDstFile);

        // Remaining Cleanup
        SafeMemFree(pszDstFile);
    }

    // Reset Yield
    m_fCompactYield = FALSE;

    // Release Locks
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CheckForCorruption
//--------------------------------------------------------------------------
HRESULT CDatabase::_CheckForCorruption(void)
{
    // Locals
    HRESULT                  hr=S_OK;
    ULONG                    cRecords;
    DWORD                    i;
    HRESULT                  rghrCorrupt[CMAX_INDEXES]={0};
    DWORD                    cCorrupt=0;
    INDEXORDINAL             iIndex;

    // Trace
    TraceCall("CDatabase::_CheckForCorruption");

    // We should not be currently repairing
    Assert(FALSE == m_pShare->fRepairing);

    // We are now repairing
    IF_DEBUG(m_pShare->fRepairing = TRUE);

    // Walk Through the Indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Zero Out cRecords
        cRecords = 0;

        // Assume all is good
        rghrCorrupt[iIndex] = S_OK;

        // Start at the root 
        if (m_pHeader->rgfaIndex[iIndex])
        {
            // Validate the Index
            rghrCorrupt[iIndex] = _ValidateIndex(iIndex, m_pHeader->rgfaIndex[iIndex], 0, &cRecords);
        }

        // If Not Corrupt, validate the record counts
        if (DB_E_CORRUPT != rghrCorrupt[iIndex] && m_pHeader->rgcRecords[iIndex] != cRecords)
        {
            // Its Corrupt
            rghrCorrupt[iIndex] = TraceResult(DB_E_CORRUPT);
        }

        // If Corrupt
        if (DB_E_CORRUPT == rghrCorrupt[iIndex])
        {
            // Count Number of Corrupted records
            cCorrupt += m_pHeader->rgcRecords[iIndex];
        }
    }

    // Are the Corrupt Records
    if (cCorrupt > 0 || m_pHeader->fCorrupt)
    {
        // I'm going to nuke the free block tables since they may also be corrupted...
        ZeroMemory(m_pHeader->rgfaFreeBlock, sizeof(FILEADDRESS) * CC_FREE_BUCKETS);

        // Reset Fixed blocks
        m_pHeader->faFreeStreamBlock = m_pHeader->faFreeChainBlock = m_pHeader->faFreeLargeBlock = 0;

        // Nuke the Transaction List
        m_pHeader->cTransacts = m_pHeader->faTransactHead = m_pHeader->faTransactTail = 0;

        // Nuke The Fixed Block Allocation Pages
        ZeroMemory(&m_pHeader->AllocateRecord, sizeof(ALLOCATEPAGE));
        ZeroMemory(&m_pHeader->AllocateChain, sizeof(ALLOCATEPAGE));
        ZeroMemory(&m_pHeader->AllocateStream, sizeof(ALLOCATEPAGE));

        // Reset rgcbAllocated
        ZeroMemory(m_pHeader->rgcbAllocated, sizeof(DWORD) * CC_MAX_BLOCK_TYPES);

        // Reset faNextAllocate
        m_pHeader->faNextAllocate = m_pStorage->cbFile;

        // Walk Through the Indexes
        for (i = 0; i < m_pHeader->cIndexes; i++)
        {
            // Get Index Ordinal
            iIndex = m_pHeader->rgiIndex[i];

            // If Corrupt
            if (DB_E_CORRUPT == rghrCorrupt[iIndex])
            {
                // Not Corrupt
                m_pHeader->fCorrupt = TRUE;

                // Rebuild the Index
                IF_FAILEXIT(hr = _RebuildIndex(iIndex));
            }
        }
    }

    // Not Corrupt
    m_pHeader->fCorrupt = FALSE;

    // This causes all current file views to be flushed and released. Insures we are in a good state.
#ifdef BACKGROUND_MONITOR
    DoBackgroundMonitor();
#else
    CloseFileViews(TRUE);
#endif

exit:
    // We are now repairing
    IF_DEBUG(m_pShare->fRepairing = FALSE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeIndex(FILEADDRESS faChain)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_FreeIndex");

    // Nothing to validate
    if (0 == faChain)
        return(S_OK);

    // Validate faChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Go to the left
    IF_FAILEXIT(hr = _FreeIndex(pChain->faLeftChain));

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Validate the Right Chain
        IF_FAILEXIT(hr = _FreeIndex(pChain->rgNode[i].faRightChain));
    }

    // Free this Chain
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faChain));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateIndex(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, ULONG cLeftNodes, ULONG *pcRecords)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;
    LPRECORDBLOCK   pRecord;
    DWORD           cLeafs=0;
    DWORD           cNodes;
    RECORDMAP       Map;

    // Trace
    TraceCall("CDatabase::_ValidateIndex");

    // Nothing to validate
    Assert(0 != faChain);

    // Get Chain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faBlock != m_pHeader->rgfaIndex[iIndex])
        return TraceResult(DB_E_CORRUPT);

    // Validate faParent
    if (pChain->faParent)
    {
        // Locals
        LPCHAINBLOCK pParent;

        // Get Parent
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->faParent, (LPVOID *)&pParent));

        // Validate iParent
        if (pChain->iParent >= pParent->cNodes)
            return TraceResult(DB_E_CORRUPT);

        // Validate the Parent Pointer
        if (0 == pChain->iParent)
        {
            // Validation
            if (pParent->rgNode[pChain->iParent].faRightChain != pChain->faBlock && pParent->faLeftChain != pChain->faBlock)
                return TraceResult(DB_E_CORRUPT);
        }

        // Otherwise
        else if (pParent->rgNode[pChain->iParent].faRightChain != pChain->faBlock)
            return TraceResult(DB_E_CORRUPT);
    }

    // Otherwise, iParent should be zero...
    else
    {
        // This is the root chain
        if (m_pHeader->rgfaIndex[iIndex] != pChain->faBlock)
            return TraceResult(DB_E_CORRUPT);

        // iParent should be 0
        Assert(pChain->iParent == 0);
    }

    // Do the Left
    if (pChain->faLeftChain)
    {
        // Go to the left
        IF_FAILEXIT(hr = _ValidateIndex(iIndex, pChain->faLeftChain, cLeftNodes, pcRecords));
    }

    // cNodes
    cNodes = pChain->cLeftNodes;

    // Validate the Records in this chain
    for (i=0; i<pChain->cNodes; i++)
    {
        // Count the number of leaf nodes
        cLeafs += (0 == pChain->rgNode[i].faRightChain) ? 1 : 0;

        // cNodes
        cNodes += pChain->rgNode[i].cRightNodes;
    }

    // Validate the Number of Leafs
    if (cLeafs > 0 && cLeafs != (DWORD)pChain->cNodes)
        return TraceResult(DB_E_CORRUPT);

    // No leafs, but their are child nodes, or vice vera...
    if ((0 != cLeafs && 0 != cNodes) || (0 == cLeafs && 0 == cNodes))
        return TraceResult(DB_E_CORRUPT);

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Try to get the record, if the block is invalid, we will throw away the record
        if (SUCCEEDED(_GetBlock(BLOCK_RECORD, pChain->rgNode[i].faRecord, (LPVOID *)&pRecord, FALSE)))
        {
            // Validate Block...
            if (SUCCEEDED(_GetRecordMap(FALSE, pRecord, &Map)))
            {
                // Validate and Repair the Record
                if (S_OK == _ValidateAndRepairRecord(&Map))
                {
                    // Count Records
                    (*pcRecords)++;
                }
            }
        }

        // First Node ?
        if (0 == i)
        {
            // Increment cLeft Nodes
            cLeftNodes += pChain->cLeftNodes;
        }

        // Otherwise
        else 
        {
            // Increment cLeftNodes
            cLeftNodes += pChain->rgNode[i - 1].cRightNodes;
        }

        // Failure
        if ((*pcRecords) != cLeftNodes + 1)
            return TraceResult(DB_E_CORRUPT);

        // Increment cLeftNodes
        cLeftNodes++;

        // Do the Right
        if (pChain->rgNode[i].faRightChain)
        {
            // Validate the Right Chain
            IF_FAILEXIT(hr = _ValidateIndex(iIndex, pChain->rgNode[i].faRightChain, cLeftNodes, pcRecords));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RebuildIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_RebuildIndex(INDEXORDINAL iIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pBinding=NULL;
    DWORD           cRecords=0;
    FILEADDRESS     faPrimary;

    // Trace
    TraceCall("CDatabase::_RebuildIndex");

    // Allocate a record
    IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

    // Save Primary Index Starting Address
    faPrimary = m_pHeader->rgfaIndex[IINDEX_PRIMARY];

    // Reset rgfaIndex[iIndex]
    m_pHeader->rgfaIndex[iIndex] = 0;

    // Is there a root chain ?
    if (faPrimary)
    {
        // Recursively Rebuild this index
        IF_FAILEXIT(hr = _RecursiveRebuildIndex(iIndex, faPrimary, pBinding, &cRecords));
    }

    // Fixup Record Count
    m_pHeader->rgcRecords[iIndex] = cRecords;

    // Send Notifications ?
    if (m_pShare->rgcIndexNotify[iIndex] > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_INDEX_CHANGED, iIndex, NULL, 0, 0);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBinding);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RecursiveRebuildIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_RecursiveRebuildIndex(INDEXORDINAL iIndex, 
    FILEADDRESS faCurrent, LPVOID pBinding, LPDWORD pcRecords)
{
    // Locals
    NODEINDEX       i;
    FILEADDRESS     faRecord;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    CHAINBLOCK      Chain;
    LPCHAINBLOCK    pChain;
    INT             nCompare;
    BOOL            fGoodRecord=TRUE;
    RECORDMAP       Map;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::_RecursiveRebuildIndex");

    // Nothing to validate
    Assert(0 != faCurrent);

    // Validate faChain
    if (FAILED(_GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pChain)))
        return(S_OK);

    // Copy This
    CopyMemory(&Chain, pChain, sizeof(CHAINBLOCK));

    // Do the left
    if (Chain.faLeftChain)
    {
        // Go to the left
        _RecursiveRebuildIndex(iIndex, Chain.faLeftChain, pBinding, pcRecords);
    }

    // Loop throug right chains
    for (i=0; i<Chain.cNodes; i++)
    {
        // Set faRecord
        faRecord = Chain.rgNode[i].faRecord;

        // Get the Block
        if (SUCCEEDED(_GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecord, NULL, FALSE)))
        {
            // Rebuilding Primary Index ?
            if (IINDEX_PRIMARY == iIndex)
            {
                // Assume this is a bad record
                fGoodRecord = FALSE;

                // Try to get the record map
                if (SUCCEEDED(_GetRecordMap(FALSE, pRecord, &Map)))
                {
                    // Validate Map ?
                    if (S_OK == _ValidateAndRepairRecord(&Map))
                    {
                        // Good Record
                        fGoodRecord = TRUE;
                    }
                }
            }

            // Good Record ?
            if (fGoodRecord)
            {
                // Load the Record
                if (SUCCEEDED(_ReadRecord(faRecord, pBinding, TRUE)))
                {
                    // Reset hrVisible
                    if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
                    {
                        // Otherwise: Decide Where to insert
                        if (DB_S_NOTFOUND == _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, NULL, &nCompare))
                        {
                            // Insert the Record
                            if (SUCCEEDED(_IndexInsertRecord(iIndex, faChain, faRecord, &iNode, nCompare)))
                            {
                                // Increment Record Count
                                (*pcRecords)++;
                            }
                        }
                    }
                }
            }
        }

        // Do the Right
        if (Chain.rgNode[i].faRightChain)
        {
            // Index the Right Chain
            _RecursiveRebuildIndex(iIndex, Chain.rgNode[i].faRightChain, pBinding, pcRecords);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateStream
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateStream(FILEADDRESS faStart)
{
    // Locals
    LPSTREAMBLOCK   pStream;
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_ValidateStream");

    // No Stream
    if (0 == faStart)
        return(S_OK);

    // Initialize Loop
    faCurrent = faStart;

    // Read through all of the blocks (i.e. verify headers and count the number of chains)
    while (faCurrent)
    {
        // Valid stream Block
        if (FAILED(_GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pStream)))
            return(S_FALSE);

        // Validate cbData
        if (pStream->cbData > pStream->cbSize)
            return(S_FALSE);

        // Set faCurrent
        faCurrent = pStream->faNext;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateAndRepairRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateAndRepairRecord(LPRECORDMAP pMap)
{
    // Locals
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;
    WORD            iTag;

    // Trace
    TraceCall("CDatabase::_ValidateAndRepairRecord");

    // Walk through the Tags of the Record
    for (iTag=0; iTag<pMap->cTags; iTag++)
    {
        // Readability
        pTag = &pMap->prgTag[iTag];

        // Validate the Tag
        if (pTag->iColumn >= m_pSchema->cColumns)
            return(S_FALSE);

        // De-ref the Column
        pColumn = &m_pSchema->prgColumn[pTag->iColumn];

        // Read the Data
        if (S_FALSE == DBTypeValidate(pColumn, pTag, pMap))
            return(S_FALSE);

        // Is this a stream ?
        if (CDT_STREAM == pColumn->type)
        {
            // Locals
            FILEADDRESS faStream;

            // Get the faStream
            if (1 == pTag->fData) 
                faStream = pTag->Offset;
            else
                faStream = *((DWORD *)(pMap->pbData + pTag->Offset));

            // Validate this stream...
            if (S_FALSE == _ValidateStream(faStream))
            {
                // Kill the stream address...
                if (1 == pTag->fData) 
                    pTag->Offset = 0;
                else
                    *((DWORD *)(pMap->pbData + pTag->Offset)) = 0;
            }
        }

        // Unique Key ?
        if (CDT_UNIQUE == pColumn->type)
        {
            // Locals
            DWORD dwUniqueID;

            // Get the dwUniqueID
            if (1 == pTag->fData) 
                dwUniqueID = pTag->Offset;
            else
                dwUniqueID = *((DWORD *)(pMap->pbData + pTag->Offset));

            // Adjust the id in the header ?
            if (dwUniqueID >= m_pHeader->dwNextId)
                m_pHeader->dwNextId = dwUniqueID + 1;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRecordMap
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRecordMap(BOOL fGoCorrupt, LPRECORDBLOCK pBlock, 
    LPRECORDMAP pMap)
{
    // Trace
    TraceCall("CDatabase::_GetRecordMap");

    // Invalid Args
    Assert(pBlock && pMap);

    // Set pSchema
    pMap->pSchema = m_pSchema;

    // Store Number of Tags
    pMap->cTags = min(pBlock->cTags, m_pSchema->cColumns);

    // Set prgTag
    pMap->prgTag = (LPCOLUMNTAG)((LPBYTE)pBlock + sizeof(RECORDBLOCK));

    // Compute Size of Tags
    pMap->cbTags = (pBlock->cTags * sizeof(COLUMNTAG));

    // Compute Size of Data
    pMap->cbData = (pBlock->cbSize - pMap->cbTags);

    // Set pbData
    pMap->pbData = (LPBYTE)((LPBYTE)pBlock + sizeof(RECORDBLOCK) + pMap->cbTags);

    // No Tags - this is usually the sign of a freeblock that was reused but not allocated
    if (0 == pMap->cTags)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // Too many tags
    if (pMap->cTags > m_pSchema->cColumns)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // cbTags is too large ?
    if (pMap->cbTags > pBlock->cbSize)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // Done
    return(S_OK);
}

#ifdef DEBUG
//--------------------------------------------------------------------------
// DBDebugValidateRecordFormat
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateRecordFormat(void)
{
    // Locals
    ULONG           i;
    DWORD           dwOrdinalPrev=0;
    DWORD           dwOrdinalMin=0xffffffff;
    DWORD           dwOrdinalMax=0;

    // Validate memory buffer binding offset
    Assert(0xFFFFFFFF != m_pSchema->ofMemory && m_pSchema->ofMemory < m_pSchema->cbBinding);

    // Validate version binding offset
    Assert(0xFFFFFFFF != m_pSchema->ofVersion && m_pSchema->ofVersion < m_pSchema->cbBinding);

    // Validate Extension
    Assert(*m_pSchema->pclsidExtension != CLSID_NULL);

    // Validate Version
    Assert(m_pSchema->dwMinorVersion != 0);

    // Check Number of Indexes
    Assert(m_pSchema->pPrimaryIndex);

    // Loop through they Keys
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // This Ordinal better be larger than the previous
        if (i > 0)
            Assert(m_pSchema->prgColumn[i].iOrdinal > dwOrdinalPrev);

        // Save Min Ordinal
        if (m_pSchema->prgColumn[i].iOrdinal < dwOrdinalMin)
            dwOrdinalMin = m_pSchema->prgColumn[i].iOrdinal;

        // Save Max Ordinal
        if (m_pSchema->prgColumn[i].iOrdinal > dwOrdinalMax)
            dwOrdinalMax = m_pSchema->prgColumn[i].iOrdinal;

        // Save the Previous Ordinal
        dwOrdinalPrev = m_pSchema->prgColumn[i].iOrdinal;
    }

    // Min ordinal must be one
    Assert(dwOrdinalMin == 0);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// _DebugValidateUnrefedRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateUnrefedRecord(FILEADDRESS faRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CDatabase::_DebugValidateUnrefedRecord");

    // Walk Through the Indexes
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Start at the root 
        if (m_pHeader->rgfaIndex[iIndex])
        {
            // Validate the Index
            IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(m_pHeader->rgfaIndex[iIndex], faRecord));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DebugValidateIndexUnrefedRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateIndexUnrefedRecord(FILEADDRESS faChain,
    FILEADDRESS faRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_DebugValidateIndexUnrefedRecord");

    // Nothing to validate
    Assert(0 != faChain);

    // Validate faChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Do the left
    if (pChain->faLeftChain)
    {
        // Go to the left
        IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(pChain->faLeftChain, faRecord));
    }

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Set faRecord
        if (faRecord == pChain->rgNode[i].faRecord)
        {
            IxpAssert(FALSE);
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Do the Right
        if (pChain->rgNode[i].faRightChain)
        {
            // Index the Right Chain
            IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(pChain->rgNode[i].faRightChain, faRecord));
        }
    }

exit:
    // Done
    return(hr);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\listen.h ===
//--------------------------------------------------------------------------
// Listen.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabase;

//--------------------------------------------------------------------------
// HMONITORDBDB
//--------------------------------------------------------------------------
#ifdef BACKGROUND_MONITOR
DECLARE_HANDLE(HMONITORDB);
typedef HMONITORDB *LPHMONITORDB;
#endif

//--------------------------------------------------------------------------
// Notification Window Messages
//--------------------------------------------------------------------------
#define WM_ONTRANSACTION (WM_USER + 100)

//--------------------------------------------------------------------------
// Window Class Names
//--------------------------------------------------------------------------
extern const LPSTR g_szDBListenWndProc;
extern const LPSTR g_szDBNotifyWndProc;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
ULONG ListenThreadAddRef(void);
ULONG ListenThreadRelease(void);
HRESULT CreateListenThread(void);
HRESULT GetListenWindow(HWND *phwndListen);
HRESULT CreateNotifyWindow(CDatabase *pDB, IDatabaseNotify *pNotify, HWND *phwndThunk);
#ifdef BACKGROUND_MONITOR
HRESULT RegisterWithMonitor(CDatabase *pDB, LPHMONITORDB phMonitor);
HRESULT UnregisterFromMonitor(CDatabase *pDB, LPHMONITORDB phMonitor);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\dll\factory.h ===
//----------------------------------------------------------------------
// Factory.h
//----------------------------------------------------------------------
#pragma once

//----------------------------------------------------------------------
// Forward Decls
//----------------------------------------------------------------------
class CClassFactory;

//----------------------------------------------------------------------
// Object Flags
//----------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

//----------------------------------------------------------------------
// Object Creation Prototypes
//----------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

//----------------------------------------------------------------------
// InetComm ClassFactory
//----------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    //----------------------------------------------------------------------
    // Public Data
    //----------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    //----------------------------------------------------------------------
    // IUnknown members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IClassFactory members
    //----------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\query.cpp ===
//--------------------------------------------------------------------------
// Query.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "query.h"
#include "shlwapi.h"
#include "strconst.h"

//--------------------------------------------------------------------------
// OPERATORTYPE
//--------------------------------------------------------------------------
typedef enum tagOPERATORTYPE {
    OPERATOR_LEFTPAREN,
    OPERATOR_RIGHTPAREN,
    OPERATOR_EQUAL,
    OPERATOR_NOTEQUAL,
    OPERATOR_LESSTHANEQUAL,
    OPERATOR_LESSTHAN,
    OPERATOR_GREATERTHANEQUAL,
    OPERATOR_GREATERTHAN,
    OPERATOR_AND,
    OPERATOR_BITWISEAND,
    OPERATOR_OR,
    OPERATOR_BITWISEOR,
    OPERATOR_STRSTRI,
    OPERATOR_STRSTR,
    OPERATOR_LSTRCMPI,
    OPERATOR_LSTRCMP,
    OPERATOR_ADD,
    OPERATOR_SUBTRACT,
    OPERATOR_MULTIPLY,
    OPERATOR_DIVIDE,
    OPERATOR_MOD,
    OPERATOR_LAST
} OPERATORTYPE;

//--------------------------------------------------------------------------
// TOKENTYPE
//--------------------------------------------------------------------------
typedef enum tagTOKENTYPE {
    TOKEN_INVALID,
    TOKEN_OPERATOR,
    TOKEN_OPERAND
} TOKENTYPE;

//--------------------------------------------------------------------------
// OPERANDTYPE
//--------------------------------------------------------------------------
typedef enum tagOPERANDTYPE {
    OPERAND_INVALID,
    OPERAND_COLUMN,
    OPERAND_STRING,
    OPERAND_DWORD,
    OPERAND_METHOD,
    OPERAND_LAST
} OPERANDTYPE;

//--------------------------------------------------------------------------
// OPERANDINFO
//--------------------------------------------------------------------------
typedef struct tagOPERANDINFO {
    OPERANDTYPE         tyOperand;
    DWORD               iSymbol;
    LPVOID              pRelease;
    union {
        COLUMNORDINAL   iColumn;        // OPERAND_COLUMN
        LPSTR           pszString;      // OPERAND_STRING
        DWORD           dwValue;        // OPERAND_DWORD
        METHODID        idMethod;       // OPERAND_METHOD
    };
    DWORD               dwReserved;
} OPERANDINFO, *LPOPERANDINFO;

//--------------------------------------------------------------------------
// QUERYTOKEN
//--------------------------------------------------------------------------
typedef struct tagQUERYTOKEN *LPQUERYTOKEN;
typedef struct tagQUERYTOKEN {
    TOKENTYPE           tyToken;
    DWORD               cRefs;
    union {
        OPERATORTYPE    tyOperator;     // TOKEN_OPERATOR
        OPERANDINFO     Operand;        // TOKEN_OPERAND
    };
    LPQUERYTOKEN        pNext;
    LPQUERYTOKEN        pPrevious;
} QUERYTOKEN;

//--------------------------------------------------------------------------
// PFNCOMPAREOPERAND - Compares Two Operands of the same type
//--------------------------------------------------------------------------
typedef INT (APIENTRY *PFNCOMPAREOPERAND)(LPVOID pDataLeft, LPVOID pDataRight);
#define PCOMPARE(_pfn) ((PFNCOMPAREOPERAND)_pfn)

//--------------------------------------------------------------------------
// CompareOperandString
//--------------------------------------------------------------------------
INT CompareOperandString(LPVOID pDataLeft, LPVOID pDataRight) {
    return(lstrcmpi((LPSTR)pDataLeft, (LPSTR)pDataRight));
}

//--------------------------------------------------------------------------
// CompareOperandDword
//--------------------------------------------------------------------------
INT CompareOperandDword(LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) - *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// g_rgpfnCompareOperand
//--------------------------------------------------------------------------
const static PFNCOMPAREOPERAND g_rgpfnCompareOperand[OPERAND_LAST] = {
    NULL,                           // OPERAND_INVALID        
    NULL,                           // OPERAND_COLUMN
    PCOMPARE(CompareOperandString), // OPERAND_STRING
    PCOMPARE(CompareOperandDword)   // OPERAND_DWORD
};

//--------------------------------------------------------------------------
// CompareOperands
//--------------------------------------------------------------------------
#define CompareOperands(_tyOperand, _pDataLeft, _pDataRight) \
    (*(g_rgpfnCompareOperand[_tyOperand]))(_pDataLeft, _pDataRight)

//--------------------------------------------------------------------------
// PFNEVALUATEOPERATOR - Compares data in two flat records.
//--------------------------------------------------------------------------
typedef DWORD (APIENTRY *PFNEVALUATEOPERATOR)(OPERANDTYPE tyOperand, 
    LPVOID pDataLeft, LPVOID pDataRight);
#define PEVAL(_pfn) ((PFNEVALUATEOPERATOR)_pfn)

//--------------------------------------------------------------------------
// Evaluate Operator Prototypes
//--------------------------------------------------------------------------
DWORD EvaluateEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateNotEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateLessThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateLessThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateGreaterThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateGreaterThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateBitwiseAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateBitwiseOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrStrI(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrStr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrcmpi(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrcmp(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateAdd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateSubtract(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateMultiply(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateDivide(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateModula(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);

//--------------------------------------------------------------------------
// OPERATORINFO
//--------------------------------------------------------------------------
typedef struct tagOPERATORINFO {
    LPCSTR              pszName;
    BYTE                bISP;
    BYTE                bICP;
    PFNEVALUATEOPERATOR pfnEvaluate;
} OPERATORINFO, *LPOPERATORINFO;

//--------------------------------------------------------------------------
// Operator Precedence Table
//--------------------------------------------------------------------------
static const OPERATORINFO g_rgOperator[OPERATOR_LAST] = {
    // Name         ISP     ICP     Function
    { "(",          6,      0,      NULL                                }, // OPERATOR_LEFTPAREN
    { ")",          1,      1,      NULL                                }, // OPERATOR_RIGHTPAREN
    { "==",         5,      5,      PEVAL(EvaluateEqual)                }, // OPERATOR_EQUAL
    { "!=",         5,      5,      PEVAL(EvaluateNotEqual)             }, // OPERATOR_NOTEQUAL
    { "<=",         5,      5,      PEVAL(EvaluateLessThanEqual)        }, // OPERATOR_LESSTHANEQUAL
    { "<",          5,      5,      PEVAL(EvaluateLessThan)             }, // OPERATOR_LESSTHAN
    { ">=",         5,      5,      PEVAL(EvaluateGreaterThanEqual)     }, // OPERATOR_GREATERTHANEQUAL
    { ">",          5,      5,      PEVAL(EvaluateGreaterThan)          }, // OPERATOR_GREATERTHAN
    { "&&",         4,      4,      PEVAL(EvaluateAnd)                  }, // OPERATOR_AND
    { "&",          3,      3,      PEVAL(EvaluateBitwiseAnd)           }, // OPERATOR_BITWISEAND
    { "||",         4,      4,      PEVAL(EvaluateOr)                   }, // OPERATOR_OR
    { "|",          3,      3,      PEVAL(EvaluateBitwiseOr)            }, // OPERATOR_BITWISEOR
    { "containsi",  5,      5,      PEVAL(EvaluateStrStrI)              }, // OPERATOR_STRSTRI
    { "contains",   5,      5,      PEVAL(EvaluateStrStr)               }, // OPERATOR_STRSTR
    { "comparei",   5,      5,      PEVAL(EvaluateStrcmpi)              }, // OPERATOR_LSTRCMPI
    { "compare",    5,      5,      PEVAL(EvaluateStrcmp)               }, // OPERATOR_LSTRCMP
    { "+",          4,      4,      PEVAL(EvaluateAdd)                  }, // OPERATOR_ADD,
    { "-",          4,      4,      PEVAL(EvaluateSubtract)             }, // OPERATOR_SUBTRACT,
    { "*",          3,      3,      PEVAL(EvaluateMultiply)             }, // OPERATOR_MULTIPLY,
    { "/",          3,      3,      PEVAL(EvaluateDivide)               }, // OPERATOR_DIVIDE,
    { "%",          3,      3,      PEVAL(EvaluateModula)               }, // OPERATOR_MOD,
};

//--------------------------------------------------------------------------
// EvaluateOperator
//--------------------------------------------------------------------------
#define EvaluateOperator(_tyOperator, _tyOperand, _pDataLeft, _pDataRight) \
    (*(g_rgOperator[_tyOperator].pfnEvaluate))(_tyOperand, _pDataLeft, _pDataRight)

//--------------------------------------------------------------------------
// MAPCOLUMNTYPE
//--------------------------------------------------------------------------
typedef void (APIENTRY *PFNMAPCOLUMNTYPE)(LPOPERANDINFO pOperand, 
    LPCTABLECOLUMN pColumn, LPVOID pBinding, LPVOID *ppValue);
#define PMAP(_pfn) ((PFNMAPCOLUMNTYPE)_pfn)

//--------------------------------------------------------------------------
// MapColumnString
//--------------------------------------------------------------------------
void MapColumnString(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    (*ppValue) = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
}

//--------------------------------------------------------------------------
// MapColumnByte
//--------------------------------------------------------------------------
void MapColumnByte(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// MapColumnDword
//--------------------------------------------------------------------------
void MapColumnDword(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// MapColumnWord
//--------------------------------------------------------------------------
void MapColumnWord(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// COLUMNTYPEINFO
//--------------------------------------------------------------------------
typedef struct tagCOLUMNTYPEINFO {
    OPERANDTYPE         tyOperand;
    PFNMAPCOLUMNTYPE    pfnMapColumnType;
} COLUMNTYPEINFO, *LPCOLUMNTYPEINFO;

//--------------------------------------------------------------------------
// g_rgColumnTypeInfo
//--------------------------------------------------------------------------
static const COLUMNTYPEINFO g_rgColumnTypeInfo[CDT_LASTTYPE] = {
    { OPERAND_INVALID, NULL                     }, // CDT_FILETIME,
    { OPERAND_STRING,  PMAP(MapColumnString)    }, // CDT_FIXSTRA,
    { OPERAND_STRING,  PMAP(MapColumnString)    }, // CDT_VARSTRA,
    { OPERAND_DWORD,   PMAP(MapColumnByte)      }, // CDT_BYTE,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_DWORD,
    { OPERAND_DWORD,   PMAP(MapColumnWord)      }, // CDT_WORD,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_STREAM,
    { OPERAND_INVALID, NULL                     }, // CDT_VARBLOB,
    { OPERAND_INVALID, NULL                     }, // CDT_FIXBLOB,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_FLAGS,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_UNIQUE
};

//--------------------------------------------------------------------------
// MapColumnType
//--------------------------------------------------------------------------
#define MapColumnType(_tyColumn, _pOperand, _pColumn, _pBinding, _ppValue) \
    (*(g_rgColumnTypeInfo[_tyColumn].pfnMapColumnType))(_pOperand, _pColumn, _pBinding, _ppValue)

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT GetNextQueryToken(LPSTR *ppszT, LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppToken, CDatabase *pDB);
HRESULT LinkToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppHead, LPQUERYTOKEN *ppTail);
HRESULT ReleaseTokenList(BOOL fReverse, LPQUERYTOKEN *ppHead, CDatabase *pDB);
HRESULT ReleaseToken(LPQUERYTOKEN *ppToken, CDatabase *pDB);
HRESULT ParseStringLiteral(LPCSTR pszStart, LPOPERANDINFO pOperand, LPSTR *ppszEnd, CDatabase *pDB);
HRESULT ParseNumeric(LPCSTR pszT, LPOPERANDINFO pOperand, LPSTR *ppszEnd);
HRESULT ParseSymbol(LPCSTR pszT, LPCTABLESCHEMA pSchema, LPOPERANDINFO pOperand, LPSTR *ppszEnd, CDatabase *pDB);
HRESULT PushStackToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppStackTop);
HRESULT PopStackToken(LPQUERYTOKEN *ppToken, LPQUERYTOKEN *ppStackTop);
HRESULT EvaluateClause(OPERATORTYPE tyOperator, LPVOID pBinding, LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppStackTop, CDatabase *pDB, IDatabaseExtension *pExtension);
IF_DEBUG(HRESULT DebugDumpExpression(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPQUERYTOKEN pPostfixHead));

//--------------------------------------------------------------------------
// ISP inline
//--------------------------------------------------------------------------
inline BYTE ISP(LPQUERYTOKEN pToken)
{
    // Validate
    Assert(TOKEN_OPERATOR == pToken->tyToken && pToken->tyOperator < OPERATOR_LAST);

    // Return ISP
    return (g_rgOperator[pToken->tyOperator].bISP);
}

//--------------------------------------------------------------------------
// ICP inline
//--------------------------------------------------------------------------
inline BYTE ICP(LPQUERYTOKEN pToken)
{
    // Validate
    Assert(TOKEN_OPERATOR == pToken->tyToken && pToken->tyOperator < OPERATOR_LAST);

    // Return ISP
    return (g_rgOperator[pToken->tyOperator].bICP);
}

// --------------------------------------------------------------------------
// DBIsDigit
// --------------------------------------------------------------------------
int DBIsDigit(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return(wType & C1_DIGIT);
}

//--------------------------------------------------------------------------
// EvaluateQuery
//--------------------------------------------------------------------------
HRESULT EvaluateQuery(HQUERY hQuery, LPVOID pBinding, LPCTABLESCHEMA pSchema,
    CDatabase *pDB, IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPQUERYTOKEN    pToken;
    LPQUERYTOKEN    pResult=NULL;
    LPQUERYTOKEN    pStackTop=NULL;

    // Trace
    TraceCall("EvaluateQuery");

    // Assert
    Assert(hQuery && pBinding && pSchema);

    // Walk through the tokens
    for (pToken=(LPQUERYTOKEN)hQuery; pToken!=NULL; pToken=pToken->pNext)
    {
        // If this is an operand, append to the stack
        if (TOKEN_OPERAND == pToken->tyToken)
        {
            // LinkStackToken
            PushStackToken(pToken, &pStackTop);
        }

        // Otherwise, must be an operator
        else
        {
            // Operator ?
            Assert(TOKEN_OPERATOR == pToken->tyToken && g_rgOperator[pToken->tyOperator].pfnEvaluate != NULL);

            // EvaluateOperator
            IF_FAILEXIT(hr = EvaluateClause(pToken->tyOperator, pBinding, pSchema, &pStackTop, pDB, pExtension));
        }
    }

    // Pop the stack
    PopStackToken(&pResult, &pStackTop);

    // No Token and Stack should now be empty..
    Assert(pResult && NULL == pStackTop && pResult->tyToken == TOKEN_OPERAND && pResult->Operand.tyOperand == OPERAND_DWORD);

    // 0 or not zero
    hr = (pResult->Operand.dwValue == 0) ? S_FALSE : S_OK;

exit:
    // Cleanup
    ReleaseToken(&pResult, pDB);
    ReleaseTokenList(TRUE, &pStackTop, pDB);

    // Done
    return(SUCCEEDED(hr) ? hr : S_FALSE);
}

//--------------------------------------------------------------------------
// ParseQuery
//--------------------------------------------------------------------------
HRESULT ParseQuery(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPHQUERY phQuery,
    CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszT=(LPSTR)pszQuery;
    LPQUERYTOKEN    pCurrent;
    LPQUERYTOKEN    pPrevious;
    LPQUERYTOKEN    pToken=NULL;
    LPQUERYTOKEN    pPostfixHead=NULL;
    LPQUERYTOKEN    pPostfixTail=NULL;
    LPQUERYTOKEN    pStackTop=NULL;

    // Trace
    TraceCall("ParseQuery");

    // Invalid Args
    if (NULL == pszQuery || NULL == pSchema || NULL == phQuery)
        return TraceResult(E_INVALIDARG);

    // Initialize
    (*phQuery) = NULL;

    // Start the Parsing Loop
    while(1)
    {
        // Parse next Token
        IF_FAILEXIT(hr = GetNextQueryToken(&pszT, pSchema, &pToken, pDB));

        // Done
        if (S_FALSE == hr)
            break;

        // If this was an operand, append to postfix expression
        if (TOKEN_OPERAND == pToken->tyToken)
        {
            // LinkToken
            LinkToken(pToken, &pPostfixHead, &pPostfixTail);

            // Don't pToken
            ReleaseToken(&pToken, pDB);
        }

        // Otherwise, must be an operator
        else
        {
            // Must be an operator
            Assert(TOKEN_OPERATOR == pToken->tyToken);
        
            // If Right Paren
            if (OPERATOR_RIGHTPAREN == pToken->tyOperator)
            {
                // Pop all the items from the stack and link into the postfix expression
                while (pStackTop && OPERATOR_LEFTPAREN != pStackTop->tyOperator)
                {
                    // Save pPrevious
                    pPrevious = pStackTop->pPrevious;

                    // Otherwise
                    LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

                    // Releae
                    ReleaseToken(&pStackTop, pDB);

                    // Goto Previuos
                    pStackTop = pPrevious;
                }

                // If not a left parent was found, then we failed
                if (OPERATOR_LEFTPAREN != pStackTop->tyOperator)
                {
                    hr = TraceResult(DB_E_UNMATCHINGPARENS);
                    goto exit;
                }

                // Save pPrevious
                pPrevious = pStackTop->pPrevious;

                // Free pStackTop
                ReleaseToken(&pStackTop, pDB);

                // Reset pStackTop
                pStackTop = pPrevious;

                // Free pToken
                ReleaseToken(&pToken, pDB);
            }

            // Otherwise
            else
            {
                // Pop all the items into the postfix expression according to a cool little priority rule
                while (pStackTop && ISP(pStackTop) <= ICP(pToken))
                {
                    // Save pPrevious
                    pPrevious = pStackTop->pPrevious;

                    // Otherwise
                    LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

                    // Releae
                    ReleaseToken(&pStackTop, pDB);

                    // Goto Previuos
                    pStackTop = pPrevious;
                }

                // Append pToken to the Stack
                LinkToken(pToken, NULL, &pStackTop);

                // Don't pToken
                ReleaseToken(&pToken, pDB);
            }
        }
    }

    // Pop all the items from the stack and link into the postfix expression
    while (pStackTop)
    {
        // Save pPrevious
        pPrevious = pStackTop->pPrevious;

        // Append to Postfix Expression
        LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

        // Releae
        ReleaseToken(&pStackTop, pDB);

        // Goto Previuos
        pStackTop = pPrevious;
    }

    // lets write the postfix notation...
    //IF_DEBUG(DebugDumpExpression(pszQuery, pSchema, pPostfixHead));

    // Success
    (*phQuery) = (HQUERY)pPostfixHead;

exit:
    // Cleanup On Failure
    if (FAILED(hr))
    {
        // Free pToken
        ReleaseToken(&pToken, pDB);

        // Free the Stack
        ReleaseTokenList(TRUE, &pStackTop, pDB);

        // Free the Postfix Expression
        ReleaseTokenList(FALSE, &pPostfixHead, pDB);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// DebugDumpExpression
//--------------------------------------------------------------------------
#ifdef DEBUG
HRESULT DebugDumpExpression(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, 
    LPQUERYTOKEN pPostfixHead)
{
    // Locals
    LPQUERYTOKEN pToken;

    // Trace
    TraceCall("DebugDumpExpression");

    // Write Infix
    DebugTrace("ParseQuery (Infix)   : %s\n", pszQuery);

    // Write Postfix header
    DebugTrace("ParseQuery (Postfix) : ");

    // Loop through the tokens
    for (pToken=pPostfixHead; pToken!=NULL; pToken=pToken->pNext)
    {
        // Operator
        if (TOKEN_OPERATOR == pToken->tyToken)
        {
            // Write the Operator
            DebugTrace("%s", g_rgOperator[pToken->tyOperator].pszName);
        }

        // Operand
        else if (TOKEN_OPERAND == pToken->tyToken)
        {
            // Column Operand
            if (OPERAND_COLUMN == pToken->Operand.tyOperand)
            {
                // Must have an iSymbol
                Assert(0xffffffff != pToken->Operand.iSymbol);

                // Write the Symbol
                DebugTrace("Column: %d (%s)", pToken->Operand.dwValue, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
            }

            // String Operand
            else if (OPERAND_STRING == pToken->Operand.tyOperand)
            {
                // Write the Symbol
                DebugTrace("<%s>", pToken->Operand.pszString);
            }

            // Dword Operand
            else if (OPERAND_DWORD == pToken->Operand.tyOperand)
            {
                // Has a iSymbol
                if (0xffffffff != pToken->Operand.iSymbol)
                {
                    // Write the Symbol
                    DebugTrace("%d (%s)", pToken->Operand.dwValue, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
                }

                // Otherwise, just write the value
                else
                {
                    // Write the Symbol
                    DebugTrace("%d", pToken->Operand.dwValue);
                }
            }

            // Method 
            else if (OPERAND_METHOD == pToken->Operand.tyOperand)
            {
                // Validate Symbol Type
                Assert(SYMBOL_METHOD == pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].tySymbol);

                // Write the Method
                DebugTrace("Method: %d (%s)", pToken->Operand.idMethod, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
            }
        }

        // Bad
        else
            Assert(FALSE);

        // Write Delimiter
        DebugTrace(", ");
    }

    // Wrap the line
    DebugTrace("\n");

    // Done
    return(S_OK);
}
#endif // DEBUG

//--------------------------------------------------------------------------
// CompareSymbol
//--------------------------------------------------------------------------
HRESULT CompareSymbol(LPSTR pszT, LPCSTR pszName, LPSTR *ppszEnd)
{
    // Locals
    LPSTR       pszName1;
    LPSTR       pszName2;

    // Trace
    TraceCall("CompareSymbol");

    // Set pszName
    pszName1 = (LPSTR)pszName;

    // Set pszName2
    pszName2 = pszT;

    // Compare pszTo to Operator pszName...
    while ('\0' != *pszName2 && *pszName1 == *pszName2)
    {
        // Increment
        pszName1++;
        pszName2++;

        // Reached the End of pszName1, must be a match
        if ('\0' == *pszName1)
        {
            // Set ppszEnd
            *ppszEnd = pszName2;

            // Done
            return(S_OK);
        }
    }

    // Done
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// GetNextQueryToken
//--------------------------------------------------------------------------
HRESULT GetNextQueryToken(LPSTR *ppszT, LPCTABLESCHEMA pSchema,
    LPQUERYTOKEN *ppToken, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LPSTR           pszT=(*ppszT);
    LPSTR           pszEnd;
    DWORD           i;
    LPQUERYTOKEN    pToken=NULL;

    // Trace
    TraceCall("GetNextQueryToken");

    // Allocate a Token
    IF_NULLEXIT(pToken = (LPQUERYTOKEN)pDB->PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(QUERYTOKEN)));

    // Set Reference Count
    pToken->cRefs = 1;

    // No Token foundyet
    pToken->tyToken = TOKEN_INVALID;

    // Invalid Symbol Index
    pToken->Operand.iSymbol = 0xffffffff;

    // Skip White Space...
    while(*pszT && (*pszT == ' ' || *pszT == '\t'))
        pszT++;

    // Done
    if ('\0' == *pszT)
        goto exit;
    
    // Check for the Start of an Operator...
    for (i=0; i<OPERATOR_LAST; i++)
    {
        // Does pszT point to the start of an operator ?
        if (S_OK == CompareSymbol(pszT, g_rgOperator[i].pszName, &pszEnd))
        {
            // Update pszT
            pszT = pszEnd;

            // We found an operator
            pToken->tyToken = TOKEN_OPERATOR;

            // Set the operator type
            pToken->tyOperator = (OPERATORTYPE)i;

            // Done
            break;
        }
    }

    // No Token Yet ?
    if (TOKEN_INVALID == pToken->tyToken)
    {
        // Start of a String Literal ?
        if ('"' == *pszT)
        {
            // ParseStringLiteral
            IF_FAILEXIT(hr = ParseStringLiteral(pszT, &pToken->Operand, &pszEnd, pDB));
        }

        // Otherwise, start of a number
        else if (DBIsDigit(pszT))
        {
            // ParseNumeric
            IF_FAILEXIT(hr = ParseNumeric(pszT, &pToken->Operand, &pszEnd));
        }

        // Start of a Symbol
        else
        {
            // ParseSymbol
            IF_FAILEXIT(hr = ParseSymbol(pszT, pSchema, &pToken->Operand, &pszEnd, pDB));
        }

        // Must have been an operand
        pToken->tyToken = TOKEN_OPERAND;

        // Set pszT
        pszT = pszEnd;
    }

    // Set ppszT
    *ppszT = pszT;

    // Success
    hr = S_OK;

    // Return the Token
    *ppToken = pToken;

    // Don't Free the Token
    pToken = NULL;

exit:
    // Cleanup
    ReleaseToken(&pToken, pDB);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseStringLiteral
//--------------------------------------------------------------------------
HRESULT ParseStringLiteral(LPCSTR pszStart, LPOPERANDINFO pOperand, 
    LPSTR *ppszEnd, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszValue;
    DWORD           cchString;
    LPSTR           pszT=(LPSTR)pszStart;
    
    // Trace
    TraceCall("ParseStringLiteral");

    // Validate Args
    Assert(*pszT == '"' && pOperand && ppszEnd);

    // Increment over "
    pszT++;

    // Find the End of the Quoted String
    while(*pszT)
    {
        // DBCS Lead Byte
        if (IsDBCSLeadByte(*pszT) || '\\' == *pszT)
        {
            pszT+=2;
            continue;
        }

        // If Escaped Quote..
        if ('"' == *pszT)
        {
            // Set ppszEnd
            *ppszEnd = pszT + 1;

            // Done
            break;
        }

        // Increment pszT
        pszT++;
    }

    // Not Found
    if ('\0' == *pszT)
    {
        hr = TraceResult(DB_E_UNMATCHINGQUOTES);
        goto exit;
    }

    // Get Size
    cchString = (DWORD)(pszT - (pszStart + 1));

    // Duplicate the String
    IF_NULLEXIT(pszValue = (LPSTR)pDB->PHeapAllocate(NOFLAGS, cchString + 1));

    // Copy the String
    CopyMemory(pszValue, pszStart + 1, cchString);

    // Set the Null
    pszValue[cchString] = '\0';

    // Set Operand Type
    pOperand->tyOperand = OPERAND_STRING;

    // Release
    pOperand->pRelease = (LPVOID)pszValue;

    // Set Value
    pOperand->pszString = pszValue;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseNumeric
//--------------------------------------------------------------------------
HRESULT ParseNumeric(LPCSTR pszStart, LPOPERANDINFO pOperand, LPSTR *ppszEnd)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwValue;
    CHAR            szNumber[255];
    DWORD           dwIncrement=0;
    LPSTR           pszT=(LPSTR)pszStart;
    DWORD           cchNumber;
    
    // Trace
    TraceCall("ParseNumeric");

    // Validate Args
    Assert(DBIsDigit(pszT) && pOperand && ppszEnd);

    // Is Hex: 0x
    if ('0' == *pszT && '\0' != *(pszT + 1) && 'X' == TOUPPERA(*(pszT + 1)))
    {
        // IsHex
        dwIncrement = 2;

        // Set pszT
        pszT += 2;
    }

    // Find the End of the Number
    while (*pszT && DBIsDigit(pszT))
    {
        // Increment
        pszT++;
    }

    // Get Length
    cchNumber = (DWORD)(pszT - (pszStart + dwIncrement));

    // Too Frickin Big
    if (cchNumber >= ARRAYSIZE(szNumber))
    {
        hr = TraceResult(DB_E_NUMBERTOOBIG);
        goto exit;
    }

    // Copy into szNumber
    CopyMemory(szNumber, pszStart + dwIncrement, cchNumber);

    // Set Null
    szNumber[cchNumber] = '\0';

    // If Is Hex, convert to integer
    if (FALSE == StrToIntEx(szNumber, dwIncrement ? STIF_SUPPORT_HEX : STIF_DEFAULT, (INT *)&dwValue))
    {
        hr = TraceResult(DB_E_BADNUMBER);
        goto exit;
    }

    // Set Operand Type
    pOperand->tyOperand = OPERAND_DWORD;

    // Set Value
    pOperand->dwValue = dwValue;

    // Return ppszEnd
    *ppszEnd = pszT;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseSymbol
//--------------------------------------------------------------------------
HRESULT ParseSymbol(LPCSTR pszT, LPCTABLESCHEMA pSchema, LPOPERANDINFO pOperand, 
    LPSTR *ppszEnd, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPSYMBOLINFO    pSymbol;
    LPSTR           pszEnd;
    
    // Trace
    TraceCall("ParseSymbol");

    // No Symbols
    if (NULL == pSchema->pSymbols)
    {
        hr = TraceResult(DB_E_NOSYMBOLS);
        goto exit;
    }

    // Check for the Start of an Operator...
    for (i=0; i<pSchema->pSymbols->cSymbols; i++)
    {
        // Readability
        pSymbol = (LPSYMBOLINFO)&pSchema->pSymbols->rgSymbol[i];

        // Does pszT point to the start of an operator ?
        if (S_OK == CompareSymbol((LPSTR)pszT, pSymbol->pszName, &pszEnd))
        {
            // Update pszT
            *ppszEnd = pszEnd;

            // Save iSymbol
            pOperand->iSymbol = i;

            // Is Column Symbol
            if (SYMBOL_COLUMN == pSymbol->tySymbol)
            {
                // Validate the Ordinal
                if (pSymbol->dwValue > pSchema->cColumns)
                {
                    hr = TraceResult(DB_E_INVALIDCOLUMN);
                    goto exit;
                }

                // Convert to OPERANDTYPE
                pOperand->tyOperand = OPERAND_COLUMN;

                // Save the Column
                pOperand->iColumn = (COLUMNORDINAL)pSymbol->dwValue;
            }

            // Otherwise, is a method ?
            else if (SYMBOL_METHOD == pSymbol->tySymbol)
            {
                // Convert to OPERANDTYPE
                pOperand->tyOperand = OPERAND_METHOD;

                // Save the Column
                pOperand->idMethod = pSymbol->dwValue;
            }

            // Otherwise, just a dword value
            else
            {
                // Dword
                pOperand->tyOperand = OPERAND_DWORD;

                // Set the operator type
                pOperand->dwValue = pSymbol->dwValue;
            }

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = TraceResult(DB_E_INVALIDSYMBOL);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CloseQuery
//--------------------------------------------------------------------------
HRESULT CloseQuery(LPHQUERY phQuery, CDatabase *pDB)
{
    // Trace
    TraceCall("CloseQuery");

    // ReleaseTokenList
    ReleaseTokenList(FALSE, (LPQUERYTOKEN *)phQuery, pDB);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PushStackToken
//--------------------------------------------------------------------------
HRESULT PushStackToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppStackTop)
{
    // Trace
    TraceCall("PushStackToken");

    // Set pStackPrevious
    pToken->pPrevious = (*ppStackTop);

    // Update Stack Top
    (*ppStackTop) = pToken;

    // AddRef the Token
    pToken->cRefs++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PopStackToken
//--------------------------------------------------------------------------
HRESULT PopStackToken(LPQUERYTOKEN *ppToken, LPQUERYTOKEN *ppStackTop)
{
    // Trace
    TraceCall("PopStackToken");

    // Validate
    Assert(ppToken && ppStackTop);

    // No more tokens...
    if (NULL == *ppStackTop)
        return TraceResult(DB_E_BADEXPRESSION);

    // Set Token
    *ppToken = (*ppStackTop);

    // Goto Previous
    (*ppStackTop) = (*ppToken)->pPrevious;

    // Release the Token
    //(*ppToken)->cRefs--;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// LinkToken
//--------------------------------------------------------------------------
HRESULT LinkToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppHead, LPQUERYTOKEN *ppTail)
{
    // Trace
    TraceCall("LinkToken");

    // Invalid Args
    Assert(pToken && ppTail);

    // No Next and No Previous
    pToken->pNext = pToken->pPrevious = NULL;

    // No Head yet ?
    if (ppHead && NULL == *ppHead)
    {
        // Set the Head and Tail
        *ppHead = pToken;
    }

    // Otherwise, append to the end
    else if (*ppTail)
    {
        // Set ppTail->pNext
        (*ppTail)->pNext = pToken;

        // Set Previous
        pToken->pPrevious = (*ppTail);
    }

    // Update the Tail
    *ppTail = pToken;

    // AddRef the Token
    pToken->cRefs++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// ReleaseToken
//--------------------------------------------------------------------------
HRESULT ReleaseToken(LPQUERYTOKEN *ppToken, CDatabase *pDB)
{
    // Trace
    TraceCall("ReleaseToken");

    // Token
    if (*ppToken)
    {
        // Validate Reference Count
        Assert((*ppToken)->cRefs);

        // Decrement Reference Count
        (*ppToken)->cRefs--;

        // No more refs...
        if (0 == (*ppToken)->cRefs)
        {
            // Free pData
            pDB->HeapFree((*ppToken)->Operand.pRelease);

            // Free pElement
            pDB->HeapFree((*ppToken));
        }

        // Don't Release Again
        *ppToken = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// ReleaseTokenList
//--------------------------------------------------------------------------
HRESULT ReleaseTokenList(BOOL fReverse, LPQUERYTOKEN *ppHead, CDatabase *pDB)
{
    // Locals
    LPQUERYTOKEN    pNext;
    LPQUERYTOKEN    pToken=(*ppHead);

    // Trace
    TraceCall("ReleaseTokenList");

    // Walk the Linked List
    while (pToken)
    {
        // Save Next
        pNext = (fReverse ? pToken->pPrevious : pToken->pNext);

        // Free this token
        ReleaseToken(&pToken, pDB);

        // Goto Next
        pToken = pNext;
    }

    // Don't Free Again
    *ppHead = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PGetOperandData
//--------------------------------------------------------------------------
LPVOID PGetOperandData(OPERANDTYPE tyOperand, LPOPERANDINFO pOperand, 
    LPVOID pBinding, LPCTABLESCHEMA pSchema, CDatabase *pDB, 
    IDatabaseExtension *pExtension)
{
    // Locals
    LPVOID      pValue=NULL;

    // Trace
    TraceCall("PGetOperandData");

    // OPERAND_COLUMN
    if (OPERAND_COLUMN == pOperand->tyOperand)
    {
        // Get the Tag 
        LPCTABLECOLUMN pColumn = &pSchema->prgColumn[pOperand->iColumn];

        // MapColumnType
        MapColumnType(pColumn->type, pOperand, pColumn, pBinding, &pValue);
    }

    // OPERAND_STRING
    else if (OPERAND_STRING == pOperand->tyOperand)
    {
        // Better want a string out
        Assert(OPERAND_STRING == tyOperand);

        // Return Data Pointer
        pValue = pOperand->pszString;
    }

    // OPERAND_DWORD
    else if (OPERAND_DWORD == pOperand->tyOperand)
    {
        // Better want a dword out
        Assert(OPERAND_DWORD == tyOperand);

        // Return Data Pointer
        pValue = (LPVOID)&pOperand->dwValue;
    }

    // OPERAND_METHOD
    else if (OPERAND_METHOD == pOperand->tyOperand && pExtension)
    {
        // Better want a dword out
        Assert(OPERAND_DWORD == tyOperand);

        // Call the Method on the Extension
        pExtension->OnExecuteMethod(pOperand->idMethod, pBinding, &pOperand->dwReserved);

        // Return Data Pointer
        pValue = (LPVOID)&pOperand->dwReserved;
    }

    // No Data ?
    if (NULL == pValue)
    {
        // What type of operand was wanted
        switch(tyOperand)
        {
        case OPERAND_STRING:
            pValue = (LPVOID)c_szEmpty;
            break;

        case OPERAND_DWORD:
            pOperand->dwReserved = 0;
            pValue = (LPVOID)&pOperand->dwReserved;
            break;

        default:
            AssertSz(FALSE, "While go ahead and Jimmy my buffet..");
            break;
        }
    }

    // Done
    return(pValue);
}

//--------------------------------------------------------------------------
// GetCommonOperandType
//--------------------------------------------------------------------------
OPERANDTYPE GetCommonOperandType(LPOPERANDINFO pLeft, LPOPERANDINFO pRight,
    LPCTABLESCHEMA pSchema)
{
    // Locals
    OPERANDTYPE tyLeft = (OPERAND_STRING == pLeft->tyOperand ? OPERAND_STRING : OPERAND_DWORD);
    OPERANDTYPE tyRight = (OPERAND_STRING == pRight->tyOperand ? OPERAND_STRING : OPERAND_DWORD);

    // Trace
    TraceCall("GetCommonOperandType");

    // Left is a column
    if (OPERAND_COLUMN == pLeft->tyOperand)
    {
        // Maps to a string
        if (OPERAND_STRING == g_rgColumnTypeInfo[pSchema->prgColumn[pLeft->iColumn].type].tyOperand)
            tyLeft = OPERAND_STRING;
    }

    // Right is a string
    if (OPERAND_COLUMN == pRight->tyOperand)
    {
        // Maps to a String ?
        if (OPERAND_STRING == g_rgColumnTypeInfo[pSchema->prgColumn[pRight->iColumn].type].tyOperand)
            tyRight = OPERAND_STRING;
    }

    // Better be the Same
    Assert(tyLeft == tyRight);

    // Return tyLeft since they are the same
    return(tyLeft);
}

//--------------------------------------------------------------------------
// EvaluateClause
//--------------------------------------------------------------------------
HRESULT EvaluateClause(OPERATORTYPE tyOperator, LPVOID pBinding,
    LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppStackTop, CDatabase *pDB,
    IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pDataLeft=NULL;
    LPVOID          pDataRight=NULL;
    LPQUERYTOKEN    pTokenResult=NULL;
    LPQUERYTOKEN    pTokenRight=NULL;
    LPQUERYTOKEN    pTokenLeft=NULL;
    OPERANDTYPE     tyOperand;
    INT             nCompare;

    // Trace
    TraceCall("EvaluateClause");

    // Pop the right token
    IF_FAILEXIT(hr = PopStackToken(&pTokenRight, ppStackTop));

    // Pop the left token
    IF_FAILEXIT(hr = PopStackToken(&pTokenLeft, ppStackTop));

    // Better have Data
    Assert(TOKEN_OPERAND == pTokenLeft->tyToken && TOKEN_OPERAND == pTokenRight->tyToken);

    // Compute Operand type
    tyOperand = GetCommonOperandType(&pTokenLeft->Operand, &pTokenRight->Operand, pSchema);

    // Get Left Data
    pDataLeft = PGetOperandData(tyOperand, &pTokenLeft->Operand, pBinding, pSchema, pDB, pExtension);

    // Get Right Data
    pDataRight = PGetOperandData(tyOperand, &pTokenRight->Operand, pBinding, pSchema, pDB, pExtension);

    // Create new Token to push back onto the stack
    IF_NULLEXIT(pTokenResult = (LPQUERYTOKEN)pDB->PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(QUERYTOKEN)));

    // Set Reference Count
    pTokenResult->cRefs = 1;

    // No Token foundyet
    pTokenResult->tyToken = TOKEN_OPERAND;

    // Invalid Symbol Index
    pTokenResult->Operand.iSymbol = 0xffffffff;

    // Set Result
    pTokenResult->Operand.tyOperand = OPERAND_DWORD;

    // EvaluateData
    pTokenResult->Operand.dwValue = EvaluateOperator(tyOperator, tyOperand, pDataLeft, pDataRight);

    // Push the result operand
    PushStackToken(pTokenResult, ppStackTop);
   
exit:
    // Cleanup
    ReleaseToken(&pTokenLeft, pDB);
    ReleaseToken(&pTokenRight, pDB);
    ReleaseToken(&pTokenResult, pDB);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// EvaluateEqual
//--------------------------------------------------------------------------
DWORD EvaluateEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (0 == CompareOperands(tyOperand, pDataLeft, pDataRight) ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateNotEqual
//--------------------------------------------------------------------------
DWORD EvaluateNotEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (0 != CompareOperands(tyOperand, pDataLeft, pDataRight) ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateLessThanEqual
//--------------------------------------------------------------------------
DWORD EvaluateLessThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) <= 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateLessThan
//--------------------------------------------------------------------------
DWORD EvaluateLessThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) < 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateGreaterThanEqual
//--------------------------------------------------------------------------
DWORD EvaluateGreaterThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) >= 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateGreaterThan
//--------------------------------------------------------------------------
DWORD EvaluateGreaterThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) > 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateAnd
//--------------------------------------------------------------------------
DWORD EvaluateAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) && *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateBitwiseAnd
//--------------------------------------------------------------------------
DWORD EvaluateBitwiseAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) & *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateOr
//--------------------------------------------------------------------------
DWORD EvaluateOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) || *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateBitwiseOr
//--------------------------------------------------------------------------
DWORD EvaluateBitwiseOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) | *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateStrStrI
//--------------------------------------------------------------------------
DWORD EvaluateStrStrI(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (NULL == StrStrIA((LPCSTR)pDataLeft, (LPCSTR)pDataRight) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// EvaluateStrStr
//--------------------------------------------------------------------------
DWORD EvaluateStrStr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (NULL == StrStrA((LPCSTR)pDataLeft, (LPCSTR)pDataRight) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// EvaluateStrcmpi
//--------------------------------------------------------------------------
DWORD EvaluateStrcmpi(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (lstrcmpi((LPCSTR)pDataLeft, (LPCSTR)pDataRight) == 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateStrcmp
//--------------------------------------------------------------------------
DWORD EvaluateStrcmp(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (lstrcmp((LPCSTR)pDataLeft, (LPCSTR)pDataRight) == 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateAdd
//--------------------------------------------------------------------------
DWORD EvaluateAdd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) + *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateSubtract
//--------------------------------------------------------------------------
DWORD EvaluateSubtract(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) - *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateMultiply
//--------------------------------------------------------------------------
DWORD EvaluateMultiply(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) * *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateDivide
//--------------------------------------------------------------------------
DWORD EvaluateDivide(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) / *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateModula
//--------------------------------------------------------------------------
DWORD EvaluateModula(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) % *((DWORD *)pDataRight));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\database.h ===
//--------------------------------------------------------------------------
// Database.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "utility.h"
#include "query.h"
#include "listen.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabaseQuery;

//--------------------------------------------------------------------------
// DwordAlign
//--------------------------------------------------------------------------
inline DWORD DwordAlign(DWORD cb) { 
    DWORD dw = (cb % 4); return(0 == dw ? 0 : (4 - dw));
}

//--------------------------------------------------------------------------
// String Constants
//--------------------------------------------------------------------------
#define CCHMAX_DB_FILEPATH      (MAX_PATH + MAX_PATH)

//--------------------------------------------------------------------------
// DESCENDING
//--------------------------------------------------------------------------
#define DESCENDING(_nCompare)   ((_nCompare < 0) ? 1 : -1)
typedef DWORD TICKCOUNT;

//--------------------------------------------------------------------------
// Version and Signatures
//--------------------------------------------------------------------------
#define BTREE_SIGNATURE         0xfe12adcf
#define BTREE_VERSION           5

//--------------------------------------------------------------------------
// B-Tree Chain Sizes
//--------------------------------------------------------------------------
#define BTREE_ORDER             50
#define BTREE_MIN_CAP           25

//--------------------------------------------------------------------------
// Upper Limit on Various Resources
//--------------------------------------------------------------------------
#define CMAX_OPEN_STREAMS       512
#define CMAX_OPEN_ROWSETS       32
#define CMAX_RECIPIENTS         15
#define CMAX_CLIENTS            32

//--------------------------------------------------------------------------
// Block Allocate Page Sizes
//--------------------------------------------------------------------------
#define CB_CHAIN_PAGE           15900
#define CB_STREAM_PAGE          63360
#define CB_VARIABLE_PAGE        49152
#define CB_STREAM_BLOCK         512
#define CC_MAX_BLOCK_TYPES      16

//--------------------------------------------------------------------------
// Variable Length Block Allocation Sizes
//--------------------------------------------------------------------------
#define CB_ALIGN_LARGE          1024
#define CB_FREE_BUCKET          4
#define CC_FREE_BUCKETS         2048
#define CB_MIN_FREE_BUCKET      32
#define CB_MAX_FREE_BUCKET      (CB_MIN_FREE_BUCKET + (CB_FREE_BUCKET * CC_FREE_BUCKETS))

//--------------------------------------------------------------------------
// Heap Block Cache
//--------------------------------------------------------------------------
#define CB_HEAP_BUCKET          8
#define CC_HEAP_BUCKETS         1024
#define CB_MAX_HEAP_BUCKET      (CB_HEAP_BUCKET * CC_HEAP_BUCKETS)

//--------------------------------------------------------------------------
// Other Constants
//--------------------------------------------------------------------------
#define MEMORY_GUARD_SIGNATURE  0xdeadbeef
#define DELETE_ON_CLOSE         TRUE

//--------------------------------------------------------------------------
// File Mapping Constants
//--------------------------------------------------------------------------
#define CB_MAPPED_VIEW          10485760

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
class CDatabase;
class CDatabaseStream;

//--------------------------------------------------------------------------
// Locking Values
//--------------------------------------------------------------------------
#define LOCK_VALUE_NONE     0
#define LOCK_VALUE_WRITER   -1

//--------------------------------------------------------------------------
// STREAMINDEX
//--------------------------------------------------------------------------
typedef WORD STREAMINDEX;
typedef LPWORD LPSTREAMINDEX;
#define INVALID_STREAMINDEX 0xffff

//--------------------------------------------------------------------------
// ROWSETORDINAL
//--------------------------------------------------------------------------
typedef BYTE ROWSETORDINAL;

//--------------------------------------------------------------------------
// FILEADDRESS
//--------------------------------------------------------------------------
typedef DWORD FILEADDRESS;
typedef LPDWORD LPFILEADDRESS;

//--------------------------------------------------------------------------
// NODEINDEX
//--------------------------------------------------------------------------
typedef BYTE NODEINDEX;
typedef BYTE *LPNODEINDEX;
#define INVALID_NODEINDEX 0xff

//--------------------------------------------------------------------------
// BLOCKTYPE
//--------------------------------------------------------------------------
typedef enum tagBLOCKTYPE {
    BLOCK_RECORD,
    BLOCK_STRING,
    BLOCK_RESERVED1,
    BLOCK_TRANSACTION,
    BLOCK_CHAIN,
    BLOCK_STREAM,
    BLOCK_FREE,
    BLOCK_ENDOFPAGE,
    BLOCK_RESERVED2,
    BLOCK_RESERVED3,
    BLOCK_LAST
} BLOCKTYPE;

//--------------------------------------------------------------------------
// CHAINDELETETYPE
//--------------------------------------------------------------------------
typedef enum tagCHAINDELETETYPE {
    CHAIN_DELETE_SHARE,
    CHAIN_DELETE_COALESCE
} CHAINDELETETYPE;

//--------------------------------------------------------------------------
// CHAINSHARETYPE
//--------------------------------------------------------------------------
typedef enum tagCHAINSHARETYPE {
    CHAIN_SHARE_LEFT,
    CHAIN_SHARE_RIGHT
} CHAINSHARETYPE;

//--------------------------------------------------------------------------
// OPERATIONTYPE - Specifies how _UnlinkRecordFromTable from table works
//--------------------------------------------------------------------------
typedef enum tagOPERATIONTYPE {
	OPERATION_DELETE,
	OPERATION_UPDATE,
    OPERATION_INSERT
} OPERATIONTYPE;

//--------------------------------------------------------------------------
// INVOKETYPE
//--------------------------------------------------------------------------
typedef enum tagINVOKETYPE {
    INVOKE_RELEASEMAP       = 100,
    INVOKE_CREATEMAP        = 101,
    INVOKE_CLOSEFILE        = 102,
    INVOKE_OPENFILE         = 103,
    INVOKE_OPENMOVEDFILE    = 104
} INVOKETYPE;

//--------------------------------------------------------------------------
// FINDRESULT
//--------------------------------------------------------------------------
typedef struct tagFINDRESULT {
    FILEADDRESS         faChain;
    NODEINDEX           iNode;
    BYTE                fChanged;
    BYTE                fFound;
    INT                 nCompare;
} FINDRESULT, *LPFINDRESULT;

//--------------------------------------------------------------------------
// ALLOCATEPAGE
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagALLOCATEPAGE {
	FILEADDRESS			faPage;
	DWORD				cbPage;
	DWORD				cbUsed;
} ALLOCATEPAGE, *LPALLOCATEPAGE;
#pragma pack()

//--------------------------------------------------------------------------
// TABLEHEADER
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagTABLEHEADER {
    DWORD               dwSignature;                        // 4
    CLSID               clsidExtension;                     // 20
    DWORD               dwMinorVersion;                     // 24
    DWORD               dwMajorVersion;                     // 28
    DWORD               cbUserData;                         // 32
    FILEADDRESS         faCatalogOld;                       // 36
    ALLOCATEPAGE        AllocateRecord;                     // 48
    ALLOCATEPAGE		AllocateChain;                      // 60
    ALLOCATEPAGE		AllocateStream;                     // 72
    FILEADDRESS         faFreeStreamBlock;                  // 76
    FILEADDRESS         faFreeChainBlock;                   // 80
    FILEADDRESS         faFreeLargeBlock;                   // 84
    DWORD               cbAllocated;                        // 88
    DWORD               cbFreed;                            // 92
    DWORD               dwNextId;                           // 96
    DWORD               fCorrupt;                           // 100
    DWORD               fCorruptCheck;                      // 104
    DWORD               cActiveThreads;                     // 108
    FILEADDRESS         faTransactHead;                     // 112
    FILEADDRESS         faTransactTail;                     // 116
    DWORD               cTransacts;                         // 120
    DWORD               cBadCloses;                         // 124
    FILEADDRESS         faNextAllocate;                     // 128
    DWORD               cIndexes;                           // 132
    FILEADDRESS         rgfaFilter[CMAX_INDEXES];           // 164
    DWORD               rgbReserved5[8];                    // 196
    DWORD               rgcRecords[CMAX_INDEXES];           // 228
    FILEADDRESS         rgfaIndex[CMAX_INDEXES];            // 260
    INDEXORDINAL        rgiIndex[CMAX_INDEXES];             // 292
    BYTE                rgbReserved4[116];                  // 408
    BYTE                fReserved;                          // 409
    DWORD               rgbReserved6[8];                    // 196
    BYTE                rgdwReserved2[192];                 // 637
    DWORD               rgcbAllocated[CC_MAX_BLOCK_TYPES];  // 701
    FILEADDRESS         rgfaFreeBlock[CC_FREE_BUCKETS];     // 8893
    TABLEINDEX          rgIndexInfo[CMAX_INDEXES];          // 9293
    WORD                wTransactSize;                      // 9405
    BYTE                rgdwReserved3[110];
} TABLEHEADER, *LPTABLEHEADER;
#pragma pack()

//--------------------------------------------------------------------------
// BLOCKHEADER
//-------------------------------------------------------------------------- 
#pragma pack(4)
typedef struct tagBLOCKHEADER {
    FILEADDRESS         faBlock;
    DWORD               cbSize;
} BLOCKHEADER, *LPBLOCKHEADER;
#pragma pack()

//--------------------------------------------------------------------------
// FREEBLOCK
//-------------------------------------------------------------------------- 
#pragma pack(4)
typedef struct tagFREEBLOCK : public BLOCKHEADER {
    DWORD               cbBlock;
    DWORD               dwReserved;
    FILEADDRESS         faNext;
} FREEBLOCK, *LPFREEBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// CHAINNODE
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagCHAINNODE {
    FILEADDRESS         faRecord;
    FILEADDRESS         faRightChain;
    DWORD               cRightNodes;
} CHAINNODE, *LPCHAINNODE;
#pragma pack()

//--------------------------------------------------------------------------
// CHAINBLOCK - 636
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagCHAINBLOCK : public BLOCKHEADER {
    FILEADDRESS         faLeftChain;
    FILEADDRESS         faParent;
    BYTE                iParent;
    BYTE                cNodes;
    WORD                wReserved;
    DWORD               cLeftNodes;
    CHAINNODE           rgNode[BTREE_ORDER + 1];
} CHAINBLOCK, *LPCHAINBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// STREAMBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagSTREAMBLOCK : public BLOCKHEADER {
    DWORD               cbData;
    FILEADDRESS         faNext;
} STREAMBLOCK, *LPSTREAMBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// RECORDBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagRECORDBLOCK : public BLOCKHEADER {
    WORD                wReserved;
    BYTE                cTags;
    BYTE                bVersion;
} RECORDBLOCK, *LPRECORDBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// COLUMNTAG
//--------------------------------------------------------------------------
#define TAG_DATA_MASK 0xFF800000
#pragma pack(4)
typedef struct tagCOLUMNTAG {
    unsigned            iColumn  : 7;
    unsigned            fData    : 1;
    unsigned            Offset   : 24;
} COLUMNTAG, *LPCOLUMNTAG;
#pragma pack()

//--------------------------------------------------------------------------
// RECORDMAP
//--------------------------------------------------------------------------
typedef struct tagRECORDMAP {
    LPCTABLESCHEMA      pSchema;
    BYTE                cTags;
    LPCOLUMNTAG         prgTag;
    DWORD               cbTags;
    DWORD               cbData;
    LPBYTE              pbData;
} RECORDMAP, *LPRECORDMAP;

//--------------------------------------------------------------------------
// OPENSTREAM
//--------------------------------------------------------------------------
typedef struct tagOPENSTREAM {
    BYTE                fInUse;
    FILEADDRESS         faStart;
    FILEADDRESS         faMoved;
    DWORD               cOpenCount;
    LONG                lLock;
    BYTE                fDeleteOnClose;
} OPENSTREAM, *LPOPENSTREAM;

//--------------------------------------------------------------------------
// NOTIFYRECIPIENT
//--------------------------------------------------------------------------
typedef struct tagNOTIFYRECIPIENT {
    HWND                hwndNotify;
    DWORD               dwThreadId;
    DWORD_PTR           dwCookie;
    BYTE                fSuspended;
    BYTE                fRelease;
    BYTE                fOrdinalsOnly;
    DWORD_PTR           pNotify;
    INDEXORDINAL        iIndex;
} NOTIFYRECIPIENT, *LPNOTIFYRECIPIENT;

//--------------------------------------------------------------------------
// CLIENTENTRY
//--------------------------------------------------------------------------
typedef struct tagCLIENTENTRY {
    HWND                hwndListen;
    DWORD               dwProcessId;
    DWORD               dwThreadId;
    DWORD_PTR           pDB;
    DWORD               cRecipients;
    NOTIFYRECIPIENT     rgRecipient[CMAX_RECIPIENTS];
} CLIENTENTRY, *LPCLIENTENTRY;

//--------------------------------------------------------------------------
// TRANSACTIONBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagTRANSACTIONBLOCK : public BLOCKHEADER {
    TRANSACTIONTYPE     tyTransaction;
    WORD                cRefs;
    INDEXORDINAL        iIndex;
    ORDINALLIST         Ordinals;
    FILEADDRESS         faRecord1;
    FILEADDRESS         faRecord2;
    FILEADDRESS         faNext;
    FILEADDRESS         faPrevious;
    FILEADDRESS         faNextInBatch;
} TRANSACTIONBLOCK, *LPTRANSACTIONBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// ROWSETINFO
//--------------------------------------------------------------------------
typedef struct tagROWSETINFO {
    ROWSETORDINAL       iRowset;
    INDEXORDINAL        iIndex;
    ROWORDINAL          iRow;
} ROWSETINFO, *LPROWSETINFO;

//--------------------------------------------------------------------------
// ROWSETTABLE
//--------------------------------------------------------------------------
typedef struct tagROWSETTABLE {
    BYTE                fInitialized;
    BYTE                cFree;
    BYTE                cUsed;
    ROWSETORDINAL       rgiFree[CMAX_OPEN_ROWSETS];
    ROWSETORDINAL       rgiUsed[CMAX_OPEN_ROWSETS];
    ROWSETINFO          rgRowset[CMAX_OPEN_ROWSETS];
} ROWSETTABLE, *LPROWSETTABLE;

//--------------------------------------------------------------------------
// SHAREDDATABASE
//--------------------------------------------------------------------------
typedef struct tagSHAREDDATABASE {
    WCHAR               szFile[CCHMAX_DB_FILEPATH];
    LONG                cWaitingForLock;
    BYTE                fCompacting;
    DWORD               dwVersion;
    DWORD               dwQueryVersion;
    DWORD               cNotifyLock;
    FILEADDRESS         faTransactLockHead;
    FILEADDRESS         faTransactLockTail;
    OPENSTREAM          rgStream[CMAX_OPEN_STREAMS];
    DWORD               cClients;
    DWORD               cNotifyOrdinalsOnly;
    DWORD               cNotifyWithData;
    DWORD               cNotify;
    DWORD               rgcIndexNotify[CMAX_INDEXES];
    CLIENTENTRY         rgClient[CMAX_CLIENTS];
    ROWSETTABLE         Rowsets;
    IF_DEBUG(BYTE       fRepairing;)
} SHAREDDATABASE, *LPSHAREDDATABASE;

//--------------------------------------------------------------------------
// INVOKEPACKAGE
//--------------------------------------------------------------------------
typedef struct tagINVOKEPACKAGE {
    INVOKETYPE          tyInvoke;
    DWORD_PTR           pDB;
} INVOKEPACKAGE, *LPINVOKEPACKAGE;

//--------------------------------------------------------------------------
// MARKBLOCK
//--------------------------------------------------------------------------
typedef struct tagMARKBLOCK {
    DWORD               cbBlock;
} MARKBLOCK, *LPMARKBLOCK;

//--------------------------------------------------------------------------
// FILEVIEW
//--------------------------------------------------------------------------
typedef struct tagFILEVIEW *LPFILEVIEW;
typedef struct tagFILEVIEW {
    FILEADDRESS         faView;
    LPBYTE              pbView;
    DWORD               cbView;
    LPFILEVIEW          pNext;
} FILEVIEW, *LPFILEVIEW;

//--------------------------------------------------------------------------
// STORAGEINFO
//--------------------------------------------------------------------------
typedef struct tagSTORAGEINFO {
    LPWSTR              pszMap;
    HANDLE              hFile;
    HANDLE              hMap;
    HANDLE              hShare;
    DWORD               cbFile;
#ifdef BACKGROUND_MONITOR
    TICKCOUNT           tcMonitor;
#endif
    DWORD               cbMappedViews;
    DWORD               cbMappedSpecial;
    DWORD               cAllocated;
    DWORD               cSpecial;
    LPFILEVIEW          prgView;
    LPFILEVIEW          pSpecial;
} STORAGEINFO, *LPSTORAGEINFO;

//--------------------------------------------------------------------------
// MEMORYTAG
//--------------------------------------------------------------------------
typedef struct tagMEMORYTAG {
    DWORD               dwSignature;
    DWORD               cbSize;
    LPVOID              pNext;
} MEMORYTAG, *LPMEMORYTAG;

//--------------------------------------------------------------------------
// CORRUPTREASON
//--------------------------------------------------------------------------
typedef enum tagCORRUPTREASON {
    REASON_BLOCKSTARTOUTOFRANGE             = 10000,
    REASON_UMATCHINGBLOCKADDRESS            = 10002,
    REASON_BLOCKSIZEOUTOFRANGE              = 10003,
    REASON_INVALIDFIRSTRECORD               = 10035,
    REASON_INVALIDLASTRECORD                = 10036,
    REASON_INVALIDRECORDMAP                 = 10037
} CORRUPTREASON;

//--------------------------------------------------------------------------
// CDatabase
//--------------------------------------------------------------------------
class CDatabase : public IDatabase
{
public:
    //----------------------------------------------------------------------
    // Construction - Destruction
    //----------------------------------------------------------------------
    CDatabase(void);
    ~CDatabase(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    HRESULT Open(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension);

    //----------------------------------------------------------------------
    // Locking Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Lock(LPHLOCK phLock);
    STDMETHODIMP Unlock(LPHLOCK phLock);

    //----------------------------------------------------------------------
    // Data Manipulation Methods
    //----------------------------------------------------------------------
    STDMETHODIMP InsertRecord(LPVOID pBinding);
    STDMETHODIMP UpdateRecord(LPVOID pBinding);
    STDMETHODIMP DeleteRecord(LPVOID pBinding);
    STDMETHODIMP FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPROWORDINAL piRow);
    STDMETHODIMP GetRowOrdinal(INDEXORDINAL iIndex, LPVOID pBinding, LPROWORDINAL piRow);
    STDMETHODIMP FreeRecord(LPVOID pBinding);
    STDMETHODIMP GetUserData(LPVOID pvUserData, ULONG cbUserData);
    STDMETHODIMP SetUserData(LPVOID pvUserData, ULONG cbUserData);
    STDMETHODIMP GetRecordCount(INDEXORDINAL iIndex, LPDWORD pcRecords);

    //----------------------------------------------------------------------
    // Indexing Methods
    //----------------------------------------------------------------------
    STDMETHODIMP GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter, LPTABLEINDEX pIndex);
    STDMETHODIMP ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter, LPCTABLEINDEX pIndex);
    STDMETHODIMP DeleteIndex(INDEXORDINAL iIndex);

    //----------------------------------------------------------------------
    // Rowset Methods
    //----------------------------------------------------------------------
    STDMETHODIMP CreateRowset(INDEXORDINAL iIndex, CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset);
    STDMETHODIMP SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, LONG cRows, LPROWORDINAL piRowNew);
    STDMETHODIMP QueryRowset(HROWSET hRowset, LONG cWanted, LPVOID *prgpBinding, LPDWORD pcObtained);
    STDMETHODIMP CloseRowset(LPHROWSET phRowset);

    //----------------------------------------------------------------------
    // Streaming Methods
    //----------------------------------------------------------------------
    STDMETHODIMP CreateStream(LPFILEADDRESS pfaStart);
    STDMETHODIMP DeleteStream(FILEADDRESS faStart);
    STDMETHODIMP CopyStream(IDatabase *pDst, FILEADDRESS faStream, LPFILEADDRESS pfaNew);
    STDMETHODIMP OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart, IStream **ppStream);
    STDMETHODIMP ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew);

    //----------------------------------------------------------------------
    // Notification Methods
    //----------------------------------------------------------------------
    STDMETHODIMP RegisterNotify(INDEXORDINAL iIndex, REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, IDatabaseNotify *pNotify);
    STDMETHODIMP DispatchNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP SuspendNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP ResumeNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP UnregisterNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock);
    STDMETHODIMP UnlockNotify(LPHLOCK phLock);
    STDMETHODIMP GetTransaction(LPHTRANSACTION phTransaction, LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals);

    //----------------------------------------------------------------------
    // Maintenence Methods
    //----------------------------------------------------------------------
    STDMETHODIMP MoveFile(LPCWSTR pszFilePath);
    STDMETHODIMP SetSize(DWORD cbSize);
    STDMETHODIMP GetFile(LPWSTR *ppszFile);
    STDMETHODIMP GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, LPDWORD pcbFreed, LPDWORD pcbStreams);
    STDMETHODIMP Repair(void) { return _CheckForCorruption(); }

    //----------------------------------------------------------------------
    // Fast-Heap Methods
    //----------------------------------------------------------------------
    STDMETHODIMP HeapFree(LPVOID pvBuffer);
    STDMETHODIMP HeapAllocate(DWORD dwFlags, DWORD cbSize, LPVOID *ppBuffer) {
        *ppBuffer = PHeapAllocate(dwFlags, cbSize);
        return(*ppBuffer ? S_OK : E_OUTOFMEMORY);
    }

    //----------------------------------------------------------------------
    // General Utility Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags);
    STDMETHODIMP GenerateId(LPDWORD pdwId);
    STDMETHODIMP GetClientCount(LPDWORD pcClients);

    //----------------------------------------------------------------------
    // CDatabase Members
    //----------------------------------------------------------------------
    HRESULT StreamCompareDatabase(CDatabaseStream *pStream, IDatabase *pDatabase);
    HRESULT GetStreamAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStream);
    HRESULT StreamRead(CDatabaseStream *pStream, LPVOID pvData, ULONG cbWanted, ULONG *pcbRead);
    HRESULT StreamWrite(CDatabaseStream *pStream, const void *pvData, ULONG cb, ULONG *pcbWrote);
    HRESULT StreamSeek(CDatabaseStream *pStream, LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew);
    HRESULT StreamRelease(CDatabaseStream *pStream);
    HRESULT StreamGetAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStart);
    HRESULT DoInProcessInvoke(INVOKETYPE tyInvoke);
#ifdef BACKGROUND_MONITOR
    HRESULT DoBackgroundMonitor(void);
#endif
    HRESULT BindRecord(LPRECORDMAP pMap, LPVOID pBinding);
    LPVOID  PHeapAllocate(DWORD dwFlags, DWORD cbSize);

    //----------------------------------------------------------------------
    // AllocateBinding
    //----------------------------------------------------------------------
    HRESULT AllocateBinding(LPVOID *ppBinding) {
        *ppBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding);
        return(*ppBinding ? S_OK : E_OUTOFMEMORY);
    }

private:
    //----------------------------------------------------------------------
    // General Btree Methods
    //----------------------------------------------------------------------
    HRESULT _IsLeafChain(LPCHAINBLOCK pChain);
    HRESULT _AdjustParentNodeCount(INDEXORDINAL iIndex, FILEADDRESS faChain, LONG lCount);
    HRESULT _ValidateFileVersions(OPENDATABASEFLAGS dwFlags);
    HRESULT _ResetTableHeader(void);
    HRESULT _RemoveClientFromArray(DWORD dwProcessId, DWORD_PTR pDB);
    HRESULT _BuildQueryTable(void);
    HRESULT _StreamSychronize(CDatabaseStream *pStream);
    HRESULT _InitializeExtension(OPENDATABASEFLAGS dwFlags, IDatabaseExtension *pExtension);
    HRESULT _GetRecordMap(BOOL fGoCorrupt, LPRECORDBLOCK pBlock, LPRECORDMAP pMap);

    //----------------------------------------------------------------------
    // File Mapping / View Utilities
    //----------------------------------------------------------------------
    HRESULT _InitializeFileViews(void);
    HRESULT _CloseFileViews(BOOL fFlush);
    HRESULT _AllocateSpecialView(FILEADDRESS faView, DWORD cbView, LPFILEVIEW *ppSpecial);

    //----------------------------------------------------------------------
    // Btree Search / Virtual Scrolling
    //----------------------------------------------------------------------
    HRESULT _GetChainByIndex(INDEXORDINAL iIndex, ROWORDINAL iRow, LPFILEADDRESS pfaChain, LPNODEINDEX piNode);
    HRESULT _CompareBinding(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, FILEADDRESS faRecord, INT *pnCompare);
    HRESULT _IsVisible(HQUERY hQuery, LPVOID pBinding);
    HRESULT _PartialIndexCompare(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPCHAINBLOCK *ppChain, LPNODEINDEX piNode, LPROWORDINAL piRow);
    HRESULT _FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPFILEADDRESS pfaChain, LPNODEINDEX piNode, LPROWORDINAL piRow=NULL, INT *pnCompare=NULL);

    //----------------------------------------------------------------------
    // Btree Deletion Methods
    //----------------------------------------------------------------------
    HRESULT _CollapseChain(LPCHAINBLOCK pChain, NODEINDEX iDelete);
    HRESULT _ExpandChain(LPCHAINBLOCK pChain, NODEINDEX iNode);
    HRESULT _IndexDeleteRecord(INDEXORDINAL iIndex, FILEADDRESS faDelete, NODEINDEX iDelete);
    HRESULT _GetRightSibling(FILEADDRESS faCurrent, LPCHAINBLOCK *ppSibling);
    HRESULT _GetLeftSibling(FILEADDRESS faCurrent, LPCHAINBLOCK *ppSibling);
    HRESULT _GetInOrderSuccessor(FILEADDRESS faStart, NODEINDEX iDelete, LPCHAINBLOCK *ppSuccessor);
    HRESULT _DecideHowToDelete(LPFILEADDRESS pfaShare, FILEADDRESS faDelete, CHAINDELETETYPE *ptyDelete, CHAINSHARETYPE *ptyShare);
    HRESULT _ChainDeleteShare(INDEXORDINAL iIndex, FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare);
    HRESULT _ChainDeleteCoalesce(INDEXORDINAL iIndex, FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare);

    //----------------------------------------------------------------------
    // Btree Insertion Methods
    //----------------------------------------------------------------------
    HRESULT _IndexInsertRecord(INDEXORDINAL iIndex, FILEADDRESS faChain, FILEADDRESS faRecord, LPNODEINDEX piNode, INT nCompare);
    HRESULT _ChainInsert(INDEXORDINAL iIndex, LPCHAINBLOCK pChain, LPCHAINNODE pNode, LPNODEINDEX piNodeIndex);
    HRESULT _SplitChainInsert(INDEXORDINAL iIndex, FILEADDRESS faLeaf);

    //----------------------------------------------------------------------
    // Record Persistence Methods
    //----------------------------------------------------------------------
    HRESULT _GetRecordSize(LPVOID pBinding, LPRECORDMAP pMap);
    HRESULT _SaveRecord(LPRECORDBLOCK pBlock, LPRECORDMAP pMap, LPVOID pBinding);
    HRESULT _ReadRecord(FILEADDRESS faRecord, LPVOID pBinding, BOOL fInternal=FALSE);
    HRESULT _LinkRecordIntoTable(LPRECORDMAP pMap, LPVOID pBinding, BYTE bVersion, LPFILEADDRESS pfaRecord);

    //----------------------------------------------------------------------
    // Notification / Invoke Methods
    //----------------------------------------------------------------------
    HRESULT _DispatchInvoke(INVOKETYPE tyInvoke);
    HRESULT _DispatchNotification(HTRANSACTION hTransaction);
    HRESULT _LogTransaction(TRANSACTIONTYPE tyTransaction, INDEXORDINAL iIndex, LPORDINALLIST pOrdinals, FILEADDRESS faRecord1, FILEADDRESS faRecord2);
    HRESULT _CloseNotificationWindow(LPNOTIFYRECIPIENT pRecipient);
    HRESULT _FindClient(DWORD dwProcessId, DWORD_PTR dwDB, LPDWORD piClient, LPCLIENTENTRY *ppClient);
    HRESULT _FindNotifyRecipient(DWORD iClient, IDatabaseNotify *pNotify, LPDWORD piRecipient,  LPNOTIFYRECIPIENT *ppRecipient);
    HRESULT _DispatchPendingNotifications(void);
    HRESULT _AdjustNotifyCounts(LPNOTIFYRECIPIENT pRecipient, LONG lChange);

    //----------------------------------------------------------------------
    // Rowset Support Methods
    //----------------------------------------------------------------------
    HRESULT _AdjustOpenRowsets(INDEXORDINAL iIndex, ROWORDINAL iRow, OPERATIONTYPE tyOperation);

    //----------------------------------------------------------------------
    // Alloctation Methods
    //----------------------------------------------------------------------
    HRESULT _MarkBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _ReuseFixedFreeBlock(LPFILEADDRESS pfaFreeHead, BLOCKTYPE tyBlock, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _FreeRecordStorage(OPERATIONTYPE tyOperation, FILEADDRESS faRecord);
    HRESULT _FreeStreamStorage(FILEADDRESS faStart);
    HRESULT _SetStorageSize(DWORD cbSize);
    HRESULT _AllocateBlock(BLOCKTYPE tyBlock, DWORD cbExtra, LPVOID *ppBlock);
    HRESULT _AllocateFromPage(BLOCKTYPE tyBlock, LPALLOCATEPAGE pPage, DWORD cbPage, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _FreeBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock);
    HRESULT _AllocatePage(DWORD cbPage, LPFILEADDRESS pfaAddress);
    HRESULT _FreeIndex(FILEADDRESS faChain);
    HRESULT _CopyRecord(FILEADDRESS faRecord, LPFILEADDRESS pfaCopy);
    HRESULT _FreeTransactBlock(LPTRANSACTIONBLOCK pTransact);
    HRESULT _CleanupTransactList(void);

    //----------------------------------------------------------------------
    // Compaction Helpers
    //----------------------------------------------------------------------
    HRESULT _CompactMoveRecordStreams(CDatabase *pDstDB, LPVOID pBinding);
    HRESULT _CompactMoveOpenDeletedStreams(CDatabase *pDstDB);
    HRESULT _CompactTransferFilters(CDatabase *pDstDB);
    HRESULT _CompactInsertRecord(LPVOID pBinding);

    //----------------------------------------------------------------------
    // Index Management
    //----------------------------------------------------------------------
    HRESULT _ValidateIndex(INDEXORDINAL iIndex, FILEADDRESS faChain, ULONG cLeftNodes, ULONG *pcRecords);
    HRESULT _RebuildIndex(INDEXORDINAL iIndex);
    HRESULT _RecursiveRebuildIndex(INDEXORDINAL iIndex, FILEADDRESS faCurrent, LPVOID pBinding, LPDWORD pcRecords);

    //----------------------------------------------------------------------
    // Corruption Validation and Repair Methods
    //----------------------------------------------------------------------
    HRESULT _HandleOpenMovedFile(void);
    HRESULT _SetCorrupt(BOOL fGoCorrupt, INT nLine, CORRUPTREASON tyReason, BLOCKTYPE tyBlock, FILEADDRESS faExpected, FILEADDRESS faActual, DWORD cbBlock);
    HRESULT _CheckForCorruption(void);
    HRESULT _GetBlock(BLOCKTYPE tyExpected, FILEADDRESS faBlock, LPVOID *ppvBlock, LPMARKBLOCK pMark=NULL, BOOL fGoCorrupt=TRUE);
    HRESULT _ValidateAndRepairRecord(LPRECORDMAP pMap);
    HRESULT _ValidateStream(FILEADDRESS faStart);

    //----------------------------------------------------------------------
    // Private Debug Methods
    //----------------------------------------------------------------------
    IF_DEBUG(HRESULT _DebugValidateRecordFormat(void));
    IF_DEBUG(HRESULT _DebugValidateUnrefedRecord(FILEADDRESS farecord));
    IF_DEBUG(HRESULT _DebugValidateIndexUnrefedRecord(FILEADDRESS faChain, FILEADDRESS faRecord));

private:
    //----------------------------------------------------------------------
    // Prototypes
    //----------------------------------------------------------------------
    LONG                    m_cRef;
    LONG                    m_cExtRefs;
    HANDLE                  m_hMutex;
#ifdef BACKGROUND_MONITOR
    HMONITORDB              m_hMonitor;
#endif
    DWORD                   m_dwProcessId;
    BOOL                    m_fDirty;
    LPCTABLESCHEMA          m_pSchema;
    LPSTORAGEINFO           m_pStorage;
    LPTABLEHEADER           m_pHeader;
    LPSHAREDDATABASE        m_pShare;
    HANDLE                  m_hHeap;
    BYTE                    m_fDeconstruct;
    BYTE                    m_fInMoveFile;
    BYTE                    m_fExclusive;
    BYTE                    m_fCompactYield;
    DWORD                   m_dwQueryVersion;
    HQUERY                  m_rghFilter[CMAX_INDEXES];
    IDatabaseExtension     *m_pExtension;
    IUnknown               *m_pUnkRelease;
    LPBYTE                  m_rgpRecycle[CC_HEAP_BUCKETS];
    CRITICAL_SECTION        m_csHeap;
    IF_DEBUG(DWORD          m_cbHeapAlloc);
    IF_DEBUG(DWORD          m_cbHeapFree);

    //----------------------------------------------------------------------
    // Friend
    //----------------------------------------------------------------------
    friend CDatabaseQuery;
};

//--------------------------------------------------------------------------
// CDatabaseQuery
//--------------------------------------------------------------------------
class CDatabaseQuery : public IDatabaseQuery
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CDatabaseQuery(void) {
        TraceCall("CDatabaseQuery::CDatabaseQuery");
        m_cRef = 1;
        m_hQuery = NULL;
        m_pDatabase = NULL;
    }

    //----------------------------------------------------------------------
    // De-Construction
    //----------------------------------------------------------------------
    ~CDatabaseQuery(void) {
        TraceCall("CDatabaseQuery::~CDatabaseQuery");
        CloseQuery(&m_hQuery, m_pDatabase);
        SafeRelease(m_pDatabase);
    }

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        TraceCall("CDatabaseQuery::QueryInterface");
        *ppv = NULL;
        if (IID_IUnknown == riid)
            *ppv = (IUnknown *)this;
        else if (IID_IDatabaseQuery == riid)
            *ppv  = (IDatabaseQuery *)this;
        else
            return TraceResult(E_NOINTERFACE);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    //----------------------------------------------------------------------
    // IDatabaseQuery::AddRef
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void) {
        TraceCall("CDatabaseQuery::AddRef");
        return InterlockedIncrement(&m_cRef);
    }

    //----------------------------------------------------------------------
    // IDatabaseQuery::Release
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) Release(void) {
        TraceCall("CDatabaseQuery::Release");
        LONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
            delete this;
        return (ULONG)cRef;
    }

    //----------------------------------------------------------------------
    // CDatabaseQuery::Initialize
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDatabase, LPCSTR pszQuery) {
        TraceCall("CDatabaseQuery::Initialize");
        pDatabase->QueryInterface(IID_CDatabase, (LPVOID *)&m_pDatabase);
        return(ParseQuery(pszQuery, m_pDatabase->m_pSchema, &m_hQuery, m_pDatabase));
    }

    //----------------------------------------------------------------------
    // CDatabaseQuery::Evaluate
    //----------------------------------------------------------------------
    STDMETHODIMP Evaluate(LPVOID pBinding) {
        TraceCall("CDatabaseQuery::Evaluate");
        return(EvaluateQuery(m_hQuery, pBinding, m_pDatabase->m_pSchema, m_pDatabase, m_pDatabase->m_pExtension));
    }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG        m_cRef;
    HQUERY      m_hQuery;
    CDatabase  *m_pDatabase;
};

//--------------------------------------------------------------------------
// PTagFromOrdinal
//--------------------------------------------------------------------------
inline LPCOLUMNTAG PTagFromOrdinal(LPRECORDMAP pMap, COLUMNORDINAL iColumn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\query.h ===
//--------------------------------------------------------------------------
// Query.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabase;
typedef struct tagRECORDMAP *LPRECORDMAP;

//--------------------------------------------------------------------------
// HQUERY
//--------------------------------------------------------------------------
DECLARE_HANDLE(HQUERY);
typedef HQUERY *LPHQUERY;

//--------------------------------------------------------------------------
// BuildQueryTree
//--------------------------------------------------------------------------
HRESULT EvaluateQuery(HQUERY hQuery, LPVOID pBinding, LPCTABLESCHEMA pSchema, CDatabase *pDB, IDatabaseExtension *pExtension);
HRESULT ParseQuery(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPHQUERY phQuery, CDatabase *pDB);
HRESULT CloseQuery(LPHQUERY phQuery, CDatabase *pDB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\session.h ===
//--------------------------------------------------------------------------
// Session.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CDatabaseSession
//--------------------------------------------------------------------------
class CDatabaseSession : public IDatabaseSession
{
public:
    //----------------------------------------------------------------------
    // Construction / Deconstruction
    //----------------------------------------------------------------------
    CDatabaseSession(void);
    ~CDatabaseSession(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IDatabaseSession Members
    //----------------------------------------------------------------------
    STDMETHODIMP OpenDatabase(LPCSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB);
    STDMETHODIMP OpenDatabaseW(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB);
    STDMETHODIMP OpenQuery(IDatabase *pDatabase, LPCSTR pszQuery, IDatabaseQuery **ppQuery);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                    m_cRef;
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateDatabaseSession(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\session.cpp ===
//--------------------------------------------------------------------------
// Session.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "session.h"
#include "listen.h"
#include "database.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// CreateDatabaseSession
//--------------------------------------------------------------------------
HRESULT CreateDatabaseSession(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateDatabaseSession");

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CDatabaseSession *pNew = new CDatabaseSession();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseSession *);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabaseSession::CDatabaseSession
//--------------------------------------------------------------------------
CDatabaseSession::CDatabaseSession(void)
{
    TraceCall("CDatabaseSession::CDatabaseSession");
    m_cRef = 1;
    ListenThreadAddRef();
}

//--------------------------------------------------------------------------
// CDatabaseSession::~CDatabaseSession
//--------------------------------------------------------------------------
CDatabaseSession::~CDatabaseSession(void)
{
    TraceCall("CDatabaseSession::~CDatabaseSession");
    ListenThreadRelease();
}

//--------------------------------------------------------------------------
// CDatabaseSession::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseSession::AddRef(void)
{
    TraceCall("CDatabaseSession::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CDatabaseSession::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseSession::Release(void)
{
    TraceCall("CDatabaseSession::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CDatabaseSession::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CDatabaseSession::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IDatabaseSession == riid)
        *ppv = (IDatabaseSession *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenDatabase
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenDatabase(LPCSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszFile=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenDatabase");

    // Convert to Unicode
    IF_NULLEXIT(pwszFile = ConvertToUnicode(CP_ACP, pszFile));

    // Open It
    IF_FAILEXIT(hr = OpenDatabaseW(pwszFile, dwFlags, pSchema, pExtension, ppDB));

exit:
    // Cleanup
    g_pMalloc->Free(pwszFile);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenDatabaseW
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenDatabaseW(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB)
{
    // Locals
    HRESULT         hr=S_OK;
    CDatabase      *pDatabase=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenDatabaseW");

    // Create a pDatabase
    IF_NULLEXIT(pDatabase = new CDatabase);

    // Open It
    IF_FAILEXIT(hr = pDatabase->Open(pszFile, dwFlags, pSchema, pExtension));

    // Cast It
    (*ppDB) = (IDatabase *)pDatabase;

    // Don't Free It
    pDatabase = NULL;

exit:
    // Cleanup
    SafeRelease(pDatabase);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenQuery
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenQuery(IDatabase *pDatabase, LPCSTR pszQuery,
    IDatabaseQuery **ppQuery)
{
    // Locals
    HRESULT         hr=S_OK;
    CDatabaseQuery *pQuery=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenQuery");

    // Create a pDatabase
    IF_NULLEXIT(pQuery = new CDatabaseQuery);

    // Open It
    IF_FAILEXIT(hr = pQuery->Initialize(pDatabase, pszQuery));

    // Cast It
    (*ppQuery) = (IDatabaseQuery *)pQuery;

    // Don't Free It
    pQuery = NULL;

exit:
    // Cleanup
    SafeRelease(pQuery);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\types.cpp ===
//--------------------------------------------------------------------------
// Types.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "types.h"
#include "qstrcmpi.h"
#include "strconst.h"

//--------------------------------------------------------------------------
// Defaults
//--------------------------------------------------------------------------
static const FILETIME g_ftDefault = {0};

//--------------------------------------------------------------------------
// DBCompareStringA
//--------------------------------------------------------------------------
inline INT DBCompareStringA(LPCINDEXKEY pKey, LPSTR pszValue1, LPSTR pszValue2)
{
    // Case Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_ASANSI) && !ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        // Loop through both strings
        while (*pszValue1 || *pszValue2)
        {
            // pszValue1 < pszValue2
            if (*pszValue1 < *pszValue2)
                return(-1);

            // pszValue1 > pszValue2
            if (*pszValue1 > *pszValue2)
                return(1);

            // Increment Pointers
            pszValue1++;
            pszValue2++;
        }

        // pszValue1 = psValue2
        return(0);
    }

    // Case In-Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_ASANSI) && ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        return(OEMstrcmpi(pszValue1, pszValue2));
    }

    // Case Sensitive International Compare
    if (!ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE)) 
    {
        // Strcmp
        return(lstrcmp(pszValue1, pszValue2));
    }

    // Finally, Case In-Sensitive International Compare
    return(lstrcmpi(pszValue1, pszValue2));
}

//--------------------------------------------------------------------------
// DBCompareStringW
//--------------------------------------------------------------------------
inline INT DBCompareStringW(LPCINDEXKEY pKey, LPWSTR pwszValue1, LPWSTR pwszValue2)
{
    // Case In-Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        return(StrCmpIW(pwszValue1, pwszValue2));
    }

    // Strcmp
    return(StrCmpW(pwszValue1, pwszValue2));
}

//--------------------------------------------------------------------------
// DBTypeIsDefault Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
BOOL DBTypeIsDefault_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPFILETIME pftValue = (LPFILETIME)((LPBYTE)pBinding + pColumn->ofBinding);
    return (0 == pftValue->dwLowDateTime && 0 == pftValue->dwHighDateTime); 
}

// CDT_FIXSTRA
BOOL DBTypeIsDefault_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPSTR pszValue = (LPSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    return(NULL == pszValue);
}

// CDT_VARSTRA
BOOL DBTypeIsDefault_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPSTR pszValue = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(NULL == pszValue);
}

// CDT_BYTE
BOOL DBTypeIsDefault_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    BYTE bValue = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == bValue);
}

// CDT_DWORD
BOOL DBTypeIsDefault_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_WORD
BOOL DBTypeIsDefault_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    WORD wValue = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == wValue);
}

// CDT_STREAM
BOOL DBTypeIsDefault_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    FILEADDRESS faValue = *((FILEADDRESS *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == faValue);
}

// CDT_VARBLOB
BOOL DBTypeIsDefault_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    return(0 == pBlob->cbSize);
}

// CDT_FIXBLOB
BOOL DBTypeIsDefault_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(FALSE); // We always store fixed length blobs
}

// CDT_FLAGS
BOOL DBTypeIsDefault_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_UNIQUE
BOOL DBTypeIsDefault_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_FIXSTRW
BOOL DBTypeIsDefault_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPWSTR pwszValue = (LPWSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    return(NULL == pwszValue);
}

// CDT_VARSTRW
BOOL DBTypeIsDefault_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPWSTR pwszValue = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(NULL == pwszValue);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeIsDefault, PFNDBTYPEISDEFAULT);

//--------------------------------------------------------------------------
// DBTypeGetSize Methods
//--------------------------------------------------------------------------

// CDT_FILETIME
DWORD DBTypeGetSize_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(sizeof(FILETIME));
}

// CDT_FIXSTRA
DWORD DBTypeGetSize_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_VARSTRA
DWORD DBTypeGetSize_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD cb=0; LPSTR pszValue;
    pszValue = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pszValue) { while(*pszValue) { cb++; pszValue++; } }
    cb++;
    return(cb);
}

// CDT_BYTE
DWORD DBTypeGetSize_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(0); // Stored in Column Tag
}

// CDT_DWORD
DWORD DBTypeGetSize_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_WORD
DWORD DBTypeGetSize_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(0); // Stored in Column Tag
}

// CDT_STREAM
DWORD DBTypeGetSize_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_VARBLOB
DWORD DBTypeGetSize_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    return(pBlob->cbSize + sizeof(DWORD));
}

// CDT_FIXBLOB
DWORD DBTypeGetSize_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_FLAGS
DWORD DBTypeGetSize_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_UNIQUE
DWORD DBTypeGetSize_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_FIXSTRW
DWORD DBTypeGetSize_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_VARSTRW
DWORD DBTypeGetSize_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD cb=0; LPWSTR pwszValue;
    pwszValue = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pwszValue) { while(*pwszValue) { cb += 2; pwszValue++; } }
    cb += 2;
    return(cb);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeGetSize, PFNDBTYPEGETSIZE);

//--------------------------------------------------------------------------
// DBTypeCompareRecords Implementation
//--------------------------------------------------------------------------

// 0  means pValue1 is equal to pValue2
// -1 means pValue1 is less than pValue2
// +1 means pValue1 is greater than pValue2

// CDT_FILETIME
INT DBTypeCompareRecords_FILETIME(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPFILETIME pftValue1; LPFILETIME pftValue2;
    if (NULL == pTag1) pftValue1 = (LPFILETIME)&g_ftDefault;
    else pftValue1 = (LPFILETIME)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pftValue2 = (LPFILETIME)&g_ftDefault;
    else pftValue2 = (LPFILETIME)(pMap2->pbData + pTag2->Offset);
    return(CompareFileTime(pftValue1, pftValue2));
}

// CDT_FIXSTRA
INT DBTypeCompareRecords_FIXSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPSTR pszValue1; LPSTR pszValue2;
    if (NULL == pTag1) pszValue1 = (LPSTR)c_szEmpty;
    else pszValue1 = (LPSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_VARSTRA
INT DBTypeCompareRecords_VARSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPSTR pszValue1; LPSTR pszValue2;
    if (NULL == pTag1) pszValue1 = (LPSTR)c_szEmpty;
    else pszValue1 = (LPSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_BYTE
INT DBTypeCompareRecords_BYTE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    BYTE bValue1; BYTE bValue2;
    if (NULL == pTag1) bValue1 = 0;
    else bValue1 = (BYTE)pTag1->Offset;
    if (NULL == pTag2) bValue2 = 0;
    else bValue2 = (BYTE)pTag2->Offset;
    return((INT)(bValue1 - bValue2));
}

// CDT_DWORD
INT DBTypeCompareRecords_DWORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_WORD
INT DBTypeCompareRecords_WORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    WORD wValue1; WORD wValue2;
    if (NULL == pTag1) wValue1 = 0;
    else wValue1 = (WORD)pTag1->Offset;
    if (NULL == pTag2) wValue2 = 0;
    else wValue2 = (WORD)pTag2->Offset;
    return((INT)(wValue1 - wValue2));
}

// CDT_STREAM
INT DBTypeCompareRecords_STREAM(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_VARBLOB
INT DBTypeCompareRecords_VARBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD cbValue1; DWORD cbValue2; LPBYTE pbValue1; LPBYTE pbValue2;
    if (NULL == pTag1) cbValue1 = 0;
    else cbValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) cbValue2 = 0;
    else cbValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    if (cbValue1 < cbValue2) return(-1);
    if (cbValue2 > cbValue1) return(1);
    if (0 == cbValue1 && 0 == cbValue2) return(1);
    pbValue1 = (LPBYTE)(pMap1->pbData + pTag1->Offset + sizeof(DWORD));
    pbValue2 = (LPBYTE)(pMap2->pbData + pTag2->Offset + sizeof(DWORD));
    return(memcmp(pbValue1, pbValue2, cbValue1));
}

// CDT_FIXBLOB
INT DBTypeCompareRecords_FIXBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    Assert(pTag1 && pTag2);
    LPBYTE pbValue1 = (LPBYTE)(pMap1->pbData + pTag1->Offset);
    LPBYTE pbValue2 = (LPBYTE)(pMap2->pbData + pTag2->Offset);
    return(memcmp(pbValue1, pbValue2, pColumn->cbSize));
}

// CDT_FLAGS
INT DBTypeCompareRecords_FLAGS(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return (INT)((dwValue1 & pKey->dwBits) - (dwValue2 & pKey->dwBits));
}

// CDT_UNIQUE
INT DBTypeCompareRecords_UNIQUE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_FIXSTRW
INT DBTypeCompareRecords_FIXSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    if (NULL == pTag1) pwszValue1 = (LPWSTR)c_wszEmpty;
    else pwszValue1 = (LPWSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// CDT_VARSTRW
INT DBTypeCompareRecords_VARSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    if (NULL == pTag1) pwszValue1 = (LPWSTR)c_wszEmpty;
    else pwszValue1 = (LPWSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// The Function Map
DEFINE_FUNCTION_MAP(DBTypeCompareRecords, PFNDBTYPECOMPARERECORDS);

//--------------------------------------------------------------------------
// DBTypeCompareBinding Implementation
//--------------------------------------------------------------------------

// 0  means pBinding is equal to pValue
// -1 means pBinding is less than pValue
// +1 means pBinding is greater than pValue

// CDT_FILETIME
INT DBTypeCompareBinding_FILETIME(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPFILETIME pftValue1; LPFILETIME pftValue2;
    pftValue1 = (LPFILETIME)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pftValue2 = (LPFILETIME)&g_ftDefault;
    else pftValue2 = (LPFILETIME)(pMap->pbData + pTag->Offset);
    return(CompareFileTime(pftValue1, pftValue2));
}

// CDT_FIXSTRA
INT DBTypeCompareBinding_FIXSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPSTR pszValue1; LPSTR pszValue2;
    pszValue1 = (LPSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_VARSTRA
INT DBTypeCompareBinding_VARSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPSTR pszValue1; LPSTR pszValue2;
    pszValue1 = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pszValue1) pszValue1 = (LPSTR)c_szEmpty;
    if (NULL == pTag) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_BYTE
INT DBTypeCompareBinding_BYTE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    BYTE bValue1; BYTE bValue2;
    bValue1 = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) bValue2 = 0;
    else bValue2 = (BYTE)(pTag->Offset);
    return((INT)(bValue1 - bValue2));
}

// CDT_DWORD
INT DBTypeCompareBinding_DWORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_WORD
INT DBTypeCompareBinding_WORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    WORD wValue1; WORD wValue2;
    wValue1 = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) wValue2 = 0;
    else wValue2 = (WORD)(pTag->Offset);
    return((INT)(wValue1 - wValue2));
}

// CDT_STREAM
INT DBTypeCompareBinding_STREAM(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_VARBLOB
INT DBTypeCompareBinding_VARBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPBLOB pBlob; DWORD cbValue1; DWORD cbValue2; LPBYTE pbValue1; LPBYTE pbValue2;
    pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    cbValue1 = pBlob->cbSize;
    if (NULL == pTag) cbValue2 = 0;
    else cbValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (cbValue1 < cbValue2) return(-1);
    if (cbValue2 > cbValue1) return(1);
    if (0 == cbValue1 && 0 == cbValue2) return(1);
    pbValue1 = pBlob->pBlobData;
    pbValue2 = (LPBYTE)(pMap->pbData + pTag->Offset + sizeof(DWORD));
    return(memcmp(pbValue1, pbValue2, cbValue1));
}

// CDT_FIXBLOB
INT DBTypeCompareBinding_FIXBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    Assert(pTag);
    LPBYTE pbValue1; LPBYTE pbValue2;
    pbValue1 = (LPBYTE)((LPBYTE)pBinding + pColumn->ofBinding);
    pbValue2 = (LPBYTE)(pMap->pbData + pTag->Offset);
    return(memcmp(pbValue1, pbValue2, pColumn->cbSize));
}

// CDT_FLAGS
INT DBTypeCompareBinding_FLAGS(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)((dwValue1 & pKey->dwBits) - (dwValue2 & pKey->dwBits)));
}

// CDT_UNIQUE
INT DBTypeCompareBinding_UNIQUE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_FIXSTRW
INT DBTypeCompareBinding_FIXSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    pwszValue1 = (LPWSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// CDT_VARSTRW
INT DBTypeCompareBinding_VARSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    pwszValue1 = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pwszValue1) pwszValue1 = (LPWSTR)c_wszEmpty;
    if (NULL == pTag) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeCompareBinding, PFNDBTYPECOMPAREBINDING);

//--------------------------------------------------------------------------
// DBTypeWriteValue Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
DWORD DBTypeWriteValue_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, sizeof(FILETIME));
    return(sizeof(FILETIME));
}

// CDT_FIXSTRA
DWORD DBTypeWriteValue_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_VARSTRA
DWORD DBTypeWriteValue_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPSTR pszT; DWORD cb=0;
    pszT = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pszT) { while(*pszT) { *(pbDest + cb) = *pszT; cb++; pszT++; } }
    *(pbDest + cb) = '\0';
    cb++;
    return(cb);
}

// CDT_BYTE
DWORD DBTypeWriteValue_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    pTag->Offset = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    pTag->fData = 1;
    return(0);
}

// CDT_DWORD
DWORD DBTypeWriteValue_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_WORD
DWORD DBTypeWriteValue_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    pTag->Offset = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    pTag->fData = 1;
    return(0);
}

// CDT_STREAM
DWORD DBTypeWriteValue_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding,
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_VARBLOB
DWORD DBTypeWriteValue_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    CopyMemory(pbDest, &pBlob->cbSize, sizeof(DWORD));
    if (pBlob->cbSize > 0) CopyMemory(pbDest + sizeof(DWORD), pBlob->pBlobData, pBlob->cbSize);
    return(pBlob->cbSize + sizeof(DWORD));
}

// CDT_FIXBLOB
DWORD DBTypeWriteValue_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_FLAGS
DWORD DBTypeWriteValue_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_UNIQUE
DWORD DBTypeWriteValue_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_FIXSTRW
DWORD DBTypeWriteValue_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_VARSTRW
DWORD DBTypeWriteValue_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPWSTR pwszT1; LPWSTR pwszT2; DWORD cb=0;
    pwszT1 = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    pwszT2 = (LPWSTR)pbDest;
    if (pwszT1) { while(*pwszT1) { *pwszT2 = *pwszT1; pwszT1++; pwszT2++; cb += 2; } }
    *pwszT2 = L'\0';
    cb += 2;
    return(cb);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeWriteValue, PFNDBTYPEWRITEVALUE);

//--------------------------------------------------------------------------
// DBTypeReadValue Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
void DBTypeReadValue_FILETIME(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + sizeof(FILETIME) > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), sizeof(FILETIME));
}

// CDT_FIXSTRA
void DBTypeReadValue_FIXSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_VARSTRA
void DBTypeReadValue_VARSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset > pMap->cbData) return;
    *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding)) = (LPSTR)(pMap->pbData + pTag->Offset);
}

// CDT_BYTE
void DBTypeReadValue_BYTE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData) return;
    *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
}

// CDT_DWORD
void DBTypeReadValue_DWORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData && pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    if (1 == pTag->fData) *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
    else *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_WORD
void DBTypeReadValue_WORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData) return;
    *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
}

// CDT_STREAM
void DBTypeReadValue_STREAM(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_VARBLOB
void DBTypeReadValue_VARBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    DWORD cbSize = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (pTag->Offset + sizeof(DWORD) + cbSize > pMap->cbData) return;
    pBlob->cbSize = cbSize;
    pBlob->pBlobData = (pBlob->cbSize > 0) ? ((pMap->pbData + pTag->Offset) + sizeof(DWORD)) : NULL;
}

// CDT_FIXBLOB
void DBTypeReadValue_FIXBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_FLAGS
void DBTypeReadValue_FLAGS(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_UNIQUE
void DBTypeReadValue_UNIQUE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_FIXSTRW
void DBTypeReadValue_FIXSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_VARSTRW
void DBTypeReadValue_VARSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset > pMap->cbData) return;
    *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding)) = (LPWSTR)(pMap->pbData + pTag->Offset);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeReadValue, PFNDBTYPEREADVALUE);

//--------------------------------------------------------------------------
// DBTypeValidate Implementation
//--------------------------------------------------------------------------

HRESULT DBValidateStringA(LPCOLUMNTAG pTag, LPRECORDMAP pMap, DWORD cbMax)
{
    LPSTR pszT = (LPSTR)(pMap->pbData + pTag->Offset);
    DWORD cbT=0;
    while (*pszT && cbT < cbMax) { pszT++; cbT++; }
    return('\0' == *pszT ? S_OK : S_FALSE);
}

HRESULT DBValidateStringW(LPCOLUMNTAG pTag, LPRECORDMAP pMap, DWORD cbMax)
{
    LPWSTR pwszT = (LPWSTR)(pMap->pbData + pTag->Offset);
    DWORD cbT=0;
    while (*pwszT && cbT < cbMax) { pwszT++; cbT += 2; }
    return(L'\0' == *pwszT ? S_OK : S_FALSE);
}

// CDT_FILETIME
HRESULT DBTypeValidate_FILETIME(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + sizeof(FILETIME) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXSTRA
HRESULT DBTypeValidate_FIXSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringA(pTag, pMap, pColumn->cbSize)) return(S_FALSE);
    return(S_OK);
}

// CDT_VARSTRA
HRESULT DBTypeValidate_VARSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringA(pTag, pMap, pMap->cbData)) return(S_FALSE);
    return(S_OK);
}

// CDT_BYTE
HRESULT DBTypeValidate_BYTE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (0 == pTag->fData) return(S_FALSE);
    return(S_OK);
}

// CDT_DWORD
HRESULT DBTypeValidate_DWORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_WORD
HRESULT DBTypeValidate_WORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (0 == pTag->fData) return(S_FALSE);
    return(S_OK);
}

// CDT_STREAM
HRESULT DBTypeValidate_STREAM(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_VARBLOB
HRESULT DBTypeValidate_VARBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    BLOB Blob;
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    Blob.cbSize = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (pTag->Offset + sizeof(DWORD) + Blob.cbSize > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXBLOB
HRESULT DBTypeValidate_FIXBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FLAGS
HRESULT DBTypeValidate_FLAGS(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_UNIQUE
HRESULT DBTypeValidate_UNIQUE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXSTRW
HRESULT DBTypeValidate_FIXSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringW(pTag, pMap, pColumn->cbSize)) return(S_FALSE);
    return(S_OK);
}

// CDT_VARSTRW
HRESULT DBTypeValidate_VARSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringW(pTag, pMap, pMap->cbData)) return(S_FALSE);
    return(S_OK);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeValidate, PFNDBTYPEVALIDATE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\utility.h ===
//--------------------------------------------------------------------------
// Utility.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateSystemHandleName(
        /* in */        LPCWSTR                     pszBase, 
        /* in */        LPCWSTR                     pszSpecific, 
        /* out */       LPWSTR                     *ppszName);

HRESULT DBGetFullPath(
        /* in */        LPCWSTR                     pszFilePath,
        /* out */       LPWSTR                     *ppszFullPath,
        /* out */       LPDWORD                     pcchFilePath);

HRESULT DBGetFileSize(
        /* in */        HANDLE                      hFile,
        /* out */       LPDWORD                     pcbSize);

HRESULT RegisterWindowClass(
        /* in */        LPCSTR                      pszClass,
        /* in */        WNDPROC                     pfnWndProc);

HRESULT CreateNotifyWindow(
        /* in */        LPCSTR                      pszClass,
        /* in */        LPVOID                      pvParam,
        /* in */        HWND                       *phwndNotify);

HRESULT DBOpenFileMapping(
        /* in */        HANDLE                      hFile,
        /* in */        LPCWSTR                     pszName,
        /* in */        DWORD                       cbSize,
        /* out */       BOOL                       *pfNew,
        /* out */       HANDLE                     *phMemoryMap,
        /* out */       LPVOID                     *ppvView);

HRESULT DBMapViewOfFile(
        /* in */        HANDLE                      hMapping, 
        /* in */        DWORD                       cbFile,
        /* in,out */    LPFILEADDRESS               pfaView, 
        /* in,out */    LPDWORD                     pcbView,
        /* out */       LPVOID                     *ppvView);

HRESULT DBOpenFile(
        /* in */        LPCWSTR                     pszFile,
        /* in */        BOOL                        fNoCreate,
        /* in */        BOOL                        fExclusive,
        /* out */       BOOL                       *pfNew,
        /* ou */        HANDLE                     *phFile);

HRESULT GetAvailableDiskSpace(
        /* in */        LPCWSTR                     pszFilePath,
        /* out */       DWORDLONG                   *pdwlFree);

HRESULT CompareTableIndexes(
        /* in */        LPCTABLEINDEX               pIndex1,
        /* in */        LPCTABLEINDEX               pIndex2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\wrapwide.cpp ===
//--------------------------------------------------------------------------
// WrapWide.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"

// --------------------------------------------------------------------------
// AllocateStringA
// --------------------------------------------------------------------------
LPSTR AllocateStringA(DWORD cch)
{
    // Allocate It
    return((LPSTR)g_pMalloc->Alloc((cch + 1) * sizeof(CHAR)));
}

// --------------------------------------------------------------------------
// AllocateStringW
// --------------------------------------------------------------------------
LPWSTR AllocateStringW(DWORD cch)
{
    // Allocate It
    return((LPWSTR)g_pMalloc->Alloc((cch + 1) * sizeof(WCHAR)));
}

// --------------------------------------------------------------------------
// DuplicateStringA
// --------------------------------------------------------------------------
LPSTR DuplicateStringA(LPCSTR psz)
{
    // Locals
    HRESULT hr=S_OK;
    DWORD   cch;
    LPSTR   pszT;

    // Trace
    TraceCall("DuplicateStringA");

    // Invalid Arg
    if (NULL == psz)
        return(NULL);

    // Length
    cch = lstrlenA(psz);

    // Allocate
    IF_NULLEXIT(pszT = AllocateStringA(cch));

    // Copy (including NULL)
    CopyMemory(pszT, psz, (cch + 1) * sizeof(CHAR));

exit:
    // Done
    return(pszT);
}

// --------------------------------------------------------------------------
// DuplicateStringW
// --------------------------------------------------------------------------
LPWSTR DuplicateStringW(LPCWSTR psz)
{
    // Locals
    HRESULT hr=S_OK;
    DWORD   cch;
    LPWSTR  pszT;

    // Trace
    TraceCall("DuplicateStringW");

    // Invalid Arg
    if (NULL == psz)
        return(NULL);

    // Length
    cch = lstrlenW(psz);

    // Allocate
    IF_NULLEXIT(pszT = AllocateStringW(cch));

    // Copy (including NULL) 
    CopyMemory(pszT, psz, (cch + 1) * sizeof(WCHAR));

exit:
    // Done
    return(pszT);
}

// --------------------------------------------------------------------------
// ConvertToUnicode
// --------------------------------------------------------------------------
LPWSTR ConvertToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    IF_NULLEXIT(pwszDup = AllocateStringW(cchWide));

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        SafeMemFree(pwszDup);
        goto exit;
    }

exit:
    // Done
    return(pwszDup);
}

// --------------------------------------------------------------------------
// ConvertToANSI
// --------------------------------------------------------------------------
LPSTR ConvertToANSI(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    IF_NULLEXIT(pszDup = AllocateStringA(cchNarrow + 1));

    // Do the actual translation
	cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow + 1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        SafeMemFree(pszDup);
        goto exit;
    }

exit:
    // Done
    return(pszDup);
}

//--------------------------------------------------------------------------
// GetFullPathNameWrapW
//--------------------------------------------------------------------------
DWORD GetFullPathNameWrapW(LPCWSTR pwszFileName, DWORD nBufferLength, 
    LPWSTR pwszBuffer, LPWSTR *ppwszFilePart)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwReturn;
    LPSTR       pszFileName=NULL;
    LPSTR       pszFilePart=NULL;
    LPSTR       pszBuffer=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("GetFullPathNameWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(GetFullPathNameW(pwszFileName, nBufferLength, pwszBuffer, ppwszFilePart));

    // Convert
    if (pwszFileName)
    {
        // To ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Allocate
    if (pwszBuffer && nBufferLength)
    {
        // Allocate a Buffer
        IF_NULLEXIT(pszBuffer = AllocateStringA(nBufferLength));
    }

    // Call
    dwReturn = GetFullPathNameA(pszFileName, nBufferLength, pszBuffer, &pszFilePart);

    // Save Last Error
    dwError = GetLastError();

    // If we have a buffer
    if (pwszBuffer && nBufferLength)
    {
        // Convert to Unicode
        if (0 == (dwReturn = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszBuffer, -1, pwszBuffer, nBufferLength)))
        {
            TraceResult(E_FAIL);
            goto exit;
        }
		if(dwReturn < nBufferLength)
			pwszBuffer[dwReturn] = L'\0';
		else
			Assert(FALSE);
    }

    // Set ppwszFilePath
    if (ppwszFilePart)
    {
        // Do we have a file part
        if (pszFilePart && pszBuffer && pwszBuffer && nBufferLength)
        {
            // Set Length
            DWORD cch = (DWORD)(pszFilePart - pszBuffer);

            // Set
            *ppwszFilePart = (LPWSTR)((LPBYTE)pwszBuffer + (cch * sizeof(WCHAR)));
        }

        // Otherwise
        else
            *ppwszFilePart = NULL;
    }


exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);
    g_pMalloc->Free(pszBuffer);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(SUCCEEDED(hr) ? dwReturn : 0);
}

//--------------------------------------------------------------------------
// CreateMutexWrapW
//--------------------------------------------------------------------------
HANDLE CreateMutexWrapW(LPSECURITY_ATTRIBUTES pMutexAttributes, 
    BOOL bInitialOwner, LPCWSTR pwszName)
{
    // Locals
    HRESULT         hr=S_OK;
    HANDLE          hMutex=NULL;
    LPSTR           pszName=NULL;
    DWORD           dwError=0;

    // Trace
    TraceCall("CreateMutexWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateMutexW(pMutexAttributes, bInitialOwner, pwszName));

    // Convert to Ansi
    if (pwszName)
    {
        // To ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMutex = CreateMutexA(pMutexAttributes, bInitialOwner, pszName);

    // Save Last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(hMutex);
}


//--------------------------------------------------------------------------
// CharLowerBuffWrapW
//--------------------------------------------------------------------------
DWORD CharLowerBuffWrapW(LPWSTR pwsz, DWORD cch)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=NULL;
    DWORD       dwReturn=0;
    DWORD       dwError=0;
    DWORD       cchMax;

    // Trace
    TraceCall("CharLowerBuffWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CharLowerBuffW(pwsz, cch));

    // Convert
    if (pwsz)
    {
        // Convert to ANSI
        IF_NULLEXIT(psz = ConvertToANSI(CP_ACP, pwsz));
    }

    // Call ANSI
    dwReturn = CharLowerBuffA(psz, cch);

    // Get the last error
    dwError = GetLastError();

    // If psz
    if (psz)
    {
        // Convert back to unicode
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, -1, pwsz, cch);
    }

exit:
    // Cleanup
    g_pMalloc->Free(psz);

    // Save the last error
    SetLastError(dwError);

    // Done
    return(dwReturn);
}

//--------------------------------------------------------------------------
// CreateFileWrapW
//--------------------------------------------------------------------------
HANDLE CreateFileWrapW(LPCWSTR pwszFileName, DWORD dwDesiredAccess,
    DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSecurityAttributes,
    DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hFile=INVALID_HANDLE_VALUE;
    LPSTR       pszFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("CreateFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateFileW(pwszFileName, dwDesiredAccess, dwShareMode, pSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile));

    // To ANSI
    if (pwszFileName)
    {
        // Convert to ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Call ANSI
    hFile = CreateFileA(pszFileName, dwDesiredAccess, dwShareMode, pSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);

    // Set Last Error
    SetLastError(dwError);

    // Done
    return(hFile);
}

//--------------------------------------------------------------------------
// GetDiskFreeSpaceWrapW
//--------------------------------------------------------------------------
BOOL GetDiskFreeSpaceWrapW(LPCWSTR pwszRootPathName, LPDWORD pdwSectorsPerCluster,
    LPDWORD pdwBytesPerSector, LPDWORD pdwNumberOfFreeClusters,
    LPDWORD pdwTotalNumberOfClusters)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszRootPathName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("GetClassInfoWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(GetDiskFreeSpaceW(pwszRootPathName, pdwSectorsPerCluster, pdwBytesPerSector, pdwNumberOfFreeClusters, pdwTotalNumberOfClusters));

    // To ANSI
    if (pwszRootPathName)
    {
        // to ANSI
        IF_NULLEXIT(pszRootPathName = ConvertToANSI(CP_ACP, pwszRootPathName));
    }

    // Call ANSI
    fReturn = GetDiskFreeSpaceA(pszRootPathName, pdwSectorsPerCluster, pdwBytesPerSector, pdwNumberOfFreeClusters, pdwTotalNumberOfClusters);

    // Save Last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszRootPathName);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}
 
//--------------------------------------------------------------------------
// OpenFileMappingWrapW
//--------------------------------------------------------------------------
HANDLE OpenFileMappingWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle,
    LPCWSTR pwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMapping=NULL;
    LPSTR       pszName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("OpenFileMappingWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(OpenFileMappingW(dwDesiredAccess, bInheritHandle, pwszName));

    // To ANSI
    if (pwszName)
    {
        // to ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMapping = OpenFileMappingA(dwDesiredAccess, bInheritHandle, pszName);

    // Save the last error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Set the last error
    SetLastError(dwError);

    // Done
    return(hMapping);
}

//--------------------------------------------------------------------------
// CreateFileMappingWrapW
//--------------------------------------------------------------------------
HANDLE CreateFileMappingWrapW(HANDLE hFile, LPSECURITY_ATTRIBUTES pFileMappingAttributes,
    DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow,
    LPCWSTR pwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMapping=NULL;
    LPSTR       pszName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("OpenFileMappingWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateFileMappingW(hFile, pFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pwszName));

    // To ANSI
    if (pwszName)
    {
        // to ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMapping = CreateFileMappingA(hFile, pFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pszName);

    // Save last error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Save last error
    SetLastError(dwError);

    // Done
    return(hMapping);
}
 
//--------------------------------------------------------------------------
// MoveFileWrapW
//--------------------------------------------------------------------------
BOOL MoveFileWrapW(LPCWSTR pwszExistingFileName, LPCWSTR pwszNewFileName)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszExistingFileName=NULL;
    LPSTR       pszNewFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("MoveFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(MoveFileW(pwszExistingFileName, pwszNewFileName));

    // To ANSI
    if (pwszExistingFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszExistingFileName = ConvertToANSI(CP_ACP, pwszExistingFileName));
    }

    // To ANSI
    if (pwszNewFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszNewFileName = ConvertToANSI(CP_ACP, pwszNewFileName));
    }

    // Call ANSI
    fReturn = MoveFileA(pszExistingFileName, pszNewFileName);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszExistingFileName);
    g_pMalloc->Free(pszNewFileName);

    // Save the last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}

//--------------------------------------------------------------------------
// DeleteFileWrapW
//--------------------------------------------------------------------------
BOOL DeleteFileWrapW(LPCWSTR pwszFileName)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("DeleteFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(DeleteFileW(pwszFileName));

    // To ANSI
    if (pwszFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Call ANSI
    fReturn = DeleteFileA(pszFileName);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);

    // Save the last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}

/**********************************************************************************\
* from msoert ported by YSt 6/25/99
*
* bobn 6/23/99
*
* The following code was ported from ShlWapi.  There were problems with
* our implementation on Win95 and it seemed prudent to have a solution
* without a bunch of special cases.
*
*
\**********************************************************************************/

#define DBCS_CHARSIZE   (2)

int DDB_MBToWCS(LPSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

int DDB_WCSToMB(LPCWSTR pwszIn, int cchIn, LPSTR *ppszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppszOut))
    {
        cchIn++;
        cbAlloc = cchIn * DBCS_CHARSIZE;

        *ppszOut = (LPSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppszOut)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchIn, 
                                      *ppszOut, cbAlloc, NULL, NULL);

            if (!cch)
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */
#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* DDB_SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from DDB_SP_GetFmtValue)
\***************************************************************************/

LPCWSTR DDB_SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* DDB_SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int DDB_SP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* DDB_SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void DDB_SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

int DDB_wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPWSTR lpT, lpTWC;
    LPSTR psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        CHAR sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = DDB_SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = DDB_SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * DDB_SP_PutNumberW returns FALSE if it runs out of space
                 */
                if (!DDB_SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    DDB_SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    DDB_SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = (LPSTR)(val.sz);
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = lstrlenW(lpT);
                } else {
                    psz = va_arg(varglist, LPSTR);
                    cch = lstrlen((LPCSTR)psz);
putstring:
                    cch = DDB_MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

int wsprintfWrapW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... )
{
    va_list arglist;
    int ret;

    Assert(lpOut);
    Assert(lpFmt);

    lpOut[0] = 0;
    va_start(arglist, lpFmt);
    
    ret = DDB_wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\stream.h ===
//--------------------------------------------------------------------------
// Stream.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
#include "database.h"

//--------------------------------------------------------------------------
// CDatabaseStream
//--------------------------------------------------------------------------
class CDatabaseStream : public IDatabaseStream
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CDatabaseStream(CDatabase *pDB, STREAMINDEX iStream, ACCESSTYPE tyAccess, FILEADDRESS faStart) 
        : m_iStream(iStream), 
          m_faStart(faStart), 
          m_tyAccess(tyAccess) 
    {
        TraceCall("CDatabaseStream::CDatabaseStream");
        m_cRef = 1; 
        m_cbOffset = 0; 
        m_iCurrent = 0; 
        m_cbCurrent = 0;
        m_faCurrent = m_faStart; 
        m_pDB = pDB; 
        m_pDB->AddRef();
    }
        
    //----------------------------------------------------------------------
    // De-construction
    //----------------------------------------------------------------------
    ~CDatabaseStream(void) { 
        TraceCall("CDatabaseStream::~CDatabaseStream");
        m_pDB->StreamRelease(this); m_pDB->Release(); 
    }

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        TraceCall("CDatabaseStream::QueryInterface");
        *ppv = NULL;
        if (IID_IUnknown == riid)
            *ppv = (IUnknown *)(IDatabaseStream *)this;
        else if (IID_IStream == riid)
            *ppv  = (IStream *)this;
        else if (IID_IDatabaseStream == riid)
            *ppv = (IDatabaseStream *)this;
        else if (IID_CDatabaseStream == riid)
            *ppv = (CDatabaseStream *)this;
        else
            return TraceResult(E_NOINTERFACE);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    //----------------------------------------------------------------------
    // IStream::AddRef
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void) {
        TraceCall("CDatabaseStream::AddRef");
        return InterlockedIncrement(&m_cRef);
    }

    //----------------------------------------------------------------------
    // IStream::Release
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) Release(void) {
        TraceCall("CDatabaseStream::Release");
        LONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
            delete this;
        return (ULONG)cRef;
    }

    //----------------------------------------------------------------------
    // IStream::Read
    //----------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID pvData, ULONG cbWanted, ULONG *pcbRead) { 
        TraceCall("CDatabaseStream::Read");
        return m_pDB->StreamRead(this, pvData, cbWanted, pcbRead);
    }

    //----------------------------------------------------------------------
    // IStream::Write
    //----------------------------------------------------------------------
    STDMETHODIMP Write(const void *pvData, ULONG cb, ULONG *pcbWritten) {
        TraceCall("CDatabaseStream::Write");
        return m_pDB->StreamWrite(this, pvData, cb, pcbWritten);
    }

    //----------------------------------------------------------------------
    // IStream::Seek
    //----------------------------------------------------------------------
    STDMETHODIMP Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew) {
        TraceCall("CDatabaseStream::Seek");
        return m_pDB->StreamSeek(this, liMove, dwOrigin, pulNew);
    }

    //----------------------------------------------------------------------
    // CDatabaseStream::GetFileAddress
    //----------------------------------------------------------------------
    STDMETHODIMP GetFileAddress(LPFILEADDRESS pfaStream) { 
        TraceCall("CDatabaseStream::GetFileAddress");
        return m_pDB->GetStreamAddress(this, pfaStream);
    }

    //----------------------------------------------------------------------
    // CDatabaseStream::CompareDatabase
    //----------------------------------------------------------------------
    STDMETHODIMP CompareDatabase(IDatabase *pDatabase) {
        TraceCall("CDatabaseStream::CompareDatabase");
        return m_pDB->StreamCompareDatabase(this, pDatabase);
    }

    //----------------------------------------------------------------------
    // Not Implemented IStream Methods
    //----------------------------------------------------------------------
    STDMETHODIMP SetSize(ULARGE_INTEGER uliSize) { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) { return S_OK; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER,DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM*) { return E_NOTIMPL; }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                    m_cRef;
    STREAMINDEX             m_iStream;
    FILEADDRESS             m_faStart;
    ACCESSTYPE              m_tyAccess;
    DWORD                   m_iCurrent;
    DWORD                   m_faCurrent;
    DWORD                   m_cbCurrent;
    DWORD                   m_cbOffset;
    CDatabase              *m_pDB;

    //----------------------------------------------------------------------
    // Private Friend
    //----------------------------------------------------------------------
    friend CDatabase;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\types.h ===
//--------------------------------------------------------------------------
// Types.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// DEFINE_FUNCTION_MAP
//--------------------------------------------------------------------------
#define DEFINE_FUNCTION_MAP(_name, _pfnType) \
    const _pfnType g_rgpfn##_name[CDT_LASTTYPE] = { \
        (_pfnType)_name##_FILETIME,     \
        (_pfnType)_name##_FIXSTRA,      \
        (_pfnType)_name##_VARSTRA,      \
        (_pfnType)_name##_BYTE,         \
        (_pfnType)_name##_DWORD,        \
        (_pfnType)_name##_WORD,         \
        (_pfnType)_name##_STREAM,       \
        (_pfnType)_name##_VARBLOB,      \
        (_pfnType)_name##_FIXBLOB,      \
        (_pfnType)_name##_FLAGS,        \
        (_pfnType)_name##_UNIQUE,       \
        (_pfnType)_name##_FIXSTRW,      \
        (_pfnType)_name##_VARSTRW       \
    };

//--------------------------------------------------------------------------
// Function Types
//--------------------------------------------------------------------------
typedef BOOL (APIENTRY *PFNDBTYPEISDEFAULT)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding);

typedef INT (APIENTRY *PFNDBTYPECOMPARERECORDS)(
    LPCTABLECOLUMN      pColumn, 
    LPCINDEXKEY         pKey, 
    LPCOLUMNTAG         pTag1, 
    LPCOLUMNTAG         pTag2, 
    LPRECORDMAP         pMap1, 
    LPRECORDMAP         pMap2);

typedef INT (APIENTRY *PFNDBTYPECOMPAREBINDING)(
    LPCTABLECOLUMN      pColumn, 
    LPCINDEXKEY         pKey, 
    LPVOID              pBinding, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap);

typedef DWORD (APIENTRY *PFNDBTYPEGETSIZE)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding);

typedef DWORD (APIENTRY *PFNDBTYPEWRITEVALUE)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding, 
    LPCOLUMNTAG         pTag, 
    LPBYTE              pbDest);

typedef void (APIENTRY *PFNDBTYPEREADVALUE)(
    LPCTABLECOLUMN      pColumn, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap, 
    LPVOID              pBinding);

typedef HRESULT (APIENTRY *PFNDBTYPEVALIDATE)(
    LPCTABLECOLUMN      pColumn, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap);

//--------------------------------------------------------------------------
// Global Function Pointer Tables
//--------------------------------------------------------------------------
extern const PFNDBTYPEISDEFAULT         g_rgpfnDBTypeIsDefault[CDT_LASTTYPE];
extern const PFNDBTYPEGETSIZE           g_rgpfnDBTypeGetSize[CDT_LASTTYPE];
extern const PFNDBTYPECOMPARERECORDS    g_rgpfnDBTypeCompareRecords[CDT_LASTTYPE];
extern const PFNDBTYPECOMPAREBINDING    g_rgpfnDBTypeCompareBinding[CDT_LASTTYPE];
extern const PFNDBTYPEWRITEVALUE        g_rgpfnDBTypeWriteValue[CDT_LASTTYPE];
extern const PFNDBTYPEREADVALUE         g_rgpfnDBTypeReadValue[CDT_LASTTYPE];
extern const PFNDBTYPEVALIDATE          g_rgpfnDBTypeValidate[CDT_LASTTYPE];

//--------------------------------------------------------------------------
// Macros
//--------------------------------------------------------------------------
#define DBTypeIsDefault(_pColumn, _pBinding) \
    (*(g_rgpfnDBTypeIsDefault[(_pColumn)->type])) \
    ((_pColumn), _pBinding)

#define DBTypeGetSize(_pColumn, _pBinding) \
    (*(g_rgpfnDBTypeGetSize[(_pColumn)->type])) \
    ((_pColumn), _pBinding)

#define DBTypeCompareRecords(_pColumn, _pKey, _pTag1, _pTag2, _pMap1, _pMap2) \
    (*(g_rgpfnDBTypeCompareRecords[(_pColumn)->type])) \
    ((_pColumn), _pKey, _pTag1, _pTag2, _pMap1, _pMap2)

#define DBTypeCompareBinding(_pColumn, _pKey, _pBinding, _pTag, _pMap) \
    (*(g_rgpfnDBTypeCompareBinding[(_pColumn)->type])) \
    ((_pColumn), _pKey, _pBinding, _pTag, _pMap)

#define DBTypeWriteValue(_pColumn, _pBinding, _pTag, _pbDest) \
    (*(g_rgpfnDBTypeWriteValue[(_pColumn)->type])) \
    ((_pColumn), _pBinding, _pTag, _pbDest)

#define DBTypeReadValue(_pColumn, _pTag, _pMap, _pBinding) \
    (*(g_rgpfnDBTypeReadValue[(_pColumn)->type])) \
    ((_pColumn), _pTag, _pMap, _pBinding)

#define DBTypeValidate(_pColumn, _pTag, _pMap) \
    (*(g_rgpfnDBTypeValidate[(_pColumn)->type])) \
    ((_pColumn), _pTag, _pMap)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\utility.cpp ===
//--------------------------------------------------------------------------
// Utility.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "utility.h"
#include "database.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// CreateSystemHandleName
//--------------------------------------------------------------------------
HRESULT CreateSystemHandleName(LPCWSTR pwszBase, LPCWSTR pwszSpecific, 
    LPWSTR *ppwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cchName;
    LPWSTR      pszT;

    // Trace
    TraceCall("CreateSystemHandleName");

    // Invalid Args
    Assert(pwszBase && pwszSpecific && ppwszName);

    // Init
    *ppwszName = NULL;

    // Compute Length
    cchName = lstrlenW(pwszBase) + lstrlenW(pwszSpecific) + 15;

    // Allocate
    IF_NULLEXIT(*ppwszName = AllocateStringW(cchName));

    // Setup Arguments
    wsprintfWrapW(*ppwszName, cchName, L"%s%s", pwszBase, pwszSpecific);

    // Remove backslashes from this string
    for (pszT = (*ppwszName); *pszT != L'\0'; pszT++)
    {
        // Replace Back Slashes
        if (*pszT == L'\\')
        {
            // With _
            *pszT = L'_';
        }
    }

    // Lower Case
    CharLowerBuffWrapW(*ppwszName, lstrlenW(*ppwszName));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DBGetFullPath
// --------------------------------------------------------------------------------
HRESULT DBGetFullPath(LPCWSTR pszFilePath, LPWSTR *ppszFullPath, LPDWORD pcchFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchAllocate;
    LPWSTR          pszFilePart;

    // Trace
    TraceCall("DBGetFullPath");

    // Set cchFullPath
    cchAllocate = max(lstrlenW(pszFilePath), MAX_PATH + MAX_PATH);

    // Allocate ppszFullPath
    IF_NULLEXIT(*ppszFullPath = AllocateStringW(cchAllocate));

    // GetFullPathName
    *pcchFilePath = GetFullPathNameWrapW(pszFilePath, cchAllocate, (*ppszFullPath), &pszFilePart);

    // Failure
    if (*pcchFilePath && *pcchFilePath >= cchAllocate)
    {
        // Re-allocate
        IF_NULLEXIT(*ppszFullPath = AllocateStringW(*pcchFilePath));

        // Expand the Path
        *pcchFilePath = GetFullPathNameWrapW(pszFilePath, *pcchFilePath, (*ppszFullPath), &pszFilePart);
    }

    // cch is 0
    if (0 == *pcchFilePath)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Validate
    Assert((*ppszFullPath)[(*pcchFilePath)] == L'\0');

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompareTableIndexes
// --------------------------------------------------------------------------------
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2)
{
    // Locals
    DWORD i;

    // Trace
    TraceCall("CompareTableIndexes");

    // Different Number of Keys
    if (pIndex1->cKeys != pIndex2->cKeys)
        return(S_FALSE);

    // Loop through the keys
    for (i=0; i<pIndex1->cKeys; i++)
    {
        // Different Column
        if (pIndex1->rgKey[i].iColumn != pIndex2->rgKey[i].iColumn)
            return(S_FALSE);

        // Different Compare Flags
        if (pIndex1->rgKey[i].bCompare != pIndex2->rgKey[i].bCompare)
            return(S_FALSE);

        // Different Compare Bits
        if (pIndex1->rgKey[i].dwBits != pIndex2->rgKey[i].dwBits)
            return(S_FALSE);
    }

    // Equal
    return(S_OK);
}

//--------------------------------------------------------------------------
// DBOpenFile
//--------------------------------------------------------------------------
HRESULT DBOpenFile(LPCWSTR pszFile, BOOL fNoCreate, BOOL fExclusive, 
    BOOL *pfNew, HANDLE *phFile)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hFile;
    DWORD       dwShare;
    DWORD       dwCreate;

    // Trace
    TraceCall("DBOpenFile");

    // Invalid Args
    Assert(pszFile && phFile);
    
    // Initialize
    *phFile = NULL;
    *pfNew = FALSE;

    // Set Share Falgs
    dwShare = fExclusive ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE;

    // If not fNoCreate, then OPEN_ALWAYS
    dwCreate = fNoCreate ? OPEN_EXISTING : OPEN_ALWAYS;

    // Do the CreateFile
    hFile = CreateFileWrapW(pszFile, GENERIC_READ | GENERIC_WRITE, dwShare, NULL, dwCreate, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == hFile)
    {
        // Return a Good Error
        if (ERROR_SHARING_VIOLATION == GetLastError())
        {
            // Set hr
            hr = TraceResult(DB_E_ACCESSDENIED);
        }

        // Otherwise, generic Error
        else
        {
            // Create File
            hr = TraceResult(DB_E_CREATEFILE);
        }

        // Done
        goto exit;
    }

    // If Not no create
    if (FALSE == fNoCreate)
    {
        // Return pfNew ?
        *pfNew = (ERROR_ALREADY_EXISTS == GetLastError()) ? FALSE : TRUE;
    }

    // Return the hFile
    *phFile = hFile;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// DBMapViewOfFile
//--------------------------------------------------------------------------
HRESULT DBMapViewOfFile(HANDLE hMapping, DWORD cbFile, LPFILEADDRESS pfaView, 
    LPDWORD pcbView, LPVOID *ppvView)
{
    // Locals
    FILEADDRESS     faBase = (*pfaView);
    DWORD           cbSize = (*pcbView);

    // cbBoundary
    DWORD cbBoundary = (faBase % g_SystemInfo.dwAllocationGranularity);

    // Decrement faBase
    faBase -= cbBoundary;

    // Increment cbSize
    cbSize += cbBoundary;

    // Fixup cbSize
    if (faBase + cbSize > cbFile)
    {
        // Map to the end of the file
        cbSize = (cbFile - faBase);
    }

    // Map a view of the entire file
    *ppvView = MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, faBase, cbSize);

    // Failure
    if (NULL == *ppvView)
        return(TraceResult(DB_E_MAPVIEWOFFILE));

    // Return Actual Sizes
    *pfaView = faBase;
    *pcbView = cbSize;

    // Success
    return(S_OK);
}

//--------------------------------------------------------------------------
// DBOpenFileMapping
//--------------------------------------------------------------------------
HRESULT DBOpenFileMapping(HANDLE hFile, LPCWSTR pwszName, DWORD cbSize, BOOL *pfNew, 
    HANDLE *phMemoryMap, LPVOID *ppvView)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMemoryMap=NULL;
    LPVOID      pvView=NULL;

    // Tracing
    TraceCall("OpenFileMapping");

    // Invalid Arg
    Assert(hFile != NULL && phMemoryMap && pfNew);

    // Initialize
    *phMemoryMap = NULL;
    *pfNew = FALSE;
    if (ppvView)
        *ppvView = NULL;

    // Open or create the file mapping
    hMemoryMap = OpenFileMappingWrapW(FILE_MAP_ALL_ACCESS, FALSE, pwszName);

    // If that failed, then lets create the file mapping
    if (NULL == hMemoryMap)
    {
        // Create the file mapping
        hMemoryMap = CreateFileMappingWrapW(hFile, NULL, PAGE_READWRITE, 0, cbSize, pwszName);

        // Failure
        if (NULL == hMemoryMap)
        {
            hr = TraceResult(DB_E_CREATEFILEMAPPING);
            goto exit;
        }

        // Set a State
        *pfNew = TRUE;
    }

    // Map the View
    if (ppvView)
    {
        // Map a view of the entire file
        pvView = MapViewOfFile(hMemoryMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

        // Failure
        if (NULL == pvView)
        {
            hr = TraceResult(DB_E_MAPVIEWOFFILE);
            goto exit;
        }

        // Return It
        *ppvView = pvView;

        // Don't Free It
        pvView = NULL;
    }

    // Set Return Values
    *phMemoryMap = hMemoryMap;

    // Don't Free
    hMemoryMap = NULL;

exit:
    // Cleanup
    if (pvView)
        UnmapViewOfFile(pvView);
    if (hMemoryMap)
        CloseHandle(hMemoryMap);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// RegisterWindowClass
//--------------------------------------------------------------------------
HRESULT RegisterWindowClass(LPCSTR pszClass, WNDPROC pfnWndProc)
{
    // Locals
    HRESULT         hr=S_OK;
    WNDCLASS        WindowClass;

    // Tracing
    TraceCall("RegisterWindowClass");

    // Register the Window Class
    if (0 != GetClassInfo(g_hInst, pszClass, &WindowClass))
        goto exit;

    // Zero the object
    ZeroMemory(&WindowClass, sizeof(WNDCLASS));

    // Initialize the Window Class
    WindowClass.lpfnWndProc = pfnWndProc;
    WindowClass.hInstance = g_hInst;
    WindowClass.lpszClassName = pszClass;

    // Register the Class
    if (0 == RegisterClass(&WindowClass))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CreateNotifyWindow
//--------------------------------------------------------------------------
HRESULT CreateNotifyWindow(LPCSTR pszClass, LPVOID pvParam, HWND *phwndNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Tracing
    TraceCall("CreateNotifyWindow");

    // Invalid ARg
    Assert(pszClass && phwndNotify);

    // Initialize
    *phwndNotify = NULL;

    // Create the Window
    hwnd = CreateWindowEx(WS_EX_TOPMOST, pszClass, pszClass, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInst, (LPVOID)pvParam);

    // Failure
    if (NULL == hwnd)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set Return
    *phwndNotify = hwnd;

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DBGetFileSize
//--------------------------------------------------------------------------
HRESULT DBGetFileSize(HANDLE hFile, LPDWORD pcbSize)
{
    // Trace
    TraceCall("GetFileSize");

    // Invalid Arg
    Assert(pcbSize);

    // Get the Size
    *pcbSize = ::GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == *pcbSize)
        return TraceResult(DB_E_GETFILESIZE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(LPCWSTR pszFilePath, DWORDLONG *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       wszDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == L':' && pdwlFree);

    // Split the path
    wszDrive[0] = *pszFilePath;
    wszDrive[1] = L':';
    wszDrive[2] = L'\\';
    wszDrive[3] = L'\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpaceWrapW(wszDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
	    hr = TraceResult(E_FAIL);
	    goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\engine\wrapwide.h ===
//--------------------------------------------------------------------------
// WrapWide.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
LPSTR   AllocateStringA(DWORD cch);
LPWSTR  AllocateStringW(DWORD cch);
LPSTR   DuplicateStringA(LPCSTR psz);
LPWSTR  DuplicateStringW(LPCWSTR psz);
LPWSTR  ConvertToUnicode(UINT cp, LPCSTR pcszSource);
LPSTR   ConvertToANSI(UINT cp, LPCWSTR pcwszSource);
DWORD   GetFullPathNameWrapW(LPCWSTR pwszFileName, DWORD nBufferLength, LPWSTR pwszBuffer, LPWSTR *ppwszFilePart);
HANDLE  CreateMutexWrapW(LPSECURITY_ATTRIBUTES pMutexAttributes, BOOL bInitialOwner, LPCWSTR pwszName);
int     wsprintfWrapW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... );
DWORD   CharLowerBuffWrapW(LPWSTR pwsz, DWORD cch);
HANDLE  CreateFileWrapW(LPCWSTR pwszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
BOOL    GetDiskFreeSpaceWrapW(LPCWSTR pwszRootPathName, LPDWORD pdwSectorsPerCluster, LPDWORD pdwBytesPerSector, LPDWORD pdwNumberOfFreeClusters, LPDWORD pdwTotalNumberOfClusters);
HANDLE  OpenFileMappingWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR pwszName);
HANDLE  CreateFileMappingWrapW(HANDLE hFile, LPSECURITY_ATTRIBUTES pFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR pwszName);
BOOL    MoveFileWrapW(LPCWSTR pwszExistingFileName, LPCWSTR pwszNewFileName);
BOOL    DeleteFileWrapW(LPCWSTR pwszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\guids\defguid.cpp ===
//--------------------------------------------------------------------------
// Defguid.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#define INITGUID
#include <initguid.h>
#include <directdb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\inc\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\inc\strconst.h ===
//--------------------------------------------------------------------------
// strconst.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Constant String Definition Macros
//--------------------------------------------------------------------------
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#ifndef STRCONSTA
#ifdef DEFINE_STRCONST
#define STRCONSTA(x,y)    EXTERN_C const char x[] = y
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y
#else
#define STRCONSTA(x,y)    EXTERN_C const char x[]
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]
#endif
#endif

//--------------------------------------------------------------------------
// Constant String
//--------------------------------------------------------------------------
STRCONSTA(c_szEmpty,                            "");
STRCONSTW(c_wszEmpty,                           "");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\directdb\res\makefile.inc ===
$(O)\directdb.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC


typedef struct tagCSSA_CUI {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_CRYPTUI_STRUCT_A, *PCERT_SELECT_CRYPTUI_STRUCT_A;

typedef struct tagCSSW_CUI {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_CRYPTUI_STRUCT_W, *PCERT_SELECT_CRYPTUI_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_CRYPTUI_STRUCT_W CERT_SELECT_CRYPTUI_STRUCT;
typedef PCERT_SELECT_CRYPTUI_STRUCT_W PCERT_SELECT_CRYPTUI_STRUCT;
#else
typedef CERT_SELECT_CRYPTUI_STRUCT_A CERT_SELECT_CRYPTUI_STRUCT;
typedef PCERT_SELECT_CRYPTUI_STRUCT_A PCERT_SELECT_CRYPTUI_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateCryptUIA(
        IN OUT PCERT_SELECT_CRYPTUI_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateCryptUIW(
        IN OUT PCERT_SELECT_CRYPTUI_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIW
#else
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIA
#endif
#endif  // MAC


/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


typedef struct tagCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIESCRYPTUI_STRUCT_A, *PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIESCRYPTUI_STRUCT_W, *PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIESCRYPTUI_STRUCT_W CERT_VIEWPROPERTIESCRYPTUI_STRUCT;
typedef PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W PCERT_VIEWPROPERTIESCRYPTUI_STRUCT;
#else
typedef CERT_VIEWPROPERTIESCRYPTUI_STRUCT_A CERT_VIEWPROPERTIESCRYPTUI_STRUCT;
typedef PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A PCERT_VIEWPROPERTIESCRYPTUI_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesCryptUIA(
        PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesCryptUIW(
        PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIW
#else
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIA
#endif
#endif  // MAC



//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }

#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  
    
typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#define malloc(_cb)         GlobalAlloc(GMEM_FIXED, _cb)
#define realloc(_pb, _cb)   GlobalReAlloc(_pb, _cb, 0)
#define free(_pb)           GlobalFree(_pb)

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\exploder\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#ifndef __RESOURCE_H
#define __RESOURCE_H

// --------------------------------------------------------------------------------
// String Resource Ids
// --------------------------------------------------------------------------------
#define IDS_CMDLINE_FORMAT          100
#define IDS_HELP                    101
#define IDS_TITLE                   102
#define IDS_FILE_NOEXIST            103
#define IDS_MHTML_FILTER            104
#define IDS_DIRECTORY_NOEXIST       105
#define IDS_NOCREATE_DIRECTORY      106
#define IDS_BROWSE_DEST             107
#define IDS_MEMORY                  108
#define IDS_GENERAL_ERROR           109
#define IDS_OPEN_FILE               110
#define IDS_LOAD_FAILURE            111
#define IDS_NO_HTML                 112

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\cryptui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptui.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTUI_H__
#define __CRYPTUI_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <prsht.h>
#include <wintrust.h>

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(8)


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the functions which return property sheet pages take this callback as one of the parameters in
//  the input structure.  it is then called when each page is about to be created and when each page
//  is about to be destroyed.  the messages are PSPCB_CREATE when a page is about to be created and
//  PSPCB_RELEASE when a page is about to be destroyed.  the pvCallbackData parameter in the callback
//  is the pvoid that was passed in with the callback in the input structure.
typedef BOOL (WINAPI * PFNCPROPPAGECALLBACK)(
        HWND        hWndPropPage,
        UINT        uMsg,
        void        *pvCallbackData);


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below       (OPTIONAL)
// szTitle                         title for the window                                     (OPTIONAL)
// pCertContext                    the cert context that is to be displayed
// rgszPurposes                    array of purposes that this cert is to be validated for  (OPTIONAL)
// cPurposes                       number of purposes                                       (OPTIONAL)
// pCryptProviderData/hWVTStateData if WinVerifyTrust has already been called for the cert  (OPTIONAL)
//                                 then pass in a pointer to the state struct that was
//                                 acquired through a call to WTHelperProvDataFromStateData(),
//                                 or pass in the hWVTStateData of the WINTRUST_DATA struct
//                                 if WTHelperProvDataFromStateData() was not called.
//                                 if pCryptProviderData/hWVTStateData is used then
//                                 fpCryptProviderDataTrustedUsage, idxSigner, idxCert, and
//                                 fCounterSignature must be set
// fpCryptProviderDataTrustedUsage if WinVerifyTrust was called this is the result of whether (OPTIONAL)
//                                 the cert was trusted
// idxSigner                       the index of the signer to view                          (OPTIONAL)
// idxCert                         the index of the cert that is being viewed within the    (OPTIONAL)
//                                 signer chain.  the cert context of this cert MUST match
//                                 pCertContext
// fCounterSigner                  set to TRUE if a counter signature is being viewed.  if  (OPTIONAL)
//                                 this is TRUE then idxCounterSigner must be valid
// idxCounterSigner                the index of the counter signer to view                  (OPTIONAL)
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog.              (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog.                        (OPTIONAL)
//                                 each page in this array will NOT recieve the lParam in
//                                 the PROPSHEET structure as the lParam in the
//                                 WM_INITDIALOG, instead it will receive a pointer to a
//                                 CRYPTUI_INITDIALOG_STRUCT (defined below) which contains
//                                 the lParam in the PROPSSHEET structure AND the
//                                 PCCERT_CONTEXT for which the page is being displayed.
// nStartPage                      this is the index of the initial page that will be
//                                 displayed.  if the upper most bit (0x8000) is set then
//                                 the index is assumed to index rgPropSheetPages
//                                 (after the upper most bit has been stripped off.  eg.
//                                 0x8000 will indicate the first page in rgPropSheetPages),
//                                 if the upper most bit is 0 then nStartPage will be the
//                                 starting index of the default certificate dialog pages.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_HIERARCHYPAGE       0x00000001
#define CRYPTUI_HIDE_DETAILPAGE          0x00000002
#define CRYPTUI_DISABLE_EDITPROPERTIES   0x00000004
#define CRYPTUI_ENABLE_EDITPROPERTIES    0x00000008
#define CRYPTUI_DISABLE_ADDTOSTORE       0x00000010
#define CRYPTUI_ENABLE_ADDTOSTORE        0x00000020
#define CRYPTUI_ACCEPT_DECLINE_STYLE     0x00000040
#define CRYPTUI_IGNORE_UNTRUSTED_ROOT    0x00000080  
#define CRYPTUI_DONT_OPEN_STORES         0x00000100
#define CRYPTUI_ONLY_OPEN_ROOT_STORE     0x00000200
#define CRYPTUI_WARN_UNTRUSTED_ROOT      0x00000400  // For use with viewing of certificates on remote 
                                                     // machines only.  If this flag is used rghStores[0] 
                                                     // must be the handle of the root store on the remote machine.

typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCWSTR                     szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEW           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTW, *PCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;


typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCSTR                      szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEA           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTA, *PCRYPTUI_VIEWCERTIFICATE_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

//
// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
//
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

BOOL
WINAPI
CryptUIDlgViewCertificateA(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

#ifdef UNICODE
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateW
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTW
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW
#else
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateA
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTA
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTA
#endif

//
// this struct is passed as the lParam in the WM_INITDIALOG call to each
// property sheet that is in the rgPropSheetPages array of the
// CRYPTUI_VIEWCERTIFICATE_STRUCT structure
//
typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
    LPARAM          lParam;
    PCCERT_CONTEXT  pCertContext;
} CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;


//
// this structure is used in CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT,
// and allows users of MMC to recieve notifications that properties
// on certificates have changed
//
typedef HRESULT (__stdcall * PFNCMMCCALLBACK)(LONG_PTR lNotifyHandle, LPARAM param);

typedef struct tagCRYPTUI_MMCCALLBACK_STRUCT {
    PFNCMMCCALLBACK pfnCallback;    // the address of MMCPropertyChangeNotify()
    LONG_PTR         lNotifyHandle;  // the lNotifyHandle passed to MMCPropertyChangeNotify()
    LPARAM          param;          // the param passed to MMCPropertyChangeNotify()
} CRYPTUI_MMCCALLBACK_STRUCT, *PCRYPTUI_MMCCALLBACK_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// union                           the szTitle field of the union is only valid if
//                                 CryptUIDlgViewCertificateProperties is being called.
//                                 the pMMCCallback field of the union is only valid if
//                                 CryptUIGetCertificatePropertiesPages is being called.
//                                 Note that if pMMCCallback is non-NULL and
//                                 CryptUIGetCertificatePropertiesPages was called, the
//                                 struct pointed to by pMMCCallback will not be referenced
//                                 by cryptui.dll after the callback has been made to MMC.
//                                 this will allow the original caller of
//                                 CryptUIGetCertificatePropertiesPages to free the struct
//                                 pointed to by pMMCCallback in the actual callback.
//      szTitle                    title for the window                                     (OPTIONAL)
//      pMMCCallback               this structure is used to callback MMC if properties     (OPTIONAL)
//                                 have changed
// pCertContext                    the cert context that is to be displayed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetCertificatePropertiesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.  Note that this is not used if
//                                 CryptUIDlgViewCertificateProperties is called
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCWSTR                     szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCSTR                      szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );

BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEW                              **prghPropPages,
            OUT DWORD                                       *pcPropPages
            );

BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                         *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEA                               **prghPropPages,
            OUT DWORD                                        *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesW(
            IN PROPSHEETPAGEW   *rghPropPages,
            IN DWORD            cPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesA(
            IN PROPSHEETPAGEA   *rghPropPages,
            IN DWORD            cPropPages
            );

#ifdef UNICODE
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesW
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesW
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesW
#else
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesA
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesA
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesA
#endif

//
// The certificate properties property sheet dialog is extensible via a callback mechanism.
// A client needs to register their callback using CryptRegisterDefaultOIDFunction, and,
// if they need to unregister it they should use CryptUnregisterDefaultOIDFunction.
// The form for calling these functions is given below
//
// CryptRegisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            CRYPT_REGISTER_FIRST_INDEX,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// CryptUnregisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// NOTE: Per the documentation on CryptRegisterDefaultOIDFunction in wincrypt.h,
//       the dll name may contain environment-variable strings
//       which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
#define MAX_CLIENT_PAGES 20
#define CRYPTUILDLG_CERTPROP_PAGES_CALLBACK "CryptUIDlgClientCertPropPagesCallback"

//
//
// The typedef for the callback function which resides in the registered dll is given
// below.  Note that the callback must have the name #defined by
// CRYPTUILDLG_CERTPROP_PAGES_CALLBACK
//
// pCertContext - The certificate for which the properties are being displayed.
// rgPropPages  - An array of PropSheetPageW structures that are to be filled in by
//                the client with the property pages to be shown.
// pcPropPages  - A pointer to a DWORD that on input contains the maximum number of
//                PropSheetPages the client may supply, and on output must have been
//                filled in by the client with the number of pages they supplied in
//                rgPropPages.
//
// Return Value:  The client should return TRUE if they wish to show extra property pages,
//                in this case pcPropPages must >= 1 and rgPropPages must have the
//                corresponding number of pages.  or, return FALSE if no pages are suplied.
typedef BOOL (WINAPI *PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK)
        (IN     PCCERT_CONTEXT pCertContext,
         OUT    PROPSHEETPAGEW *rgPropPages,
         IN OUT DWORD *pcPropPages);


/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cCertSearchStores;              count of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// rghCertSearchStores;            array of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWCTL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTW, *PCRYPTUI_VIEWCTL_STRUCTW;
typedef const CRYPTUI_VIEWCTL_STRUCTW *PCCRYPTUI_VIEWCTL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCTL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTA, *PCRYPTUI_VIEWCTL_STRUCTA;
typedef const CRYPTUI_VIEWCTL_STRUCTA *PCCRYPTUI_VIEWCTL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCTLW(
            IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
            );

BOOL
WINAPI
CryptUIDlgViewCTLA(
            IN PCCRYPTUI_VIEWCTL_STRUCTA pcvctl
            );

#ifdef UNICODE
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLW
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTW
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTW
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTW
#else
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLA
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTA
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTA
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTA
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_REVOCATIONLIST_PAGE   0x00000001

typedef struct tagCRYPTUI_VIEWCRL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTW, *PCRYPTUI_VIEWCRL_STRUCTW;
typedef const CRYPTUI_VIEWCRL_STRUCTW *PCCRYPTUI_VIEWCRL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCRL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTA, *PCRYPTUI_VIEWCRL_STRUCTA;
typedef const CRYPTUI_VIEWCRL_STRUCTA *PCCRYPTUI_VIEWCRL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCRLW(
            IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
            );

BOOL
WINAPI
CryptUIDlgViewCRLA(
            IN PCCRYPTUI_VIEWCRL_STRUCTA pcvcrl
            );

#ifdef UNICODE
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLW
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTW
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTW
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTW
#else
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLA
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTA
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTA
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pSignerInfo                     the signer info struct that is to be displayed
// hMsg                            the HCRYPTMSG that the signer info was extracted from
// pszOID                          an OID that signifies what the certificate that did the  (OPTIONAL)
//                                 signing whould be validated for.  for instance if this is
//                                 being called to view the signature of a CTL the
//                                 szOID_KP_CTL_USAGE_SIGNING OID should be passed in.
//                                 if this is NULL then the certificate is only validated
//                                 cryptographicaly and not for usages.
// dwReserved                      reserved for future use and must be set to NULL
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTW, *PCRYPTUI_VIEWSIGNERINFO_STRUCTW;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTW *PCCRYPTUI_VIEWSIGNERINFO_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTA, *PCRYPTUI_VIEWSIGNERINFO_STRUCTA;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTA *PCCRYPTUI_VIEWSIGNERINFO_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewSignerInfoW(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTW pcvsi
            );

BOOL
WINAPI
CryptUIDlgViewSignerInfoA(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTA pcvsi
            );

#ifdef UNICODE
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoW
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTW
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTW
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTW
#else
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoA
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTA
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTA
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// szTitle                         title for the window                                     (OPTIONAL)
// choice                          the form of the message that is to have its signers displayed
// u                               either an encoded message or a message handle
//          EncodedMessage         a data blob which contains a pointer to the encoded data
//                                 and the count of encoded bytes
//          hMsg                   a message handle
// szFileName                      the fully qualified file name, should be passed in if    (OPTIONAL)
//                                 signatures on a file are being viewed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetViewSignaturesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// for the coice field of the CRYPTUI_VIEWSIGNATURES_STRUCT structure
#define EncodedMessage_Chosen   1
#define hMsg_Chosen             2

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCWSTR                 szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTW, *PCRYPTUI_VIEWSIGNATURES_STRUCTW;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTW *PCCRYPTUI_VIEWSIGNATURES_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCSTR                  szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTA, *PCRYPTUI_VIEWSIGNATURES_STRUCTA;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTA *PCCRYPTUI_VIEWSIGNATURES_STRUCTA;


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWSIGNATURES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
//              szTitle
BOOL
WINAPI
CryptUIGetViewSignaturesPagesW(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTW    pcvs,
            OUT PROPSHEETPAGEW                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIGetViewSignaturesPagesA(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTA    pcvs,
            OUT PROPSHEETPAGEA                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesW(
            IN PROPSHEETPAGEW  *rghPropPages,
            IN DWORD           cPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesA(
            IN PROPSHEETPAGEA  *rghPropPages,
            IN DWORD           cPropPages
            );

#ifdef UNICODE
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesW
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesW
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTW
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTW
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTW
#else
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesA
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesA
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTA
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTA
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTA
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the select store dialog can be passed a callback which is called to validate the store that the
//  user selected.  Return TRUE to accept the store, or FALSE to reject the store.  It TRUE is
//  returned then the store will be returned to the caller of CryptUIDlg\, if FALSE is returned
//  then the select store dialog will remain displayed so the user may make another selection

typedef BOOL (WINAPI * PFNCVALIDATESTOREPROC)(
        HCERTSTORE  hStore,
        HWND        hWndSelectStoreDialog,
        void        *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      these two parameters are passed to the CertEnumSystemStore call and the stores that are
//      enumerated via that call are added to the store selection list.
//
//      dwFlags                    CertEnumSystemStore
//      pvSystemStoreLocationPara  CertEnumSystemStore
typedef struct _STORENUMERATION_STRUCT {
    DWORD               dwFlags;
    void *              pvSystemStoreLocationPara;
} STORENUMERATION_STRUCT, *PSTORENUMERATION_STRUCT;
typedef const STORENUMERATION_STRUCT *PCSTORENUMERATION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      both the array of store handles and the array of enumeration strucs may be used to
//      populate the store selection list.  if either is not used the count must be set to 0.
//      if the array of store handles is used the cert stores must have either been opened
//      with the CERT_STORE_SET_LOCALIZED_NAME_FLAG flag, or the CertSetStoreProperty function
//      must have been called with the CERT_STORE_LOCALIZED_NAME_PROP_ID flag.  if the
//      CryptUIDlgSelectStore function is unable to obtain a name for a store that store will not
//      be displayed.
//
//      cStores                    count of stores to select from
//      rghStores                  array of stores to select from
//      cEnumerationStructs        count of enumeration structs
//      rgEnumerationStructs       array of enumeration structs
typedef struct _STORESFORSELCTION_STRUCT {
    DWORD                       cStores;
    HCERTSTORE *                rghStores;
    DWORD                       cEnumerationStructs;
    PCSTORENUMERATION_STRUCT    rgEnumerationStructs;
} STORESFORSELCTION_STRUCT, *PSTORESFORSELCTION_STRUCT;
typedef const STORESFORSELCTION_STRUCT *PCSTORESFORSELCTION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to infor the user what they are selecting a store
//                                 for.  if it is not set a default string will be displayed,
//                                 the default resource is IDS_SELECT_STORE_DEFAULT
// pStoresForSelection             a struct that contains the stores that are to be selected
//                                 from.  the stores can be in two different formats, an array
//                                 of store handles and/or an array of enumeration structs
//                                 which will be used to call CertEnumSystemStore
// pValidateStoreCallback          a pointer to a PFNCVALIDATESTOREPROC which is used to    (OPTIONAL)
//                                 callback the caller of CryptUIDlgSelectStore when the
//                                 user hasselected a store and pressed OK
// pvCallbackData                  if pValidateStoreCallback is being used this value is    (OPTIONAL)
//                                 passed back to the caller when the pValidateStoreCallback
//                                 is made
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW       0x00000001
#define CRYPTUI_RETURN_READ_ONLY_STORE          0x00000002
#define CRYPTUI_DISPLAY_WRITE_ONLY_STORES       0x00000004
#define CRYPTUI_VALIDATE_STORES_AS_WRITABLE     0x00000008

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCWSTR                     szTitle;                // OPTIONAL
    LPCWSTR                     szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTW, *PCRYPTUI_SELECTSTORE_STRUCTW;
typedef const CRYPTUI_SELECTSTORE_STRUCTW *PCCRYPTUI_SELECTSTORE_STRUCTW;

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCSTR                      szTitle;                // OPTIONAL
    LPCSTR                      szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTA, *PCRYPTUI_SELECTSTORE_STRUCTA;
typedef const CRYPTUI_SELECTSTORE_STRUCTA *PCCRYPTUI_SELECTSTORE_STRUCTA;

//
// the HCERTSTORE that is returned must be closed by calling CertCloseStore
//
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            IN PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            );

HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            IN PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            );

#ifdef UNICODE
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreW
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTW
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTW
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTW
#else
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreA
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTA
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTA
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  The select cert dialog can be passed a filter proc to reduce the set of certificates
//  displayed.  Return TRUE to display the certificate and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this cert should be the initially selected cert.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected cert.

typedef BOOL (WINAPI * PFNCFILTERPROC)(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Certificates may be viewed by the user when selecting certificates from the select certificate
//  dialog.  This callback will allow the caller of the select certificate dialog to handle the
//  displaying of those certificates.  This may be useful if the caller wishes to call WinVerifyTrust
//  with their own policy module and display the certificate with that WinVerifyTrust state.  If
//  FALSE is returned from this callback it is assumed that the select certificate dialog will be
//  responsible for dislaying the certificate in question.  If TRUE is returned it is assumed that the
//  display of the certificate was already handled.

typedef BOOL (WINAPI * PFNCCERTDISPLAYPROC)(
        PCCERT_CONTEXT  pCertContext,
        HWND            hWndSelCertDlg,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// dwDontUseColumn                 This can be used to disable the display of certain       (OPTIONAL)
//                                 columns.  It can be set with any comibnation of the
//                                 column flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to inform the user what they are selecting a
//                                 a certificate for.  if it is not set a default string
//                                 will be displayed.  the defualt strings resourece is
//                                 IDS_SELECT_CERT_DEFAULT
// pFilterCallback                 a pointer to a PFNCMFILTERPROC which is used to filter   (OPTIONAL)
//                                 the certificates which are displayed for selection
// pDisplayCallback                a pointer to a PFNCCERTDISPLAYPROC which is used to
//                                 handle displaying certificates
// pvCallbackData                  if either or both pFilterCallback or pDisplayCallback    (OPTIONAL)
//                                 are being used this value is passed back to the caller
//                                 when the callbacks are made
// cDisplayStores                  count of stores that contain the certs to display
//                                 for selection
// rghDisplayStores                array of stores that contain the certs to display
//                                 for selection
// cStores                         count of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// rghStores                       array of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// cPropSheetPages                 PASS THROUGH - number of pages in rgPropSheetPages array (OPTIONAL)
// rgPropSheetPages                PASS THROUGH - extra pages that are passed through       (OPTIONAL)
//                                 to the certificate viewing dialog when it is invoked from
//                                 the selection dialog
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// flags for dwDontUseColumn
#define CRYPTUI_SELECT_ISSUEDTO_COLUMN        0x000000001
#define CRYPTUI_SELECT_ISSUEDBY_COLUMN        0x000000002
#define CRYPTUI_SELECT_INTENDEDUSE_COLUMN     0x000000004
#define CRYPTUI_SELECT_FRIENDLYNAME_COLUMN    0x000000008
#define CRYPTUI_SELECT_LOCATION_COLUMN        0x000000010
#define CRYPTUI_SELECT_EXPIRATION_COLUMN      0x000000020

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCWSTR             szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTW, *PCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCSTR              szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTA, *PCRYPTUI_SELECTCERTIFICATE_STRUCTA;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;

//
// the PCCERT_CONTEXT that is returned must be released by calling CertFreeCertificateContext().
// if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
// "cancel" button, otherwise GetLastError() will contain the last error.
//
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            );

PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            );

#ifdef UNICODE
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateW
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTW
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTW
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTW
#else
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateA
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTA
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTA
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTA
#endif


//flags for dwFlags in CRYPTUI_SELECT_CA_STRUCT struct
#define     CRYPTUI_DLG_SELECT_CA_FROM_NETWORK                  0x0001
#define     CRYPTUI_DLG_SELECT_CA_USE_DN                        0x0002
#define     CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION     0x0004
//-------------------------------------------------------------------------
//
//	CRYPTUI_CA_CONTEXT
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CA_CONTEXT
{
    DWORD                   dwSize;	
    LPCWSTR                 pwszCAName;
    LPCWSTR                 pwszCAMachineName;
}CRYPTUI_CA_CONTEXT, *PCRYPTUI_CA_CONTEXT;

typedef const CRYPTUI_CA_CONTEXT *PCCRYPTUI_CA_CONTEXT;


//-------------------------------------------------------------------------
//
//	
//
//  The select certificate authoritiy (CA) dialog can be passed a filter proc to reduce the set of CAs
//  displayed.  Return TRUE to display the CA and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this CA should be the initially selected CA.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected CA.
//
//-------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CRYPTUI_SELECT_CA_FUNC)(
        PCCRYPTUI_CA_CONTEXT        pCAContext,
        BOOL                        *pfInitialSelected,
        void                        *pvCallbackData);


//-------------------------------------------------------------------------
//
//	CRYPTUI_SELECT_CA_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_SELECT_CA_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Flags, Can be set to any combination of the following:
//                                  CRYPTUI_DLG_SELECT_CA_FROM_NETWORK:
//                                     All the available CAs from the network will be displayed
//                                  CRYPTUI_DLG_SELECT_CA_USE_DN:
//                                     Use the full DN (Distinguished Name) as the CA name.
//                                      By default, CN (common name) is used.
//                                  CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION:
//                                      Display the CAs available to the local machine only.
//                                      By Default, CAs available to the current user will be displayed
//  wszTitle           Optional:    Title of the dialog
//  wszDisplayString   Optional:    A string that will be displayed in the dialog that may   (OPTIONAL)
//                                  be used to inform the user what they are selecting a
//                                  a certificate for.  if it is not set a default string
//                                  will be displayed.  the defualt strings resourece is
//                                  IDS_SELECT_CA_DISPLAY_DEFAULT
//  cCAContext         Optional:    The count of additional CA contexts that will be displayed
//                                  in the dialogs
//  *rgCAContext       Optioanl:    The array of additional CA contexts that will be displayed
//                                  in the dialogs
//  pSelectCACallback  Optional:    a pointer to a PCCRYPTUI_CA_CONTEXT which is used to filter
//                                  the certificate autorities which are displayed for selection
//  pvCallbackData     Optional:    if pSelectCACallback is being used this value is passed
//                                  back to the caller when the pSelectCACallback is made
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_SELECT_CA_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     wszTitle;                   // OPTIONAL
    LPCWSTR                     wszDisplayString;           // OPTIONAL
    DWORD                       cCAContext;                 // OPTIONAL
    PCCRYPTUI_CA_CONTEXT        *rgCAContext;               // OPTIONAL
    PFN_CRYPTUI_SELECT_CA_FUNC  pSelectCACallback;          // OPTIONAL
    void                        *pvCallbackData;            // OPTIONAL
}CRYPTUI_SELECT_CA_STRUCT, *PCRYPTUI_SELECT_CA_STRUCT;

typedef const CRYPTUI_SELECT_CA_STRUCT *PCCRYPTUI_SELECT_CA_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUISelectCA       IN  Required
//
//  the PCCRYPTUI_CA_CONTEXT that is returned must be released by calling
//  CryptUIDlgFreeCAContext
//  if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
//  "cancel" button, otherwise GetLastError() will contain the last error.
//
//
//--------------------------------------------------------------
PCCRYPTUI_CA_CONTEXT
WINAPI
CryptUIDlgSelectCA(
        IN PCCRYPTUI_SELECT_CA_STRUCT pCryptUISelectCA
             );

BOOL
WINAPI
CryptUIDlgFreeCAContext(
        IN PCCRYPTUI_CA_CONTEXT       pCAContext
            );




//-------------------------------------------------------------------------
//
//	CRYPTUI_CERT_MGR_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_CERT_MGR_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Reserved:    Must be set to 0
//  wszTitle           Optional:    Title of the dialog
//  pszInitUsageOID    Optional:    The enhanced key usage object identifier (OID).
//                                  Certificates with this OID will initially
//                                  be shown as a default. User
//                                  can then choose different OIDs.
//                                  NULL means all certificates will be shown initially.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUICertMgr       IN  Required
//
//
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgCertMgr(
        IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);



/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------
//  The valid values for dwFlags for the CryptUIWiz APIs
//
//------------------------------------------------------------------------

#define     CRYPTUI_WIZ_NO_UI                           0x0001


//CRYPTUI_WIZ_NO_INSTALL_ROOT is only valid for CryptUIWizCertRequest API
//the wizard will not install the issued certificate chain into the root store,
//instead, it will put the certificate chain into the CA store.
#define     CRYPTUI_WIZ_NO_INSTALL_ROOT                 0x0010


//CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to enter destination where the CTL will
//be stored.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION       0x0004


//CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to sign the CTL.
//the CTLContext returned by CryptUIWizBuildCTL will not be signed.
//Caller can then use CryptUIWizDigitalSign to sign the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING           0x0008

//CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user for the purpose, validity,
//and list ID of the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE           0x0010


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
{
    DWORD           dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT)
    PCCERT_CONTEXT  pCertContext;       //Required: Use the private key of the certificate context
                                        //          The certificate context
                                        //          has to have CERT_KEY_PROV_INFO_PROP_ID property
                                        //          and the private key has to exist
}CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Required: The information about the provider and the private key
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
}CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Optional: The information about the provider and the private key
                                                //          NULL means use the default
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
    DWORD                   dwGenKeyFlags;      //Optional: The flags for CryptGenKey
}CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_TYPE
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_TYPE
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_TYPE)
    DWORD                   cCertType;          //the count of rgwszCertType.  cCertType should be 1.
    LPWSTR                  *rgwszCertType;     //the array of certificate type name
}CRYPTUI_WIZ_CERT_TYPE, *PCRYPTUI_WIZ_CERT_TYPE;

typedef const CRYPTUI_WIZ_CERT_TYPE *PCCRYPTUI_WIZ_CERT_TYPE;


//-----------------------------------------------------------------------
// dwPvkChoice
//-----------------------------------------------------------------------
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT        1
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING    2
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW         3

//-----------------------------------------------------------------------
// dwPurpose
//-----------------------------------------------------------------------

#define     CRYPTUI_WIZ_CERT_ENROLL     0x00010000
#define     CRYPTUI_WIZ_CERT_RENEW      0x00020000

//-----------------------------------------------------------------------
//
// valid flags for dwPostOption
//-----------------------------------------------------------------------
//post the requested certificate on the directory serivce
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS                     0x01

//post the requested certificate with the private key container.
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP                    0x02

//-----------------------------------------------------------------------
//
// valid flags for dwCertChoice
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                      0x01

#define     CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE                      0x02
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_INFO
{
	DWORD			    dwSize;				    //Required: Has to be set to sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
    DWORD               dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                                //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                                //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                                //          at the same time
    LPCWSTR             pwszMachineName;        //Optional: The machine name for which to enroll.
    LPCWSTR             pwszAccountName;        //Optional: The account name(user or service) for which to enroll
                                                //
                                                //  pwszMachineName     pwszAccountName    Meaning
                                                //---------------------------------------------------
                                                //  NULL                NULL               Request for current account on the current machine
                                                //  "fooMachine"        NULL               Request for the machine named "fooMachine"
                                                //  NULL                "fooUser"          Request for the "fooUser" account on the current machine
                                                //  "fooMachine"        "fooUser"          Request for the "fooUser" accunt on the "fooMachine" machine
                                                //
    void                *pAuthentication;       //Reserved: authenticate info.  Must be set to NULL.
    LPCWSTR             pCertRequestString;     //Reserved: The additional request string.  Must be set to NULL.
    LPCWSTR             pwszDesStore;           //Optional: The desination store where to put
                                                //              the enrolled certificate.  Default to "My" if the value is NULL
    DWORD               dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                                //          destination store
                                                //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                                //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    LPCSTR              pszHashAlg;             //Optional: The oid string of the hash algorithm of the certificate.
	PCCERT_CONTEXT      pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                                //Ignored   otherwise and shoule be set to NULL.
    DWORD               dwPvkChoice;            //Required: Specify the private key information
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                       //Required.
    {
		PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert;	
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting;
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew;
    };

    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)
    DWORD               dwPostOption;           //Optional  Can set to any combination of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS
                                                //
    DWORD               dwCertChoice;           //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is not set
                                                //Required  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is set
                                                //ignored   otherwise and should be set to 0.
                                                //          Specify the type of the requested certificate
                                                //          it can be one of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //              CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE
    union
    {
        PCERT_ENHKEY_USAGE      pKeyUsage;      //          Indicate the enhanced key usage OIDs for the requested certificate.
        PCCRYPTUI_WIZ_CERT_TYPE pCertType;      //          Indicate the certificate type of the requested certificate
    };

    LPCWSTR             pwszFriendlyName;       //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The friendly name of the certificate
    LPCWSTR             pwszDescription;        //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The description of the certificate
    PCERT_EXTENSIONS    pCertRequestExtensions; //Optional  The extensions to add to the certificate request
    LPWSTR              pwszCertDNName;         //Optional  The certificate DN string
}CRYPTUI_WIZ_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CERT_REQUEST_INFO;

typedef const CRYPTUI_WIZ_CERT_REQUEST_INFO *PCCRYPTUI_WIZ_CERT_REQUEST_INFO;


//-----------------------------------------------------------------------
//
// possible status for pdwStatus
//  Those status indicate the status value returned
//  from the certificate authority (certificate server).
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED           0
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR       1
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED      2
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY   3
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION    4
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN             5
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED         6
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED   7


//-----------------------------------------------------------------------
//
//  CryptUIWizCertRequest
//
//      Request a certificate via a wizard.
//
//  dwFlags:  IN Optional
//      If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.
//      If CRYPTUI_WIZ_NO_INSTALL_ROOT is set in dwFlags, the wizard will not
//      install the issued certificate chain into the root store,
//      instead, it will put the certificate chain into the CA store.

//
//  hwndParent:  IN Optional
//      The parent window for the UI.  Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pwszWizardTitle: IN Optional
//      The title of the wizard.   Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CERT_REQUEST_INFO struct
//
//  ppCertContext: Out Optional
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequest(
 IN             DWORD                           dwFlags,
 IN OPTIONAL    HWND                            hwndParent,
 IN OPTIONAL    LPCWSTR                         pwszWizardTitle,
 IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
 OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,
 OUT OPTIONAL   DWORD                           *pCAdwStatus
);

//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in IMPORT_SUBJECT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_FILE                 1
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT         2
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT          3
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT          4
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE           5

//-------------------------------------------------------------------------
//
//	Struct to define the subject CertImportWizard
//
//  CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(IMPORT_SUBJECT_INFO)
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_FILE
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE
    union
	{
		LPCWSTR          	pwszFileName;	
        PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   dwFlags;            //Required if pwszFileName contains a PFX BLOB.
                                                //Ignored otherwise
                                                //This is the same flag for PFXImportCertStore
    LPCWSTR                 pwszPassword;       //Required if pwszFileName contains a PFX BLOB.
                                                //ignored otherwise
}CRYPTUI_WIZ_IMPORT_SRC_INFO, *PCRYPTUI_WIZ_IMPORT_SRC_INFO;

typedef const CRYPTUI_WIZ_IMPORT_SRC_INFO *PCCRYPTUI_WIZ_IMPORT_SRC_INFO;

//-----------------------------------------------------------------------
//
// Valid flags for dwFlags in CryptUIWizImport
//
//-----------------------------------------------------------------------
//if this flag is set in dwFlags, user will not be allowed to change
//the hDesCertStore in the wizard page
#define   CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE           0x00010000

//Allow importing certificate
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CERT                     0x00020000

//Allow importing certificate revocation list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CRL                      0x00040000

//Allow importing certificate trust list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CTL                      0x00080000

//-----------------------------------------------------------------------
//
// CryptU