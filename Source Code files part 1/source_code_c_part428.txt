TTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;

        if (pContext->ContextNames)
        {
            UINT Length = (UINT) wcslen(pContext->ContextNames);
            ContextNames->sUserName = (LPWSTR) UserFunctions->AllocateHeap((Length+1) * sizeof(WCHAR));
            if (ContextNames->sUserName == NULL) {
                Status = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL, "SpQueryContextAttributes, NtLmAllocate returns NULL\n" ));
                goto Cleanup;
            }
            RtlCopyMemory(
                ContextNames->sUserName,
                pContext->ContextNames,
                Length * sizeof(WCHAR)
                );
            *(ContextNames->sUserName + Length) = L'\0';
        }
        else
        {
            SspPrint(( SSP_API_MORE, "SpQueryContextAttributes no ContextNames\n" ));
            ContextNames->sUserName = (LPWSTR) UserFunctions->AllocateHeap(sizeof(WCHAR));
            *(ContextNames->sUserName) = L'\0';
        }

        break;
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfoSize = sizeof(SecPkgInfoW) + sizeof(NTLMSP_NAME) + sizeof(NTLMSP_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfoW) UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PBYTE) PackageInfo->PackageInfo->Name)) + sizeof(NTLMSP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            NTLMSP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTLMSP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_WINNT;
        PackageInfo->PackageInfo->fCapabilities = NTLMSP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTLMSP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }
        break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if(pContext->PasswordExpiry.QuadPart != 0) {
            PasswordExpires->tsPasswordExpires = pContext->PasswordExpiry;
        } else {
            Status = SEC_E_UNSUPPORTED_FUNCTION;
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlags = (PSecPkgContext_UserFlags) Buffer;
        UserFlags->UserFlags = pContext->UserFlags;
        break;

    case SECPKG_ATTR_FLAGS:
    {
        BOOLEAN Client = (pContext->ClientTokenHandle == 0);
        ULONG Flags = 0;

        //
        // note: doesn't return all flags; by design.
        //
        ContextFlags = (PSecPkgContext_Flags) Buffer;
        ContextFlags->Flags = 0;

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            if( Client )
            {
                Flags |= ISC_RET_CONFIDENTIALITY;
            } else {
                Flags |= ASC_RET_CONFIDENTIALITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            if( Client )
            {
                Flags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
            } else {
                Flags |= ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT | ASC_RET_INTEGRITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NULL_SESSION) {
            if( Client )
            {
                Flags |= ISC_RET_NULL_SESSION;
            } else {
                Flags |= ASC_RET_NULL_SESSION;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) {
            if( Client )
            {
                Flags |= ISC_RET_DATAGRAM;
            } else {
                Flags |= ASC_RET_DATAGRAM;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
            if( Client )
            {
                Flags |= ISC_RET_IDENTIFY;
            } else {
                Flags |= ASC_RET_IDENTIFY;
            }
        }

        ContextFlags->Flags |= Flags;

        break;
    }
    case SECPKG_ATTR_ACCESS_TOKEN:
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //
        if(pContext->ClientTokenHandle)
            AccessToken->AccessToken = pContext->ClientTokenHandle;
        else
            Status = SEC_E_NO_IMPERSONATION;
        break;

    case SECPKG_ATTR_LIFESPAN:
    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        switch (Attribute) {

        case SECPKG_ATTR_NAMES:

            if (ContextNames != NULL && ContextNames->sUserName )
            {
                NtLmFree(ContextNames->sUserName);
            }
            break;

        case SECPKG_ATTR_DCE_INFO:

            if (ContextDceInfo != NULL && ContextDceInfo->pPac)
            {
                NtLmFree(ContextDceInfo->pPac);
            }
            break;
        }
    }

    if (pContext != NULL)
    {
        (VOID) DereferenceUserContext(pContext);
    }

    SspPrint(( SSP_API, "Leaving SpQueryContextAttributes: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (InputBuffer);
    SspPrint(( SSP_API, "Entering SpCompleteAuthToken\n" ));
    SspPrint(( SSP_API, "Leaving SpCompleteAuthToken\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (FormattedCredentials);
    SspPrint(( SSP_API, "Entering SpFormatCredentials\n" ));
    SspPrint(( SSP_API, "Leaving SpFormatCredentials\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    UNREFERENCED_PARAMETER (CredentialSize);
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (MarshalledCredSize);
    UNREFERENCED_PARAMETER (MarshalledCreds);
    SspPrint(( SSP_API, "Entering SpMarshallSupplementalCreds\n" ));
    SspPrint(( SSP_API, "Leaving SpMarshallSupplementalCreds\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_CLIENT_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_PACKED_CONTEXT PackedContext = NULL;
    ULONG ContextSize, ContextNameSize = 0;


    if (Context->ContextNames)
    {
        ContextNameSize = (ULONG) wcslen(Context->ContextNames);
    }

    ContextSize =  sizeof(NTLM_CLIENT_CONTEXT) +
                   ContextNameSize * sizeof(WCHAR) + sizeof( WCHAR );

    PackedContext = (PNTLM_PACKED_CONTEXT) NtLmAllocateLsaHeap( ContextSize );

    if (PackedContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    // Copy all fields of the old context

    PackedContext->Tag = NTLM_PACKED_CONTEXT_MAP ;
    PackedContext->NegotiateFlags = Context->NegotiateFlags ;
    PackedContext->SendNonce = Context->SendNonce ;
    PackedContext->RecvNonce = Context->RecvNonce ;
    RtlCopyMemory(
        PackedContext->SessionKey,
        Context->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    PackedContext->ContextSignature = Context->ContextSignature ;
    PackedContext->PasswordExpiry = Context->PasswordExpiry ;
    PackedContext->UserFlags = Context->UserFlags ;
    if ( ContextNameSize )
    {
        PackedContext->ContextNames = sizeof( NTLM_PACKED_CONTEXT );
        PackedContext->ContextNameLength = (ContextNameSize + 1) * sizeof( WCHAR ) ;

        RtlCopyMemory(
            (PackedContext + 1),
            Context->ContextNames,
            PackedContext->ContextNameLength );

    }
    else
    {
        PackedContext->ContextNames = 0 ;
    }

    RtlCopyMemory(
        PackedContext->SignSessionKey,
        Context->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->VerifySessionKey,
        Context->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->SealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->UnsealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &PackedContext->SealRc4Sched,
        &Context->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &PackedContext->UnsealRc4Sched,
        &Context->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );


    // Replace some fields


    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = 0 ;

    // Save the fact that it's exported
    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            NtLmFreeLsaHeap(PackedContext);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    PNTLM_CLIENT_CONTEXT Context = NULL ;
    PNTLM_PACKED_CONTEXT pvContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    BOOLEAN MappedContext = FALSE;


    SspPrint(( SSP_API,"Entering SpExportSecurityContext for context 0x%x\n", ContextHandle ));

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Context = ReferenceUserContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        SspPrint((SSP_CRITICAL, "SpExportSecurityContext: Invalid handle supplied (0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    Status = NtLmMakePackedContext(
                Context,
                &MappedContext,
                PackedContext,
                Flags
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    ASSERT(MappedContext);


    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        ULONG LockIndex;

        LockIndex = ListIndexToLockIndex( HandleToListIndex( ContextHandle ) );

        RtlAcquireResourceShared( &NtLmUserContextLock[LockIndex], TRUE );

        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            RtlConvertSharedToExclusive( &NtLmUserContextLock[LockIndex] );

            *TokenHandle = Context->ClientTokenHandle;
            Context->ClientTokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->ClientTokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }

        RtlReleaseResource( &NtLmUserContextLock[LockIndex] );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    pvContext = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;

    // Semantics of this flag: Export from here, but reset the Nonce.
    // We zero out the session key, since all we need is the rc4 key.

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        pvContext->SendNonce = (ULONG) -1;
        pvContext->RecvNonce = (ULONG) -1;
    }

    RtlZeroMemory(
        &pvContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

Cleanup:

    if (Context != NULL)
    {
        SubStatus = DereferenceUserContext(Context);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API,"Leaving SpExportContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmCreateUserModeContext
//
//  Synopsis:   Creates a user-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmCreateUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN HANDLE Token,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_CLIENT_CONTEXT * NewContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT Context = NULL;
    PNTLM_PACKED_CONTEXT PackedContext;
    ULONG ListIndex;
    ULONG LockIndex;

    if (MarshalledContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        SspPrint((SSP_CRITICAL,"NtLmCreateUserModeContext: Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(NTLM_PACKED_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PNTLM_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Context = (PNTLM_CLIENT_CONTEXT)NtLmAllocate ( sizeof(NTLM_CLIENT_CONTEXT));

    if (Context == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Context->NegotiateFlags = PackedContext->NegotiateFlags ;
    Context->SendNonce = PackedContext->SendNonce ;
    Context->RecvNonce = PackedContext->RecvNonce ;
    RtlCopyMemory(
        Context->SessionKey,
        PackedContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    Context->ContextSignature = PackedContext->ContextSignature ;
    Context->PasswordExpiry = PackedContext->PasswordExpiry ;
    Context->UserFlags = PackedContext->UserFlags ;

    if ( PackedContext->ContextNames )
    {
        Context->ContextNames = (PWSTR) NtLmAllocate( PackedContext->ContextNameLength );
        if ( Context->ContextNames == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }

        RtlCopyMemory(
            Context->ContextNames,
            ((PUCHAR) PackedContext) + PackedContext->ContextNames,
            PackedContext->ContextNameLength );

    }
    else
    {
        Context->ContextNames = NULL ;
    }

    RtlCopyMemory(
        Context->SignSessionKey,
        PackedContext->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        Context->VerifySessionKey,
        PackedContext->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        Context->SealSessionKey,
        PackedContext->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );
    RtlCopyMemory(
        Context->UnsealSessionKey,
        PackedContext->UnsealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &Context->SealRc4Sched,
        &PackedContext->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &Context->UnsealRc4Sched,
        &PackedContext->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );


    // These need to be changed

    Context->ClientTokenHandle = Token;

    if (Context->SendNonce == (ULONG) -1)
    {
        Context->SendNonce = 0;
    }

    if (Context->RecvNonce == (ULONG) -1)
    {
        Context->RecvNonce = 0;
    }

    if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 )
    {
        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->UnsealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->RecvNonce;
    } else {
        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->SealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->SendNonce;
    }

    Context->References = 2;

    //
    // Modify the DACL on the token to grant access to the caller
    //

    if (Context->ClientTokenHandle != NULL)
    {
        Status = SspCreateTokenDacl(
                    Context->ClientTokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    // Dummy up an lsa handle by incrementing a global variable. This
    // will ensure that each imported context has a unique handle.
    // Skip over values that could be interpreted as an aligned pointer,
    // so that they won't get mixed up with real lsa handles.
    Context->LsaContext = InterlockedIncrement((PLONG)&ExportedContext);
    while(Context->LsaContext % MAX_NATURAL_ALIGNMENT == 0)
    {
        Context->LsaContext = InterlockedIncrement((PLONG)&ExportedContext);
    }


    ListIndex = HandleToListIndex( Context->LsaContext );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceExclusive(&NtLmUserContextLock[LockIndex], TRUE);

    InsertHeadList ( &NtLmUserContextList[ListIndex], &Context->Next );
    NtLmUserContextCount[ListIndex]++;

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);

    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            FreeUserContext(Context);
        }
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PULONG_PTR ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT Context = NULL;

    SspPrint(( SSP_API,"Entering SpImportSecurityContext\n"));

    Status = NtLmCreateUserModeContext(
                0,              // no lsa context
                Token,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL,"SpImportSecurityContext: Failed to create user mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *ContextHandle = Context->LsaContext;

Cleanup:

    if (Context != NULL)
    {
        SubStatus = DereferenceUserContext(Context);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API,"Leaving SpImportSecurityContext: 0x%lx\n", Status));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



NTSTATUS
SspGetTokenUser(
    HANDLE Token,
    PTOKEN_USER pTokenUser,
    PULONG TokenUserSize
    )
/*++

RoutineDescription:

    Gets the TOKEN_USER from an open token

Arguments:

    Token - Handle to a token open for TOKEN_QUERY access

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to complete the
        function.

    Errors from NtQueryInformationToken.

--*/

{
    NTSTATUS Status;

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                pTokenUser,
                *TokenUserSize,
                TokenUserSize
                );

    return(Status);
}


NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    )
/*++

RoutineDescription:

    Creates a new DACL for the token granting the server and client
    all access to the token.

Arguments:

    Token - Handle to an impersonation token open for TOKEN_QUERY and
        WRITE_DAC

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - insufficient memory to complete
        the function.

    Errors from NtSetSecurityObject

--*/
{
    NTSTATUS Status;

    PTOKEN_USER ThreadTokenUser;
    PTOKEN_USER ImpersonationTokenUser = NULL;

    PTOKEN_USER SlowProcessTokenUser = NULL;
    PTOKEN_USER SlowThreadTokenUser = NULL;
    PTOKEN_USER SlowImpersonationTokenUser = NULL;

    ULONG_PTR FastThreadTokenUser[ 128/sizeof(ULONG_PTR) ];
    ULONG_PTR FastImpersonationTokenUser[ 128/sizeof(ULONG_PTR) ];
    ULONG TokenUserSize;

    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength;

    PACL NewDacl;
    PACL SlowNewDacl = NULL;
    ULONG_PTR FastNewDacl[ 512/sizeof(ULONG_PTR) ];

    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // Build the two well known sids we need.
    //

    if (NtLmGlobalLocalSystemSid == NULL)
    {
        PSID pLocalSidSystem;
        PSID pOldSid;

        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &pLocalSidSystem
                    );
        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalLocalSystemSid,
                        pLocalSidSystem,
                        NULL
                        );
        if( pOldSid )
        {
            RtlFreeSid( pLocalSidSystem );
        }
    }

    if (NtLmGlobalAliasAdminsSid == NULL)
    {
        PSID pLocalSidAdmins;
        PSID pOldSid;

        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,0,0,0,0,0,
                    &pLocalSidAdmins
                    );
        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalAliasAdminsSid,
                        pLocalSidAdmins,
                        NULL
                        );
        if( pOldSid )
        {
            RtlFreeSid( pLocalSidAdmins );
        }
    }

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //

        ImpersonationTokenUser = (PTOKEN_USER)FastImpersonationTokenUser;
        TokenUserSize = sizeof(FastImpersonationTokenUser);

        Status = SspGetTokenUser(
                    ImpersonationToken,
                    ImpersonationTokenUser,
                    &TokenUserSize
                    );

        if( Status == STATUS_BUFFER_TOO_SMALL )
        {
            SlowImpersonationTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
            if(SlowImpersonationTokenUser == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            ImpersonationTokenUser = SlowImpersonationTokenUser;

            Status = SspGetTokenUser(
                        ImpersonationToken,
                        ImpersonationTokenUser,
                        &TokenUserSize
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
            goto Cleanup;
        }
    }


    if( NtLmGlobalProcessUserSid == NULL )
    {
        PTOKEN_USER ProcessTokenUser;
        ULONG_PTR FastProcessTokenUser[ 128/sizeof(ULONG_PTR) ];
        PSID pOldSid;
        PSID pNewSid;
        ULONG cbNewSid;

        //
        // Open the process token to find out the user sid
        //

        Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    TOKEN_QUERY,
                    &ProcessToken
                    );

        if(!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, NtOpenProcessToken returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        //
        // get the token user for the process token.
        //

        ProcessTokenUser = (PTOKEN_USER)FastProcessTokenUser;
        TokenUserSize = sizeof(FastProcessTokenUser);

        Status = SspGetTokenUser(
                    ProcessToken,
                    ProcessTokenUser,
                    &TokenUserSize
                    );

        if( Status == STATUS_BUFFER_TOO_SMALL )
        {
            SlowProcessTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
            if(SlowProcessTokenUser == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            ProcessTokenUser = SlowProcessTokenUser;

            Status = SspGetTokenUser(
                        ProcessToken,
                        ProcessTokenUser,
                        &TokenUserSize
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        cbNewSid = RtlLengthSid( ProcessTokenUser->User.Sid );
        pNewSid = NtLmAllocate( cbNewSid );
        if( pNewSid == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        CopyMemory( pNewSid, ProcessTokenUser->User.Sid, cbNewSid );

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalProcessUserSid,
                        pNewSid,
                        NULL
                        );
        if( pOldSid )
        {
            NtLmFree( pNewSid );
        }

    }



    //
    // Now get the token user for the thread.
    //

    ThreadTokenUser = (PTOKEN_USER)FastThreadTokenUser;
    TokenUserSize = sizeof(FastThreadTokenUser);

    Status = SspGetTokenUser(
                Token,
                ThreadTokenUser,
                &TokenUserSize
                );

    if( Status == STATUS_BUFFER_TOO_SMALL )
    {
        SlowThreadTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
        if(SlowThreadTokenUser == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        ThreadTokenUser = SlowThreadTokenUser;

        Status = SspGetTokenUser(
                    Token,
                    ThreadTokenUser,
                    &TokenUserSize
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
        goto Cleanup;
    }



    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( NtLmGlobalProcessUserSid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( NtLmGlobalLocalSystemSid ) +
                RtlLengthSid( NtLmGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, NtLmGlobalProcessUserSid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }


    if( AclLength <= sizeof(FastNewDacl) )
    {
        NewDacl = (PACL)FastNewDacl;
    } else {

        SlowNewDacl = (PACL)NtLmAllocate(AclLength );

        NewDacl = SlowNewDacl;

        if (SlowNewDacl == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, NtLmallocate returns 0x%lx\n", NewDacl));
            goto Cleanup;
        }


    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalProcessUserSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        ASSERT( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalLocalSystemSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    ASSERT( NT_SUCCESS( Status ));


Cleanup:

    if (ImpersonationToken != NULL)
    {
        //
        // put the thread token back if we were impersonating.
        //

        SetThreadToken( NULL, ImpersonationToken );
        NtClose(ImpersonationToken);
    }


    if (SlowThreadTokenUser != NULL) {
        NtLmFree( SlowThreadTokenUser );
    }

    if (SlowProcessTokenUser != NULL) {
        NtLmFree( SlowProcessTokenUser );
    }

    if (SlowImpersonationTokenUser != NULL) {

        NtLmFree( SlowImpersonationTokenUser );
    }

    if (SlowNewDacl != NULL) {
        NtLmFree( SlowNewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    return( Status );
}

NTSTATUS
SspMapContext(
    IN PULONG_PTR   phContext,
    IN PUCHAR       pSessionKey,
    IN ULONG        NegotiateFlags,
    IN HANDLE       TokenHandle,
    IN PTimeStamp   PasswordExpiry OPTIONAL,
    IN ULONG        UserFlags,
    OUT PSecBuffer  ContextData
    )

/*++

RoutineDescription:

    Create a local context for a real context
    Don't link it to out list of local contexts.

Arguments:

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PNTLM_PACKED_CONTEXT pContext = NULL;
    ULONG cbContextData;

    WCHAR szContextNames[(UNLEN + DNS_MAX_NAME_LENGTH + 2 + 1) *sizeof (WCHAR)];

    PLUID pLogonId = NULL;
    TOKEN_STATISTICS TokenStats;

    PSSP_CONTEXT pTempContext = (PSSP_CONTEXT)*phContext;
    PACTIVE_LOGON pActiveLogon = NULL;
    LPWSTR pszUserName = NULL;
    UINT Length = 0;
    BOOLEAN bActiveLogonsAreLocked = FALSE;

    if (pTempContext == NULL)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SspMapContext, pTempContext is 0x%lx\n", pTempContext));
        goto Cleanup;
    }

    if ( pTempContext->Credential != NULL )
    {
        pLogonId = &(pTempContext->Credential->LogonId);
    }
    else
    {

        //
        // if it was a local call where the default creds were used, lookup
        // the username and domain name based on the AuthenticationId of the
        // access token.  The local call gets a duplicated access token
        // associated with the original client, so information on this logon
        // should be found in the active logon list.
        //

        if ( NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL &&
            pTempContext->UserName.Length == 0 &&
            pTempContext->UserName.Buffer == NULL &&
            pTempContext->DomainName.Length == 0 &&
            pTempContext->DomainName.Buffer == NULL &&
            TokenHandle )
         {

            DWORD TokenInfoLength = sizeof( TokenStats );

            if ( GetTokenInformation(
                        TokenHandle,
                        TokenStatistics,
                        &TokenStats,
                        TokenInfoLength,
                        &TokenInfoLength
                        ))
            {
                pLogonId = &(TokenStats.AuthenticationId);
            }
        }
    }

    if ( pLogonId )
    {
        NlpLockActiveLogonsRead();
        bActiveLogonsAreLocked = TRUE;
        pActiveLogon = NlpFindActiveLogon(pLogonId);
    }

    szContextNames[0] = L'\0';

    if (pActiveLogon != NULL)
    {
        if ((pActiveLogon->UserName.Length > 0)  &&
            (pActiveLogon->LogonDomainName.Length > 0))
        {
            RtlCopyMemory(szContextNames,
                          pActiveLogon->LogonDomainName.Buffer,
                          pActiveLogon->LogonDomainName.Length);

            Length = (pActiveLogon->LogonDomainName.Length)/sizeof(WCHAR);

            szContextNames[Length] = L'\\';
            Length += 1;
            pszUserName = &szContextNames[Length];

            RtlCopyMemory (pszUserName,
                           pActiveLogon->UserName.Buffer,
                           pActiveLogon->UserName.Length);

            Length += (pActiveLogon->UserName.Length)/sizeof(WCHAR);

            szContextNames[Length] = L'\0';
        }
    }
    else
    {
        // We don't store network logons, but in the case of server side
        // mapping, the client has sent us the Context Names, so use that.
        // Also, handle the case where we don't have domainnames, just usernames
        // Must handle the valid case where both domainname & username are NULL (rdr)

        if ((pTempContext->DomainName.Length > 0)  &&
            (pTempContext->UserName.Length > 0))
        {
            RtlCopyMemory(szContextNames,
                          pTempContext->DomainName.Buffer,
                          pTempContext->DomainName.Length);

            Length = (pTempContext->DomainName.Length)/sizeof(WCHAR);

            szContextNames[Length] = L'\\';
            Length += 1;
            pszUserName = &szContextNames[Length];

            RtlCopyMemory (pszUserName,
                           pTempContext->UserName.Buffer,
                           pTempContext->UserName.Length);

            Length += (pTempContext->UserName.Length)/sizeof(WCHAR);

            szContextNames[Length] = L'\0';

        }
        else if ((pTempContext->DomainName.Length == 0) &&
                 (pTempContext->UserName.Length >0))
        {
            RtlCopyMemory(szContextNames + Length,
                          pTempContext->UserName.Buffer,
                          pTempContext->UserName.Length);

            Length = (pTempContext->UserName.Length)/sizeof(WCHAR);

            szContextNames[Length] = L'\0';
        }
    }

    Length = (UINT) (wcslen(szContextNames) * sizeof(WCHAR));

    cbContextData =
                    sizeof(NTLM_PACKED_CONTEXT) +
                    Length +
                    sizeof(WCHAR);

    cbContextData += pTempContext->cbMarshalledTargetInfo;

    // the first sizeof (NTLM_CLIENT_CONTEXT) bytes can be
    // casted to pContext anyway.

    pContext = (PNTLM_PACKED_CONTEXT)NtLmAllocateLsaHeap( cbContextData );

    if (!pContext)
    {
        SspPrint((SSP_CRITICAL, "SspMapContext, NtLmAllocate returns NULL\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //    ZeroMemory( pContext, cbContextData );

    pContext->NegotiateFlags = NegotiateFlags;

    RtlCopyMemory(pContext->SessionKey,
                  pSessionKey,
                  MSV1_0_USER_SESSION_KEY_LENGTH);


    // Save away the LsaContextHandle
    //    pContext->LsaContext = *phContext;

    // dup token if it exists

    pContext->ClientTokenHandle = 0 ;

    if (TokenHandle != NULL)
    {
        HANDLE Tmp ;
        Status = LsaFunctions->DuplicateHandle(
                           TokenHandle,
                           &Tmp);

        if (!NT_SUCCESS(Status))
        {
            if (pContext)
            {
                NtLmFreeLsaHeap(pContext);
            }
            SspPrint(( SSP_CRITICAL, "SspMapContext, DuplicateHandle returns 0x%lx\n", Status));
            goto Cleanup;
        }

        pContext->ClientTokenHandle = (ULONG) ((ULONG_PTR) Tmp) ;
    }

    if (cbContextData > sizeof(NTLM_PACKED_CONTEXT) )
    {
        pContext->ContextNames = sizeof(NTLM_PACKED_CONTEXT);
        pContext->ContextNameLength = Length;

        RtlCopyMemory(pContext + 1,
                      szContextNames,
                      pContext->ContextNameLength
                      );

        pContext->ContextNameLength += sizeof(WCHAR);
    }
    else
    {
        pContext->ContextNames = 0;
        pContext->ContextNameLength = 0;
    }

    if ( pTempContext->pbMarshalledTargetInfo )
    {
        pContext->MarshalledTargetInfo = (ULONG)pContext->ContextNameLength + sizeof(NTLM_PACKED_CONTEXT) ;
        pContext->MarshalledTargetInfoLength = pTempContext->cbMarshalledTargetInfo;

        RtlCopyMemory( (PBYTE)pContext + pContext->MarshalledTargetInfo,
                        pTempContext->pbMarshalledTargetInfo,
                        pContext->MarshalledTargetInfoLength
                        );
    }

    pContext->SendNonce = 0;
    pContext->RecvNonce = 0;

    ContextData->pvBuffer = pContext;
    ContextData->cbBuffer = cbContextData;


    if (ARGUMENT_PRESENT(PasswordExpiry))
    {
        pContext->PasswordExpiry = *PasswordExpiry;
    }
    else
    {
        pContext->PasswordExpiry.QuadPart = 0;
    }

    pContext->UserFlags = UserFlags;

Cleanup:

    if (bActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
    }

    return(Status);
}


ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    ASSERT( (NTLM_USERLIST_COUNT != 0) );
    ASSERT( (NTLM_USERLIST_COUNT & 1) == 0 );

    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (NTLM_USERLIST_COUNT-1) ) ;
}

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    )
{
    //
    // insure power of two if not one.
    //

    return ( ListIndex & (NtLmUserContextLockCount-1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\subauth.c ===
/*++

Copyright (c) 1987-1994  Microsoft Corporation

Module Name:

    subauth.c

Abstract:

    Interface to SubAuthentication Package.

Author:

    Cliff Van Dyke (cliffv) 23-May-1994

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
 Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\subauth.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"
#include <winreg.h>
#include <kerberos.h>

//
// Prototype for subauthentication routines.
//
// the pre NT 5.0 Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINE)(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

// the NT 5.0 Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINEEX)(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerfomed
);

// the NT 5.0 Generic Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINEGENERIC)(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);
typedef enum _SUBAUTH_TYPE {
    SubAuth = 1,   // Pre NT 5.0 subAuth called using LogonUser
    SubAuthEx,     // NT 5.0 subAuth called during LogonUser
    SubAuthGeneric // NT 5.0 subAuth called during LaCallAuthenticationPackage
} SUBAUTH_TYPE;
//
// Structure describing a loaded SubAuthentication DLL.
//

typedef struct _SUBAUTHENTICATION_DLL {
    LIST_ENTRY Next;
    ULONG DllNumber;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric;
} SUBAUTHENTICATION_DLL, *PSUBAUTHENTICATION_DLL;

//
// Global list of all loaded subauthentication DLLs
//

LIST_ENTRY SubAuthenticationDlls;
RTL_RESOURCE SubAuthenticationCritSect;




VOID
Msv1_0SubAuthenticationInitialization(
    VOID
)
/*++

Routine Description:

    Initialization routine for this source file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlInitializeResource( &SubAuthenticationCritSect );
    InitializeListHead( &SubAuthenticationDlls );
}

PSUBAUTHENTICATION_DLL
ReferenceSubAuth (
    IN ULONG DllNumber,
    OUT PNTSTATUS SubStatus)
{
    LONG RegStatus;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll = NULL;

    HKEY ParmHandle = NULL;
    HINSTANCE DllHandle = NULL;

    CHAR ValueName[sizeof(MSV1_0_SUBAUTHENTICATION_VALUE)+3];
    CHAR DllName[MAXIMUM_FILENAME_LENGTH+1];
    DWORD DllNameSize;
    DWORD DllNameType;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine = NULL;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx = NULL;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric = NULL;

    PLIST_ENTRY ListEntry;

    *SubStatus = STATUS_SUCCESS;
    DllName[0] = 0;

    // See if the SubAuthentication Dll is already loaded.
    //

    RtlAcquireResourceShared(&SubAuthenticationCritSect, TRUE);

    for ( ListEntry = SubAuthenticationDlls.Flink ;
          ListEntry != &SubAuthenticationDlls ;
          ListEntry = ListEntry->Flink) {

        SubAuthenticationDll = CONTAINING_RECORD( ListEntry,
                                                  SUBAUTHENTICATION_DLL,
                                                  Next );

        if ( SubAuthenticationDll->DllNumber == DllNumber ) {
            break;
        }

        SubAuthenticationDll = NULL;

    }

    RtlReleaseResource(&SubAuthenticationCritSect);

    //
    // If the Dll is not already loaded,
    // load it.
    //

    if ( SubAuthenticationDll != NULL ) {
        goto Cleanup;
    }

    //
    // Build the name of the registry value.
    //

    RtlCopyMemory( ValueName,
                   MSV1_0_SUBAUTHENTICATION_VALUE,
                   sizeof(MSV1_0_SUBAUTHENTICATION_VALUE) );

    *SubStatus = RtlIntegerToChar(
                DllNumber & KERB_SUBAUTHENTICATION_MASK,
                10,          // Base
                4,           // Length of buffer
                &ValueName[sizeof(MSV1_0_SUBAUTHENTICATION_VALUE)-1] );

    if ( !NT_SUCCESS(*SubStatus) ) {
        goto Cleanup;
    }


    //
    // Open the MSV1_0_SUBAUTHENTICATION_KEY registry key.
    //


    if ((DllNumber & KERB_SUBAUTHENTICATION_FLAG) == 0) {
        RegStatus = RegOpenKeyExA(
                        HKEY_LOCAL_MACHINE,
                        MSV1_0_SUBAUTHENTICATION_KEY,
                        0,      //Reserved
                        KEY_QUERY_VALUE,
                        &ParmHandle );
    } else {
        RegStatus = RegOpenKeyExA(
                        HKEY_LOCAL_MACHINE,
                        KERB_SUBAUTHENTICATION_KEY,
                        0,      //Reserved
                        KEY_QUERY_VALUE,
                        &ParmHandle );

    }

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_MISC, "Cannot open registry key %s %ld.\n",
                  MSV1_0_SUBAUTHENTICATION_KEY,
                  RegStatus ));
    }
    else
    {

        //
        // Get the registry value.
        //

        DllNameSize = sizeof(DllName);

        RegStatus = RegQueryValueExA(
                    ParmHandle,
                    ValueName,
                    NULL,     // Reserved
                    &DllNameType,
                    (LPBYTE) DllName,
                    &DllNameSize );

        if ( RegStatus == ERROR_SUCCESS ) {

            if ( DllNameType != REG_SZ ) {
                SspPrint((SSP_MISC, "Registry value %s isn't REG_SZ.\n",
                      ValueName ));
                *SubStatus = STATUS_DLL_NOT_FOUND;
                goto Cleanup;
            }

            //
            // Load the DLL
            //

            DllHandle = LoadLibraryA( DllName );

            if ( DllHandle == NULL ) {
                SspPrint((SSP_MISC, "MSV1_0: Cannot load dll %s %ld.\n",
                  DllName,
                  GetLastError() ));
                *SubStatus = STATUS_DLL_NOT_FOUND;
                goto Cleanup;
            }

            //
            // Find the SubAuthenticationRoutine. For packages other than
            // zero, this will be Msv1_0SubauthenticationRoutine. For packge
            // zero it will be Msv1_0SubauthenticationFilter.
            //

            if ((DllNumber & KERB_SUBAUTHENTICATION_MASK) == 0)
            {
                SubAuthenticationRoutine = (PSUBAUTHENTICATION_ROUTINE)
                GetProcAddress(DllHandle, "Msv1_0SubAuthenticationFilter");
            }
            else
            {
                SubAuthenticationRoutine = (PSUBAUTHENTICATION_ROUTINE)
                GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutine");
            }

            //
            // Find the SubAuthenticationRoutine
            //

            SubAuthenticationRoutineEx = (PSUBAUTHENTICATION_ROUTINEEX)
            GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutineEx");

            //
            // Find the SubAuthenticationRoutineGeneric
            //

            SubAuthenticationRoutineGeneric = (PSUBAUTHENTICATION_ROUTINEGENERIC)
            GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutineGeneric");

        }
    }

    //
    // If we didn't find the DLL or any routines, bail out now.
    //

    if ((DllHandle == NULL) ||
        ((SubAuthenticationRoutine == NULL) &&
        (SubAuthenticationRoutineEx == NULL) &&
        (SubAuthenticationRoutineGeneric == NULL))) {

        SspPrint((SSP_MISC, "Cannot find any of the subauth entry points in %s %ld.\n",
           DllName,
           GetLastError() ));
        *SubStatus = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Cache the address of the procedure.
    //

    SubAuthenticationDll =
        I_NtLmAllocate(sizeof(SUBAUTHENTICATION_DLL));

    if ( SubAuthenticationDll == NULL ) {
        *SubStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    SubAuthenticationDll->DllNumber = DllNumber;
    SubAuthenticationDll->SubAuthenticationRoutine = SubAuthenticationRoutine;
    SubAuthenticationDll->SubAuthenticationRoutineEx = SubAuthenticationRoutineEx;
    SubAuthenticationDll->SubAuthenticationRoutineGeneric = SubAuthenticationRoutineGeneric;

    RtlAcquireResourceExclusive(&SubAuthenticationCritSect, TRUE);
    InsertHeadList( &SubAuthenticationDlls, &SubAuthenticationDll->Next );
    RtlReleaseResource(&SubAuthenticationCritSect);

    DllHandle = NULL;

    //
    // Cleanup up before returning.
    //

Cleanup:


    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }

    if ( !NT_SUCCESS( *SubStatus) ) {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }

    return SubAuthenticationDll;
}


BOOLEAN
Msv1_0SubAuthenticationPresent(
    IN ULONG DllNumber
)
/*++

Routine Description:

    Returns TRUE if there is a subauthentication package with the given number

Arguments:

    DllNumber - the number of the DLL to check

Return Value:

    TRUE if there is a subauthentication DLL, otherwise FALSE.

--*/
{
    NTSTATUS SubStatus;
    BOOLEAN Present;

    if(ReferenceSubAuth( DllNumber, &SubStatus) != NULL) {
        Present = TRUE;
    } else {
        Present = FALSE;
    }

    return Present;
}


NTSTATUS
Msv1_0SubAuthenticationRoutineZero(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    ULONG DllNumber;

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;
    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;

    if( DllNumber != 0 ) {
        return STATUS_SUCCESS;
    }

    return Msv1_0SubAuthenticationRoutine(
                    LogonLevel,
                    LogonInformation,
                    Flags,
                    UserAll,
                    WhichFields,
                    UserFlags,
                    Authoritative,
                    LogoffTime,
                    KickoffTime
                    );
}



NTSTATUS
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    ULONG DllNumber;
    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;


    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;
    *Authoritative = TRUE;

    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth ( DllNumber, &SubStatus);

    //
    // If this was package zero and we didn't find it, remember it for
    // next time.
    //

    if ( (DllNumber == 0) && (SubAuthenticationDll == NULL) ) {
        NlpSubAuthZeroExists = FALSE;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }


    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutine = SubAuthenticationDll->SubAuthenticationRoutine;

    if (SubAuthenticationRoutine == NULL)
    {
        if( DllNumber == 0 ) {

            //
            // If this was package zero and we didn't find it, remember it for
            // next time.
            //

            NlpSubAuthZeroExists = FALSE;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_PROCEDURE_NOT_FOUND;
        }
        goto Cleanup;
    }

    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutine)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   WhichFields,
                   UserFlags,
                   Authoritative,
                   LogoffTime,
                   KickoffTime );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}


NTSTATUS
Msv1_0ExportSubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN ULONG DllNumber,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags -- Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    DllNumber - The number of the subauthentication DLL to call.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;


    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    *Authoritative = TRUE;

    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth ( DllNumber, &SubStatus);

    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutine = SubAuthenticationDll->SubAuthenticationRoutine;

    if (SubAuthenticationRoutine == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutine)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   WhichFields,
                   UserFlags,
                   Authoritative,
                   LogoffTime,
                   KickoffTime );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}



NTSTATUS
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    ULONG DllNumber;
    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;


    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth (DllNumber, &SubStatus);;


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutineEx = SubAuthenticationDll->SubAuthenticationRoutineEx;

    if (SubAuthenticationRoutineEx == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }
    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutineEx)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   UserHandle,
                   ValidationInfo,
                   ActionsPerformed
                   );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}

NTSTATUS
MspNtSubAuth(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0SubAuthInfo.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PMSV1_0_SUBAUTH_REQUEST SubAuthRequest;
    PMSV1_0_SUBAUTH_RESPONSE SubAuthResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    ULONG ReturnDataLength = 0;
    PVOID ReturnDataBuffer = NULL;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric;

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_SUBAUTH_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    SubAuthRequest = (PMSV1_0_SUBAUTH_REQUEST) ProtocolSubmitBuffer;

    //
    // Make sure the buffer fits in the supplied size
    //

    if (SubAuthRequest->SubAuthSubmitBuffer != NULL) {
        if (SubAuthRequest->SubAuthSubmitBuffer + SubAuthRequest->SubAuthInfoLength >
            (PUCHAR) ClientBufferBase + SubmitBufferSize) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Reset the pointers for the validation data
        //

        SubAuthRequest->SubAuthSubmitBuffer =
                (PUCHAR) SubAuthRequest -
                (ULONG_PTR) ClientBufferBase +
                (ULONG_PTR) SubAuthRequest->SubAuthSubmitBuffer;

    }

    // If subauth package found, call the routine,


    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth (SubAuthRequest->SubAuthPackageId, &SubStatus);;


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutineGeneric = SubAuthenticationDll->SubAuthenticationRoutineGeneric;

    if (SubAuthenticationRoutineGeneric == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }
    Status = (*SubAuthenticationRoutineGeneric)(
                           (PVOID) SubAuthRequest->SubAuthSubmitBuffer,
                           SubAuthRequest->SubAuthInfoLength,
                           &ReturnDataLength,
                           &ReturnDataBuffer);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_SUBAUTH_RESPONSE) +
                        ReturnDataLength;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_SUBAUTH_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    SubAuthResponse = (PMSV1_0_SUBAUTH_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    SubAuthResponse->MessageType = MsV1_0SubAuth;
    SubAuthResponse->SubAuthInfoLength = ReturnDataLength;

    if (ReturnDataLength > 0)
    {
        SubAuthResponse->SubAuthReturnBuffer = ClientBufferDesc.UserBuffer + sizeof(MSV1_0_SUBAUTH_RESPONSE);

        if (ReturnDataBuffer)
        {
            RtlCopyMemory(
                SubAuthResponse + 1,
                ReturnDataBuffer,
                ReturnDataLength
                );

            // Make relative pointers
            SubAuthResponse->SubAuthReturnBuffer = (PUCHAR) sizeof(MSV1_0_SUBAUTH_RESPONSE);
        }
        else
        {
            SubAuthResponse->SubAuthReturnBuffer = NULL;
            SubStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        SubAuthResponse->SubAuthReturnBuffer = 0;
    }


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if (ReturnDataBuffer != NULL) {
        MIDL_user_free(ReturnDataBuffer);
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    *ProtocolStatus = SubStatus;
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\utility.cxx ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    utility.cxx

Abstract:

    Private NtLmSsp service utility routines.

Author:

    Cliff Van Dyke (cliffv) 9-Jun-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    ChandanS  06-Aug-1996 Stolen from net\svcdlls\ntlmssp\common\utility.c

--*/

//
// Common include files.
//

#include <global.h>

//
// Include files specific to this .c file
//

#include <netlib.h>     // NetpMemoryFree()
#include <secobj.h>     // ACE_DATA ...
#include <stdio.h>      // vsprintf().
#include <tstr.h>       // TCHAR_ equates.

#define SSP_TOKEN_ACCESS (READ_CONTROL              |\
                          WRITE_DAC                 |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)


#if DBG


SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    )
/*++

Routine Description:

    Convert an NtStatus code to the corresponding Security status code. For
    particular errors that are required to be returned as is (for setup code)
    don't map the errors.


Arguments:

    NtStatus - NT status to convert

Return Value:

    Returns security status code.

--*/
{
    //
    // this routine is left here for DBG builds to enable the developer
    // to ASSERT on status codes, etc.
    //

    return(NtStatus);
}

#endif


BOOLEAN
SspTimeHasElapsed(
    IN ULONG TickStart,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds have elapsed since TickStart.

Arguments:

    TickStart - Specifies a tick count when the event started in milliseconds.

    Timeout   - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since TickStart.

--*/
{
    ULONG TickNow = 0;

    TickNow = GetTickCount();

    //
    // TickNow < TickStart means TickCount is wrapped around (happens very
    // 49.7 days)
    //
    // We assume the interim between the Init/Accept calls with the same
    // context can have at most one wrapping around
    //

    if ( (TickNow > TickStart && TickNow - TickStart > TickNow) ||
         (TickNow < TickStart && 0xFFFFFFFF - TickStart + TickNow > Timeout) ) {
        return TRUE;
    }

    return FALSE;
}


SECURITY_STATUS
SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken
    )
/*++

Routine Description:

    Duplicates a token

Arguments:

    OriginalToken - Token to duplicate
    DuplicatedToken - Receives handle to duplicated token

Return Value:

    Any error from NtDuplicateToken

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.EffectiveOnly = FALSE;
    QualityOfService.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    QualityOfService.ImpersonationLevel = ImpersonationLevel;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    Status = NtDuplicateToken(
                OriginalToken,
                SSP_TOKEN_ACCESS,
                &ObjectAttributes,
                FALSE,
                TokenImpersonation,
                DuplicatedToken
                );

    return(SspNtStatusToSecStatus(Status, SEC_E_NO_IMPERSONATION));
}


LPWSTR
SspAllocWStrFromWStr(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Allocate and copy unicode string (wide character strdup)

Arguments:

    Unicode - pointer to wide character string to make copy of

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NtLmFree.

--*/

{
    DWORD   Size;
    LPWSTR  ptr;

    Size = (DWORD) WCSSIZE(Unicode);
    ptr = (LPWSTR)NtLmAllocate(Size);
    if ( ptr != NULL) {
        RtlCopyMemory(ptr, Unicode, Size);
    }
    return ptr;
}


VOID
SspHidePassword(
    IN OUT PUNICODE_STRING Password
    )
/*++

Routine Description:

    Run-encodes the password so that it is not very visually
    distinguishable.  This is so that if it makes it to a
    paging file, it wont be obvious.


    WARNING - This routine will use the upper portion of the
    password's length field to store the seed used in encoding
    password.  Be careful you don't pass such a string to
    a routine that looks at the length (like and RPC routine).

Arguments:

    Seed - The seed to use to hide the password.

    PasswordSource - Contains password to hide.

Return Value:


--*/
{
    SspPrint((SSP_API_MORE, "Entering SspHidePassword\n"));

    if( (Password->Length != 0) && (Password->MaximumLength != 0) )
    {
        LsaFunctions->LsaProtectMemory( Password->Buffer, (ULONG)Password->MaximumLength );
    }

    SspPrint((SSP_API_MORE, "Leaving SspHidePassword\n"));
}


VOID
SspRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    )
/*++

Routine Description

    Reveals a previously hidden password so that it
    is plain text once again.

Arguments:

    HiddenPassword - Contains the password to reveal

Return Value

--*/
{
    SspPrint((SSP_API_MORE, "Entering SspRevealPassword\n"));

    if( (HiddenPassword->Length != 0) && (HiddenPassword->MaximumLength != 0) )
    {
        LsaFunctions->LsaUnprotectMemory( HiddenPassword->Buffer, (ULONG)HiddenPassword->MaximumLength );
    }

    SspPrint((SSP_API_MORE, "Leaving SspRevealPassword\n"));
}


BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    )

/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
        token. If not specified, TokenBuffer and TokenSize will be returned
        as NULL.

    TokenBuffer - Returns a pointer to the buffer for the token.

    TokenSize - Returns a pointer to the location of the size of the buffer.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

{
    ULONG i, Index = 0;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    ASSERT(*Token != NULL);
    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        return TRUE;
    }

    if (TokenDescriptor->ulVersion != SECBUFFER_VERSION)
    {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            // reject the buffer.
            //

            if (!ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY))
            {
                return  FALSE;
            }

            //
            // It is possible that there are > 1 buffers of type SECBUFFER_TOKEN
            // eg, the rdr
            //

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }

            //
            // Return the requested information
            //

            if (!NT_SUCCESS(LsaFunctions->MapBuffer(Buffer, Buffer)))
            {
                return FALSE;
            }
            *Token = Buffer;
            return TRUE;
        }

    }

    //
    // If we didn't have a buffer, fine.
    //

    SspPrint((SSP_API_MORE, "SspGetTokenBuffer: No token passed in\n"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\pwdtest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    pwdtest.c

Abstract:

    Test program for the changing passwords.

Author:

    30-Apr-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
 Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\pwdtest.c


--*/


//
// Common include files.
//

#include <msp.h>
#define NLP_ALLOCATE
#include <nlp.h>
#include <lsarpc.h>     // Lsar routines
#include <lsaisrv.h>    // LsaIFree and Trusted Client Routines
#include <stdio.h>


//
// Dummy routines from LSA
//

NTSTATUS
LsapAllocateClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )

{

    UNREFERENCED_PARAMETER (ClientRequest);
    *ClientBaseAddress = RtlAllocateHeap( MspHeap, 0, LengthRequired );

    if ( *ClientBaseAddress == NULL ) {
        return(STATUS_QUOTA_EXCEEDED);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapFreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress OPTIONAL
    )
{
    UNREFERENCED_PARAMETER (ClientRequest);
    UNREFERENCED_PARAMETER (ClientBaseAddress);

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapCopyToClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )

{
    UNREFERENCED_PARAMETER (ClientRequest);
    RtlMoveMemory( ClientBaseAddress, BufferToCopy, Length );
    return(STATUS_SUCCESS);
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the password changing.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NTSTATUS Status;
    MSV1_0_CHANGEPASSWORD_REQUEST Request;
    PMSV1_0_CHANGEPASSWORD_RESPONSE ReturnBuffer;
    ULONG ReturnBufferSize;
    NTSTATUS ProtocolStatus;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    UNICODE_STRING LocalComputerName = { 0, 0, NULL };
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    if ( argc < 5 ) {
        fprintf( stderr,
            "Usage: pwdtest DomainName UserName OldPassword NewPassword\n" );
        return(1);
    }

    //
    // Set up MSV1_0.dll environment.
    //

    MspHeap = RtlProcessHeap();

    Status = NlInitialize();

    if ( !NT_SUCCESS( Status ) ) {
        printf("pwdtest: NlInitialize failed, status %x\n", Status);
        return(1);
    }

    Lsa.AllocateClientBuffer = LsapAllocateClientBuffer;
    Lsa.FreeClientBuffer = LsapFreeClientBuffer;
    Lsa.CopyToClientBuffer = LsapCopyToClientBuffer;



    //
    // Open the LSA policy database in case change password needs it
    //

    InitializeObjectAttributes( &LSAObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( &LocalComputerName,
                            &LSAObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &NlpPolicyHandle );

    if( !NT_SUCCESS(Status) ) {
        printf("pwdtest: LsaOpenPolicy failed, status %x\n", Status);
        return(1);
    }


    //
    // Get the name of our domain.
    //

    Status = LsaQueryInformationPolicy(
                    NlpPolicyHandle,
                    PolicyPrimaryDomainInformation,
                    (PVOID *) &PrimaryDomainInfo );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("pwdtest: LsaQueryInformationPolicy failed, status %x\n",
                 Status));
        return(1);
    }

    NlpSamDomainName = PrimaryDomainInfo->Name;



    //
    // Build the request message
    //

    Request.MessageType = MsV1_0ChangePassword;
    RtlCreateUnicodeStringFromAsciiz( &Request.DomainName, argv[1] );
    RtlCreateUnicodeStringFromAsciiz( &Request.AccountName, argv[2] );
    RtlCreateUnicodeStringFromAsciiz( &Request.OldPassword, argv[3] );
    RtlCreateUnicodeStringFromAsciiz( &Request.NewPassword, argv[4] );

    Status = MspLm20ChangePassword( NULL,
                                    &Request,
                                    &Request,
                                    0x7FFFFFFF,
                                    (PVOID *) &ReturnBuffer,
                                    &ReturnBufferSize,
                                    &ProtocolStatus );

    printf( "Status = 0x%lx  0x%lx\n", Status, ProtocolStatus );

    if ( ProtocolStatus == STATUS_CANT_DISABLE_MANDATORY ) {
        printf( "Are you running as SYSTEM?\n" );
    }

    if ( ReturnBufferSize != 0 ) {
        printf( "PasswordInfoValid %ld\n", ReturnBuffer->PasswordInfoValid );
        if ( ReturnBuffer->PasswordInfoValid ) {
            printf( "Min length: %ld  PasswordHistory: %ld  Prop 0x%lx\n",
                ReturnBuffer->DomainPasswordInfo.MinPasswordLength,
                ReturnBuffer->DomainPasswordInfo.PasswordHistoryLength,
                ReturnBuffer->DomainPasswordInfo.PasswordProperties );
        }
    }
    return 0;


}


//
// Stub routines needed by msvpaswd.c
//

NTSTATUS
LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )
{
    return( LsaQueryInformationPolicy( PolicyHandle,
                                       InfoClass,
                                       Buffer ) );
}

VOID
LsaIFree_LSAPR_POLICY_INFORMATION (
    POLICY_INFORMATION_CLASS InfoClass,
    PLSAPR_POLICY_INFORMATION Buffer
    )
{
    UNREFERENCED_PARAMETER (InfoClass);
    UNREFERENCED_PARAMETER (Buffer);
}

NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )
{
    UNREFERENCED_PARAMETER (DomainName);
    UNREFERENCED_PARAMETER (UserName);
    UNREFERENCED_PARAMETER (LmOwfPassword);
    UNREFERENCED_PARAMETER (NtOwfPassword);
    return(STATUS_SUCCESS);
}



NTSTATUS
NlInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize NETLOGON portion of msv1_0 authentication package.

Arguments:

    None.

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status;
    LPWSTR ComputerName;
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NT_PRODUCT_TYPE NtProductType;
    UNICODE_STRING TempUnicodeString;

    //
    // Initialize global data
    //

    NlpEnumerationHandle = 0;
    NlpSessionCount = 0;

    NlpComputerName.Buffer = NULL;
    NlpSamDomainName.Buffer = NULL;
    NlpSamDomainId = NULL;
    NlpSamDomainHandle = NULL;



    //
    // Get the name of this machine.
    //

    ComputerName = RtlAllocateHeap(
                        MspHeap, 0,
                        ComputerNameLength * sizeof(WCHAR) );

    if (ComputerName == NULL ||
        !GetComputerNameW( ComputerName, &ComputerNameLength )) {

        KdPrint(( "MsV1_0: Cannot get computername %lX\n", GetLastError() ));

        NlpLanmanInstalled = FALSE;
        RtlFreeHeap( MspHeap, 0, ComputerName );
        ComputerName = NULL;
    } else {

        NlpLanmanInstalled = TRUE;
    }

    RtlInitUnicodeString( &NlpComputerName, ComputerName );

    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        KdPrint(( "MsV1_0: Nt Product Type undefined (WinNt assumed)\n" ));
        NtProductType = NtProductWinNt;
    }

    NlpWorkstation = (BOOLEAN)(NtProductType != NtProductLanManNt);


#ifdef notdef

    //
    // Initialize any locks.
    //

    __try
    {
        RtlInitializeResource(&NlpActiveLogonLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( NT_SUCCESS(Status) );

    InitializeListHead(&NlpActiveLogonListAnchor);
    RtlInitializeCriticalSection(&NlpSessionCountLock);

    //
    // initialize the cache - creates a critical section is all
    //

    NlpCacheInitialize();
#endif // notdef


    //
    // Attempt to load Netapi.dll
    //

    NlpLoadNetapiDll();

#ifdef COMPILED_BY_DEVELOPER
    KdPrint(("msv1_0: COMPILED_BY_DEVELOPER breakpoint.\n"));
    DbgBreakPoint();
#endif // COMPILED_BY_DEVELOPER

    //
    // Initialize useful encryption constants
    //

    Status = RtlCalculateLmOwfPassword( "", &NlpNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &NlpNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );

#ifdef notdef
    //
    // If we weren't successful,
    //  Clean up global resources we intended to initialize.
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( NlpComputerName.Buffer != NULL ) {
            MIDL_user_free( NlpComputerName.Buffer );
        }

    }
#endif // notdef

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\kernel\krnlapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        krnlapi.cxx
//
// Contents:    Kernel-mode APIs to the NTLM package
//
//
// History:     07-Sep-1996   Created         ChandanS
//
//------------------------------------------------------------------------

#include <ntlmkrnl.h>
extern "C"
{
#include <cryptdll.h>
#include <zwapi.h>
}

#include "crc32.h"  // How to use crc32

extern "C"
{
#include <rc4.h>    // How to use RC4 routine
#include <md5.h>
#include <hmac.h>
}

#define DEFENSIVE_HANDLES


// Context Signatures

#define NTLM_CONTEXT_SIGNATURE 'MLTN'
#define NTLM_CONTEXT_DELETED_SIGNATURE 'XXXX'

// Keep this is sync with NTLM_KERNEL_CONTEXT defined in
// security\msv_sspi\userapi.cxx

typedef struct _NTLM_KERNEL_CONTEXT{
    KSEC_LIST_ENTRY      List;
    ULONG_PTR            LsaContext;
    ULONG                NegotiateFlags;
    HANDLE               ClientTokenHandle;
    PACCESS_TOKEN        AccessToken;

    PULONG                  pSendNonce;      // ptr to nonce to use for send
    PULONG                  pRecvNonce;      // ptr to nonce to use for receive
    struct RC4_KEYSTRUCT *  pSealRc4Sched;   // ptr to key sched used for Seal
    struct RC4_KEYSTRUCT *  pUnsealRc4Sched; // ptr to key sched used to Unseal

    ULONG                   SendNonce;
    ULONG                   RecvNonce;
    LPWSTR                  ContextNames;
    PUCHAR                  pbMarshalledTargetInfo;
    ULONG                   cbMarshalledTargetInfo;
    UCHAR                SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    ULONG                ContextSignature;
    ULONG                References ;
    TimeStamp            PasswordExpiry;
    ULONG                UserFlags;
    UCHAR                   SignSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   VerifySessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   SealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   UnsealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    ULONG64                 Pad1;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    SealRc4Sched;   // key struct used for Seal
    ULONG64                 Pad2;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    UnsealRc4Sched; // key struct used to Unseal
} NTLM_KERNEL_CONTEXT, * PNTLM_KERNEL_CONTEXT;

typedef struct _NTLM_PACKED_CONTEXT {
    ULONG   Tag ;
    ULONG   NegotiateFlags ;
    ULONG   ClientTokenHandle ;
    ULONG   SendNonce ;
    ULONG   RecvNonce ;
    UCHAR   SessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    ULONG   ContextSignature ;
    TimeStamp   PasswordExpiry ;
    ULONG   UserFlags ;
    ULONG   ContextNames ;
    ULONG   ContextNameLength ;
    ULONG   MarshalledTargetInfo;       // offset
    ULONG   MarshalledTargetInfoLength;
    UCHAR   SignSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   VerifySessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   SealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   UnsealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    struct RC4_KEYSTRUCT    SealRc4Sched;
    struct RC4_KEYSTRUCT    UnsealRc4Sched;
} NTLM_PACKED_CONTEXT, * PNTLM_PACKED_CONTEXT ;


#define NTLM_PACKED_CONTEXT_MAP     0

#define CSSEALMAGIC "session key to client-to-server sealing key magic constant"
#define SCSEALMAGIC "session key to server-to-client sealing key magic constant"
#define CSSIGNMAGIC "session key to client-to-server signing key magic constant"
#define SCSIGNMAGIC "session key to server-to-client signing key magic constant"

typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;


//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
KspInitPackageFn       NtLmInitKernelPackage;
KspDeleteContextFn     NtLmDeleteKernelContext;
KspInitContextFn       NtLmInitKernelContext;
KspMapHandleFn         NtLmMapKernelHandle;
KspMakeSignatureFn     NtLmMakeSignature;
KspVerifySignatureFn   NtLmVerifySignature;
KspSealMessageFn       NtLmSealMessage;
KspUnsealMessageFn     NtLmUnsealMessage;
KspGetTokenFn          NtLmGetContextToken;
KspQueryAttributesFn   NtLmQueryContextAttributes;
KspCompleteTokenFn     NtLmCompleteToken;
SpExportSecurityContextFn NtLmExportSecurityContext;
SpImportSecurityContextFn NtLmImportSecurityContext;
KspSetPagingModeFn     NtlmSetPagingMode ;

//
// Local prototypes:
//

NTSTATUS
NtLmCreateKernelModeContext(
    IN ULONG ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_KERNEL_CONTEXT * NewContext
    );

NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_KERNEL_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    );

NTSTATUS
NtlmFreeKernelContext (
    PNTLM_KERNEL_CONTEXT KernelContext
    );

#define NtlmReferenceContext( Context, Remove ) \
            KSecReferenceListEntry( (PKSEC_LIST_ENTRY) Context, \
                                    NTLM_CONTEXT_SIGNATURE, \
                                    Remove )

VOID
NtlmDerefContext(
    PNTLM_KERNEL_CONTEXT Context
    );

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    );

VOID
SspEncryptBuffer(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    );

VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    );

SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    );

} // extern "C"




#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLmInitKernelPackage)
#pragma alloc_text(PAGE, NtLmDeleteKernelContext)
#pragma alloc_text(PAGE, NtLmInitKernelContext)
#pragma alloc_text(PAGE, NtLmMapKernelHandle)
#pragma alloc_text(PAGEMSG, NtLmMakeSignature)
#pragma alloc_text(PAGEMSG, NtLmVerifySignature)
#pragma alloc_text(PAGEMSG, NtLmSealMessage)
#pragma alloc_text(PAGEMSG, NtLmUnsealMessage)
#pragma alloc_text(PAGEMSG, NtLmGetContextToken)
#pragma alloc_text(PAGEMSG, NtLmQueryContextAttributes)
#pragma alloc_text(PAGEMSG, NtlmDerefContext )
#pragma alloc_text(PAGE, NtLmCompleteToken)
#pragma alloc_text(PAGE, NtLmExportSecurityContext)
#pragma alloc_text(PAGE, NtLmImportSecurityContext)
#pragma alloc_text(PAGEMSG, NtlmFreeKernelContext )

#pragma alloc_text(PAGE, NtLmCreateKernelModeContext )
#pragma alloc_text(PAGE, NtLmMakePackedContext )

#pragma alloc_text(PAGEMSG, SspGenCheckSum)
#pragma alloc_text(PAGEMSG, SspEncryptBuffer)
#pragma alloc_text(PAGE, SspRc4Key)
#pragma alloc_text(PAGEMSG, SspSignSealHelper)

#endif

SECPKG_KERNEL_FUNCTION_TABLE NtLmFunctionTable = {
    NtLmInitKernelPackage,
    NtLmDeleteKernelContext,
    NtLmInitKernelContext,
    NtLmMapKernelHandle,
    NtLmMakeSignature,
    NtLmVerifySignature,
    NtLmSealMessage,
    NtLmUnsealMessage,
    NtLmGetContextToken,
    NtLmQueryContextAttributes,
    NtLmCompleteToken,
    NtLmExportSecurityContext,
    NtLmImportSecurityContext,
    NtlmSetPagingMode
};

PSECPKG_KERNEL_FUNCTIONS LsaKernelFunctions;
POOL_TYPE NtlmPoolType ;
PVOID NtlmPagedList ;
PVOID NtlmNonPagedList ;
PVOID NtlmActiveList ;

#define MAYBE_PAGED_CODE() \
    if ( NtlmPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }



//+-------------------------------------------------------------------------
//
//  Function:   FreeKernelContext
//
//  Synopsis:   frees alloced pointers in this context and
//              then frees the context
//
//  Arguments:  KernelContext  - the unlinked kernel context
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
NtlmFreeKernelContext (
    PNTLM_KERNEL_CONTEXT KernelContext
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering FreeKernelContext\n" ));

    if (KernelContext->ContextNames != NULL)
    {
        NtLmFree (KernelContext->ContextNames);
    }

    if (KernelContext->ClientTokenHandle != NULL)
    {
        NTSTATUS IgnoreStatus;

#ifdef DEFENSIVE_HANDLES
        OBJECT_HANDLE_FLAG_INFORMATION HandleInfo ;

        HandleInfo.Inherit = FALSE ;
        HandleInfo.ProtectFromClose = FALSE ;

        IgnoreStatus = ZwSetInformationObject(
                            KernelContext->ClientTokenHandle,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof(HandleInfo) );

        ASSERT( NT_SUCCESS( IgnoreStatus ) );
#endif
        IgnoreStatus = NtClose( KernelContext->ClientTokenHandle);
        ASSERT (NT_SUCCESS (IgnoreStatus));
    }

    if (KernelContext->AccessToken != NULL)
    {
        ObDereferenceObject (KernelContext->AccessToken);
    }

    DebugLog(( DEB_TRACE, "Deleting Context 0x%lx\n", KernelContext));

    NtLmFree (KernelContext);

    DebugLog(( DEB_TRACE, "Leaving FreeKernelContext: 0x%lx\n", Status ));

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   NtlmDerefContext
//
//  Synopsis:   Dereference a kernel context
//
//  Arguments:  [Context] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NtlmDerefContext(
    PNTLM_KERNEL_CONTEXT Context
    )
{
    BOOLEAN Delete ;

    MAYBE_PAGED_CODE();

    KSecDereferenceListEntry(
                    &Context->List,
                    &Delete );

    if ( Delete )
    {
        NtlmFreeKernelContext( Context );
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmInitKernelPackage
//
//  Synopsis:   Initialize an instance of the NtLm package in
//              a client's (kernel) address space
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS or
//              returns from ExInitializeResource
//
//  Notes:      we do what was done in SpInstanceInit()
//              from security\msv_sspi\userapi.cxx
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS KernelFunctions
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmInitKernelPackage\n" ));

    LsaKernelFunctions = KernelFunctions;
    //
    // Set up Context list support:
    //

    NtlmPoolType = PagedPool ;
    NtlmPagedList = LsaKernelFunctions->CreateContextList( KSecPaged );

    if ( !NtlmPagedList )
    {
        return STATUS_NO_MEMORY ;
    }

    NtlmActiveList = NtlmPagedList ;


    DebugLog(( DEB_TRACE, "Leaving NtLmInitKernelPackage 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle    - The Lsa mode handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmDeleteKernelContext(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{

    PNTLM_KERNEL_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS, SaveStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmDeleteKernelContext\n" ));


    Status = NtlmReferenceContext( KernelContextHandle, TRUE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;

    }
    else
    {
        *LsaContextHandle = KernelContextHandle;
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp;

    }

    *LsaContextHandle = pContext->LsaContext;
    if ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT) != 0)
    {
        // Ignore all other errors and pass back
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }


CleanUp:


    if (pContext != NULL)
    {
        NtlmDerefContext( pContext );

    }

    if (SaveStatus == SEC_I_NO_LSA_CONTEXT)
    {
        Status = SaveStatus;
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmDeleteKernelContext 0x%lx\n", Status ));
    return(Status);
}





//+-------------------------------------------------------------------------
//
//  Function:   NtLmInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Arguments:  LsaContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext = NULL;

    PNTLM_PACKED_CONTEXT pTmpContext  = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmInitKernelContext\n" ));

    *NewContextHandle = NULL;

    if (PackedContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_ERROR,
          "Bad size of Packed context 0x%lx\n", PackedContext->cbBuffer));
        goto Cleanup;
    }

    pContext = (PNTLM_KERNEL_CONTEXT) NtLmAllocate(
                                            sizeof(NTLM_KERNEL_CONTEXT) +
                                            pTmpContext->MarshalledTargetInfoLength
                                            );

    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog(( DEB_ERROR, "Allocation error for pContext\n"));
        goto Cleanup;
    }

    RtlZeroMemory(
        pContext,
        sizeof(NTLM_KERNEL_CONTEXT)
        );

    KsecInitializeListEntry( &pContext->List, NTLM_CONTEXT_SIGNATURE );

    // Copy contents of PackedContext->pvBuffer to pContext

    pContext->ClientTokenHandle = (HANDLE) ULongToPtr(pTmpContext->ClientTokenHandle);
#ifdef DEFENSIVE_HANDLES
    if ( pContext->ClientTokenHandle )
    {
        OBJECT_HANDLE_FLAG_INFORMATION HandleInfo ;
        POBJECT_TYPE_INFORMATION TypeInfo ;
        NTSTATUS IgnoreStatus = STATUS_SUCCESS ;
        UNICODE_STRING TokenTypeName ;

        TypeInfo = (POBJECT_TYPE_INFORMATION) ExAllocatePoolWithTag( PagedPool, sizeof( OBJECT_TYPE_INFORMATION ) + 16, NTLM_KRNL_POOL_TAG );

        if ( TypeInfo )
        {
            IgnoreStatus = ZwQueryObject(pContext->ClientTokenHandle,
                                ObjectTypeInformation,
                                TypeInfo,
                                (sizeof( OBJECT_TYPE_INFORMATION ) + 16 ),
                                NULL );

            if ( NT_SUCCESS( IgnoreStatus ) )
            {
                RtlInitUnicodeString( &TokenTypeName, L"Token" );

                if ( !RtlEqualUnicodeString( &TypeInfo->TypeName, &TokenTypeName, FALSE ))
                {
                    IgnoreStatus = STATUS_INVALID_HANDLE ;
                }

            }
            else if ( IgnoreStatus != STATUS_INVALID_HANDLE )
            {
                IgnoreStatus = STATUS_SUCCESS ;
            }

            ExFreePool( TypeInfo );
        }

        if ( !NT_SUCCESS( IgnoreStatus ) )
        {
            ASSERT( NT_SUCCESS( IgnoreStatus ) );
            Status = IgnoreStatus ;
            DebugLog(( DEB_ERROR, "Bad token handle from LSA: %p\n", pContext->ClientTokenHandle ));
            goto Cleanup;

        }

        HandleInfo.Inherit = FALSE ;
        HandleInfo.ProtectFromClose = TRUE ;

        IgnoreStatus = ZwSetInformationObject(
                            pContext->ClientTokenHandle,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ) );

    }
#endif
    pContext->LsaContext = LsaContextHandle;
    pContext->NegotiateFlags = pTmpContext->NegotiateFlags;

    //
    // keep all 128 bits here, so signing can be strong even if encrypt can't be
    //

    RtlCopyMemory(  pContext->SessionKey,
                        pTmpContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

    //
    // if doing full duplex as part of NTLM2, generate different sign
    // and seal keys for each direction
    //  all we do is MD5 the base session key with a different magic constant
    //

    if ( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
        MD5_CTX Md5Context;
        ULONG KeyLen;

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_128 )
            KeyLen = 16;
        else if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_56 )
            KeyLen = 7;
        else
            KeyLen = 5;

//        DebugLog(( SSP_SESSION_KEYS, "NTLMv2 session key size: %lu\n", KeyLen));

        //
        // make client to server encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)CSSEALMAGIC, sizeof(CSSEALMAGIC));
        MD5Final(&Md5Context);

        //
        // if TokenHandle == NULL, this is the client side
        //  put key in the right place: for client it's seal, for server it's unseal
        //

        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)SCSEALMAGIC, sizeof(SCSEALMAGIC));
        MD5Final(&Md5Context);
        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make client to server signing key -- always 128 bits!
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)CSSIGNMAGIC, sizeof(CSSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client signing key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)SCSIGNMAGIC, sizeof(SCSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to different key schedule and nonce for each direction
        //  key schedule will be filled in later...
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->UnsealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->RecvNonce;
   } else {

        //
        // just copy session key to all four keys
        //  leave them 128 bits -- they get cut to 40 bits later
        //

        RtlCopyMemory(  pContext->SealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->UnsealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->SignSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->VerifySessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to share a key schedule and nonce for each direction
        //  (OK because half duplex!)
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->SealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->SendNonce;
    }



    if ( pTmpContext->ContextNameLength == 0 )
    {
        //There's no string after the NTLM_KERNEL_CONTEXT struct
        pContext->ContextNames = NULL;
    }
    else
    {
        pContext->ContextNames = (LPWSTR) NtLmAllocate( pTmpContext->ContextNameLength );

        if (!pContext->ContextNames)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(pContext->ContextNames,
                      (PUCHAR) pTmpContext + pTmpContext->ContextNames,
                      pTmpContext->ContextNameLength );

    }

    if( pTmpContext->MarshalledTargetInfo )
    {
        pContext->pbMarshalledTargetInfo = (PUCHAR)(pContext+1);
        pContext->cbMarshalledTargetInfo = pTmpContext->MarshalledTargetInfoLength;

        RtlCopyMemory(  pContext->pbMarshalledTargetInfo,
                        (PUCHAR) pTmpContext + pTmpContext->MarshalledTargetInfo,
                        pTmpContext->MarshalledTargetInfoLength );
    }


    pContext->SendNonce = pTmpContext->SendNonce;
    pContext->RecvNonce = pTmpContext->RecvNonce;

    SspRc4Key(pContext->NegotiateFlags, &pContext->SealRc4Sched, pContext->SealSessionKey);
    SspRc4Key(pContext->NegotiateFlags, &pContext->UnsealRc4Sched, pContext->UnsealSessionKey);


    pContext->PasswordExpiry = pTmpContext->PasswordExpiry;
    pContext->UserFlags = pTmpContext->UserFlags;

    KSecInsertListEntry(
            NtlmActiveList,
            &pContext->List );

    NtlmDerefContext( pContext );

    *NewContextHandle = (ULONG_PTR) pContext;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            NtlmFreeKernelContext( pContext );
        }
    }

    if (PackedContext->pvBuffer != NULL)
    {
        LsaKernelFunctions->FreeHeap(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmInitKernelContext 0x%lx\n", Status ));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();

    DebugLog((DEB_TRACE,"Entering NtLmMapKernelhandle\n"));

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;

        *LsaContextHandle = Context->LsaContext ;

        NtlmDerefContext( Context );

    }
    else
    {
        DebugLog(( DEB_WARN, "Invalid context handle - %x\n",
                    KernelContextHandle ));
        *LsaContextHandle = KernelContextHandle ;
    }

    DebugLog((DEB_TRACE,"Leaving NtLmMapKernelhandle 0x%lx\n", Status));

    return (Status);
}


//
// Bogus add-shift check sum
//

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )

/*++

RoutineDescription:

    Generate a crc-32 checksum for a buffer

Arguments:

Return Value:
Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
       routine SspGenCheckSum. It's possible that
       bugs got copied too

--*/

{
    MAYBE_PAGED_CODE();

    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}


VOID
SspEncryptBuffer(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    )

/*++

RoutineDescription:

    Encrypts a buffer with the RC4 key in the context.  If the context
    is for a datagram session, then the key is copied before being used
    to encrypt the buffer.

Arguments:

    pContext - Context containing the key to encrypt the data

    BufferSize - Length of buffer in bytes

    Buffer - Buffer to encrypt.
    Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
           routine SspEncryptBuffer. It's possible that
           bugs got copied too

Return Value:

--*/

{
    MAYBE_PAGED_CODE();

    struct RC4_KEYSTRUCT TemporaryKey;
    struct RC4_KEYSTRUCT * EncryptionKey = pRc4Key;

    if (BufferSize == 0)
    {
        return;
    }

    //
    // For datagram (application supplied sequence numbers) before NTLM2
    // we used to copy the key before encrypting so we don't
    // have a changing key; but that reused the key stream. Now we only
    // do that when backwards compatibility is explicitly called for.
    //

    if (((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) &&
        ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0) ) {

        RtlCopyMemory(
            &TemporaryKey,
            EncryptionKey,
            sizeof(TemporaryKey)
            );
        EncryptionKey = &TemporaryKey;

    }

    rc4(
        EncryptionKey,
        BufferSize,
        (PUCHAR) Buffer
        );

}


VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    )
/*++

RoutineDescription:

    Create an RC4 key schedule, making sure key length is OK for export

Arguments:

    NegotiateFlags  negotiate feature flags; NTLM2 bit is only one looked at
    pRc4Key         pointer to RC4 key schedule structure; filled in by this routine
    pSessionKey     pointer to session key -- must be full 16 bytes

Return Value:

--*/
{
    PAGED_CODE();

    //
    // For NTLM2, effective length was already cut down
    //

    if ((NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0) {

        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);

    } else if( NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
        UCHAR Key[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
        ULONG KeyLen;

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH == 8);

        // prior to Win2k, negotiated key strength had no bearing on
        // key size.  So, to allow proper interop to NT4, we don't
        // worry about 128bit.  56bit and 40bit are the only supported options.
        // 56bit is enabled because this was introduced in Win2k, and
        // Win2k -> Win2k interops correctly.
        //
#if 0
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            KeyLen = 8;

        } else
#endif
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            KeyLen = 7;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 56 bits.
            //

            Key[7] = 0xa0;
        } else {
            KeyLen = 5;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;
        }

///        DebugLog(( SSP_SESSION_KEYS, "Non NTLMv2 session key size: %lu\n", KeyLen));

        RtlCopyMemory(Key,pSessionKey,KeyLen);

        rc4_key(pRc4Key, MSV1_0_LANMAN_SESSION_KEY_LENGTH, Key);
    } else {
        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);
    }
}



SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    )
/*++

RoutineDescription:

    Handle signing a message

Arguments:

Return Value:

--*/

{

    HMACMD5_CTX HMACMD5Context;
    UCHAR TempSig[MD5DIGESTLEN];
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    int Signature;
    ULONG i;
    PUCHAR pKey;                            // ptr to key to use for encryption
    PUCHAR pSignKey;                        // ptr to key to use for signing
    PULONG pNonce;                          // ptr to nonce to use
    struct RC4_KEYSTRUCT * pRc4Sched;       // ptr to key schedule to use

    NTLMSSP_MESSAGE_SIGNATURE  AlignedSig;


    MAYBE_PAGED_CODE();



    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    if (pMessage->pBuffers[Signature].cbBuffer < NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    *ppSig = (NTLMSSP_MESSAGE_SIGNATURE*)pMessage->pBuffers[Signature].pvBuffer;

    RtlCopyMemory( &AlignedSig, *ppSig, sizeof(AlignedSig) );

    //
    // If sequence detect wasn't requested, put on an empty
    // security token . Don't do the check if Seal/Unseal is called.
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) &&
       (Op == eSign || Op == eVerify))
    {
        RtlZeroMemory(pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLM_SIGN_VERSION;
        return(SEC_E_OK);
    }

    // figure out which key, key schedule, and nonce to use
    //  depends on the op. SspAddLocalContext set up so that code on client
    //  and server just (un)seals with (un)seal key or key schedule, etc.
    //  and also sets pointers to share sending/receiving key schedule/nonce
    //  when in half duplex mode. Hence, this code gets to act as if it were
    //  always in full duplex mode.
    switch (Op) {
    case eSeal:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eUnseal:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    case eSign:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;        // might be used to encrypt the signature
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eVerify:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;      // might be used to decrypt the signature
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    default:
        ASSERT(FALSE);
        return(STATUS_INVALID_LEVEL);
    }

    //
    // Either we can supply the sequence number, or
    // the application can supply the message sequence number.
    //

    Sig.Version = NTLM_SIGN_VERSION;

    // if we're doing the new NTLM2 version:
    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce = *pNonce;    // use our sequence number
            (*pNonce) += 1;
        }
        else {

            if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
                Sig.Nonce = MessageSeqNo;
            else
                Sig.Nonce = AlignedSig.Nonce;

            //   if using RC4, must rekey for each packet
            //   RC4 is used for seal, unseal; and for encrypting the HMAC hash if
            //   key exchange was negotiated (we use just HMAC if no key exchange,
            //   so that a good signing option exists with no RC4 encryption needed)

            if (Op == eSeal || Op == eUnseal || pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                MD5_CTX Md5ContextReKey;

                MD5Init(&Md5ContextReKey);
                MD5Update(&Md5ContextReKey, pKey, MSV1_0_USER_SESSION_KEY_LENGTH);
                MD5Update(&Md5ContextReKey, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));
                MD5Final(&Md5ContextReKey);
                ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
                SspRc4Key(pContext->NegotiateFlags, pRc4Sched, Md5ContextReKey.digest);
            }
        }

        //
        // using HMAC hash, init it with the key
        //

        HMACMD5Init(&HMACMD5Context, pSignKey, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // include the message sequence number
        //

        HMACMD5Update(&HMACMD5Context, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                if ((pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                    == (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                {
                    //
                    // FESTER: return INVALID_TOKEN because of data buffers
                    //

                    return SEC_E_INVALID_TOKEN;
                }

                // decrypt (before checksum...) if it's not READ_ONLY
                if ( (Op == eUnseal)
                    && !(pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM) )
                   )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                HMACMD5Update(
                            &HMACMD5Context,
                            (unsigned char*)pMessage->pBuffers[i].pvBuffer,
                            pMessage->pBuffers[i].cbBuffer);

                //
                // Encrypt if its not READ_ONLY
                //

                if ( (Op == eSeal)
                    && !(pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM) )
                   )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        HMACMD5Final(&HMACMD5Context, TempSig);

        //
        // use RandomPad and Checksum fields for 8 bytes of MD5 hash
        //

        RtlCopyMemory(&Sig.RandomPad, TempSig, 8);

        //
        // if we're using crypto for KEY_EXCH, may as well use it for signing too...
        //

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            SspEncryptBuffer(
                pContext,
                pRc4Sched,
                8,
                &Sig.RandomPad
                );
    }
    //
    // pre-NTLM2 methods
    //
    else {

        //
        // required by CRC-32 algorithm
        //
        Sig.CheckSum = 0xffffffff;

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA)
                && (pMessage->pBuffers[i].cbBuffer != 0))
            {
                if ((pMessage->pBuffers[i].BufferType & (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                    == (SECBUFFER_READONLY | SECBUFFER_READONLY_WITH_CHECKSUM))
                {
                    //
                    // FESTER: return invalid token because of data buffers
                    //

                    return SEC_E_INVALID_TOKEN;
                }

                //
                // retain the "read-only" semantics for NTLMv1
                //

                if (pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                {
                    continue;
                }

                // decrypt (before checksum...)
                if ( (Op == eUnseal)
                     && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM) )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                SspGenCheckSum(&pMessage->pBuffers[i], &Sig);

                // Encrypt
                if ( (Op == eSeal)
                     && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM) )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        //
        // Required by CRC-32 algorithm
        //

        Sig.CheckSum ^= 0xffffffff;

        // when we encrypt 0, we will get the cipher stream for the nonce!
        Sig.Nonce = 0;

        SspEncryptBuffer(
            pContext,
            pRc4Sched,
            sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
            &Sig.RandomPad
            );


        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce ^= *pNonce;    // use our sequence number and encrypt it
            (*pNonce) += 1;
        }
        else if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
            Sig.Nonce ^= MessageSeqNo;   // use caller's sequence number and encrypt it
        else
            Sig.Nonce = AlignedSig.Nonce;    // use sender's sequence number

        //
        // for SignMessage calling, does nothing (copies garbage)
        // For VerifyMessage calling, allows it to compare sig block
        // upon return to Verify without knowing whether its MD5 or CRC32
        //

        Sig.RandomPad = AlignedSig.RandomPad;
    }

    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

     return(SEC_E_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PNTLM_KERNEL_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    NTLMSSP_MESSAGE_SIGNATURE  *pSig;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmMakeSignature\n" ));

    UNREFERENCED_PARAMETER(fQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                        pContext,
                        eSign,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );


    if( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "NtLmMakeSignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:

    DebugLog(( DEB_TRACE, "Leaving NtLmMakeSignature 0x%lx\n", Status ));
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
NtLmVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;

    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer with sig in it
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // Aligned sig buffer.

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmVerifySignature\n" ));

    UNREFERENCED_PARAMETER(pfQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                        pContext,
                        eVerify,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );


    if( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "NtLmVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof( AlignedSig ) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    // with MD5 sig, this now matters!
    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }

CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:


    DebugLog(( DEB_TRACE, "Leaving NtLmVerifySignature 0x%lx\n", Status ));
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;    // pointer to buffer where sig goes

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmSealMessage\n" ));

    UNREFERENCED_PARAMETER(fQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                    pContext,
                    eSeal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog(( DEB_ERROR, "SpSealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:


    DebugLog(( DEB_TRACE, "Leaving NtLmSealMessage 0x%lx\n", Status ));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;

    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer where sig goes
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // aligned buffer.

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmUnsealMessage\n" ));

    UNREFERENCED_PARAMETER(pfQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }

    Status = SspSignSealHelper(
                    pContext,
                    eUnseal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog(( DEB_ERROR, "SpUnsealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof(AlignedSig) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:

    DebugLog(( DEB_TRACE, "Leaving NtLmUnsealMessage 0x%lx\n", Status ));
    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext = NULL;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmGetContextToken\n" ));

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }

    if (pContext->ClientTokenHandle == NULL)
    {
        DebugLog(( DEB_ERROR, "Invalid TokenHandle for context 0x%lx\n", pContext ));
        Status= SEC_E_NO_IMPERSONATION;
        goto CleanUp;
    }

    if (ARGUMENT_PRESENT(ImpersonationToken))
    {
        *ImpersonationToken = pContext->ClientTokenHandle;
    }

    if (ARGUMENT_PRESENT(RawToken))
    {
        if (pContext->ClientTokenHandle != NULL)
        {
            if (pContext->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                             pContext->ClientTokenHandle,
                             TOKEN_IMPERSONATE | TOKEN_QUERY,
                             NULL,
                             ExGetPreviousMode(),
                             (PVOID *) &pContext->AccessToken,
                             NULL);


            }
        }

        if (NT_SUCCESS(Status))
        {
            ASSERT(pContext->AccessToken != NULL);
            *RawToken = pContext->AccessToken;
        }
    }


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:
    DebugLog(( DEB_TRACE, "Leaving NtLmGetContextToken 0x%lx\n", Status ));
    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_UNSUPPORTED_FUNCTION -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSecPkgContext_NamesW ContextNames = NULL;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_SessionKey ContextSessionKeyInfo = NULL;
    PSecPkgContext_Sizes ContextSizes = NULL;
    PSecPkgContext_Flags ContextFlags = NULL;
    PSecPkgContext_PasswordExpiry PasswordExpires;
    PSecPkgContext_UserFlags UserFlags;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_TargetInformation TargetInformation = NULL;

    PNTLM_KERNEL_CONTEXT pContext = NULL;
    unsigned int Length = 0;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmQueryContextAttributes\n" ));



    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    } else {

        //
        // for PACKAGE_INFO or NEGOTIATION_INFO, don't require a completed
        // context.
        //

        if( (Attribute != SECPKG_ATTR_PACKAGE_INFO) &&
            (Attribute != SECPKG_ATTR_NEGOTIATION_INFO)
            )
        {
            DebugLog(( DEB_ERROR,
            "Bad kernel context 0x%lx\n", KernelContextHandle));
            goto CleanUp_NoDeref;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Handle each of the various queried attributes
    //

    switch ( Attribute ) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ContextSizes->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (pContext->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL) ) {
            ContextSizes->cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        } else {
            ContextSizes->cbMaxSignature = 0;
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            ContextSizes->cbBlockSize = 1;
            ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            ContextSizes->cbSecurityTrailer = 0;
        }

        break;

    //
    // No one uses the function so don't go to the overhead of maintaining
    // the username in the context structure.
    //

    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;

        if (ContextDceInfo == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_DCE_INFO.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (pContext->ContextNames)
        {
            Length = (unsigned int) wcslen(pContext->ContextNames);
        }

        ContextDceInfo->pPac = (LPWSTR) LsaKernelFunctions->AllocateHeap(
                 (Length + 1) * sizeof(WCHAR));

        if (ContextDceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                ContextDceInfo->pPac,
                pContext->ContextNames,
                Length * sizeof(WCHAR));

            LPWSTR Temp =  (LPWSTR)ContextDceInfo->pPac;
            Temp[Length] = L'\0';
        }
        else
        {
            DebugLog(( DEB_ERROR, "Bad Context->pPac in SECPKG_ATTR_DCE_INFO.\n" ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;

        if (ContextNames == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_NAMES.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (pContext->ContextNames)
        {
            Length = (unsigned int) wcslen(pContext->ContextNames);
            DebugLog(( DEB_TRACE, "NtLmQueryContextAttributes: ContextNames length is 0x%lx\n", Length));
        }

        ContextNames->sUserName = (LPWSTR) LsaKernelFunctions->AllocateHeap(
                 (Length + 1) * sizeof(WCHAR));

        if (ContextNames->sUserName != NULL)
        {
            RtlCopyMemory(
                ContextNames->sUserName,
                pContext->ContextNames,
                Length * sizeof(WCHAR));

            ContextNames->sUserName[Length] = L'\0';
        }
        else
        {
            DebugLog(( DEB_ERROR, "Bad Context->sUserName in SECPKG_ATTR_NAMES.\n" ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:

        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_TARGET_INFORMATION.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (pContext->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        Length = pContext->cbMarshalledTargetInfo;
        DebugLog(( DEB_TRACE, "NtLmQueryContextAttributes: TargetInformation length is 0x%lx\n", Length));

        TargetInformation->MarshalledTargetInfo = (PUCHAR) LsaKernelFunctions->AllocateHeap(
                                                                    Length
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                pContext->pbMarshalledTargetInfo,
                Length
                );

            TargetInformation->MarshalledTargetInfoLength = Length;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_SESSION_KEY:
       ContextSessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
       ContextSessionKeyInfo->SessionKeyLength = MSV1_0_USER_SESSION_KEY_LENGTH;
       ContextSessionKeyInfo->SessionKey =
           (PUCHAR) LsaKernelFunctions->AllocateHeap(
               ContextSessionKeyInfo->SessionKeyLength);
       if (ContextSessionKeyInfo->SessionKey != NULL)
       {
           RtlCopyMemory(
               ContextSessionKeyInfo->SessionKey,
               pContext->SessionKey,
               MSV1_0_USER_SESSION_KEY_LENGTH);
       }
       else
       {
           Status = STATUS_INSUFFICIENT_RESOURCES;
       }

       break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if(pContext->PasswordExpiry.QuadPart != 0) {
            PasswordExpires->tsPasswordExpires = pContext->PasswordExpiry;
        } else {
            Status = SEC_E_UNSUPPORTED_FUNCTION;
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlags = (PSecPkgContext_UserFlags) Buffer;
        UserFlags->UserFlags = pContext->UserFlags;
        break;

    case SECPKG_ATTR_FLAGS:
    {
        BOOLEAN Client = (pContext->ClientTokenHandle == 0);
        ULONG Flags = 0;

        ContextFlags = (PSecPkgContext_Flags) Buffer;
        ContextFlags->Flags = 0;

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            if( Client )
            {
                Flags |= ISC_RET_CONFIDENTIALITY;
            } else {
                Flags |= ASC_RET_CONFIDENTIALITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            if( Client )
            {
                Flags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
            } else {
                Flags |= ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT | ASC_RET_INTEGRITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NULL_SESSION) {
            if( Client )
            {
                Flags |= ISC_RET_NULL_SESSION;
            } else {
                Flags |= ASC_RET_NULL_SESSION;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) {
            if( Client )
            {
                Flags |= ISC_RET_DATAGRAM;
            } else {
                Flags |= ASC_RET_DATAGRAM;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
            if( Client )
            {
                Flags |= ISC_RET_IDENTIFY;
            } else {
                Flags |= ASC_RET_IDENTIFY;
            }
        }

        ContextFlags->Flags |= Flags;

        break;
    }

    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;

        PackageInfo->PackageInfo = (PSecPkgInfoW) LsaKernelFunctions->AllocateHeap(
                                                    sizeof(SecPkgInfoW) +
                                                    sizeof(NTLMSP_NAME) +
                                                    sizeof(NTLMSP_COMMENT)
                                                    );

        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PCHAR) PackageInfo->PackageInfo->Name)) + sizeof(NTLMSP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            NTLMSP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTLMSP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = NTLMSP_RPCID;
        PackageInfo->PackageInfo->fCapabilities = NTLMSP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTLMSP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            PSecPkgContext_NegotiationInfo NegInfo ;

            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            if( pContext ) {
                NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
            } else {
                NegInfo->NegotiationState = 0;
            }
        }
        break;

    case SECPKG_ATTR_LIFESPAN:
    default:

        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:

    if (!NT_SUCCESS(Status)) {

        switch ( Attribute) {

          case SECPKG_ATTR_NAMES:

              if (ContextNames && ContextNames->sUserName)
              {
                  LsaKernelFunctions->FreeHeap(ContextNames->sUserName);
                  ContextNames->sUserName = NULL;
              }
          break;

          case SECPKG_ATTR_DCE_INFO:

              if (ContextDceInfo && ContextDceInfo->pPac)
              {
                  LsaKernelFunctions->FreeHeap(ContextDceInfo->pPac);
                  ContextDceInfo->pPac = NULL;
              }
          break;

          case SECPKG_ATTR_SESSION_KEY:

              if(ContextSessionKeyInfo && ContextSessionKeyInfo->SessionKey)
              {
                  LsaKernelFunctions->FreeHeap(ContextSessionKeyInfo->SessionKey);
                  ContextSessionKeyInfo->SessionKey = NULL;
              }
          break;

          case SECPKG_ATTR_NEGOTIATION_INFO:

              if(PackageInfo && PackageInfo->PackageInfo)
              {
                  LsaKernelFunctions->FreeHeap(PackageInfo->PackageInfo);
                  PackageInfo->PackageInfo = NULL;
              }
          break;

        }
    }

    if( pContext ) {
        NtlmDerefContext( pContext );
    }

CleanUp_NoDeref:
    DebugLog(( DEB_TRACE, "Leaving NtLmQueryContextAttributes 0x%lx\n", Status ));
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmCompleteToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
NtLmCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (InputBuffer);
    PAGED_CODE();
    DebugLog(( DEB_TRACE, "Entering NtLmCompleteToken\n" ));
    DebugLog(( DEB_TRACE, "Leaving NtLmCompleteToken\n" ));
    return(STATUS_NOT_SUPPORTED);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_KERNEL_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_PACKED_CONTEXT PackedContext = NULL;
    ULONG ContextSize, ContextNameSize = 0;

    PAGED_CODE();


    if (Context->ContextNames)
    {
        ContextNameSize = (ULONG) wcslen(Context->ContextNames);
    }


    ContextSize =  sizeof(NTLM_PACKED_CONTEXT) +
                   ContextNameSize * sizeof(WCHAR);

    PackedContext = (PNTLM_PACKED_CONTEXT) NtLmAllocate(ContextSize);

    if (PackedContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory( PackedContext, ContextSize );

#if 0
    // Copy all fields of the old context


    RtlCopyMemory(
        PackedContext,
        Context,
        sizeof(NTLM_KERNEL_CONTEXT)
        );


    if (ContextNameSize > 0)
    {
        PackedContext->ContextNames = (LPWSTR) sizeof(NTLM_PACKED_CONTEXT);

        RtlCopyMemory(
            PackedContext+1,
            Context->ContextNames,
            ContextNameSize * sizeof(WCHAR));
    }
    else
    {
        PackedContext->ContextNames=NULL;
    }



    // Replace some fields

    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = NULL;

    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        PackedContext->SendNonce = (ULONG) -1;
        PackedContext->RecvNonce = (ULONG) -1;
    }

    RtlZeroMemory(
        &PackedContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );
#endif




    PackedContext->Tag = NTLM_PACKED_CONTEXT_MAP ;
    PackedContext->NegotiateFlags = Context->NegotiateFlags ;
    PackedContext->SendNonce = Context->SendNonce ;
    PackedContext->RecvNonce = Context->RecvNonce ;
    RtlCopyMemory(
        PackedContext->SessionKey,
        Context->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    PackedContext->ContextSignature = Context->ContextSignature ;
    PackedContext->PasswordExpiry = Context->PasswordExpiry ;
    PackedContext->UserFlags = Context->UserFlags ;
    if ( ContextNameSize )
    {
        PackedContext->ContextNames = sizeof( NTLM_PACKED_CONTEXT );
        PackedContext->ContextNameLength = (ContextNameSize + 1) * sizeof( WCHAR ) ;

        RtlCopyMemory(
            (PackedContext + 1),
            Context->ContextNames,
            PackedContext->ContextNameLength );

    }
    else
    {
        PackedContext->ContextNames = 0 ;
    }

    RtlCopyMemory(
        PackedContext->SignSessionKey,
        Context->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->VerifySessionKey,
        Context->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->SealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->UnsealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &PackedContext->SealRc4Sched,
        &Context->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &PackedContext->UnsealRc4Sched,
        &Context->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );


    // Replace some fields


    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = 0 ;

    // Save the fact that it's exported
    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        PackedContext->SendNonce = (ULONG) -1;
        PackedContext->RecvNonce = (ULONG) -1;
    }



    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;



    *MappedContext = TRUE;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            NtLmFree(PackedContext);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    IN OUT PHANDLE TokenHandle
    )
{
    PNTLM_KERNEL_CONTEXT Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN MappedContext = FALSE;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmExportSecurityContext\n" ));

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Status = NtlmReferenceContext( ContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PNTLM_KERNEL_CONTEXT) ContextHandle ;
    }
    else
    {
        goto Cleanup_NoDeref ;
    }

    Status = NtLmMakePackedContext(
                Context,
                &MappedContext,
                PackedContext,
                Flags
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    ASSERT(MappedContext);

    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *TokenHandle = Context->ClientTokenHandle;
            Context->ClientTokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->ClientTokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:

    NtlmDerefContext( Context );

Cleanup_NoDeref:

    return (Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmCreateKernelModeContext
//
//  Synopsis:   Creates a kernel-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmCreateKernelModeContext(
    IN ULONG_PTR ContextHandle,
    IN OPTIONAL HANDLE TokenHandle,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_KERNEL_CONTEXT * NewContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT Context = NULL;
    PNTLM_PACKED_CONTEXT PackedContext;
    unsigned int Length = 0;

    PAGED_CODE();

    if (MarshalledContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        DebugLog((DEB_ERROR,"NtLmCreateKernelModeContext: Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(NTLM_PACKED_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PNTLM_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Context = (PNTLM_KERNEL_CONTEXT) NtLmAllocate( sizeof(NTLM_KERNEL_CONTEXT));
    if (!Context)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR,"NtLmCreateKernelModeContext: Allocation error for Context\n"));
        goto Cleanup;
    }

    RtlZeroMemory(
            Context,
            sizeof(NTLM_KERNEL_CONTEXT));

    // Copy contenets of PackedContext->pvBuffer to Context
////    *Context = *PackedContext;

    Context->NegotiateFlags = PackedContext->NegotiateFlags;
////    Context->ClientTokenHandle = (HANDLE)PackedContext->ClientTokenHandle;
    Context->ContextSignature = PackedContext->ContextSignature;


    RtlCopyMemory( Context->SessionKey, PackedContext->SessionKey, sizeof(PackedContext->SessionKey) );

    RtlCopyMemory( Context->SignSessionKey, PackedContext->SignSessionKey, sizeof(PackedContext->SignSessionKey) );
    RtlCopyMemory( Context->VerifySessionKey, PackedContext->VerifySessionKey, sizeof(PackedContext->VerifySessionKey) );
    RtlCopyMemory( Context->SealSessionKey, PackedContext->SealSessionKey, sizeof(PackedContext->SealSessionKey) );
    RtlCopyMemory( Context->UnsealSessionKey, PackedContext->UnsealSessionKey, sizeof(PackedContext->UnsealSessionKey) );

    RtlCopyMemory( &Context->SealRc4Sched, &PackedContext->SealRc4Sched, sizeof(PackedContext->SealRc4Sched) );
    RtlCopyMemory( &Context->UnsealRc4Sched, &PackedContext->UnsealRc4Sched, sizeof(PackedContext->UnsealRc4Sched) );


    KsecInitializeListEntry( &Context->List, NTLM_CONTEXT_SIGNATURE );


    // These need to be changed

    Context->ClientTokenHandle = TokenHandle;

    if (Context->SendNonce == (ULONG) -1)
    {
        // The context was exported with the reset flag
        Context->SendNonce = 0;
    }

    if (Context->RecvNonce == (ULONG) -1)
    {
        // The context was exported with the reset flag
        Context->RecvNonce = 0;
    }

    if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {

        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->UnsealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->RecvNonce;
    } else {

        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->SealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->SendNonce;
    }


    Context->ContextNames = NULL;

    Length = (MarshalledContext->cbBuffer - sizeof(NTLM_PACKED_CONTEXT));
    if (Length > 0)
    {
        Context->ContextNames = (LPWSTR) NtLmAllocate(Length + sizeof(WCHAR));
        if (!Context->ContextNames)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(Context->ContextNames, PackedContext + 1, Length);
        // null terminate the string
        *(Context->ContextNames + (Length/2)) = UNICODE_NULL;
    }

    Context->PasswordExpiry = PackedContext->PasswordExpiry;
    Context->UserFlags = PackedContext->UserFlags;

    KSecInsertListEntry(
            NtlmActiveList,
            &Context->List );

    *NewContext = Context;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            NtlmFreeKernelContext(Context);
        }
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmCreateKernelContext 0x%lx\n", Status ));
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PULONG_PTR ContextHandle
    )
{
    NTSTATUS Status;
    PNTLM_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"Entering NtLmImportSecurityContext\n"));

    Status = NtLmCreateKernelModeContext(
                0,              // LsaContextHandle not present
                TokenHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"NtLmImportSecurityContext: Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *ContextHandle = (ULONG_PTR) Context;

Cleanup:
    if (Context != NULL)
    {
        NtlmDerefContext( Context );
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   NtlmSetPagingMode
//
//  Synopsis:   Switch the paging mode for cluster support
//
//  Arguments:  [Pagable] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NtlmSetPagingMode(
    BOOLEAN Pagable
    )
{
    if ( Pagable )
    {
        NtlmPoolType = PagedPool ;
        NtlmActiveList = NtlmPagedList ;
    }
    else
    {
        if ( NtlmNonPagedList == NULL )
        {
            NtlmNonPagedList = LsaKernelFunctions->CreateContextList( KSecNonPaged );
            if ( NtlmNonPagedList == NULL )
            {
                return STATUS_NO_MEMORY ;
            }
        }

        NtlmActiveList = NtlmNonPagedList ;

        NtlmPoolType = NonPagedPool ;
    }
    return STATUS_SUCCESS ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\trace.h ===
#ifndef _TRACE_H
#define _TRACE_H
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Include file to contain variables required for event tracing 
    for NTLM

Author:

    15-June-2000  Jason Clark

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C BOOL             NtlmGlobalEventTraceFlag;
EXTERN_C TRACEHANDLE      NtlmGlobalTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      NtlmGlobalTraceLoggerHandle;

EXTERN_C
ULONG
NtlmInitializeTrace();

// Helper macros for populating the trace
#define SET_TRACE_DATA(TraceVar, MofNum, Data) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) &Data; \
        TraceVar.eventInfo[MofNum].Length = sizeof(Data); \
    }
    
#define SET_TRACE_DATAPTR(TraceVar, MofNum, Data) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) Data; \
        TraceVar.eventInfo[MofNum].Length = sizeof(*Data); \
    }
    
#define SET_TRACE_USTRING(TraceVar, MofNum, UString) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) &UString.Length; \
        TraceVar.eventInfo[MofNum].Length = sizeof(UString.Length) ; \
        TraceVar.eventInfo[MofNum+1].DataPtr = (ULONGLONG) UString.Buffer; \
        TraceVar.eventInfo[MofNum+1].Length = UString.Length ; \
    }
    
#define SET_TRACE_HEADER(TraceVar, TheGuid, TheType, TheFlags, NumMofs) \
    { \
        TraceVar.EventTrace.Guid = TheGuid; \
        TraceVar.EventTrace.Class.Type = TheType; \
        TraceVar.EventTrace.Flags = TheFlags; \
        TraceVar.EventTrace.Size = sizeof(EVENT_TRACE_HEADER)+ \
            sizeof(MOF_FIELD) * NumMofs ; \
    }
    
// Helper defines for populating the Init/Accept trace
#define TRACE_INITACC_STAGEHINT      0
#define TRACE_INITACC_INCONTEXT      1
#define TRACE_INITACC_OUTCONTEXT     2
#define TRACE_INITACC_STATUS         3
#define TRACE_INITACC_CLIENTNAME     4
#define TRACE_INITACC_CLIENTDOMAIN   6
#define TRACE_INITACC_WORKSTATION    8

// Helper defines for populating the Logon trace
#define TRACE_LOGON_STATUS          0
#define TRACE_LOGON_TYPE            1
#define TRACE_LOGON_USERNAME        2
#define TRACE_LOGON_DOMAINNAME      4

// Helper defines for populating the Validate trace
#define TRACE_VALIDATE_SUCCESS      0
#define TRACE_VALIDATE_SERVER       1
#define TRACE_VALIDATE_DOMAIN       3
#define TRACE_VALIDATE_USERNAME     5
#define TRACE_VALIDATE_WORKSTATION  7

// Helper defines for populating the Passthrough trace
#define TRACE_PASSTHROUGH_DOMAIN    0
#define TRACE_PASSTHROUGH_PACKAGE   2

// Accept stage hints
#define TRACE_ACCEPT_NEGOTIATE 1
#define TRACE_ACCEPT_AUTHENTICATE 2
#define TRACE_ACCEPT_INFO 3

// Init stage hints
#define TRACE_INIT_FIRST 1
#define TRACE_INIT_CHALLENGE 2

// The current limit is 16 MOF fields.
// Each UNICODE strings needs two MOF fields.

typedef struct _NTLM_TRACE_INFO
{
    EVENT_TRACE_HEADER EventTrace;
   
    MOF_FIELD eventInfo[MAX_MOF_FIELDS];
} NTLM_TRACE_INFO, *PNTLM_TRACE_INFO;


//
// This is the control Guid for the group of Guids traced below
//

DEFINE_GUID( // {C92CF544-91B3-4dc0-8E11-C580339A0BF8}
    NtlmControlGuid,  
    0xc92cf544, 
    0x91b3, 
    0x4dc0, 
    0x8e, 0x11, 0xc5, 0x80, 0x33, 0x9a, 0xb, 0xf8);

//
// This is the Accept guid
//
   
DEFINE_GUID( // {94D4C9EB-0D01-41ae-99E8-15B26B593A83}
    NtlmAcceptGuid, 
    0x94d4c9eb, 
    0xd01, 
    0x41ae, 
    0x99, 0xe8, 0x15, 0xb2, 0x6b, 0x59, 0x3a, 0x83);

//
// This is the Initialize guid
//

DEFINE_GUID( // {6DF28B22-73BE-45cc-BA80-8B332B35A21D}
    NtlmInitializeGuid, 
    0x6df28b22, 
    0x73be, 
    0x45cc, 
    0xba, 0x80, 0x8b, 0x33, 0x2b, 0x35, 0xa2, 0x1d);


//
// This is the LogonUser guid
//

DEFINE_GUID( // {19196B33-A302-4c12-9D5A-EAC149E93C46}
    NtlmLogonGuid, 
    0x19196b33, 
    0xa302, 
    0x4c12, 
    0x9d, 0x5a, 0xea, 0xc1, 0x49, 0xe9, 0x3c, 0x46);

//
// This is the NTLM Password Validate
//

DEFINE_GUID( // {34D84181-C28A-41d8-BB9E-995190DF83DF}
    NtlmValidateGuid,
    0x34d84181, 
    0xc28a, 
    0x41d8, 
    0xbb, 0x9e, 0x99, 0x51, 0x90, 0xdf, 0x83, 0xdf);
    
//    
// This is the GenericPassthrough Trace Guid
//

DEFINE_GUID( // {21ABB5D9-8EEC-46e4-9D1C-F09DD57CF70B}
    NtlmGenericPassthroughGuid, 
    0x21abb5d9, 
    0x8eec, 
    0x46e4, 
    0x9d, 0x1c, 0xf0, 0x9d, 0xd5, 0x7c, 0xf7, 0xb);




#endif /* _TRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\trace.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace.c

Abstract:

    Contains the initialization function for event tracing, the callback function
    which enables and disables tracing, plus the handles and trace flag.

Author:

    15-June-2000  Jason Clark

Revision History:

--*/


//
//
//
#define INITGUID
#include <Global.h>
#include "trace.h"

#define IMAGE_PATH L"Msv1_0.dll"
#define RESOURCE_NAME L"MofResource"

BOOL             NtlmGlobalEventTraceFlag = FALSE;
TRACEHANDLE      NtlmGlobalTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      NtlmGlobalTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
NtlmTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION NtlmTraceGuids[] =
{
    { &NtlmAcceptGuid,
      NULL
    },
    { &NtlmInitializeGuid,
      NULL
    },
    { &NtlmLogonGuid,
      NULL
    },
    { &NtlmValidateGuid,
      NULL
    },
    { &NtlmGenericPassthroughGuid,
      NULL
    }   
};

#define NtlmGuidCount (sizeof(NtlmTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
NtlmInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                NtlmTraceControlCallback,
                NULL,
                &NtlmControlGuid,
                NtlmGuidCount,
                NtlmTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &NtlmGlobalTraceRegistrationHandle);

    if (status != ERROR_SUCCESS) {
       SspPrint((SSP_API, "Trace registration failed with %x\n",status));
        //DebugLog((DEB_ERROR,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
NtlmTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;
    
    SspPrint((SSP_API,"NtlmTrace callback\n"));

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            NtlmGlobalTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            NtlmGlobalEventTraceFlag = TRUE;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            NtlmGlobalEventTraceFlag = FALSE;
            RetSize = 0;
            NtlmGlobalTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // NtlmTraceControlCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\rpctest\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -i security package name (ntlm, kerberos or negotiate)\n");
    fprintf(stderr, " -c target principal name (necessary for kerberos or negotiate). For e.g, domainname\\username\n");
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    fprintf(stderr, " -w password\n");
    fprintf(stderr, " -a user account name\n");
    fprintf(stderr, " -d user account domain\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszSecPackage = "negotiate";
    unsigned char * pszPrincipalName = NULL;
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    unsigned char * pszUserName = NULL;
    unsigned char * pszPassword;
    unsigned char * pszDomain;
    SEC_WINNT_AUTH_IDENTITY sID;
    unsigned long SecPackageId = RPC_C_AUTHN_WINNT;
    int i;

    sID.User = NULL;
    sID.UserLength = 0;
    sID.Domain = NULL;
    sID.DomainLength = 0;
    sID.Password = NULL;
    sID.PasswordLength = 0;
    sID.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'i':  // secpackage 
                pszSecPackage = argv[++i];
                break;
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'c':  // principal name
                pszPrincipalName = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'a':
                sID.User = argv[++i];
                sID.UserLength = strlen(sID.User);
                break;
            case 'w':
                sID.Password = argv[++i];
                sID.PasswordLength = strlen(sID.Password);
                break;
            case 'd':
                sID.Domain = argv[++i];
                sID.DomainLength = strlen(sID.Domain);
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    // default package is ntlm

    if ( lstrcmpi(pszSecPackage, "ntlm") == 0)
    {
        SecPackageId = RPC_C_AUTHN_WINNT;
    }
    else if ( lstrcmpi(pszSecPackage, "kerberos") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_KERBEROS;
    }
    else if ( lstrcmpi(pszSecPackage, "negotiate") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_NEGOTIATE;
    }

    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    pszPrincipalName,
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    SecPackageId,
                    &sID,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\kernel\ntlmkrnl.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmkrnl.h
//
// Contents:    global include file for kernel mode NTLM security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __NTLMKRNL_H__
#define __NTLMKRNL_H__

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

extern "C"
{
#include "msvprgma.h"
#include <ntosp.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <winerror.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
#include <..\ntlmssp.h>
}

//
// Global state variables
//

ULONG NtLmPackageId;
extern PSECPKG_KERNEL_FUNCTIONS KernelFunctions;
extern POOL_TYPE NtlmPoolType ;

//
// Useful macros
//

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

#define NTLM_KRNL_POOL_TAG       'CvsM'
#define NtLmAllocate( _x_ ) ExAllocatePoolWithTag( NtlmPoolType, (_x_),  NTLM_KRNL_POOL_TAG )
#define NtLmFree( _x_ ) ExFreePool(_x_)


#if DBG


#define DEB_ERROR               0x00000001
#define DEB_WARN                0x00000002
#define DEB_TRACE               0x00000004
#define DEB_TRACE_LOCKS         0x00010000

extern "C"
{
void KsecDebugOut(ULONG, const char *, ...);
}

#define DebugLog(x) KsecDebugOut x

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __NTLMKRNL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\rpctest\server\hellos.c ===
/****************************************************************************
			  Microsoft RPC Version 1.0
			 Copyright Microsoft Corp. 1992
				Hello Example

    FILE:	hellos.c
    USAGE:	hellos
    PURPOSE:	Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
// #include <secext.h>
#include "hello.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -i security package (ntlm, kerberos or negotiate)\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszSecPackage       = "negotiate";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint 	= "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    unsigned long SecPackageId = RPC_C_AUTHN_WINNT;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
	if ((*argv[i] == '-') || (*argv[i] == '/')) {
	    switch (tolower(*(argv[i]+1))) {
		case 'p':  // protocol sequence
		    pszProtocolSequence = argv[++i];
		    break;
		case 'i':  // security package
		    pszSecPackage = argv[++i];
		    break;
		case 'n':  // network address
		    pszNetworkAddress = argv[++i];
		    break;
		case 'e':
		    pszEndpoint = argv[++i];
		    break;
		case 'o':
		    pszOptions = argv[++i];
		    break;
		case 'u':
		    pszUuid = argv[++i];
		    break;
		case 'h':
		case '?':
		default:
		    Usage(argv[0]);
	    }
	}
	else
	    Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
				   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    // default package is ntlm

    if ( lstrcmpi(pszSecPackage, "ntlm") == 0)
    {
        SecPackageId = RPC_C_AUTHN_WINNT;
    }
    else if ( lstrcmpi(pszSecPackage, "kerberos") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_KERBEROS;
    }
    else if ( lstrcmpi(pszSecPackage, "negotiate") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_NEGOTIATE;
    }

    status = RpcServerRegisterAuthInfo( "HelloS", SecPackageId, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
		side of RPC distributed application
    FUNCTIONS:	HelloProc() - prints "hello, world" or other string
		sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    char szUser[256];
    DWORD iSize;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    };

//    GetUserNameEx(NameUserPrincipal, szUser, sizeof(szUser)-1);
    iSize = sizeof(szUser)-1;
    GetUserName(szUser, &iSize);
    printf("User '%s' says '%s'\n", szUser, pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\base64\base64.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    base64.cxx

Abstract:

    base64

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "base64.h"

//#define BASE64_STRICT     // enforce syntax check on input data
#undef BASE64_STRICT        // enforce syntax check on input data

// The following table translates an ascii subset to 6 bit values as follows
// (see RFC 1421 and/or RFC 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";

#define MOD4(x) ((x) & 3)

__inline BOOL
_IsBase64WhiteSpace(
    IN TCHAR const ch
    )
{
    return(
    ch == TEXT(' ') ||
    ch == TEXT('\t') ||
    ch == TEXT('\r') ||
    ch == TEXT('\n'));
}

DWORD
Base64DecodeA(
    IN CHAR const     *pchIn,
    IN DWORD           cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD      *pcbOut
    )
{
    DWORD dwErr;
    DWORD cchInDecode, cbOutDecode;
    CHAR const *pchInEnd;
    CHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    dwErr = ERROR_INVALID_DATA;
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
        if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
        {
            // Found a non-base64 character.  Decide what to do.

            DWORD cch;

            if (_IsBase64WhiteSpace(*pchInT))
            {
            continue;       // skip all whitespace
            }

            // The length calculation may stop in the middle of the last
            // translation quantum, because the equal sign padding characters
            // are treated as invalid input.  If the last translation quantum
            // is not 4 bytes long, there must be 3, 2 or 1 equal sign(s).

            if (0 != cchInDecode)
            {
            cch = MOD4(cchInDecode);
            if (0 != cch)
            {
                cch = 4 - cch;
                while (0 != cch && pchInT < pchInEnd && '=' == *pchInT)
                {
                pchInT++;
                cch--;
                }
            }
            //#ifdef BASE64_STRICT
            if (0 == cch)
            //#endif
            {
                break;
            }
            }
            goto ErrorReturn;
        }
        cchInDecode++;          // only count valid base64 chars
    }
    assert(pchInT <= pchInEnd);

#ifdef BASE64_STRICT
    if (pchInT < pchInEnd)
    {
    CHAR const *pch;
    DWORD cchEqual = 0;

    for (pch = pchInT; pch < pchInEnd; pch++)
    {
        if (!_IsBase64WhiteSpace(*pch))
        {
        // Allow up to 3 extra trailing equal signs.
        if (TEXT('=') == *pch && 3 > cchEqual)
        {
            cchEqual++;
            continue;
        }
        goto BadTrailingBase64Data;
        }
    }
    }
#endif

    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.  Compensate for a fractional translation quantum.

    cbOutDecode = ((cchInDecode + 3) >> 2) * 3;
    switch (cchInDecode % 4)
    {
    case 1:
    case 2:
        cbOutDecode -= 2;
        break;

    case 3:
        cbOutDecode--;
        break;
    }

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
        // Decode one quantum at a time: 4 bytes ==> 3 bytes

        //assert(cbOutDecode <= *pcbOut);
        if (cbOutDecode > *pcbOut)
        {
            *pcbOut = cbOutDecode;
            dwErr = ERROR_MORE_DATA;
            goto ErrorReturn;
        }

    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        ZeroMemory(ab4, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        assert(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    assert((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = SAFE_SUBTRACT_POINTERS(pbOutT, pbOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;
}

// Encode a BYTE array into a Base64 text string.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.
// Do not add -----BEGIN/END headers -- that's also handled by the caller.

DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut
    )
{
    DWORD dwErr;
    CHAR *pchOutT;
    DWORD cchOutEncode;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
    (fNoCR? 1 : 2) *
    ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
    pchOutT += cchOutEncode;
    //printf("cchOut:       =%x Computed=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode);
    }
    else
    {
    DWORD cCol;

    if (cchOutEncode > *pcchOut)
    {
        *pcchOut = cchOutEncode;
        dwErr = ERROR_MORE_DATA;
        goto ErrorReturn;
    }

    cCol = 0;
    while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
    {
        BYTE ab3[3];

        if (cCol == CB_BASE64LINEMAX/4)
        {
        cCol = 0;
        if (!fNoCR)
        {
            *pchOutT++ = '\r';
        }
        *pchOutT++ = '\n';
        }
        cCol++;
        ZeroMemory(ab3, sizeof(ab3));

        ab3[0] = *pbIn++;
        if (cbIn > 1)
        {
        ab3[1] = *pbIn++;
        if (cbIn > 2)
        {
            ab3[2] = *pbIn++;
        }
        }

        *pchOutT++ = abEncode[ab3[0] >> 2];
        *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
        *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
        *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

        cbIn -= 3;
    }

    // Append CR-LF only if there was input data

    if (pchOutT != pchOut)
    {
        if (!fNoCR)
        {
        *pchOutT++ = '\r';
        }
        *pchOutT++ = '\n';
    }
    //printf("cchOut: Actual=%x Computed=%x Buffer=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode, *pcchOut);
    assert((DWORD) (pchOutT - pchOut) == cchOutEncode);
    }
    *pcchOut = SAFE_SUBTRACT_POINTERS(pchOutT, pchOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;
}

DWORD
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *wszOut,
    OUT DWORD *pcchOut
    )
{

    DWORD   cchOut;
    CHAR   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    assert(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if (wszOut == NULL)
    {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(pbIn, cbIn, Flags, NULL, pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        pch = (CHAR *) malloc(cchOut);
        if (NULL != pch)
    {
            err = Base64EncodeA(pbIn, cbIn, Flags, pch, &cchOut);
        if (ERROR_SUCCESS == err)
        {
        // should not fail!
        cch = MultiByteToWideChar(0, 0, pch, cchOut, wszOut, *pcchOut);

        // check to make sure we did not fail
        assert(*pcchOut == 0 || cch != 0);
        }
    }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

DWORD
Base64DecodeW(
    IN const WCHAR * wszIn,
    IN DWORD cch,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut
    )
{
    CHAR *pch;
    DWORD err = ERROR_SUCCESS;

    // in all cases we need to convert to an ascii string
    // we know the ascii string is less

    if ((pch = (CHAR *) malloc(cch)) == NULL)
    {
        err = ERROR_OUTOFMEMORY;
    }

    // we know no base64 wide char map to more than 1 ascii char
    else if (WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, NULL, NULL) == 0)
    {
        err = ERROR_NO_DATA;
    }

    // get the length of the buffer
    else if (pbOut == NULL)
    {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }

    // otherwise fill in the buffer
    else {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

//
// some helper functions to facilitate debugging
//

HRESULT
ReadBytes(
    IN PCSTR pszFileName,
    OUT BYTE** ppBuffer,
    OUT ULONG* pcbBuffer
    )
{
    THResult hRetval = S_OK;

    ULONG temp = 0;
    BYTE* pBuffer = NULL;
    ULONG cbBuffer = 0;

    FILE* file = NULL;

    *pcbBuffer = 0;
    *ppBuffer = NULL;

    DebugPrintf(SSPI_LOG, "ReadBytes from file %s\n", pszFileName);

    file = fopen(pszFileName, "r");

    hRetval DBGCHK = file ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        while (EOF != (temp = getc(file)))
        {
            if (!_IsBase64WhiteSpace(static_cast<CHAR>(temp)))
            {
                cbBuffer++;
            }
        }
        rewind(file);

        pBuffer = new BYTE[cbBuffer + 2];

        hRetval DBGCHK = pBuffer ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        RtlZeroMemory(pBuffer, cbBuffer + 2);

        for ( UCHAR* p = (UCHAR*) pBuffer;
             (p < pBuffer + cbBuffer) && (EOF != (temp = getc(file)));
             /* p++ */ )
        {

            if (_IsBase64WhiteSpace(static_cast<CHAR>(temp)))
            {
                continue;
            }

            *p++ = static_cast<CHAR>(temp);
        }

        *ppBuffer = pBuffer;
        pBuffer = NULL;
        *pcbBuffer = cbBuffer;
    }

    if (pBuffer)
    {
        delete [] pBuffer;
    }

    return hRetval;
}

INT
__cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    THResult hRetval = E_FAIL;

    BYTE* pBuffer = NULL;
    ULONG cbBuffer = 0;

    BYTE* pResult = NULL;
    ULONG cbResult = 0;

    if (argc != 2)
    {
        DebugPrintf(SSPI_ERROR, "Usage: %s <file name>\n", argv[0]);
        exit(-1);
    }

    hRetval DBGCHK = ReadBytes(argv[1], &pBuffer, &cbBuffer);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(Base64DecodeA(reinterpret_cast<PCSTR>(pBuffer), cbBuffer, NULL, &cbResult));
    }

    if (SUCCEEDED(hRetval))
    {
        pResult = new BYTE[cbResult];

        hRetval DBGCHK = pResult ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(Base64DecodeA(reinterpret_cast<PCSTR>(pBuffer), cbBuffer, pResult, &cbResult));
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "Decoded buffer and length: %#x %#x\n", pResult, cbResult);

        //
        // pause here
        //

        ASSERT(FALSE);
    }

    if (pResult)
    {
        delete [] pResult;
    }

    if (pBuffer)
    {
        delete [] pBuffer;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\rpctesta\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    "ntdev\\chandans",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    18,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\rpctesta\server\hellos.c ===
/****************************************************************************
			  Microsoft RPC Version 1.0
			 Copyright Microsoft Corp. 1992
				Hello Example

    FILE:	hellos.c
    USAGE:	hellos
    PURPOSE:	Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint 	= "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
	if ((*argv[i] == '-') || (*argv[i] == '/')) {
	    switch (tolower(*(argv[i]+1))) {
		case 'p':  // protocol sequence
		    pszProtocolSequence = argv[++i];
		    break;
		case 'n':  // network address
		    pszNetworkAddress = argv[++i];
		    break;
		case 'e':
		    pszEndpoint = argv[++i];
		    break;
		case 'o':
		    pszOptions = argv[++i];
		    break;
		case 'u':
		    pszUuid = argv[++i];
		    break;
		case 'h':
		case '?':
		default:
		    Usage(argv[0]);
	    }
	}
	else
	    Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
				   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", 18, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
		side of RPC distributed application
    FUNCTIONS:	HelloProc() - prints "hello, world" or other string
		sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }
    printf("%s\n", pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\asrequest\asrequest.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    asrequest.cxx

Abstract:

    enumusers

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <kerberos.h>
#include "asrequest.hxx"

void
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s -c<client name> -C<client realm> "
                "-s<server name> -S<server realm> -t<server name type> -p<client password>\n\n", pszApp);
    exit(-1);
}

#if 0

typedef struct _KERB_TICKET_AS_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG Flags;
    ULONG NameType;
    UNICODE_STRING ClientName;
    UNICODE_STRING ClientRealm;
    UNICODE_STRING ClientPassword;
    UNICODE_STRING ServerName;  // optional, default to krbtgt
    UNICODE_STRING ServerRealm; // optinal, default to local realm
} KERB_TICKET_AS_REQUEST, *PKERB_TICKET_AS_REQUEST;

#endif

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    NTSTATUS AuthPackageStatus = STATUS_UNSUCCESSFUL;

    HANDLE LogonHandle = NULL;
    ULONG PackageId = -1;

    KERB_TICKET_AS_REQUEST AsReq;
    KERB_TICKET_AS_REQUEST* pAsRequest = NULL;
    ULONG cbAsQuest = sizeof(KERB_TICKET_AS_REQUEST);

    KERB_TICKET_AS_REQUEST* pAsResp = NULL;
    ULONG AsResponseLength = 0;
    CHAR* pWhere = NULL;

    RtlZeroMemory(&AsReq, sizeof(AsReq));

    AsReq.MessageType = (KERB_PROTOCOL_MESSAGE_TYPE) KerbTicketAsRequestMessage;

    /* allow the user to override settings with command line switches */
    for (int i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (argv[i][1])
            {
            case 'c':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &AsReq.ClientName);
                cbAsQuest += AsReq.ClientName.MaximumLength;
                break;

            case 'C':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &AsReq.ClientRealm);
                cbAsQuest += AsReq.ClientRealm.MaximumLength;
                break;

            case 's':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &AsReq.ServerName);
                cbAsQuest += AsReq.ServerName.MaximumLength;
                break;

            case 'S':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &AsReq.ServerRealm);
                cbAsQuest += AsReq.ServerRealm.MaximumLength;
                break;

            case 'p':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &AsReq.ClientPassword);
                cbAsQuest += AsReq.ClientPassword.MaximumLength;
                break;

            case 't':
                AsReq.NameType = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    if (NT_SUCCESS(Status) && (AsReq.NameType == KRB_NT_UNKNOWN))
    {
        DebugPrintf(SSPI_ERROR, "server name type required\n");
        Status DBGCHK = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetLsaHandleAndPackageId(
                    MICROSOFT_KERBEROS_NAME_A,
                    &LogonHandle,
                    &PackageId
                    );
    }

    if (NT_SUCCESS(Status))
    {
        pAsRequest = (KERB_TICKET_AS_REQUEST*) new UCHAR[cbAsQuest];
        Status DBGCHK = pAsRequest ? S_OK : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        pWhere = ((CHAR*) pAsRequest) + sizeof(KERB_TICKET_AS_REQUEST);
        *pAsRequest = AsReq;

        RelocatePackUnicodeString(&pAsRequest->ClientRealm, &pWhere);
        RelocatePackUnicodeString(&pAsRequest->ClientName, &pWhere);
        RelocatePackUnicodeString(&pAsRequest->ClientPassword, &pWhere);
        RelocatePackUnicodeString(&pAsRequest->ServerRealm, &pWhere);
        RelocatePackUnicodeString(&pAsRequest->ServerName, &pWhere);

        DebugPrintf(SSPI_LOG,
            "pAsRequest %p, ClientRealm (%wZ), ClientName (%wZ), "
            "ClientPassword (%wZ), ServerRealm (%wZ), "
             "ServerName (%wZ), SererNameType %d(%#x), pWhere %p\n",
            pAsRequest,
            &pAsRequest->ClientRealm,
            &pAsRequest->ClientName,
            &pAsRequest->ClientPassword,
            &pAsRequest->ServerRealm,
            &pAsRequest->ServerName,
            pAsRequest->NameType,
            pAsRequest->NameType,
            pWhere);

        Status DBGCHK = LsaCallAuthenticationPackage(
                   LogonHandle,
                   PackageId,
                   pAsRequest,
                   cbAsQuest,
                   (PVOID*) &pAsResp,
                   &AsResponseLength,
                   &AuthPackageStatus
                   );
    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    RtlFreeUnicodeString(&AsReq.ClientName);
    RtlFreeUnicodeString(&AsReq.ClientRealm);
    RtlFreeUnicodeString(&AsReq.ServerName);
    RtlFreeUnicodeString(&AsReq.ServerRealm);
    RtlFreeUnicodeString(&AsReq.ClientPassword);

    if (pAsRequest)
    {
        delete [] pAsRequest;
    }

    if (pAsResp)
    {
        LsaFreeReturnBuffer(pAsResp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\asrequest\miscapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        miscapi.cxx
//
// Contents:    Code for miscellaneous lsa mode Kerberos entrypoints
//
//
// History:     16-April-1996   MikeSw  Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <crypt.h>      // NT_OWF_PASSWORD_LENGTH
#include <kerbpass.h>
#include <spncache.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//
// LsaApCallPackage() function dispatch table
//

NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRefreshSmartcardCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbAddExtraCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbTicketAsRequestSafe(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

PLSA_AP_CALL_PACKAGE
KerbCallPackageDispatch[] = {
#if DBG
    KerbDebugRequest,
#else
    NULL,
#endif
    KerbQueryTicketCache,
    KerbChangeMachinePassword,
    KerbVerifyPac,
    KerbRetrieveTicket,
    KerbSetIpAddresses,
    KerbPurgeTicket,
    KerbChangePassword,
    KerbRetrieveEncodedTicket,
#if DBG
    KerbDecryptMessage,
#else
    NULL,
#endif
    KerbAddBindingCacheEntry,
    KerbSetPassword,
    KerbSetPassword,
    KerbVerifyCredentials,
    KerbQueryTicketCacheEx,
    KerbPurgeTicketEx,
//  KerbRetrieveEncodedTicketEx,
    KerbRefreshSmartcardCredentials,
    KerbAddExtraCredential,
    NULL,
    KerbTicketAsRequestSafe,
 };


//+-------------------------------------------------------------------------
//
//  Function:   SpGetUserInfo
//
//  Synopsis:   Gets information about a user
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    return(STATUS_NOT_SUPPORTED);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsaApCallPackage
//
//  Synopsis:   Kerberos entrypoint for LsaCallAuthenticationPackage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG MessageType;
    PLSA_AP_CALL_PACKAGE TempFn = NULL;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ((MessageType >=
         (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0]))) ||
         (KerbCallPackageDispatch[MessageType] == NULL))
    {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    TempFn = KerbCallPackageDispatch[MessageType];

    D_DebugLog((DEB_WARN, "LsaApCallPackage %#x(%d), TempFn %p\n", MessageType, MessageType, TempFn));

    if (!TempFn)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    Status = (*TempFn)(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus );

//    RtlCheckForOrphanedCriticalSections(NtCurrentThread());

Cleanup:
    return(Status);

}


NTSTATUS NTAPI
LsaApCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Untrusted clients are not allowed to call the ChangeMachinePassword function
    //

    if (MessageType == KerbChangeMachinePasswordMessage)
    {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}


NTSTATUS NTAPI
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // only allow passthrough related requests.
    //

    if (MessageType != KerbVerifyPacMessage)
    {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDebugRequest
//
//  Synopsis:   CallPackage entrypoint for debugging
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    PVOID Handle = NULL;
    PBYTE AuthData = NULL;
    UNICODE_STRING AccountName = {0};

    BYTE Buffer[sizeof(KERB_DEBUG_REPLY) + sizeof(KERB_DEBUG_STATS) - sizeof(UCHAR) * ANYSIZE_ARRAY];
    PKERB_DEBUG_REQUEST DebugRequest;
    PKERB_DEBUG_REPLY   DebugReply = (PKERB_DEBUG_REPLY) Buffer;
    PKERB_DEBUG_STATS   DebugStats = (PKERB_DEBUG_STATS) DebugReply->Data;

    if (SubmitBufferLength < sizeof(*DebugRequest)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DebugRequest = (PKERB_DEBUG_REQUEST) ProtocolSubmitBuffer;
    switch(DebugRequest->DebugRequest) {
    case KERB_DEBUG_REQ_BREAKPOINT:
        DbgBreakPoint();
        break;

    case KERB_DEBUG_REQ_STATISTICS:
        DebugReply->MessageType = KerbDebugRequestMessage;
        DebugStats->CacheHits = KerbTicketCacheHits;
        DebugStats->CacheMisses = KerbTicketCacheMisses;
        DebugStats->SkewedRequests = KerbSkewState.SkewedRequests;
        DebugStats->SuccessRequests = KerbSkewState.SuccessRequests;
        DebugStats->LastSync = KerbSkewState.LastSync;
        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    ProtocolReturnBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    *ProtocolReturnBuffer,
                    DebugReply
                    );
        if (!NT_SUCCESS(Status))
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                *ProtocolReturnBuffer
                );
            *ProtocolReturnBuffer = NULL;
        }
        else
        {
            *ReturnBufferLength = sizeof(Buffer);
        }

        break;

    case KERB_DEBUG_CREATE_TOKEN:
    {
        UNICODE_STRING String, String2;
        ULONG AuthDataSize = 0;
        HANDLE TokenHandle = NULL;
        LUID LogonId;
        NTSTATUS SubStatus;

        RtlInitUnicodeString(
            &String,
            L"Administrator"
            );
        RtlInitUnicodeString(
            &String2,
            NULL
            );

        Status = LsaFunctions->OpenSamUser(
                    &String,
                    SecNameSamCompatible,
                    &String2,
                    TRUE,               // allow guest
                    0,                  // reserved
                    &Handle
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to open sam user: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        Status = LsaFunctions->GetUserAuthData(
                    Handle,
                    &AuthData,
                    &AuthDataSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to get auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Now create that token
        //

        Status = LsaFunctions->ConvertAuthDataToToken(
                    AuthData,
                    AuthDataSize,
                    SecurityImpersonation,
                    &KerberosSource,
                    Network,
                    &String,
                    &TokenHandle,
                    &LogonId,
                    &AccountName,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to create token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        NtClose(TokenHandle);
        DebugLog((DEB_ERROR,"Logged on account is %wZ. %ws, line %d\n",&AccountName, THIS_FILE, __LINE__));
        break;

    }

    default:
        Status = STATUS_INVALID_PARAMETER;
    }

Cleanup:

    if( Handle != NULL )
    {
        LsaFunctions->CloseSamUser( Handle );
    }

    if( AuthData != NULL )
    {
        LsaFunctions->FreeLsaHeap( AuthData );
    }

    if( AccountName.Buffer != NULL )
    {
        LsaFunctions->FreeLsaHeap( AccountName.Buffer );
    }

#else
    Status = STATUS_INVALID_PARAMETER;
#endif
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRefreshSmartcardCredentials
//
//  Synopsis:   Notifies Kerberos when the smart card credentials need to
//              be updated.  Basically a workaround for winlogon session
//              switching behavior during TS connects / re-connects.
//              When this happens, your HPROV goes bad...
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbRefreshSmartcardCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS                      Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION           LogonSession = NULL;
    PKERB_REFRESH_SCCRED_REQUEST  ChangeRequest;
    SECPKG_CLIENT_INFO            ClientInfo;
    PLUID                         LogonId;

    if (SubmitBufferLength < sizeof(KERB_REFRESH_SCCRED_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChangeRequest = (PKERB_REFRESH_SCCRED_REQUEST) ProtocolSubmitBuffer;

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //
    Status = LsaFunctions->GetClientInfo( &ClientInfo );
    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    if ( RtlIsZeroLuid( &ChangeRequest->LogonId ))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }
    else
    {
        LogonId = &ChangeRequest->LogonId;
    }



    LogonSession = KerbReferenceLogonSession(
                            LogonId,
                            FALSE
                            );

    DsysAssert(LogonSession != NULL);
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    KerbReleasePkCreds(
        LogonSession,
        NULL,
        TRUE  // ok for reuse - save PIN and SChelper data
        );

    Status = STATUS_SUCCESS;

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbChangeMachinePassword
//
//  Synopsis:   Notifies Kerberos when the machine password has changed
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS                      Status = STATUS_SUCCESS;
    LUID                          SystemLogonId = SYSTEM_LUID;
    PKERB_LOGON_SESSION           SystemLogonSession = NULL;
    PKERB_CHANGE_MACH_PWD_REQUEST ChangeRequest;
    ULONG                         StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST);

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }

#if _WIN64

    SECPKG_CALL_INFO              CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST_WOW64);
    }

#endif  // _WIN64

    if (SubmitBufferLength < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    ChangeRequest = (PKERB_CHANGE_MACH_PWD_REQUEST) ProtocolSubmitBuffer;

#if _WIN64

    KERB_CHANGE_MACH_PWD_REQUEST LocalChangeRequest;

    //
    // Thunk 32-bit pointers if this is a WOW caller
    //

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PKERB_CHANGE_MACH_PWD_REQUEST_WOW64 ChangeRequestWOW =
            (PKERB_CHANGE_MACH_PWD_REQUEST_WOW64) ChangeRequest;

        LocalChangeRequest.MessageType = ChangeRequest->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.NewPassword,
                                       &ChangeRequestWOW->NewPassword);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.OldPassword,
                                       &ChangeRequestWOW->OldPassword);

        ChangeRequest = &LocalChangeRequest;
    }

#endif  // _WIN64


    //
    // Find the system logon session.
    //

    SystemLogonSession = KerbReferenceLogonSession(
                            &SystemLogonId,
                            FALSE               // don't unlink
                            );

    DsysAssert(SystemLogonSession != NULL);
    if (SystemLogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }



    //
    // Calculate the new password list
    //

    if (ChangeRequest->NewPassword.Buffer != NULL)
    {
        //
        // If there is an old password, update with that one first so it
        // will later get moved to the old password field.
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        if (ChangeRequest->OldPassword.Buffer != NULL)
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->OldPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }
        if (NT_SUCCESS(Status))
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->NewPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }

        KerbUnlockLogonSessions(SystemLogonSession);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Update the flags to indicate that we have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags &= ~(KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }
    else
    {
        //
        // Update the flags to indicate that we do not have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags |= (KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }


    Status = STATUS_SUCCESS;
Cleanup:
    if (SystemLogonSession != NULL)
    {
        KerbDereferenceLogonSession(SystemLogonSession);
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbNameLength
//
//  Synopsis:   returns length in bytes of variable portion of KERB_INTERNAL_NAME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbWOWNameLength.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------


ULONG
KerbNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    if (!ARGUMENT_PRESENT(Name))
    {
        return(0);
    }
    Length = sizeof(KERB_INTERNAL_NAME)
                - sizeof(UNICODE_STRING)
                + Name->NameCount * sizeof(UNICODE_STRING) ;
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    Length = ROUND_UP_COUNT(Length, sizeof(LPWSTR));
    return(Length);
}

ULONG
KerbStringNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    Length = Name->NameCount * sizeof(WCHAR);   // for separators & null terminator
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    return(Length);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcName
//
//  Synopsis:   Copies a Kdc name to a buffer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWKdcName.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcName(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PKERB_EXTERNAL_NAME * OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    ULONG Index;
    PKERB_INTERNAL_NAME LocalName = (PKERB_INTERNAL_NAME) *Where;

    if (!ARGUMENT_PRESENT(InputName))
    {
        *OutputName = NULL;
        return;
    }
    *Where += sizeof(KERB_INTERNAL_NAME) - sizeof(UNICODE_STRING) +
                InputName->NameCount * sizeof(UNICODE_STRING);
    LocalName->NameType = InputName->NameType;
    LocalName->NameCount = InputName->NameCount;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        LocalName->Names[Index].Length =
            LocalName->Names[Index].MaximumLength =
            InputName->Names[Index].Length;
        LocalName->Names[Index].Buffer = (LPWSTR) (*Where + Offset);
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
    }
    *Where = (PBYTE) ROUND_UP_POINTER(*Where,sizeof(LPWSTR));
    *OutputName = (PKERB_EXTERNAL_NAME) ((PBYTE) LocalName + Offset);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcNameAsString
//
//  Synopsis:   Copies a KERB_INTERNAL_NAME into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcNameAsWOWString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcNameAsString(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PUNICODE_STRING OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    USHORT Index;

    OutputName->Buffer = (LPWSTR) (*Where + Offset);
    OutputName->Length = 0;
    OutputName->MaximumLength = 0;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
        OutputName->Length = OutputName->Length + InputName->Names[Index].Length;
        if (Index == (InputName->NameCount - 1))
        {
            *((LPWSTR) *Where) = L'\0';
            OutputName->MaximumLength = OutputName->Length + sizeof(WCHAR);
        }
        else
        {
            *((LPWSTR) *Where) = L'/';
            OutputName->Length += sizeof(WCHAR);
        }
        *Where += sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutString(
    IN PUNICODE_STRING InputString,
    OUT PUNICODE_STRING OutputString,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = (LPWSTR) (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSize
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client? (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSize(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponse(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = (LONG) CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponse->Tickets[*Index].ServerName.Buffer = (LPWSTR) (*Where + *Offset);
                CacheResponse->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponse->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

#if _WIN64

            }
            else
            {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponseWOW64->Tickets[*Index].ServerName.Buffer = PtrToUlong (*Where + *Offset);
                CacheResponseWOW64->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponseWOW64->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCache
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN LockHeld = FALSE;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    DsysAssert( !LockHeld );
    KerbReadLockLogonSessions(LogonSession);
    KerbReadLockTicketCache();
    LockHeld = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSize(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    SafeAllocaAllocate(CacheResponse, CacheSize);

    if ( CacheResponse == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponse(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if (LockHeld)
    {
        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    SafeAllocaFree(CacheResponse);

    if (ClientCacheResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSizeEx
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSizeEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_EX_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         // client name
                         PrimaryCredentials->UserName.Length +
                         // client realm
                         PrimaryCredentials->DomainName.Length +
                         // server name
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         // server realm
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponseEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutString(
                    &PrimaryCredentials->UserName,
                    &CacheResponse->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponse->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );

#if _WIN64

            } else {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutWOWString(
                    &PrimaryCredentials->UserName,
                    &CacheResponseWOW64->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddExtraCredential
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbAddExtraCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{

    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_ADD_CREDENTIALS_REQUEST AddCredRequest = (PKERB_ADD_CREDENTIALS_REQUEST) ProtocolSubmitBuffer;
    PKERB_LOGON_SESSION LogonSession = NULL;

    if (ARGUMENT_PRESENT( ReturnBufferLength ))
    {
        *ReturnBufferLength = 0;
    }

    if (ARGUMENT_PRESENT( ProtocolReturnBuffer ))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if ( SubmitBufferSize < sizeof( KERB_ADD_CREDENTIALS_REQUEST ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif // _WIN64

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &AddCredRequest->LogonId ))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }
    else
    {
        LogonId = &AddCredRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL )
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    NULL_RELOCATE_ONE( &AddCredRequest->DomainName );
    NULL_RELOCATE_ONE( &AddCredRequest->Password );
    NULL_RELOCATE_ONE( &AddCredRequest->UserName );

    //
    // We will default nothing for this request.
    //
    if (( AddCredRequest->DomainName.Length == 0 ) ||
        ( AddCredRequest->UserName.Length == 0 ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (((AddCredRequest->Flags & (KERB_REQUEST_ADD_CREDENTIAL | KERB_REQUEST_REPLACE_CREDENTIAL )) != 0) &&
         ( AddCredRequest->Password.Length == 0 ))

    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    Status = KerbAddExtraCredentialsToLogonSession(
                    LogonSession,
                    AddCredRequest
                    );

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "KerbAddExtraCredentialToLogonSession failed %x\n", Status));
        goto Cleanup;
    }


Cleanup:

    if ( LogonSession != NULL )
    {
        KerbDereferenceLogonSession( LogonSession );
    }
    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCacheEx
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN CredmanLocked = FALSE;
    PLIST_ENTRY ListEntry;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    DsysAssert( !TicketCacheLocked );
    KerbReadLockLogonSessions( LogonSession );

    KerbLockList( &LogonSession->CredmanCredentials );
    CredmanLocked = TRUE;

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSizeEx(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbComputeTicketCacheSizeEx(
            CredmanCred->SuppliedCredentials,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &CacheSize,
            &CacheEntries
            );
    }

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    SafeAllocaAllocate(CacheResponse, CacheSize);

    if ( CacheResponse == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheExMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponseEx(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbBuildQueryTicketCacheResponseEx(
            CredmanCred->SuppliedCredentials,
            CacheResponse,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &Offset,
            &Where,
            &Index
            );
    }

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if ( CredmanLocked ) {

        KerbUnlockList( &LogonSession->CredmanCredentials );
    }

    if ( TicketCacheLocked ) {

        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    SafeAllocaFree( CacheResponse );

    if ( ClientCacheResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackExternalTicket
//
//  Synopsis:   Marshalls a ticket cache entry for return to the caller
//
//  Effects:    Allocates memory in client's address space
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPackExternalTicket(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOL RetrieveTicketAsKerbCred,
    IN BOOL AllowTgtSessionKey,
    OUT PULONG ClientTicketSize,
    OUT PUCHAR * ClientTicket
    )
{
    ULONG TicketSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_EXTERNAL_TICKET TicketResponse = NULL;
    PBYTE ClientTicketResponse = NULL;
    KERB_MESSAGE_BUFFER EncodedTicket = {0};
    LONG_PTR Offset;
    PBYTE Where;
    BOOL fTicketOnStack = FALSE;
    KERB_TICKET_CACHE_ENTRY CacheEntryT;

    *ClientTicket = NULL;
    *ClientTicketSize = 0;

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

    //
    // Return a 32-bit external ticket if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // 448010: do not fess up the session key for primary TGTs unless
    //         the caller is trusted or policy is set appropriately
    //

    if ( !AllowTgtSessionKey &&
         ( CacheEntry->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT )) {

        CacheEntryT = *CacheEntry;
        RtlZeroMemory( &CacheEntryT.SessionKey, sizeof( KERB_ENCRYPTION_KEY ));
        CacheEntry = &CacheEntryT;
    }

    //
    // Encode the ticket
    //

    if ( RetrieveTicketAsKerbCred )
    {
        Status = KerbBuildKerbCred(
                     NULL,         // service ticket
                     CacheEntry,
                     &EncodedTicket.Buffer,
                     &EncodedTicket.BufferSize
                     );

        if ( !NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERBERR KerbErr;

        KerbErr = KerbPackData(
                    &CacheEntry->Ticket,
                    KERB_TICKET_PDU,
                    &EncodedTicket.BufferSize,
                    &EncodedTicket.Buffer
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }

    //
    // NOTE:  The 64-bit code below is (effectively) duplicated in
    //        the WOW helper routine.  If modifying one, make sure
    //        to apply the change(s) to the other as well.
    //

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = KerbPackExternalWOWTicket(CacheEntry,
                                           &EncodedTicket,
                                           &TicketResponse,
                                           &ClientTicketResponse,
                                           &TicketSize);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {

#endif  // _WIN64

        TicketSize = sizeof(KERB_EXTERNAL_TICKET) +
                        CacheEntry->DomainName.Length +
                        CacheEntry->TargetDomainName.Length +
                        CacheEntry->ClientDomainName.Length +
                        CacheEntry->SessionKey.keyvalue.length +
                        KerbNameLength(CacheEntry->ServiceName) +
                        KerbNameLength(CacheEntry->TargetName) +
                        KerbNameLength(CacheEntry->ClientName) +
                        EncodedTicket.BufferSize
                        ;

        //
        // Now allocate two copies of the structure - one in our process,
        // one in the client's process. We then build the structure in our
        // process but with pointer valid in the client's process
        //

        SafeAllocaAllocate(TicketResponse, TicketSize);
        fTicketOnStack = TRUE;

        if (TicketResponse == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    TicketSize,
                    (PVOID *) &ClientTicketResponse
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Offset = (LONG_PTR) (ClientTicketResponse - (PBYTE) TicketResponse);

        Where = ((PUCHAR) (TicketResponse + 1));

        //
        // Copy the non-pointer fields
        //

        TicketResponse->TicketFlags = CacheEntry->TicketFlags;
        TicketResponse->Flags = 0;
        TicketResponse->KeyExpirationTime.QuadPart = 0;
        TicketResponse->StartTime = CacheEntry->StartTime;
        TicketResponse->EndTime = CacheEntry->EndTime;
        TicketResponse->RenewUntil = CacheEntry->RenewUntil;
        TicketResponse->TimeSkew = CacheEntry->TimeSkew;
        TicketResponse->SessionKey.KeyType = CacheEntry->SessionKey.keytype;


        //
        // Copy the structure to the client's address space
        //

        //
        // These are PVOID aligned
        //

        //
        // Make sure the two name types are the same
        //

        DsysAssert(sizeof(KERB_INTERNAL_NAME) == sizeof(KERB_EXTERNAL_NAME));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameType) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameType));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameCount) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameCount));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,Names) == FIELD_OFFSET(KERB_EXTERNAL_NAME,Names));

        KerbPutKdcName(
            CacheEntry->ServiceName,
            &TicketResponse->ServiceName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->TargetName,
            &TicketResponse->TargetName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->ClientName,
            &TicketResponse->ClientName,
            Offset,
            &Where
            );


        //
        // From here on, they are WCHAR aligned
        //

        KerbPutString(
            &CacheEntry->DomainName,
            &TicketResponse->DomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->TargetDomainName,
            &TicketResponse->TargetDomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->ClientDomainName,
            &TicketResponse->AltTargetDomainName,       // ClientDomainName
            Offset,
            &Where
            );


        //
        // And from here they are BYTE aligned
        //

        TicketResponse->SessionKey.Value = (PBYTE) (Where + Offset);
        RtlCopyMemory(
            Where,
            CacheEntry->SessionKey.keyvalue.value,
            CacheEntry->SessionKey.keyvalue.length
            );
        Where += CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->SessionKey.Length = CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->EncodedTicketSize = EncodedTicket.BufferSize;
        TicketResponse->EncodedTicket = Where + Offset;

        RtlCopyMemory(
            Where,
            EncodedTicket.Buffer,
            EncodedTicket.BufferSize
            );

        Where += EncodedTicket.BufferSize;

        DsysAssert(Where - ((PUCHAR) TicketResponse) == (LONG_PTR) TicketSize);

#if _WIN64

    }

#endif  // _WIN64

    //
    // Copy the mess to the client
    //


    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                TicketSize,
                ClientTicketResponse,
                TicketResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ClientTicket = ClientTicketResponse;
    *ClientTicketSize = TicketSize;

    ClientTicketResponse = NULL;

Cleanup:

    if (EncodedTicket.Buffer != NULL)
    {
        MIDL_user_free(EncodedTicket.Buffer);
    }

    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    if (fTicketOnStack)
    {
        SafeAllocaFree(TicketResponse);
    }
    else
    {
        KerbFree(TicketResponse);
    }

    return(Status);
}


KERBERR
KerbBuildFullServiceName(
    IN OPTIONAL PUNICODE_STRING pDomainName,
    IN PUNICODE_STRING pServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME* ppFullServiceName
    )
{
    PKERB_INTERNAL_NAME pFinalName = NULL;
    PUCHAR pWhere;
    ULONG NameParts;
    ULONG NameLength = 0;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))

    {
        NameParts = 1;
        NameLength = (pDomainName  ? pDomainName->Length : 0) + pServiceName->Length + 2 * sizeof(WCHAR);
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
            (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
            (NameType == KRB_NT_ENTERPRISE_PRINCIPAL) ||
            (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        NameParts = 1;
        NameLength = pServiceName->Length + sizeof(WCHAR);
    }
    else
    {
        NameParts = pDomainName && pDomainName->Length ? 2 : 1;
        NameLength = (pDomainName ? pDomainName->Length : 0) + pServiceName->Length + 2 * sizeof(WCHAR);
    }

    *ppFullServiceName = NULL;

    pFinalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength);
    if (pFinalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    RtlZeroMemory(
        pFinalName,
        KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength
        );

    pWhere = (PUCHAR) pFinalName + KERB_INTERNAL_NAME_SIZE(NameParts);
    pFinalName->NameType = (USHORT) NameType;
    pFinalName->NameCount = (USHORT) NameParts;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))
    {
        //
        // If the domain name does not have an initial '\', reserve space for one
        //

        pFinalName->Names[0].Buffer = (PWSTR) pWhere;

        // This is dependent on our naming conventions.
        //
        // The full service name is the '\' domain name ':' service name.
        //

        pFinalName->Names[0].Length = (USHORT) ((pDomainName ? pDomainName->Length : 0) +
                                  pServiceName->Length +
                                  sizeof(WCHAR));

        pFinalName->Names[0].MaximumLength =
            pFinalName->Names[0].Length + sizeof(WCHAR);

        if (pDomainName && pDomainName->Length)
        {
            RtlCopyMemory(
                pFinalName->Names[0].Buffer,
                pDomainName->Buffer,
                pDomainName->Length
                );

            pWhere += pDomainName->Length;
        }

        if (pDomainName && (pDomainName->Length != 0) && (pServiceName->Length != 0))
        {
            *(PWSTR) pWhere = L'\\';
            pWhere += sizeof(WCHAR);
        }

        RtlCopyMemory(
            pWhere,
            pServiceName->Buffer,
            pServiceName->Length
            );

        pWhere += pServiceName->Length;
        pFinalName->Names[0].Length = (USHORT)(pWhere - (PUCHAR) pFinalName->Names[0].Buffer);
        *(LPWSTR) pWhere = L'\0';
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
             (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
             (NameType == KRB_NT_ENTERPRISE_PRINCIPAL)||
             (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        //
        // Principals have no domain name
        //

        pFinalName->Names[0].Length = pServiceName->Length;
        pFinalName->Names[0].MaximumLength = pServiceName->Length + sizeof(WCHAR);
        pFinalName->Names[0].Buffer = (PWSTR) pWhere;

        RtlCopyMemory(
            pWhere,
            pServiceName->Buffer,
            pServiceName->Length
            );
        pWhere += pServiceName->Length;
        *((LPWSTR) pWhere) = L'\0';
    }
    else
    {
        pFinalName->Names[0].Length = pServiceName->Length;
        pFinalName->Names[0].MaximumLength = pServiceName->Length + sizeof(WCHAR);
        pFinalName->Names[0].Buffer = (PWSTR) pWhere;

        RtlCopyMemory(
            pWhere,
            pServiceName->Buffer,
            pServiceName->Length
            );
        pWhere += pServiceName->Length;
        *((PWSTR) pWhere) = L'\0';
        pWhere += sizeof(WCHAR);

        if (pDomainName && pDomainName->Length)
        {
            pFinalName->Names[1].Length = pDomainName->Length;
            pFinalName->Names[1].MaximumLength = pDomainName->Length + sizeof(WCHAR);
            pFinalName->Names[1].Buffer = (PWSTR) pWhere;

            RtlCopyMemory(
                pWhere,
                pDomainName->Buffer,
                pDomainName->Length
                );
            pWhere += pDomainName->Length;
            *((PWSTR) pWhere) = L'\0';
            pWhere += sizeof(WCHAR);
        }
    }

    *ppFullServiceName = pFinalName;

    return (KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbTicketAsRequest
//
//  Synopsis:   Retrieves ticket via As Request
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbTicketAsRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    KERBERR KerbErr;

    KERB_TICKET_AS_REQUEST* pAsRequest = NULL;
    PBYTE pClientTicketResponse = NULL;
    ULONG TicketSize = 0;
    PKERB_LOGON_SESSION pLogonSession = NULL;
    LUID LogonId = {0};

    PKERB_TICKET_CACHE_ENTRY pTicketCacheEntry = NULL;
    KERB_ENCRYPTION_KEY CredentialKey = {0};

    PKERB_INTERNAL_NAME KdcServiceName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    PKERB_MIT_REALM MitRealm = NULL;
    ULONG RequestFlags = 0;
    BOOLEAN UsingSuppliedCreds = FALSE;
    BOOLEAN UseWkstaRealm = TRUE;
    BOOLEAN MitRealmLogon = FALSE;
    BOOLEAN UsedPrimaryLogonCreds = FALSE;

    pAsRequest = (KERB_TICKET_AS_REQUEST*) ProtocolSubmitBuffer;

    //
    // Verify the request
    //

    if ( !pAsRequest || (SubmitBufferSize < sizeof(KERB_TICKET_AS_REQUEST)) )
    {
        D_DebugLog((DEB_ERROR, "KerbTicketAsRequest %p %d\n", pAsRequest, SubmitBufferSize));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    NULL_RELOCATE_ONE(&pAsRequest->ClientName);
    NULL_RELOCATE_ONE(&pAsRequest->ClientRealm);
    NULL_RELOCATE_ONE(&pAsRequest->ServerName);
    NULL_RELOCATE_ONE(&pAsRequest->ServerRealm);
    NULL_RELOCATE_ONE(&pAsRequest->ClientPassword);

    D_DebugLog((DEB_WARN, "ClientRealm (%wZ), ClientName (%wZ), ClientPassword (%wZ), ServerRealm (%wZ), ServerName (%wZ)\n",
            &pAsRequest->ClientRealm,
            &pAsRequest->ClientName,
            &pAsRequest->ClientPassword,
            &pAsRequest->ServerRealm,
            &pAsRequest->ServerName));

    Status = NtAllocateLocallyUniqueId( &LogonId );

    if (NT_SUCCESS(Status))
    {
        Status = KerbCreateLogonSession(
                     &LogonId,
                     &pAsRequest->ClientName,
                     &pAsRequest->ClientRealm,
                     &pAsRequest->ClientPassword,
                     NULL,  // no old password
                     PRIMARY_CRED_CLEAR_PASSWORD,
                     KERB_LOGON_DUMMY_SESSION,
                     &pLogonSession
                     );
    }


    //
    // Parse the name
    //

    if (NT_SUCCESS(Status))
    {
        Status = KerbGetClientNameAndRealm(
                    &pLogonSession->LogonId,
                    &pLogonSession->PrimaryCredentials,
                    NULL,
                    &MitRealmLogon,
                    UseWkstaRealm,
                    &ClientName,
                    &ClientRealm
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

     //
    // if we're doing a MIT logon, add the MIT logon flag
    //

    if (MitRealmLogon && UsedPrimaryLogonCreds)
    {
       pLogonSession->LogonSessionFlags |= KERB_LOGON_MIT_REALM;
    }

TicketAsRequestRestart:

    D_DebugLog((DEB_TRACE, "KerbTicketAsRequest GetTicketRestart ClientRealm %wZ\n", &ClientRealm));

    KerbErr = KerbBuildFullServiceName(
                &pAsRequest->ServerRealm,
                &pAsRequest->ServerName,
                pAsRequest->NameType,
                &KdcServiceName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "KdcServiceName is "));
    D_KerbPrintKdcName((DEB_TRACE, KdcServiceName));

    Status = KerbGetAuthenticationTicket(
                pLogonSession,
                NULL, // no supplied cred
                NULL, // no credman cred
                KdcServiceName,
                &ClientRealm,
                ClientName,
                RequestFlags,
                KERB_TICKET_CACHE_PRIMARY_TGT,
                &pTicketCacheEntry,
                &CredentialKey,
                &CorrectRealm
                );

    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
       if (--RetryCount != 0)
       {
          KerbFreeKdcName(&KdcServiceName);
          KerbFreeString(&ClientRealm);
          ClientRealm = CorrectRealm;
          CorrectRealm.Buffer = NULL;

          //
          // Might be an MIT realm, in which case we'll need to adjust
          // the client name.  This will also populate the realm list
          // with appropriate entries, so the KerbGetKdcBinding will not
          // hit DNS again.
          //

          if (KerbLookupMitRealmWithSrvLookup(
                           &ClientRealm,
                           &MitRealm,
                           FALSE,
                           FALSE
                           ))
          {
                D_DebugLog((DEB_TRACE,"Reacquiring client name & realm after referral\n"));
                UseWkstaRealm = FALSE;
                KerbFreeKdcName(&ClientName);

                Status = KerbGetClientNameAndRealm(
                            &LogonId,
                            &pLogonSession->PrimaryCredentials,
                            NULL,
                            NULL,
                            UseWkstaRealm,
                            &ClientName,
                            &ClientRealm
                            );

                if (!NT_SUCCESS(Status))
                {
                   goto Cleanup;
                }
           }

           goto TicketAsRequestRestart;
       }
       else
       {
           // Tbd:  Log error here?  Max referrals reached..

           goto Cleanup;
       }
    }
    else if ((Status == STATUS_NO_SUCH_USER) && UsingSuppliedCreds && UseWkstaRealm)
    {
        //
        // We tried using the realm of the workstation and the account couldn't
        // be found - try the realm from the UPN now.
        //

        if (KerbIsThisOurDomain(&ClientRealm))
        {
            UseWkstaRealm = FALSE;

            KerbFreeKdcName(&ClientName);
            KerbFreeString(&ClientRealm);

            //
            // Only do this if the caller did not supply a
            // domain name
            //

            if (pLogonSession->PrimaryCredentials.DomainName.Length == 0)
            {
                Status = KerbGetClientNameAndRealm(
                            &LogonId,
                            &pLogonSession->PrimaryCredentials,
                            NULL,
                            NULL,
                            UseWkstaRealm,
                            &ClientName,
                            &ClientRealm
                            );
            }

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            goto TicketAsRequestRestart;
        }
    }

    if (pTicketCacheEntry == NULL)
    {
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    Status = KerbPackExternalTicket(
                pTicketCacheEntry,
                FALSE,
                TRUE,
                &TicketSize,
                &pClientTicketResponse
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = pClientTicketResponse;
    pClientTicketResponse = NULL;
    *ReturnBufferLength = TicketSize;

Cleanup:

    if (pTicketCacheEntry)
    {
        KerbDereferenceTicketCacheEntry(pTicketCacheEntry);
    }
    if (pLogonSession)
    {
        KerbDereferenceLogonSession(pLogonSession);
    }

    if (pClientTicketResponse)
    {
        LsaFunctions->FreeClientBuffer(
                        NULL,
                        pClientTicketResponse
                        );
    }

    KerbFreeKey(&CredentialKey);

    KerbFreeKdcName(&ClientName);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&CorrectRealm);

    KerbFreeKdcName(&KdcServiceName);

    *ProtocolStatus = Status;
    return (STATUS_SUCCESS);
}

NTSTATUS NTAPI
KerbTicketAsRequestSafe(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;

    __try
    {
        Status = KerbTicketAsRequest(
            ClientRequest,
            ProtocolSubmitBuffer,
            ClientBufferBase,
            SubmitBufferLength,
            ProtocolReturnBuffer,
            ReturnBufferLength,
            ProtocolStatus
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        D_DebugLog((DEB_ERROR, "KerbTicketAsRequest encountered an exception %#x\n", Status));
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveTicket
//
//  Synopsis:   Retrieves the initial ticket cache entry.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PBYTE ClientTicketResponse = NULL;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    ULONG TicketSize = 0;

    //
    // Verify the request.
    //
    if (SubmitBufferLength < sizeof(KERB_QUERY_TKT_CACHE_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    CacheRequest = (PKERB_QUERY_TKT_CACHE_REQUEST) ProtocolSubmitBuffer;


    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId ) )
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // elses ticket cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                    LogonId,
                    FALSE               // don't unlink
                    );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now find the TGT from the authentication ticket cache.
    //

    KerbReadLockLogonSessions(LogonSession);

    CacheEntry = KerbLocateTicketCacheEntryByRealm(
                    &LogonSession->PrimaryCredentials.AuthenticationTicketCache,
                    NULL,               // get initial ticket
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );

    KerbUnlockLogonSessions(LogonSession);

    if (CacheEntry == NULL)
    {
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                CacheEntry,
                FALSE,
                ( ClientInfo.HasTcbPrivilege || KerbGlobalAllowTgtSessionKey ),
                &TicketSize,
                &ClientTicketResponse
                );

    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    *ProtocolReturnBuffer = ClientTicketResponse;
    ClientTicketResponse = NULL;
    *ReturnBufferLength = TicketSize;

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }
    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetIpAddresses
//
//  Synopsis:   Saves the IP addresses passed in by netlogon
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_UPDATE_ADDRESSES_REQUEST UpdateRequest;

    //
    // This can only be called internally.
    //

    if (ClientRequest != NULL)
    {
        DebugLog((DEB_ERROR,"Can't update addresses from outside process. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Verify the request.
    //

    if (SubmitBufferLength < FIELD_OFFSET(KERB_UPDATE_ADDRESSES_REQUEST, Addresses))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    UpdateRequest = (PKERB_UPDATE_ADDRESSES_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the input
    //


    if (SubmitBufferLength < (sizeof(KERB_UPDATE_ADDRESSES_REQUEST)
                                + UpdateRequest->AddressCount * (sizeof(SOCKET_ADDRESS) + sizeof(struct sockaddr_in))
                                - ANYSIZE_ARRAY * sizeof(ULONG)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status= KerbUpdateGlobalAddresses(
                (PSOCKET_ADDRESS) UpdateRequest->Addresses,
                UpdateRequest->AddressCount
                );


    //
    // Copy them into the global for others to use
    //


Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPac
//
//  Synopsis:   Verifies that a PAC was signed by a valid KDC
//
//  Effects:
//
//  Arguments:  Same as for LsaApCallAuthenticationPackage. The submit
//              buffer must contain a KERB_VERIFY_PAC_REQUEST message.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS. The real error is in the protocol status.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_VERIFY_PAC_REQUEST VerifyRequest;
    DWORD MaxBufferSize;

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }
    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }
    if (SubmitBufferLength < sizeof(*VerifyRequest)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_PAC_REQUEST) ProtocolSubmitBuffer;

    MaxBufferSize = SubmitBufferLength -
                    FIELD_OFFSET(KERB_VERIFY_PAC_REQUEST, ChecksumAndSignature);
    if ((VerifyRequest->ChecksumLength > MaxBufferSize) ||
        (VerifyRequest->SignatureLength > MaxBufferSize) ||
        ((VerifyRequest->ChecksumLength + VerifyRequest->SignatureLength) >
         MaxBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (KerbKdcHandle == NULL)
    {
        Status = STATUS_MUST_BE_KDC;
        goto Cleanup;
    }

    DsysAssert(KerbKdcVerifyPac != NULL);

    Status = (*KerbKdcVerifyPac)(
                    VerifyRequest->ChecksumLength,
                    VerifyRequest->ChecksumAndSignature,
                    VerifyRequest->SignatureType,
                    VerifyRequest->SignatureLength,
                    VerifyRequest->ChecksumAndSignature + VerifyRequest->ChecksumLength
                    );
Cleanup:
    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


NTSTATUS
KerbPurgePrimaryCredentialsTickets(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN OPTIONAL PUNICODE_STRING ServerRealm
    )
{
    NTSTATUS Status;

    DsysAssert( PrimaryCredentials );

    if ( ServerName == NULL && ServerRealm == NULL ) {

        Status = STATUS_SUCCESS;

        KerbPurgeTicketCache( &PrimaryCredentials->AuthenticationTicketCache );
        KerbPurgeTicketCache( &PrimaryCredentials->ServerTicketCache );
        KerbPurgeTicketCache( &PrimaryCredentials->S4UTicketCache );


    } else if ( ServerName != NULL && ServerRealm != NULL ) {

        KERB_TICKET_CACHE * TicketCaches[3] = {
            &PrimaryCredentials->AuthenticationTicketCache,
            &PrimaryCredentials->ServerTicketCache,
            &PrimaryCredentials->S4UTicketCache
        };

        //
        // Prowl through the caches and remove all the matching tickets
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        KerbWriteLockTicketCache();

        for ( ULONG i = 0 ; i < 3 ; i++ ) {

            KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

            for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
                  ListEntry !=  &TicketCache->CacheEntries ;
                  ListEntry = ListEntry->Flink ) {

                KERB_TICKET_CACHE_ENTRY * CacheEntry;
                UNICODE_STRING SearchName = {0};

                CacheEntry= CONTAINING_RECORD(
                                ListEntry,
                                KERB_TICKET_CACHE_ENTRY,
                                ListEntry.Next
                                );

                if ( !KERB_SUCCESS( KerbConvertKdcNameToString(
                                        &SearchName,
                                        CacheEntry->ServiceName,
                                        NULL ))) { // no realm

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }

                //
                // Check to see if the server & realm name matches
                //

                if ( RtlEqualUnicodeString(
                         &SearchName,
                         ServerName,
                         TRUE ) &&
                     RtlEqualUnicodeString(
                         &CacheEntry->DomainName,
                         ServerRealm,
                         TRUE )) {

                    D_DebugLog((DEB_TRACE,"Purging a ticket!\n"));

                    Status = STATUS_SUCCESS;

                    //
                    // Move back one entry so that Remove() does not
                    // trash the iteration
                    //

                    ListEntry = ListEntry->Blink;

                    KerbRemoveTicketCacheEntry( CacheEntry );
                }

                KerbFreeString(&SearchName);
            }
        }

        KerbUnlockTicketCache();

    } else {

        //
        // ServerName and ServerRealm need to be either both specified or
        // both NULL.  Getting here means that only one of them is NULL,
        // and the assert below will specify which one it is.
        //

        DsysAssert( ServerName != NULL );
        DsysAssert( ServerRealm != NULL );

        Status = STATUS_SUCCESS;
    }

Cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicket
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST );
    PKERB_PURGE_TKT_CACHE_REQUEST PurgeRequest  = ( PKERB_PURGE_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Purging ticket cache\n"));


    //
    // Any purging will also tag SPN cache for purge
    //
    KerbCleanupSpnCache();


#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_REQUEST LocalPurgeRequest;

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId     = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.ServerName,
            &PurgeRequestWOW->ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.RealmName,
            &PurgeRequestWOW->RealmName );

        PurgeRequest = &LocalPurgeRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->RealmName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // If no servername / realm name were supplied, purge all tickets
    //

    if ((PurgeRequest->ServerName.Length) == 0 && (PurgeRequest->RealmName.Length == 0))
    {
        D_DebugLog((DEB_TRACE, "Purging all tickets\n"));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

    } else {

        D_DebugLog(( DEB_TRACE, "Purging tickets %wZ\\%wZ\n",
            &PurgeRequest->RealmName,
            &PurgeRequest->ServerName ));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     &PurgeRequest->ServerName,
                     &PurgeRequest->RealmName
                     );
    }

Cleanup:

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicketEx
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST );
    PKERB_PURGE_TKT_CACHE_EX_REQUEST PurgeRequest = ( PKERB_PURGE_TKT_CACHE_EX_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Purging ticket cache Ex\n"));



    //
    // Any purging will also tag SPN cache for purge
    //
    KerbCleanupSpnCache();


#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 );
    }

#endif

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_EX_REQUEST LocalPurgeRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientName,
            &PurgeRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientRealm,
            &PurgeRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerName,
            &PurgeRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerRealm,
            &PurgeRequestWOW->TicketTemplate.ServerRealm );

        LocalPurgeRequest.TicketTemplate.StartTime = PurgeRequestWOW->TicketTemplate.StartTime;
        LocalPurgeRequest.TicketTemplate.EndTime = PurgeRequestWOW->TicketTemplate.EndTime;
        LocalPurgeRequest.TicketTemplate.RenewTime = PurgeRequestWOW->TicketTemplate.RenewTime;
        LocalPurgeRequest.TicketTemplate.EncryptionType = PurgeRequestWOW->TicketTemplate.EncryptionType;
        LocalPurgeRequest.TicketTemplate.TicketFlags = PurgeRequestWOW->TicketTemplate.TicketFlags;

        PurgeRequest = &LocalPurgeRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerRealm );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller is required to have the TCB privilege
        // in order to access someone else's ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Purge the entire ticket cache?
    //

    if ( PurgeRequest->Flags & KERB_PURGE_ALL_TICKETS ) {

        D_DebugLog(( DEB_TRACE, "Purging all tickets\n" ));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

        DsysAssert( NT_SUCCESS( Status ));

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL) {

                continue;
            }

            Status = KerbPurgePrimaryCredentialsTickets(
                         CredmanCred->SuppliedCredentials,
                         NULL,
                         NULL
                         );

            DsysAssert( NT_SUCCESS( Status ));
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

    } else {

        BOOLEAN MatchClient = (
                    PurgeRequest->TicketTemplate.ClientName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ClientRealm.Length > 0 );

        BOOLEAN MatchServer = (
                    PurgeRequest->TicketTemplate.ServerName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ServerRealm.Length > 0 );

        BOOLEAN Found = FALSE;

        //
        // Take a look at the primary credentials and see if they need cleaning
        //

        if ( !MatchClient ||
             ( RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.UserName,
                   &PurgeRequest->TicketTemplate.ClientName,
                   TRUE ) &&
               RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.DomainName,
                   &PurgeRequest->TicketTemplate.ClientRealm,
                   TRUE ))) {

            UNICODE_STRING * MatchServerName;
            UNICODE_STRING * MatchServerRealm;

            if ( MatchServer ) {

                MatchServerName = &PurgeRequest->TicketTemplate.ServerName;
                MatchServerRealm = &PurgeRequest->TicketTemplate.ServerRealm;

            } else {

                MatchServerName = NULL;
                MatchServerRealm = NULL;
            }

            Status = KerbPurgePrimaryCredentialsTickets(
                         &LogonSession->PrimaryCredentials,
                         MatchServerName,
                         MatchServerRealm
                         );

            if ( NT_SUCCESS( Status )) {

                Found = TRUE;

            } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                goto Cleanup;
            }
        }

        //
        // Now look at the credman credentials and purge those
        //

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL ) {

                continue;
            }

            if ( !MatchClient ||
                 ( RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->UserName,
                       &PurgeRequest->TicketTemplate.ClientName,
                       TRUE ) &&
                   RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->DomainName,
                       &PurgeRequest->TicketTemplate.ClientRealm,
                       TRUE ))) {

                UNICODE_STRING * MatchServerName;
                UNICODE_STRING * MatchServerRealm;

                if ( MatchServer ) {

                    MatchServerName = &PurgeRequest->TicketTemplate.ServerName;
                    MatchServerRealm = &PurgeRequest->TicketTemplate.ServerRealm;

                } else {

                    MatchServerName = NULL;
                    MatchServerRealm = NULL;
                }

                Status = KerbPurgePrimaryCredentialsTickets(
                             CredmanCred->SuppliedCredentials,
                             MatchServerName,
                             MatchServerRealm
                             );

                if ( NT_SUCCESS( Status )) {

                    Found = TRUE;

                } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                    KerbUnlockList( &LogonSession->CredmanCredentials );
                    goto Cleanup;
                }
            }
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

        if ( Found ) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

Cleanup:

    if ( LogonSession ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = NULL;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicket
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    KERB_PRIMARY_CREDENTIAL * PrimaryCreds = NULL;
    PKERB_RETRIEVE_TKT_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_RESPONSE RetrieveResponse = NULL;
    KERB_TICKET_CACHE_ENTRY * CacheEntry = NULL;
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    ULONG Flags = 0;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TargetName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( (RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE) != 0)
    {
        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential);

        if (!NT_SUCCESS(Status))
        {
            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the
        // logon session.
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    }
    else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId ) )
    {

        LogonId = &ClientInfo.LogonId;

    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        //
        // The caller must have TCB privilege in order to access someone
        // elses ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Process the target names
    //

    Status = KerbProcessTargetNames(
                 &RetrieveRequest->TargetName,
                 NULL,                           // no supp target name
                 0,                              // no flags
                 &Flags,
                 &TargetName,
                 &TargetRealm
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check the TGT cache, as KerbGetServiceTicket doesn't look there
    //

    if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_DONT_USE_CACHE) == 0)
    {
        KerbReadLockLogonSessions(LogonSession);

        //
        // Pick which ticket cache to use
        //

        if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
        {
            PrimaryCreds = Credential->SuppliedCredentials;
        }
        else
        {
            PrimaryCreds = &LogonSession->PrimaryCredentials;
        }

        CacheEntry = KerbLocateTicketCacheEntry(
                         &PrimaryCreds->AuthenticationTicketCache,
                         TargetName,
                         &TargetRealm
                         );

        if (CacheEntry == NULL)
        {
            //
            // If the tgt cache failed, check the normal cache
            //

            CacheEntry = KerbLocateTicketCacheEntry(
                             &PrimaryCreds->ServerTicketCache,
                             TargetName,
                             &TargetRealm
                             );
        }

        //
        // Check if this is a TGT
        //

        if (CacheEntry == NULL)
        {
            if ((TargetName->NameCount == 2) &&
                 RtlEqualUnicodeString(
                     &TargetName->Names[0],
                     &KerbGlobalKdcServiceName,
                     TRUE                        // case insensitive
                     ))
            {

                //
                // If the tgt cache failed, check the normal cache
                //

                CacheEntry = KerbLocateTicketCacheEntryByRealm(
                                 &PrimaryCreds->AuthenticationTicketCache,
                                 &TargetRealm,
                                 KERB_TICKET_CACHE_PRIMARY_TGT
                                 );

                if (CacheEntry != NULL)
                {
                    //
                    // Make sure the name matches
                    //

                    KerbReadLockTicketCache();

                    if ( !KerbEqualKdcNames(
                              TargetName,
                              CacheEntry->ServiceName
                              ))
                    {
                        //
                        // We must unlock the ticket cache before dereferencing
                        //

                        KerbUnlockTicketCache();
                        KerbDereferenceTicketCacheEntry( CacheEntry );
                        CacheEntry = NULL;

                    }
                    else
                    {
                        KerbUnlockTicketCache();
                    }
                }
            }
        }

        //
        // If we found a ticket, make sure it has the right flags &
        // encryption type
        //

        if (CacheEntry != NULL)
        {
            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            LONG CacheEncryptionType;

            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = CacheEntry->TicketFlags;
            CacheEncryptionType = CacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags( RetrieveRequest->TicketFlags );

            //
            // Verify the flags
            //

            if ((( CacheTicketFlags & TicketFlags ) != TicketFlags) ||
                ((RetrieveRequest->EncryptionType != KERB_ETYPE_DEFAULT) && (CacheEncryptionType != RetrieveRequest->EncryptionType)))
            {
                //
                // Something doesn't match, so throw away the entry
                //

                KerbDereferenceTicketCacheEntry( CacheEntry );
                CacheEntry = NULL;
            }
        }

        KerbUnlockLogonSessions(LogonSession);
    }
    else
    {
        Flags |= KERB_GET_TICKET_NO_CACHE;
    }

    if (CacheEntry == NULL)
    {
        //
        // If we aren't supposed to get a new ticket, return a failure now.
        //

        if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CACHE_ONLY) != 0)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Now get a ticket
        //

        Status = KerbGetServiceTicket(
                    LogonSession,
                    Credential,
                    NULL,
                    TargetName,
                    &TargetRealm,
                    Flags,
                    RetrieveRequest->TicketFlags,
                    RetrieveRequest->EncryptionType,
                    NULL,                       // no error message
                    NULL,                       // no authorization data
                    NULL,                       // no tgt reply
                    &CacheEntry,
                    NULL                        // don't return logon guid
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "KerbRetrieveEncodedTicket failed to get outbound ticket: KerbGetServiceTicket failed with 0x%x\n",Status));
            goto Cleanup;
        }
    }

    //
    // Encode the ticket or kerb_cred
    //

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                 CacheEntry,
                 RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_AS_KERB_CRED,
                 ( ClientInfo.HasTcbPrivilege || KerbGlobalAllowTgtSessionKey ),
                 &ResponseSize,
                 &ClientResponse
                 );

    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry( CacheEntry );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    KerbFreeString( &TargetRealm );
    KerbFreeKdcName( &TargetName );

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


#if 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicketEx
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST );
    PKERB_RETRIEVE_TKT_EX_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_EX_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_EX_RESPONSE RetrieveResponse = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    ULONG Flags = 0;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;

    //
    // Verify the request
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket ex\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_RETRIEVE_TKT_EX_REQUEST LocalRetrieveRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 RetrieveRequestWOW =
            ( PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 )RetrieveRequest;

        LocalRetrieveRequest.MessageType = RetrieveRequestWOW->MessageType;
        LocalRetrieveRequest.LogonId = RetrieveRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientName,
            &RetrieveRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientRealm,
            &RetrieveRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerName,
            &RetrieveRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerRealm,
            &RetrieveRequestWOW->TicketTemplate.ServerRealm );

        LocalRetrieveRequest.TicketTemplate.StartTime = RetrieveRequestWOW->TicketTemplate.StartTime;
        LocalRetrieveRequest.TicketTemplate.EndTime = RetrieveRequestWOW->TicketTemplate.EndTime;
        LocalRetrieveRequest.TicketTemplate.RenewTime = RetrieveRequestWOW->TicketTemplate.RenewTime;
        LocalRetrieveRequest.TicketTemplate.EncryptionType = RetrieveRequestWOW->TicketTemplate.EncryptionType;
        LocalRetrieveRequest.TicketTemplate.TicketFlags = RetrieveRequestWOW->TicketTemplate.TicketFlags;

        LocalRetrieveRequest.CacheOptions = RetrieveRequestWOW->CacheOptions;
        LocalRetrieveRequest.CredentialsHandle = RetrieveRequestWOW->CredentialsHandle;

        //
        // TODO: take care of SecondTicket, UserAuthData and Addresses
        //

        LocalRetrieveRequest.SecondTicket = NULL;
        LocalRetrieveRequest.UserAuthData = NULL;
        LocalRetrieveRequest.Addresses = NULL;

        RetrieveRequest = &LocalRetrieveRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerRealm );

    //
    // TODO: take care of SecondTicket, UserAuthData and Addresses
    //

    if ( RetrieveRequest->SecondTicket != NULL ||
         RetrieveRequest->UserAuthData != NULL ||
         RetrieveRequest->Addresses != NULL ) {

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, user the caller's logon id
    //

    if ( RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE ) {

        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential
                     );

        if ( !NT_SUCCESS( Status )) {

            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the logon session
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    } else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone else's
        // ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    if ( Credential != NULL ) {

        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if ( ClientResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}

#endif // 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptMessage
//
//  Synopsis:   Decrypts a buffer with either the specified key or the d
//              primary key from the specified logon session.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_DECRYPT_REQUEST DecryptRequest;
    PBYTE DecryptResponse = NULL;
    ULONG ResponseLength = 0;

    PBYTE ClientResponse = NULL;
    PKERB_ENCRYPTION_KEY KeyToUse = NULL;
    KERB_ENCRYPTION_KEY SuppliedKey = {0};
    BOOLEAN FreeKey = FALSE;
    PCRYPTO_SYSTEM CryptoSystem = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Decrypting Message\n"));

    if (SubmitBufferSize < sizeof(KERB_DECRYPT_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DecryptRequest = (PKERB_DECRYPT_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the pointers
    //

    if (DecryptRequest->InitialVector != NULL)
    {
        if (DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + DecryptRequest->InitialVectorSize > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"InitialVector end pass end of buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->InitialVector < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"InitialVector begin before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->InitialVector = DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
    }
    else
    {
        if (DecryptRequest->InitialVectorSize != 0)
        {
            DebugLog((DEB_ERROR,"Non-zero vector size with null vector\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + DecryptRequest->EncryptedDataSize > SubmitBufferSize)
    {
        DebugLog((DEB_ERROR,"EncryptedData end past end of request buffer\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (DecryptRequest->EncryptedData < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
    {
        DebugLog((DEB_ERROR,"EncryptedData begin before end of DECRYPT_REQUEST\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    DecryptRequest->EncryptedData = DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;

    //
    // If the caller wants the default key, then open the specified logon
    // session and get out the key.
    //

    if (DecryptRequest->Flags & KERB_DECRYPT_FLAG_DEFAULT_KEY)
    {
        //
        // Find the callers logon id & TCB status
        //

        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If the caller did not provide a logon id, use the caller's logon id.
        //

        if ( RtlIsZeroLuid( &DecryptRequest->LogonId ) )
        {
            LogonId = &ClientInfo.LogonId;
        }
        else
        {
            //
            // Verify the caller has TCB privilege if they want access to someone
            // elses ticket cache.
            //

            if (!ClientInfo.HasTcbPrivilege)
            {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

            LogonId = &DecryptRequest->LogonId;
        }

        LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        FALSE               // don't unlink
                        );

        if (LogonSession == NULL)
        {
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        //
        // Get the key from the logon session
        //

        KerbReadLockLogonSessions(LogonSession);
        if (LogonSession->PrimaryCredentials.Passwords != NULL)
        {
            KeyToUse = KerbGetKeyFromList(
                        LogonSession->PrimaryCredentials.Passwords,
                        DecryptRequest->CryptoType
                        );
            if (KeyToUse != NULL)
            {
                KERBERR KerbErr;

                KerbErr = KerbDuplicateKey(
                            &SuppliedKey,
                            KeyToUse
                            );
                KeyToUse = NULL;
                Status = KerbMapKerbError(KerbErr);
            }
            else
            {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        }
        else
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        KerbUnlockLogonSessions(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KeyToUse = &SuppliedKey;
        FreeKey = TRUE;
    }
    else
    {
        if (DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + DecryptRequest->Key.Length > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"End of supplied key past end of request buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->Key.Value < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"Begin of supplied key before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->Key.Value = DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
        SuppliedKey.keytype = DecryptRequest->Key.KeyType;
        SuppliedKey.keyvalue.value = DecryptRequest->Key.Value;
        SuppliedKey.keyvalue.length = DecryptRequest->Key.Length;
        KeyToUse = &SuppliedKey;
    }



    //
    // Now do the decryption
    //

    SafeAllocaAllocate(DecryptResponse, DecryptRequest->EncryptedDataSize);

    if (DecryptResponse == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ResponseLength = DecryptRequest->EncryptedDataSize;

    Status = CDLocateCSystem(
                DecryptRequest->CryptoType,
                &CryptoSystem
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The crypt system must be integrity protected - otherwise it may be
    // used as a general purpose encryption/decryption technique.
    //

    if ((CryptoSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) == 0)
    {
        DebugLog((DEB_ERROR,"Trying to decrypt with non-integrity protected crypt system (%d)\n",
            CryptoSystem->EncryptionType));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = CryptoSystem->Initialize(
                KeyToUse->keyvalue.value,
                KeyToUse->keyvalue.length,
                DecryptRequest->KeyUsage,
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If there was an initial vector, use it now
    //

    if (DecryptRequest->InitialVectorSize != 0)
    {
        Status = CryptoSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    DecryptRequest->InitialVector,
                    DecryptRequest->InitialVectorSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Decrypt
    //

    Status = CryptoSystem->Decrypt(
                CryptBuffer,
                DecryptRequest->EncryptedData,
                DecryptRequest->EncryptedDataSize,
                DecryptResponse,
                &ResponseLength
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Return the decrypted data to the client
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                ResponseLength,
                (PVOID *) &ClientResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                ResponseLength,
                ClientResponse,
                DecryptResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseLength;

Cleanup:

    if ((CryptoSystem != NULL) && (CryptBuffer != NULL))
    {
        CryptoSystem->Discard(&CryptBuffer);
    }
    if (FreeKey)
    {
        KerbFreeKey(&SuppliedKey);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    SafeAllocaFree(DecryptResponse);

    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddBindingCacheEntry
//
//  Synopsis:   Adds an entry to the binding cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST BindingRequest = ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST )ProtocolSubmitBuffer;
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    ULONG StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Addding binding cache entry\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_ADD_BINDING_CACHE_ENTRY_REQUEST LocalBindingRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 BindingRequestWOW =
            ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 )BindingRequest;

        LocalBindingRequest.MessageType = BindingRequestWOW->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.RealmName,
            &BindingRequestWOW->RealmName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.KdcAddress,
            &BindingRequestWOW->KdcAddress );

        LocalBindingRequest.AddressType = BindingRequestWOW->AddressType;

        BindingRequest = &LocalBindingRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &BindingRequest->RealmName );
    NULL_RELOCATE_ONE( &BindingRequest->KdcAddress );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // Require the caller to have TCB.
    //

    if ( !ClientInfo.HasTcbPrivilege ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }

    Status = KerbCacheBinding(
                 &BindingRequest->RealmName,
                 &BindingRequest->KdcAddress,
                 BindingRequest->AddressType,
                 0,
                 0,
                 0,
                 &CacheEntry
                 );

Cleanup:

    if ( CacheEntry != NULL ) {

        KerbDereferenceBindingCacheEntry( CacheEntry );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;
    *ProtocolStatus = Status;

    return STATUS_SUCCESS;
}


NTSTATUS
VerifyCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password
    )
{
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll;
    SID_AND_ATTRIBUTES_LIST GroupMembership;

    NT_OWF_PASSWORD NtOwfPassword;
    BOOLEAN UpdateLogonStats = FALSE;
    NTSTATUS Status = STATUS_LOGON_FAILURE;

    GroupMembership.SidAndAttributes = NULL;


    //
    // lazy initialization of SAM handles.
    //

    if( KerbGlobalDomainHandle == NULL )
    {
        SAMPR_HANDLE SamHandle = NULL;
        SAMPR_HANDLE DomainHandle = NULL;
        PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;

        //
        // Open SAM to get the account information
        //

        Status = SamIConnect(
                    NULL,                   // no server name
                    &SamHandle,
                    0,                      // no desired access
                    TRUE                    // trusted caller
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalSamHandle,
                        SamHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &SamHandle );
        }


        Status = LsaIQueryInformationPolicyTrusted(
                        PolicyAccountDomainInformation,
                        &PolicyInfo
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SamrOpenDomain(
                        KerbGlobalSamHandle,
                        0,                  // no desired access
                        (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                        &DomainHandle
                        );

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            PolicyInfo
            );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalDomainHandle,
                        DomainHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &DomainHandle );
        }
    }

    //
    // try by DN first, then by UPN/SAM accountname.
    //

    Status = SamIGetUserLogonInformationEx(
                KerbGlobalDomainHandle,
                SAM_OPEN_BY_DN | SAM_NO_MEMBERSHIPS,
                UserName,
                USER_ALL_OWFPASSWORD |          // OWFs
                USER_ALL_NTPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_LMPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_BADPASSWORDCOUNT |     // bad password count.
                USER_ALL_USERACCOUNTCONTROL,    // UserAccountControl - account disabled/etc.
                &UserAllInfo,
                &GroupMembership,
                &UserHandle
                );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_OBJECT_NAME_INVALID)
    {
        Status = SamIGetUserLogonInformationEx(
                    KerbGlobalDomainHandle,
                    SAM_OPEN_BY_UPN_OR_ACCOUNTNAME | SAM_NO_MEMBERSHIPS,
                    UserName,
                    USER_ALL_OWFPASSWORD |          // OWFs
                    USER_ALL_NTPASSWORDPRESENT |    // OWF present bits.
                    USER_ALL_LMPASSWORDPRESENT |    // OWF present bits.
                    USER_ALL_BADPASSWORDCOUNT |     // bad password count.
                    USER_ALL_USERACCOUNTCONTROL,    // UserAccountControl - account disabled/etc.
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    UserAll = &UserAllInfo->All;


    Status = RtlCalculateNtOwfPassword(
                Password,
                &NtOwfPassword
                );

    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }


    Status = STATUS_LOGON_FAILURE;

    if (UserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
    {
        goto Cleanup;
    }

    if (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        goto Cleanup;
    }

    if ( !UserAll->NtPasswordPresent )
    {
        if( UserAll->LmPasswordPresent )
        {
            goto Cleanup;
        }

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            &KerbGlobalNullNtOwfPassword,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            UpdateLogonStats = TRUE;
            goto Cleanup;
        }

    } else {

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            UserAll->NtOwfPassword.Buffer,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            UpdateLogonStats = TRUE;
            goto Cleanup;
        }
    }

    //
    // success!
    //

    if ( UserAll->BadPasswordCount )
    {
        //
        // successful logon, insure logon status gets updated for the lockout/bad password case.
        //

        UpdateLogonStats = TRUE;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    ZeroMemory( &NtOwfPassword, sizeof(NtOwfPassword) );

    if( UserAllInfo != NULL )
    {
        //
        // SamIFree zeroes the sensitive fields.
        //

        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if( UpdateLogonStats )
    {
        SAM_LOGON_STATISTICS LogonStats;

        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        if( NT_SUCCESS(Status) )
        {
            LogonStats.StatisticsToApply = USER_LOGON_INTER_SUCCESS_LOGON;
        } else {
            LogonStats.StatisticsToApply = USER_LOGON_BAD_PASSWORD;
        }

        SamIUpdateLogonStatistics( UserHandle, &LogonStats );
    }

    if (UserHandle != NULL)
    {
        SamrCloseHandle( &UserHandle );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        SamIFreeSidAndAttributesList(&GroupMembership);
    }

    return Status;
}

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest = NULL;
    NTSTATUS Status = STATUS_LOGON_FAILURE;


    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "KerbVerifyCredentials\n"));

    //
    // only support in proc use of this interface.
    //

    if( ClientRequest != NULL )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    if (SubmitBufferSize < sizeof(KERB_VERIFY_CREDENTIALS_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_CREDENTIALS_REQUEST) ProtocolSubmitBuffer;


#if 0   // only needed if out-proc supported.
    //
    // Normalize the strings
    //

    if( ClientRequest != NULL )
    {
        NULL_RELOCATE_ONE(&VerifyRequest->UserName);
        NULL_RELOCATE_ONE(&VerifyRequest->DomainName);
        NULL_RELOCATE_ONE(&VerifyRequest->Password);
    }
#endif


    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    Status = VerifyCredentials(
                    &VerifyRequest->UserName,
                    &VerifyRequest->DomainName,
                    &VerifyRequest->Password
                    );

Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\idl\pacimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        pacimp.h
//
// Contents:    imports for pac.idl
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <lsass.h>
#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntmsv1_0.h>
#include <logonmsv.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\idl\secimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        secimp.h
//
// Contents:    imports for security .idl files
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <security.h>
#include <kerbcred.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\base64\base64.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    base64.h

Abstract:

    base64

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#ifndef __BASE64_H__
#define __BASE64_H__

#include <assert.h>

#ifdef UNICODE
#define Base64Encode  Base64EncodeW
#else
#define Base64Encode  Base64EncodeA
#endif // !UNICODE

#ifndef SAFE_SUBTRACT_POINTERS
#define SAFE_SUBTRACT_POINTERS(__x__, __y__) ( DW_PtrDiffc(__x__, sizeof(*(__x__)), __y__, sizeof(*(__y__))) )

#define CRYPT_STRING_NOCR                   0x80000000

__inline DWORD
DW_PtrDiffc(
    IN void const *pb1,
    IN DWORD dwPtrEltSize1,
    IN void const *pb2,
    IN DWORD dwPtrEltSize2)
{
    // pb1 should be greater
    assert((ULONG_PTR)pb1 >= (ULONG_PTR)pb2);

    // both should have same elt size
    assert(dwPtrEltSize1 == dwPtrEltSize2);

    // assert that the result doesn't overflow 32-bits
    assert((DWORD)((ULONG_PTR)pb1 - (ULONG_PTR)pb2) == (ULONG_PTR)((ULONG_PTR)pb1 - (ULONG_PTR)pb2));

    // return number of objects between these pointers
    return (DWORD) ( ((ULONG_PTR)pb1 - (ULONG_PTR)pb2) / dwPtrEltSize1 );
}
#endif SAFE_SUBTRACT_POINTERS

#ifdef __cplusplus
extern "C" {
#endif

DWORD
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut
    );

DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut
    );

DWORD
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *wszOut,
    OUT DWORD *pcchOut
    );

DWORD
Base64DecodeW(
    IN const WCHAR * wszIn,
    IN DWORD cch,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut
    );

#ifdef __cplusplus
}
#endif

#endif // #ifndef __BASE64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\changepass\password.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    password.cxx

Abstract:

    password

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "password.hxx"

VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s [-p<package>] [-s] [-l] -r "
        "-c<client name> -C<client realm> -o<old password> -n<new password>\n"
        "Remarks: package default to NTLM, use -s to set password, -l local only\n"
        "         -r not impernating (self)\n\n", pszApp);
    exit(-1);
}

NTSTATUS
MsvChangePasswordUser(
    IN HANDLE LogonHandle,
    IN ULONG PackageId,
    IN BOOLEAN bCacheOnly,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pOldPassword,
    IN UNICODE_STRING* pNewPassword,
    IN BOOLEAN bImpersonating
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    MSV1_0_CHANGEPASSWORD_RESPONSE* pResponse = NULL ;
    ULONG cbResponseSize;
    MSV1_0_CHANGEPASSWORD_REQUEST* pChangeRequest = NULL;
    ULONG cbChangeRequestSize;

    DebugPrintf(SSPI_LOG, "MsvChangePasswordUser PackageId %d, DomainName %wZ, "
                "UserName %wZ, OldPass %wZ, NewPass %wZ, Impersonating %s\n",
                PackageId, pDomainName, pUserName, pOldPassword, pNewPassword, bImpersonating ? "true" : "false");

    cbChangeRequestSize = ROUND_UP_COUNT(sizeof(MSV1_0_CHANGEPASSWORD_REQUEST), sizeof(DWORD))
                            + pUserName->Length
                            + pDomainName->Length
                            + pOldPassword->Length
                            + pNewPassword->Length;
    pChangeRequest = (MSV1_0_CHANGEPASSWORD_REQUEST*) new CHAR[cbChangeRequestSize];

    Status DBGCHK = pChangeRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pChangeRequest, cbChangeRequestSize);

        pChangeRequest->MessageType = bCacheOnly ? MsV1_0ChangeCachedPassword : MsV1_0ChangePassword;

        pChangeRequest->AccountName = *pUserName;
        pChangeRequest->AccountName.Buffer = (PWSTR) ROUND_UP_POINTER(sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) + (PBYTE) pChangeRequest, sizeof(DWORD));
        RtlCopyMemory(
            pChangeRequest->AccountName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        pChangeRequest->DomainName = *pDomainName;
        pChangeRequest->DomainName.Buffer = pChangeRequest->AccountName.Buffer + pChangeRequest->AccountName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->DomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        pChangeRequest->OldPassword = *pOldPassword;
        pChangeRequest->OldPassword.Buffer = pChangeRequest->DomainName.Buffer + pChangeRequest->DomainName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->OldPassword.Buffer,
            pOldPassword->Buffer,
            pOldPassword->Length
            );

        pChangeRequest->NewPassword = *pNewPassword;
        pChangeRequest->NewPassword.Buffer = pChangeRequest->OldPassword.Buffer + pChangeRequest->OldPassword.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->NewPassword.Buffer,
            pNewPassword->Buffer,
            pNewPassword->Length
            );

        //
        // We are running as the caller, so state we are impersonating
        //

        pChangeRequest->Impersonating = bImpersonating;

        DebugPrintf(SSPI_LOG, "Msg type %#x\n", pChangeRequest->MessageType);
        Status DBGCHK = LsaCallAuthenticationPackage(
                            LogonHandle,
                            PackageId,
                            pChangeRequest,
                            cbChangeRequestSize,
                            (VOID**) &pResponse,
                            &cbResponseSize,
                            &SubStatus
                            );
    }

    if (NT_SUCCESS(Status))
    {
        if (pResponse && pResponse->PasswordInfoValid)
        {
            DebugPrintf(SSPI_LOG, "SubStatus %#x, MinPasswordLength %d, PasswordHistoryLength %d\n",
                SubStatus,
                pResponse->DomainPasswordInfo.MinPasswordLength,
                pResponse->DomainPasswordInfo.PasswordHistoryLength);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "MaxPasswordAge ", &pResponse->DomainPasswordInfo.MaxPasswordAge);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "MinPasswordAge ", &pResponse->DomainPasswordInfo.MinPasswordAge);

        }
        Status DBGCHK = SubStatus;
    }
    else
    {
        DebugPrintf(SSPI_LOG, "SubStatus %#x\n", SubStatus);
    }

    if (pResponse)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    if (pChangeRequest)
    {
        delete [] pChangeRequest;
    }
    return Status;
}

NTSTATUS
KerbChangePasswordUser(
    IN HANDLE LogonHandle,
    IN ULONG PackageId,
    IN BOOLEAN bImpersonating,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pOldPassword,
    IN UNICODE_STRING* pNewPassword
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    PVOID pResponse = NULL ;
    ULONG cbResponseSize;
    PKERB_CHANGEPASSWORD_REQUEST pChangeRequest = NULL;
    ULONG cbChangeRequestSize;

    DebugPrintf(SSPI_LOG, "KerbChangePasswordUser PackageId %d, DomainName %wZ, "
        "UserName %wZ, OldPass %wZ, NewPass %wZ, Impersonating %s\n",
        PackageId, pDomainName, pUserName, pOldPassword, pNewPassword, bImpersonating ? "true" : "false");

    cbChangeRequestSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST), sizeof(DWORD))
                            + pUserName->Length + pDomainName->Length
                            + pOldPassword->Length + pNewPassword->Length;

    pChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) new CHAR[cbChangeRequestSize];

    Status DBGCHK = pChangeRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pChangeRequest, cbChangeRequestSize);

        pChangeRequest->MessageType = KerbChangePasswordMessage;

        pChangeRequest->AccountName = *pUserName;
        pChangeRequest->AccountName.Buffer = (PWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) pChangeRequest, sizeof(DWORD));
        RtlCopyMemory(
            pChangeRequest->AccountName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        pChangeRequest->DomainName = *pDomainName;
        pChangeRequest->DomainName.Buffer = pChangeRequest->AccountName.Buffer + pChangeRequest->AccountName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->DomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        pChangeRequest->OldPassword = *pOldPassword;
        pChangeRequest->OldPassword.Buffer = pChangeRequest->DomainName.Buffer + pChangeRequest->DomainName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->OldPassword.Buffer,
            pOldPassword->Buffer,
            pOldPassword->Length
            );

        pChangeRequest->NewPassword = *pNewPassword;
        pChangeRequest->NewPassword.Buffer = pChangeRequest->OldPassword.Buffer + pChangeRequest->OldPassword.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pChangeRequest->NewPassword.Buffer,
            pNewPassword->Buffer,
            pNewPassword->Length
            );

        //
        // We are running as the caller, so state we are impersonating
        //

        pChangeRequest->Impersonating = bImpersonating;

        Status DBGCHK = LsaCallAuthenticationPackage(
                            LogonHandle,
                            PackageId,
                            pChangeRequest,
                            cbChangeRequestSize,
                            &pResponse,
                            &cbResponseSize,
                            &SubStatus
                            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }
    else
    {
        DebugPrintf(SSPI_LOG, "SubStatus %#x\n", SubStatus);
    }

    if (pResponse)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    if (pChangeRequest)
    {
        delete [] pChangeRequest;
    }
    return Status;
}

NTSTATUS
KerbSetPasswordUser(
    IN HANDLE LogonHandle,
    IN ULONG PackageId,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pNewPassword,
    IN OPTIONAL PCredHandle pCredentialsHandle
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    PVOID pResponse = NULL ;
    ULONG cbResponseSize = NULL;

    PKERB_SETPASSWORD_REQUEST pSetRequest = NULL;
    ULONG cbChangeSize;

    DebugPrintf(SSPI_LOG, "KerbSetPasswordUser PackageId %d, DomainName %wZ, "
        "UserName %wZ, NewPassword %wZ, CredHandle %p\n",
        PackageId, pDomainName, pUserName, pNewPassword, pCredentialsHandle);

    cbChangeSize = ROUND_UP_COUNT(sizeof(KERB_SETPASSWORD_REQUEST), sizeof(DWORD))
                    + pUserName->Length + pDomainName->Length + pNewPassword->Length;

    pSetRequest = (PKERB_SETPASSWORD_REQUEST) new CHAR [cbChangeSize];

    Status DBGCHK = pSetRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pSetRequest, cbChangeSize);

        pSetRequest->MessageType = KerbSetPasswordMessage;

        pSetRequest->AccountName = *pUserName;
        pSetRequest->AccountName.Buffer = (PWSTR) ROUND_UP_POINTER(sizeof(KERB_SETPASSWORD_REQUEST) + (PBYTE) pSetRequest, sizeof(DWORD));

        RtlCopyMemory(
            pSetRequest->AccountName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        pSetRequest->DomainName = *pDomainName;
        pSetRequest->DomainName.Buffer = pSetRequest->AccountName.Buffer + pSetRequest->AccountName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pSetRequest->DomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        pSetRequest->Password = *pNewPassword;
        pSetRequest->Password.Buffer = pSetRequest->DomainName.Buffer + pSetRequest->DomainName.Length / sizeof(WCHAR);

        RtlCopyMemory(
            pSetRequest->Password.Buffer,
            pNewPassword->Buffer,
            pNewPassword->Length
            );

        if (pCredentialsHandle)
        {
            pSetRequest->CredentialsHandle = *pCredentialsHandle;
            pSetRequest->Flags |= KERB_SETPASS_USE_CREDHANDLE;
        }

        Status DBGCHK = LsaCallAuthenticationPackage(
                            LogonHandle,
                            PackageId,
                            pSetRequest,
                            cbChangeSize,
                            &pResponse,
                            &cbResponseSize,
                            &SubStatus
                            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (pResponse)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    if (pSetRequest)
    {
        delete [] pSetRequest;
    }

    return Status;
}

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    HANDLE LogonHandle = NULL;
    ULONG PackageId = -1;
    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING OldPassword = {0};
    UNICODE_STRING NewPassword = {0};

    BOOLEAN bIsSetPassword = FALSE;
    BOOLEAN bCacheOnly = FALSE;
    BOOLEAN bImpersonating = TRUE;
    PCSTR pszPackageName = NTLMSP_NAME_A;

    for (INT i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (argv[i][1])
            {
            case 'c':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ClientName);
                break;

            case 'C':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ClientRealm);
                break;

            case 'p':
                pszPackageName = argv[i] + 2;
                break;

            case 'o':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &OldPassword);
                break;

            case 'n':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &NewPassword);
                break;

            case 'r':
                bImpersonating = FALSE;
                break;

            case 's':
                bIsSetPassword = TRUE;
                break;

            case 'l':
                bCacheOnly = TRUE;
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetLsaHandleAndPackageId(
                            pszPackageName,
                            &LogonHandle,
                            &PackageId
                            );
    }

    if (NT_SUCCESS(Status))
    {
        if (0 == _stricmp(NTLMSP_NAME_A, pszPackageName))
        {
            if (bIsSetPassword)
            {
                DebugPrintf(SSPI_ERROR, "SetPassword not supported\n");
                Status DBGCHK = STATUS_NOT_SUPPORTED;
            }
            else
            {
                Status DBGCHK = MsvChangePasswordUser(
                                    LogonHandle,
                                    PackageId,
                                    bCacheOnly,
                                    &ClientRealm,
                                    &ClientName,
                                    &OldPassword,
                                    &NewPassword,
                                    bImpersonating
                                    );
            }
        }
        else if (0 == _stricmp(MICROSOFT_KERBEROS_NAME_A, pszPackageName))
        {
            if (bIsSetPassword)
            {
                Status DBGCHK = KerbSetPasswordUser(
                                    LogonHandle,
                                    PackageId,
                                    &ClientRealm,
                                    &ClientName,
                                    &NewPassword,
                                    NULL // no cred handle
                                    );
            }
            else
            {
                Status DBGCHK = KerbChangePasswordUser(
                                    LogonHandle,
                                    PackageId,
                                    bImpersonating,
                                    &ClientRealm,
                                    &ClientName,
                                    &OldPassword,
                                    &NewPassword
                                    );
            }
        }
        else
        {
            DebugPrintf(SSPI_ERROR, "%s not supported\n", pszPackageName);
            Status DBGCHK = STATUS_NOT_SUPPORTED;
        }
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "Operation succeeded\n");
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "Operation failed\n");
    }

    if (LogonHandle)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    RtlFreeUnicodeString(&ClientName);
    RtlFreeUnicodeString(&ClientRealm);
    RtlFreeUnicodeString(&OldPassword);
    RtlFreeUnicodeString(&NewPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\kerbcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbcred.h
//
// Contents:    structures for kerberos primary and supplemental credentials
//
//
// History:     20-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCRED_H__
#define __KERBCRED_H__


//
// Kerberos primary credentials store keys suitable for different
// encryption types.
//
#ifndef _KRB5_Module_H_
typedef struct _KERB_RPC_OCTET_STRING {
    unsigned long length;
#ifdef MIDL_PASS
    [size_is(length)]
#endif // MIDL_PASS
    unsigned char *value;
} KERB_RPC_OCTET_STRING;

typedef struct _KERB_ENCRYPTION_KEY {
    long keytype;
    KERB_RPC_OCTET_STRING keyvalue;
} KERB_ENCRYPTION_KEY;
#endif // _KRB5_Module_H_


typedef struct _KERB_KEY_DATA {
    UNICODE_STRING Salt;
    KERB_ENCRYPTION_KEY Key;
} KERB_KEY_DATA, *PKERB_KEY_DATA;

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA Credentials[*];
#else
    KERB_KEY_DATA Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;


#define KERB_PRIMARY_CRED_OWF_ONLY      2
#define KERB_PRIMARY_CRED_REVISION      3

//
// Flags for setting account keys
//

#define KERB_SET_KEYS_REPLACE   0x1



//
// KERB_STORED_CREDENTIALS are stored in the DS (blob), so
// they've got to be stored in 32 bit format, for W2k and 
// 32bit DC compatibility. 7/6/2000 - TS
//

#define KERB_KEY_DATA32_SIZE 20 
#define KERB_STORED_CREDENTIAL32_SIZE 16

#pragma pack(4)

typedef struct _KERB_ENCRYPTION_KEY32 {
    LONG keytype;
    ULONG keyvaluelength;       // KERB_RPC_OCTET_STRING32 
    ULONG keyvaluevalue;
} KERB_ENCRYPTION_KEY32;

typedef struct _KERB_KEY_DATA32 {
    UNICODE_STRING32 Salt;
    KERB_ENCRYPTION_KEY32 Key; // KERB_ENCRYPTION_KEY32
} KERB_KEY_DATA32, *PKERB_KEY_DATA32;



typedef struct _KERB_STORED_CREDENTIAL32 {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING32 DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA32 Credentials[*];              // KERB_KEY_DATA32
#else
    KERB_KEY_DATA32 Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL32, *PKERB_STORED_CREDENTIAL32;

#pragma pack()

#ifdef _WIN64

NTSTATUS
KdcPack32BitStoredCredential(
   IN PKERB_STORED_CREDENTIAL Cred64,
   OUT PKERB_STORED_CREDENTIAL32 * ppCred32,
   OUT PULONG pCredSize
   );

NTSTATUS
KdcUnpack32BitStoredCredential(
    IN PKERB_STORED_CREDENTIAL32 Cred32,
    IN OUT PKERB_STORED_CREDENTIAL * ppCred64,
    IN OUT PULONG CredLength
    );
#endif // WIN64
       



#endif // __KERBCRED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\derivecred\derivecred.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    derivecred.cxx

Abstract:

    derivecred

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "derivecred.hxx"

VOID
Usage(
    IN PCWSTR pszProgramName
    )
{
    DebugPrintf(SSPI_LOG, "Usage:  %ws -a <account name> -p <privilege to add> -P <privilege to remove> -r <system access to set> -s <server name>\n", pszProgramName);
    DebugPrintf(SSPI_LOG, "example system access are SECURITY_ACCESS_INTERACTIVE_LOGON and SECURITY_ACCESS_DENY_SERVICE_LOGON\n");
    exit(1);
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    CHAR Data[4094] = {0};
    MSV1_0_DERIVECRED_REQUEST* pDeriveCred = NULL;
    MSV1_0_DERIVECRED_RESPONSE* pDeriveCredResponse = NULL;
    LUID LogonId = {0x3e4, 0};
    ULONG Type = MSV1_0_DERIVECRED_TYPE_SHA1;
    ULONG cbDataToDerive = 8;
    ULONG cbRequest = 0;
    HANDLE hLsa = NULL;
    ULONG PackageId = 0;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;
    ULONG cbResponse = 0;

    for (INT i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (*(argv[i] + 1))
            {
            case 'l':
                LogonId.LowPart = wcstol(argv[++i], NULL, 0);
                break;
            case 'h':
                LogonId.HighPart = wcstol(argv[++i], NULL, 0);
                break;
            case 't':
                Type = wcstol(argv[++i], NULL, 0);
                break;
            case 'd':
                cbDataToDerive = wcstol(argv[++i], NULL, 0);
                break;
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    cbRequest = sizeof(MSV1_0_DERIVECRED_REQUEST) + cbDataToDerive;

    pDeriveCred = (MSV1_0_DERIVECRED_REQUEST*) new CHAR[cbRequest];

    Status DBGCHK = pDeriveCred ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pDeriveCred, cbRequest);
        pDeriveCred->LogonId = LogonId;
        pDeriveCred->MessageType = MsV1_0DeriveCredential;
        pDeriveCred->DeriveCredType = Type;
        pDeriveCred->DeriveCredInfoLength = cbDataToDerive;
        RtlCopyMemory(pDeriveCred->DeriveCredSubmitBuffer, Data, cbDataToDerive);

        Status DBGCHK = GetLsaHandleAndPackageId(
            MSV1_0_PACKAGE_NAME,
            &hLsa,
            &PackageId
            );
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("DeriveCred type %#x, LogonId %#x:%#x\n"),
            pDeriveCred->DeriveCredType, pDeriveCred->LogonId.HighPart, pDeriveCred->LogonId.LowPart);
        SspiPrintHex(SSPI_LOG, TEXT("Data to derive"), pDeriveCred->DeriveCredInfoLength, pDeriveCred->DeriveCredSubmitBuffer);
        Status DBGCHK = LsaCallAuthenticationPackage(
            hLsa,
            PackageId,
            pDeriveCred,
            cbRequest,
            (PVOID*) &pDeriveCredResponse,
            &cbResponse,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrintHex(SSPI_LOG, TEXT("Response"), pDeriveCredResponse->DeriveCredInfoLength, pDeriveCredResponse->DeriveCredReturnBuffer);
    }

    if (pDeriveCredResponse)
    {
        LsaFreeReturnBuffer(pDeriveCredResponse);
    }

    if (pDeriveCred)
    {
        delete [] pDeriveCred;
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\crack\crack.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    crack.cxx

Abstract:

    crack

Author:

    Larry Zhu (LZhu)                      June 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "crack.hxx"
#include <Ntdsapi.h>

#define SKIP_WSPACE(s)  while (*s && (*s == TEXT(' ') || *s == TEXT('\t'))) { ++s; }
#define SKIP_NON_WSPACE(s)  while (*s && (*s != TEXT(' ') && *s != TEXT('\t') &&  *s != TEXT('\n'))) { ++s; }

VOID
Usage(
    IN PCTSTR pszApp
    )
{
    SspiPrint(SSPI_ERROR,
        TEXT("\n\nUsage: %s [-domaincontroller <domaincontroller>] [-dnsdomainname <dnsdomainname>]\n")
        TEXT("[-flags <flags>] [-formatoffered <formatoffered>] [-formatdesired <formatdesired>]\n")
        TEXT("[-names <names>]\n\n"), pszApp);
    exit(-1);
}

VOID
ReleaseArgumentList(
    IN ULONG cArgs,
    IN PTSTR* ppszArgs
    )
{
    if (ppszArgs)
    {
        for (ULONG i = 0; i < cArgs; i++)
        {
            delete  [] ppszArgs[i];
        }
        delete [] ppszArgs;
    }
}

HRESULT
String2ArgumentList(
    IN PTSTR pszArgs,
    OUT ULONG* pcArgs,
    OUT PTSTR** pppszArgs
    )
{
    HRESULT hRetval = S_OK;

    ULONG cArgs = 0;
    PTSTR* ppszArgs = NULL;
    PTSTR pszSave = pszArgs;

    *pcArgs = NULL;
    *pppszArgs = NULL;

    while (pszArgs && *pszArgs)
    {
        SKIP_WSPACE(pszArgs);
        ++cArgs;

        // check for quote
        if (*pszArgs == TEXT('"'))
        {
            ++pszArgs;
            if (*pszArgs == TEXT('"'))
            {
                continue;
            }

            while (*pszArgs && (*pszArgs++ != TEXT('"'))) /* empty */;

            if (*(pszArgs - 1) != TEXT('"'))
            {
                hRetval = E_INVALIDARG;
                goto Cleanup;
            }
        }
        else
        {
            SKIP_NON_WSPACE(pszArgs);
        }
    }

    if (cArgs)
    {
        pszArgs = pszSave;
        ppszArgs = new PTSTR[cArgs];

        if (!ppszArgs)
        {
            hRetval = E_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(ppszArgs, cArgs * sizeof(PTSTR));

        ULONG argc = 0;

        while (pszArgs && *pszArgs)
        {
            SKIP_WSPACE(pszArgs);

            PTSTR pStart = pszArgs;
            PTSTR pEnd = pStart;

            // check for quote
            if (*pszArgs == TEXT('"'))
            {
                ++pszArgs;
                pStart = pszArgs;
                if (*pszArgs == TEXT('"'))
                {
                    pEnd = pStart;
                }
                else
                {
                    while (*pszArgs && (*pszArgs++ != TEXT('"'))) /* empty */;

                    pEnd = pszArgs - 1;
                }
            }
            else
            {
                SKIP_NON_WSPACE(pszArgs);
                pEnd = pszArgs;
            }

            TCHAR* pszItem = new TCHAR[pEnd - pStart + 1];

            if (!pszItem)
            {
                hRetval = E_OUTOFMEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                pszItem,
                pStart,
                (pEnd - pStart) * sizeof(TCHAR)
                );

            pszItem[pEnd - pStart] = TEXT('\0');

            ppszArgs[argc] = pszItem;

            ++argc;
        }
    }

    *pppszArgs = ppszArgs;
    *pcArgs = cArgs;

    cArgs = 0;
    ppszArgs = NULL;

Cleanup:

    ReleaseArgumentList(cArgs, ppszArgs);

    return hRetval;
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    THResult hRetval = S_OK;

    HANDLE hDs = NULL;

    PTSTR pszDomainController = NULL;
    PTSTR pszDnsDomainName = NULL;
    PTSTR pszNames = NULL;
    ULONG FormatOffered = DS_USER_PRINCIPAL_NAME;
    ULONG FormatDesired = DS_NT4_ACCOUNT_NAME;
    ULONG Flags = 0;
    ULONG cNames = 0;
    PTSTR* rpNames = NULL;
    DS_NAME_RESULT* pResult = NULL;

    ULONG mark = 1;

    argc--;

    while (argc)
    {
        if (!lstrcmp(argv[mark], TEXT("-domaincontroller")) && argc > 1)
        {
            argc--; mark++;
            pszDomainController = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-dnsdomainname")) && argc > 1)
        {
            argc--; mark++;
            pszDnsDomainName = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-formatoffered")) && argc > 1)
        {
            argc--; mark++;
            FormatOffered = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-formatdesired")) && argc > 1)
        {
            argc--; mark++;
            FormatDesired = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-flags")) && argc > 1)
        {
            argc--; mark++;
            Flags = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-names")) && argc > 1)
        {
            argc--; mark++;
            pszNames = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-h"))
                 || !lstrcmp(argv[mark], TEXT("-?"))
                 || !lstrcmp(argv[mark], TEXT("/h"))
                 || !lstrcmp(argv[mark], TEXT("/?")))
        {
            argc--; mark++;
            Usage(argv[0]);
        }
        else
        {
            Usage(argv[0]);
        }
    }

    hRetval DBGCHK = String2ArgumentList(pszNames, &cNames, &rpNames);

    SspiPrint(SSPI_LOG,
        TEXT("DC \"%s\", DnsDomain \"%s\", Flags %#x, Names \"%s\", FormatOffered %#x, FormatDesired %#x, cNames %#x\n"),
        pszDomainController,
        pszDnsDomainName,
        Flags,
        pszNames,
        FormatOffered,
        FormatDesired,
        cNames);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(
            DsBind(
                pszDomainController,
                pszDnsDomainName,
                &hDs
                ));
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(
            DsCrackNames(
                hDs,
                (DS_NAME_FLAGS) Flags,
                (DS_NAME_FORMAT) FormatOffered,
                (DS_NAME_FORMAT) FormatDesired,
                cNames ,
                rpNames,
                &pResult
                ));
    }


    if (pResult)
    {
        for (ULONG i = 0; i < pResult->cItems; i++)
        {
            SspiPrint(SSPI_LOG,
                TEXT("Item %#x: status %#x, domain \"%s\", name \"%s\"\n"),
                i,
                pResult->rItems[i].status,
                pResult->rItems[i].pDomain,
                pResult->rItems[i].pName);
        }
        DsFreeNameResult(pResult);
    }

    if (hDs)
    {
        DsUnBind(&hDs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\krb5p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krb5p.h
//
// Contents:    pointer type definitions for ASN.1 stub types
//
//
// History:     8-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERB5P_H__
#define __KERB5P_H__

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_EXT_ERROR *PKERB_EXT_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;
typedef KERB_PA_FOR_USER *PKERB_PA_FOR_USER;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;

#define KERB_KDC_OPTIONS_reserved             0x80000000
#define KERB_KDC_OPTIONS_forwardable          0x40000000
#define KERB_KDC_OPTIONS_forwarded            0x20000000
#define KERB_KDC_OPTIONS_proxiable            0x10000000
#define KERB_KDC_OPTIONS_proxy                0x08000000
#define KERB_KDC_OPTIONS_postdated            0x02000000
#define KERB_KDC_OPTIONS_allow_postdate       0x04000000
#define KERB_KDC_OPTIONS_unused7              0x01000000
#define KERB_KDC_OPTIONS_renewable            0x00800000
#define KERB_KDC_OPTIONS_unused9              0x00400000
#define KERB_KDC_OPTIONS_name_canonicalize    0x00010000
#define KERB_KDC_OPTIONS_cname_in_addl_tkt    0x00020000
#define KERB_KDC_OPTIONS_cname_in_pa_data     0x00040000
#define KERB_KDC_OPTIONS_renewable_ok         0x00000010
#define KERB_KDC_OPTIONS_enc_tkt_in_skey      0x00000008
#define KERB_KDC_OPTIONS_renew                0x00000002
#define KERB_KDC_OPTIONS_validate             0x00000001

#define KERB_AP_OPTIONS_reserved              0x80000000
#define KERB_AP_OPTIONS_use_session_key       0x40000000
#define KERB_AP_OPTIONS_mutual_required       0x20000000
#define KERB_AP_OPTIONS_reserved1             0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number              sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until               renew_until
#define KERB_CRED_INFO_renew_until                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until               renew_until
#define KERB_KDC_REQUEST_BODY_server_name               server_name
#define KERB_KDC_REQUEST_preauth_data                   preauth_data
#define KERB_AUTHENTICATOR_sequence_number              sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                  subkey
#define KERB_TGT_REQUEST_server_name                    server_name
#define KERB_ERROR_client_name                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                   usec
#define KERB_KDC_REQUEST_BODY_client_name               client_name
#define KERB_KDC_REPLY_preauth_data                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                   usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime              starttime
#define KERB_CRED_INFO_starttime                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                 starttime
#define KERB_ENCRYPTED_PRIV_sequence_number             sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                 starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses

#endif // __KERB5P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\krbprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    krbprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let Kerberos compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\pacimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        pacimp.h
//
// Contents:    imports for pac.idl
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <lsass.h>
#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntmsv1_0.h>
#include <logonmsv.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\exterr.h ===
//+-----------------------------------------------------------------------
//
// File:        exterr.h
//
// Contents:    Kerberos extended error structures and macros
//
// History:     23-Feb-2000    Todds   Created
//
//
//------------------------------------------------------------------------

#ifndef __EXTERR_H__
#define __EXTERR_H__

//
// This macro is universally used for extended errors
//
#define EXT_ERROR_SUCCESS(s)             (NT_SUCCESS(s.status))

//
// defines for flags member of KERB_EXT_ERROR structure
//
#define  EXT_ERROR_CLIENT_INFO      0x1   // this is an extended error for use by client

//
// is there a useful NTSTATUS embedded in returned error?
//
#define  EXT_CLIENT_INFO_PRESENT(p)    ((NULL != p) && (p->flags & EXT_ERROR_CLIENT_INFO) && !NT_SUCCESS(p->status))

#endif // __EXTERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\enumusers\enumusers.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    enumusers.cxx

Abstract:

    enumusers

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "enumusers.hxx"

NTSTATUS
GetUserInfo(
    IN LUID* pLogonId,
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    OUT VOID** ppUserInfoResponse,
    OUT DWORD* pUserInfoResponseLength
    )
/*++

Routine Description:

    This function asks the MS V1.0 Authentication Package for information on
    a specific user.

Arguments:

    pLogonId - Supplies the logon id of the user we want information about.

    ppUserInfoResponse - Returns a pointer to a structure of information about
        the user.  This memory is allocated by the authentication package
        and must be freed with LsaFreeReturnBuffer when done with it.

    pUserInfoResponseLength - Returns the length of the returned information
        in number of bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    TNtStatus ntstatus;
    NTSTATUS AuthPackageStatus = STATUS_UNSUCCESSFUL;

    MSV1_0_GETUSERINFO_REQUEST UserInfoRequest;

    DebugPrintf(SSPI_LOG, "Calling MsV1_0GetUserInfo\n");

    //
    // Ask authentication package for user information.
    //
    UserInfoRequest.MessageType = MsV1_0GetUserInfo;
    RtlCopyLuid(&UserInfoRequest.LogonId, pLogonId);

    ntstatus DBGCHK = LsaCallAuthenticationPackage(
        LsaHandle,
        AuthPackageId,
        &UserInfoRequest,
        sizeof(MSV1_0_GETUSERINFO_REQUEST),
        ppUserInfoResponse,
        pUserInfoResponseLength,
        &AuthPackageStatus
        );

    if (ntstatus == STATUS_SUCCESS)
    {
        ntstatus DBGCHK = AuthPackageStatus;
    }

    return ntstatus;
}

NTSTATUS
EnumUsers(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    OUT VOID** ppEnumUsersResponse
    )
/*++

Routine Description:

    This function asks the MS V1.0 Authentication Package to list all users
    who are physically logged on to the local computer.

Arguments:

    ppEnumUsersResponse - Returns a pointer to a list of user logon ids.  This
        memory is allocated by the authentication package and must be freed
        with LsaFreeReturnBuffer when done with it.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    TNtStatus Status;
    NTSTATUS AuthPackageStatus;

    MSV1_0_ENUMUSERS_REQUEST EnumUsersRequest;
    ULONG EnumUsersResponseLength;

    DebugPrintf(SSPI_LOG, "Calling MsV1_0EnumerateUsers\n");

    //
    // Ask authentication package to enumerate users who are physically
    // logged to the local machine.
    //
    EnumUsersRequest.MessageType = MsV1_0EnumerateUsers;

    Status DBGCHK = LsaCallAuthenticationPackage(
        LsaHandle,
        AuthPackageId,
        &EnumUsersRequest,
        sizeof(MSV1_0_ENUMUSERS_REQUEST),
        ppEnumUsersResponse,
        &EnumUsersResponseLength,
        &AuthPackageStatus
        );

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = AuthPackageStatus;
    }

    return Status;
}

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;

    HANDLE LogonHandle = NULL;
    ULONG PackageId = -1;

    MSV1_0_ENUMUSERS_RESPONSE* pEnumUsersResponse = NULL;
    DWORD UserInfoResponseLength = 0;

    DebugPrintf(SSPI_LOG, "Testing MsV1_0EnumerateUsers and MsV1_0GetUserInfo\n");

    AUTO_LOG_OPEN(TEXT("enumusers.exe"));

    Status DBGCHK = GetLsaHandleAndPackageId(
        NTLMSP_NAME_A,
        &LogonHandle,
        &PackageId
        );
    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = EnumUsers(LogonHandle, PackageId, (VOID**) &pEnumUsersResponse);
    }

    for (ULONG i = 0; NT_SUCCESS(Status) && i < pEnumUsersResponse->NumberOfLoggedOnUsers; i++)
    {
        MSV1_0_GETUSERINFO_RESPONSE* pUserInfoResponse = NULL;

        DebugPrintf(SSPI_LOG, "*************** %#x **********\n", i);
        Status DBGCHK = GetUserInfo(
            &pEnumUsersResponse->LogonIds[i],
            LogonHandle,
            PackageId,
            (VOID**) &pUserInfoResponse,
            &UserInfoResponseLength
            );

        if (NT_SUCCESS(Status))
        {   UNICODE_STRING UserSidString = {0};
            Status DBGCHK = RtlConvertSidToUnicodeString( &UserSidString, pUserInfoResponse->UserSid, TRUE );

            if (NT_SUCCESS(Status) )
            {
                DebugPrintf(SSPI_LOG, "Sid: %wZ\n", &UserSidString);
                DebugPrintf(SSPI_LOG, "UserName: %wZ\n", &pUserInfoResponse->UserName);
                DebugPrintf(SSPI_LOG, "LogonDomainName: %wZ\n", &pUserInfoResponse->LogonDomainName);
                DebugPrintf(SSPI_LOG, "LogonServer: %wZ\n", &pUserInfoResponse->LogonServer);
                DebugPrintf(SSPI_LOG, "LogonType: %#x : %s\n", pUserInfoResponse->LogonType, LogonType2Str(pUserInfoResponse->LogonType));
            }
            RtlFreeUnicodeString(&UserSidString);
        }

        if (pUserInfoResponse)
        {
            LsaFreeReturnBuffer(pUserInfoResponse);
        }
    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (pEnumUsersResponse)
    {
        LsaFreeReturnBuffer(pEnumUsersResponse);
    }

    AUTO_LOG_CLOSE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\kerberr.h ===
//+-----------------------------------------------------------------------
//
// File:        kerberr.h
//
// Contents:    Security Status codes
//
// History:     <Whenever>  RichardW    Created secscode.h
//              26-May-93   RichardW    fixed dependency & conflict with scode.h
//              02-Jun-93   WadeR   Added FAILED and SUCCEDED macros
//              14-Jun-93   WadeR   Added "proper" kerberos errors, changed
//                                  to hex.
//              07-Jul-93   WadeR   Removed FAILED and SUCCEEDED macros
//              20-Sep-93   WadeR   Moved to $(SECURITY)\h\kerberr.h
//
//------------------------------------------------------------------------

#ifndef __KERBERR_H__
#define __KERBERR_H__




// Component specific errors:

//
// KERBERR is a kerberos-specific error. Make it a pointer to a structure
// to make sure we only return the correct error.
//

typedef LONG KERBERR, *PKERBERR;

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCEPTED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KERBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)
//
// These are local definitions that should not be sent over the network
//

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )
#define KDC_ERR_NOT_RUNNING           ((KERBERR) 0x80000002 )
#define KDC_ERR_NO_RESPONSE           ((KERBERR) 0x80000003 ) // used when we don't get a certain level of "goodness" in our response.
#define KRB_ERR_NAME_TOO_LONG         ((KERBERR) 0x80000004 )

#endif // __KERBERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct TYPED_DATA_s * PTYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_EXT_ERROR)

typedef struct TYPED_DATA_s {
    PTYPED_DATA next;
    KERB_TYPED_DATA value;
} TYPED_DATA_Element, *TYPED_DATA;
#define TYPED_DATA_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(TYPED_DATA_Element)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//
#include <wmidata.h>

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\inc\kerbcomm.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbcomm.h
//
// Contents:    prototypes for common kerberos routines
//
//
// History:     15-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef _KERBCOMM_H_
#define _KERBCOMM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
#include <rpc.h>
#include <rpcndr.h>
#ifndef WIN32_CHICAGO
#include <ntsam.h>
#endif // WIN32_CHICAGO
#include <windef.h>
#include <stdio.h>
#include <limits.h>
#include <winbase.h>
#include <winsock2.h>
#include <krb5.h>
#include <cryptdll.h>
#include <align.h>
#ifdef __cplusplus
}
#endif // _cplusplus
#include <krb5p.h>
#include <kerberr.h>
#include <exterr.h>
#include <kerbcred.h>
#ifndef WIN32_CHICAGO
// SECURITY_WIN32 is already defined
#include <security.h>
#endif // WIN32_CHICAGO

//////////////////////////////////////////////////////////////////////////
//
// Definitions (for lack of a better place)
//
//////////////////////////////////////////////////////////////////////////

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response


//
// Pre-auth data types

#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_FOR_USER            129 /* target client identity */

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE       64
#define KERB_AUTH_SESAME        65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data
#define KERB_AUTH_PROXY_ANNOTATION      139     // entry id for a proxy logon annotation string

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC
#define KERB_AUTH_DATA_TOKEN_RESTRICTIONS 141   // entry id for token restrictions
//
// Transited realm compression types:
//

#define DOMAIN_X500_COMPRESS            1

//
// Certificate types for PKINIT
//

#define KERB_CERTIFICATE_TYPE_X509      1
#define KERB_CERTIFICATE_TYPE_PGP       2

//
// Signature & seal types used by PKINIT
//

#define KERB_PKINIT_SIGNATURE_ALG               CALG_MD5
#define KERB_PKINIT_EXPORT_SEAL_OID             szOID_RSA_RC2CBC
#define KERB_PKINIT_EXPORT_SEAL_ETYPE           KERB_ETYPE_RC2_CBC_ENV
#define KERB_PKINIT_SEAL_ETYPE                  KERB_ETYPE_DES_EDE3_CBC_ENV
#define KERB_PKINIT_SEAL_OID                    szOID_RSA_DES_EDE3_CBC
#define KERB_PKINIT_SIGNATURE_OID               szOID_RSA_MD5RSA
#define KERB_PKINIT_KDC_CERT_TYPE               szOID_PKIX_KP_SERVER_AUTH

#ifdef szOID_KP_SMARTCARD_LOGON
#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_KP_SMARTCARD_LOGON
#else
#define KERB_PKINIT_CLIENT_CERT_TYPE "1.3.6.1.4.1.311.20.2.2"
#endif


//
// Transport information
//

#define KERB_KDC_PORT                   88
#define KERB_KPASSWD_PORT               464

//
// KDC service principal
//

#define KDC_PRINCIPAL_NAME              L"krbtgt"
#define KDC_PRINCIPAL_NAME_A            "krbtgt"
#define KERB_HOST_STRING_A              "host"
#define KERB_HOST_STRING                L"host"
#define KERB_KPASSWD_FIRST_NAME         L"kadmin"
#define KERB_KPASSWD_SECOND_NAME        L"changepw"


//
// address types - corresponds to GSS types
//
#define KERB_ADDRTYPE_UNSPEC           0x0
#define KERB_ADDRTYPE_LOCAL            0x1
#define KERB_ADDRTYPE_INET             0x2
#define KERB_ADDRTYPE_IMPLINK          0x3
#define KERB_ADDRTYPE_PUP              0x4
#define KERB_ADDRTYPE_CHAOS            0x5
#define KERB_ADDRTYPE_NS               0x6
#define KERB_ADDRTYPE_NBS              0x7
#define KERB_ADDRTYPE_ECMA             0x8
#define KERB_ADDRTYPE_DATAKIT          0x9
#define KERB_ADDRTYPE_CCITT            0xA
#define KERB_ADDRTYPE_SNA              0xB
#define KERB_ADDRTYPE_DECnet           0xC
#define KERB_ADDRTYPE_DLI              0xD
#define KERB_ADDRTYPE_LAT              0xE
#define KERB_ADDRTYPE_HYLINK           0xF
#define KERB_ADDRTYPE_APPLETALK        0x10
#define KERB_ADDRTYPE_BSC              0x11
#define KERB_ADDRTYPE_DSS              0x12
#define KERB_ADDRTYPE_OSI              0x13
#define KERB_ADDRTYPE_NETBIOS          0x14
#define KERB_ADDRTYPE_X25              0x15


//
// Misc. Flags
//

#define KERB_EXPORT_KEY_FLAG 0x20000000
#define KERB_NO_KEY_VERSION 0

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

//
// Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2

//
// Types for extended errors
//

#define TD_MUST_USE_USER2USER                 -128
#define TD_EXTENDED_ERROR                     -129

//
// PKINIT method errors
//
#define KERB_PKINIT_UNSPEC_ERROR        0       // not specified
#define KERB_PKINIT_BAD_PUBLIC_KEY      1       // cannot verify public key
#define KERB_PKINIT_INVALID_CERT        2       // invalid certificate
#define KERB_PKINIT_REVOKED_CERT        3       // revoked certificate
#define KERB_PKINIT_INVALID_KDC_NAME    4       // invalid KDC name
#define KERB_PKINIT_CLIENT_NAME_MISMATCH 5      // client name mismatch

//
// HACK for MAX_UNICODE_STRING, as KerbDuplicateString & others add a NULL
// terminator when doing the duplication
//
#define KERB_MAX_UNICODE_STRING (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

#define KERBFLAG_LOGON                  0x1
#define KERBFLAG_INTERACTIVE            0x2

//
// KDC-Kerberos interaction
//

#define KDC_START_EVENT                 L"\\Security\\KdcStartEvent"

#define KERB_MAX_CRYPTO_SYSTEMS 20
#define KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF 100

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5
#define KERB_DEFAULT_PREAUTH_TYPE       0

//
// Registry parameters
//

#define KERB_PATH                       L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos"
#define KERB_PARAMETER_PATH             L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"
#define KERB_PARAMETER_SKEWTIME         L"SkewTime"
#define KERB_PARAMETER_MAX_UDP_PACKET   L"MaxPacketSize"
#define KERB_PARAMETER_START_TIME       L"StartupTime"
#define KERB_PARAMETER_KDC_CALL_TIMEOUT L"KdcWaitTime"
#define KERB_PARAMETER_KDC_BACKOFF_TIME L"KdcBackoffTime"
#define KERB_PARAMETER_KDC_SEND_RETRIES L"KdcSendRetries"
#define KERB_PARAMETER_USE_SID_CACHE    L"UseSidCache"
#define KERB_PARAMETER_LOG_LEVEL        L"LogLevel"
#define KERB_PARAMETER_DEFAULT_ETYPE    L"DefaultEncryptionType"
#define KERB_PARAMETER_FAR_KDC_TIMEOUT  L"FarKdcTimeout"
#define KERB_PARAMETER_NEAR_KDC_TIMEOUT L"NearKdcTimeout"
#define KERB_PARAMETER_STRONG_ENC_DG    L"StronglyEncryptDatagram"
#define KERB_PARAMETER_MAX_REFERRAL_COUNT L"MaxReferralCount"
#define KERB_PARAMETER_MAX_TOKEN_SIZE     L"MaxTokenSize"
#define KERB_PARAMETER_SPN_CACHE_TIMEOUT  L"SpnCacheTimeout"
#define KERB_PARAMETER_S4UCACHE_TIMEOUT   L"S4UCacheTimeout"
#define KERB_PARAMETER_S4UTICKET_LIFETIME L"S4UTicketLifetime"
#define KERB_PARAMETER_RETRY_PDC          L"RetryPDC"
#define KERB_PARAMETER_REQUEST_OPTIONS      L"RequestOptions"
#define KERB_PARAMETER_CLIENT_IP_ADDRESSES  L"ClientIpAddresses"
#define KERB_PARAMETER_TGT_RENEWAL_TIME     L"TgtRenewalTime"
#define KERB_PARAMETER_ALLOW_TGT_SESSION_KEY L"AllowTgtSessionKey"

//
// Registry defaults
//

#define KERB_DEFAULT_LOGLEVEL 0
#define KERB_DEFAULT_USE_STRONG_ENC_DG FALSE
#define KERB_DEFAULT_CLIENT_IP_ADDRESSES 0
#define KERB_DEFAULT_TGT_RENEWAL_TIME 600
#define KERB_DEFAULT_ALLOW_TGT_SESSION_KEY FALSE

//
// These are arbitrary sizes for max request and responses sizes for datagram
// requests.
//

#define KERB_MAX_KDC_RESPONSE_SIZE      4000
#define KERB_MAX_KDC_REQUEST_SIZE       4000
#define KERB_MAX_DATAGRAM_SIZE          2000
#define KERB_MAX_RETRIES                3
#define KERB_MAX_REFERRAL_COUNT         3

//
// timeout values in minutes
//

#define KERB_BINDING_FAR_DC_TIMEOUT     10
#define KERB_BINDING_NEAR_DC_TIMEOUT    30
#define KERB_SPN_CACHE_TIMEOUT          15
#define KERB_S4U_CACHE_TIMEOUT          15
#define KERB_S4U_QUERY_INTERVAL         15
#define KERB_S4U_TICKET_LIFETIME        15
#define KERB_DEFAULT_SKEWTIME           5

//
// Network service session timer callback frequency
//

#define KERB_SKLIST_CALLBACK_FEQ        10

//
// timeout values in seconds
//

#define KERB_KDC_CALL_TIMEOUT                   5
#define KERB_KDC_CALL_TIMEOUT_BACKOFF           5
#define KERB_KDC_WAIT_TIME      120

//
// BER encoding values
//

#define KERB_BER_APPLICATION_TAG 0xc0
#define KERB_BER_APPLICATION_MASK 0x1f
#define KERB_TGS_REQ_TAG 12
#define KERB_AS_REQ_TAG 10
#define KERB_TGS_REP_TAG 13
#define KERB_AS_REP_TAG 11
#define KERB_ERROR_TAG 30

//
// Common types
//

typedef struct _KERB_MESSAGE_BUFFER {
    ULONG BufferSize;
    PUCHAR Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;

//
// This is the maximum number of elements in a KERB_INTERNAL_NAME
//

#define MAX_NAME_ELEMENTS 20

typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;

//
// Prototypes
//
#ifdef __cplusplus

class CAuthenticatorList;

KERBERR NTAPI
KerbCheckTicket(
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  PKERB_ENCRYPTION_KEY pkKey,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  PTimeStamp SkewTime,
    IN  ULONG ServiceNameCount,
    IN  OPTIONAL PUNICODE_STRING ServiceName,
    IN  OPTIONAL PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PBOOLEAN UseSubKey
    );

extern "C" {

#endif // __cplusplus

KERBERR
KerbVerifyTicket(
    IN PKERB_TICKET PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL PUNICODE_STRING ServiceNames,
    IN OPTIONAL PUNICODE_STRING ServiceRealm,
    IN PKERB_ENCRYPTION_KEY ServiceKey,
    IN OPTIONAL PTimeStamp SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket
    );

BOOLEAN
KerbVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );


KERBERR NTAPI
KerbPackTicket(
    IN PKERB_TICKET InternalTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG KeyVersion,
    OUT PKERB_TICKET PackedTicket
    );

VOID
KerbPrintPrincipalName(
    IN ULONG DebugLevel,
    IN PKERB_PRINCIPAL_NAME Name
    );

NTSTATUS
KerbHashS4UPreauth(
    IN PKERB_PA_FOR_USER S4UPreauth,
    IN PKERB_ENCRYPTION_KEY Key,
    IN LONG ChecksumType,
    IN OUT PKERB_CHECKSUM CheckSum
    );

VOID KerbPrintKerbRealm(
    IN ULONG DebugLevel,
    IN PKERB_REALM Realm
    );

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    );

// VOID NTAPI
// KerbFreeTicket(
//     IN PKERB_ENCRYPTED_TICKET Ticket
//     );

#define KerbFreeTicket( Ticket ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TICKET_PDU, \
        (Ticket) \
        )

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET DestinationTicket,
    IN PKERB_TICKET SourceTicket
    );

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    );

VOID
CheckForOutsideStringToKey();

KERBERR NTAPI
KerbHashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbHashPasswordEx(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

BOOLEAN
KerbIsKeyExportable(
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PKERB_ENCRYPTION_KEY Key
    );

VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    );

PKERB_ENCRYPTION_KEY
KerbGetKeyFromList(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType
    );

PKERB_ENCRYPTION_KEY
KerbGetKeyFromListByIndex(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType,
    OUT PULONG pIndex
    );

KERBERR
KerbFindCommonCryptSystem(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN OPTIONAL PKERB_STORED_CREDENTIAL MorePasswords,
    OUT PKERB_ENCRYPTION_KEY * Key
    );

KERBERR NTAPI
KerbRandomFill(
    IN OUT PUCHAR pbBuffer,
    IN ULONG cbBuffer
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG SequenceNumber,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PTimeStamp ptsTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    );


DWORD
KerbCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    );


// VOID NTAPI
// KerbFreeAuthenticator(
//     IN PKERB_AUTHENTICATOR Authenticator
//     );

#define KerbFreeAuthenticator( Authenticator ) \
    KerbFreeData( \
        KERB_AUTHENTICATOR_PDU, \
        (Authenticator) \
        )

KERBERR NTAPI
KerbPackKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG KeyVersion,
    IN ULONG KeySalt,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    );

// KERBERR NTAPI
// KerbPackAsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackAsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_AS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackAsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackAsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeAsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeAsReply( Request) \
    KerbFreeData( \
        KERB_AS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackTgsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_TGS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackTgsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackTgsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeTgsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeTgsReply( Request) \
    KerbFreeData( \
        KERB_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// VOID
// KerbFreeKdcReplyBody(
//    IN PKERB_ENCRYPTED_KDC_REPLY Request
//    );

#define KerbFreeKdcReplyBody( Request) \
    KerbFreeData( \
        KERB_ENCRYPTED_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackAsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackAsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackAsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackAsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_AS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeAsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeAsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackTgsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackTgsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackTgsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_TGS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeTgsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeTgsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackEncryptedData(
//     IN PKERB_ENCRYPTED_DATA EncryptedData,
//     OUT PULONG DataSize,
//     OUT PUCHAR * MarshalledData
//     );

#define KerbPackEncryptedData( EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedData(
//     IN PUCHAR EncryptedData,
//    IN ULONG DataSize,
//    OUT PKERB_ENCRYPTED_DATA * Data
//    );

#define KerbUnpackEncryptedData( EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

// VOID
// KerbFreeEncryptedData(
//    IN PKERB_ENCRYPTED_DATA EncryptedData
//    );

#define KerbFreeEncryptedData( EncryptedData) \
    KerbFreeData( \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID) (EncryptedData) \
        )

#ifdef notdef
// KERBERR NTAPI
// KerbPackAuthData(
//     IN PKERB_AUTHORIZATION_DATA AuthData,
//     OUT PULONG AuthDataSize,
//     OUT PUCHAR * MarshalledAuthData
//     );

#define KerbPackAuthData( AuthData, AuthDataSize, MarshalledAuthData ) \
    KerbPackData( \
        (PVOID) (AuthData), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (AuthDataSize), \
        (MarshalledAuthData) \
        )

// KERBERR NTAPI
// KerbUnpackAuthData(
//     IN PUCHAR PackedAuthData,
//     IN ULONG AuthDataSize,
//     OUT PKERB_AUTHORIZATION_DATA * AuthData
//     );

#define KerbUnpackAuthData( PackedAuthData, AuthDataSize, AuthData ) \
    KerbUnpackData( \
        (PackedAuthData), \
        (AuthDataSize), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID *) (AuthData) \
        )

// VOID
// KerbFreeAuthData(
//    IN PKERB_AUTH_DATA AuthData
//    );

#define KerbFreeAuthData( AuthData) \
    KerbFreeData( \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID) (AuthData) \
        )

#endif // notdef

VOID
KerbFreeAuthData(
   IN PKERB_AUTHORIZATION_DATA AuthData
   );

// KERBERR NTAPI
// KerbPackApRequest(
//     IN PKERB_AP_REQUEST ApRequestMessage,
//     OUT PULONG ApRequestSize,
//     OUT PUCHAR * MarshalledApRequest
//     );

#define KerbPackApRequest( ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

// KERBERR NTAPI
// KerbUnpackApRequest(
//    IN PUCHAR ApRequestMessage,
//    IN ULONG ApRequestSize,
//    OUT PKERB_AP_REQUEST * ApRequest
//    );

#define KerbUnpackApRequest( ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

// VOID
// KerbFreeApRequest(
//    IN PKERB_AP_REQUEST Request
//    );

#define KerbFreeApRequest( Request) \
    KerbFreeData( \
        KERB_AP_REQUEST_PDU, \
        (PVOID) (Request) \
        )


// KERBERR NTAPI
// KerbPackApReply(
//     IN PKERB_AP_REPLY ApReplyMessage,
//     OUT PULONG ApReplySize,
//     OUT PUCHAR * MarshalledApReply
//     );

#define KerbPackApReply( ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

// KERBERR NTAPI
// KerbUnpackApReply(
//     IN PUCHAR ApReplyMessage,
//     IN ULONG ApReplySize,
//     OUT PKERB_AP_REPLY * ApReply
//    );

#define KerbUnpackApReply( ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

// VOID
// KerbFreeApReply(
//    IN PKERB_AP_REPLY Reply
//    );

#define KerbFreeApReply( Reply) \
    KerbFreeData( \
        KERB_AP_REPLY_PDU, \
        (PVOID) (Reply) \
        )

// KERBERR NTAPI
// KerbPackApReplyBody(
//     IN PKERB_ENCRYPTED_AP_REPLY ApReplyBodyMessage,
//     OUT PULONG ApReplyBodySize,
//     OUT PUCHAR * MarshalledApReplyBody
//    );

#define KerbPackApReplyBody( ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

// KERBERR NTAPI
// KerbUnpackApReplyBody(
//     IN PUCHAR ApReplyBodyMessage,
//     IN ULONG ApReplyBodySize,
//     OUT PKERB_ENCRYPTED_AP_REPLY * ApReplyBody
//    );

#define KerbUnpackApReplyBody( ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

// VOID
// KerbFreeApReplyBody(
//    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody
//    );

#define KerbFreeApReplyBody( ReplyBody) \
    KerbFreeData( \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID) (ReplyBody) \
        )

// KERBERR NTAPI
// KerbUnmarshallTicket(
//     IN PUCHAR TicketMessage,
//     IN ULONG TicketSize,
//     OUT PKERB_ENCRYPTED_TICKET * Ticket
//     );

#define KerbUnmarshallTicket( TicketMessage, TicketSize, Ticket ) \
    KerbUnpackData( \
        (TicketMessage), \
        (TicketSize), \
        KERB_ENCRYPTED_TICKET_PDU, \
        (PVOID *) (Ticket) \
        )

// KERBERR NTAPI
// KerbPackEncryptedCred(
//     IN PKERB_ENCRYPTED_CRED EncryptedCred,
//     OUT PULONG CredSize,
//     OUT PUCHAR * MarshalledCred
//     );

#define KerbPackEncryptedCred( EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedCred(
//     IN PUCHAR EncryptedCred,
//    IN ULONG CredSize,
//    OUT PKERB_ENCRYPTED_CRED * Cred
//    );

#define KerbUnpackEncryptedCred( EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

// VOID
// KerbFreeEncryptedCred(
//    IN PKERB_ENCRYPTED_CRED EncryptedCred
//    );

#define KerbFreeEncryptedCred( EncryptedCred) \
    KerbFreeData( \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID) (EncryptedCred) \
        )

// KERBERR NTAPI
// KerbPackKerbCred(
//     IN PKERB_CRED KerbCred,
//     OUT PULONG KerbCredSize,
//     OUT PUCHAR * MarshalledKerbCred
//     );

#define KerbPackKerbCred( KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

// KERBERR NTAPI
// KerbUnpackKerbCred(
//    IN PUCHAR MarshalledKerbCred,
//    IN ULONG KerbCredSize,
//    OUT PKERB_CRED * KerbCred
//    );

#define KerbUnpackKerbCred( MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

// VOID
// KerbFreeKerbCred(
//    IN PKERB_CRED KerbCred
//    );

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

// KERBERR NTAPI
// KerbPackKerbError(
//     IN PKERB_ERROR ErrorMessage,
//     OUT PULONG ErrorSize,
//     OUT PUCHAR * MarshalledError
//     );

#define KerbPackKerbError( ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

// KERBERR NTAPI
// KerbUnpackKerbError(
//     IN PUCHAR ErrorMessage,
//     IN ULONG ErrorSize,
//     OUT PKERB_ERROR * Error
//     );

#define KerbUnpackKerbError( ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

// VOID
// KerbFreeKerbError(
//    IN PKERB_ERROR Request
//    );

#define KerbFreeKerbError( Error ) \
    KerbFreeData( \
        KERB_ERROR_PDU, \
        (PVOID) (Error) \
        )

// KERBERR NTAPI
// KerbPackEncryptedTime(
//     IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTimeMessage,
//     OUT PULONG EncryptedTimeSize,
//     OUT PUCHAR * MarshalledEncryptedTime
//     );

#define KerbPackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedTime(
//     IN PUCHAR EncryptedTimeMessage,
//     IN ULONG EncryptedTimeSize,
//     OUT PKERB_ENCRYPTED_TIMESTAMP * EncryptedTime
//     );

#define KerbUnpackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

// VOID
// KerbFreeEncryptedTime(
//    IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTime
//    );

#define KerbFreeEncryptedTime( EncryptedTime ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID) (EncryptedTime) \
        )

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptData(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

#ifndef WIN32_CHICAGO
KERBERR NTAPI
KerbCheckSumVerify(
    IN PUCHAR pbBuffer,
    IN ULONG cbBuffer,
    OUT PKERB_CHECKSUM pcsCheck
    );

KERBERR NTAPI
KerbCheckSum(
    PUCHAR pbData,
    ULONG cbData,
    PCHECKSUM_FUNCTION pcsfSum,
    PKERB_CHECKSUM pcsCheckSum
    );
#endif // WIN32_CHICAGO

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    );

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
KerbConvertStringToSid(
    IN PUNICODE_STRING String,
    OUT PSID * Sid
    );

NTSTATUS
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    );

KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    );

KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

LPWSTR
KerbBuildNullTerminatedString(
    IN PUNICODE_STRING String
    );

VOID
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    );



KERBERR
KerbCompareUnicodeRealmToKerbRealm(
    IN PKERB_REALM KerbRealm,
    IN PUNICODE_STRING UnicodeRealm,
    OUT PBOOLEAN Result
    );




VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    );

#ifndef WIN32_CHICAGO
KERBERR
KerbCheckLogonRestrictions(
    IN PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PTimeStamp LogoffTime,
    OUT PNTSTATUS RetStatus
    );

#include <pacndr.h>
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    );

NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    );



#define KERB_TOKEN_RESTRICTION_DISABLE_GROUPS   1
#define KERB_TOKEN_RESTRICTION_RESTRICT_SIDS    2
#define KERB_TOKEN_RESTRICTION_DELETE_PRIVS     4


#endif // WIN32_CHICAGO

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String,
    IN ULONG NameType
    );

KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_PRINCIPAL_NAME SourcePrincipalName
    );

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN KERB_REALM RealmName
    );

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    );

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN PUNICODE_STRING String
    );

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PKERB_REALM Realm
    );

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    );

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    );

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2
    );

BOOLEAN
KerbCompareStringToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    );

KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount,
    IN BOOL bIncludeOldEtypes
    );

KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    );

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    );

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    );

PKERB_AUTHORIZATION_DATA
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    );

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    );

KERBERR
KerbGetPacFromAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT PKERB_AUTHORIZATION_DATA * Pac
    );

KERBERR
KerbBuildFullServiceName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING FullServiceName
    );

KERBERR
KerbBuildUnicodeSpn(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    );


KERBERR
KerbBuildEmailName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING EmailName
    );

KERBERR
KerbBuildFullServiceKdcName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    IN OPTIONAL PUNICODE_STRING UnicodeRealm
    );

KERBERR
KerbBuildKeySalt(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    );

KERBERR
KerbBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    OUT PUNICODE_STRING Salt
    );

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR * ErrorMessage
    );

KERBERR
KerbBuildExtendedError(
   IN PKERB_EXT_ERROR  pExtendedError,
   OUT PULONG          ExtErrorSize,
   OUT PBYTE*          ExtErrorData
   );

#ifdef __cplusplus
}   // extern "C"
#endif

//
// Socket functions
//

NTSTATUS
KerbInitializeSockets(
    IN WORD VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    );

VOID
KerbCleanupSockets(
    );

NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    );

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    );

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    );

KERBERR
KerbDuplicateHostAddresses(
    OUT PKERB_HOST_ADDRESSES * DestAddresses,
    IN PKERB_HOST_ADDRESSES SourceAddresses
    );

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN PUNICODE_STRING String
    );

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PSTRING KerbString
    );

BOOLEAN
KerbMbStringToUnicodeString(
      PUNICODE_STRING     pDest,
      char *              pszString
      );

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME * KdcName
    );

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName
    );

BOOLEAN
KerbEqualKdcNames(
    IN PKERB_INTERNAL_NAME Name1,
    IN PKERB_INTERNAL_NAME Name2
    );

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName,
    OUT PBOOLEAN Result
    );

VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN PKERB_INTERNAL_NAME Name
    );

#define KERB_INTERNAL_NAME_SIZE(NameCount) (sizeof(KERB_INTERNAL_NAME) + ((NameCount) - ANYSIZE_ARRAY) * sizeof(UNICODE_STRING))

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN PUNICODE_STRING String
    );

NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    );

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING Realm
    );

NTSTATUS
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN PKERB_INTERNAL_NAME Source
    );

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

ULONG
KerbConvertFlagsToUlong(
    IN PVOID Flags
    );

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    );

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );

#ifdef __WINCRYPT_H__
KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    );

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    );

NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    );

NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString,
    IN BOOLEAN NullTerminate
    );

#if DBG

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN FILETIME *pFileTime
    );
#endif

#endif //  __WINCRYPT_H__

#endif // _KERBCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\cache\cache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Injectee

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lmcons.h>
#include <ntsamp.h>
#include <md5.h>
#include <hmac.h>
#include <rc4.h>

#include "cache.hxx"

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    BOOL bRet;
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_PROCESS_ATTACH:
        break;

    default:
        break;
    }

    bRet = DllMainDefaultHandler(hModule, dwReason, dwReserved);

    DebugPrintf(SSPI_LOG, "DllMain leaving %#x\n", bRet);

    return bRet;
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    DWORD dwErr;

    dwErr = RunItDefaultHandler(cbParameters, pvParameters);

    DebugPrintf(SSPI_LOG, "RunIt leaving %#x\n", dwErr);

    return dwErr;

}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    CHAR* pNlpCacheEncryptionKey = NULL;
    LIST_ENTRY* pNlpActiveCtes = NULL;

    SspiPrintHex(SSPI_LOG, TEXT("Start Parameters"), cbParameters, pvParameters);

    if (cbParameters == sizeof(ULONG_PTR) + sizeof(ULONG_PTR))
    {
        TNtStatus Status;

        pNlpCacheEncryptionKey = * ((CHAR**) pvParameters);
        pNlpActiveCtes = * ((LIST_ENTRY**) ((CHAR*)pvParameters + sizeof(ULONG_PTR)));

        Status DBGCHK = EnumerateNlpCacheEntries(pNlpCacheEncryptionKey, pNlpActiveCtes);

        if (NT_SUCCESS(Status))
        {
            SspiPrint(SSPI_LOG, TEXT("Operation succeeded\n"));
        }
        else
        {
            SspiPrint(SSPI_LOG, TEXT("Operation failed\n"));
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        SspiPrint(SSPI_LOG, TEXT("Start received invalid parameter\n"));
    }

    return dwErr;
}

int
Init(
    IN ULONG argc,
    IN PCSTR argv[],
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    CHAR* pNlpCacheEncryptionKey = NULL;
    LIST_ENTRY* pNlpActiveCtes = NULL;

    *pcbParameters = 0;
    *ppvParameters = NULL;

    if (argc == 2)
    {
        DebugPrintf(SSPI_LOG, "argv[0] %s, argv[1] %s\n", argv[0], argv[1]);

        pNlpCacheEncryptionKey = (CHAR*) (ULONG_PTR) strtol(argv[0], NULL, 0);
        pNlpActiveCtes = (LIST_ENTRY*) (ULONG_PTR) strtol(argv[1], NULL, 0);

        SspiPrint(SSPI_LOG, TEXT("msv1_0!NlpCacheEncryptionKey %p, addr of msv1_0!NlpActiveCtes %p\n"), pNlpCacheEncryptionKey, pNlpActiveCtes);

        memcpy(Parameters, &pNlpCacheEncryptionKey, sizeof(ULONG_PTR));
        cbParameter = sizeof(ULONG_PTR);

        memcpy(Parameters + cbParameter, &pNlpActiveCtes, sizeof(ULONG_PTR));
        cbParameter += sizeof(ULONG_PTR);
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<value of msv1_0!NlpCacheEncryptionKey> <addr of msv1_0!NlpActiveCtes>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER;
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return dwErr;
}

NTSTATUS
NlpMakeCacheEntryName(
    IN ULONG EntryIndex,
    OUT UNICODE_STRING* pName
    )
{
    TNtStatus NtStatus = STATUS_SUCCESS;

    UNICODE_STRING TmpString = {0};

    WCHAR TmpStringBuffer[256] = {0};

    if (EntryIndex > NLP_MAX_LOGON_CACHE_COUNT)
    {
        DebugPrintf(SSPI_ERROR, "NlpMakeCacheEntryName EntryIndex %#x exceeds NLP_MAX_LOGON_CACHE_COUNT %#x\n", EntryIndex, NLP_MAX_LOGON_CACHE_COUNT);
        NtStatus DBGCHK = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus))
    {
        pName->Length = 0;
        NtStatus DBGCHK = RtlAppendUnicodeToString(pName, L"NL$");
    }

    if (NT_SUCCESS(NtStatus))
    {
        TmpString.MaximumLength = 16;
        TmpString.Length = 0;
        TmpString.Buffer = TmpStringBuffer;
        NtStatus DBGCHK = RtlIntegerToUnicodeString(
            (EntryIndex + 1), // make 1 based index
            10, // Base 10
            &TmpString
            );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus DBGCHK = RtlAppendUnicodeStringToString(pName, &TmpString);
    }

    return NtStatus;
}

NTSTATUS
NlpOpenCache(
    OUT HANDLE* phNlpCache
    )
{
    TNtStatus NtStatus;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;

    ObjectName.Length = ObjectName.MaximumLength = CACHE_NAME_SIZE;
    ObjectName.Buffer = CACHE_NAME;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ObjectName,
        OBJ_CASE_INSENSITIVE,
        0,      // RootDirectory
        NULL    // default is reasonable from SYSTEM context
        );

    NtStatus DBGCHK = NtOpenKey(
        phNlpCache,
        KEY_READ,
        &ObjectAttributes
        );

    return NtStatus;
}

NTSTATUS
NlpReadCacheEntryByIndex(
    IN ULONG Index,
    OUT PLOGON_CACHE_ENTRY* ppCacheEntry,
    OUT PULONG pcbEntrySize
    )
{
    TNtStatus NtStatus = STATUS_SUCCESS;

    UNICODE_STRING ValueName = {0};
    HANDLE hNlpCache = NULL;

    WCHAR szNameBuffer[256] = {0};

    ULONG cbRequiredSize = 0;

    PKEY_VALUE_FULL_INFORMATION pRegInfo = NULL;

    PLOGON_CACHE_ENTRY pRCacheEntry = NULL;   // CacheEntry in registry buffer

    BYTE FastBuffer[4098] = {0};
    PBYTE pSlowBuffer = NULL;

    ValueName.Buffer = szNameBuffer;
    ValueName.MaximumLength = sizeof(szNameBuffer) - sizeof(WCHAR);
    ValueName.Length = 0;
    NtStatus DBGCHK = NlpMakeCacheEntryName(Index, &ValueName);

    if (NT_SUCCESS(NtStatus))
    {
        SspiPrint(SSPI_LOG, TEXT("NlpReadCacheEntryByIndex %#x, ValueName %wZ\n"), Index, &ValueName);

        NtStatus DBGCHK = NlpOpenCache(&hNlpCache);
    }

    if (NT_SUCCESS(NtStatus))
    {
        pRegInfo = (PKEY_VALUE_FULL_INFORMATION)FastBuffer;
        cbRequiredSize = sizeof(FastBuffer);

        DBGCFG2(NtStatus, STATUS_BUFFER_TOO_SMALL, STATUS_BUFFER_OVERFLOW);

        //
        // perform first query to find out how much buffer to allocate
        //

        NtStatus DBGCHK = NtQueryValueKey(
            hNlpCache,
            &ValueName,
            KeyValueFullInformation,
            pRegInfo,
            cbRequiredSize,
            &cbRequiredSize
            );

        if ( ( ((NTSTATUS) NtStatus) == STATUS_BUFFER_TOO_SMALL )
             || ( ((NTSTATUS) NtStatus) == STATUS_BUFFER_OVERFLOW ) )
        {

            SspiPrint(SSPI_WARN, TEXT("NlpReadCacheEntryByIndex NtQueryValueKey requires %#x bytes\n"), cbRequiredSize);

            //
            // allocate buffer then do query again, this time receiving data
            //

            pSlowBuffer = new BYTE[cbRequiredSize];
            NtStatus DBGCHK = pSlowBuffer ? STATUS_SUCCESS : STATUS_NO_MEMORY;

            if (NT_SUCCESS(NtStatus))
            {
                pRegInfo = (PKEY_VALUE_FULL_INFORMATION)pSlowBuffer;

                NtStatus DBGCHK = NtQueryValueKey(
                    hNlpCache,
                    &ValueName,
                    KeyValueFullInformation,
                    pRegInfo,
                    cbRequiredSize,
                    &cbRequiredSize
                    );
            }
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        if (pRegInfo->DataLength == 0 )
        {
            NtStatus DBGCHK = STATUS_INTERNAL_DB_CORRUPTION;
            *ppCacheEntry = NULL;
            *pcbEntrySize = 0;
        }
        else
        {
            pRCacheEntry = (PLOGON_CACHE_ENTRY) ((PCHAR)pRegInfo + pRegInfo->DataOffset);
            *pcbEntrySize = pRegInfo->DataLength;

            (*ppCacheEntry) = (PLOGON_CACHE_ENTRY) new CHAR[*pcbEntrySize];

            NtStatus DBGCHK = *ppCacheEntry ? STATUS_SUCCESS : STATUS_NO_MEMORY;

            if (NT_SUCCESS(NtStatus))
            {
                RtlCopyMemory((*ppCacheEntry), pRCacheEntry, (*pcbEntrySize) );
            }
        }
    }

    if (pSlowBuffer)
    {
        delete [] pSlowBuffer;
    }

    if (hNlpCache)
    {
        NtClose(hNlpCache);
    }

    return NtStatus;
}

NTSTATUS
NlpDecryptCacheEntry(
    IN CHAR NlpCacheEncryptionKey[NLP_CACHE_ENCRYPTION_KEY_LEN],
    IN ULONG EntrySize,
    IN OUT PLOGON_CACHE_ENTRY pCacheEntry
    )
{
    TNtStatus NtStatus = STATUS_SUCCESS;

    HMACMD5_CTX hmacCtx;
    RC4_KEYSTRUCT rc4key;
    CHAR DerivedKey[ MD5DIGESTLEN ];

    CHAR MAC[ MD5DIGESTLEN ];

    PBYTE pbData;
    ULONG cbData;

    // DebugPrintHex(SSPI_LOG, "NlpDecryptCacheEntry NlpCacheEncryptionKey",
    //    NLP_CACHE_ENCRYPTION_KEY_LEN, NlpCacheEncryptionKey);

    if ( pCacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 )
    {
        NtStatus DBGCHK = STATUS_UNSUCCESSFUL;
    }

    //
    // derive encryption key from global machine LSA secret, and random
    // cache entry key.
    //

    if (NT_SUCCESS(NtStatus))
    {
        HMACMD5Init(&hmacCtx, (PUCHAR) NlpCacheEncryptionKey, NLP_CACHE_ENCRYPTION_KEY_LEN);
        HMACMD5Update(&hmacCtx, (PUCHAR) pCacheEntry->RandomKey, sizeof(pCacheEntry->RandomKey));
        HMACMD5Final(&hmacCtx, (PUCHAR) DerivedKey);

        //
        // begin decrypting at the cachepasswords field.
        //

        pbData = (PBYTE)&(pCacheEntry->CachePasswords);

        //
        // data length is EntrySize - header up to CachePasswords.
        //

        cbData = EntrySize - (ULONG)( pbData - (PBYTE)pCacheEntry );

        //
        // now decrypt it...
        //

        rc4_key( &rc4key, sizeof(DerivedKey), (PUCHAR) DerivedKey );
        rc4( &rc4key, cbData, pbData );

        //
        // compute MAC on decrypted data for integrity checking.
        //

        HMACMD5Init(&hmacCtx, (PUCHAR) DerivedKey, sizeof(DerivedKey));
        HMACMD5Update(&hmacCtx, pbData, cbData);
        HMACMD5Final(&hmacCtx, (PUCHAR) MAC);

        RtlZeroMemory( DerivedKey, sizeof(DerivedKey) );

        //
        // verify MAC.
        //

        if (memcmp( MAC, pCacheEntry->MAC, sizeof(MAC) ) != 0)
        {
            NtStatus DBGCHK = STATUS_LOGON_FAILURE;
        }
    }

    return NtStatus;
}

NTSTATUS
EnumerateNlpCacheEntries(
    IN CHAR NlpCacheEncryptionKey[NLP_CACHE_ENCRYPTION_KEY_LEN],
    IN LIST_ENTRY* pNlpActiveCtes
    )
{
    TNtStatus NtStatus = STATUS_SUCCESS;
    ULONG i = 0;

    SspiPrint(SSPI_LOG, TEXT("EnumerateNlpCacheEntries NlpCacheEncryptionKey %p, NlpActiveCtes %p\n"),
        NlpCacheEncryptionKey, pNlpActiveCtes);

    for (PNLP_CTE pNext = (PNLP_CTE) pNlpActiveCtes->Flink;
         NT_SUCCESS(NtStatus) && (pNext != (PNLP_CTE)pNlpActiveCtes);
         pNext = (PNLP_CTE)pNext->Link.Flink)
    {
        LOGON_CACHE_ENTRY* pCacheEntry = NULL;
        ULONG cbEntrySize = 0;
        UNICODE_STRING CachedUser = {0};
        UNICODE_STRING CachedDomain = {0};
        UNICODE_STRING CachedDnsDomain = {0};
        UNICODE_STRING CachedUpn = {0};

        SspiPrint(SSPI_LOG, TEXT("*************#%#x) _NLP_CTE %p, Index %#x*******\n"), i++, pNext, pNext->Index);

        NtStatus DBGCHK = NlpReadCacheEntryByIndex(
             pNext->Index,
             &pCacheEntry,
             &cbEntrySize
             );

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus DBGCHK = (pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B) ? STATUS_SUCCESS : STATUS_INTERNAL_ERROR;
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus DBGCHK = NlpDecryptCacheEntry(
                NlpCacheEncryptionKey,
                cbEntrySize,
                pCacheEntry
                );
        }

        if (NT_SUCCESS(NtStatus))
        {
            CachedUser.Length = CachedUser.MaximumLength = pCacheEntry->UserNameLength;

            NtStatus DBGCHK = (pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0) ? STATUS_SUCCESS : STATUS_INTERNAL_ERROR;
        }

        if (NT_SUCCESS(NtStatus))
        {
            CachedUser.Buffer = (PWSTR) ((PBYTE) pCacheEntry + sizeof(LOGON_CACHE_ENTRY));

            CachedDomain.Length = CachedDomain.MaximumLength = pCacheEntry->DomainNameLength;
            CachedDomain.Buffer = (PWSTR)((LPBYTE)CachedUser.Buffer
                + ROUND_UP_COUNT(pCacheEntry->UserNameLength, sizeof(ULONG)));

            CachedDnsDomain.Length = CachedDnsDomain.MaximumLength = pCacheEntry->DnsDomainNameLength;
            CachedDnsDomain.Buffer = (PWSTR)((PBYTE)CachedDomain.Buffer
                + ROUND_UP_COUNT(pCacheEntry->DomainNameLength, sizeof(ULONG)));

            CachedUpn.Length = CachedUpn.MaximumLength = pCacheEntry->UpnLength;
            CachedUpn.Buffer = (PWSTR)((PBYTE)CachedDnsDomain.Buffer
                + ROUND_UP_COUNT(pCacheEntry->DnsDomainNameLength, sizeof(ULONG)));

            SspiPrint(SSPI_LOG,
                TEXT("domain \"%wZ\", dns domain \"%wZ\", upn \"%wZ\", user \"%wZ\", flags %#x, ")
                TEXT("UserId %#x, PrimaryGroupId %#x, GroupCount %#x, LogonPackage %#x\n"),
                &CachedDomain, &CachedDnsDomain, &CachedUpn, &CachedUser, pCacheEntry->CacheFlags,
                pCacheEntry->UserId, pCacheEntry->PrimaryGroupId, pCacheEntry->GroupCount, pCacheEntry->LogonPackage);
        }

        if (pCacheEntry)
        {
            delete [] pCacheEntry;
        }
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\cachelogon\cachelogon.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cachelogon.cxx

Abstract:

    cachelogon

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <logonmsv.h>
#include <tchar.h>

#include "cachelogon.hxx"

EXTERN_C
NTSTATUS NTAPI
LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    BOOL bRet;
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_PROCESS_ATTACH:
        break;

    default:
        break;
    }

    bRet = DllMainDefaultHandler(hModule, dwReason, dwReserved);

    DebugPrintf(SSPI_LOG, "DllMain leaving %#x\n", bRet);

    return bRet;
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    DWORD dwErr;

    dwErr = RunItDefaultHandler(cbParameters, pvParameters);

    DebugPrintf(SSPI_LOG, "RunIt leaving %#x\n", dwErr);

    return dwErr;

}

NTSTATUS
CacheLogonInformation(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pDomainName,
    IN OPTIONAL PUNICODE_STRING pPassword,
    IN OPTIONAL PUNICODE_STRING pDnsDomainName,
    IN OPTIONAL PUNICODE_STRING pUpn,
    IN ULONG ParameterControl,
    IN BOOLEAN bIsMitLogon,
    IN ULONG CacheRequestFlags,
    IN OPTIONAL PNETLOGON_VALIDATION_SAM_INFO3 pValidationInfo,
    IN OPTIONAL PVOID pSupplementalCreds,
    IN OPTIONAL ULONG cbSupplementalCredSize
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    ULONG cbCacheRequest = 0;
    HANDLE hLsa = NULL;
    ULONG PackageId = 0;

    MSV1_0_CACHE_LOGON_REQUEST* pCacheRequest = NULL;
    NETLOGON_VALIDATION_SAM_INFO4* pValidationInfoToUse = NULL;
    NETLOGON_INTERACTIVE_INFO* pMsvLogonInfo = NULL;

    PVOID pOutputBuffer = NULL;
    ULONG cbOutputBufferSize = NULL;

    PVOID pSupplementalMitCreds = NULL;
    ULONG cbSupplementalMitCredSize = 0;
    WCHAR szWorkStation[256] = {0};
    UNICODE_STRING Workstation = {0, sizeof(szWorkStation), szWorkStation};
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));

    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    WCHAR* pWhere = NULL;
    ULONG cchWorkstation = COUNTOF(szWorkStation);

    (VOID) GetComputerNameW(szWorkStation, &cchWorkstation);

    Workstation.Length = (USHORT) cchWorkstation * sizeof(WCHAR);

    SspiPrint(SSPI_LOG,
        TEXT("CacheLogonInformation workstation %wZ, User %wZ, Domain %wZ, Password %wZ, DnsDomain %wZ, Upn %wZ, ")
        TEXT("ParameterControl %#x, bIsMitLogon %#x, CacheRequestFlags %#x, pValidationInfo %p, ")
        TEXT("pSupplementalCreds %p, cbSupplementalCredSize %#x\n"),
        &Workstation, pUserName, pDomainName, pPassword, pDnsDomainName, pUpn,
        ParameterControl, bIsMitLogon, CacheRequestFlags, pValidationInfo,
        pSupplementalCreds, cbSupplementalCredSize);

    cbCacheRequest = ROUND_UP_COUNT(sizeof(NETLOGON_INTERACTIVE_INFO), sizeof(ULONG_PTR))
        + ROUND_UP_COUNT(pDomainName->Length + sizeof(WCHAR), sizeof(ULONG_PTR))
        + ROUND_UP_COUNT(Workstation.Length + sizeof(WCHAR), sizeof(ULONG_PTR))
        + ROUND_UP_COUNT(pUserName->Length + sizeof(WCHAR), sizeof(ULONG_PTR)) + 10 * sizeof(ULONG_PTR);

    if (bIsMitLogon)
    {
       cbSupplementalMitCredSize = (2 * ROUND_UP_COUNT(sizeof(UNICODE_STRING), sizeof(ULONG_PTR)))
           + ROUND_UP_COUNT(pUserName->Length + sizeof(WCHAR), sizeof(ULONG_PTR))
           + ROUND_UP_COUNT(pDomainName->Length + sizeof(WCHAR), sizeof(ULONG_PTR));
       cbCacheRequest = cbSupplementalMitCredSize;
    }
    else
    {
        cbCacheRequest += ROUND_UP_COUNT(cbSupplementalCredSize, sizeof(ULONG_PTR));
    }

    cbCacheRequest += ROUND_UP_COUNT(sizeof(NETLOGON_VALIDATION_SAM_INFO4), sizeof(ULONG_PTR));
    if (pDnsDomainName)
    {
        cbCacheRequest += ROUND_UP_COUNT(pDnsDomainName->Length + sizeof(WCHAR), sizeof(ULONG_PTR));
    }

    pCacheRequest = (MSV1_0_CACHE_LOGON_REQUEST*) new CHAR[cbCacheRequest];
    Status DBGCHK = pCacheRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pCacheRequest, cbCacheRequest);
        pCacheRequest->MessageType = MsV1_0CacheLogon;

        pMsvLogonInfo = (NETLOGON_INTERACTIVE_INFO*) ROUND_UP_POINTER(((PCHAR)pCacheRequest) + ROUND_UP_COUNT(sizeof(*pCacheRequest), sizeof(ULONG_PTR)), sizeof(ULONG_PTR));

        pCacheRequest->LogonInformation = pMsvLogonInfo;

        pWhere = (WCHAR*) (((PCHAR) pMsvLogonInfo) + ROUND_UP_COUNT(sizeof(*pMsvLogonInfo), sizeof(ULONG_PTR)));

        pMsvLogonInfo->Identity.ParameterControl = ParameterControl;

        PackUnicodeStringAsUnicodeStringZ(pDomainName, &pWhere, &pMsvLogonInfo->Identity.LogonDomainName);
        PackUnicodeStringAsUnicodeStringZ(pUserName, &pWhere, &pMsvLogonInfo->Identity.UserName);
        PackUnicodeStringAsUnicodeStringZ(&Workstation, &pWhere, &pMsvLogonInfo->Identity.Workstation);

        if (pPassword)
        {
            Status DBGCHK = RtlCalculateNtOwfPassword(
                pPassword,
                &pMsvLogonInfo->NtOwfPassword
                );
        }
    }

    //
    // If this was a logon to an MIT realm that we know about,
    // then add the MIT username (upn?) & realm to the supplemental data
    //

    if (NT_SUCCESS(Status))
    {
        if (bIsMitLogon)
        {
           SspiPrint(SSPI_LOG, TEXT("Using MIT caching\n"));

           pCacheRequest->RequestFlags = MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON | CacheRequestFlags;

           pSupplementalMitCreds = ROUND_UP_POINTER(pWhere, sizeof(ULONG_PTR));

           pWhere += /* 2 * */ ROUND_UP_COUNT(sizeof(UNICODE_STRING), sizeof(ULONG_PTR));

           PackUnicodeStringAsUnicodeStringZ(pUserName, &pWhere, (UNICODE_STRING*) pSupplementalMitCreds);
           PackUnicodeStringAsUnicodeStringZ(pDomainName, &pWhere, ((UNICODE_STRING*) pSupplementalMitCreds) + 1);

           pCacheRequest->SupplementalCacheData = pSupplementalMitCreds;
           pCacheRequest->SupplementalCacheDataLength = cbSupplementalMitCredSize;
        }
        else
        {
           pCacheRequest->RequestFlags = CacheRequestFlags;

           pCacheRequest->SupplementalCacheData = ROUND_UP_POINTER(pWhere, sizeof(ULONG_PTR));
           pCacheRequest->SupplementalCacheDataLength = cbSupplementalCredSize;
           pWhere = (WCHAR*) ROUND_UP_POINTER(((CHAR*) pWhere) + sizeof(ULONG_PTR) + cbSupplementalCredSize, sizeof(ULONG_PTR));
           if (pSupplementalCreds)
           {
               RtlCopyMemory(pCacheRequest->SupplementalCacheData, pSupplementalCreds,  cbSupplementalCredSize);
           }
        }
    }

    if (NT_SUCCESS(Status))
    {
        pValidationInfoToUse = (NETLOGON_VALIDATION_SAM_INFO4*) ROUND_UP_POINTER(pWhere, sizeof(ULONG_PTR));

        pCacheRequest->ValidationInformation = pValidationInfoToUse;
        pCacheRequest->RequestFlags |= MSV1_0_CACHE_LOGON_REQUEST_INFO4;

        pWhere = (WCHAR*) ROUND_UP_POINTER(pValidationInfoToUse, sizeof(ULONG_PTR));

        if (pValidationInfo)
        {
            RtlCopyMemory(pValidationInfoToUse,
                          pValidationInfo,
                          sizeof(*pValidationInfo));
        }

        if (pDnsDomainName)
        {
            PackUnicodeStringAsUnicodeStringZ(pDnsDomainName, &pWhere, &pValidationInfoToUse->DnsLogonDomainName);
        }
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrintHex(SSPI_LOG, TEXT("CacheRequest"), cbCacheRequest, pCacheRequest);

        Status DBGCHK = GetLsaHandleAndPackageId(MSV1_0_PACKAGE_NAME, &hLsa, &PackageId);
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaICallPackage(
            &MsvPackageName,
            pCacheRequest,
            sizeof(MSV1_0_CACHE_LOGON_REQUEST), // cbCacheRequest,
            &pOutputBuffer,
            &cbOutputBufferSize,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (pCacheRequest)
    {
        delete [] pCacheRequest;
    }

    if (pOutputBuffer)
    {
        LsaFreeReturnBuffer(pOutputBuffer);
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }

    return Status;

}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    CHAR* pNlpCacheEncryptionKey = NULL;
    LIST_ENTRY** ppNlpActiveCtes = NULL;

    SspiPrintHex(SSPI_LOG, TEXT("Start Parameters"), cbParameters, pvParameters);

    if (cbParameters >= 3)
    {
        TNtStatus Status;

        UNICODE_STRING UserName = {0};
        UNICODE_STRING DomainName = {0};

        ULONG ParameterControl = RPC_C_AUTHN_GSS_KERBEROS;
        ULONG CacheRequestFlags = MSV1_0_CACHE_LOGON_DELETE_ENTRY;

        Status DBGCHK = CreateUnicodeStringFromAsciiz((CHAR*)pvParameters, &UserName);

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = CreateUnicodeStringFromAsciiz(((CHAR*) pvParameters) + strlen((CHAR*) pvParameters) + 1, &DomainName);
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = CacheLogonInformation(
                &UserName,
                &DomainName,
                NULL, // no password
                NULL, // no dns domain
                NULL, // no upn
                ParameterControl,
                FALSE, // not MIT
                CacheRequestFlags,  // flags
                NULL, // no validation info
                NULL, // no supplemental creds
                0  // sizeof supplemental cred is 0
                );

        }

        RtlFreeUnicodeString(&UserName);
        RtlFreeUnicodeString(&DomainName);

        if (NT_SUCCESS(Status))
        {
            SspiPrint(SSPI_LOG, TEXT("Operation succeeded\n"));
        }
        else
        {
            SspiPrint(SSPI_LOG, TEXT("Operation failed\n"));
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        SspiPrint(SSPI_LOG, TEXT("Start received invalid parameter\n"));
    }

    return dwErr;
}

#if 0

VOID
Usage(
    IN PCTSTR pszApp
    )
{
    SspiPrint(SSPI_ERROR,
        TEXT("\n\nUsage: %s -u<user> -d<domain> [-c<ParameterControl>] [-f<CacheRequestFlags>]\n\n"),
        pszApp);
    exit(-1);
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ClientRealm = {0};
    ULONG ParameterControl = RPC_C_AUTHN_GSS_KERBEROS;
    ULONG CacheRequestFlags = MSV1_0_CACHE_LOGON_DELETE_ENTRY;

    AUTO_LOG_OPEN(TEXT("cachelogon.exe"));

    for (INT i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == TEXT('-')) || (*argv[i] == TEXT('/')))
        {
            switch (argv[i][1])
            {
            case TEXT('u'):
                RtlInitUnicodeString(&ClientName, argv[i] + 2);
                break;

            case TEXT('d'):
                RtlInitUnicodeString(&ClientRealm, argv[i] + 2);
                break;

            case TEXT('c'):
                ParameterControl = wcstol(argv[i] + 2, NULL, 0);
                break;

            case TEXT('f'):
                CacheRequestFlags = wcstol(argv[i] + 2, NULL, 0);
                break;

            case TEXT('h'):
            case TEXT('?'):
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    Status DBGCHK = CacheLogonInformation(
        &ClientName,
        &ClientRealm,
        NULL, // no password
        NULL, // no dns domain
        NULL, // no upn
        ParameterControl,
        FALSE, // not MIT
        CacheRequestFlags,  // flags
        NULL, // no validation info
        NULL, // no supplemental creds
        0  // sizeof supplemental cred is 0
        );

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("Operation succeeded\n"));
    }
    else
    {
        SspiPrint(SSPI_ERROR, TEXT("Operation failed\n"));
    }

    AUTO_LOG_CLOSE();
}

#endif

Init(
    IN ULONG argc,
    IN PCSTR argv[],
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    CHAR* pNlpCacheEncryptionKey = NULL;
    LIST_ENTRY** ppNlpActiveCtes = NULL;

    *pcbParameters = 0;
    *ppvParameters = NULL;

    if (argc == 2)
    {
        DebugPrintf(SSPI_LOG, "argv[0] %s, argv[1] %s\n", argv[0], argv[1]);

        pNlpCacheEncryptionKey = (CHAR*) (ULONG_PTR) strtol(argv[0], NULL, 0);
        ppNlpActiveCtes = (LIST_ENTRY**) (ULONG_PTR) strtol(argv[1], NULL, 0);

        SspiPrint(SSPI_LOG, TEXT("msv1_0!NlpCacheEncryptionKey %p, addr of msv1_0!NlpActiveCtes %p\n"), pNlpCacheEncryptionKey, ppNlpActiveCtes);

        memcpy(Parameters, argv[0], strlen(argv[0]) + 1);
        cbParameter = strlen(argv[0]) + 1;

        memcpy(Parameters + cbParameter, argv[1], strlen(argv[1]) + 1);
        cbParameter += strlen(argv[1]) + 1;
        cbParameter++; // add a NULL
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<user name> <domain name>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER;
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\injectee\injectee.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    injectee.cxx

Abstract:

    Injectee

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "injectee.hxx"

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    return DllMainDefaultHandler(hModule, dwReason, dwReason);
}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    // do your stuff

    HMODULE hLib = LoadLibraryA((CHAR*) pvParameters);

    //
    //  Unload the dll
    //

    if (hLib)
    {
        DebugPrintf(SSPI_LOG, "Start() LoadLibraryA(%s)\n", pvParameters);

        while (FreeLibrary(hLib))
        {
        }
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "Start() LoadLibraryA(%s) failed with last error %#x\n", pvParameters, GetLastError());
    }

    return 0;
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{

    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    return RunItDefaultHandler(cbParameters, pvParameters);
}

int
Init(
    IN ULONG argc,
    IN PCSTR argv[],
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    DebugPrintf(SSPI_LOG, "Init: Hello world!\n");

    *pcbParameters = 0;
    *ppvParameters = NULL;

    if (argc == 1)
    {
        memcpy(Parameters + cbParameter, argv[0], strlen(argv[0]) + 1);
        cbParameter += strlen(argv[0]) + 1;
        cbParameter++; // add a NULL

        dwErr = ERROR_SUCCESS;
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<dll to be unloaded>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER; // will display usage
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    #if 0

    dwErr = ERROR_CONTINUE; // use the default Init handler in injecter

    #endif

Cleanup:

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\getdcname\getdcname.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    getdcname.cxx

Abstract:

    getdcname

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lm.h>
#include <dsgetdc.h>
#include "getdcname.hxx"

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    return DllMainDefaultHandler(hModule, dwReason, dwReason);
}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

EXTERN_C
NET_API_STATUS
DsrGetDcNameEx2(
    IN LPWSTR ComputerName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID* DomainGuid OPTIONAL,
    IN LPWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

VOID
PrintDcInfo(
    IN ULONG Level,
    IN PCTSTR pszBanner,
    IN PDOMAIN_CONTROLLER_INFO pDcInfo
    )
{
    SspiPrint(Level,
        TEXT("%s: ClientSiteName %s, DcSiteName %s, DnsForestName %s, ")
        TEXT("DomainControllerAddress %s, DomainControllerAddressType %#x, ")
        TEXT("DomainControllerName %s, DomainName %s, Flags %#x\n"), pszBanner,
        pDcInfo->ClientSiteName,
        pDcInfo->DcSiteName,
        pDcInfo->DnsForestName,
        pDcInfo->DomainControllerAddress,
        pDcInfo->DomainControllerAddressType,
        pDcInfo->DomainControllerName,
        pDcInfo->DomainName,
        pDcInfo->Flags
        );
    SspiPrintHex(Level, pszBanner, sizeof(GUID), &pDcInfo->DomainGuid);
}

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    // do your stuff

    THResult hRetval;

    UNICODE_STRING ServiceRealm = {0};
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    ULONG Flags = (DS_KDC_REQUIRED | DS_IP_REQUIRED);

    hRetval DBGCHK = CreateUnicodeStringFromAsciiz((PCSTR) pvParameters, &ServiceRealm);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(
            DsrGetDcNameEx2(
                NULL,
                NULL,  // no account name
                UF_ACCOUNT_TYPE_MASK, // any account type
                ServiceRealm.Buffer,
                NULL, // no domain GUID
                NULL, // no site GUID,
                Flags,
                &pDcInfo
                ));
    }

    if (SUCCEEDED(hRetval))
    {
        PrintDcInfo(SSPI_LOG, TEXT("DsrGetDcNameEx2 DcInfo"), pDcInfo);
        if (pDcInfo)
        {
            NetApiBufferFree(pDcInfo);
            pDcInfo = NULL;
        }
        hRetval DBGCHK = HResultFromWin32(
            DsGetDcNameW(
                NULL,
                ServiceRealm.Buffer,
                NULL,           // no domain GUID
                NULL,           // no site GUID,
                Flags,
                &pDcInfo
                ));
    }

    if (SUCCEEDED(hRetval))
    {
        PrintDcInfo(SSPI_LOG, TEXT("DsGetDcNameW DcInfo"), pDcInfo);
    }

    if (pDcInfo)
    {
        NetApiBufferFree(pDcInfo);
    }

    RtlFreeUnicodeString(&ServiceRealm);

    return HRESULT_CODE(hRetval);
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{

    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    return RunItDefaultHandler(cbParameters, pvParameters);
}

int
Init(
    IN ULONG argc,
    IN PCSTR argv[],
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    DebugPrintf(SSPI_LOG, "Init: Hello world!\n");

    *pcbParameters = 0;
    *ppvParameters = NULL;

    if (argc == 1)
    {
        memcpy(Parameters + cbParameter, argv[0], strlen(argv[0]) + 1);
        cbParameter += strlen(argv[0]) + 1;
        cbParameter++; // add a NULL

        dwErr = ERROR_SUCCESS;
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<domain name>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER; // will display usage
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    #if 0

    dwErr = ERROR_CONTINUE; // use the default Init handler in injecter

    #endif

Cleanup:

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\owfs\owfs.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    owfs.cxx

Abstract:

    Injectee

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lmcons.h>
#include "owfs.hxx"

EXTERN_C
NTSTATUS
LsaICallPackageEx(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

PLSA_SECPKG_FUNCTION_TABLE LsaFunctions = NULL;
CHAR MyPassword[PWLEN + 1] = {0};
PLSA_CALL_PACKAGE SavedCallPackage = NULL;

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        if (SavedCallPackage && LsaFunctions)
        {
            DebugPrintf(SSPI_LOG, "DllMain DLL_PROCESS_DETACH retoring CallPackage from %p to %p\n", LsaFunctions->CallPackage, SavedCallPackage);
            LsaFunctions->CallPackage = SavedCallPackage;
        }
        break;

    case DLL_PROCESS_ATTACH:
        break;

    default:
        break;
    }

    return DllMainDefaultHandler(hModule, dwReason, dwReserved);
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    return RunItDefaultHandler(cbParameters, pvParameters);
}

typedef struct _TTempResp {
    ENCRYPTED_CREDENTIALW returnCred;
    MSV1_0_SUPPLEMENTAL_CREDENTIAL suppCred;
} TTempResp;

extern "C"
NTSTATUS
CustomCallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    __try
    {
        if (KerbQuerySupplementalCredentialsMessage != *((ULONG*)ProtocolSubmitBuffer))
        {
            DebugPrintf(SSPI_LOG, "Calling LsaICallPackageEx\n");

            Status = LsaICallPackageEx(
                        AuthenticationPackage,
                        ProtocolSubmitBuffer,   // client buffer base is same as local buffer
                        ProtocolSubmitBuffer,
                        SubmitBufferLength,
                        ProtocolReturnBuffer,
                        ReturnBufferLength,
                        ProtocolStatus
                        );
        }
        else
        {
            KERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST* pQuerySuppCred = (KERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST*) ProtocolSubmitBuffer;
            KERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE* pQuerySuppCredResp = NULL;
            UNICODE_STRING KerberosPackageName = CONSTANT_UNICODE_STRING((MICROSOFT_KERBEROS_NAME_W));
            UNICODE_STRING MsvPackageNam = CONSTANT_UNICODE_STRING((NTLMSP_NAME));
            ULONG cbResponse = 0;
            NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;
            PCREDENTIALW pCred = NULL;
            MSV1_0_SUPPLEMENTAL_CREDENTIAL* pMsvSuppCred = NULL;
            TTempResp* pTempResp = NULL;

            DebugPrintf(SSPI_LOG, "Do it myself\n");

            ASSERT(LsaFunctions);

            pTempResp = (TTempResp*) LsaFunctions->AllocatePrivateHeap(sizeof(TTempResp));
            pQuerySuppCredResp = (KERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE*) pTempResp;

            if (!pQuerySuppCredResp)
            {
                Status = STATUS_NO_MEMORY;
            }

            if (NT_SUCCESS(Status))
            {
                ANSI_STRING Ansi;
                UNICODE_STRING NtPass = {0};
                RtlInitAnsiString(&Ansi, MyPassword);
                RtlAnsiStringToUnicodeString(&NtPass, &Ansi, TRUE);

                //
                // make a copy of cert cred
                //

                pQuerySuppCredResp->ReturnedCreds = *(ENCRYPTED_CREDENTIALW*)pQuerySuppCred->MarshalledCreds;

                //
                //  make a supplemental cred
                //

                pMsvSuppCred = &pTempResp->suppCred;
                pMsvSuppCred->Flags = CRED_FLAGS_PASSWORD_FOR_CERT | CRED_FLAGS_OWF_CRED_BLOB;
                pMsvSuppCred->Version = MSV1_0_CRED_VERSION;
                RtlCalculateNtOwfPassword(&NtPass, (PNT_OWF_PASSWORD) pMsvSuppCred->NtPassword);
                RtlCalculateLmOwfPassword(MyPassword, (PLM_OWF_PASSWORD) pMsvSuppCred->LmPassword);
                pMsvSuppCred->Flags = MSV1_0_CRED_NT_PRESENT | MSV1_0_CRED_LM_PRESENT;


                //
                // encrypt it
                //

                pQuerySuppCredResp->ReturnedCreds.Cred.CredentialBlob = (BYTE*) pMsvSuppCred;
                pQuerySuppCredResp->ReturnedCreds.Cred.CredentialBlobSize = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);
                LsaFunctions->LsaProtectMemory(
                    pQuerySuppCredResp->ReturnedCreds.Cred.CredentialBlob,
                    pQuerySuppCredResp->ReturnedCreds.Cred.CredentialBlobSize
                    );
                pQuerySuppCredResp->ReturnedCreds.ClearCredentialBlobSize = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);

                //
                // fill in the flags and types etc
                //

                pQuerySuppCredResp->ReturnedCreds.Cred.Flags = CRED_FLAGS_OWF_CRED_BLOB;
                pQuerySuppCredResp->ReturnedCreds.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
                pQuerySuppCredResp->ReturnedCreds.Cred.UserName = L"ntdev\\lzhu";

                if (0)
                {
                    NTSTATUS TempStatus;

                    TempStatus = LsaFunctions->CrediWrite(
                        &pQuerySuppCred->LogonId,
                        0,
                        &pQuerySuppCredResp->ReturnedCreds,
                        0
                        );

                    if (!NT_SUCCESS(TempStatus))
                    {
                        DebugPrintf(SSPI_ERROR, "CrediWrite failed with %#x\n", TempStatus);
                    }
                }

                *ProtocolStatus = STATUS_SUCCESS;
                *ProtocolReturnBuffer = pQuerySuppCredResp;
                *ReturnBufferLength = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL) + sizeof(ENCRYPTED_CREDENTIALW);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DebugPrintf(SSPI_ERROR, "CustomCallPackage hit exception %#x\n",  Status);
    }

    return Status;
}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DebugPrintf(SSPI_LOG, "Start: Hello world!\n");
    DebugPrintHex(SSPI_LOG, "Parameters", cbParameters, pvParameters);

    LsaFunctions = *((PLSA_SECPKG_FUNCTION_TABLE*)pvParameters);

    if (!LsaFunctions)
    {
        return -1;
    }

    if (cbParameters > sizeof(ULONG_PTR))
    {
        memcpy(MyPassword, ((UCHAR*)pvParameters) + sizeof(ULONG_PTR), cbParameters - sizeof(ULONG_PTR));

        if (strlen(MyPassword) == 1)
        {
            DebugPrintf(SSPI_WARN, "Start: trying to unload this dll repeately\n");
            dwErr = ERROR_NO_MORE_USER_HANDLES;
            goto Cleanup;
        }
    }

    //
    // Sanity Check
    //

    {
        VOID* pvMem = NULL;
        pvMem = LsaFunctions->AllocatePrivateHeap(sizeof(WCHAR));
        if (pvMem)
        {
            LsaFunctions->FreePrivateHeap(pvMem);
        }
    }

    if (!SavedCallPackage)
    {
        DebugPrintf(SSPI_LOG, "Start: saving CallPackage %p, CustomCallPackage %p\n", LsaFunctions->CallPackage, CustomCallPackage);
        SavedCallPackage = LsaFunctions->CallPackage;
        LsaFunctions->CallPackage = CustomCallPackage;
    }

    //
    // don't unload this dll
    //

    dwErr = ERROR_SERVER_HAS_OPEN_HANDLES;

Cleanup:

    return dwErr;
}

int
Init(
    IN ULONG argc,
    IN PCSTR* argv,
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    DebugPrintf(SSPI_LOG, "Init: Hello world!\n");

    *pcbParameters = 0;
    *ppvParameters = NULL;

    ULONG_PTR LsaFunctions = 0x745b5688;

    DebugPrintf(SSPI_LOG, "LsaFunctions is %p\n", LsaFunctions);

    memcpy(Parameters, &LsaFunctions, sizeof(LsaFunctions));
    cbParameter = sizeof(LsaFunctions);

    if (argc >= 1)
    {
        memcpy(Parameters + cbParameter, argv[0], strlen(argv[0]));
        cbParameter += strlen(argv[0]);
        cbParameter++; // add a NULL

        dwErr = ERROR_SUCCESS;
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<password>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER;
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\tktrenew\tktrenew.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tktrenew.cxx

Abstract:

    tktrenew

Author:

    Larry Zhu (LZhu)                      January 14, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tktrenew.hxx"

typedef
VOID
(* PFuncKerbTgtRenewalTrigger)(
    VOID * TaskHandle,
    VOID * TaskItem
    );

typedef
VOID
(* PFuncKerbTgtRenewalReaper)(
    VOID * TaskItem
    );

typedef
NTSTATUS
(* PFunKerbAddScavengerTask)(
    IN BOOLEAN Periodic,
    IN LONG Interval,
    IN ULONG Flags,
    IN PFuncKerbTgtRenewalTrigger pfnTrigger,
    IN PFuncKerbTgtRenewalReaper pfnDestroy,
    IN VOID * TaskItem,
    OUT OPTIONAL VOID ** TaskHandle
    );

typedef struct _KERBEROS_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} KERBEROS_LIST_ENTRY, *PKERBEROS_LIST_ENTRY;

typedef struct _KERB_TICKET_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    volatile LONG Linked;
    PKERB_INTERNAL_NAME ServiceName;
    PKERB_INTERNAL_NAME TargetName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    UNICODE_STRING ClientDomainName;
    PKERB_INTERNAL_NAME ClientName;
    PKERB_INTERNAL_NAME AltClientName;
    ULONG TicketFlags;
    ULONG CacheFlags;
    KERB_ENCRYPTION_KEY SessionKey;
    KERB_ENCRYPTION_KEY CredentialKey; // used for pkiint only.
    TimeStamp StartTime;
    TimeStamp EndTime;
    TimeStamp RenewUntil;
    KERB_TICKET Ticket;
    TimeStamp TimeSkew;
    void * ScavengerHandle;
#if DBG
    LIST_ENTRY GlobalListEntry;
#endif
} KERB_TICKET_CACHE_ENTRY, *PKERB_TICKET_CACHE_ENTRY;

BOOL
DllMain(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    return DllMainDefaultHandler(hModule, dwReason, dwReason);
}

#if 0

Return Values for Start():

    ERROR_NO_MORE_USER_HANDLES      unload repeatedly
    ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
    others                          unload once

#endif 0

int
Start(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    // do your stuff

    THResult hRetval;

    PFunKerbAddScavengerTask pFuncAddScan = NULL;
    PFuncKerbTgtRenewalTrigger pFuncTrig = NULL;
    PFuncKerbTgtRenewalReaper pFuncReaper = NULL;
    KERB_TICKET_CACHE_ENTRY* pCacheEntry = NULL;

    hRetval DBGCHK = (cbParameters == (4 * sizeof(long) + 1)) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        UCHAR* pParam = (UCHAR*) pvParameters;

        pFuncAddScan = (PFunKerbAddScavengerTask) (ULONG_PTR) *((ULONG*) pvParameters);
        pFuncTrig = (PFuncKerbTgtRenewalTrigger) (ULONG_PTR) *((ULONG*) (pParam + sizeof(long)) );
        pFuncReaper = (PFuncKerbTgtRenewalReaper) (ULONG_PTR) *((ULONG*) (pParam + 2 * sizeof(long)) );
        pCacheEntry = (KERB_TICKET_CACHE_ENTRY*) (ULONG_PTR) *((ULONG*) (pParam + 3 * sizeof(long)) );

        SspiPrint(SSPI_LOG, TEXT("pFuncAddScan %p, pFuncTrig %p, pFuncReaper %p, pCacheEntry %p\n"),
            pFuncAddScan, pFuncTrig, pFuncReaper, pCacheEntry);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncAddScan)(
            FALSE,
            0,
            0,
            pFuncTrig,
            pFuncReaper,
            pCacheEntry,
            &pCacheEntry->ScavengerHandle
            );
    }

    return HRESULT_CODE(hRetval);
}

int
RunIt(
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{

    //
    // RunItDefaultHandler calls Start() and adds try except
    //

    return RunItDefaultHandler(cbParameters, pvParameters);
}

int
Init(
    IN ULONG argc,
    IN PCSTR argv[],
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    ULONG cbParameter = 0;

    DebugPrintf(SSPI_LOG, "Init: Hello world!\n");

    *pcbParameters = 0;
    *ppvParameters = NULL;

    if (argc == 4)
    {
        for (ULONG i = 0; i < argc; i++)
        {
            ULONG temp = strtol(argv[i], NULL, 0);
            memcpy(Parameters + cbParameter, &temp, sizeof(long));
            cbParameter += sizeof(long);
        }
        cbParameter++; // add a NULL
        dwErr = ERROR_SUCCESS;
    }
    else // return "Usage" in ppvParameters, must be a NULL terminated string
    {
        strcpy(Parameters, "<KerbAddScavengerTask> <KerbTgtRenewalTrigger> <KerbTgtRenewalReaper> <CacheEntry>");
        cbParameter = strlen(Parameters) + 1;

        dwErr = ERROR_INVALID_PARAMETER; // will display usage
    }

    *ppvParameters = new CHAR[cbParameter];
    if (*ppvParameters)
    {
        *pcbParameters = cbParameter;
        memcpy(*ppvParameters, Parameters, *pcbParameters);
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    #if 0

    dwErr = ERROR_CONTINUE; // use the default Init handler in injecter

    #endif

Cleanup:

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\injection\injecter\injecter.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    injecter.cxx

Abstract:

    Injecter

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "injecter.hxx"

DWORD
AdjustDebugPriv(
    VOID
    )
{
    HANDLE hToken = NULL;
    DWORD dwErr = 0;
    TOKEN_PRIVILEGES newPrivs = {0};

    if (!OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES,
        &hToken))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    if (!LookupPrivilegeValue(
        NULL,
        SE_DEBUG_NAME,
        &newPrivs.Privileges[0].Luid
        ))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    newPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    newPrivs.PrivilegeCount = 1;

    if (!AdjustTokenPrivileges(
        hToken,
        FALSE,
        &newPrivs,
        0,
        NULL,
        NULL
        ))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return dwErr;
}

static DWORD
WorkerFunc(
    IN REMOTE_INFO* pInfo
    )
{
    HINSTANCE hDll = NULL;
    PFuncRunIt_t pFuncRunit = NULL;
    DWORD dwErr = -1;

    hDll = pInfo->pFuncLoadLibrary(pInfo->szDllName);

    if (hDll != NULL)
    {
        pFuncRunit = (PFuncRunIt_t) pInfo->pFuncGetProcAddress(
            hDll,
            pInfo->szProcName
            );

        if (pFuncRunit != NULL)
        {
            dwErr = pFuncRunit(
                pInfo->cbParameters,
                pInfo->Parameters
                );
        }
        else
        {
            dwErr = -3;
        }

        //
        // ERROR_NO_MORE_USER_HANDLES      unload repeatedly
        // ERROR_SERVER_HAS_OPEN_HANDLES   no unload at all
        // others                          unload once
        //

        if (ERROR_SERVER_HAS_OPEN_HANDLES != dwErr)
        {
            pInfo->pFuncFreeLibrary(hDll);

            //
            // unload abandoned dll
            //

            if (ERROR_NO_MORE_USER_HANDLES == dwErr)
            {
                while (pInfo->pFuncFreeLibrary(hDll))
                {
                    // repeat FreeLibrary unit it fails
                }
            }
        }
    }
    else
    {
        dwErr = -2;
    }

    return dwErr;
}

static VOID
MarkerFunc(
    VOID
    )
{
    // empty
}

DWORD
InjectDllToProcess(
    IN HANDLE hProc,
    IN PCSTR pszDllFileName,
    IN ULONG cbParameters,
    IN VOID* pvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    VOID* pRemoteAlloc = NULL;
    HANDLE hRemoteThread = NULL;
    HINSTANCE hKernel32 = NULL;
    HINSTANCE hDll = NULL;
    REMOTE_INFO* pRemInfo = NULL;
    ULONG cbRemInfo = 0;

    ULONG ulFuncSize = 0;
    ULONG ulBytesToAlloc = 0;
    CHAR szDllPath[MAX_PATH] = {0};
    SIZE_T dwBytesWritten = 0;
    DWORD dwIgnored;
    ULONG cbPadding = sizeof(ULONG);

    cbRemInfo = sizeof(REMOTE_INFO) + cbParameters | sizeof(VOID*); // add a safe zone
    pRemInfo  = (REMOTE_INFO*) new CHAR [cbRemInfo];

    if (!pRemInfo)
    {
        dwErr = ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(pRemInfo, cbRemInfo);
    pRemInfo->cbParameters = cbParameters;

    hKernel32 = LoadLibraryA("Kernel32");
    if (!hKernel32)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    pRemInfo->pFuncLoadLibrary = (PFuncLoadLib_t) GetProcAddress(hKernel32, "LoadLibraryA");
    if (!pRemInfo->pFuncLoadLibrary)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    pRemInfo->pFuncGetProcAddress = (PFuncGetProcAddr_t) GetProcAddress(hKernel32, "GetProcAddress");
    if (!pRemInfo->pFuncGetProcAddress)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    pRemInfo->pFuncFreeLibrary = (PFuncFreeLib_t) GetProcAddress(hKernel32, "FreeLibrary");
    if (!pRemInfo->pFuncFreeLibrary)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    if (0 == GetModuleFileNameA(NULL, szDllPath, sizeof (szDllPath)))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    strcpy(strrchr (szDllPath, '\\') + 1, pszDllFileName);
    strncpy(pRemInfo->szDllName, szDllPath, sizeof(pRemInfo->szDllName));

    strncpy(pRemInfo->szProcName, REMOTE_DLL_ENTRY, sizeof(pRemInfo->szProcName));

    pRemInfo->cbParameters = cbParameters;
    memcpy(&pRemInfo->Parameters, pvParameters, pRemInfo->cbParameters);

    ulFuncSize = (ULONG) ((ULONG_PTR) MarkerFunc - (ULONG_PTR) WorkerFunc);
    cbPadding = sizeof(void*) - ulFuncSize % sizeof(void*);
    ulBytesToAlloc = ulFuncSize + cbPadding + cbRemInfo;

    DebugPrintf(SSPI_LOG, "InjectDllToProcess dllname %s, ulBytesToAlloc %#x, cbRemInfo %#x\n",
                pszDllFileName, ulBytesToAlloc, cbRemInfo);
    DebugPrintf(SSPI_LOG, "pInfo->pFuncLoadLibrary %p\n", pRemInfo->pFuncLoadLibrary);
    DebugPrintf(SSPI_LOG, "pInfo->pFuncGetProcAddress %p\n", pRemInfo->pFuncGetProcAddress);
    DebugPrintf(SSPI_LOG, "pInfo->pFuncFreeLibrary %p\n", pRemInfo->pFuncFreeLibrary);

    DebugPrintf(SSPI_LOG, "pInfo->szDllName %s\n", pRemInfo->szDllName);

    DebugPrintf(SSPI_LOG, "pInfo->szProcName %s\n", pRemInfo->szProcName);

    DebugPrintf(SSPI_LOG, "pInfo->cbParameters %#x, pInfo->Parameters %p\n",
                pRemInfo->cbParameters, pRemInfo->Parameters);
    DebugPrintHex(SSPI_LOG, "Parameters", pRemInfo->cbParameters, pRemInfo->Parameters);

    pRemoteAlloc = VirtualAllocEx(
        hProc,
        NULL,
        ulBytesToAlloc,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (pRemoteAlloc == NULL)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    if (!WriteProcessMemory(
        hProc,
        pRemoteAlloc,
        (PVOID) WorkerFunc,
        ulFuncSize + cbPadding,
        &dwBytesWritten
        ))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    if (!WriteProcessMemory(
        hProc,
        ((UCHAR*) pRemoteAlloc) + ulFuncSize + cbPadding,
        pRemInfo,
        cbRemInfo,
        &dwBytesWritten
        ))
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    DebugPrintf(SSPI_LOG,
                "InjectDllToProcess pRemoteAlloc %p, pRemInfo %p\n",
                pRemoteAlloc, ((UCHAR*) pRemoteAlloc) + ulFuncSize + cbPadding);

    hRemoteThread = CreateRemoteThread(
        hProc,
        NULL,
        0,
        (PTHREAD_START_ROUTINE) pRemoteAlloc, // start address
        ((UCHAR*) pRemoteAlloc) + ulFuncSize + cbPadding, // parameter
        0,    // creation flags
        &dwIgnored
        );
    if (!hRemoteThread)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }

    //
    // run Init()
    //

    dwErr = WaitForSingleObject(hRemoteThread, INFINITE);

    if (dwErr != ERROR_SUCCESS)
    {
        DebugPrintf(SSPI_ERROR, "WaitForSingleObject failed with %#x\n", dwErr);
        dwErr = GetLastError();
    }

Cleanup:

    if (hKernel32)
    {
        FreeLibrary(hKernel32);
    }
    if (hRemoteThread)
    {
        CloseHandle(hRemoteThread);
    }

    if (pRemoteAlloc)
    {
        VirtualFreeEx(hProc, pRemoteAlloc, 0, MEM_RELEASE);
    }

    if (pRemInfo)
    {
        delete [] pRemInfo;
    }

    return dwErr;
}

DWORD
FindPid(
    IN PCSTR pszImageFileName
    )
{
    NTSTATUS Status ;

    PSYSTEM_PROCESS_INFORMATION pSystemInfo = NULL;
    PSYSTEM_PROCESS_INFORMATION pWalk = NULL;
    ANSI_STRING AnsiProcessName = {0};
    UNICODE_STRING ProcessName = {0};
    DWORD ulPid = 0;

    DebugPrintf(SSPI_LOG, "FindPid looking for %s\n", pszImageFileName);

    pSystemInfo = new SYSTEM_PROCESS_INFORMATION[1024];

    if ( !pSystemInfo )
    {
       DebugPrintf(SSPI_ERROR, "FindPid out of memory\n");
       return ERROR_SUCCESS;
    }

    Status = NtQuerySystemInformation(
             SystemProcessInformation,
             pSystemInfo,
             sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
             NULL
             );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugPrintf(SSPI_ERROR, "NtQuerySystemInformation failed with %#x\n", Status);
        return ERROR_SUCCESS;
    }

    RtlInitAnsiString(&AnsiProcessName, pszImageFileName);
    Status = RtlAnsiStringToUnicodeString(&ProcessName, &AnsiProcessName, TRUE);

    if ( !NT_SUCCESS( Status ) )
    {
        DebugPrintf(SSPI_ERROR, "RtlAnsiStringToUnicodeString failed with %#x\n", Status);
        return ERROR_SUCCESS;
    }

    pWalk = pSystemInfo ;

    while ( RtlCompareUnicodeString( &pWalk->ImageName, &ProcessName, TRUE ) != 0 )
    {
        if ( pWalk->NextEntryOffset == 0 )
        {
            pWalk = NULL ;
            break;
        }

        pWalk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) pWalk + pWalk->NextEntryOffset );
    }

    if ( !pWalk )
    {
        delete [] pSystemInfo;
        return ERROR_SUCCESS;
    }

    ulPid = PtrToUlong( pWalk->UniqueProcessId );

    delete [] pSystemInfo;

    return ulPid;
}

void
DisplayUsage(
    IN PCSTR pszApp,
    IN OPTIONAL PCSTR pszArgs
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s <injectee.dll> [-p<PID>|-n<process name>] %s\n\n\n", pszApp, pszArgs ? pszArgs : "");
}

DWORD
Init(
    IN PCSTR pszFileName,
    IN ULONG argc,
    IN PCSTR* argv,
    IN PCSTR pszDllName,
    IN PCSTR pszRunItProcName,
    IN PCSTR pszInitProcName,
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    HINSTANCE hDll = NULL;
    PFuncRunIt_t pFuncRunIt = NULL;
    PFuncInit_t pFuncInit = NULL;

    BOOLEAN bUseDefaulInitHandler = FALSE;

    hDll = LoadLibraryA(pszDllName);
    if (!hDll)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }
    pFuncRunIt = (PFuncRunIt_t) GetProcAddress(hDll, pszRunItProcName);
    if (!pFuncRunIt)
    {
        dwErr = GetLastError();
        goto Cleanup;
    }
    pFuncInit = (PFuncInit_t) GetProcAddress(hDll, pszInitProcName);
    if (!pFuncInit)
    {
        dwErr = GetLastError();
        DebugPrintf(SSPI_WARN, "Init failed to locate %s %#x\n", REMOTE_DLL_INIT, dwErr);
        if (dwErr == ERROR_PROC_NOT_FOUND)
        {
            bUseDefaulInitHandler = TRUE;
        }
        else
        {
            goto Cleanup;
        }
    }
    else
    {
        dwErr = pFuncInit(
            argc,
            argv,
            pcbParameters,
            ppvParameters
            );
        if (dwErr == ERROR_CONTINUE)
        {
            bUseDefaulInitHandler = TRUE;
        }
        else if (dwErr == ERROR_INVALID_PARAMETER)
        {
            DisplayUsage(pszFileName, (PSTR) (*ppvParameters));
            goto Cleanup;
        }
        else if (dwErr != ERROR_SUCCESS)
        {
            DebugPrintf(SSPI_ERROR, "Init faield with %#x\n", dwErr);
            goto Cleanup;
        }
    }

    if (bUseDefaulInitHandler)
    {
        dwErr = InitDefaultHandler(argc, argv, pcbParameters, ppvParameters);
    }
    else
    {
        dwErr = ERROR_SUCCESS;
    }

Cleanup:

    if (hDll)
    {
        FreeLibrary(hDll);
    }

    return dwErr;
}

int
InitDefaultHandler(
    IN ULONG argc,
    IN PCSTR* argv,
    OUT ULONG* pcbParameters,
    OUT VOID** ppvParameters
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    CHAR Parameters[REMOTE_PACKET_SIZE] = {0};
    ULONG cbBuffer = sizeof(Parameters);
    VOID* pvParameters = NULL;
    ULONG cbParameters = 0;

    DebugPrintf(SSPI_LOG, "InitDefaultHandler is used\n");

    *pcbParameters = 0;
    *ppvParameters = NULL;

    for (ULONG i = 0; i < (ULONG) argc; i++)
    {
         cbBuffer -= _snprintf(Parameters + sizeof(Parameters) - cbBuffer, cbBuffer, "%s", argv[i]);
         cbBuffer--; // add a null
    }

    cbBuffer--; // the last null of multi-sz string

    cbParameters = sizeof(Parameters) - cbBuffer;

    pvParameters = new CHAR[cbParameters];

    if (pvParameters)
    {
        memcpy(pvParameters, Parameters, cbParameters);

        *ppvParameters = pvParameters;
        pvParameters = NULL;

        *pcbParameters = cbParameters;
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    if (pvParameters)
    {
        delete [] pvParameters;
    }

    return dwErr;
}

int __cdecl
main(
    IN int argc,
    IN CHAR* argv[]
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwIgnored;
    HANDLE hLsassProc = NULL;
    HANDLE hReceiveThread = NULL;

    ULONG ulPid = 0;
    VOID* pvParameters = NULL;
    ULONG cbParamerter = 0;

    ULONG ulStart = 2;
    PSTR pszProcess = "lsass.exe";

    if (argc >= 3)
    {
        if ((argv[2][0] == '-') || (argv[2][0] == '/'))
        {
            if (argv[2][1] == 'n')
            {
                ulStart++;
                pszProcess = argv[2] + 2 * sizeof(char);
            }
            else if (argv[2][1] == 'p')
            {
                ulStart++;
                ulPid = strtol(argv[2] + 2 * sizeof(char), NULL, 0);
            }
        }
    }

    #if 0
    /* allow the user to override settings with command line switches */
    for (i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (tolower(*(argv[i]+1)))
            {
            case 'd':
                fEncode = 0;
                break;
            case 'e':
                fEncode = 1;
                break;
            case 'i':
                fFixedStyle = 0;
                break;
            case 'f':
                pszFileName = argv[i] + 2;
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }
    #endif 0

    if ((argc >= 2) && (ulPid == 0))
    {
        ulPid = FindPid(pszProcess);
    }

    if (!ulPid)
    {
        DisplayUsage(argv[0], NULL);
        DebugPrintf(SSPI_ERROR, "%s failed: pszProcess is \"%s\", ulPid is %#x\n", argv[0], pszProcess, ulPid);
        goto Cleanup;
    }

    DebugPrintf(SSPI_LOG, "%s is injecting %s with pid %#x(%d)\n", argv[0], pszProcess, ulPid, ulPid);

    dwErr = Init(argv[0],
                 argc - ulStart,
                 (PCSTR*) reinterpret_cast<PSTR*>(argv + ulStart),
                 argv[1],
                 REMOTE_DLL_ENTRY,
                 REMOTE_DLL_INIT,
                 &cbParamerter,
                 &pvParameters);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugPrintf(SSPI_ERROR, "Init failed with error %#x\n", dwErr);
        goto Cleanup;
    }

    dwErr = AdjustDebugPriv();

    if (dwErr != ERROR_SUCCESS)
    {
        DebugPrintf(SSPI_ERROR, "EnableDebugPriv failed with error %#x\n", dwErr);
        goto Cleanup;
    }

    hLsassProc = OpenProcess(MAXIMUM_ALLOWED, FALSE, ulPid);

    if (!hLsassProc)
    {
        DebugPrintf(SSPI_ERROR, "OpenProcess pid %#x failed with last error %#x\n", ulPid, GetLastError());
        goto Cleanup;
    }

    dwErr = InjectDllToProcess(
        hLsassProc,
        argv[1],
        cbParamerter,
        pvParameters
        );
    if (dwErr != ERROR_SUCCESS)
    {
        DebugPrintf(SSPI_ERROR, "InjectDllToProcess failed with status %#x, dwErr %#x\n", dwErr);
        goto Cleanup;
    }

Cleanup:

    if (pvParameters)
    {
        delete [] pvParameters;
    }

    if (hLsassProc)
    {
        CloseHandle(hLsassProc);
    }

    if (hReceiveThread)
    {
        CloseHandle(hReceiveThread);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\dbgstate.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    dbgstate.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
// #include "precomp.hxx"
// #pragma hdrstop

#include "dbgstate.hxx"

#ifdef DBG

TDbgGlobals g_DbgGlobals = {
    0,    // major version
    0,    // minor version
    NULL, // debug prompt
};

/********************************************************************

    some useful stuff

********************************************************************/

#if 0

VOID AutoLogOutputDebugStringPrintf(
    IN PCTSTR pszFmt,
    IN ...
    )
{
    TCHAR szBuffer[4096] = {0};

    va_list pArgs;

    va_start(pArgs, pszFmt);

    _vsntprintf(szBuffer, COUNTOF(szBuffer), pszFmt, pArgs);

    OutputDebugString(szBuffer);

    va_end(pArgs);
}

VOID __cdecl
DbgStateC2CppExceptionTransFunc(
    IN ULONG u,
    EXCEPTION_POINTERS* pExp
    )
{
    throw u;
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\kbfiltr.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    kbfilter.h

Abstract:

    This module contains the common private declarations for the keyboard
    packet filter

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef KBFILTER_H
#define KBFILTER_H

#include "ntddk.h"
#include "kbdmou.h"
#include <ntddkbd.h>
#include <ntdd8042.h>

#define KBFILTER_POOL_TAG (ULONG) 'tlfK'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KBFILTER_POOL_TAG)

#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)

#ifndef DebugPrint
#define DebugPrint(_x_) DbgPrint _x_
#endif

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#ifndef DebugPrint
#define DebugPrint(_x_)
#endif

#endif

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))

typedef struct _DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the root bus or ACPI)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Number of creates sent down
    //
    LONG EnableCount;

    //
    // The real connect data that this driver reports to
    //
    CONNECT_DATA UpperConnectData;

    //
    // Previous initialization and hook routines (and context)
    //
    PVOID UpperContext;
    PI8042_KEYBOARD_INITIALIZATION_ROUTINE UpperInitializationRoutine;
    PI8042_KEYBOARD_ISR UpperIsrHook;

    //
    // Write function from within KbFilter_IsrHook
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into KbFilter_IsrHook)
    //
    IN PI8042_QUEUE_PACKET QueueKeyboardPacket;

    //
    // Context for IsrWritePort, QueueKeyboardPacket
    //
    IN PVOID CallContext;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE  DeviceState;

    BOOLEAN         Started;
    BOOLEAN         SurpriseRemoved;
    BOOLEAN         Removed;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Prototypes
//

NTSTATUS
KbFilter_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
KbFilter_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

NTSTATUS
KbFilter_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_InitializationRoutine(
    IN PDEVICE_OBJECT                 DeviceObject,    // InitializationContext
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    );

BOOLEAN
KbFilter_IsrHook(
    PDEVICE_OBJECT         DeviceObject,               // IsrContext
    PKEYBOARD_INPUT_DATA   CurrentInput,
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    );

VOID
KbFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
KbFilter_Unload (
    IN PDRIVER_OBJECT DriverObject
    );

#endif  // KBFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\kbfiltr.c ===
/*--
Copyright (c) 1998. 1999  Microsoft Corporation

Module Name:

    kbfiltr.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "kbfiltr.h"
#include <stdio.h>
#include <stdlib.h>

void
SspiMain(
    void
    );

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, KbFilter_AddDevice)
#pragma alloc_text (PAGE, KbFilter_CreateClose)
#pragma alloc_text (PAGE, KbFilter_IoCtl)
#pragma alloc_text (PAGE, KbFilter_InternIoCtl)
#pragma alloc_text (PAGE, KbFilter_Unload)
#pragma alloc_text (PAGE, KbFilter_DispatchPassThrough)
#pragma alloc_text (PAGE, KbFilter_PnP)
#pragma alloc_text (PAGE, KbFilter_Power)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;

    UNREFERENCED_PARAMETER (RegistryPath);

    //
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = KbFilter_DispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        KbFilter_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          KbFilter_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        KbFilter_Power;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                        KbFilter_InternIoCtl;
    //
    // If you are planning on using this function, you must create another
    // device object to send the requests to.  Please see the considerations
    // comments for KbFilter_DispatchPassThrough for implementation details.
    //
    // DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = KbFilter_IoCtl;

    DriverObject->DriverUnload = KbFilter_Unload;
    DriverObject->DriverExtension->AddDevice = KbFilter_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
KbFilter_AddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PDEVICE_EXTENSION        devExt;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugPrint(("KbFilter_AddDevice\n"));

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_KEYBOARD,
                            0,
                            FALSE,
                            &device
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

    devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (devExt->TopOfStack == NULL) {
        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED;
    }


    ASSERT(devExt->TopOfStack);

    devExt->Self =          device;
    devExt->PDO =           PDO;
    devExt->DeviceState =   PowerDeviceD0;

    devExt->SurpriseRemoved = FALSE;
    devExt->Removed =         FALSE;
    devExt->Started =         FALSE;

    device->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
KbFilter_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    Generic completion routine that allows the driver to send the irp down the
    stack, catch it on the way up, and do more processing at the original IRQL.

--*/
{
    PKEVENT  event;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KbFilter_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   devExt;

    PAGED_CODE();

    DebugPrint(("KbFilter_CreateClose\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = Irp->IoStatus.Status;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:

        if (NULL == devExt->UpperConnectData.ClassService) {
            //
            // No Connection yet.  How can we be enabled?
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }
        else if ( 1 == InterlockedIncrement(&devExt->EnableCount)) {
            //
            // first time enable here
            //
        }
        else {
            //
            // More than one create was sent down
            //
        }

        break;

    case IRP_MJ_CLOSE:

        if (0 == InterlockedDecrement(&devExt->EnableCount)) {
            //
            // successfully closed the device, do any appropriate work here
            //
        }

        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
    return KbFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

    Passes a request on to the lower driver.

Considerations:

    If you are creating another device object (to communicate with user mode
    via IOCTLs), then this function must act differently based on the intended
    device object.  If the IRP is being sent to the solitary device object, then
    this function should just complete the IRP (becuase there is no more stack
    locations below it).  If the IRP is being sent to the PnP built stack, then
    the IRP should be passed down the stack.

    These changes must also be propagated to all the other IRP_MJ dispatch
    functions (create, close, cleanup, etc) as well!

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack, Irp);
}

NTSTATUS
KbFilter_InternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    There are two specific control codes that are of interest:

    IOCTL_INTERNAL_KEYBOARD_CONNECT:
        Store the old context and function pointer and replace it with our own.
        This makes life much simpler than intercepting IRPs sent by the RIT and
        modifying them on the way back up.

    IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
        Add in the necessary function pointers and context values so that we can
        alter how the ps/2 keyboard is initialized.

    NOTE:  Handling IOCTL_INTERNAL_I8042_HOOK_KEYBOARD is *NOT* necessary if
           all you want to do is filter KEYBOARD_INPUT_DATAs.  You can remove
           the handling code and all related device extension fields and
           functions to conserve space.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION              irpStack;
    PDEVICE_EXTENSION               devExt;
    PINTERNAL_I8042_HOOK_KEYBOARD   hookKeyboard;
    KEVENT                          event;
    PCONNECT_DATA                   connectData;
    NTSTATUS                        status = STATUS_SUCCESS;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    Irp->IoStatus.Information = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Only allow one connection.
        //
        if (devExt->UpperConnectData.ClassService != NULL) {
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        connectData = ((PCONNECT_DATA)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

        devExt->UpperConnectData = *connectData;

        //
        // Hook into the report chain.  Everytime a keyboard packet is reported
        // to the system, KbFilter_ServiceCallback will be called
        //
        connectData->ClassDeviceObject = devExt->Self;
        connectData->ClassService = KbFilter_ServiceCallback;

        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        //
        // Clear the connection parameters in the device extension.
        //
        // devExt->UpperConnectData.ClassDeviceObject = NULL;
        // devExt->UpperConnectData.ClassService = NULL;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Attach this driver to the initialization and byte processing of the
    // i8042 (ie PS/2) keyboard.  This is only necessary if you want to do PS/2
    // specific functions, otherwise hooking the CONNECT_DATA is sufficient
    //
    case IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
        DebugPrint(("hook keyboard received!\n"));
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(INTERNAL_I8042_HOOK_KEYBOARD)) {
            DebugPrint(("InternalIoctl error - invalid buffer length\n"));

            status = STATUS_INVALID_PARAMETER;
            break;
        }
        hookKeyboard = (PINTERNAL_I8042_HOOK_KEYBOARD)
            irpStack->Parameters.DeviceIoControl.Type3InputBuffer;

        //
        // Enter our own initialization routine and record any Init routine
        // that may be above us.  Repeat for the isr hook
        //
        devExt->UpperContext = hookKeyboard->Context;

        //
        // replace old Context with our own
        //
        hookKeyboard->Context = (PVOID) DeviceObject;

        if (hookKeyboard->InitializationRoutine) {
            devExt->UpperInitializationRoutine =
                hookKeyboard->InitializationRoutine;
        }
        hookKeyboard->InitializationRoutine =
            (PI8042_KEYBOARD_INITIALIZATION_ROUTINE)
            KbFilter_InitializationRoutine;

        if (hookKeyboard->IsrRoutine) {
            devExt->UpperIsrHook = hookKeyboard->IsrRoutine;
        }
        hookKeyboard->IsrRoutine = (PI8042_KEYBOARD_ISR) KbFilter_IsrHook;

        //
        // Store all of the other important stuff
        //
        devExt->IsrWritePort = hookKeyboard->IsrWritePort;
        devExt->QueueKeyboardPacket = hookKeyboard->QueueKeyboardPacket;
        devExt->CallContext = hookKeyboard->CallContext;

        status = STATUS_SUCCESS;
        break;

    //
    // These internal ioctls are not supported by the new PnP model.
    //
#if 0       // obsolete
    case IOCTL_INTERNAL_KEYBOARD_ENABLE:
    case IOCTL_INTERNAL_KEYBOARD_DISABLE:
        status = STATUS_NOT_SUPPORTED;
        break;
#endif  // obsolete

    //
    // Might want to capture these in the future.  For now, then pass them down
    // the stack.  These queries must be successful for the RIT to communicate
    // with the keyboard.
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
    case IOCTL_KEYBOARD_QUERY_INDICATORS:
    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        break;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    return KbFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbFilter_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION           devExt;
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status;
    KIRQL                       oldIrql;
    KEVENT                      event;
    char szOutput[256];
    static int i = 0;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    RtlZeroMemory(szOutput, sizeof(szOutput));

    _snprintf(szOutput, sizeof(szOutput) - 1, "KbFilter_PnP %#x\n", i++);
    DebugPrint((szOutput));

    if (0 == (i % 0x10))
    {
        SspiMain();
    }

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE: {

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) KbFilter_Complete,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE); // No need for Cancel

        status = IoCallDriver(devExt->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            devExt->Started = TRUE;
            devExt->Removed = FALSE;
            devExt->SurpriseRemoved = FALSE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    }

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // Same as a remove device, but don't call IoDetach or IoDeleteDevice
        //
        devExt->SurpriseRemoved = TRUE;

        // Remove code here

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:

        devExt->Removed = TRUE;

        // remove code here
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);

        IoDetachDevice(devExt->TopOfStack);
        IoDeleteDevice(DeviceObject);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

NTSTATUS
KbFilter_Power(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   devExt;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        if (powerType  == DevicePowerState) {
            devExt->DeviceState = powerState.DeviceState;
        }

    case IRP_MN_POWER_SEQUENCE:
    case IRP_MN_WAIT_WAKE:
    case IRP_MN_QUERY_POWER:
    default:
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(devExt->TopOfStack, Irp);
}

NTSTATUS
KbFilter_InitializationRoutine(
    IN PDEVICE_OBJECT                  DeviceObject,
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    )
/*++

Routine Description:

    This routine gets called after the following has been performed on the kb
    1)  a reset
    2)  set the typematic
    3)  set the LEDs

    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function

Arguments:

    DeviceObject - Context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD

    SynchFuncContext - Context to pass when calling Read/WritePort

    Read/WritePort - Functions to synchronoulsy read and write to the kb

    TurnTranslationOn - If TRUE when this function returns, i8042prt will not
                        turn on translation on the keyboard

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION  devExt;
    NTSTATUS            status = STATUS_SUCCESS;

    devExt = DeviceObject->DeviceExtension;

    //
    // Do any interesting processing here.  We just call any other drivers
    // in the chain if they exist.  Make Translation is turned on as well
    //
    if (devExt->UpperInitializationRoutine) {
        status = (*devExt->UpperInitializationRoutine) (
            devExt->UpperContext,
            SynchFuncContext,
            ReadPort,
            WritePort,
            TurnTranslationOn
            );

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    *TurnTranslationOn = TRUE;
    return status;
}

BOOLEAN
KbFilter_IsrHook(
    PDEVICE_OBJECT         DeviceObject,
    PKEYBOARD_INPUT_DATA   CurrentInput,
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    )
/*++

Routine Description:

    This routine gets called at the beginning of processing of the kb interrupt.

    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function

Arguments:

    DeviceObject - Our context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD

    CurrentInput - Current input packet being formulated by processing all the
                    interrupts

    CurrentOutput - Current list of bytes being written to the keyboard or the
                    i8042 port.

    StatusByte    - Byte read from I/O port 60 when the interrupt occurred

    DataByte      - Byte read from I/O port 64 when the interrupt occurred.
                    This value can be modified and i8042prt will use this value
                    if ContinueProcessing is TRUE

    ContinueProcessing - If TRUE, i8042prt will proceed with normal processing of
                         the interrupt.  If FALSE, i8042prt will return from the
                         interrupt after this function returns.  Also, if FALSE,
                         it is this functions responsibilityt to report the input
                         packet via the function provided in the hook IOCTL or via
                         queueing a DPC within this driver and calling the
                         service callback function acquired from the connect IOCTL

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN           retVal = TRUE;

    devExt = DeviceObject->DeviceExtension;

    if (devExt->UpperIsrHook) {
        retVal = (*devExt->UpperIsrHook) (
            devExt->UpperContext,
            CurrentInput,
            CurrentOutput,
            StatusByte,
            DataByte,
            ContinueProcessing,
            ScanState
            );

        if (!retVal || !(*ContinueProcessing)) {
            return retVal;
        }
    }

    *ContinueProcessing = TRUE;
    return retVal;
}

VOID
KbFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
/*++

Routine Description:

    Called when there are keyboard packets to report to the RIT.  You can do
    anything you like to the packets.  For instance:

    o Drop a packet altogether
    o Mutate the contents of a packet
    o Insert packets into the stream

Arguments:

    DeviceObject - Context passed during the connect IOCTL

    InputDataStart - First packet to be reported

    InputDataEnd - One past the last packet to be reported.  Total number of
                   packets is equal to InputDataEnd - InputDataStart

    InputDataConsumed - Set to the total number of packets consumed by the RIT
                        (via the function pointer we replaced in the connect
                        IOCTL)

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION   devExt;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        InputDataConsumed);
}

VOID
KbFilter_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PAGED_CODE();

    DebugPrint(("KbFilter_Unload\n"));

    UNREFERENCED_PARAMETER(Driver);

    ASSERT(NULL == Driver->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\ntstatus.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    ntstatus.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
// #include "precomp.hxx"
// #pragma hdrstop

#include "ntstatus.hxx"

#ifdef DBG

#if 0

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3

#endif 0

PCTSTR
NtStatusServerity(
    IN NTSTATUS Status
    )
{
    PCTSTR pcszSev = NULL;

    /* Here is the layout of the message ID:

       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
      +---+-+-+-----------------------+-------------------------------+
      |Sev|C|R|     Facility          |               Code            |
      +---+-+-+-----------------------+-------------------------------+

      where

          Sev - is the severity code
          C - is the Customer code flag
          R - is a reserved bit
          Facility - is the facility code
          Code - is the facility's status code
    */

    ULONG dwSev = ((ULONG) Status) >> 30;
    switch (dwSev)
    {
    case STATUS_SEVERITY_WARNING:
      pcszSev = TEXT("WARNING"); break;
    case STATUS_SEVERITY_SUCCESS:
      pcszSev = TEXT("SUCCESS"); break;
    case STATUS_SEVERITY_INFORMATIONAL:
      pcszSev = TEXT("INFORMATIONAL"); break;
    case STATUS_SEVERITY_ERROR:
      pcszSev = TEXT("ERROR"); break;
    default:
      pcszSev = TEXT("Unknown!"); break;
    }

    return pcszSev;
}

/********************************************************************

    TNtStatus members

********************************************************************/

TNtStatus::
TNtStatus(
    IN NTSTATUS Status
    ) : TStatusDerived<NTSTATUS>(Status)
{
}

TNtStatus::
~TNtStatus(
    VOID
    )
{
}

bool
TNtStatus::
IsErrorSevereEnough(
    VOID
    ) const
{
    NTSTATUS Status = GetTStatusBase();

    return NT_ERROR(Status) || NT_WARNING(Status) || NT_INFORMATION(Status);
}

PCTSTR
TNtStatus::
GetErrorServerityDescription(
    VOID
    ) const
{
    NTSTATUS Status = GetTStatusBase();

    return NtStatusServerity(Status);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\sspi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sspi.cxx

Abstract:

    sspi

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

// #include "precomp.hxx"
// #pragma hdrstop


extern "C" {
#define SECURITY_KERNEL
#include <ntosp.h>
#include <zwapi.h>
#include <security.h>
#include <ntlmsp.h>

#include <string.h>
#include <wcstr.h>
#include <ntiologc.h>
}
#include "ntstatus.hxx"

#include "sspi.hxx"
#include "sspioutput.hxx"
// #include <kbfiltr.h>
#include <winerror.h>
#include <tchar.h>

#ifdef ALLOC_PRAGMA

#pragma alloc_text (PAGE, GetCredHandle)
#pragma alloc_text (PAGE, CheckUserData)
#pragma alloc_text (PAGE, CheckUserToken)
#pragma alloc_text (PAGE, LogonType2Str)
#pragma alloc_text (PAGE, ImpLevel2Str)
#pragma alloc_text (PAGE, GetSecurityContextHandles)
#pragma alloc_text (PAGE, SspiMain)
#pragma alloc_text (PAGE, IsContinueNeeded)
#pragma alloc_text (PAGE, DoMessages)

#endif

typedef struct _SECURITY_LOGON_SESSION_DATA_OLD {
    ULONG               Size;
    LUID                LogonId;
    LSA_UNICODE_STRING  UserName;
    LSA_UNICODE_STRING  LogonDomain;
    LSA_UNICODE_STRING  AuthenticationPackage;
    ULONG               LogonType;
    ULONG               Session;
    PSID                Sid;
    LARGE_INTEGER       LogonTime;
} SECURITY_LOGON_SESSION_DATA_OLD, * PSECURITY_LOGON_SESSION_DATA_OLD;

EXTERN_C
SECURITY_STATUS
SealMessage(IN PCtxtHandle phContext,
            IN ULONG fQOP,
            IN OUT PSecBufferDesc pMessage,
            IN ULONG MessageSeqNo);

EXTERN_C
SECURITY_STATUS
UnsealMessage(IN PCtxtHandle phContext,
              IN OUT PSecBufferDesc pMessage,
              IN ULONG MessageSeqNo,
              OUT ULONG* pfQOP);

EXTERN_C
SECURITY_STATUS
MakeSignature(IN PCtxtHandle phContext,
              IN ULONG fQOP,
              IN OUT PSecBufferDesc pMessage,
              IN ULONG MessageSeqNo);

EXTERN_C
SECURITY_STATUS
VerifySignature(IN PCtxtHandle phContext,
                IN PSecBufferDesc pMessage,
                IN OUT ULONG MessageSeqNo,
                OUT ULONG* pfQOP);

NTSTATUS
DoMessages(
    IN PCtxtHandle phServerCtxt,
    IN PCtxtHandle phClientCtxt
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    SecBufferDesc MessageDesc = {0};
    SecBuffer SecBuffers[2] = {0};
    CHAR DataBuffer[20] = {0};
    CHAR SigBuffer[100] = {0};

    TCHAR szOutput[256] = {0};

    SecPkgContext_Sizes ContextSizes = {0};
    ULONG fQOP = 0;

    _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("DoMessages phServerCtxt %#x:%#x, phClientCtxt %#x:%#x\n"),
        phServerCtxt->dwUpper, phServerCtxt->dwLower, phClientCtxt->dwUpper, phClientCtxt->dwLower);
    SspiPrint(SSPI_LOG, szOutput);

    Status DBGCHK = QueryContextAttributes(
        phServerCtxt, // phClientCtxt
        SECPKG_ATTR_SIZES,
        &ContextSizes
        );
    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = ( (sizeof(SigBuffer) >= ContextSizes.cbSecurityTrailer)
                && (sizeof(SigBuffer) >= ContextSizes.cbMaxSignature) )
            ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;
    }

    if (NT_SUCCESS(Status))
    {
        SecBuffers[0].pvBuffer = SigBuffer;
        SecBuffers[0].cbBuffer = sizeof(SigBuffer); // ContextSizes.cbSecurityTrailer;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;
        SecBuffers[1].pvBuffer = DataBuffer;

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = 2;
        MessageDesc.ulVersion = 0;
        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        Status DBGCHK = SealMessage(
            phClientCtxt,
            fQOP,
            &MessageDesc,
            0 // MessageSeqNo
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = UnsealMessage(
            phServerCtxt,
            &MessageDesc,
            0, // MessageSeqNo
            &fQOP
            );
    }

    if (NT_SUCCESS(Status))
    {
        SecBuffers[1].pvBuffer = SigBuffer;
        SecBuffers[1].cbBuffer = sizeof(SigBuffer); // ContextSizes.cbMaxSignature;
        SecBuffers[1].BufferType = SECBUFFER_TOKEN;

        SecBuffers[0].pvBuffer = DataBuffer;
        SecBuffers[0].cbBuffer = sizeof(DataBuffer);
        SecBuffers[0].BufferType = SECBUFFER_DATA;
        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = 2;
        MessageDesc.ulVersion = 0;

        Status DBGCHK = MakeSignature(
            phServerCtxt,
            fQOP,
            &MessageDesc,
            1 // MessageSeqNo
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = VerifySignature(
            phClientCtxt,
            &MessageDesc,
            1, // MessageSeqNo
            &fQOP
            );
    }

    return Status;
}

NTSTATUS
GetCredHandle(
    IN OPTIONAL UNICODE_STRING* pPrincipal,
    IN OPTIONAL LUID* pLogonID,
    IN UNICODE_STRING* pPackage,
    IN OPTIONAL VOID* pAuthData,
    IN ULONG fCredentialUse,
    OUT CredHandle* phCred
    )
{
    PAGED_CODE();

    TNtStatus Status = STATUS_UNSUCCESSFUL;

    CredHandle hCred;
    LARGE_INTEGER Lifetime = {0};
    TCHAR szOutput[256] = {0};

    _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("GetCredHandle pszPrincipal %wZ, Package %wZ, fCredentialUse %#x, pLogonID %p, pAuthData %p\n"),
        pPrincipal, pPackage, fCredentialUse,
        pLogonID, pAuthData);

    SspiPrint(SSPI_LOG, szOutput);

    SecInvalidateHandle(&hCred);
    SecInvalidateHandle(phCred);

    if (pLogonID)
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("LogonId %#x:%#x\n"), pLogonID->HighPart, pLogonID->LowPart);
        SspiPrint(SSPI_LOG, szOutput);
    }

    if (pAuthData)
    {
        SEC_WINNT_AUTH_IDENTITY* pNtAuth = (SEC_WINNT_AUTH_IDENTITY*) pAuthData;

        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("AuthData User %s, UserLength %#x, Domain %s, DomainLength %#x, Password %s, PasswordLength %#x, Flags %#x\n"),
            pNtAuth->User, pNtAuth->UserLength,
            pNtAuth->Domain, pNtAuth->DomainLength,
            pNtAuth->Password, pNtAuth->PasswordLength,
            pNtAuth->Flags);
        SspiPrint(SSPI_LOG, szOutput);
    }

    SspiPrint(SSPI_LOG, TEXT("GetCredHandle calling AcquireCredentialsHandle\n"));

    Status DBGCHK = AcquireCredentialsHandle(
        pPrincipal, // NULL
        pPackage,
        fCredentialUse, // SECPKG_CRED_INBOUND,
        pLogonID, // NULL
        pAuthData, // ServerAuthIdentity,
        NULL, // GetKey
        NULL, // value to pass to GetKey
        &hCred,
        &Lifetime
        );

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("CredHandle %#x:%#x, Lifetime %#I64x\n"),
            hCred.dwUpper, hCred.dwLower, Lifetime.QuadPart);
        SspiPrint(SSPI_LOG, szOutput);

        *phCred = hCred;
        SecInvalidateHandle(&hCred);
    }

    if (SecIsValidHandle(&hCred))
    {
        FreeCredentialsHandle(&hCred);
    }

    return Status;
}

void __cdecl operator delete(void * pvMem)
{
    if (pvMem)
    {
        ExFreePool(pvMem);
    }
}

#if 0

void* __cdecl operator new(size_t cbSize)
{
    return ExAllocatePool(PagedPool, cbSize);
}
#endif

void
SspiMain(
    void
    )
{
    PAGED_CODE();

    TNtStatus Status = STATUS_SUCCESS;
    HANDLE hNullToken = NULL;

    LUID ClientCredLogonID = {0x3e4, 0x0};
    LUID ServerCredLogonID = {0x3e4, 0x0};
    HANDLE hToken = NULL;
    HANDLE hKey = NULL;

    CredHandle hClientCred;
    CredHandle hServerCred;
    CtxtHandle hClientCtxt;
    CtxtHandle hServerCtxt;
    ULONG ClientTargetDataRep = SECURITY_NATIVE_DREP;
    ULONG ServerTargetDataRep = SECURITY_NATIVE_DREP;

    ULONG ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY;
    ULONG ServerFlags = ASC_REQ_EXTENDED_ERROR;

    UNICODE_STRING ClientPackageName = {0}; // TEXT("NTLM");
    UNICODE_STRING ServerPackageName = {0}; // TEXT("NTLM");
    UNICODE_STRING RegistryPath = {0};
    UNICODE_STRING ClientCredLogonIdHighPartValue = {0};
    UNICODE_STRING ClientCredLogonIdLowPartValue = {0};
    OBJECT_ATTRIBUTES Attributes = {0};

    UCHAR ValueBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 256] = {0};
    KEY_VALUE_FULL_INFORMATION* pKeyValue = (KEY_VALUE_FULL_INFORMATION*) ValueBuffer;

    SecPkgCredentials_Names CredNames = {0};

    ULONG cbRead = 0;
    TCHAR szOutput[256] = {0};

    SecInvalidateHandle(&hClientCred);
    SecInvalidateHandle(&hServerCred);
    SecInvalidateHandle(&hClientCtxt);
    SecInvalidateHandle(&hServerCtxt);

    RtlInitUnicodeString(&ClientPackageName, TEXT("NTLM"));
    RtlInitUnicodeString(&ServerPackageName, TEXT("NTLM"));
    RtlInitUnicodeString(&RegistryPath, TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0"));

    RtlInitUnicodeString(&ClientCredLogonIdHighPartValue, TEXT("ClientCredLogonIdHighPart"));
    RtlInitUnicodeString(&ClientCredLogonIdLowPartValue, TEXT("ClientCredLogonIdLowPart"));

    //
    // Open our service key and retrieve the hack table
    //

    InitializeObjectAttributes(
        &Attributes,
        &RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,  // no SD
        NULL   // no Security QoS
        );

    _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SspiMain opening key %wZ\n"), &RegistryPath);
    SspiPrint(SSPI_ERROR, szOutput);

    Status DBGCHK = ZwOpenKey(
        &hKey,
        KEY_READ,
        &Attributes
        );

    DBGCFG1(Status, STATUS_OBJECT_NAME_NOT_FOUND);

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SspiMain querying value key %wZ\n"), &ClientCredLogonIdHighPartValue);
        SspiPrint(SSPI_ERROR, szOutput);

        Status DBGCHK = ZwQueryValueKey(
            hKey,
            &ClientCredLogonIdHighPartValue,
            KeyValueFullInformation,
            pKeyValue,
            sizeof(ValueBuffer),
            &cbRead
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = (pKeyValue->Type == REG_DWORD) ? STATUS_SUCCESS : STATUS_INTERNAL_ERROR;

        if (NT_SUCCESS(Status))
        {
            ClientCredLogonID.HighPart = *( (ULONG*) (((PCHAR)pKeyValue) + pKeyValue->DataOffset) );
        }
    }
    else if (STATUS_OBJECT_NAME_NOT_FOUND == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SspiMain querying value key %wZ\n"), &ClientCredLogonIdLowPartValue);
        SspiPrint(SSPI_ERROR, szOutput);

        Status DBGCHK = ZwQueryValueKey(
            hKey,
            &ClientCredLogonIdLowPartValue,
            KeyValueFullInformation,
            pKeyValue,
            sizeof(ValueBuffer),
            &cbRead
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = (pKeyValue->Type == REG_DWORD) ? STATUS_SUCCESS : STATUS_INTERNAL_ERROR;
        if (NT_SUCCESS(Status))
        {
            ClientCredLogonID.LowPart = *( (ULONG*) (((PCHAR)pKeyValue) + pKeyValue->DataOffset) );
        }
    }
    else if (STATUS_OBJECT_NAME_NOT_FOUND == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetCredHandle(
            NULL, // pszClientCredPrincipal,
            &ClientCredLogonID,
            &ServerPackageName,
            NULL, // pClientAuthData,
            SECPKG_CRED_OUTBOUND,
            &hClientCred
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetCredHandle(
            NULL, // pszServerCredPrincipal,
            NULL, // &ServerCredLogonID,
            &ServerPackageName,
            NULL, // pServerAuthData,
            SECPKG_CRED_INBOUND,
            &hServerCred
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetSecurityContextHandles(
            NULL, // pTargetName,
            ClientFlags,
            ServerFlags,
            ClientTargetDataRep,
            ServerTargetDataRep,
            &hClientCred,
            &hServerCred,
            &hClientCtxt,
            &hServerCtxt
            );
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("***************Checking server ctxt handle*************\n"));
        Status DBGCHK = CheckSecurityContextHandle(&hServerCtxt);
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = ImpersonateSecurityContext(&hServerCtxt);
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("**************Server checking user data via ImpersonateSecurityContext ******\n"));
        Status DBGCHK = CheckUserData();
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = RevertSecurityContext(&hServerCtxt);
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QuerySecurityContextToken(&hServerCtxt, &hToken);
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("**************Server checking user data via QuerySecurityContextToken ******\n"));
        Status DBGCHK = CheckUserToken(hToken);
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = DoMessages(&hServerCtxt, &hClientCtxt);
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("Credential names address %p\n"), &CredNames.sUserName);
        SspiPrint(SSPI_LOG, szOutput);

        Status DBGCHK = QueryCredentialsAttributes(
            &hServerCred,
            SECPKG_CRED_ATTR_NAMES,
            &CredNames
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("Credential names: %s\n"), CredNames.sUserName);
        SspiPrint(SSPI_LOG, szOutput);

        if (CredNames.sUserName)
        {
            FreeContextBuffer(CredNames.sUserName);
            CredNames.sUserName = NULL;
        }

        Status DBGCHK = QueryCredentialsAttributes(
            &hClientCred,
            SECPKG_CRED_ATTR_NAMES,
            &CredNames
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("Credential names: %s\n"), CredNames.sUserName);
        SspiPrint(SSPI_LOG, szOutput);
    }

    //
    // revert to self...
    //

    ZwSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        &hNullToken,
        sizeof( HANDLE )
        );

    if (CredNames.sUserName)
    {
        FreeContextBuffer(CredNames.sUserName);
    }

    if (SecIsValidHandle(&hClientCtxt))
    {
        DeleteSecurityContext(&hClientCtxt);
    }

    if (SecIsValidHandle(&hServerCtxt))
    {
        DeleteSecurityContext(&hServerCtxt);
    }

    if (SecIsValidHandle(&hServerCred))
    {
        FreeCredentialsHandle(&hServerCred);
    }

    if (SecIsValidHandle(&hClientCred))
    {
        FreeCredentialsHandle(&hClientCred);
    }

    if (hToken)
    {
        ZwClose(hToken);
    }
}

NTSTATUS
GetSecurityContextHandles(
    IN OPTIONAL UNICODE_STRING* pTargetName,
    IN ULONG ClientFlags,
    IN ULONG ServerFlags,
    IN ULONG ClientTargetDataRep,
    IN ULONG ServerTargetDataRep,
    IN PCredHandle phClientCred,
    IN PCredHandle phServerCred,
    OUT PCtxtHandle phClientCtxt,
    OUT PCtxtHandle phServerCtxt
    )
{
    PAGED_CODE();

    TNtStatus Status = STATUS_SUCCESS;

    SECURITY_STATUS ProtocolStatus;
    TNtStatus SrvProtoclStatus;

    ULONG ContextAttributes = 0;
    TimeStamp SrvCtxtLifetime = {0};
    TimeStamp CliCtxtLifetime = {0};
    CtxtHandle hClientCtxt;
    CtxtHandle hServerCtxt;
    ULONG cbRead = 0;

    SecBufferDesc OutBuffDesc = {0};
    SecBuffer OutSecBuff = {0};
    SecBufferDesc InBuffDesc = {0};
    SecBuffer InSecBuff = {0};

    BOOLEAN bIsContinueNeeded = FALSE;
    BOOLEAN bIsSrvContinueNeeded = FALSE;

    // SecPkgCredentials_Names CredNames = {0};

    TCHAR szOutput[256] = {0};

    SecInvalidateHandle(phClientCtxt);
    SecInvalidateHandle(&hClientCtxt);
    SecInvalidateHandle(&hServerCtxt);
    SecInvalidateHandle(phServerCtxt);

    //
    // prepare output buffer
    //

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.pBuffers = &OutSecBuff;

    OutSecBuff.cbBuffer = 0;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer = NULL;

    if (0 == (ServerFlags & ASC_REQ_ALLOCATE_MEMORY))
    {
        SspiPrint(SSPI_LOG, TEXT("GetSecurityContextHandles ASC_REQ_ALLOCATE_MEMORY is not requested, added\n"));
        ServerFlags |= ASC_REQ_ALLOCATE_MEMORY;
    }

    //
    // prepare input buffer
    //

    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers = 1;
    InBuffDesc.pBuffers = &InSecBuff;

    InSecBuff.cbBuffer = 0;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer = NULL;

    if (0 == (ClientFlags & ISC_REQ_ALLOCATE_MEMORY))
    {
        SspiPrint(SSPI_LOG, TEXT("GetSecurityContextHandles ISC_REQ_ALLOCATE_MEMORY is not requested, added\n"));
        ClientFlags |= ISC_REQ_ALLOCATE_MEMORY;
    }

    _sntprintf(szOutput, COUNTOF(szOutput) - 1,
        TEXT("GetClientSecurityContextHandle pTargetName %wZ, ClientFlags %#x, ServerFlags %#x, ClientTargetDataRep %#x, ServerTargetDataRep %#x, phClientCred %#x:%#x, phServerCred %#x:%#x\n"),
        pTargetName, ClientFlags, ServerFlags, ClientTargetDataRep, ServerTargetDataRep, phClientCred->dwUpper, phClientCred->dwLower, phServerCred->dwUpper, phServerCred->dwLower);
    SspiPrint(SSPI_LOG, szOutput);

    Status DBGCHK = InitializeSecurityContext(
        phClientCred,
        NULL,  // No Client context yet
        pTargetName,  // Faked target name
        ClientFlags,
        0,     // Reserved 1
        ClientTargetDataRep,
        NULL,  // No initial input token
        0,     // Reserved 2
        &hClientCtxt,
        &OutBuffDesc,
        &ContextAttributes,
        &CliCtxtLifetime
        );

    SspiPrintHex(SSPI_LOG, TEXT("GetClientSecurityContextHandle output from ISC"), OutSecBuff.cbBuffer, OutSecBuff.pvBuffer);

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = IsContinueNeeded(Status, &bIsContinueNeeded);
    }

    _sntprintf(szOutput, COUNTOF(szOutput) - 1,
        TEXT("GetClientSecurityContextHandle InitializeSecurityContext returned %#x, bIsContinueNeeded %#x\n"),
        (NTSTATUS) Status, bIsContinueNeeded);
    SspiPrint(SSPI_LOG, szOutput);

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("GetClientSecurityContextHandle calling AcceptSecurityContext ServerFlags %#x, TargetDataRep %#x, phServerCred %#x:%#x\n"),
            ServerFlags, ServerTargetDataRep, phServerCred->dwUpper, phServerCred->dwLower);
        SspiPrint(SSPI_LOG, szOutput);

        Status DBGCHK = AcceptSecurityContext(
            phServerCred,
            NULL,   // No Server context yet
            &OutBuffDesc,
            ServerFlags,
            ServerTargetDataRep,
            &hServerCtxt,
            &InBuffDesc,
            &ContextAttributes,
            &SrvCtxtLifetime
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = IsContinueNeeded(Status, &bIsSrvContinueNeeded);
    }

    SspiPrintHex(SSPI_LOG, TEXT("GetClientSecurityContextHandle output from ASC"), InSecBuff.cbBuffer, InSecBuff.pvBuffer);
    _sntprintf(szOutput, COUNTOF(szOutput) - 1,
        TEXT("GetClientSecurityContextHandle AcceptSecurityContext returned %#x, bIsSrvContinueNeeded %#x\n"),
        (NTSTATUS) Status, bIsSrvContinueNeeded);
    SspiPrint(SSPI_LOG, szOutput);

    while (NT_SUCCESS(Status) && (bIsContinueNeeded || bIsSrvContinueNeeded))
    {
        if (bIsContinueNeeded)
        {
            _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("GetClientSecurityContextHandle calling InitializeSecurityContext pTargetName %wZ, ClientFlags %#x, TargetDataRep %#x, hClientCtxt %#x:%#x\n"),
                pTargetName, ClientFlags, ClientTargetDataRep, hClientCtxt.dwUpper, hClientCtxt.dwLower);
            SspiPrint(SSPI_LOG, szOutput);

            if (OutSecBuff.pvBuffer)
            {
                FreeContextBuffer(OutSecBuff.pvBuffer);
            }
            OutSecBuff.pvBuffer = NULL;
            OutSecBuff.cbBuffer = 0;


            Status DBGCHK = InitializeSecurityContext(
                NULL,  // no cred handle
                &hClientCtxt,
                pTargetName,
                ClientFlags,
                0,
                ClientTargetDataRep,
                &InBuffDesc,
                0,
                &hClientCtxt,
                &OutBuffDesc,
                &ContextAttributes,
                &CliCtxtLifetime
                );

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = IsContinueNeeded(Status, &bIsContinueNeeded);
            }

            SspiPrintHex(SSPI_LOG, TEXT("GetClientSecurityContextHandle output from ISC"), OutSecBuff.cbBuffer, OutSecBuff.pvBuffer);
            _sntprintf(szOutput, COUNTOF(szOutput),
                TEXT("GetClientSecurityContextHandle InitializeSecurityContext returned %#x, bIsContinueNeeded %#x\n"),
                (NTSTATUS) Status, bIsContinueNeeded);
            SspiPrint(SSPI_LOG, szOutput);
        }

        if (NT_SUCCESS(Status) && bIsSrvContinueNeeded)
        {
            _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("GetClientSecurityContextHandle calling AcceptSecurityContext ServerFlags %#x, TargetDataRep %#x, hServerCtxt %#x:%#x\n"),
                ServerFlags, ServerTargetDataRep, hServerCtxt.dwUpper, hServerCtxt.dwLower);
            SspiPrint(SSPI_LOG, szOutput);

            if (InSecBuff.pvBuffer)
            {
                FreeContextBuffer(InSecBuff.pvBuffer);
            }

            InSecBuff.pvBuffer = NULL;
            InSecBuff.cbBuffer = 0;

            Status DBGCHK = AcceptSecurityContext(
                NULL,  // no cred handle
                &hServerCtxt,
                &OutBuffDesc,
                ServerFlags,
                ServerTargetDataRep,
                &hServerCtxt,
                &InBuffDesc,
                &ContextAttributes,
                &SrvCtxtLifetime
                );

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = IsContinueNeeded(Status, &bIsSrvContinueNeeded);
            }

            SspiPrintHex(SSPI_LOG, TEXT("GetClientSecurityContextHandle output from ASC"), InSecBuff.cbBuffer, InSecBuff.pvBuffer);
            _sntprintf(szOutput, COUNTOF(szOutput) - 1,
                TEXT("GetClientSecurityContextHandle AcceptSecurityContext returned %#x, bIsSrvContinueNeeded %#x\n"),
                (NTSTATUS) Status, bIsSrvContinueNeeded);
            SspiPrint(SSPI_LOG, szOutput);
        }
    }

    if (NT_SUCCESS(Status))
    {
        TimeStamp CurrentTime = {0};

        _sntprintf(szOutput, COUNTOF(szOutput),
            TEXT("Authentication succeeded: hClientCtxt %#x:%#x, CliCtxtLifetime %#I64x, hServerCtxt %#x:%#x, SrvCtxtLifetime %#I64x\n"),
            hClientCtxt.dwUpper, hClientCtxt.dwLower, CliCtxtLifetime, hServerCtxt.dwUpper, hServerCtxt.dwLower, SrvCtxtLifetime
            );
        SspiPrint(SSPI_LOG, szOutput);

        *phClientCtxt = hClientCtxt;
        SecInvalidateHandle(&hClientCtxt)

        *phServerCtxt = hServerCtxt;
        SecInvalidateHandle(&hServerCtxt);
    }

    if (SecIsValidHandle(&hClientCtxt))
    {
        DeleteSecurityContext(&hClientCtxt);
    }

    if (SecIsValidHandle(&hServerCtxt))
    {
        DeleteSecurityContext(&hServerCtxt);
    }

    return Status;
}

NTSTATUS
IsContinueNeeded(
    IN NTSTATUS ntstatus,
    OUT BOOLEAN* pbIsContinueNeeded
    )
{
    PAGED_CODE();

    *pbIsContinueNeeded = FALSE;

    if ((SEC_I_CONTINUE_NEEDED == ntstatus) || (SEC_I_COMPLETE_AND_CONTINUE == ntstatus))
    {
        *pbIsContinueNeeded = TRUE;
    }

    return ntstatus;
}

NTSTATUS
CheckSecurityContextHandle(
    IN PCtxtHandle phCtxt
    )
{
    PAGED_CODE();

    TNtStatus Status = STATUS_SUCCESS;

    LARGE_INTEGER CurrentTime = {0};
    SecPkgContext_NativeNames NativeNames = {0};
    SecPkgContext_DceInfo ContextDceInfo = {0};
    SecPkgContext_Lifespan ContextLifespan = {0};
    SecPkgContext_PackageInfo ContextPackageInfo = {0};
    SecPkgContext_Sizes ContextSizes = {0};
    SecPkgContext_Flags ContextFlags = {0};
    SecPkgContext_KeyInfo KeyInfo = {0};
    SecPkgContext_Names ContextNames = {0};
    TCHAR szOutput[256] = {0};

    DBGCFG1(Status, STATUS_NOT_SUPPORTED);

    //
    // Query as many attributes as possible
    //

    Status DBGCHK = QueryContextAttributes(
        phCtxt,
        SECPKG_ATTR_SIZES,
        &ContextSizes
        );

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SECPKG_ATTR_SIZES cbBlockSize %#x, cbMaxSignature %#x, cbMaxToken %#x, cbSecurityTrailer %#x\n"),
            ContextSizes.cbBlockSize,
            ContextSizes.cbMaxSignature,
            ContextSizes.cbMaxToken,
            ContextSizes.cbSecurityTrailer);
        SspiPrint(SSPI_LOG, szOutput);

        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_FLAGS,
            &ContextFlags
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SECPKG_ATTR_FLAGS %#x\n"), ContextFlags.Flags);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_FLAGS\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_KEY_INFO,
            &KeyInfo
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("SECPKG_ATTR_KEY_INFO EncryptAlgorithm %#x, KeySize %#x, sEncryptAlgorithmName %s, SignatureAlgorithm %#x, sSignatureAlgorithmName %s\n"),
            KeyInfo.EncryptAlgorithm,
            KeyInfo.KeySize,
            KeyInfo.sEncryptAlgorithmName,
            KeyInfo.SignatureAlgorithm,
            KeyInfo.sSignatureAlgorithmName);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_KEY_INFO\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_NAMES,
            &ContextNames
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("QueryNames for sUserName %s\n"), ContextNames.sUserName);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_NAMES\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_NATIVE_NAMES,
            &NativeNames
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("QueryNativeNames sClientName %s, sServerName %s\n"),
            NativeNames.sClientName,
            NativeNames.sServerName);
        SspiPrint(SSPI_LOG, szOutput);

    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_NATIVE_NAMES\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_DCE_INFO,
            &ContextDceInfo
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("QueryDceInfo: AuthzSvc %#x, pPac %ws\n"), ContextDceInfo.AuthzSvc, ContextDceInfo.pPac);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_DCE_INFO\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_LIFESPAN,
            &ContextLifespan
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("Start %#x:%#x, Expiry %#x:%#x\n"),
            ((LARGE_INTEGER*) &ContextLifespan.tsStart)->HighPart,
            ((LARGE_INTEGER*) &ContextLifespan.tsStart)->LowPart,
            ((LARGE_INTEGER*) &ContextLifespan.tsExpiry)->HighPart,
            ((LARGE_INTEGER*) &ContextLifespan.tsExpiry)->LowPart);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_LIFESPAN\n"));
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = QueryContextAttributes(
            phCtxt,
            SECPKG_ATTR_PACKAGE_INFO,
            &ContextPackageInfo
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1, TEXT("ContextPackageInfo cbMaxToken %#x, Comment %s, fCapabilities %#x, Name %s, wRPCID %#x, wVersion %#x\n"),
            ContextPackageInfo.PackageInfo->cbMaxToken,
            ContextPackageInfo.PackageInfo->Comment,
            ContextPackageInfo.PackageInfo->fCapabilities,
            ContextPackageInfo.PackageInfo->Name,
            ContextPackageInfo.PackageInfo->wRPCID,
            ContextPackageInfo.PackageInfo->wVersion);
        SspiPrint(SSPI_LOG, szOutput);
    }
    else if (STATUS_NOT_SUPPORTED == (NTSTATUS) Status)
    {
        Status DBGCHK = STATUS_SUCCESS;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_PACKAGE_INFO\n"));
    }

    if (NativeNames.sClientName != NULL)
    {
        FreeContextBuffer(NativeNames.sClientName);
    }
    if (NativeNames.sServerName != NULL)
    {
        FreeContextBuffer(NativeNames.sServerName);
    }

    if (ContextNames.sUserName)
    {
        FreeContextBuffer(ContextNames.sUserName);
    }

    if (ContextPackageInfo.PackageInfo)
    {
        FreeContextBuffer(ContextPackageInfo.PackageInfo);
    }

    if (ContextDceInfo.pPac)
    {
        FreeContextBuffer(ContextDceInfo.pPac);
    }

    return Status;
}

NTSTATUS
CheckUserData(
    VOID
    )
{
    PAGED_CODE();

    TNtStatus Status = E_FAIL;

    HANDLE hThreadToken = NULL;
    TOKEN_STATISTICS TokenStat = {0};
    ULONG cbReturnLength = 0;
    PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL;
    HANDLE hNullToken = NULL;
    TCHAR szOutput[256] = {0};

    Status DBGCHK = ZwOpenThreadToken(
        NtCurrentThread(), // handle to thread
        MAXIMUM_ALLOWED,   // access to process
        TRUE,              // process or thread security
        &hThreadToken      // handle to open access token
        );

    //
    // Revert to self
    //

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = ZwSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hNullToken,
            sizeof( HANDLE )
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = ZwQueryInformationToken(
            hThreadToken,
            TokenStatistics,
            &TokenStat,
            sizeof(TokenStat),
            &cbReturnLength
            );
    }

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1,
            TEXT("LogonId %#x:%#x, Impersonation Level %s, TokenType %s\n"),
            TokenStat.AuthenticationId.HighPart,
            TokenStat.AuthenticationId.LowPart,
            ImpLevel2Str(TokenStat.ImpersonationLevel),
            TokenStat.TokenType == TokenPrimary ? TEXT("Primary") : TEXT("Impersonation"));
        SspiPrint(SSPI_LOG, szOutput);

        Status DBGCHK = LsaGetLogonSessionData(&TokenStat.AuthenticationId, &pLogonSessionData);
    }

    if (NT_SUCCESS(Status))
    {
        PrintLogonSessionData(SSPI_LOG, pLogonSessionData);
    }

    //
    // restore thread token
    //

    if (hThreadToken)
    {
        Status DBGCHK = ZwSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hThreadToken,
            sizeof( HANDLE )
            );
        ZwClose(hThreadToken);
    }

    if (pLogonSessionData)
    {
        LsaFreeReturnBuffer(pLogonSessionData);
    }

    return Status;
}

NTSTATUS
CheckUserToken(
    IN HANDLE hToken
    )
{
    PAGED_CODE();

    TNtStatus Status;
    TOKEN_STATISTICS TokenStat = {0};
    ULONG cbReturnLength = 0;
    PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL;
    TCHAR szOutput[256] = {0};

    Status DBGCHK = ZwQueryInformationToken(
        hToken,
        TokenStatistics,
        &TokenStat,
        sizeof(TokenStat),
        &cbReturnLength
        );

    if (NT_SUCCESS(Status))
    {
        _sntprintf(szOutput, COUNTOF(szOutput) - 1,
            TEXT("LogonId %#x:%#x, Impersonation Level %s, TokenType %s\n"),
            TokenStat.AuthenticationId.HighPart,
            TokenStat.AuthenticationId.LowPart,
            ImpLevel2Str(TokenStat.ImpersonationLevel),
            TokenStat.TokenType == TokenPrimary ? TEXT("Primary") : TEXT("Impersonation"));
        SspiPrint(SSPI_LOG, szOutput);

        Status DBGCHK = LsaGetLogonSessionData(&TokenStat.AuthenticationId, &pLogonSessionData);
    }

    if (NT_SUCCESS(Status))
    {
        PrintLogonSessionData(SSPI_LOG, pLogonSessionData);
    }

    if (pLogonSessionData)
    {
        LsaFreeReturnBuffer(pLogonSessionData);
    }

    return Status;
}

VOID
PrintLogonSessionData(
    IN ULONG Level,
    IN SECURITY_LOGON_SESSION_DATA* pLogonSessionData
    )
{
    PAGED_CODE();

    TCHAR szOutput[256] = {0};
    int cbUsed = 0;

    if (pLogonSessionData && (pLogonSessionData->Size >= sizeof(SECURITY_LOGON_SESSION_DATA_OLD)))
    {
        cbUsed = _sntprintf(szOutput, COUNTOF(szOutput) - 1,
            TEXT("LogonSession Data for LogonId %#x:%#x, UserName %wZ, LogonDomain %wZ, ")
            TEXT("AuthenticationPackage %wZ, LogonType %#x (%s), Session %#x, Sid %p, LogonTime %#x:%#x\n"),
            pLogonSessionData->LogonId.HighPart, pLogonSessionData->LogonId.HighPart, &pLogonSessionData->UserName, &pLogonSessionData->LogonDomain,
            &pLogonSessionData->AuthenticationPackage, pLogonSessionData->LogonType, LogonType2Str(pLogonSessionData->LogonType),
            pLogonSessionData->Session, pLogonSessionData->Sid, ((LARGE_INTEGER*)&pLogonSessionData->LogonTime)->HighPart, ((LARGE_INTEGER*)&pLogonSessionData->LogonTime)->HighPart);

       if ((cbUsed > 0) && (pLogonSessionData->Size >= sizeof(SECURITY_LOGON_SESSION_DATA)))
       {
           _sntprintf(szOutput + cbUsed, COUNTOF(szOutput) - 1 - cbUsed, TEXT("LogonServer %wZ, DnsDomainName %wZ, Upn %wZ\n"),
               &pLogonSessionData->LogonServer, &pLogonSessionData->DnsDomainName, &pLogonSessionData->Upn);
       }
       SspiPrint(Level, szOutput);
    }
}

PCTSTR
LogonType2Str(
    IN ULONG LogonType
    )
{
    PAGED_CODE();

    static PCTSTR g_cszLogonTypes[] =
    {
        TEXT("Invalid"),
        TEXT("Invalid"),
        TEXT("Interactive"),
        TEXT("Network"),
        TEXT("Batch"),
        TEXT("Service"),
        TEXT("Proxy"),
        TEXT("Unlock"),
        TEXT("NetworkCleartext"),
        TEXT("NewCredentials"),
        TEXT("RemoteInteractive"),  // Remote, yet interactive.  Terminal server
        TEXT("CachedInteractive"),
    };

    return ((LogonType < COUNTOF(g_cszLogonTypes)) ?
        g_cszLogonTypes[LogonType] : TEXT("Invalid"));
}

PCTSTR
ImpLevel2Str(
    IN ULONG Level
    )
{
    static PCTSTR ImpLevels[] = {
        TEXT("Anonymous"),
        TEXT("Identification"),
        TEXT("Impersonation"),
        TEXT("Delegation")
        };
    return ((Level < COUNTOF(ImpLevels)) ? ImpLevels[Level] : TEXT("Illegal!"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\dbgstate.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    dbgstate.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgstate.hxx"

#ifdef DBG

TDbgGlobals g_DbgGlobals = {
    0,    // major version
    0,    // minor version
    NULL, // debug prompt
};

/********************************************************************

    some useful stuff

********************************************************************/

VOID AutoLogOutputDebugStringPrintf(
    IN PCTSTR pszFmt,
    IN ...
    )
{
    TCHAR szBuffer[4096] = {0};

    va_list pArgs;

    va_start(pArgs, pszFmt);

    _vsntprintf(szBuffer, COUNTOF(szBuffer), pszFmt, pArgs);

    OutputDebugString(szBuffer);

    va_end(pArgs);
}

VOID __cdecl
DbgStateC2CppExceptionTransFunc(
    IN UINT u,
    IN EXCEPTION_POINTERS* pExp
    )
{
    throw u;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\hresult.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    hresult.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "hresult.hxx"

#ifdef DBG

/********************************************************************

    THResult members

********************************************************************/

THResult::
THResult(
    IN HRESULT hResult
    ) : TStatusDerived<HRESULT>(hResult)
{
}

THResult::
~THResult(
    VOID
    )
{
}

BOOL
THResult::
IsErrorSevereEnough(
    VOID
    ) const
{
    HRESULT hResult = GetTStatusBase();

    return FAILED(hResult);
}

PCTSTR
THResult::
GetErrorServerityDescription(
    VOID
    ) const
{
    HRESULT hResult = GetTStatusBase();

    return SUCCEEDED(hResult) ? TEXT("SUCCEEDED") : TEXT("FAILED");
}

#endif // DBG

EXTERN_C
HRESULT
HResultFromWin32(
    IN DWORD dwError
    )
{
    return HRESULT_FROM_WIN32(dwError);
}

EXTERN_C
HRESULT
GetLastErrorAsHResult(
    VOID
    )
{
    return HResultFromWin32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\common.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    common.cxx

Abstract:

    utils

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "common.hxx"

BOOL
DllMainDefaultHandler(
    IN HANDLE hModule,
    IN DWORD dwReason,
    IN DWORD dwReserved
    )
{
    static CHAR szPrompt[MAX_PATH] = {0};

    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        DebugPrintf(SSPI_LOG, "DllMainDefaultHandler: DLL_PROCESS_DETACH\n");
        DebugLogClose();
        break;

    case DLL_PROCESS_ATTACH:
        {
            PSTR pszFileName = NULL;
            CHAR szDllPath[MAX_PATH] = {0};

            if (0 == GetModuleFileNameA(reinterpret_cast<HMODULE>(hModule), szDllPath, sizeof (szDllPath)))
            {
                DebugPrintf(SSPI_ERROR,
                            "GetModuleFileNameA failed with last error %#x\n",
                            GetLastError());
                return FALSE;
            }

            pszFileName = strrchr (szDllPath, '\\') + 1;

            if (!pszFileName)
            {
                pszFileName = szDllPath;
            }

            _snprintf(szPrompt, sizeof(szPrompt) - 1, "[%s] ", pszFileName);

            DebugLogOpen(szPrompt, -1);
        }

        DisableThreadLibraryCalls(reinterpret_cast<HMODULE>(hModule));

        DebugPrintf(SSPI_LOG, "DllMainDefaultHandler: DLL_PROCESS_ATTACH\n");

        break;

    default:
        break;
    }

    UNREFERENCED_PARAMETER(dwReserved);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\kerberr.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    kerberr.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "kerberr.hxx"

#ifdef DBG

/********************************************************************

    TKerbErr members

********************************************************************/

TKerbErr::
TKerbErr(
    IN KERBERR KerbErr
    ) : TStatusDerived<KERBERR>(KerbErr)
{
}

TKerbErr::
~TKerbErr(
    VOID
    )
{
}

BOOL
TKerbErr::
IsErrorSevereEnough(
    VOID
    ) const
{
    KERBERR KerbErr = GetTStatusBase();

    return !KERB_SUCCESS(KerbErr);
}

PCTSTR
TKerbErr::
GetErrorServerityDescription(
    VOID
    ) const
{
    KERBERR KerbErr = GetTStatusBase();

    return KERB_SUCCESS(KerbErr) ? TEXT("KERB_SUCCESS") : TEXT("KERB_ERROR");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\kbfiltr\sspioutput.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    sspioutput.cxx

Abstract:

    sspioutput

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

// #include "precomp.hxx"
// #pragma hdrstop

extern "C" {
#define SECURITY_KERNEL
#include <ntosp.h>
#include <zwapi.h>
#include <security.h>
#include <ntlmsp.h>

#include <string.h>
#include <wcstr.h>
#include <ntiologc.h>
#include <tchar.h>
}

#include "sspioutput.hxx"
#include "ntstatus.hxx"

TSspiLibarayGlobals g_SspiGlobals = {
    1,    // major version
    2,    // minor version
    0xF,  // debug mask
    TEXT("SSPI"), // debug prompt
};

#if defined(UNICODE) || defined(_UNICODE)
#define lstrlen wcslen
#endif

WCHAR SspiToChar(IN UCHAR c)
{
    UCHAR* pChar = &c;

    if ((c >= ' ') && (c <= '~'))
    {
        return RtlAnsiCharToUnicodeChar(&pChar);
    }

    return TEXT('.');
}

VOID SspiSpaceIt(IN ULONG cchLen, IN TCHAR* buf)
{
    for (ULONG i = 0; i < cchLen; i++)
    {
        buf[i] = TEXT(' ');
    }
}

TCHAR SspiToHex(
    IN ULONG c
    )
{
    static PCTSTR pszDigits = TEXT("0123456789abcdef");
    static ULONG len = lstrlen(pszDigits);

    if (c <= len)
    { // c >= 0
        return pszDigits[c];
    }

    return TEXT('*');
}

VOID
SspiPrintHex(
    IN ULONG ulLevel,
    IN OPTIONAL PCTSTR pszBanner,
    IN ULONG cbBuffer,
    IN const VOID* pvbuffer
    )
{
    if (g_SspiGlobals.uDebugMask & ulLevel)
    {
        const UCHAR* pBuffer = reinterpret_cast<const UCHAR*>(pvbuffer);
        ULONG high = 0;
        ULONG low = 0;
        TCHAR szLine[256] = {0};
        ULONG i = 0;

        OutputDebugString(pszBanner);
        OutputDebugString(TEXT("\n"));

        SspiSpaceIt(72, szLine);

        for (i = 0; i < cbBuffer; i++)
        {
            high = pBuffer[i] / 16;
            low = pBuffer[i] % 16;

            szLine[3 * (i % 16)] = SspiToHex(high);
            szLine[3 * (i % 16) + 1] = SspiToHex(low);
            szLine [52 + (i % 16)] = SspiToChar(pBuffer[i]);

            if (i % 16 == 7  && i != (cbBuffer - 1))
            {
                szLine[3 * (i % 16) + 2] = TEXT('-');
            }

            if (i % 16 == 15)
            {
                OutputDebugString(szLine);
                OutputDebugString(TEXT("\n"));
                SspiSpaceIt(72, szLine);
            }
        }

        OutputDebugString(szLine);
        OutputDebugString(TEXT("\n"));
    }
}

PCTSTR
SspiLevel2Str(
    IN ULONG ulLevel
    )
{
    PCTSTR pszText = NULL;

    switch (ulLevel)
    {
    case SSPI_WARN:
        pszText = TEXT("[warn]");
        break;

    case SSPI_ERROR:
        pszText = TEXT("[error]");
        break;

    case SSPI_LOG:
        pszText = TEXT("[log]");
        break;

    case SSPI_LOG_MORE:
        pszText = TEXT("[more]");
        break;
    case SSPI_MSG:
        pszText = TEXT("[msg]");
        break;

    default:
        pszText = TEXT("[invalid]");
        break;
    }

    return pszText;
}

VOID
SspiLogOpen(
    IN PCTSTR pszPrompt,
    IN ULONG ulMask
    )
{
    g_SspiGlobals.uDebugMask = ulMask;
    g_SspiGlobals.pszDbgPrompt = pszPrompt;
}

VOID
SspiLogClose(
    VOID
    )
{
    g_SspiGlobals.uDebugMask = 0;
    g_SspiGlobals.pszDbgPrompt = NULL;
}

VOID
SspiPrint(
    IN ULONG ulLevel,
    IN PCTSTR pszOutput
    )
{
    if (g_SspiGlobals.uDebugMask & ulLevel)
    {
        OutputDebugString(pszOutput);
    }
}

void OutputDebugString(PCTSTR pszBuff)
{
    #if defined(UNICODE) || defined(_UNICODE)

        UNICODE_STRING Buff = {0};
        ANSI_STRING AnsiBuff = {0};

        RtlInitUnicodeString(&Buff, pszBuff);

        RtlUnicodeStringToAnsiString(&AnsiBuff, &Buff, TRUE);

        DebugPrint((AnsiBuff.Buffer));

        RtlFreeAnsiString(&AnsiBuff);

    #else

       DebugPrint((pszBuff));

    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\impersonation.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    impersonation.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             January 1, 2002 Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "impersonation.hxx"

TImpersonation::TImpersonation(
    IN OPTIONAL HANDLE hToken
    ) : m_hTokenOld(NULL),
    m_bIsOldTokenValid(FALSE),
    m_hTokenNew(hToken),
    m_Status(STATUS_UNSUCCESSFUL)
{
    m_Status DBGCHK = Initialize();
}

TImpersonation::~TImpersonation(
    VOID
    )
{
    if ( m_bIsOldTokenValid && ((NULL != m_hTokenOld) || (NULL != m_hTokenNew)) )
    {
        TNtStatus Status;

        Status DBGCHK = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &m_hTokenOld,
            sizeof(HANDLE)
            );
        if (NT_SUCCESS(Status))
        {
            SspiPrint(SSPI_LOG,
                TEXT("TImpersonation::~TImpersonation restores thread token from %p to m_hTokenOld %p\n"),
                m_hTokenNew, m_hTokenOld);
        }
   }

   if (m_hTokenOld)
   {
       NtClose(m_hTokenOld);
   }
}

NTSTATUS
TImpersonation::Validate(
    VOID
    ) const
{
    return m_Status;
}

/******************************************************************************

    Private Methods

******************************************************************************/
NTSTATUS
TImpersonation::Initialize(
    VOID
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    DBGCFG1(Status, STATUS_NO_TOKEN);

    Status DBGCHK = NtOpenThreadToken(
        NtCurrentThread(),
        TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE,
        TRUE,
        &m_hTokenOld
        );
    if (Status == STATUS_NO_TOKEN)
    {
        m_hTokenOld = NULL;
        m_bIsOldTokenValid = TRUE;

        Status DBGCHK = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(Status))
    {
        m_bIsOldTokenValid = TRUE;

        HANDLE hNullToken = NULL;
        Status DBGCHK = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hNullToken,
            sizeof(HANDLE)
            );
    }

    if ( NT_SUCCESS(Status) && ((NULL != m_hTokenOld) || (NULL != m_hTokenNew)) )
    {
        SspiPrint(SSPI_LOG, TEXT("TImpersonation::Initialize impersonating token new %p, old %p\n"), m_hTokenNew, m_hTokenOld);
        Status DBGCHK = Impersonate(m_hTokenNew);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\logon.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    logon.cxx

Abstract:

    logon

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "logon.hxx"

NTSTATUS
LogonUserWrapper(
    IN PCWSTR pszUserName,
    IN PCWSTR pszDomainName,
    IN PCWSTR pszPassword,
    IN DWORD LogonType,
    IN DWORD dwLogonProvider,
    OUT HANDLE* phToken
    )
{
    THResult hResult = S_OK;

    PSID pLoginSid = NULL;
    VOID* pProfile = NULL;
    ULONG cbProfile = 0;
    QUOTA_LIMITS Quotas = {0};

    DebugPrintf(SSPI_LOG, "LogonUserWrapper UserName %ws, DomainName %ws, Password %ws, LogonType %#x, Provider %#x\n",
        pszUserName, pszDomainName, pszPassword, LogonType, dwLogonProvider);

    hResult DBGCHK = LogonUserExW(
                        (PWSTR) pszUserName,
                        (PWSTR) pszDomainName,
                        (PWSTR) pszPassword,
                        LogonType,
                        dwLogonProvider,
                        phToken,
                        &pLoginSid,
                        &pProfile,
                        &cbProfile,
                        &Quotas
                        ) ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hResult))
    {
        DebugPrintSidFriendlyName(SSPI_LOG, "LogonSid:", pLoginSid);
        DebugPrintProfileAndQuotas(SSPI_LOG, pProfile, &Quotas);

        DebugPrintf(SSPI_LOG, "LogonUserWrapper TokenHandle %p\n", *phToken);
    }

    if (pLoginSid)
    {
        LsaFreeReturnBuffer(pLoginSid);
    }

    if (pProfile)
    {
        LsaFreeReturnBuffer(pProfile);
    }

    return SUCCEEDED(hResult) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

VOID
DebugPrintProfileAndQuotas(
    IN ULONG Level,
    IN OPTIONAL VOID* pProfile,
    IN OPTIONAL QUOTA_LIMITS* pQuotas
    )
{

    if (pQuotas)
    {
        DebugPrintf(Level, "Quotas PagedPoolLimit %p, NonPagedPoolLimit %p, "
            "MinimumWorkingSetSize %p, MaximumWorkingSetSize %p, PagedPoolLimit %p\n",
            pQuotas->PagedPoolLimit, pQuotas->NonPagedPoolLimit,
            pQuotas->MinimumWorkingSetSize, pQuotas->MaximumWorkingSetSize,
            pQuotas->PagedPoolLimit);
        DebugPrintSysTimeAsLocalTime(Level, "TimeLimit", &pQuotas->TimeLimit);
    }

    if (pProfile)
    {
        if (MsV1_0InteractiveProfile  == *((ULONG*) pProfile))
        {
            MSV1_0_INTERACTIVE_PROFILE* pMsvInteractiveProfile = (MSV1_0_INTERACTIVE_PROFILE*) pProfile;
            DebugPrintf(Level, "MsV1_0InteractiveProfile: "
                "LogonCount %#x, BadPasswordCount %#x, LogonScript %wZ, "
                "HomeDirectory %wZ, FullName %wZ, ProfilePath %wZ, "
                "HomeDriectoryDrive %wZ, LogonServer %wZ, UserFlags %#x\n",
                 pMsvInteractiveProfile->LogonCount,
                 pMsvInteractiveProfile->BadPasswordCount,
                 &pMsvInteractiveProfile->LogonScript,
                 &pMsvInteractiveProfile->HomeDirectory,
                 &pMsvInteractiveProfile->FullName,
                 &pMsvInteractiveProfile->ProfilePath,
                 &pMsvInteractiveProfile->HomeDirectoryDrive,
                 &pMsvInteractiveProfile->LogonServer,
                 pMsvInteractiveProfile->UserFlags);
            DebugPrintSysTimeAsLocalTime(Level, "LogonTime", &pMsvInteractiveProfile->LogonTime);
            DebugPrintSysTimeAsLocalTime(Level, "LogoffTime", &pMsvInteractiveProfile->LogoffTime);
            DebugPrintSysTimeAsLocalTime(Level, "KickOffTime", &pMsvInteractiveProfile->KickOffTime );
            DebugPrintSysTimeAsLocalTime(Level, "PasswordLastSet", &pMsvInteractiveProfile->PasswordLastSet );
            DebugPrintSysTimeAsLocalTime(Level, "PasswordCanChange", &pMsvInteractiveProfile->PasswordCanChange );
            DebugPrintSysTimeAsLocalTime(Level, "PasswordMustChange", &pMsvInteractiveProfile->PasswordMustChange );
        }
        else if (MsV1_0Lm20LogonProfile == *((ULONG*) pProfile))
        {
            MSV1_0_LM20_LOGON_PROFILE* pMsvLm20LogonProfile = (MSV1_0_LM20_LOGON_PROFILE*) pProfile;
            DebugPrintf(Level, "MsV1_0Lm20LogonProfile: "
                "UserFlags %#x, LogonDomainName %wZ, LogonServer %wZ, UserParameters %#x\n",
                pMsvLm20LogonProfile->UserFlags,
                &pMsvLm20LogonProfile->LogonDomainName,
                &pMsvLm20LogonProfile->LogonServer,
                pMsvLm20LogonProfile->UserParameters);
            DebugPrintHex(Level, "UserSessionKey:", MSV1_0_USER_SESSION_KEY_LENGTH, pMsvLm20LogonProfile->UserSessionKey);
            DebugPrintHex(Level, "LanmanSessionKey:", MSV1_0_LANMAN_SESSION_KEY_LENGTH, pMsvLm20LogonProfile->LanmanSessionKey);
            DebugPrintSysTimeAsLocalTime(Level, "KickOffTime", &pMsvLm20LogonProfile->KickOffTime);
            DebugPrintSysTimeAsLocalTime(Level, "LogoffTime", &pMsvLm20LogonProfile->LogoffTime);
        }
        else if (KerbInteractiveProfile == *((ULONG*) pProfile))
        {
            KERB_TICKET_PROFILE* pKerbTicketProfile = (KERB_TICKET_PROFILE*) pProfile;
            KERB_INTERACTIVE_PROFILE* pKrbInteractiveProfile = &pKerbTicketProfile->Profile;
            DebugPrintf(Level, "KerbInteractiveProfile: "
                "LogCount %#x, BaddPasswordCount %#x, LogonScript %wZ, "
                "HomeDirectory %wZ, FullName %wZ, ProfilePath %wZ, "
                "HomeDriectoryDrive %wZ, LogonServer %wZ, UserFlags %#x\n",
                 pKrbInteractiveProfile->LogonCount,
                 pKrbInteractiveProfile->BadPasswordCount,
                 &pKrbInteractiveProfile->LogonScript,
                 &pKrbInteractiveProfile->HomeDirectory,
                 &pKrbInteractiveProfile->FullName,
                 &pKrbInteractiveProfile->ProfilePath,
                 &pKrbInteractiveProfile->HomeDirectoryDrive,
                 &pKrbInteractiveProfile->LogonServer,
                 pKrbInteractiveProfile->UserFlags);
            DebugPrintSysTimeAsLocalTime(Level, "LogonTime", &pKrbInteractiveProfile->LogonTime);
            DebugPrintSysTimeAsLocalTime(Level, "LogoffTime", &pKrbInteractiveProfile->LogoffTime);
            DebugPrintSysTimeAsLocalTime(Level, "KickOffTime", &pKrbInteractiveProfile->KickOffTime);
            DebugPrintSysTimeAsLocalTime(Level, "PasswordLastSet", &pKrbInteractiveProfile->PasswordLastSet);
            DebugPrintSysTimeAsLocalTime(Level, "PasswordCanChange", &pKrbInteractiveProfile->PasswordCanChange);
            DebugPrintSysTimeAsLocalTime(Level, "PasswordMustChange", &pKrbInteractiveProfile->PasswordMustChange);
            DebugPrintHex(Level, "SessionKey:", sizeof(pKerbTicketProfile->SessionKey), &pKerbTicketProfile->SessionKey);
        }
        else
        {
            DebugPrintf(SSPI_ERROR, "Unsupported profile type %#x\n", *((ULONG*) pProfile));
        }
    }
}

NTSTATUS
GetLm20LogonInfoNtlmv1(
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT ULONG* pcbLogonInfo,
    OUT PMSV1_0_LM20_LOGON *ppLognInfo
    )
{
    TNtStatus Status;

    PMSV1_0_LM20_LOGON pMsvNetAuthInfo = NULL;
    ULONG cbMsvNetAuthInfo;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING LmPassword;
    UCHAR LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;

    DebugPrintf(SSPI_LOG, "GetLm20LogonInfoNtlmv1 UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n",
        pUserName, pDomainName, pPassword, pWorkstation);

    *ppLognInfo = NULL;
    *pcbLogonInfo = 0;

    cbMsvNetAuthInfo = ROUND_UP_COUNT(sizeof(MSV1_0_LM20_LOGON), sizeof(ULONG_PTR))
        + pUserName->Length
        + pDomainName->Length
        + pWorkstation->Length
        + NT_RESPONSE_LENGTH
        + LM_RESPONSE_LENGTH;

    pMsvNetAuthInfo = (PMSV1_0_LM20_LOGON) new CHAR[cbMsvNetAuthInfo];

    Status DBGCHK = pMsvNetAuthInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        //
        // Start packing in the string
        //

        RtlZeroMemory(pMsvNetAuthInfo, cbMsvNetAuthInfo);

        pMsvNetAuthInfo->MessageType = MsV1_0NetworkLogon; // if set MsV1_0Lm20Logon, ignore ParameterControl

        //
        // Copy the user name into the authentication buffer
        //

        pMsvNetAuthInfo->UserName.Length = pUserName->Length;
        pMsvNetAuthInfo->UserName.MaximumLength = pMsvNetAuthInfo->UserName.Length;

        pMsvNetAuthInfo->UserName.Buffer = (PWSTR)(pMsvNetAuthInfo + 1); // could be aligned here
        RtlCopyMemory(
            pMsvNetAuthInfo->UserName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        //
        // Copy the domain name into the authentication buffer
        //

        pMsvNetAuthInfo->LogonDomainName.Length = pDomainName->Length;
        pMsvNetAuthInfo->LogonDomainName.MaximumLength = pDomainName->Length ;

        pMsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR) ((PBYTE)(pMsvNetAuthInfo->UserName.Buffer)
            + pMsvNetAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            pMsvNetAuthInfo->LogonDomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        //
        // Copy the workstation name into the buffer
        //

        pMsvNetAuthInfo->Workstation.Length = pWorkstation->Length;

        pMsvNetAuthInfo->Workstation.MaximumLength = pMsvNetAuthInfo->Workstation.Length;

        pMsvNetAuthInfo->Workstation.Buffer = (PWSTR) ((PBYTE) (pMsvNetAuthInfo->LogonDomainName.Buffer)
            + pMsvNetAuthInfo->LogonDomainName.MaximumLength);

        RtlCopyMemory(
            pMsvNetAuthInfo->Workstation.Buffer,
            pWorkstation->Buffer,
            pWorkstation->Length
            );

        RtlCopyMemory(pMsvNetAuthInfo->ChallengeToClient,
            ChallengeToClient,
            MSV1_0_CHALLENGE_LENGTH);

        //
        // Set up space for response
        //

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer =
            (((PCHAR) pMsvNetAuthInfo->Workstation.Buffer)
             + pMsvNetAuthInfo->Workstation.MaximumLength);

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Length = NT_RESPONSE_LENGTH;

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength = NT_RESPONSE_LENGTH;

        RtlCalculateNtOwfPassword(
            pPassword,
            &PasswordHash
            );

        RtlCalculateNtResponse(
            (PNT_CHALLENGE) ChallengeToClient,
            &PasswordHash,
            (PNT_RESPONSE) pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer
            );

        //
        // Now do the painful LM compatible hash, so anyone who is maintaining
        // their account from a WfW machine will still have a password.
        //

        LmPassword.Buffer = (PCHAR) LmPasswordBuf;
        LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

        Status DBGCHK = RtlUpcaseUnicodeStringToOemString(
            &LmPassword,
            pPassword,
            FALSE
            );
    }

    if (NT_SUCCESS(Status))
    {
        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer =
           ((PCHAR) (pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer)
            + pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength);

        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length = LM_RESPONSE_LENGTH;
        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength = LM_RESPONSE_LENGTH;

        RtlCalculateLmOwfPassword(
            LmPassword.Buffer,
            &LmPasswordHash
            );

        RtlZeroMemory(LmPassword.Buffer, LmPassword.Length);

        RtlCalculateLmResponse(
            (PLM_CHALLENGE) ChallengeToClient,
            &LmPasswordHash,
            (PLM_RESPONSE) pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer
            );

        *ppLognInfo = pMsvNetAuthInfo;
        pMsvNetAuthInfo = NULL;
        *pcbLogonInfo = cbMsvNetAuthInfo;

    }

    if (pMsvNetAuthInfo)
    {
        delete [] pMsvNetAuthInfo;
    }

    return Status;
}

VOID
CalculateNtlmv2Owf(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    OUT UCHAR Ntlmv2Owf[MSV1_0_NTLM3_OWF_LENGTH]
    )
{
    HMACMD5_CTX HMACMD5Context;

    //
    // reserve a scratch buffer
    //

    WCHAR szUserName[(UNLEN + 4)] = {0};
    UNICODE_STRING UserName = {0, sizeof(szUserName), szUserName};

    //
    //  first make a copy then upcase it
    //

    UserName.Length = min(UserName.MaximumLength, pUserName->Length);

    ASSERT(UserName.Length == pUserName->Length);

    RtlCopyMemory(UserName.Buffer, pUserName->Buffer, UserName.Length);

    RtlUpcaseUnicodeString(&UserName, &UserName, FALSE);

    //
    // Calculate Ntlmv2 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))
    //

    HMACMD5Init(
        &HMACMD5Context,
        (UCHAR *) pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) UserName.Buffer,
        UserName.Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlmv2Owf
        );
}

VOID
GetLmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT OPTIONAL USER_SESSION_KEY* pUserSessionKey,
    OUT OPTIONAL LM_SESSION_KEY* pLanmanSessionKey // [MSV1_0_LANMAN_SESSION_KEY_LENGTH]
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLM3_OWF_LENGTH];

    C_ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);

    //
    // get Ntlmv2 OWF
    //

    CalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );

    //
    // Calculate Ntlmv2 Response
    // HMAC(Ntlmv2Owf, (ChallengeToClient, ChallengeFromClient))
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    if (pUserSessionKey && pLanmanSessionKey)
    {
        // now compute the session keys
        //  HMAC(Kr, R)
        HMACMD5Init(
            &HMACMD5Context,
            Ntlmv2Owf,
            MSV1_0_NTLM3_OWF_LENGTH
            );

        HMACMD5Update(
            &HMACMD5Context,
            Response,
            MSV1_0_NTLM3_RESPONSE_LENGTH
            );

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

        HMACMD5Final(
            &HMACMD5Context,
            (PUCHAR)pUserSessionKey
            );

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(
            pLanmanSessionKey,
            pUserSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );
    }
}

VOID
Lm20GetNtlmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN STRING* pTargetInfo,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT MSV1_0_NTLM3_RESPONSE* pNtlmv2Response,
    OUT MSV1_0_LM3_RESPONSE* pLmv2Response,
    OUT USER_SESSION_KEY* pNtUserSessionKey,
    OUT LM_SESSION_KEY* pLmSessionKey
    )
{
    //
    // fill in version numbers, timestamp, and client's challenge
    //

    pNtlmv2Response->RespType = 1;
    pNtlmv2Response->HiRespType = 1;
    pNtlmv2Response->Flags = 0;
    pNtlmv2Response->MsgWord = 0;

    GetSystemTimeAsFileTime((FILETIME*)(&pNtlmv2Response->TimeStamp));

    RtlGenRandom(pNtlmv2Response->ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);

    RtlCopyMemory(pNtlmv2Response->Buffer, pTargetInfo->Buffer, pTargetInfo->Length);

    //
    // Calculate Ntlmv2 response, filling in response field
    //

    GetNtlmv2Response(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        pTargetInfo->Length,
        ChallengeToClient,
        pNtlmv2Response,
        pNtUserSessionKey,
        pLmSessionKey
        );

    //
    // Use same challenge to compute the LMV2 response
    //

    RtlCopyMemory(pLmv2Response->ChallengeFromClient, pNtlmv2Response->ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);

    //
    // Calculate LMV2 response
    //

    GetLmv2Response(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        ChallengeToClient,
        pLmv2Response->ChallengeFromClient,
        pLmv2Response->Response,
        NULL,
        NULL
        );
}

VOID
GetNtlmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN ULONG TargetInfoLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN OUT MSV1_0_NTLM3_RESPONSE* pNtlmv2Response,
    OUT USER_SESSION_KEY* pNtUserSessionKey,
    OUT LM_SESSION_KEY* pLmSessionKey
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLM3_OWF_LENGTH];

    C_ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);
    C_ASSERT(MD5DIGESTLEN == sizeof(USER_SESSION_KEY));
    C_ASSERT(sizeof(LM_SESSION_KEY) <= sizeof(USER_SESSION_KEY));

    //
    // get Ntlmv2 OWF
    //

    CalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        &pNtlmv2Response->RespType,
        (MSV1_0_NTLM3_INPUT_LENGTH + TargetInfoLength)
        );

    HMACMD5Final(
        &HMACMD5Context,
        pNtlmv2Response->Response
        );

    //
    // now compute the session keys
    //  HMAC(Kr, R)
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        pNtlmv2Response->Response,
        MSV1_0_NTLM3_RESPONSE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        (UCHAR*) pNtUserSessionKey
        );

    RtlCopyMemory(pLmSessionKey, pNtUserSessionKey, sizeof(LM_SESSION_KEY));
}

NTSTATUS
GetLm20LogonInfoNtlmv2(
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation,
    IN OPTIONAL UNICODE_STRING* pTargetName,
    IN OPTIONAL STRING* pTargetInfo,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT ULONG* pcbLogonInfo,
    OUT PMSV1_0_LM20_LOGON *ppLognInfo
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    STRING TargetInfo = {0};

    PMSV1_0_LM20_LOGON pMsvNetAuthInfo = NULL;
    ULONG cbMsvNetAuthInfo = 0;
    NT_OWF_PASSWORD NtOwfPassword;
    USER_SESSION_KEY NtUserSessionKey;
    LM_SESSION_KEY LmSessionKey;
    MSV1_0_LM3_RESPONSE Lmv2Response;
    MSV1_0_NTLM3_RESPONSE* pNtlmv2Reponse = NULL;
    ULONG cbNtlmv2Response = 0;

    DebugPrintf(SSPI_LOG, "GetLm20LogonInfoNtlmv2 UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n",
        pUserName, pDomainName, pPassword, pWorkstation);

    *ppLognInfo = NULL;
    *pcbLogonInfo = 0;

    RtlCalculateNtOwfPassword(
        pPassword,
        &NtOwfPassword
        );

    if (pTargetInfo)
    {
        TargetInfo = *pTargetInfo;
    }
    else if (pTargetName)
    {
        Status DBGCHK = CreateTargetInfo(pTargetName, &TargetInfo);
    }

    if (NT_SUCCESS(Status))
    {
        cbNtlmv2Response = ROUND_UP_COUNT(sizeof(MSV1_0_NTLM3_RESPONSE), sizeof(ULONG_PTR)) + TargetInfo.Length;
        pNtlmv2Reponse = (MSV1_0_NTLM3_RESPONSE*) new CHAR[cbNtlmv2Response];
        Status DBGCHK = pNtlmv2Reponse ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        Lm20GetNtlmv2Response(
            &NtOwfPassword,
            pUserName,
            pDomainName,
            &TargetInfo,
            ChallengeToClient,
            pNtlmv2Reponse,
            &Lmv2Response,
            &NtUserSessionKey,
            &LmSessionKey
            );
        cbMsvNetAuthInfo = ROUND_UP_COUNT(sizeof(MSV1_0_LM20_LOGON), sizeof(ULONG_PTR))
            + pUserName->Length
            + pDomainName->Length
            + pWorkstation->Length
            + cbNtlmv2Response
            + sizeof(Lmv2Response);

        pMsvNetAuthInfo = (PMSV1_0_LM20_LOGON) new CHAR[cbMsvNetAuthInfo];

        Status DBGCHK = pMsvNetAuthInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Start packing in the string
        //

        RtlZeroMemory(pMsvNetAuthInfo, cbMsvNetAuthInfo);

        pMsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

        //
        // Copy the user name into the authentication buffer
        //

        pMsvNetAuthInfo->UserName.Length = pUserName->Length;
        pMsvNetAuthInfo->UserName.MaximumLength = pMsvNetAuthInfo->UserName.Length;

        pMsvNetAuthInfo->UserName.Buffer = (PWSTR) (pMsvNetAuthInfo + 1); // could be aligned here
        RtlCopyMemory(
            pMsvNetAuthInfo->UserName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        //
        // Copy the domain name into the authentication buffer
        //

        pMsvNetAuthInfo->LogonDomainName.Length = pDomainName->Length;
        pMsvNetAuthInfo->LogonDomainName.MaximumLength = pDomainName->Length ;

        pMsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR) ((PBYTE)(pMsvNetAuthInfo->UserName.Buffer)
            + pMsvNetAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            pMsvNetAuthInfo->LogonDomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        //
        // Copy the workstation name into the buffer
        //

        pMsvNetAuthInfo->Workstation.Length = pWorkstation->Length;

        pMsvNetAuthInfo->Workstation.MaximumLength = pMsvNetAuthInfo->Workstation.Length;

        pMsvNetAuthInfo->Workstation.Buffer = (PWSTR) ((PBYTE) (pMsvNetAuthInfo->LogonDomainName.Buffer)
            + pMsvNetAuthInfo->LogonDomainName.MaximumLength );

        RtlCopyMemory(
            pMsvNetAuthInfo->Workstation.Buffer,
            pWorkstation->Buffer,
            pWorkstation->Length
            );

        RtlCopyMemory(pMsvNetAuthInfo->ChallengeToClient,
            ChallengeToClient,
            MSV1_0_CHALLENGE_LENGTH);

        //
        // Set up space for response
        //

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer =
            ((PCHAR) (pMsvNetAuthInfo->Workstation.Buffer)
            + pMsvNetAuthInfo->Workstation.MaximumLength);

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Length = (USHORT) cbNtlmv2Response;

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength = (USHORT) cbNtlmv2Response;

        RtlCopyMemory(
            pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer,
            pNtlmv2Reponse,
            cbNtlmv2Response
            );

        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer =
           ((PCHAR) (pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer)
            + pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length = sizeof(Lmv2Response);

        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength = sizeof(Lmv2Response);

        RtlCopyMemory(
            pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer,
            &Lmv2Response,
            sizeof(Lmv2Response)
            );

        *ppLognInfo = pMsvNetAuthInfo;
        pMsvNetAuthInfo = NULL;
        *pcbLogonInfo = cbMsvNetAuthInfo;

    }

    if (pMsvNetAuthInfo)
    {
        delete [] pMsvNetAuthInfo;
    }

    if (pNtlmv2Reponse)
    {
        delete [] pNtlmv2Reponse;
    }

    return Status;
}

NTSTATUS
GetMsvInteractiveLogonInfo(
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UNICODE_STRING* pPassword,
    OUT ULONG* pcbLogonInfo,
    OUT MSV1_0_INTERACTIVE_LOGON** ppLogonInfo
    )
{
    TNtStatus Status;
    ULONG cbLogonInfo = 0;

    UCHAR* pWhere = NULL;
    MSV1_0_INTERACTIVE_LOGON* pLogonInfo = NULL;

    DebugPrintf(SSPI_LOG, "GetMsvInteractiveLogonInfo UserName %wZ, LogonDomainName %wZ, Password %wZ\n",
        pUserName, pLogonDomainName, pPassword);
    cbLogonInfo = ROUND_UP_COUNT(sizeof(MSV1_0_INTERACTIVE_LOGON), sizeof(ULONG_PTR))
        + pUserName->Length
        + pLogonDomainName->Length
        + pPassword->Length;

    pLogonInfo = (MSV1_0_INTERACTIVE_LOGON*) new CHAR[cbLogonInfo];

    Status DBGCHK = pLogonInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        pLogonInfo->MessageType = MsV1_0InteractiveLogon;

        pWhere = (PUCHAR) (pLogonInfo + 1);

        pLogonInfo->UserName.Buffer = (PWSTR) pWhere;
        pLogonInfo->UserName.MaximumLength = pUserName->Length;
        pLogonInfo->UserName.Length = pUserName->Length;

        RtlCopyMemory(pLogonInfo->UserName.Buffer,
            pUserName->Buffer,
            pUserName->Length);

        pWhere += pLogonInfo->UserName.Length;

        pLogonInfo->LogonDomainName.Buffer = (PWSTR) pWhere;
        pLogonInfo->LogonDomainName.MaximumLength = pLogonDomainName->Length;
        pLogonInfo->LogonDomainName.Length = pLogonDomainName->Length;

        RtlCopyMemory(pLogonInfo->LogonDomainName.Buffer,
            pLogonDomainName->Buffer,
            pLogonDomainName->Length);

        pWhere += pLogonInfo->LogonDomainName.Length;

        pLogonInfo->Password.Buffer = (PWSTR) pWhere;
        pLogonInfo->Password.MaximumLength = pPassword->Length;
        pLogonInfo->Password.Length = pPassword->Length;

        RtlCopyMemory(pLogonInfo->Password.Buffer,
            pPassword->Buffer,
            pPassword->Length);

        pWhere += pLogonInfo->Password.Length;

        *ppLogonInfo = pLogonInfo;
        pLogonInfo = NULL;
        *pcbLogonInfo = cbLogonInfo;
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}

NTSTATUS
GetKrbS4U2SelfLogonInfo(
    IN UNICODE_STRING* pClientUpn,
    IN OPTIONAL UNICODE_STRING* pClientRealm,
    IN ULONG Flags,
    OUT ULONG* pcbLogonInfo,
    OUT KERB_S4U_LOGON** ppLogonInfo
    )
{
    TNtStatus Status;
    ULONG cbLogonInfo = 0;

    WCHAR* pWhere = NULL;
    KERB_S4U_LOGON* pLogonInfo = NULL;

    DebugPrintf(SSPI_LOG, "GetKrbS4U2SelfLogonInfo ClientUpn %wZ, ClientRealm %wZ, Flags %#x\n",
        pClientUpn, pClientRealm, Flags);

    cbLogonInfo = ROUND_UP_COUNT(sizeof(KERB_S4U_LOGON), sizeof(ULONG_PTR))
        + pClientUpn->Length + sizeof(WCHAR)
        + (pClientRealm ? pClientRealm->Length : 0) + sizeof(WCHAR);
    pLogonInfo = (KERB_S4U_LOGON*) new CHAR[cbLogonInfo];

    Status DBGCHK = pLogonInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pLogonInfo, cbLogonInfo);

        pLogonInfo->MessageType = KerbS4ULogon;

        pWhere = (PWCHAR) (pLogonInfo + 1);

        PackUnicodeStringAsUnicodeStringZ(pClientUpn, &pWhere, &pLogonInfo->ClientUpn);

        if (pClientRealm)
        {
            PackUnicodeStringAsUnicodeStringZ(pClientRealm, &pWhere, &pLogonInfo->ClientRealm);
        }

        pLogonInfo->Flags = Flags;

        *ppLogonInfo = pLogonInfo;
        pLogonInfo = NULL;
        *pcbLogonInfo = cbLogonInfo;
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}

NTSTATUS
GetKrbInteractiveLogonInfo(
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UNICODE_STRING* pPassword,
    OUT ULONG* pcbLogonInfo,
    OUT KERB_INTERACTIVE_LOGON** ppLogonInfo
    )
{
    TNtStatus Status;
    ULONG cbLogonInfo = 0;

    UCHAR* pWhere = NULL;
    KERB_INTERACTIVE_LOGON* pLogonInfo = NULL;

    DebugPrintf(SSPI_LOG, "GetKrbInteractiveLogonInfo UserName %wZ, LogonDomainName %wZ, Password %wZ\n",
        pUserName, pLogonDomainName, pPassword);

    cbLogonInfo = ROUND_UP_COUNT(sizeof(KERB_INTERACTIVE_LOGON), sizeof(ULONG_PTR))
        + pUserName->Length
        + pLogonDomainName->Length
        + pPassword->Length;

    pLogonInfo = (KERB_INTERACTIVE_LOGON*) new CHAR[cbLogonInfo];

    Status DBGCHK = pLogonInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        pLogonInfo->MessageType = KerbInteractiveLogon;

        pWhere = (PUCHAR) (pLogonInfo + 1);

        pLogonInfo->UserName.Buffer = (PWSTR) pWhere;
        pLogonInfo->UserName.MaximumLength = pUserName->Length;
        pLogonInfo->UserName.Length = pUserName->Length;

        RtlCopyMemory(pLogonInfo->UserName.Buffer,
            pUserName->Buffer,
            pUserName->Length);

        pWhere += pLogonInfo->UserName.Length;

        pLogonInfo->LogonDomainName.Buffer = (PWSTR) pWhere;
        pLogonInfo->LogonDomainName.MaximumLength = pLogonDomainName->Length;
        pLogonInfo->LogonDomainName.Length = pLogonDomainName->Length;

        RtlCopyMemory(pLogonInfo->LogonDomainName.Buffer,
            pLogonDomainName->Buffer,
            pLogonDomainName->Length);

        pWhere += pLogonInfo->LogonDomainName.Length;

        pLogonInfo->Password.Buffer = (PWSTR) pWhere;
        pLogonInfo->Password.MaximumLength = pPassword->Length;
        pLogonInfo->Password.Length = pPassword->Length;

        RtlCopyMemory(pLogonInfo->Password.Buffer,
            pPassword->Buffer,
            pPassword->Length);

        pWhere += pLogonInfo->Password.Length;

        *ppLogonInfo = pLogonInfo;
        pLogonInfo = NULL;
        *pcbLogonInfo = cbLogonInfo;
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}

NTSTATUS
KrbLsaLogonUser(
    IN HANDLE hLsa,
    IN ULONG PackageId,
    IN SECURITY_LOGON_TYPE LogonType,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN ULONG Flags,
    OUT HANDLE* phToken
    )
{
    TNtStatus Status;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    PVOID pLogonInfo = NULL;
    ULONG cbLogonInfo = 0;

    LSA_STRING Name = {0};

    TOKEN_SOURCE SourceContext = {0};
    KERB_TICKET_PROFILE* pKerbTicketProfile = NULL;
    ULONG cbProfileSize = 0;
    LUID LogonId = {0};
    QUOTA_LIMITS Quotas = {0};

    DebugPrintf(SSPI_LOG, "KrbLsaLogonUser PackageId %#x, LogonType %#x, "
        "UserName %wZ, DomainName %wZ, Password %wZ\n",
        PackageId, LogonType, pUserName,
        pDomainName, pPassword);

    switch (LogonType)
    {
    case Network:
        Status DBGCHK = GetKrbS4U2SelfLogonInfo(
                            pUserName,
                            pDomainName,
                            Flags,
                            &cbLogonInfo,
                            (KERB_S4U_LOGON**) &pLogonInfo
                            );
        break;

    case Interactive:
    case CachedInteractive:
    case RemoteInteractive:
    case Unlock:
    default:
        Status DBGCHK = GetKrbInteractiveLogonInfo(
                            pUserName,
                            pDomainName,
                            pPassword,
                            &cbLogonInfo,
                            (KERB_INTERACTIVE_LOGON**) &pLogonInfo
                            );
        break;
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrintHex(SSPI_LOG, TEXT("KrbLsaLogonUser LogonInfo"), cbLogonInfo, pLogonInfo);

        strncpy(
            SourceContext.SourceName,
            "ssptest",
            sizeof(SourceContext.SourceName)
            );
        NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

        //
        // Now call LsaLogonUser
        //

        RtlInitString(
            &Name,
            "ssptest"
            );

        Status DBGCHK = LsaLogonUser(
                            hLsa,
                            &Name,
                            LogonType,
                            PackageId,
                            pLogonInfo,
                            cbLogonInfo,
                            NULL, // no token groups
                            &SourceContext,
                            (VOID**) &pKerbTicketProfile,
                            &cbProfileSize,
                            &LogonId,
                            phToken,
                            &Quotas,
                            &SubStatus
                            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", LogonId.HighPart, LogonId.LowPart);
        DebugPrintf(SSPI_LOG, "TokenHandle %p\n", *phToken);
        DebugPrintProfileAndQuotas(SSPI_LOG, pKerbTicketProfile, &Quotas);
    }

    if (pKerbTicketProfile)
    {
        LsaFreeReturnBuffer(pKerbTicketProfile);
    }

    return Status;
}

NTSTATUS
MsvLsaLogonUser(
    IN HANDLE hLsa,
    IN ULONG PackageId,
    IN SECURITY_LOGON_TYPE LogonType,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation,
    IN ELogonTypeSubType SubType,
    OUT HANDLE* phToken
    )
{
    TNtStatus Status;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    PVOID pLogonInfo = NULL;
    ULONG cbLogonInfo = 0;
    LSA_STRING Name = {0};

    TOKEN_SOURCE SourceContext = {0};
    VOID* pProfile = NULL;
    ULONG cbProfileSize = 0;
    LUID LogonId = {0};
    QUOTA_LIMITS Quotas = {0};
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH] = {0};

    DebugPrintf(SSPI_LOG, "MsvLsaLogonUser PackageId %#x, LogonType %#x, SubType %#x, "
        "UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n",
        PackageId, LogonType, SubType, pUserName,
        pDomainName, pPassword, pWorkstation);

    RtlGenRandom(ChallengeToClient, sizeof(ChallengeToClient));

    switch (LogonType)
    {
    case Network:
        switch (SubType)
        {
        case kNetworkLogonNtlmv1:
            Status DBGCHK = GetLm20LogonInfoNtlmv1(
                                pUserName,
                                pDomainName,
                                pPassword,
                                pWorkstation,
                                ChallengeToClient,
                                &cbLogonInfo,
                                (MSV1_0_LM20_LOGON **) &pLogonInfo
                                );
            break;

        case kNetworkLogonNtlmv2:
            Status DBGCHK = GetLm20LogonInfoNtlmv2(
                                pUserName,
                                pDomainName,
                                pPassword,
                                pWorkstation,
                                NULL, // no target name
                                NULL, // no target info
                                ChallengeToClient,
                                &cbLogonInfo,
                                (MSV1_0_LM20_LOGON **) &pLogonInfo
                                );
            break;

        case kSubAuthLogon:
        default:
            Status DBGCHK = STATUS_NOT_SUPPORTED;
            break;
        }

        break;

    case Interactive:
    case CachedInteractive:
    case RemoteInteractive:
    case Unlock:
    default:
        Status DBGCHK = GetMsvInteractiveLogonInfo(
                            pUserName,
                            pDomainName,
                            pPassword,
                            &cbLogonInfo,
                            (MSV1_0_INTERACTIVE_LOGON **) &pLogonInfo
                            );
        break;
    }

    if (NT_SUCCESS(Status))
    {
        strncpy(
            SourceContext.SourceName,
            "ssptest",
            sizeof(SourceContext.SourceName)
            );
        NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

        //
        // Now call LsaLogonUser
        //

        RtlInitString(
            &Name,
            "ssptest"
            );

        Status DBGCHK = LsaLogonUser(
                            hLsa,
                            &Name,
                            LogonType,
                            PackageId,
                            pLogonInfo,
                            cbLogonInfo,
                            NULL, // no token groups
                            &SourceContext,
                            (VOID**) &pProfile,
                            &cbProfileSize,
                            &LogonId,
                            phToken,
                            &Quotas,
                            &SubStatus
                            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", LogonId.HighPart, LogonId.LowPart);
        DebugPrintf(SSPI_LOG, "TokenHandle %p\n", *phToken);
        DebugPrintProfileAndQuotas(SSPI_LOG, pProfile, &Quotas);
    }

    if (pProfile)
    {
        LsaFreeReturnBuffer(pProfile);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\ntstatus.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    ntstatus.cxx

Abstract:

    auto log

Author:

    Larry Zhu (LZhu)                     December 6, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "ntstatus.hxx"

#ifdef DBG

#if 0

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3

#endif 0

PCTSTR
NtStatusServerity(
    IN NTSTATUS Status
    )
{
    PCTSTR pcszSev = NULL;

    /* Here is the layout of the message ID:

       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
      +---+-+-+-----------------------+-------------------------------+
      |Sev|C|R|     Facility          |               Code            |
      +---+-+-+-----------------------+-------------------------------+

      where

          Sev - is the severity code
          C - is the Customer code flag
          R - is a reserved bit
          Facility - is the facility code
          Code - is the facility's status code
    */

    ULONG dwSev = ((ULONG) Status) >> 30;
    switch (dwSev)
    {
    case STATUS_SEVERITY_WARNING:
      pcszSev = TEXT("WARNING"); break;
    case STATUS_SEVERITY_SUCCESS:
      pcszSev = TEXT("SUCCESS"); break;
    case STATUS_SEVERITY_INFORMATIONAL:
      pcszSev = TEXT("INFORMATIONAL"); break;
    case STATUS_SEVERITY_ERROR:
      pcszSev = TEXT("ERROR"); break;
    default:
      pcszSev = TEXT("Unknown!"); break;
    }

    return pcszSev;
}

/********************************************************************

    TNtStatus members

********************************************************************/

TNtStatus::
TNtStatus(
    IN NTSTATUS Status
    ) : TStatusDerived<NTSTATUS>(Status)
{
}

TNtStatus::
~TNtStatus(
    VOID
    )
{
}

BOOL
TNtStatus::
IsErrorSevereEnough(
    VOID
    ) const
{
    NTSTATUS Status = GetTStatusBase();

    return NT_ERROR(Status) || NT_WARNING(Status) || NT_INFORMATION(Status);
}

PCTSTR
TNtStatus::
GetErrorServerityDescription(
    VOID
    ) const
{
    NTSTATUS Status = GetTStatusBase();

    return NtStatusServerity(Status);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\krb5.c ===
#include "krbprgma.h"
#include <windows.h>
#include "krb5.h"

ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[49] = {
    (ASN1EncFun_t) ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) ASN1Enc_TYPED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[49] = {
    (ASN1DecFun_t) ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) ASN1Dec_TYPED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[49] = {
    (ASN1FreeFun_t) ASN1Free_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_PKERB_PREAUTH_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_PRIV,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTION_KEY,
    (ASN1FreeFun_t) ASN1Free_KERB_CHECKSUM,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_PKERB_ETYPE_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PKCS_SIGNATURE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE2,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_DH_KEY_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_SERV_REFERRAL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_CHANGE_PASSWORD_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR_METHOD_DATA,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_TYPED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_FOR_USER,
    (ASN1FreeFun_t) ASN1Free_KERB_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTHENTICATOR,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SAFE_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PRIV_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTH_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP2,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ2,
};
static const ULONG sizetab[49] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 49, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
    ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
    ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1BEREncS32(enc, 0x2, f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    t = lstrlenA(f->value);
    if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1ztcharstring_free(f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->user_data);
    if ((val)->o[0] & 0x80) {
    }
    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->user_data);
    if ((val)->o[0] & 0x80) {
    }
    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x20) {
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
        return 0;
    if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x20) {
        ASN1ztcharstring_free((val)->client_realm);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    }
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    if ((val)->o[0] & 0x8) {
        ASN1charstring_free(&(val)->error_text);
    }
    if ((val)->o[0] & 0x4) {
        ASN1octetstring_free(&(val)->error_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->salt);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    }
    if ((val)->o[0] & 0x40) {
        ASN1ztcharstring_free((val)->server_realm);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncOpenType(enc, &(val)->parameters))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
    return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->algorithm);
    if ((val)->o[0] & 0x80) {
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
    ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
    ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000000:
    (val)->choice = 1;
    if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
        return 0;
    break;
    case 0x80000001:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1octetstring_free(&(val)->u.dh_signed_data);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.key_package);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000001:
    (val)->choice = 1;
    if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
        return 0;
    break;
    case 0x80000004:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    if ((val)->o[0] & 0x80) {
        ASN1bitstring_free(&(val)->subject_public_key);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->signed_auth_pack);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
    }
    if ((val)->o[0] & 0x40) {
        ASN1octetstring_free(&(val)->kdc_cert);
    }
    if ((val)->o[0] & 0x20) {
        ASN1octetstring_free(&(val)->encryption_cert);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
    ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
    ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
    ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
    ASN1Free_KERB_SIGNATURE(&(val)->checksum);
    ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
    }
    ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    t = lstrlenA((val)->target_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->new_password);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
    }
    if ((val)->o[0] & 0x40) {
        ASN1ztcharstring_free((val)->target_realm);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->data_value);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TYPED_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PTYPED_DATA)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TYPED_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val)
{
    PTYPED_DATA f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TYPED_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
    ASN1ztcharstring_free((val)->userRealm);
    ASN1Free_KERB_CHECKSUM(&(val)->cksum);
    ASN1ztcharstring_free((val)->authentication_package);
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CERTIFICATE(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CERTIFICATE(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    if ((val)->o[0] & 0x80) {
        ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->flags);
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
    }
    if ((val)->o[0] & 0x20) {
        ASN1intx_free(&(val)->sequence_number);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
    return 0;
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x2;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->kdc_options);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    }
    ASN1ztcharstring_free((val)->realm);
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    }
    if ((val)->o[0] & 0x20) {
    }
    if ((val)->o[0] & 0x10) {
    }
    ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
    if ((val)->o[0] & 0x8) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
    }
    if ((val)->o[0] & 0x2) {
        ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
        return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
    }
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    ASN1Free_KERB_TICKET(&(val)->ticket);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
    (val)->o[0] |= 0x8;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
    ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
    if ((val)->o[0] & 0x80) {
    }
    ASN1bitstring_free(&(val)->flags);
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x20) {
    }
    ASN1ztcharstring_free((val)->server_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->ap_options);
    ASN1Free_KERB_TICKET(&(val)->ticket);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
    ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
    ASN1Free_KERB_CRED_tickets(&(val)->tickets);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    t = lstrlenA((val)->principal_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    t = lstrlenA((val)->service_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x2;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x1;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[1] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[1] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
    if ((val)->o[0] & 0x80) {
        ASN1ztcharstring_free((val)->principal_realm);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
    if ((val)->o[0] & 0x20) {
        ASN1bitstring_free(&(val)->flags);
    }
    if ((val)->o[0] & 0x10) {
    }
    if ((val)->o[0] & 0x8) {
    }
    if ((val)->o[0] & 0x4) {
    }
    if ((val)->o[0] & 0x2) {
    }
    if ((val)->o[0] & 0x1) {
        ASN1ztcharstring_free((val)->service_realm);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
    ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
    ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
        return 0;
    break;
    case 3:
    if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000000:
    (val)->choice = 1;
    if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
        return 0;
    break;
    case 0x80000001:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
        return 0;
    break;
    case 0x80000002:
    (val)->choice = 3;
    if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.ca_name);
        break;
    case 3:
        ASN1octetstring_free(&(val)->u.issuer_and_serial);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TRUSTED_CAS(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CRED_INFO(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TICKET(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TICKET(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
    }
    ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
    }
    ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
    ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
    ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\krbutils.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    krbutils.cxx

Abstract:

    utils

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "krbutils.hxx"
#include "kerberr.hxx"

VOID
KerbFreeRealm(
    IN PKERB_REALM pRealm
    )
{
    if (*pRealm != NULL)
    {
        MIDL_user_free(*pRealm);
        *pRealm = NULL;
    }
}

VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME pName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM pElem, pNextElem;

    pElem = pName->name_string;
    while (pElem != NULL)
    {
        if (pElem->value != NULL)
        {
            MIDL_user_free(pElem->value);
        }
        pNextElem = pElem->next;
        MIDL_user_free(pElem);
        pElem = pNextElem;
    }
    pName->name_string = NULL;
}

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID pData
    )
{
    ASN1decoding_t pDec = NULL;

    if (pData)
    {
        TKerbErr KerbErr;
        KerbErr DBGCHK = KerbInitAsn(
            NULL,
            &pDec       // this is a decoded structure
            );

        if (KERB_SUCCESS(KerbErr))
        {
            ASN1_FreeDecoded(pDec, pData, PduValue);
        }

        KerbTermAsn(NULL, pDec);
    }
}

BOOL fKRB5ModuleStarted = FALSE;

KERBERR
KerbInitAsn(
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    TKerbErr KerbErr = KRB_ERR_GENERIC;
    ASN1error_e Asn1Err;

    if (!fKRB5ModuleStarted)
    {
        fKRB5ModuleStarted = TRUE;
        KRB5_Module_Startup();
    }

    if (pEnc != NULL)
    {
        Asn1Err = ASN1_CreateEncoder(
            KRB5_Module,
            pEnc,
            NULL,           // pbBuf
            0,              // cbBufSize
            NULL            // pParent
            );
    }
    else
    {
        Asn1Err = ASN1_CreateDecoder(
            KRB5_Module,
            pDec,
            NULL,           // pbBuf
            0,              // cbBufSize
            NULL            // pParent
            );
    }

    KerbErr DBGCHK = ASN1_SUCCESS == Asn1Err ? KDC_ERR_NONE : KRB_ERR_GENERIC;

    return KerbErr;
}

VOID
KerbTermAsn(
    IN ASN1encoding_t pEnc,
    IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
    {
        ASN1_CloseEncoder(pEnc);
    }
    else if (pDec != NULL)
    {
        ASN1_CloseDecoder(pDec);
    }
}

KERBERR
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA pEncryptedData,
    IN ULONG cbDataSize,
    IN PUCHAR Data,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY pKey
    )
{
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(pKey->keytype, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    //
    // Initialize header
    //

    pEncryptedData->encryption_type = pKey->keytype;

    Status = pcsCrypt->Initialize(
        (PUCHAR) pKey->keyvalue.value,
        pKey->keyvalue.length,
        UsageFlags,
        &psbCryptBuffer
        );

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    Status =  pcsCrypt->Encrypt(
        psbCryptBuffer,
        Data,
        cbDataSize,
        pEncryptedData->cipher_text.value,
        &pEncryptedData->cipher_text.length
        );

    (void) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    if (KeyVersion != KERB_NO_KEY_VERSION)
    {
        pEncryptedData->version = KeyVersion;
        pEncryptedData->bit_mask |= version_present;
    }
    return KDC_ERR_NONE;
}

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG cbBufferSize,
    OUT PUINT pcbEncryptionBufferSize,
    OUT PBYTE* pEncryptionBuffer
    )
{
    TKerbErr KerbErr = KDC_ERR_NONE;
    ULONG cbEncryptionOverhead = 0;
    ULONG cbBlockSize = 0;

    KerbErr DBGCHK = KerbGetEncryptionOverhead(
        EncryptionType,
        &cbEncryptionOverhead,
        &cbBlockSize
        );
    if (KERB_SUCCESS(KerbErr))
    {
        *pcbEncryptionBufferSize = (UINT) ROUND_UP_COUNT(cbEncryptionOverhead + cbBufferSize, cbBlockSize);

        *pEncryptionBuffer =  (PBYTE) MIDL_user_allocate(*pcbEncryptionBufferSize);
        if (*pEncryptionBuffer == NULL)
        {
            KerbErr DBGCHK = KRB_ERR_GENERIC;
        }
    }

    return KerbErr;
}

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG cbBufferSize,
    OUT ULONG* pcbEncryptionBufferSize,
    OUT PBYTE* pEncryptionBuffer
    )
{
    TKerbErr KerbErr = KDC_ERR_NONE;
    UINT tempInt = 0;

    KerbErr DBGCHK = KerbAllocateEncryptionBuffer(
        EncryptionType,
        cbBufferSize,
        &tempInt,
        pEncryptionBuffer
        );

    if (KERB_SUCCESS(KerbErr))
    {
        *pcbEncryptionBufferSize = tempInt;
    }

    return KerbErr;
}

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG pcbOverhead,
    OUT OPTIONAL PULONG pcbBlockSize
    )
{
    PCRYPTO_SYSTEM pcsCrypt;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return (KDC_ERR_ETYPE_NOTSUPP);
    }

    *pcbOverhead = pcsCrypt->HeaderSize;
    if (pcbBlockSize)
    {
        *pcbBlockSize = pcsCrypt->BlockSize;
    }
    return (KDC_ERR_NONE);
}

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG pcbDataSize,
    OUT PUCHAR * MarshalledData
    )
{
    TKerbErr KerbErr = KDC_ERR_NONE;
    ASN1encoding_t pEnc = NULL;
        ASN1error_e Asn1Err;

    KerbErr DBGCHK = KerbInitAsn(
        &pEnc,          // we are encoding
        NULL
        );
    if (KERB_SUCCESS(KerbErr))
    {
        //
        // Encode the data type.
        //

        Asn1Err = ASN1_Encode(
            pEnc,
            Data,
            PduValue,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (!ASN1_SUCCEEDED(Asn1Err))
        {
            DebugPrintf(SSPI_ERROR, "KerbPackData failed to encode data: %d\n", Asn1Err);
            KerbErr DBGCHK = KRB_ERR_GENERIC;
        }
        else
        {
            *MarshalledData = (PUCHAR) MIDL_user_allocate(pEnc->len);
            if (*MarshalledData == NULL)
            {
                KerbErr DBGCHK = KRB_ERR_GENERIC;
                *pcbDataSize = 0;
            }
            else
            {
                RtlCopyMemory(*MarshalledData, pEnc->buf, pEnc->len);
                *pcbDataSize = pEnc->len;

            }
            ASN1_FreeEncoded(pEnc, pEnc->buf);
        }
    }

    KerbTermAsn(pEnc, NULL);

    return KerbErr;
}

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM pRealm,
    IN PUNICODE_STRING pString
    )
{
    TKerbErr KerbErr;
    STRING TempString;

    RtlInitString(
        &TempString,
        NULL
        );

    *pRealm = NULL;
    KerbErr DBGCHK = KerbUnicodeStringToKerbString(
        &TempString,
        pString
        );

    if (KERB_SUCCESS(KerbErr))
    {
        *pRealm = TempString.Buffer;
    }

    return KerbErr;
}

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING pKerbString,
    IN PUNICODE_STRING pString
    )
{
    STRING TempString;

    if (!pKerbString)
    {
        return KRB_ERR_GENERIC;
    }

    TempString.Buffer = KerbAllocUtf8StrFromUnicodeString(pString);
    if (TempString.Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    RtlInitString(
        &TempString,
        TempString.Buffer
        );
    *pKerbString = TempString;
    return KDC_ERR_NONE;
}

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME pPrincipalName,
    IN PKERB_INTERNAL_NAME pKdcName
    )
{
    TKerbErr KerbErr = KDC_ERR_NONE;

    PKERB_PRINCIPAL_NAME_ELEM pElem;
    PKERB_PRINCIPAL_NAME_ELEM* pLast;
    STRING TempKerbString;
    ULONG Index;

    pPrincipalName->name_type = (int) pKdcName->NameType;
    pPrincipalName->name_string = NULL;
    pLast = &pPrincipalName->name_string;

    //
    // Index through the KDC name and add each element to the list
    //

    for (Index = 0; KERB_SUCCESS(KerbErr) && (Index < pKdcName->NameCount); Index++)
    {
        KerbErr DBGCHK = KerbUnicodeStringToKerbString(
            &TempKerbString,
            &pKdcName->Names[Index]
            );
        if (KERB_SUCCESS(KerbErr))
        {
            pElem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
            if (pElem == NULL)
            {
                KerbErr DBGCHK = KRB_ERR_GENERIC;
            }
            pElem->value = TempKerbString.Buffer;
            pElem->next = NULL;
            *pLast = pElem;
            pLast = &pElem->next;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreePrincipalName(pPrincipalName);
    }
    return KerbErr;
}

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return ReturnFlag;
}

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME pClientTime,
    OUT OPTIONAL INT* pClientUsec,
    IN PTimeStamp pTimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

#ifndef WIN32_CHICAGO
    if (pTimeStamp->QuadPart == 0)
#else // WIN32_CHICAGO
    if (*pTimeStamp == 0)
#endif // WIN32_CHICAGO
    {
        RtlZeroMemory(
            pClientTime,
            sizeof(KERB_TIME)
            );
        //
        // For MIT compatibility, time zero is 1/1/70
        //

        pClientTime->year = 1970;
        pClientTime->month = 1;
        pClientTime->day = 1;

        if (pClientUsec)

        {
            *pClientUsec = 0;
        }
        pClientTime->universal = TRUE;
    }
    else
    {

#ifndef WIN32_CHICAGO
        RtlTimeToTimeFields(
            pTimeStamp,
            &TimeFields
            );
#else // WIN32_CHICAGO
        RtlTimeToTimeFields(
            (LARGE_INTEGER*) pTimeStamp,
            &TimeFields
            );
#endif // WIN32_CHICAGO

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            pClientTime->year = 2037;
        }
        else
        {
            pClientTime->year = TimeFields.Year;
        }
        pClientTime->month = (ASN1uint8_t) TimeFields.Month;
        pClientTime->day = (ASN1uint8_t) TimeFields.Day;
        pClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        pClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        pClientTime->second = (ASN1uint8_t) TimeFields.Second;

        // MIT kerberos does not support millseconds
        //

        pClientTime->millisecond = 0;

        if (pClientUsec)
        {
            //
            // Since we don't include milliseconds above, use the whole
            // thing here.
            //

#ifndef WIN32_CHICAGO
            *pClientUsec = (pTimeStamp->LowPart / 10) % 1000000;
#else // WIN32_CHICAGO
            *pClientUsec = (int) ((*pTimeStamp / 10) % 1000000);
#endif // WIN32_CHICAGO
        }

        pClientTime->diff = 0;
        pClientTime->universal = TRUE;
    }
}

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    NTSTATUS Status;
    switch(KerbError)
    {
    case KDC_ERR_NONE:
        Status = STATUS_SUCCESS;
        break;
    case KDC_ERR_CLIENT_REVOKED:
        Status = STATUS_ACCOUNT_DISABLED;
        break;
    case KDC_ERR_KEY_EXPIRED:
        Status = STATUS_PASSWORD_EXPIRED;
        break;
    case KRB_ERR_GENERIC:
        Status = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case KRB_AP_ERR_SKEW:
    case KRB_AP_ERR_TKT_NYV:
    // Note this was added because of the following scenario:
    // Let's say the dc and the client have the correct time. And the
    // server's time is off. We aren't going to get rid of the ticket for the
    // server on the client because it hasn't expired yet. But, the server
    // thinks it has. If event logging was turned on, then admins could look
    // at the server's event log and potentially deduce that the server's
    // time is off relative to the dc.
    case KRB_AP_ERR_TKT_EXPIRED:
        Status = STATUS_TIME_DIFFERENCE_AT_DC;
        break;
    case KDC_ERR_POLICY:
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;
    case KDC_ERR_C_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_S_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        break;
    case KRB_AP_ERR_MODIFIED:
    case KDC_ERR_PREAUTH_FAILED:
        Status = STATUS_WRONG_PASSWORD;
        break;
    case KRB_ERR_RESPONSE_TOO_BIG:
        Status = STATUS_INVALID_BUFFER_SIZE;
        break;
    case KDC_ERR_PADATA_TYPE_NOSUPP:
        Status = STATUS_NOT_SUPPORTED;
        break;
    case KRB_AP_ERR_NOT_US:
        Status = SEC_E_WRONG_PRINCIPAL;
        break;

    case KDC_ERR_SVC_UNAVAILABLE:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_WRONG_REALM:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_CANT_VERIFY_CERTIFICATE:
        Status = TRUST_E_SYSTEM_ERROR;
        break;
    case KDC_ERR_INVALID_CERTIFICATE:
        Status = STATUS_INVALID_PARAMETER;
        break;
    case KDC_ERR_REVOKED_CERTIFICATE:
        Status = CRYPT_E_REVOKED;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNKNOWN:
        Status = CRYPT_E_NO_REVOCATION_CHECK;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNAVAILABLE:
        Status = CRYPT_E_REVOCATION_OFFLINE;
        break;
    case KDC_ERR_CLIENT_NAME_MISMATCH:
    case KERB_PKINIT_CLIENT_NAME_MISMATCH:
    case KDC_ERR_KDC_NAME_MISMATCH:
        Status = STATUS_PKINIT_NAME_MISMATCH;
        break;
    case KDC_ERR_PATH_NOT_ACCEPTED:
        Status = STATUS_TRUST_FAILURE;
        break;
    case KDC_ERR_ETYPE_NOTSUPP:
        Status = STATUS_KDC_UNKNOWN_ETYPE;
        break;
    case KDC_ERR_MUST_USE_USER2USER:
    case KRB_AP_ERR_USER_TO_USER_REQUIRED:
        Status = STATUS_USER2USER_REQUIRED;
        break;
    case KRB_AP_ERR_NOKEY:
        Status = STATUS_NO_KERB_KEY;
        break;
    case KRB_ERR_NAME_TOO_LONG:
        Status = STATUS_NAME_TOO_LONG;
        break;
    default:
        Status = STATUS_LOGON_FAILURE;
    }
    return (Status);
}

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR pData,
    IN ULONG cbDataSize,
    IN ULONG PduValue,
    OUT PVOID * pDecodedData
    )
{
    TKerbErr KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
    ASN1error_e Asn1Err;

    if ((cbDataSize == 0) || (pData == NULL))
    {
        KerbErr DBGCHK = KRB_ERR_GENERIC;
    }

    if (KERB_SUCCESS(KerbErr))
    {
        KerbErr DBGCHK = KerbInitAsn(
            NULL,
            &pDec           // we are decoding
            );
    }

    if (KERB_SUCCESS(KerbErr))
    {
        *pDecodedData = NULL;
        Asn1Err = ASN1_Decode(
            pDec,
            pDecodedData,
            PduValue,
            ASN1DECODE_SETBUFFER,
            (BYTE *) pData,
            cbDataSize
            );

        if (!ASN1_SUCCEEDED(Asn1Err))
        {
            if ((ASN1_ERR_BADARGS == Asn1Err) ||
                (ASN1_ERR_EOD == Asn1Err))
            {
                KerbErr DBGCHK = KDC_ERR_MORE_DATA;
            }
            else
            {
                KerbErr DBGCHK = KRB_ERR_GENERIC;
            }
            *pDecodedData = NULL;
        }
    }

    KerbTermAsn(NULL, pDec);

    return KerbErr;
}

PSTR
KerbAllocUtf8StrFromUnicodeString(
    IN PUNICODE_STRING pUnicodeString
    )
{
    PSTR pUtf8String = NULL;
    UINT cbUtf8StringLen;

    //
    // If the length is zero, return a null string.
    //

    if (pUnicodeString->Length == 0)
    {
        pUtf8String = (PSTR) MIDL_user_allocate(sizeof(CHAR));
        if (pUtf8String != NULL)
        {
            *pUtf8String = '\0';
        }
        return pUtf8String;
    }

    //
    // Determine the length of the Unicode string.
    //

    cbUtf8StringLen = WideCharToMultiByte(
        #ifndef WIN32_CHICAGO
        CP_UTF8,
        #else // WIN32_CHICAGO
        CP_OEMCP,
        #endif // WIN32_CHICAGO
        0,      // All characters can be mapped.
        pUnicodeString->Buffer,
        pUnicodeString->Length / sizeof(WCHAR),
        pUtf8String,
        0,
        NULL,
        NULL
        );

    if ( cbUtf8StringLen == 0 )
    {
        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    pUtf8String = (PSTR) MIDL_user_allocate( cbUtf8StringLen + 1 );

    if (pUtf8String == NULL)
    {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    cbUtf8StringLen = WideCharToMultiByte(
        #ifndef WIN32_CHICAGO
        CP_UTF8,
        #else // WIN32_CHICAGO
        CP_OEMCP,
        #endif // WIN32_CHICAGO
        0,      // All characters can be mapped.
        pUnicodeString->Buffer,
        pUnicodeString->Length / sizeof(WCHAR),
        pUtf8String,
        cbUtf8StringLen,
        NULL,
        NULL
        );

    if ( cbUtf8StringLen == 0 )
    {
        MIDL_user_free( pUtf8String );
        return NULL;
    }

    pUtf8String[cbUtf8StringLen] = '\0';

    return pUtf8String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\lsasspi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasspi.cxx

Abstract:

    lsasspi

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasspi.hxx"
#include "dbgstate.hxx"

#define SECUR32DLL TEXT("secur32.dll")

PCSTR
LogonType2Str(
    IN ULONG LogonType
    )
{
    static PCSTR g_cszLogonTypes[] =
    {
        "Invalid",
        "Invalid",
        "Interactive",
        "Network",
        "Batch",
        "Service",
        "Proxy",
        "Unlock",
        "NetworkCleartext",
        "NewCredentials",
        "RemoteInteractive",  // Remote, yet interactive.  Terminal server
        "CachedInteractive",
    };

    return ((LogonType < COUNTOF(g_cszLogonTypes)) ?
        g_cszLogonTypes[LogonType] : "Invalid");
}

PCSTR
ImpLevel2Str(
    IN ULONG Level
    )
{
    static PCSTR ImpLevels[] = {
        "Anonymous",
        "Identification",
        "Impersonation",
        "Delegation"
        };
    return ((Level < COUNTOF(ImpLevels)) ? ImpLevels[Level] : "Illegal!");
}

NTSTATUS
GetLsaHandleAndPackageId(
    IN PCSTR pszPackageNameA,
    OUT HANDLE* pLsaHandle,
    OUT ULONG* pPackageId
    )
{
    BOOLEAN bWasTcbPrivEnabled = FALSE;
    BOOLEAN bIsImpersonating = TRUE;

    return GetLsaHandleAndPackageIdEx(
        pszPackageNameA,
        pLsaHandle,
        pPackageId,
        &bWasTcbPrivEnabled,
        &bIsImpersonating
        );
}

NTSTATUS
GetLsaHandleAndPackageIdEx(
    IN PCSTR pszPackageNameA,
    OUT HANDLE* pLsaHandle,
    OUT ULONG* pPackageId,
    OUT BOOLEAN* pbWasTcbPrivEnabled,
    OUT BOOLEAN* pbIsImpersonating
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;

    STRING Name = {0};
    LSA_OPERATIONAL_MODE Ignored = 0;
    HANDLE LogonHandle = NULL;
    ULONG PackageId = -1;
    BOOLEAN bIsImpersonating = TRUE;
    DWORD UserInfoResponseLength = 0;

    DebugPrintf(SSPI_LOG, "GetLsaHandleAndPackageId looking for %s\n", pszPackageNameA);

    *pLsaHandle = NULL;
    *pPackageId = -1;

    //
    // Turn on the TCB privilege
    //

    DBGCFG2(Status, STATUS_PRIVILEGE_NOT_HELD, STATUS_NO_TOKEN);

    Status DBGCHK = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, *pbIsImpersonating, pbWasTcbPrivEnabled);

    if (STATUS_NO_TOKEN == (NTSTATUS) Status)
    {
        *pbIsImpersonating = FALSE;
        Status DBGCHK = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, *pbIsImpersonating, pbWasTcbPrivEnabled);
    }
    else if (!NT_SUCCESS(Status))
    {
        *pbIsImpersonating = TRUE;
    }

    if (NT_SUCCESS(Status))
    {
        RtlInitString(
            &Name,
            "SspTest"
            );
        Status DBGCHK = LsaRegisterLogonProcess(
            &Name,
            &LogonHandle,
            &Ignored
            );
        if (NT_SUCCESS(Status))
        {
            DebugPrintf(SSPI_LOG, "LsaRegisterLogonProcess succeeded\n");
        }
    }
    else
    {
        Status DBGCHK = LsaConnectUntrusted(&LogonHandle);
        if (NT_SUCCESS(Status))
        {
            DebugPrintf(SSPI_LOG, "LsaConnectUntrusted succeeded\n");
        }
    }

    RtlInitString(
        &Name,
        pszPackageNameA
        );
    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaLookupAuthenticationPackage(
            LogonHandle,
            &Name,
            &PackageId
            );
    }

    *pPackageId = PackageId;
    *pLsaHandle = LogonHandle;

    return Status;
}

NTSTATUS
FindAndOpenWinlogon(
    OUT HANDLE* phWinlogon
    )
{
    TNtStatus Status;

    HANDLE hWinlogon = NULL;
    SYSTEM_PROCESS_INFORMATION* pSystemInfo = NULL;
    SYSTEM_PROCESS_INFORMATION* pWalk = NULL;
    OBJECT_ATTRIBUTES Obja = {0};
    CLIENT_ID ClientId = {0};

    UNICODE_STRING Winlogon = CONSTANT_UNICODE_STRING(L"winlogon.exe");

    pSystemInfo = (SYSTEM_PROCESS_INFORMATION*) new CHAR[sizeof(SYSTEM_PROCESS_INFORMATION) * 1024];

    Status DBGCHK = pSystemInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = NtQuerySystemInformation(
            SystemProcessInformation,
            pSystemInfo,
            sizeof(SYSTEM_PROCESS_INFORMATION) * 1024,
            NULL
            );
    }

    if (NT_SUCCESS(Status))
    {
        pWalk = pSystemInfo ;

        while (RtlCompareUnicodeString(&pWalk->ImageName, &Winlogon, TRUE) != 0)
        {
            if (pWalk->NextEntryOffset == 0)
            {
                pWalk = NULL ;
                break;
            }

            pWalk = (SYSTEM_PROCESS_INFORMATION*) ((UCHAR*) pWalk + pWalk->NextEntryOffset);
        }

        Status DBGCHK = pWalk ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(Status))
    {
        ClientId.UniqueThread = (HANDLE)NULL;
        ClientId.UniqueProcess = (HANDLE)LongToHandle(PtrToUlong(pWalk->UniqueProcessId));

        InitializeObjectAttributes(
            &Obja,
            NULL,
            0, // (bInheritHandle ? OBJ_INHERIT : 0),
            NULL,
            NULL
            );
        Status DBGCHK = NtOpenProcess(
            &hWinlogon,
            (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
            &Obja,
            &ClientId
            );
    }

    if (NT_SUCCESS(Status))
    {
        *phWinlogon = hWinlogon;
        hWinlogon = NULL;
    }

    if (pSystemInfo)
    {
        delete [] pSystemInfo;
    }

    if (hWinlogon)
    {
        NtClose(hWinlogon);
    }

    return Status ;
}

NTSTATUS
GetSystemToken(
    OUT HANDLE* phSystemToken
    )
{
    TNtStatus Status;

    HANDLE hWinlogon = NULL;

    Status DBGCHK = FindAndOpenWinlogon(&hWinlogon);

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetProcessToken(hWinlogon, phSystemToken);
    }

    if (hWinlogon)
    {
        NtClose(hWinlogon);
    }

    return Status;
}

NTSTATUS
Impersonate(
    IN OPTIONAL HANDLE hToken
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    TOKEN_TYPE Type;
    ULONG cbType;
    HANDLE hImpToken = NULL;
    HANDLE hDupToken = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;

    if (hToken)
    {
        Status DBGCHK = NtQueryInformationToken(
            hToken,
            TokenType,
            &Type,
            sizeof(TOKEN_TYPE),
            &cbType
            );

        if (NT_SUCCESS(Status))
        {
            if (Type == TokenPrimary)
            {
                InitializeObjectAttributes(
                    &ObjectAttributes,
                    NULL,
                    0L,
                    NULL,
                    NULL
                    );

                SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
                SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
                SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQualityOfService.EffectiveOnly = FALSE;

                ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

                Status DBGCHK = NtDuplicateToken(
                    hToken,
                    TOKEN_IMPERSONATE | TOKEN_QUERY,
                    &ObjectAttributes,
                    FALSE,
                    TokenImpersonation,
                    &hDupToken
                    );
                if (NT_SUCCESS(Status))
                {
                    hImpToken = hDupToken;
                }
            }
            else
            {
                hImpToken = hToken;
            }
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hImpToken,
            sizeof(hImpToken)
            );
    }

    if (hDupToken)
    {
        NtClose(hDupToken);
    }

    return Status;
}

HRESULT
GetProcessToken(
    IN HANDLE hProcess,
    OUT HANDLE* phProcessToken
    )
{
    THResult hRetval;

    HANDLE hProcessToken = NULL;
    HANDLE hSubToken = NULL;
    HANDLE hDupToken = NULL;
    SECURITY_DESCRIPTOR SdNullDACL = {0};
    SECURITY_DESCRIPTOR* pSave = NULL;
    ULONG cbSdSize = 0;
    BOOLEAN bNeedRestoreSd = FALSE;

    DBGCFG1(hRetval, HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));

    hRetval DBGCHK = OpenProcessToken(
        hProcess,
        TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
        &hProcessToken
        ) ? S_OK : GetLastErrorAsHResult();

    if (FAILED(hRetval) && (HRESULT_CODE(hRetval) == ERROR_ACCESS_DENIED))
    {
        SspiPrint(SSPI_WARN,
            TEXT("GetProcessToken failed with access denied to get token for process %p\n"),
            hProcess);
        hRetval DBGCHK = OpenProcessToken(
            hProcess,
            READ_CONTROL | WRITE_DAC,
            &hSubToken
            ) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            cbSdSize = 1024;
            pSave = (SECURITY_DESCRIPTOR*) new CHAR[cbSdSize];

            hRetval DBGCHK = pSave ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = GetKernelObjectSecurity(
                hSubToken,
                DACL_SECURITY_INFORMATION,
                pSave,
                cbSdSize,
                &cbSdSize
                ) ? S_OK : GetLastErrorAsHResult();

            if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval)))
            {
                delete [] pSave;

                pSave = (SECURITY_DESCRIPTOR*) new CHAR[cbSdSize];

                hRetval DBGCHK = pSave ? S_OK : E_OUTOFMEMORY;

                if (SUCCEEDED(hRetval))
                {
                    hRetval DBGCHK = GetKernelObjectSecurity(
                        hSubToken,
                        DACL_SECURITY_INFORMATION,
                        pSave,
                        cbSdSize,
                        &cbSdSize
                        ) ? S_OK : GetLastErrorAsHResult();
                }
            }
        }

        if (SUCCEEDED(hRetval))
        {
            bNeedRestoreSd = TRUE;

            hRetval DBGCHK = InitializeSecurityDescriptor(&SdNullDACL, SECURITY_DESCRIPTOR_REVISION) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = SetSecurityDescriptorDacl(&SdNullDACL, TRUE, NULL, FALSE) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = SetKernelObjectSecurity(
                hSubToken,
                DACL_SECURITY_INFORMATION,
                &SdNullDACL
                ) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = OpenProcessToken(
                hProcess,
                TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                &hProcessToken
                ) ? S_OK : GetLastErrorAsHResult();
        }
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = DuplicateTokenEx(
            hProcessToken,
            MAXIMUM_ALLOWED,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hDupToken
            );
    }

    if (SUCCEEDED(hRetval))
    {
        *phProcessToken = hDupToken;
        hDupToken = NULL;
    }

    if (hSubToken)
    {
        CloseHandle(hSubToken);
    }

    if (hDupToken)
    {
        CloseHandle(hDupToken);
    }

    if (hProcessToken)
    {
        CloseHandle(hProcessToken);
    }

    if (bNeedRestoreSd)
    {
        SetKernelObjectSecurity(
            hSubToken,
            DACL_SECURITY_INFORMATION,
            pSave
            );
    }

    if (pSave)
    {
        delete [] pSave;
    }

    return hRetval;
}

HRESULT
GetProcessTokenWithNullDACL(
    IN HANDLE hProcess,
    OUT HANDLE* phProcessToken
    )
{
    THResult hRetval;

    HANDLE hProcessToken = NULL;
    HANDLE hSubToken = NULL;
    HANDLE hDupToken = NULL;
    SECURITY_DESCRIPTOR SdNullDACL = {0};

    hRetval DBGCHK = OpenProcessToken(
        hProcess,
        READ_CONTROL | WRITE_DAC,
        &hSubToken
        ) ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = InitializeSecurityDescriptor(&SdNullDACL, SECURITY_DESCRIPTOR_REVISION) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SetSecurityDescriptorDacl(&SdNullDACL, TRUE, NULL, FALSE) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SetKernelObjectSecurity(
            hSubToken,
            DACL_SECURITY_INFORMATION,
            &SdNullDACL
            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = OpenProcessToken(
            hProcess,
            TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
            &hProcessToken
            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = DuplicateTokenEx(
            hProcessToken,
            MAXIMUM_ALLOWED,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hDupToken
            );
    }

    if (SUCCEEDED(hRetval))
    {
        *phProcessToken = hDupToken;
        hDupToken = NULL;
    }

    if (hSubToken)
    {
        CloseHandle(hSubToken);
    }

    if (hDupToken)
    {
        CloseHandle(hDupToken);
    }

    if (hProcessToken)
    {
        CloseHandle(hProcessToken);
    }

    return hRetval;
}

HRESULT
CreateProcessAsUserEx(
    IN HANDLE hToken,
    IN UNICODE_STRING* pApplication
    )
{
    THResult hRetval = S_OK;

    PROCESS_INFORMATION pi = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, 0, 0};
    STARTUPINFOW si = {0};

    HANDLE hTokenNew = NULL;

    si.cb = sizeof(si);

    DBGCFG1(hRetval, HRESULT_FROM_WIN32(ERROR_BAD_TOKEN_TYPE));

    DebugPrintf(SSPI_LOG, "CreateProcessAsUserEx hTokenNew %p, Application %wZ\n", hToken, pApplication);

    hRetval DBGCHK = CreateProcessAsUserW(
        hToken,
        NULL,
        pApplication->Buffer,
        NULL,
        NULL,
        FALSE,
        CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
        ) ? S_OK : GetLastErrorAsHResult();

    if (FAILED(hRetval) && (ERROR_BAD_TOKEN_TYPE == HRESULT_CODE(hRetval)))
    {
        DebugPrintf(SSPI_WARN, "CreateProcessAsUserW failed with ERROR_BAD_TOKEN_TYPE\n");

        hRetval DBGCHK = DuplicateTokenEx(
            hToken,
            TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hTokenNew
            ) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = CreateProcessAsUserW(
                hTokenNew,
                NULL,
                pApplication->Buffer,
                NULL,
                NULL,
                FALSE,
                CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE,
                NULL,
                NULL,
                &si,
                &pi
                ) ? S_OK : GetLastErrorAsHResult();
        }
    }

    if (hTokenNew)
    {
        CloseHandle(hTokenNew);
    }

    if (pi.hProcess != INVALID_HANDLE_VALUE)
    {
        // WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
    }

    if (pi.hThread != INVALID_HANDLE_VALUE)
    {
        CloseHandle(pi.hThread);
    }

    return hRetval;
}

NTSTATUS
CheckUserToken(
    IN HANDLE hToken
    )
{
    TNtStatus Status;

    TOKEN_STATISTICS TokenStat = {0};
    CHAR Buff[sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE] = {0};
    TOKEN_USER* pTokenUserData = (TOKEN_USER*) Buff;

    ULONG cbReturnLength = 0;
    PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL;

    Status DBGCHK = NtQueryInformationToken(
        hToken,
        TokenStatistics,
        &TokenStat,
        sizeof(TokenStat),
        &cbReturnLength
        );

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x, Impersonation Level %s, TokenType %s\n",
            TokenStat.AuthenticationId.HighPart,
            TokenStat.AuthenticationId.LowPart,
            ImpLevel2Str(TokenStat.ImpersonationLevel),
            TokenStat.TokenType == TokenPrimary ? "Primary" : "Impersonation");

        Status DBGCHK = LsaGetLogonSessionData(&TokenStat.AuthenticationId, &pLogonSessionData);
        if (NT_SUCCESS(Status))
        {
            DebugPrintLogonSessionData(SSPI_LOG, pLogonSessionData);
        }
        else if ( (STATUS_NO_SUCH_LOGON_SESSION == (NTSTATUS) Status)
                  || (STATUS_ACCESS_DENIED == (NTSTATUS) Status) )
        {
            Status DBGCHK = NtQueryInformationToken(
                hToken,
                TokenUser,
                Buff,
                sizeof(Buff),
                &cbReturnLength
                );
            if (NT_SUCCESS(Status))
            {
                DebugPrintSidFriendlyName(SSPI_LOG, "Sid", pTokenUserData->User.Sid);
            }
        }
    }

    if (pLogonSessionData)
    {
        LsaFreeReturnBuffer(pLogonSessionData);
    }

    return Status;
}

HRESULT
CheckUserData(
    VOID
    )
{
    THResult hRetval = E_FAIL;

    TOKEN_STATISTICS TokenStat = {0};
    ULONG cbReturnLength = 0;
    PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL;
    HANDLE hNullToken = NULL;
    HANDLE hToken = NULL;
    BOOL bIsImpersonating = FALSE;

    hRetval DBGCHK = NtOpenThreadToken(
        NtCurrentThread(), // handle to thread
        MAXIMUM_ALLOWED,   // access to process
        TRUE,              // process or thread security
        &hToken      // handle to open access token
        );

    if (STATUS_NO_TOKEN == (HRESULT) hRetval)
    {
        hRetval DBGCHK = NtOpenProcessToken(
            NtCurrentProcess(), // handle to process
            MAXIMUM_ALLOWED,    // access to process
            &hToken             // handle to open access token
            );
    }
    else if (SUCCEEDED(hRetval))
    {
        bIsImpersonating = TRUE;
    }

    //
    // Revert to self
    //

    if (SUCCEEDED(hRetval) && bIsImpersonating)
    {
        hRetval DBGCHK = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hNullToken,
            sizeof( HANDLE )
            );
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = CheckUserToken(hToken);
    }

    //
    // restore thread token
    //

    if (bIsImpersonating)
    {
        TNtStatus hr;

        hr DBGCHK = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hToken,
            sizeof( HANDLE )
            );
        if (SUCCEEDED(hRetval) && FAILED(hr))
        {
            hRetval DBGNOCHK = hr;
        }
    }

    if (pLogonSessionData)
    {
        LsaFreeReturnBuffer(pLogonSessionData);
    }

    if (hToken)
    {
        NtClose(hToken);
    }

    return hRetval;
}

NTSTATUS
GetProcessHandleByCid(
    IN ULONG ProcessID,
    OUT HANDLE* phProcess
    )
{
    TNtStatus Status;

    HANDLE hProcess = NULL;
    CLIENT_ID ClientId = {0};
    OBJECT_ATTRIBUTES Obja = {0};

    SspiPrint(SSPI_LOG, TEXT("GetProcessHandleByCid %#x(%d)\n"), ProcessID, ProcessID);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    ClientId.UniqueProcess = LongToHandle(ProcessID);
    ClientId.UniqueThread = NULL;

    Status DBGCHK = NtOpenProcess(
        &hProcess,
        PROCESS_QUERY_INFORMATION,
        &Obja,
        &ClientId
        );

    if (NT_SUCCESS(Status))
    {
        *phProcess = hProcess;
        hProcess = NULL;
    }

    if (hProcess)
    {
        NtClose(hProcess);
    }

    return Status;
}

HRESULT
GetProcessTokenByProcessId(
    IN ULONG ProcessID,
    OUT HANDLE* phToken
    )
{
    THResult hRetval;
    HANDLE hProcess = NULL;
    HANDLE hToken = NULL;

    SspiPrint(SSPI_LOG, TEXT("GetProcessTokenByProcessId: ProcessID %#x(%d)\n"), ProcessID, ProcessID);

    hProcess = OpenProcess(
        PROCESS_QUERY_INFORMATION,
        FALSE,
        ProcessID
        );

    hRetval DBGCHK = hProcess ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = GetProcessToken(hProcess, &hToken);
    }

    if (SUCCEEDED(hRetval))
    {
        *phToken = hToken;
        hToken = NULL;
    }

    if (hProcess)
    {
        CloseHandle(hProcess);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return hRetval;
}

PCSTR
GetSidTypeStr(
    IN SID_NAME_USE eUse
    )
{
    static PCSTR acszSidTypeStr[] =
    {
        "Invalid", "User", "Group", "Domain", "Alias", "Well Known Group",
        "Deleted Account", "Invalid", "Unknown", "Computer",
    };

    if (eUse < SidTypeUser || eUse > SidTypeComputer)
    {
        throw "Unrecognized SID";
    }

    return acszSidTypeStr[eUse];
}

VOID
DebugPrintSidFriendlyName(
    IN ULONG Level,
    IN PCSTR pszBanner,
    IN PSID pSid
    )
{
    TNtStatus NtStatus;

    UNICODE_STRING ucsSid = {0};

    NtStatus DBGCHK = RtlConvertSidToUnicodeString(&ucsSid, pSid, TRUE);

    if (NT_SUCCESS(NtStatus))
    {
        THResult hRetval = E_FAIL;

        CHAR szName[MAX_PATH] = {0};
        CHAR szDomainName[MAX_PATH] ={0};
        SID_NAME_USE eUse = SidTypeInvalid;
        DWORD cbName = sizeof(szName) - 1;
        DWORD cbDomainName = sizeof(szDomainName) - 1;

        DBGCFG1(hRetval, HRESULT_FROM_WIN32(ERROR_NONE_MAPPED));

        hRetval DBGCHK = LookupAccountSidA(
            NULL,
            pSid,
            szName,
            &cbName,
            szDomainName,
            &cbDomainName,
            &eUse
            ) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            DebugPrintf(Level, "%s %wZ -> (%s: %s\\%s)\n",
                pszBanner,
                &ucsSid,
                GetSidTypeStr(eUse),
                *szDomainName ? szDomainName : "localhost", szName);
        }
        else if (FAILED(hRetval) && (ERROR_NONE_MAPPED == HRESULT_CODE(hRetval)))
        {
            DebugPrintf(SSPI_LOG, "%s %wZ -> (no name mapped)\n", pszBanner,&ucsSid);
        }
    }

    RtlFreeUnicodeString(&ucsSid);
}

VOID
DebugPrintLogonSessionData(
    IN ULONG Level,
    IN SECURITY_LOGON_SESSION_DATA* pLogonSessionData
    )
{
    if (pLogonSessionData && (pLogonSessionData->Size >= sizeof(SECURITY_LOGON_SESSION_DATA_OLD)))
    {
        DebugPrintf(Level, "LogonSession Data for LogonId %#x:%#x\n", pLogonSessionData->LogonId.HighPart, pLogonSessionData->LogonId.HighPart);
        DebugPrintf(Level, "UserName %wZ\n", &pLogonSessionData->UserName);
        DebugPrintf(Level, "LogonDomain %wZ\n", &pLogonSessionData->LogonDomain);
        DebugPrintf(Level, "AuthenticationPackage %wZ\n", &pLogonSessionData->AuthenticationPackage);
        DebugPrintf(Level, "LogonType %#x (%s)\n", pLogonSessionData->LogonType, LogonType2Str(pLogonSessionData->LogonType));
        DebugPrintf(Level, "Session %#x\n", pLogonSessionData->Session);
        DebugPrintSidFriendlyName(Level, "Sid", pLogonSessionData->Sid);
        DebugPrintSysTimeAsLocalTime(Level, "LogonTime", &pLogonSessionData->LogonTime);

       if (pLogonSessionData->Size >= sizeof(SECURITY_LOGON_SESSION_DATA))
       {
           DebugPrintf(Level, "LogonServer %wZ\n", &pLogonSessionData->LogonServer);
           DebugPrintf(Level, "DnsDomainName %wZ\n", &pLogonSessionData->DnsDomainName);
           DebugPrintf(Level, "Upn %wZ\n", &pLogonSessionData->Upn);
       }
    }
}

NTSTATUS
LsaGetLogonSessionData(
    IN PLUID LogonId,
    OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    )
{
    THResult hRetval;
    PFuncLsaGetLogonSessionData pFuncLsaGetLogonSessionData = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaGetLogonSessionData =
            (PFuncLsaGetLogonSessionData) GetProcAddress(hLib, "LsaGetLogonSessionData");
        hRetval DBGCHK = pFuncLsaGetLogonSessionData ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaGetLogonSessionData)(LogonId, ppLogonSessionData);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaRegisterLogonProcess (
    IN PLSA_STRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )
{
    THResult hRetval;
    PFuncLsaRegisterLogonProcess pFuncLsaRegisterLogonProcess = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();


    if (SUCCEEDED(hRetval))
    {
        pFuncLsaRegisterLogonProcess =
            (PFuncLsaRegisterLogonProcess) GetProcAddress(hLib, "LsaRegisterLogonProcess");
        hRetval DBGCHK = pFuncLsaRegisterLogonProcess ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaRegisterLogonProcess)(LogonProcessName, LsaHandle, SecurityMode);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaLookupAuthenticationPackage(
    IN HANDLE LsaHandle,
    IN PLSA_STRING PackageName,
    OUT PULONG AuthenticationPackage
    )
{
    THResult hRetval;
    PFuncLsaLookupAuthenticationPackage pFuncLsaLookupAuthenticationPackage = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaLookupAuthenticationPackage =
            (PFuncLsaLookupAuthenticationPackage) GetProcAddress(hLib, "LsaLookupAuthenticationPackage");
        hRetval DBGCHK = pFuncLsaLookupAuthenticationPackage ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaLookupAuthenticationPackage)(LsaHandle, PackageName, AuthenticationPackage);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaLogonUser(
    IN HANDLE LsaHandle,
    IN PLSA_STRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )
{
    THResult hRetval;
    PFuncLsaLogonUser pFuncLsaLogonUser = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaLogonUser =
            (PFuncLsaLogonUser) GetProcAddress(hLib, "LsaLogonUser");
        hRetval DBGCHK = pFuncLsaLogonUser ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaLogonUser)(
            LsaHandle,
            OriginName,
            LogonType,
            AuthenticationPackage,
            AuthenticationInformation,
            AuthenticationInformationLength,
            LocalGroups,
            SourceContext,
            ProfileBuffer,
            ProfileBufferLength,
            LogonId,
            Token,
            Quotas,
            SubStatus
            );
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaFreeReturnBuffer(
    IN PVOID Buffer
    )
{
    THResult hRetval;
    PFuncLsaFreeReturnBuffer pFuncLsaFreeReturnBuffer = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaFreeReturnBuffer =
            (PFuncLsaFreeReturnBuffer) GetProcAddress(hLib, "LsaFreeReturnBuffer");
        hRetval DBGCHK = pFuncLsaFreeReturnBuffer ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaFreeReturnBuffer)(Buffer);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaConnectUntrusted(
    OUT PHANDLE LsaHandle
    )
{
    THResult hRetval;
    PFuncLsaConnectUntrusted pFuncLsaConnectUntrusted = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaConnectUntrusted =
            (PFuncLsaConnectUntrusted) GetProcAddress(hLib, "LsaConnectUntrusted");
        hRetval DBGCHK = pFuncLsaConnectUntrusted ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaConnectUntrusted)(LsaHandle);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaDeregisterLogonProcess(
    IN HANDLE LsaHandle
    )
{
    THResult hRetval;
    PFuncLsaDeregisterLogonProcess pFuncLsaDeregisterLogonProcess = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaDeregisterLogonProcess =
            (PFuncLsaDeregisterLogonProcess) GetProcAddress(hLib, "LsaDeregisterLogonProcess");
        hRetval DBGCHK = pFuncLsaDeregisterLogonProcess ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaDeregisterLogonProcess)(LsaHandle);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

NTSTATUS
LsaCallAuthenticationPackage(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID* ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    THResult hRetval;
    PFuncLsaCallAuthenticationPackage pFuncLsaCallAuthenticationPackage = NULL;

    HMODULE hLib = LoadLibrary(SECUR32DLL);

    hRetval DBGCHK = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pFuncLsaCallAuthenticationPackage =
            (PFuncLsaCallAuthenticationPackage) GetProcAddress(hLib, "LsaCallAuthenticationPackage");
        hRetval DBGCHK = pFuncLsaCallAuthenticationPackage ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (*pFuncLsaCallAuthenticationPackage)(
           LsaHandle,
           AuthenticationPackage,
           ProtocolSubmitBuffer,
           SubmitBufferLength,
           ProtocolReturnBuffer,
           ReturnBufferLength,
           ProtocolStatus
           );
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return hRetval;
}

FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{
    SspiPrint(SSPI_ERROR, TEXT("pszDllName %s, pszProcName %s\n"), pszDllName, pszProcName);
    return NULL; // fool compiler
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\output.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    output.cxx

Abstract:

    output

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#include "output.hxx"

typedef struct _TLibarayGlobals
{
    ULONG uMajorVersion;
    ULONG uMinorVersion;
    ULONG uDebugMask;
    PCSTR pszDbgPrompt;
    PCRITICAL_SECTION pCriticalSection;
} TLibarayGlobals;

TLibarayGlobals g_AnsiOutputGlobals = {
    1,    // major version
    2,    // minor version
    0xF,  // debug mask
    "SSPI_TEST", // debug prompt
    NULL, // no serialization
};

CHAR ToChar(IN CHAR c)
{
    if (isprint(c))
    {
        return c;
    }

    return '.';
}

VOID SpaceIt(IN ULONG len, IN CHAR* buf)
{
    memset(buf, ' ', len);
}

CHAR ToHex(IN ULONG c)
{
    static PCSTR pszDigits = "0123456789abcdef";
    static ULONG len = strlen(pszDigits);

    if (c <= len)
    { // c >= 0
        return pszDigits[c];
    }

    return '*';
}

VOID
DebugPrintHex(
    IN ULONG ulLevel,
    IN OPTIONAL PCSTR pszBanner,
    IN ULONG cbBuffer,
    IN const VOID* pvbuffer
    )
{
    if (g_AnsiOutputGlobals.uDebugMask & ulLevel)
    {
        PCRITICAL_SECTION pCriticalSection = g_AnsiOutputGlobals.pCriticalSection;

        const UCHAR* pBuffer = reinterpret_cast<const UCHAR*>(pvbuffer);
        ULONG high = 0;
        ULONG low = 0;
        CHAR szLine[256] = {0};
        ULONG i = 0;

        CHAR szBanner[MAX_PATH * 4] = {0};

        DWORD dwPid = GetCurrentProcessId();
        DWORD dwTid = GetCurrentThreadId();

        _snprintf(szBanner, sizeof(szBanner) - 1,
            g_AnsiOutputGlobals.pszDbgPrompt ? "%#x.%#x %s> %s %s" : "%#x.%#x%s> %s %s",
            dwPid,
            dwTid,
            g_AnsiOutputGlobals.pszDbgPrompt ? g_AnsiOutputGlobals.pszDbgPrompt : "",
            DebugLevel2Str(ulLevel),
            pszBanner ? pszBanner : "");

        if (pCriticalSection)
        {
            EnterCriticalSection(pCriticalSection);
        }

        OutputDebugStringPrintf(szBanner, "\n");

        SpaceIt(72, szLine);

        for (i = 0; i < cbBuffer; i++)
        {
            high = pBuffer[i] / 16;
            low = pBuffer[i] % 16;

            szLine[3 * (i % 16)] = ToHex(high);
            szLine[3 * (i % 16) + 1] = ToHex(low);
            szLine [52 + (i % 16)] = ToChar(pBuffer[i]);

            if (i % 16 == 7  && i != (cbBuffer - 1))
            {
                szLine[3 * (i % 16) + 2] = '-';
            }

            if (i % 16 == 15)
            {
                OutputDebugStringPrintf(NULL, "  %s\n", szLine);
                SpaceIt(72, szLine);
            }
        }

        OutputDebugStringPrintf(NULL, "  %s\n", szLine);

        if (pCriticalSection)
        {
            LeaveCriticalSection(pCriticalSection);
        }
    }
}

PCSTR
DebugLevel2Str(
    IN ULONG ulLevel
    )
{
    PCSTR pszText = NULL;

    switch (ulLevel)
    {
    case SSPI_WARN:
        pszText = "[warn]";
        break;

    case SSPI_ERROR:
        pszText = "[error]";
        break;

    case SSPI_LOG:
        pszText = "[log]";
        break;

    case SSPI_LOG_MORE:
        pszText = "[more]";
        break;
    case SSPI_MSG:
        pszText = "[msg]";
        break;

    default:
        pszText = "[invalid]";
        break;
    }

    return pszText;
}

VOID
VOutputDebugStringPrintf(
    IN OPTIONAL PCSTR pszBanner,
    IN PCSTR pszFmt,
    IN va_list pArgs
    )
{
    CHAR szBuffer[4096] = {0};
    INT cbUsed = 0;

    cbUsed = _snprintf(szBuffer, sizeof(szBuffer) - 1, "%s", pszBanner ? pszBanner : "");

    if (cbUsed >= 0)
    {
        _vsnprintf(szBuffer + cbUsed, sizeof(szBuffer) - cbUsed, pszFmt, pArgs);
    }

    OutputDebugStringA(szBuffer);
}

VOID
OutputDebugStringPrintf(
    IN OPTIONAL PCSTR pszBanner,
    IN PCSTR pszFmt,
    IN ...
    )
{
    va_list marker;

    va_start(marker, pszFmt);

    VOutputDebugStringPrintf(pszBanner ? pszBanner : "", pszFmt, marker);

    va_end(marker);
}

VOID DebugPrintf(
    IN ULONG ulLevel,
    IN PCSTR pszFmt,
    IN ...
    )
{
    if (g_AnsiOutputGlobals.uDebugMask & ulLevel)
    {
        CHAR szBanner[MAX_PATH] = {0};

        DWORD dwPid = GetCurrentProcessId();
        DWORD dwTid = GetCurrentThreadId();

        _snprintf(szBanner, sizeof(szBanner) - 1,
            g_AnsiOutputGlobals.pszDbgPrompt ? "%#x.%#x %s> %s " : "%#x.%#x%s> %s ",
            dwPid,
            dwTid,
            g_AnsiOutputGlobals.pszDbgPrompt ? g_AnsiOutputGlobals.pszDbgPrompt : "", DebugLevel2Str(ulLevel));

        va_list marker;

        va_start(marker, pszFmt);

        VOutputDebugStringPrintf(szBanner, pszFmt, marker);

        va_end(marker);
    }
}

VOID
DebugLogOpen(
    IN PCSTR pszPrompt,
    IN ULONG ulMask
    )
{
    g_AnsiOutputGlobals.uDebugMask = ulMask;
    g_AnsiOutputGlobals.pszDbgPrompt = pszPrompt;
}

VOID
DebugLogOpenSerialized(
    IN PCSTR pszPrompt,
    IN ULONG ulMask,
    IN PCRITICAL_SECTION pCriticalSection
    )
{
    g_AnsiOutputGlobals.uDebugMask = ulMask;
    g_AnsiOutputGlobals.pszDbgPrompt = pszPrompt;
    g_AnsiOutputGlobals.pCriticalSection = pCriticalSection;
}

VOID
DebugLogClose(
    VOID
    )
{
    g_AnsiOutputGlobals.uDebugMask = 0;
    g_AnsiOutputGlobals.pszDbgPrompt = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\msvsharelevel.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvsharelevel.cxx

Abstract:

    msvsharelevel

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvsharelevel.hxx"

NTSTATUS
GetNtlmChallengeMessage(
    IN OPTIONAL UNICODE_STRING* pPassword,
    IN OPTIONAL UNICODE_STRING* pUserName,
    IN OPTIONAL UNICODE_STRING* pDomainName,
    OUT ULONG* pcbNtlmChallengeMessage,
    OUT NTLM_CHALLENGE_MESSAGE** ppNtlmChallengeMessage
    )
{
    TNtStatus Status;

    UCHAR* pWhere = NULL;

    ULONG cbNtlmChallengeMessage = 0;
    NTLM_CHALLENGE_MESSAGE* pNtlmChallengeMessage = NULL;

    *ppNtlmChallengeMessage = NULL;
    *pcbNtlmChallengeMessage = 0;

    cbNtlmChallengeMessage = (pPassword ? pPassword->Length : 0)
        + (pUserName ? pUserName->Length : 0)
        + (pDomainName ? pDomainName->Length : 0)
        + ROUND_UP_COUNT(sizeof(NTLM_CHALLENGE_MESSAGE), sizeof(ULONG_PTR));
    pNtlmChallengeMessage = (NTLM_CHALLENGE_MESSAGE*) new CHAR[cbNtlmChallengeMessage];

    Status DBGCHK = pNtlmChallengeMessage ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pNtlmChallengeMessage, cbNtlmChallengeMessage);
        pWhere = (UCHAR*) (pNtlmChallengeMessage + 1);
        SspCopyStringAsString32(
            pNtlmChallengeMessage,
            (STRING*) pPassword,
            &pWhere,
            &pNtlmChallengeMessage->Password
            );
        SspCopyStringAsString32(
            pNtlmChallengeMessage,
            (STRING*) pUserName,
            &pWhere,
            &pNtlmChallengeMessage->UserName
            );
        SspCopyStringAsString32(
            pNtlmChallengeMessage,
            (STRING*) pDomainName,
            &pWhere,
            &pNtlmChallengeMessage->DomainName
            );
        *ppNtlmChallengeMessage = pNtlmChallengeMessage;
        pNtlmChallengeMessage = NULL;
        *pcbNtlmChallengeMessage = cbNtlmChallengeMessage;
    }

    if (pNtlmChallengeMessage)
    {
        delete [] pNtlmChallengeMessage;
    }

    return Status;
}

NTSTATUS
GetNegociateMessage(
    IN OPTIONAL OEM_STRING* pOemDomainName,
    IN OPTIONAL OEM_STRING* pOemWorkstationName,
    IN ULONG NegotiateFlags,
    OUT ULONG* pcbNegotiateMessage,
    OUT NEGOTIATE_MESSAGE** ppNegotiateMessage
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    NEGOTIATE_MESSAGE* pNegotiateMessage = NULL;
    ULONG cbNegotiateMessage = 0;

    PUCHAR pWhere = NULL;

    *ppNegotiateMessage = NULL;
    *pcbNegotiateMessage = 0;

    cbNegotiateMessage = sizeof(NEGOTIATE_MESSAGE);

    if (pOemDomainName && pOemDomainName->Length && (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED & NegotiateFlags))
    {
        cbNegotiateMessage += pOemDomainName->MaximumLength;
    }

    if (pOemWorkstationName && pOemWorkstationName->Length && (NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED & NegotiateFlags))
    {
        cbNegotiateMessage += pOemWorkstationName->MaximumLength;
    }

    pNegotiateMessage = (NEGOTIATE_MESSAGE*) new char[cbNegotiateMessage];
    Status DBGCHK = pNegotiateMessage ? S_OK : E_OUTOFMEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pNegotiateMessage, cbNegotiateMessage);

        cbNegotiateMessage = sizeof(NEGOTIATE_MESSAGE);
        strcpy(reinterpret_cast<char*>(pNegotiateMessage->Signature), NTLMSSP_SIGNATURE);
        pNegotiateMessage->MessageType = NtLmNegotiate;

        pWhere = (UCHAR*)(pNegotiateMessage + 1);

        if (pOemDomainName && pOemDomainName->Length && (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED & NegotiateFlags))
        {
            SspCopyStringAsString32(
                pNegotiateMessage,
                (STRING*)pOemDomainName,
                &pWhere,
                &pNegotiateMessage->OemDomainName
                );
        }

        if (pOemWorkstationName && pOemWorkstationName->Length && (NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED & NegotiateFlags))
        {
            SspCopyStringAsString32(
                pNegotiateMessage,
                (STRING*) pOemWorkstationName,
                &pWhere,
                &pNegotiateMessage->OemWorkstationName);
         }

        pNegotiateMessage->NegotiateFlags = NegotiateFlags;

        *ppNegotiateMessage = pNegotiateMessage;
        pNegotiateMessage = NULL;
        *pcbNegotiateMessage = cbNegotiateMessage;
    }

    if (pNegotiateMessage)
    {
        delete [] pNegotiateMessage;
    }

    return Status;
}

NTSTATUS
GetChallengeMessage(
    IN ULONG ContextReqFlags,
    IN OPTIONAL ULONG cbNegotiateMessage,
    IN ULONG TargetFlags,
    IN UNICODE_STRING* pTargetInfo,
    IN UNICODE_STRING* pTargetName,
    IN PNEGOTIATE_MESSAGE pNegotiateMessage,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PULONG pcbChallengeMessage,
    OUT CHALLENGE_MESSAGE** ppChallengeMessage,
    OUT PULONG pContextAttributes
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    ULONG ContextAttributes = 0;

    STRING StringTargetName = {0};
    ULONG ChallengeMessageTargetFlags = 0;

    CHALLENGE_MESSAGE* pChallengeMessage = NULL;
    ULONG cbChallengeMessage = 0;
    PUCHAR pWhere = NULL;

    STRING OemWorkstationName = {0};
    STRING OemDomainName = {0};

    ULONG NegotiateFlagsKeyStrength = NTLMSSP_NEGOTIATE_56;

    *ppChallengeMessage = NULL;
    *pContextAttributes = 0;


    if ((ContextReqFlags & ASC_REQ_IDENTIFY) != 0)
    {
        ContextAttributes |= ASC_RET_IDENTIFY;
    }

    if ( (ContextReqFlags & ASC_REQ_DATAGRAM) != 0 )
    {
        ContextAttributes |= ASC_RET_DATAGRAM;
    }

    if ((ContextReqFlags & ASC_REQ_CONNECTION) != 0 )
    {
        ContextAttributes |= ASC_RET_CONNECTION;
    }

    if ((ContextReqFlags & ASC_REQ_INTEGRITY) != 0 )
    {
        ContextAttributes |= ASC_RET_INTEGRITY;
    }

    if ((ContextReqFlags & ASC_REQ_REPLAY_DETECT) != 0)
    {
        ContextAttributes |= ASC_RET_REPLAY_DETECT;
    }

    if ( (ContextReqFlags & ASC_REQ_SEQUENCE_DETECT ) != 0)
    {
        ContextAttributes |= ASC_RET_SEQUENCE_DETECT;
    }

    if ((ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) != 0)
    {
        ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
    }

    if ( ContextReqFlags & ASC_REQ_CONFIDENTIALITY )
    {
        ContextAttributes|= ASC_RET_CONFIDENTIALITY;
    }

    NegotiateFlagsKeyStrength |= NTLMSSP_NEGOTIATE_128;


    //
    // Get the pNegotiateMessage.  If we are re-establishing a datagram
    // context then there may not be one.
    //

    if ( cbNegotiateMessage >= sizeof(OLD_NEGOTIATE_MESSAGE) )
    {
        //
        // Compute the TargetName to return in the ChallengeMessage.
        //

        if ( pNegotiateMessage->NegotiateFlags & NTLMSSP_REQUEST_TARGET ||
             pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
        {

            Status DBGCHK = RtlDuplicateUnicodeString(
                 RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING | RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                 pTargetName, (UNICODE_STRING*) &StringTargetName
                 );

            if (NT_SUCCESS(Status) && ( 0 == (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)) )
            {
                Status DBGCHK = RtlUnicodeStringToOemString((POEM_STRING) &StringTargetName, (PCUNICODE_STRING)&StringTargetName, FALSE);
            }

            //
            // if client is NTLM2-aware, send it target info AV pairs
            //

            if (NT_SUCCESS(Status))
            {

                ChallengeMessageTargetFlags = TargetFlags | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO;
            }
        }
        else
        {
            ChallengeMessageTargetFlags = 0;
        }


        //
        // Allocate a Challenge message
        //

        if (NT_SUCCESS(Status))
        {
            cbChallengeMessage = sizeof(*pChallengeMessage)
              + pTargetName->Length + pTargetInfo->Length;

            pChallengeMessage = (CHALLENGE_MESSAGE*)
                           new CHAR [cbChallengeMessage];
            Status DBGCHK = pChallengeMessage ? STATUS_SUCCESS : STATUS_NO_MEMORY;
        }

        if (NT_SUCCESS(Status))
        {
            RtlZeroMemory(pChallengeMessage, cbChallengeMessage);
            pChallengeMessage->NegotiateFlags = 0;

            //
            // Check that both sides can use the same authentication model.  For
            // compatibility with beta 1 and 2 (builds 612 and 683), no requested
            // authentication type is assumed to be NTLM.  If NetWare is explicitly
            // asked for, it is assumed that NTLM would have been also, so if it
            // wasn't, return an error.
            //

            if ( (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE) &&
                 ((pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) &&
                 ((pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0)
                )
            {
                Status DBGCHK = STATUS_NOT_SUPPORTED;
            }
            else
            {
               pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;
            }
        }

        //
        // if client can do NTLM2, nuke LM_KEY
        //

        if (NT_SUCCESS(Status))
        {
            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
            {
                pNegotiateMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;

                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM2;
            }
            else if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY)
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;
            }

            //
            // If the client wants to always sign messages, so be it.
            //

            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
            }

            //
            // If the caller wants identify level, so be it.
            //

            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_IDENTIFY;

                ContextAttributes |= ASC_RET_IDENTIFY;
            }

            //
            // Determine if the caller wants OEM or UNICODE
            //
            // Prefer UNICODE if caller allows both.
            //

            if ( pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
            }
            else if ( pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
            }
            else
            {
                Status DBGCHK = SEC_E_INVALID_TOKEN;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Client wants Sign capability, OK.
            //

            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN)
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;

                ContextAttributes |= (ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT);
            }

            //
            // Client wants Seal, OK.
            //

            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;

                ContextAttributes |= ASC_RET_CONFIDENTIALITY;
            }

            if (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;

            }

            if ( (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56) &&
                (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_56) )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;
            }

            if ( (pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) &&
                (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_128) )
            {
                pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;
            }


            //
            // If the client supplied the Domain Name and User Name,
            //  and did not request datagram, see if the client is running
            //  on this local machine.
            //

            if ( ( (pNegotiateMessage->NegotiateFlags &
                    NTLMSSP_NEGOTIATE_DATAGRAM) == 0) &&
                 ( (pNegotiateMessage->NegotiateFlags &
                   (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                    NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED)) ==
                   (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                    NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) ) )
            {

                //
                // The client must pass the new negotiate message if they pass
                // these flags
                //

                if (cbNegotiateMessage < sizeof(NEGOTIATE_MESSAGE))
                {
                    Status DBGCHK = SEC_E_INVALID_TOKEN;
                }

                //
                // Convert the names to absolute references so we
                // can compare them
                //

                if (NT_SUCCESS(Status))
                {
                    Status DBGCHK = SspConvertRelativeToAbsolute(
                        pNegotiateMessage,
                        cbNegotiateMessage,
                        &pNegotiateMessage->OemDomainName,
                        FALSE,     // No special alignment
                        FALSE,
                        &OemDomainName
                        );
                }
            }

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = SspConvertRelativeToAbsolute(
                    pNegotiateMessage,
                    cbNegotiateMessage,
                    &pNegotiateMessage->OemWorkstationName,
                    FALSE,     // No special alignment
                    FALSE,
                    &OemWorkstationName
                    );
            }
        }

        //
        // Check if datagram is being negotiated
        //

        if ( NT_SUCCESS(Status) &&
             ((pNegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) ==
                NTLMSSP_NEGOTIATE_DATAGRAM) )
        {
            pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
        }
    }
    else
    {
        //
        // No negotiate message.  We need to check if the caller is asking
        // for datagram.
        //

        SspiPrint(SSPI_WARN, TEXT("GetChallengeMessage get OLD_NEGOTIATE_MESSAGE\n"))
        ;
        if ((ContextReqFlags & ASC_REQ_DATAGRAM) == 0)
        {
            Status DBGCHK = SEC_E_INVALID_TOKEN;
        }

        //
        // always send target info -- new for NTLM3!
        //
        if (NT_SUCCESS(Status))
        {
            ChallengeMessageTargetFlags = NTLMSSP_NEGOTIATE_TARGET_INFO;

            cbChallengeMessage = sizeof(*pChallengeMessage) + pTargetInfo->Length;


            pChallengeMessage = (CHALLENGE_MESSAGE*) new CHAR[cbChallengeMessage];

            Status DBGCHK = pChallengeMessage ? S_OK : STATUS_NO_MEMORY;
        }

        //
        // Record in the context that we are doing datagram.  We will tell
        // the client everything we can negotiate and let it decide what
        // to negotiate.
        //

        if (NT_SUCCESS(Status))
        {
            RtlZeroMemory(pChallengeMessage, cbChallengeMessage);

            pChallengeMessage->NegotiateFlags = NTLMSSP_NEGOTIATE_DATAGRAM |
                                                NTLMSSP_NEGOTIATE_UNICODE |
                                                NTLMSSP_NEGOTIATE_OEM |
                                                NTLMSSP_NEGOTIATE_SIGN |
                                                NTLMSSP_NEGOTIATE_LM_KEY |
                                                NTLMSSP_NEGOTIATE_NTLM |
                                                NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                                NTLMSSP_NEGOTIATE_IDENTIFY |
                                                NTLMSSP_NEGOTIATE_NTLM2 |
                                                NTLMSSP_NEGOTIATE_KEY_EXCH |
                                                NegotiateFlagsKeyStrength;

            pChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
        }
    }

    //
    // Build the Challenge Message
    //

    if (NT_SUCCESS(Status))
    {
        strcpy((PSTR) pChallengeMessage->Signature, NTLMSSP_SIGNATURE );

        pChallengeMessage->MessageType = NtLmChallenge;
        RtlCopyMemory(
            pChallengeMessage->Challenge,
            ChallengeToClient,
            MSV1_0_CHALLENGE_LENGTH
            );
        pWhere = (PUCHAR) (pChallengeMessage + 1);

        SspCopyStringAsString32(pChallengeMessage,
            (PSTRING) pTargetName,
            &pWhere,
            &pChallengeMessage->TargetName);

        SspCopyStringAsString32(pChallengeMessage,
            (PSTRING)pTargetInfo,
            &pWhere,
            &pChallengeMessage->TargetInfo);

        pChallengeMessage->NegotiateFlags |= ChallengeMessageTargetFlags;

        SspiPrint(SSPI_LOG, TEXT("GetChallengeMessage pNegotiateMessage->NegotiateFlags %#x, pChallengeMessage->NegotiateFlags %#x\n"),
            pNegotiateMessage->NegotiateFlags, pChallengeMessage->NegotiateFlags);
        SspiPrintHex(SSPI_LOG, TEXT("pNegotiateMessage"), cbNegotiateMessage, pNegotiateMessage);
        SspiPrintHex(SSPI_LOG, TEXT("pChallengeMessage"), cbChallengeMessage, pChallengeMessage);

        *ppChallengeMessage = pChallengeMessage;
        pChallengeMessage = NULL;
        *pContextAttributes = ContextReqFlags;
        *pcbChallengeMessage = cbChallengeMessage;
    }


    if (pChallengeMessage)
    {
        delete [] pChallengeMessage;
    }

    RtlFreeUnicodeString((PUNICODE_STRING) &StringTargetName);

    return Status;
}

NTSTATUS
GetAuthenticateMessage(
    IN PCredHandle phCredentialHandle,
    IN ULONG fContextReq,
    IN PTSTR pszTargetName,
    IN ULONG TargetDataRep,
    IN ULONG cbNtlmChallengeMessage,
    IN OPTIONAL NTLM_CHALLENGE_MESSAGE* pNtlmChallengeMessage,
    IN ULONG cbChallengeMessage,
    IN CHALLENGE_MESSAGE* pChallengeMessage,
    OUT PCtxtHandle phClientContextHandle,
    OUT ULONG* pfContextAttr,
    OUT ULONG* pcbAuthMessage,
    OUT AUTHENTICATE_MESSAGE** ppAuthMessage,
    OUT NTLM_INITIALIZE_RESPONSE* pInitResponse
    )
{
    TNtStatus Status = S_OK;

    ULONG fContextAttr = 0;
    CtxtHandle hClientCtxtHandle;

    SecBufferDesc InBuffDesc = {0};
    SecBuffer InBuffs[2] = {0};
    SecBufferDesc OutBuffDesc = {0};
    SecBuffer OutBuffs[2] = {0};

    TimeStamp Expiry = {0};

    SecInvalidateHandle(&hClientCtxtHandle);
    SecInvalidateHandle(phClientContextHandle);

    InBuffDesc.pBuffers = InBuffs;
    InBuffDesc.cBuffers = 1;
    InBuffDesc.ulVersion = 0;
    InBuffs[0].pvBuffer = pChallengeMessage;
    InBuffs[0].cbBuffer = cbChallengeMessage;
    InBuffs[0].BufferType = SECBUFFER_TOKEN;

    if ((fContextReq & ISC_REQ_USE_SUPPLIED_CREDS)
        && (pNtlmChallengeMessage && cbNtlmChallengeMessage))
    {
        InBuffDesc.cBuffers = 2;
        InBuffs[1].pvBuffer = pNtlmChallengeMessage;
        InBuffs[1].cbBuffer = cbNtlmChallengeMessage;
        InBuffs[1].BufferType = SECBUFFER_TOKEN;

        if (0 == (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            fContextReq |= ISC_REQ_USE_SUPPLIED_CREDS;
            SspiPrint(SSPI_WARN, TEXT("Creds supplied but ISC_REQ_USE_SUPPLIED_CREDS was not set, added\n"));
        }
    }

    OutBuffDesc.pBuffers = OutBuffs;
    OutBuffDesc.cBuffers = 2;
    OutBuffDesc.ulVersion = 0;

    if (0 == (fContextReq & ISC_REQ_ALLOCATE_MEMORY))
    {
        fContextReq |= ISC_REQ_ALLOCATE_MEMORY;
        SspiPrint(SSPI_LOG, TEXT("ISC_REQ_ALLOCATE_MEMORY was not set, added\n"));
    }

    OutBuffs[0].pvBuffer = NULL;
    OutBuffs[0].cbBuffer = 0;
    OutBuffs[0].BufferType = SECBUFFER_TOKEN;
    OutBuffs[1].pvBuffer = NULL;
    OutBuffs[1].cbBuffer = 0;
    OutBuffs[1].BufferType = SECBUFFER_TOKEN;

    SspiPrint(SSPI_LOG, TEXT("GetAuthenticateMessage calling InitializeSecurityContext pszTargetName (%s), fContextReq %#x, TargetDataRep %#x, hCred %#x:%#x\n"),
        pszTargetName, fContextReq, TargetDataRep, phCredentialHandle->dwUpper, phCredentialHandle->dwLower);

    Status DBGCHK = InitializeSecurityContext(
        phCredentialHandle,
        NULL,
        pszTargetName,
        fContextReq,
        0,
        TargetDataRep,
        &InBuffDesc,
        0,
        &hClientCtxtHandle,
        &OutBuffDesc,
        &fContextAttr,
        &Expiry
        );

    if (NT_SUCCESS(Status))
    {
        *phClientContextHandle = hClientCtxtHandle;
        SecInvalidateHandle(&hClientCtxtHandle);

        *pfContextAttr = fContextAttr;

        *ppAuthMessage = (AUTHENTICATE_MESSAGE *) OutBuffs[0].pvBuffer;
        OutBuffs[0].pvBuffer = NULL;

        *pcbAuthMessage = OutBuffs[0].cbBuffer;

        ASSERT(sizeof(*pInitResponse) == OutBuffs[1].cbBuffer);
        RtlCopyMemory(pInitResponse, OutBuffs[1].pvBuffer, sizeof(*pInitResponse));

        SspiPrint(SSPI_LOG, TEXT("ClientCtxtHandle is %#x:%#x, fContextAttr %#x\n"),
            phClientContextHandle->dwUpper, phClientContextHandle->dwLower, *pfContextAttr);

        SspiPrintHex(SSPI_LOG, TEXT("AuthMessage"), *pcbAuthMessage, *ppAuthMessage);
        SspiPrintHex(SSPI_LOG, TEXT("UserSessionKey"), MSV1_0_USER_SESSION_KEY_LENGTH, pInitResponse->UserSessionKey);
        SspiPrintHex(SSPI_LOG, TEXT("LanmanSessionKey"), MSV1_0_LANMAN_SESSION_KEY_LENGTH, pInitResponse->LanmanSessionKey);

        SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("Expiry"), &Expiry);
    }

    if (OutBuffs[0].pvBuffer)
    {
        FreeContextBuffer(OutBuffs[0].pvBuffer);
    }

    if (OutBuffs[1].pvBuffer)
    {
        FreeContextBuffer(OutBuffs[1].pvBuffer);
    }

    return Status;
}

NTSTATUS
MsvChallenge(
    IN OPTIONAL PTSTR pszCredPrincipal,
    IN OPTIONAL LUID* pCredLogonID,
    IN OPTIONAL VOID* pAuthData,
    IN OEM_STRING* pOemDomainName,
    IN OEM_STRING* pOemWorkstationName,
    IN ULONG NegotiateFlags,
    IN ULONG TargetFlags,
    IN BOOLEAN bForceGuest,
    IN ULONG fContextAttr,
    IN ULONG TargetDataRep,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN OPTIONAL UNICODE_STRING* pDnsDomainName,
    IN OPTIONAL UNICODE_STRING* pDnsComputerName,
    IN OPTIONAL UNICODE_STRING* pDnsTreeName,
    IN OPTIONAL UNICODE_STRING* pComputerName,
    IN OPTIONAL UNICODE_STRING* pComputerDomainName,
    OUT ULONG* pcbAuthMessage,
    OUT AUTHENTICATE_MESSAGE** ppAuthMessage,
    OUT PCtxtHandle phCliCtxt,
    OUT ULONG* pfContextAttr
    )
{

    TNtStatus Status;
    UNICODE_STRING TargetInfo = {0};

    WCHAR ScratchBuffer[2 * DNS_MAX_NAME_LENGTH + 2] = {0};
    UNICODE_STRING TargetName = {0, sizeof(ScratchBuffer), ScratchBuffer};


    NTLM_CHALLENGE_MESSAGE* pNtlmChallengeMessage = NULL;
    ULONG cbNtlmChallengeMessage = 0;

    NEGOTIATE_MESSAGE* pNegotiateMessage = NULL;
    ULONG cbNegotiateMessage = 0;

    CHALLENGE_MESSAGE* pChallengeMesssage = NULL;
    ULONG cbChallengeMessage = 0;

    AUTHENTICATE_MESSAGE* pAuthMessage = NULL;
    ULONG cbAuthMessage = 0;

    NTLM_INITIALIZE_RESPONSE InitResponse = {0};

    CtxtHandle hCliCtxt;
    CredHandle hCliCred;

    SecInvalidateHandle(&hCliCred);
    SecInvalidateHandle(&hCliCtxt);

    *pfContextAttr = 0;
    SecInvalidateHandle(phCliCtxt);
    *ppAuthMessage = NULL;
    *pcbAuthMessage = 0;

    SspiPrint(SSPI_LOG, TEXT("MsvChallenge CredPrincipal %s, NegotiateFlags %#x, TargetFlags %#x, bForceGuest %#x")
        TEXT("fContextAttr %#x, TargetDataRep %#x, pAuthData %p, pCredLogonID %p\n"),
        pszCredPrincipal, NegotiateFlags, TargetFlags, bForceGuest, fContextAttr, TargetDataRep, pAuthData, pCredLogonID);
    DebugPrintf(SSPI_LOG, "OemDomainName (%s), OemWorkstation (%s)\n", pOemDomainName, pOemWorkstationName);
    SspiPrintHex(SSPI_LOG, TEXT("ChallengeToClient"), MSV1_0_CHALLENGE_LENGTH, ChallengeToClient);
    SspiPrint(SSPI_LOG, TEXT("pPassword %wZ, pUserName %wZ, pDomainName %wZ, pDnsDomainName %wZ, pDnsComputerName %wZ, pDnsTreeName %wZ, pComputerName %wZ, pComputerDomainName %wZ\n"),
         pPassword, pUserName, pDomainName, pDnsDomainName, pDnsComputerName, pDnsTreeName, pComputerName, pComputerDomainName);

    if (pComputerDomainName && pComputerDomainName->Length)
    {
        //
        // Target name is of form "domain name\0computer name"
        //

        RtlCopyMemory(ScratchBuffer, pComputerDomainName->Buffer, pComputerDomainName->Length);
        if (pComputerName && pComputerName->Length)
        {
            RtlCopyMemory(ScratchBuffer + (pComputerDomainName->Length / sizeof(WCHAR)) + 1, pComputerName->Buffer, pComputerName->Length);

            TargetName.Length = pComputerDomainName->Length + pComputerName->Length + 1;
        }
        else
        {
            TargetName.Length = pComputerDomainName->Length;
        }
    }
    else if (pComputerName && pComputerName->Length)
    {
        RtlCopyMemory(ScratchBuffer, pComputerName->Buffer, pComputerName->Length);
        TargetName.Length = pComputerName->Length;
    }

    SspiPrintHex(SSPI_LOG, TEXT("MsvChallenge TargetName"), TargetName.Length, TargetName.Buffer);

    Status DBGCHK = GetNegociateMessage(
        pOemDomainName,
        pOemWorkstationName,
        NegotiateFlags,
        &cbNegotiateMessage,
        &pNegotiateMessage
        );

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetTargetInfo(
            TargetFlags,
            bForceGuest,
            pDnsDomainName,
            pDnsComputerName,
            pDnsTreeName,
            &TargetName,
            pComputerName,
            &TargetInfo
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetChallengeMessage(
            fContextAttr,
            cbNegotiateMessage,
            TargetFlags,
            &TargetInfo,
            &TargetName,
            pNegotiateMessage,
            ChallengeToClient,
            &cbChallengeMessage,
            &pChallengeMesssage,
            &fContextAttr
            );
    }

    if (NT_SUCCESS(Status)
        && ((pPassword && pPassword->Length)
            || (pDomainName && pDomainName->Length)
            || (pUserName && pUserName->Length)))
    {
        if (0 == (fContextAttr & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            SspiPrint(SSPI_WARN, TEXT("MsvChallenge explicit cred supplied, but ISC_REQ_USE_SUPPLIED_CREDS was not set, added\n"));
            fContextAttr |= ISC_REQ_USE_SUPPLIED_CREDS;
        }

        Status DBGCHK = GetNtlmChallengeMessage(
            pPassword,
            pUserName,
            pDomainName,
            &cbNtlmChallengeMessage,
            &pNtlmChallengeMessage
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetCredHandle(
            pszCredPrincipal,
            pCredLogonID,
            TEXT("NTLM"),
            pAuthData,
            SECPKG_CRED_OUTBOUND,
            &hCliCred
            );
    }

    #if defined(UNICODE) || defined(_UNICODE)

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("MsvChallenge hCliCred %#x:%#x\n"), hCliCred.dwUpper, hCliCred.dwLower);

        Status DBGCHK = GetAuthenticateMessage(
            &hCliCred,
            fContextAttr,
            TargetName.Buffer,
            TargetDataRep,
            cbNtlmChallengeMessage,
            pNtlmChallengeMessage,
            cbChallengeMessage,
            pChallengeMesssage,
            &hCliCtxt,
            &fContextAttr,
            &cbAuthMessage,
            &pAuthMessage,
            &InitResponse
            );
    }

    #else

    ANSI_STRING AnsiTargetName = {0};

    //
    // RtlUnicodeStringToAnsiString appends the NULL
    //

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = RtlUnicodeStringToAnsiString(&AnsiTargetName, &TargetName, TRUE);
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("MsvChallenge hCliCred %#x:%#x\n"), hCliCred.dwUpper, hCliCred.dwLower);

        Status DBGCHK = GetAuthenticateMessage(
            &hCliCred,
            fContextAttr,
            AnsiTargetName.Buffer,
            TargetDataRep,
            cbNtlmChallengeMessage,
            pNtlmChallengeMessage,
            cbChallengeMessage,
            pChallengeMesssage,
            &hCliCtxt,
            &fContextAttr,
            &cbAuthMessage,
            &pAuthMessage,
            &InitResponse
            );
    }

    RtlFreeAnsiString(&AnsiTargetName);

    #endif

    if (NT_SUCCESS(Status))
    {
        *phCliCtxt = hCliCtxt;
        SecInvalidateHandle(&hCliCtxt);
        *ppAuthMessage = pAuthMessage;

        pAuthMessage = NULL;
        *pcbAuthMessage = cbAuthMessage;
        *pfContextAttr = fContextAttr;
    }

    if (SecIsValidHandle(&hCliCtxt))
    {
        DeleteSecurityContext(&hCliCtxt);
    }

    if (SecIsValidHandle(&hCliCred))
    {
        DeleteSecurityContext(&hCliCred);
    }

    if (pAuthMessage)
    {
        FreeContextBuffer(pAuthMessage);
    }

    if (pNegotiateMessage)
    {
        delete[] pNegotiateMessage;
    }

    if (pChallengeMesssage)
    {
        delete [] pChallengeMesssage;
    }

    if (pNtlmChallengeMessage)
    {
        delete [] pNtlmChallengeMessage;
    }

    return Status;
}

NTSTATUS
GetAuthenticateResponse(
    IN PCredHandle pServerCredHandle,
    IN ULONG fContextAttr,
    IN ULONG TargetDataRep,
    IN ULONG cbAuthMessage,
    IN AUTHENTICATE_MESSAGE* pAuthMessage,
    IN NTLM_AUTHENTICATE_MESSAGE* pNtlmAuthMessage,
    OUT PCtxtHandle phServerCtxtHandle,
    OUT ULONG* pfContextAttr,
    OUT NTLM_ACCEPT_RESPONSE* pAcceptResponse
    )
{

    TNtStatus Status = STATUS_SUCCESS;

    CtxtHandle hServerCtxtHandle;

    SecBufferDesc InBuffDesc = {0};
    SecBuffer InBuffs[2] = {0};
    SecBufferDesc OutBuffDesc = {0};
    SecBuffer OutBuff = {0};

    TimeStamp Expiry = {0};

    SecInvalidateHandle(&hServerCtxtHandle);
    SecInvalidateHandle(phServerCtxtHandle);


    InBuffDesc.pBuffers = InBuffs;
    InBuffDesc.cBuffers = 2;
    InBuffDesc.ulVersion = 0;
    InBuffs[0].pvBuffer = pAuthMessage;
    InBuffs[0].cbBuffer = cbAuthMessage;
    InBuffs[0].BufferType = SECBUFFER_TOKEN;
    InBuffs[1].pvBuffer = pNtlmAuthMessage;
    InBuffs[1].cbBuffer = sizeof(*pNtlmAuthMessage);
    InBuffs[1].BufferType = SECBUFFER_TOKEN;

    OutBuffDesc.pBuffers = &OutBuff;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.ulVersion = 0;
    OutBuff.pvBuffer = pAcceptResponse;
    OutBuff.cbBuffer = sizeof(*pAcceptResponse);
    OutBuff.BufferType = SECBUFFER_TOKEN;

    if (fContextAttr & ASC_REQ_ALLOCATE_MEMORY)
    {
        SspiPrint(SSPI_WARN, TEXT("Authenticate ASC_REQ_ALLOCATE_MEMORY was set, removed\n"));
        fContextAttr &= ~(ASC_REQ_ALLOCATE_MEMORY);
    }

    SspiPrint(SSPI_LOG, TEXT("GetAuthenticateResponse calling AcceptSecurityContext fContextAttr %#x, TargetDataRep %#x, hCred %#x:%#x\n"),
        fContextAttr, TargetDataRep, pServerCredHandle->dwUpper, pServerCredHandle->dwLower);

    Status DBGCHK = AcceptSecurityContext(
        pServerCredHandle,
        NULL,
        &InBuffDesc,
        fContextAttr,
        TargetDataRep,
        &hServerCtxtHandle,
        &OutBuffDesc,
        &fContextAttr,
        &Expiry
        );
    if (NT_SUCCESS(Status))
    {
       *phServerCtxtHandle = hServerCtxtHandle;
       SecInvalidateHandle(&hServerCtxtHandle);
       *pfContextAttr = fContextAttr;

       ASSERT(sizeof(*pAcceptResponse) == OutBuff.cbBuffer);
       RtlCopyMemory(pAcceptResponse, OutBuff.pvBuffer, sizeof(*pAcceptResponse));

       SspiPrint(SSPI_LOG, TEXT("ServerCtxtHandle is %#x:%#x, fContextAttr %#x\n"),
           phServerCtxtHandle->dwUpper, phServerCtxtHandle->dwLower, *pfContextAttr);

       SspiPrint(SSPI_LOG, TEXT("Authenticate LogonId %#x:%#x, UserFlags %#x\n"),
           pAcceptResponse->LogonId.HighPart, pAcceptResponse->LogonId.LowPart, pAcceptResponse->UserFlags);
       SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("KickoffTime"), &pAcceptResponse->KickoffTime);
       SspiPrintHex(SSPI_LOG, TEXT("UserSessionKey"), MSV1_0_USER_SESSION_KEY_LENGTH, pAcceptResponse->UserSessionKey);
       SspiPrintHex(SSPI_LOG, TEXT("LanmanSessionKey"), MSV1_0_LANMAN_SESSION_KEY_LENGTH, pAcceptResponse->LanmanSessionKey);
       SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("Expiry"), &Expiry);
    }

    if (SecIsValidHandle(&hServerCtxtHandle))
    {
       DeleteSecurityContext(&hServerCtxtHandle);
    }

    return Status;
}

NTSTATUS
MsvAuthenticate(
    IN OPTIONAL PTSTR pszCredPrincipal,
    IN OPTIONAL LUID* pCredLogonID,
    IN OPTIONAL VOID* pAuthData,
    IN ULONG fContextAttr,
    IN ULONG TargetDataRep,
    IN ULONG cbAuthMessage,
    IN AUTHENTICATE_MESSAGE* pAuthMessage,
    IN NTLM_AUTHENTICATE_MESSAGE* pNtlmAuthMessage,
    OUT PCtxtHandle phServerCtxt,
    OUT ULONG* pfContextAttr
    )
{
    TNtStatus Status;

    CredHandle hServerCred;
    CtxtHandle hServerCtxt;

    NTLM_ACCEPT_RESPONSE AcceptResponse = {0};

    SecInvalidateHandle(&hServerCred);
    SecInvalidateHandle(&hServerCtxt);

    SspiPrint(SSPI_LOG, TEXT("MsvAuthenticate pszCredPrincipal %s, fContextAttr %#x, TargetDataRep %#x, pCredLogonID %p, pAuthData %p\n"),
        pszCredPrincipal, fContextAttr, TargetDataRep, pCredLogonID, pAuthData);
    SspiPrintHex(SSPI_LOG, TEXT("pAuthMessage"), cbAuthMessage, pAuthMessage);
    SspiPrintHex(SSPI_LOG, TEXT("pNtlmAuthMessage->ChallengeToClient"), MSV1_0_CHALLENGE_LENGTH, pNtlmAuthMessage->ChallengeToClient);
    SspiPrint(SSPI_LOG, TEXT("pNtlmAuthMessage->ParameterControl %#x\n"), pNtlmAuthMessage->ParameterControl);

    Status DBGCHK = GetCredHandle(
        pszCredPrincipal,
        pCredLogonID,
        TEXT("NTLM"),
        pAuthData,
        SECPKG_CRED_INBOUND,
        &hServerCred
        );

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetAuthenticateResponse(
            &hServerCred,
            fContextAttr,
            TargetDataRep,
            cbAuthMessage,
            pAuthMessage,
            pNtlmAuthMessage,
            &hServerCtxt,
            &fContextAttr,
            &AcceptResponse
            );
    }

    if (NT_SUCCESS(Status))
    {
        *pfContextAttr = fContextAttr;
        *phServerCtxt = hServerCtxt;
        SecInvalidateHandle(&hServerCtxt);
    }

    if (SecIsValidHandle(&hServerCtxt))
    {
        DeleteSecurityContext(&hServerCtxt);
    }

    if (SecIsValidHandle(&hServerCred))
    {
        FreeCredentialsHandle(&hServerCred);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\priv.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    priv.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             January 14, 2002 Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "priv.hxx"

TPrivilege::TPrivilege(
    IN ULONG Privilege,
    IN BOOLEAN bEnable
    ) : m_Privilege(Privilege),
    m_bEnable(bEnable),
    m_hToken(NULL),
    m_Status(STATUS_UNSUCCESSFUL)
{
    m_Status DBGCHK = Initialize();
}

TPrivilege::~TPrivilege(
    VOID
    )
{
    if (m_hToken)
    {
        TNtStatus Status;

        BOOLEAN bWasEnabled = FALSE;
        LUID LuidPrivilege = {0};

        PTOKEN_PRIVILEGES pNewPrivileges = NULL;
        PTOKEN_PRIVILEGES pOldPrivileges = NULL;
        ULONG cbReturnLength = 0;

        UCHAR Buffer1[sizeof(TOKEN_PRIVILEGES) +  ((1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))] = {0};
        UCHAR Buffer2[sizeof(TOKEN_PRIVILEGES) + ((1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))] = {0};

        pNewPrivileges = (PTOKEN_PRIVILEGES)Buffer1;
        pOldPrivileges = (PTOKEN_PRIVILEGES)Buffer2;

        LuidPrivilege = RtlConvertUlongToLuid(m_Privilege);

        pNewPrivileges->PrivilegeCount = 1;
        pNewPrivileges->Privileges[0].Luid = LuidPrivilege;
        pNewPrivileges->Privileges[0].Attributes = !m_bEnable ? SE_PRIVILEGE_ENABLED : 0;

        Status DBGCHK = NtAdjustPrivilegesToken(
            m_hToken, // TokenHandle
            FALSE, // DisableAllPrivileges
            pNewPrivileges, // NewPrivileges
            sizeof(Buffer1), // BufferLength
            pOldPrivileges, // PreviousState (OPTIONAL)
            &cbReturnLength // ReturnLength
            );
        if (NT_SUCCESS(Status))
        {
            if (pOldPrivileges->PrivilegeCount == 0)
            {
                bWasEnabled = m_bEnable;
            }
            else
            {
                bWasEnabled = (pOldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ? TRUE : FALSE;
            }

            SspiPrint(SSPI_LOG, TEXT("TPrivilege::~TPrivilege %s privilege %#x for token %p (WasEnable? %#x)\n"),
                !m_bEnable ? TEXT("enables") : TEXT("disables"),
                m_Privilege,
                m_hToken,
                bWasEnabled);
        }
        NtClose(m_hToken);
    }
}

NTSTATUS
TPrivilege::Validate(
    VOID
    ) const
{
    return m_Status;
}

/******************************************************************************

    Private Methods

******************************************************************************/
NTSTATUS
TPrivilege::Initialize(
    VOID
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;

    LUID LuidPrivilege = {0};

    PTOKEN_PRIVILEGES pNewPrivileges = NULL;
    PTOKEN_PRIVILEGES pOldPrivileges = NULL;
    HANDLE hToken = NULL;
    ULONG cbReturnLength = 0;
    BOOLEAN bWasEnabled = FALSE;
    BOOLEAN bIsImpersonation = TRUE;

    UCHAR Buffer1[sizeof(TOKEN_PRIVILEGES) +  ((1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))] = {0};
    UCHAR Buffer2[sizeof(TOKEN_PRIVILEGES) + ((1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))] = {0};

    pNewPrivileges = (PTOKEN_PRIVILEGES) Buffer1;
    pOldPrivileges = (PTOKEN_PRIVILEGES) Buffer2;

    DBGCFG1(Status, STATUS_NO_TOKEN);

    Status DBGCHK = NtOpenThreadToken(
        NtCurrentThread(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        FALSE,
        &hToken
        );

    if (STATUS_NO_TOKEN == (NTSTATUS) Status)
    {
        bIsImpersonation = FALSE;
        Status DBGCHK = NtOpenProcessToken(
            NtCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken
            );
    }

    if (NT_SUCCESS(Status))
    {
        LuidPrivilege = RtlConvertUlongToLuid(m_Privilege);

        pNewPrivileges->PrivilegeCount = 1;
        pNewPrivileges->Privileges[0].Luid = LuidPrivilege;
        pNewPrivileges->Privileges[0].Attributes = m_bEnable ? SE_PRIVILEGE_ENABLED : 0;

        Status DBGCHK = NtAdjustPrivilegesToken(
            hToken, // TokenHandle
            FALSE, // DisableAllPrivileges
            pNewPrivileges, // NewPrivileges
            sizeof(Buffer1), // BufferLength
            pOldPrivileges, // PreviousState (OPTIONAL)
            &cbReturnLength // ReturnLength
            );
    }

    if (NT_SUCCESS(Status))
    {
        if (pOldPrivileges->PrivilegeCount == 0)
        {
            bWasEnabled = m_bEnable;
        }
        else
        {
            bWasEnabled = (pOldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ? TRUE : FALSE;
        }

        if ((!bWasEnabled && m_bEnable)  || (bWasEnabled && !m_bEnable))
        {
            m_hToken = hToken;
            hToken = NULL;

            SspiPrint(SSPI_LOG, TEXT("TPrivilege::Initialize %s privilege %#x for %s token %p\n"),
                m_bEnable ? TEXT("enables") : TEXT("disables"),
                m_Privilege,
                bIsImpersonation ? TEXT("thread") : TEXT("process"),
                m_hToken);
        }
    }

    //
    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust the one privilege.
    //

    if (STATUS_NOT_ALL_ASSIGNED == (NTSTATUS) Status )
    {
        Status DBGCHK = STATUS_PRIVILEGE_NOT_HELD;
    }

    if (hToken)
    {
        NtClose(hToken);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sockcomm.h ===
/*++

Copyright 1996-1997 Microsoft Corporation

Module Name:

    sockcomm.h

Abstract:

    Some common functions for sockets

Revision History:

--*/

#ifndef SOCK_COMM_H
#define SOCK_COMM_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winsock.h>

BOOL
InitWinsock(
    VOID
    );

BOOL
TermWinsock(
    VOID
    );

BOOL
SendMsg(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf
    );

BOOL
ReceiveMsg(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN OUT VOID* pBuf,
    OUT ULONG* pcbRead
    );

BOOL
SendBytes(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf
    );

BOOL
ReceiveBytes(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf,
    OUT ULONG *pcbRead
    );

#ifdef __cplusplus
}
#endif

#endif // SOCK_COMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sources.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Larry Zhu (LZhu)                     December 1, 2001 Created

!ENDIF

USE_MSVCRT=1
NO_NTDLL=1
USE_NTDLL=0   
NO_BINPLACE=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

USE_NATIVE_EH=1

INCLUDES=..;..\..\inc;..\lib;        \
         ..\..\idl;                  \
         ..\..\idl\$(O);             \
         $(DS_GLOBAL_INC);           \
         $(NTDS_INC);                \
         $(SECURITY_INC);            \
         $(BASE_INC_PATH);           \
         $(COM_INC_PATH);            \
         $(DS_INC_PATH);             \
         $(DS_INC_PATH)\crypto;      \
         $(DRIVERS_INC_PATH);        \
         $(ENDUSER_INC_PATH);        \
         $(WINDOWS_INC_PATH);        \
         $(NET_INC_PATH);

SOURCES=                     \
        ..\output.cxx        \
        ..\lsasspi.cxx       \
        ..\utils.cxx         \
        ..\dbgstate.cxx      \
        ..\ntstatus.cxx      \
        ..\hresult.cxx       \
        ..\kerberr.cxx       \
        ..\common.cxx        \
        ..\impersonation.cxx \
        ..\priv.cxx          \
        ..\logon.cxx         \
        ..\krbutils.cxx      \
        ..\krb5.c            \
        ..\sockcomm.c        \
        ..\transport.cxx     \
        ..\sspics.cxx        \
        ..\sspiutils.cxx     \
        ..\sspioutput.cxx    \
        ..\msvsharelevel.cxx \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sspics.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sspics.cxx

Abstract:

    sspics

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspics.hxx"


TSspiClientThreadParam::TSspiClientThreadParam(
    VOID
    ) : ParameterType(kSspiCliThreadParameters),
    ServerSocketPort(kServerSocketPort),
    ClientSocketPort(kClientSocketPort),
    pszServer(NULL)
{
}

TSspiClientThreadParam::~TSspiClientThreadParam(
    VOID
    )
{
}

TSspiServerThreadParam::TSspiServerThreadParam(
    VOID
    ) : ParameterType(kSspiSrvThreadParameters),
    ServerSocket(INVALID_SOCKET)
{
}

TSspiServerThreadParam::~TSspiServerThreadParam(
    VOID
    )
{
}

TSsiServerMainLoopThreadParam::TSsiServerMainLoopThreadParam(
    VOID
    ) : ParameterType(kSspiSrvMainThreadParameters),
    ServerSocketPort(kServerSocketPort)
{
}

TSsiServerMainLoopThreadParam::~TSsiServerMainLoopThreadParam(
    VOID
    )
{
}

DWORD WINAPI
SspiClientThread(
    IN PVOID pParameter   // thread data
    )
{
    THResult hRetval = E_FAIL;

    CHAR szClientComputerName[DNS_MAX_NAME_LENGTH + 1] = {0};
    TSspiClientThreadParam* pCliParam = (TSspiClientThreadParam*) pParameter;
    SOCKET ClientSocketListen = INVALID_SOCKET;
    SOCKET ServerSocket = INVALID_SOCKET;
    SOCKET ClientSocket = INVALID_SOCKET;
    DWORD ServerThreadId = 0;
    ULONG MessageNum = 0;

    DebugPrintf(SSPI_LOG, "SspiClientThread ParameterType %#x\n", pCliParam->ParameterType);

    hRetval DBGCHK = pCliParam->ParameterType == kSspiCliThreadParameters ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = TlsSetValue(g_MessageNumTlsIndex, &MessageNum) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = gethostname(szClientComputerName, sizeof(szClientComputerName) - 1) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ServerInit(pCliParam->ClientSocketPort, "SspiClient", &ClientSocketListen);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiClientThread connecting to %s:%#x\n", pCliParam->pszServer, pCliParam->ServerSocketPort);

        hRetval DBGCHK = ClientConnect(
                            pCliParam->pszServer,
                            pCliParam->ServerSocketPort,
                            &ServerSocket
                            );
    }

    if (SUCCEEDED(hRetval))
    {
         hRetval DBGCHK = WriteMessage(
                             ServerSocket,
                             sizeof(pCliParam->ClientSocketPort),
                             &pCliParam->ClientSocketPort
                             );
    }

    if (SUCCEEDED(hRetval))
    {
         hRetval DBGCHK = WriteMessage(
                             ServerSocket,
                             strlen(szClientComputerName),
                             szClientComputerName
                             );
    }

    if (SUCCEEDED(hRetval))
    {
        ClientSocket = accept(ClientSocketListen, NULL, NULL);
        hRetval DBGCHK = (INVALID_SOCKET != ClientSocket) ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (SUCCEEDED(hRetval))
    {
        ULONG cbRead = 0;
        hRetval DBGCHK = ReadMessage(
                            ClientSocket,
                            sizeof(ServerThreadId),
                            &ServerThreadId,
                            &cbRead
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiClientThread got ServerThreadId %#x\n", ServerThreadId);

        hRetval DBGCHK = SspiClientStart(
                            pCliParam,
                            ServerSocket,
                            ClientSocket
                            );
    }

    THResult hr;

    if (INVALID_SOCKET != ClientSocket)
    {
        hr DBGCHK = closesocket(ClientSocket) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (INVALID_SOCKET != ServerSocket)
    {
        hr DBGCHK = closesocket(ServerSocket) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (INVALID_SOCKET != ClientSocketListen)
    {
        hr DBGCHK = closesocket(ClientSocketListen) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    //
    // use SspiPrint to get around -quiet
    //

    SspiPrint(SSPI_LOG, TEXT("SspiClientThread terminating %#x\n"), (HRESULT) hRetval);

    return HRESULT_CODE(hRetval);
}

DWORD WINAPI
SspiServerThread(
    IN PVOID pParameter   // thread data
    )
{
    THResult hRetval = E_FAIL;
    USHORT ClientSocketPort = 0;
    CHAR szClientMachineName[DNS_MAX_NAME_LENGTH + 1] = {0};
    SOCKET ClientSocket = INVALID_SOCKET;
    SOCKET ServerSocket = INVALID_SOCKET;
    ULONG cbRead = 0;
    ULONG MessageNum = 0;

    TSspiServerThreadParam* pSrvParam = (TSspiServerThreadParam*) pParameter;

    DebugPrintf(SSPI_LOG, "SspiServerThread ParameterType %#x\n", pSrvParam->ParameterType);

    hRetval DBGCHK = pSrvParam && pSrvParam->ParameterType == kSspiSrvThreadParameters ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = TlsSetValue(g_MessageNumTlsIndex, &MessageNum) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
         ServerSocket = pSrvParam->ServerSocket;
         hRetval DBGCHK = ReadMessage(
                             ServerSocket,
                             sizeof(ClientSocketPort),
                             &ClientSocketPort,
                             &cbRead
                             );
    }

    if (SUCCEEDED(hRetval))
    {
         hRetval DBGCHK = ReadMessage(
                            ServerSocket,
                            sizeof(szClientMachineName) - 1,
                            szClientMachineName,
                            &cbRead
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiServerThread Client Machine %s, Client Port %#x\n", szClientMachineName, ClientSocketPort);
        hRetval DBGCHK = ClientConnect(
                            szClientMachineName,
                            ClientSocketPort,
                            &ClientSocket
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DWORD dwThreadId = GetCurrentThreadId();
        hRetval DBGCHK = WriteMessage(
                            ClientSocket,
                            sizeof(dwThreadId),
                            &dwThreadId
                            );
    }

    THResult hr;

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SspiServerStart(pSrvParam, ClientSocket);
    }

    if (ClientSocket != INVALID_SOCKET)
    {
        hr DBGCHK = closesocket(ClientSocket) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (ServerSocket != INVALID_SOCKET)
    {
        hr DBGCHK = closesocket(ServerSocket);
    }

    SspiReleaseServerParam(pSrvParam);

    //
    // use SspiPrint to get around -quiet
    //

    SspiPrint(SSPI_LOG, TEXT("SspiServerThread terminating %#x\n"), (HRESULT) hRetval);

    return HRESULT_CODE(hRetval);
}

HRESULT
CheckForNoOtherServerWithSamePort(
    IN ULONG Port,
    OUT HANDLE* phEvent
    )
{
    THResult hRetval = E_FAIL;

    WCHAR szEvent[MAX_PATH] = {0};
    UNICODE_STRING EventName = {0};
    OBJECT_ATTRIBUTES EventAttributes = {0};

    _snwprintf(szEvent, COUNTOF(szEvent) - 1, L"\\SspiServerWithPort%#x(%d)", Port, Port);

    RtlInitUnicodeString( &EventName, szEvent );

    InitializeObjectAttributes(
        &EventAttributes,
        &EventName,
        0, // no attributes
        NULL, // no RootDirectory
        NULL // no SecurityQualityOfService
        );

    DBGCFG2(hRetval, STATUS_OBJECT_NAME_COLLISION, STATUS_ACCESS_DENIED);

    hRetval DBGCHK = NtCreateEvent(
                        phEvent,
                        MAXIMUM_ALLOWED, // SYNCHRONIZE | EVENT_MODIFY_STATE,
                        &EventAttributes,
                        NotificationEvent,
                        FALSE // The event is initially not signaled
                        );

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "CheckForNoOtherServerWithSamePort created event %s with handle %p\n", szEvent, *phEvent);
    }
    else if (STATUS_ACCESS_DENIED == (HRESULT) hRetval)
    {
        DebugPrintf(SSPI_WARN, "SspiServerMainLoopThread does not have permission to create events, brutal force\n");
        hRetval DBGCHK = S_OK;
    }

    return hRetval;
}

DWORD WINAPI
SspiServerMainLoopThread(
    IN PVOID pParameter   // thread data
    )
{
    THResult hRetval = E_FAIL;
    DWORD ThreadId = -1;
    HANDLE hServerThread = NULL;
    USHORT Port = 0;
    SOCKET SocketListen = INVALID_SOCKET;
    HANDLE hEvent = NULL;

    TSsiServerMainLoopThreadParam* pSrvMainParam = (TSsiServerMainLoopThreadParam*) pParameter;

    DebugPrintf(SSPI_LOG, "SspiServerMainLoopThread ParameterType %#x\n", pSrvMainParam->ParameterType);

    hRetval DBGCHK = pSrvMainParam->ParameterType == kSspiSrvMainThreadParameters ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        DBGCFG1(hRetval, STATUS_OBJECT_NAME_COLLISION);
        hRetval DBGCHK = CheckForNoOtherServerWithSamePort(pSrvMainParam->ServerSocketPort, &hEvent);
        if (STATUS_OBJECT_NAME_COLLISION == (HRESULT) hRetval)
        {
            SspiPrint(SSPI_WARN, TEXT("SspiServerMainLoopThread found existing sspi server listening on port %#x(%d)\n"), pSrvMainParam->ServerSocketPort, pSrvMainParam->ServerSocketPort);
        }
    }

    if (SUCCEEDED(hRetval))
    {
        DBGCFG1(hRetval, HRESULT_FROM_WIN32(WSAEADDRINUSE));

        hRetval DBGCHK = ServerInit(pSrvMainParam->ServerSocketPort, "SspiServerMainLoop", &SocketListen);
    }

    THResult hr;

    while (SUCCEEDED(hRetval))
    {
        SOCKET SocketClient = INVALID_SOCKET;
        TSspiServerThreadParam* pSrvParam = NULL;

        SocketClient = accept(SocketListen, NULL, NULL);
        hRetval DBGCHK = INVALID_SOCKET != SocketClient ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = SspiAcquireServerParam(pSrvMainParam, &pSrvParam);
        }

        if (SUCCEEDED(hRetval))
        {
            pSrvParam->ServerSocket = SocketClient;
            hServerThread = CreateThread(
                                NULL,  // no SD
                                0,     // user default stack size
                                SspiServerThread,
                                pSrvParam,  // thread parameter
                                0,    // no creation flags
                                &ThreadId
                                );
            hRetval DBGCHK = hServerThread ? S_OK : GetLastErrorAsHResult();
        }


        if (FAILED(hRetval))
        {
            if (INVALID_SOCKET != SocketClient)
            {
                hr DBGCHK = closesocket(SocketClient) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
            }
            if (pSrvParam)
            {
                SspiReleaseServerParam(pSrvParam);
            }
        }
    }

    if (hServerThread)
    {
        hr DBGCHK = CloseHandle(hServerThread) ? S_OK : GetLastErrorAsHResult();;
    }

    if (INVALID_SOCKET != SocketListen)
    {
        hr DBGCHK = closesocket(SocketListen) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (hEvent)
    {
        hr DBGCHK = CloseHandle(hEvent) ? S_OK : GetLastErrorAsHResult();
    }

    DebugPrintf(SSPI_LOG, "SspiServerMainLoopThread exiting %#x\n", (HRESULT) hRetval);

    return HRESULT_CODE(hRetval);
}

HRESULT
SspiStartCS(
    IN OPTIONAL TSsiServerMainLoopThreadParam *pSrvMainParam,
    IN OPTIONAL TSspiClientThreadParam* pCliParam
    )
{
    THResult hRetval = S_OK;

    HANDLE hClientThread = NULL;
    HANDLE hServerMainLoopThread = NULL;
    DWORD ServerMainLoopThreadId = -1;
    DWORD ClientThreadId = -1;

    DebugPrintf(SSPI_LOG, "SspiStartCS entering pSrvMainParam %p, pCliParam %p\n", pSrvMainParam, pCliParam);

    hRetval DBGCHK = InitWinsock() ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval) && (TLS_OUT_OF_INDEXES == g_MessageNumTlsIndex))
    {
        g_MessageNumTlsIndex = TlsAlloc();
        hRetval DBGCHK = (TLS_OUT_OF_INDEXES != g_MessageNumTlsIndex) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval) && pSrvMainParam)
    {
        hServerMainLoopThread = CreateThread(
                                    NULL,  // no SD
                                    0,     // user default stack size
                                    SspiServerMainLoopThread,
                                    pSrvMainParam,  // thread parameter
                                    0,    // no creation flags
                                    &ServerMainLoopThreadId
                                    );
        hRetval DBGCHK = hServerMainLoopThread ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval) && pCliParam)
    {
        hClientThread = CreateThread(
                            NULL,  // no SD
                            0,     // user default stack size
                            SspiClientThread,
                            pCliParam,  // thread parameter
                            0,    // no creation flags
                            &ClientThreadId
                            );
        hRetval DBGCHK = hClientThread ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval) && hClientThread)
    {
        hRetval DBGCHK = HResultFromWin32(WaitForSingleObject(hClientThread, INFINITE));
    }

    if (SUCCEEDED(hRetval) && hServerMainLoopThread)
    {
        hRetval DBGCHK = HResultFromWin32(WaitForSingleObject(hServerMainLoopThread, INFINITE));
    }

    THResult hr;

    if (hServerMainLoopThread)
    {
        hr DBGCHK = CloseHandle(hServerMainLoopThread) ? S_OK : GetLastErrorAsHResult();
    }

    if (hClientThread)
    {
        hr DBGCHK = CloseHandle(hClientThread) ? S_OK : GetLastErrorAsHResult();
    }

    if (TLS_OUT_OF_INDEXES != g_MessageNumTlsIndex)
    {
        TlsFree(g_MessageNumTlsIndex);
        g_MessageNumTlsIndex = TLS_OUT_OF_INDEXES;
    }

    TermWinsock();

    DebugPrintf(SSPI_LOG, "SspiStartCS leaving %#x\n", (HRESULT) hRetval);

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\transport.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    transport.cxx

Abstract:

    transport

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sockcomm.h"
#include "transport.hxx"

ULONG g_MessageNumTlsIndex = TLS_OUT_OF_INDEXES;
ULONG g_MsgHeaderLen = kMsgHeaderLen;

HRESULT
ServerInit(
    IN USHORT Port,
    IN OPTIONAL PCSTR pszDescription,
    OUT SOCKET* pSocketListen
    )
{
    THResult hRetval = S_OK;

    SOCKADDR_IN sin = {0};
    SOCKET sockListen = INVALID_SOCKET;
    int nRes = SOCKET_ERROR;

    *pSocketListen = INVALID_SOCKET;

    //
    // create listening socket
    //

    sockListen = socket(PF_INET, SOCK_STREAM, 0);

    hRetval DBGCHK = (INVALID_SOCKET != sockListen) ? S_OK : HResultFromWin32(WSAGetLastError());

    //
    // bind to local port
    //

    if (SUCCEEDED(hRetval))
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = htons(Port);
        nRes = bind(sockListen, (PSOCKADDR) &sin, sizeof(sin));

        DBGCFG1(hRetval, HRESULT_FROM_WIN32(WSAEADDRINUSE));
        hRetval DBGCHK = (SOCKET_ERROR != nRes) ? S_OK : HResultFromWin32(WSAGetLastError());

        if (FAILED(hRetval) && (WSAEADDRINUSE == HRESULT_CODE(hRetval)))
        {
            DebugPrintf(SSPI_ERROR, "ServerInit port %d(%#x) in use, failed to bind\n", Port, Port);
        }
        else if (FAILED(hRetval))
        {
            DebugPrintf(SSPI_ERROR, "ServerInit binding to port %d failed with %#x\n", Port, HRESULT_CODE(hRetval));
        }
    }

    //
    // listen for client
    //

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "%s%slistening on port %d(%#x)\n",
            pszDescription ? pszDescription : "", pszDescription ? " " : "", Port, Port);

        nRes = listen(sockListen, 1);
        hRetval DBGCHK = (SOCKET_ERROR != nRes) ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (SUCCEEDED(hRetval))
    {
        *pSocketListen = sockListen;
        sockListen = INVALID_SOCKET;
    }

    THResult hr;

    if (sockListen != INVALID_SOCKET)
    {
        hr DBGCHK = closesocket(sockListen) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    return hRetval;
}

HRESULT
ClientConnect(
    IN OPTIONAL PCSTR pszServer,
    IN USHORT Port,
    OUT SOCKET* pSocketConnected
    )
{
    THResult hRetval = S_OK;

    SOCKET sockServer = INVALID_SOCKET;
    ULONG ulAddress = INADDR_NONE;
    struct hostent *pHost = NULL;
    SOCKADDR_IN sin = {0};
    CHAR szServer[DNS_MAX_NAME_LENGTH + 1] = {0};

    //
    // lookup the address for the server name
    //

    if (!pszServer)
    {
        hRetval DBGCHK = gethostname(szServer, sizeof(szServer) - 1) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
        if (SUCCEEDED(hRetval))
        {
            pszServer = szServer;
        }
    }

    if (SUCCEEDED(hRetval))
    {
        ulAddress = inet_addr(pszServer);
        if (INADDR_NONE == ulAddress)
        {
            pHost = gethostbyname(pszServer);
            hRetval DBGCHK = pHost ? S_OK : HResultFromWin32(WSAGetLastError());

            if (SUCCEEDED(hRetval))
            {
                RtlCopyMemory((CHAR *)&ulAddress, pHost->h_addr, pHost->h_length);
            }
        }
    }

    //
    // create the socket
    //

    if (SUCCEEDED(hRetval))
    {
        sockServer = socket(PF_INET, SOCK_STREAM, 0);
        hRetval DBGCHK = (INVALID_SOCKET == sockServer) ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (SUCCEEDED(hRetval))
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = ulAddress;
        sin.sin_port = htons(Port);

        //
        // connect to remote endpoint
        //

        hRetval DBGCHK = connect(sockServer, (PSOCKADDR) &sin, sizeof(sin)) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    if (SUCCEEDED(hRetval))
    {
        *pSocketConnected = sockServer;
        sockServer = INVALID_SOCKET;
    }

    THResult hr;

    if (INVALID_SOCKET != sockServer)
    {
        hr DBGCHK = closesocket(sockServer) == ERROR_SUCCESS ? S_OK : HResultFromWin32(WSAGetLastError());
    }

    return hRetval;
}

HRESULT
WriteMessage(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf
    )
{
    THResult hRetval = S_OK;

    ULONG cbWritten = 0;
    ULONG cbRead = 0;

    ULONG* pMessageNum = NULL;

    hRetval DBGCHK = GetPerThreadpMessageNum(g_MessageNumTlsIndex, &pMessageNum);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SendMsg(s, cbBuf, pBuf) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReceiveMsg(s, sizeof(cbWritten), &cbWritten, &cbRead);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = (cbWritten == cbBuf) && (cbRead == sizeof(cbWritten)) ? S_OK : E_FAIL;
    }

    if (SUCCEEDED(hRetval))
    {
        CHAR szBanner[MAX_PATH] = {0};
        _snprintf(szBanner, sizeof(szBanner), "*******Message #%#x sent %#x bytes:*********", (*pMessageNum)++, cbWritten);

        DebugPrintHex(SSPI_MSG, szBanner, min(cbBuf, g_MsgHeaderLen), pBuf);
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "cbWritten %#x, cbBuf %#x, cbRead %#x\n", cbWritten, cbBuf, cbRead);
    }

    return hRetval;
}

HRESULT
GetPerThreadpMessageNum(
    IN ULONG Index,
    OUT ULONG** ppMessageNum
    )
{
    THResult hRetval = E_FAIL;

    ULONG* pMsgNum = NULL;

    *ppMessageNum = NULL;

    hRetval DBGCHK = (TLS_OUT_OF_INDEXES != Index) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        pMsgNum = (ULONG*) TlsGetValue(g_MessageNumTlsIndex);
    }

    hRetval DBGCHK = pMsgNum ? S_OK : GetLastErrorAsHResult(); // last error can be NO_ERROR

    if (SUCCEEDED(hRetval) && !pMsgNum)
    {
        hRetval DBGCHK = E_POINTER;
    }

    if (SUCCEEDED(hRetval))
    {
        *ppMessageNum = pMsgNum;
    }

    return hRetval;
}

HRESULT
ReadMessage(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN OUT VOID* pBuf,
    OUT ULONG* pcbRead
    )
{
    THResult hRetval = S_OK;

    ULONG* pMessageNum = NULL;

    hRetval DBGCHK = GetPerThreadpMessageNum(g_MessageNumTlsIndex, &pMessageNum);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReceiveMsg(s, cbBuf, pBuf, pcbRead) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SendMsg(s, sizeof(*pcbRead), pcbRead);
    }

    if (SUCCEEDED(hRetval))
    {
        CHAR szBanner[MAX_PATH] = {0};
        _snprintf(szBanner, sizeof(szBanner), "*********Message #%#x received %#x bytes:**********", (*pMessageNum)++, *pcbRead);

        DebugPrintHex(SSPI_MSG, szBanner, min(*pcbRead, g_MsgHeaderLen), pBuf);
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sspiutils.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    sspiutils.cxx

Abstract:

    sspiutils

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspiutils.hxx"

#include <ntlmsp.h>
#include <tchar.h>

HRESULT
AcquireCredHandle(
    IN OPTIONAL PSTR pszPrincipal,
    IN OPTIONAL LUID* pLogonID,
    IN PSTR pszPackageName,
    IN OPTIONAL VOID* pAuthData,
    IN ULONG fCredentialUse,
    OUT CredHandle* phCred
    )
{
    THResult hRetval = S_OK;

    CredHandle hCred;
    TimeStamp Lifetime = {0};
    TimeStamp CurrentTime = {0};
    SecPkgCredentials_NamesA CredNames = {0};
    TPrivilege* pPriv = NULL;

    DebugPrintf(SSPI_LOG, "AcquireCredHandle pszPrincipal %s, pszPackageName %s, "
        "fCredentialUse %#x, pLogonID %p, pAuthData %p\n",
        pszPrincipal, pszPackageName, fCredentialUse,
        pLogonID, pAuthData);

    SecInvalidateHandle(&hCred);
    SecInvalidateHandle(phCred);

    if (pLogonID)
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", pLogonID->HighPart, pLogonID->LowPart);

        pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
        hRetval DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = AcquireCredentialsHandleA(
                            pszPrincipal, // NULL
                            pszPackageName,
                            fCredentialUse, // SECPKG_CRED_INBOUND,
                            pLogonID, // NULL
                            pAuthData, // ServerAuthIdentity,
                            NULL, // GetKey
                            NULL, // value to pass to GetKey
                            &hCred,
                            &Lifetime
                            );
    }

    if (pPriv)
    {
        delete pPriv;
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "CredHandle: %#x:%#x\n", hCred.dwUpper, hCred.dwLower);

        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "Lifetime", &Lifetime);

        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "Current Time", &CurrentTime);

        DBGCFG1(hRetval, SEC_E_UNSUPPORTED_FUNCTION);

        hRetval DBGCHK = QueryCredentialsAttributesA(
                            &hCred,
                            SECPKG_CRED_ATTR_NAMES,
                            &CredNames
                            );
        if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
        {
            hRetval DBGCHK = S_OK;
            DebugPrintf(SSPI_WARN, "QueryCredentialsAttributesA does not support SECPKG_CRED_ATTR_NAMES\n");
        }
    }

    if (SUCCEEDED(hRetval))
    {
        *phCred = hCred;
        SecInvalidateHandle(&hCred);
        DebugPrintf(SSPI_LOG, "Credential names: %s\n", CredNames.sUserName);

    }

    THResult hr;

    if (CredNames.sUserName)
    {
        hr DBGCHK = FreeContextBuffer(CredNames.sUserName);
    }

    if (SecIsValidHandle(&hCred))
    {
        hr DBGCHK = FreeCredentialsHandle(&hCred);
    }

    return hRetval;
}

VOID
GetAuthdata(
    IN OPTIONAL PCTSTR pszUserName,
    IN OPTIONAL PCTSTR pszDomainName,
    IN OPTIONAL PCTSTR pszPassword,
    OUT SEC_WINNT_AUTH_IDENTITY* pAuthData
    )
{

#if defined(UNICODE) || defined(_UNICODE)

    pAuthData->Domain = (WCHAR*) pszDomainName;
    pAuthData->DomainLength = pszDomainName ? lstrlen(pszDomainName) : 0;
    pAuthData->Password = (WCHAR*) pszPassword;
    pAuthData->PasswordLength = pszPassword ? lstrlen(pszPassword) : 0;
    pAuthData->User = (WCHAR*) pszUserName;
    pAuthData->UserLength = pszUserName ? lstrlen(pszUserName) : 0;

#else

    pAuthData->Domain = (UCHAR*) pszDomainName;
    pAuthData->DomainLength = pszDomainName ? lstrlen(pszDomainName) : 0;
    pAuthData->Password = (UCHAR*) pszPassword;
    pAuthData->PasswordLength = pszPassword ? lstrlen(pszPassword) : 0;
    pAuthData->User = (UCHAR*) pszUserName;
    pAuthData->UserLength = pszUserName ? lstrlen(pszUserName) : 0;

#endif

    pAuthData->Flags = (sizeof(TCHAR) == sizeof(WCHAR)) ? SEC_WINNT_AUTH_IDENTITY_UNICODE : SEC_WINNT_AUTH_IDENTITY_ANSI;
}

VOID
GetAuthdataExA(
    IN OPTIONAL PCSTR pszUserName,
    IN OPTIONAL PCSTR pszDomainName,
    IN OPTIONAL PCSTR pszPassword,
    IN OPTIONAL PCSTR pszPackageList,
    OUT SEC_WINNT_AUTH_IDENTITY_EXA* pAuthDataEx
    )
{
    DebugPrintf(SSPI_LOG,
        "GetAuthdataExW pszUserName %s, pszDomainName %s, pszPassword %s, pszPackageList %s\n",
        pszUserName, pszDomainName, pszPassword, pszPackageList);

    pAuthDataEx->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
    pAuthDataEx->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);

    pAuthDataEx->Domain = (UCHAR*) pszDomainName;
    pAuthDataEx->DomainLength = pszDomainName ? strlen(pszDomainName) : 0;
    pAuthDataEx->Password = (UCHAR*)  pszPassword;
    pAuthDataEx->PasswordLength = pszPassword ? strlen(pszPassword) : 0;
    pAuthDataEx->User = (UCHAR*) pszUserName;
    pAuthDataEx->UserLength = pszUserName ? strlen(pszUserName) : 0;
    pAuthDataEx->PackageList = (UCHAR*) pszPackageList;
    pAuthDataEx->PackageListLength = pszPackageList ? strlen(pszPackageList) : 0;

    pAuthDataEx->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
}

VOID
GetAuthdataExW(
    IN OPTIONAL PCWSTR pszUserName,
    IN OPTIONAL PCWSTR pszDomainName,
    IN OPTIONAL PCWSTR pszPassword,
    IN OPTIONAL PCWSTR pszPackageList,
    OUT SEC_WINNT_AUTH_IDENTITY_EXW* pAuthDataEx
    )
{
    DebugPrintf(SSPI_LOG,
        "GetAuthdataExW pszUserName %ws, pszDomainName %ws, pszPassword %ws, pszPackageList %ws\n",
        pszUserName, pszDomainName, pszPassword, pszPackageList);

    pAuthDataEx->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
    pAuthDataEx->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);

    pAuthDataEx->Domain = (WCHAR*) pszDomainName;
    pAuthDataEx->DomainLength = pszDomainName ? wcslen(pszDomainName) : 0;
    pAuthDataEx->Password = (WCHAR*)  pszPassword;
    pAuthDataEx->PasswordLength = pszPassword ? wcslen(pszPassword) : 0;
    pAuthDataEx->User = (WCHAR*) pszUserName;
    pAuthDataEx->UserLength = pszUserName ? wcslen(pszUserName) : 0;
    pAuthDataEx->PackageList = (WCHAR*) pszPackageList;
    pAuthDataEx->PackageListLength = pszPackageList ? wcslen(pszPackageList) : 0;

    pAuthDataEx->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
}

HRESULT
GetAuthdataWMarshalled(
    IN OPTIONAL PCWSTR pszUserName,
    IN OPTIONAL PCWSTR pszDomainName,
    IN OPTIONAL PCWSTR pszPassword,
    OUT SEC_WINNT_AUTH_IDENTITY_W** ppAuthData
    )
{
    THResult hRetval;

    PUCHAR pWhere = NULL;

    ULONG cbCredSize = ( ((pszUserName != NULL) ? wcslen(pszUserName) + 1 : 0)
         + ((pszDomainName != NULL) ? wcslen(pszDomainName) + 1 : 0)
         + ((pszPassword != NULL) ? wcslen(pszPassword) + 1 : 0) ) * sizeof(WCHAR)
         + ROUND_UP_COUNT(sizeof(SEC_WINNT_AUTH_IDENTITY_W), sizeof(ULONG_PTR));

    *ppAuthData = (PSEC_WINNT_AUTH_IDENTITY_W) new CHAR[cbCredSize];

    hRetval DBGCHK = (*ppAuthData) ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        RtlZeroMemory((*ppAuthData), cbCredSize);

        pWhere = (PUCHAR) ((*ppAuthData) + 1);

        if (pszUserName != NULL)
        {
             (*ppAuthData)->UserLength = wcslen(pszUserName);
             (*ppAuthData)->User = (PWSTR) pWhere;
             RtlCopyMemory(
                pWhere,
                pszUserName,
                (*ppAuthData)->UserLength * sizeof(WCHAR)
                );
             pWhere += ((*ppAuthData)->UserLength + 1) * sizeof(WCHAR);
         }

         if (pszDomainName != NULL)
         {
             (*ppAuthData)->DomainLength = wcslen(pszDomainName);
             (*ppAuthData)->Domain = (PWSTR) pWhere;
             RtlCopyMemory(
                 pWhere,
                 pszDomainName,
                 (*ppAuthData)->DomainLength * sizeof(WCHAR)
                 );
             pWhere += ((*ppAuthData)->DomainLength + 1) * sizeof(WCHAR);
         }

         if (pszPassword != NULL)
         {
             (*ppAuthData)->PasswordLength = wcslen(pszPassword);
             (*ppAuthData)->Password = (PWSTR) pWhere;
             RtlCopyMemory(
                 pWhere,
                 pszPassword,
                 (*ppAuthData)->PasswordLength * sizeof(WCHAR)
                 );
             pWhere += ((*ppAuthData)->PasswordLength + 1) * sizeof(WCHAR);
        }

        (*ppAuthData)->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
    }

    return hRetval;
}

HRESULT
GetAuthdataExWMarshalled(
    IN OPTIONAL PCWSTR pszUserName,
    IN OPTIONAL PCWSTR pszDomainName,
    IN OPTIONAL PCWSTR pszPassword,
    IN OPTIONAL PCWSTR pszPackageList,
    OUT SEC_WINNT_AUTH_IDENTITY_EXW** ppAuthData
    )
{
    THResult hRetval;

    PUCHAR pWhere = NULL;

    ULONG cbCredSize = ( ((pszUserName != NULL) ? wcslen(pszUserName) + 1 : 0)
         + ((pszDomainName != NULL) ? wcslen(pszDomainName) + 1 : 0)
         + ((pszPassword != NULL) ? wcslen(pszPassword) + 1 : 0)
         + ((pszPackageList != NULL) ? wcslen(pszPackageList) + 1 : 0) ) * sizeof(WCHAR)
         + ROUND_UP_COUNT(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW), sizeof(ULONG_PTR));

    *ppAuthData = (PSEC_WINNT_AUTH_IDENTITY_EXW) new CHAR[cbCredSize];

    hRetval DBGCHK = (*ppAuthData) ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        RtlZeroMemory((*ppAuthData), cbCredSize);

        (*ppAuthData)->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        (*ppAuthData)->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);

        pWhere = (PUCHAR) ((*ppAuthData) + 1);

        if (pszUserName != NULL)
        {
            (*ppAuthData)->UserLength = wcslen(pszUserName);
            (*ppAuthData)->User = (PWSTR) pWhere;
            RtlCopyMemory(
                pWhere,
                pszUserName,
                (*ppAuthData)->UserLength * sizeof(WCHAR)
                );
            pWhere += ((*ppAuthData)->UserLength + 1) * sizeof(WCHAR);
        }

        if (pszDomainName != NULL)
        {
            (*ppAuthData)->DomainLength = wcslen(pszDomainName);
            (*ppAuthData)->Domain = (PWSTR) pWhere;
            RtlCopyMemory(
                pWhere,
                pszDomainName,
                (*ppAuthData)->DomainLength * sizeof(WCHAR)
                );
            pWhere += ((*ppAuthData)->DomainLength + 1) * sizeof(WCHAR);
        }

        if (pszPassword != NULL)
        {
            (*ppAuthData)->PasswordLength = wcslen(pszPassword);
            (*ppAuthData)->Password = (PWSTR) pWhere;
            RtlCopyMemory(
                pWhere,
                pszPassword,
                (*ppAuthData)->PasswordLength * sizeof(WCHAR)
                );
            pWhere += ((*ppAuthData)->PasswordLength + 1) * sizeof(WCHAR);
        }

        if (pszPackageList != NULL)
        {
            (*ppAuthData)->PackageListLength = wcslen(pszPackageList);
            (*ppAuthData)->PackageList = (PWSTR) pWhere;
            RtlCopyMemory(
                pWhere,
                pszPackageList,
                (*ppAuthData)->PackageListLength * sizeof(WCHAR)
                );
            pWhere += ((*ppAuthData)->PackageListLength + 1) * sizeof(WCHAR);
        }

        (*ppAuthData)->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
    }

    return hRetval;
}

NTSTATUS
GetCredHandle(
    IN OPTIONAL PTSTR pszPrincipal,
    IN OPTIONAL LUID* pLogonID,
    IN PTSTR pszPackageName,
    IN OPTIONAL VOID* pAuthData,
    IN ULONG fCredentialUse,
    OUT CredHandle* phCred
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    CredHandle hCred;
    TimeStamp Lifetime = {0};
    TimeStamp CurrentTime = {0};
    SecPkgCredentials_Names CredNames = {0};
    TPrivilege* pPriv = NULL;

    SspiPrint(SSPI_LOG, TEXT("GetCredHandle pszPrincipal %s, pszPackageName %s, ")
        TEXT("fCredentialUse %#x, pLogonID %p, pAuthData %p\n"),
        pszPrincipal, pszPackageName, fCredentialUse,
        pLogonID, pAuthData);

    SecInvalidateHandle(&hCred);
    SecInvalidateHandle(phCred);

    if (pLogonID)
    {
        SspiPrint(SSPI_LOG, TEXT("LogonId %#x:%#x\n"), pLogonID->HighPart, pLogonID->LowPart);

        pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
        Status DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = AcquireCredentialsHandle(
                            pszPrincipal, // NULL
                            pszPackageName,
                            fCredentialUse, // SECPKG_CRED_INBOUND,
                            pLogonID, // NULL
                            pAuthData, // ServerAuthIdentity,
                            NULL, // GetKey
                            NULL, // value to pass to GetKey
                            &hCred,
                            &Lifetime
                            );
    }

    if (pPriv)
    {
        delete pPriv;
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("CredHandle: %#x:%#x\n"), hCred.dwUpper, hCred.dwLower);

        SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("Lifetime"), &Lifetime);

        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("Current Time"), &CurrentTime);

        DBGCFG1(Status, SEC_E_UNSUPPORTED_FUNCTION);

        Status DBGCHK = QueryCredentialsAttributes(
                            &hCred,
                            SECPKG_CRED_ATTR_NAMES,
                            &CredNames
                            );
        if (SEC_E_UNSUPPORTED_FUNCTION == (NTSTATUS) Status)
        {
            Status DBGCHK = STATUS_SUCCESS;
            DebugPrintf(SSPI_WARN, "QueryCredentialsAttributesA does not support SECPKG_CRED_ATTR_NAMES\n");
        }
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("Credential names: %s\n"), CredNames.sUserName);
        *phCred = hCred;
        SecInvalidateHandle(&hCred);
    }

    THResult hr;

    if (CredNames.sUserName)
    {
        hr DBGCHK = FreeContextBuffer(CredNames.sUserName);
    }

    if (SecIsValidHandle(&hCred))
    {
        hr DBGCHK = FreeCredentialsHandle(&hCred);
    }

    return Status;
}

HRESULT
CheckSecurityContextHandle(
    IN PCtxtHandle phCtxt
    )
{
    THResult hRetval = S_OK;

    LARGE_INTEGER CurrentTime = {0};
    SecPkgContext_NativeNamesA NativeNamesA = {0};
    SecPkgContext_DceInfo ContextDceInfo = {0};
    SecPkgContext_Lifespan ContextLifespan = {0};
    SecPkgContext_PackageInfoA ContextPackageInfo = {0};
    SecPkgContext_NegotiationInfoA NegotiationInfo = {0};
    SecPkgContext_Sizes ContextSizes = {0};
    SecPkgContext_Flags ContextFlags = {0};
    SecPkgContext_KeyInfoA KeyInfo = {0};
    SecPkgContext_NamesA ContextNames = {0};
    SecPkgContext_TargetInformation TargetInfo = {0};
    SecPkgContext_SessionKey SessionKey = {0};
    SecPkgContext_UserFlags UserFlags = {0};

    DBGCFG1(hRetval, SEC_E_UNSUPPORTED_FUNCTION);

    //
    // Query as many attributes as possible
    //

    hRetval DBGCHK = QueryContextAttributesA(
                        phCtxt,
                        SECPKG_ATTR_SIZES,
                        &ContextSizes
                        );

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_SIZES cbBlockSize %#x, cbMaxSignature %#x, "
            "cbMaxToken %#x, cbSecurityTrailer %#x\n",
            ContextSizes.cbBlockSize,
            ContextSizes.cbMaxSignature,
            ContextSizes.cbMaxToken,
            ContextSizes.cbSecurityTrailer);

        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_FLAGS,
                            &ContextFlags
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_FLAGS %#x\n", ContextFlags.Flags);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_FLAGS\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_KEY_INFO,
                            &KeyInfo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_KEY_INFO EncryptAlgorithm %#x, KeySize %#x, "
            "sEncryptAlgorithmName %s, SignatureAlgorithm %#x, sSignatureAlgorithmName %s\n",
            KeyInfo.EncryptAlgorithm,
            KeyInfo.KeySize,
            KeyInfo.sEncryptAlgorithmName,
            KeyInfo.SignatureAlgorithm,
            KeyInfo.sSignatureAlgorithmName);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_KEY_INFO\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_NAMES,
                            &ContextNames
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_NAMES sUserName %s\n", ContextNames.sUserName);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_NAMES\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_NATIVE_NAMES,
                            &NativeNamesA
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_NATIVE_NAMES sClientName %s, sServerName %s\n",
            NativeNamesA.sClientName,
            NativeNamesA.sServerName);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_NATIVE_NAMES\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_DCE_INFO,
                            &ContextDceInfo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_DCE_INFO: AuthzSvc %#x, pPAC %ws\n",  ContextDceInfo.AuthzSvc, ContextDceInfo.pPac);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_DCE_INFO\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_LIFESPAN,
                            &ContextLifespan
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintLocalTime(SSPI_LOG, "SECPKG_ATTR_LIFESPAN Start", &ContextLifespan.tsStart);
        DebugPrintLocalTime(SSPI_LOG, "SECPKG_ATTR_LIFESPAN Expiry", &ContextLifespan.tsExpiry);

        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "Current Time", &CurrentTime);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_LIFESPAN\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_PACKAGE_INFO,
                            &ContextPackageInfo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_PACKAGE_INFO cbMaxToken %#x, Comment %s, fCapabilities %#x, "
            "Name %s, wRPCID %#x, wVersion %#x\n",
            ContextPackageInfo.PackageInfo->cbMaxToken,
            ContextPackageInfo.PackageInfo->Comment,
            ContextPackageInfo.PackageInfo->fCapabilities,
            ContextPackageInfo.PackageInfo->Name,
            ContextPackageInfo.PackageInfo->wRPCID,
            ContextPackageInfo.PackageInfo->wVersion);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_PACKAGE_INFO\n");
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_NEGOTIATION_INFO,
                            &NegotiationInfo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_NEGOTIATION_INFO cbMaxToken %#x, Comment %s, fCapabilities %#x, "
            "Name %s, wRPCID %#x, wVersion %#x, NegotiationState %#x\n",
            NegotiationInfo.PackageInfo->cbMaxToken,
            NegotiationInfo.PackageInfo->Comment,
            NegotiationInfo.PackageInfo->fCapabilities,
            NegotiationInfo.PackageInfo->Name,
            NegotiationInfo.PackageInfo->wRPCID,
            NegotiationInfo.PackageInfo->wVersion,
            NegotiationInfo.NegotiationState);
    }
    else if (STATUS_NOT_SUPPORTED == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        SspiPrint(SSPI_WARN, TEXT("QueryContextAttributes does not support SECPKG_ATTR_NEGOTIATION_INFO\n"));
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_TARGET_INFORMATION,
                            &TargetInfo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintHex(SSPI_LOG, "SECPKG_ATTR_TARGET_INFORMATION", TargetInfo.MarshalledTargetInfoLength, TargetInfo.MarshalledTargetInfo);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_TARGET_INFORMATION\n");
    }

    #if 0
    
    SECPKG_ATTR_SESSION_KEY is Kernel mode only
    
    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_SESSION_KEY,
                            &SessionKey
                            );
    }
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintHex(SSPI_LOG, "SECPKG_ATTR_SESSION_KEY", SessionKey.SessionKeyLength, SessionKey.SessionKey);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_SESSION_KEY\n");
    }

    #endif 
    
    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QueryContextAttributesA(
                            phCtxt,
                            SECPKG_ATTR_USER_FLAGS,
                            &UserFlags
                            );
    }
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SECPKG_ATTR_USER_FLAGS UserFlags %#x\n", UserFlags.UserFlags);
    }
    else if (SEC_E_UNSUPPORTED_FUNCTION == (HRESULT) hRetval)
    {
        hRetval DBGCHK = S_OK;
        DebugPrintf(SSPI_WARN, "QueryContextAttributesA does not support SECPKG_ATTR_SESSION_KEY\n");
    }

    THResult hr;

    if (TargetInfo.MarshalledTargetInfo)
    {
        hr DBGCHK = FreeContextBuffer(TargetInfo.MarshalledTargetInfo);
    }

    if (SessionKey.SessionKeyLength)
    {
        hr DBGCHK = FreeContextBuffer(SessionKey.SessionKey);
    }

    if (NativeNamesA.sClientName != NULL)
    {
        hr DBGCHK = FreeContextBuffer(NativeNamesA.sClientName);
    }

    if (NativeNamesA.sServerName != NULL)
    {
        hr DBGCHK = FreeContextBuffer(NativeNamesA.sServerName);
    }

    if (ContextNames.sUserName)
    {
        hr DBGCHK = FreeContextBuffer(ContextNames.sUserName);
    }

    if (ContextPackageInfo.PackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(ContextPackageInfo.PackageInfo);
    }

    if (NegotiationInfo.PackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(NegotiationInfo.PackageInfo);
    }

    if (ContextDceInfo.pPac)
    {
        hr DBGCHK = FreeContextBuffer(ContextDceInfo.pPac);
    }

    return hRetval;
}

MSV1_0_AV_PAIR*
SspAvlInit(
    IN VOID* pAvList
    )
{
    MSV1_0_AV_PAIR* pAvPair;

    pAvPair = (MSV1_0_AV_PAIR*) pAvList;

    if (!pAvPair)
    {
        return NULL;
    }

    pAvPair->AvId = MsvAvEOL;
    pAvPair->AvLen = 0;

    return pAvPair;
}

MSV1_0_AV_PAIR*
SspAvlAdd(
    IN MSV1_0_AV_PAIR* pAvList,
    IN MSV1_0_AVID AvId,
    IN OPTIONAL UNICODE_STRING* pString,
    IN ULONG cAvList
    )
{
    MSV1_0_AV_PAIR* pCurPair;

    if ((NULL == pString) || (0 == pString->Length) || (NULL == pString->Buffer))
    {
        return NULL;
    }

    //
    // find the EOL
    //

    pCurPair = SspAvlGet(pAvList, MsvAvEOL, cAvList);
    if (pCurPair == NULL)
    {
        return NULL;
    }

    //
    // check for enough space in the av list buffer, then append the new AvPair
    // (assume the buffer is long enough!)
    //

    if ( (((UCHAR*) pCurPair) - ((UCHAR*)pAvList)) + sizeof(MSV1_0_AV_PAIR) * 2 + pString->Length > cAvList)
    {
        return NULL;
    }

    pCurPair->AvId = (USHORT) AvId;
    pCurPair->AvLen = (USHORT) pString->Length;
    RtlCopyMemory(pCurPair + 1, pString->Buffer, pCurPair->AvLen);

    //
    // top it off with a new EOL
    //

    pCurPair = (MSV1_0_AV_PAIR*) ((UCHAR*) pCurPair + sizeof(MSV1_0_AV_PAIR) + pCurPair->AvLen);
    pCurPair->AvId = MsvAvEOL;
    pCurPair->AvLen = 0;

    return pCurPair;
}

MSV1_0_AV_PAIR*
SspAvlGet(
    IN MSV1_0_AV_PAIR* pAvList,
    IN MSV1_0_AVID AvId,
    IN ULONG cAvList
    )
{
    MSV1_0_AV_PAIR* pAvPair;

    pAvPair = pAvList;

    while (TRUE)
    {
        if (pAvPair->AvId == AvId)
        {
            return pAvPair;
        }

        if (pAvPair->AvId == MsvAvEOL)
        {
            return NULL;
        }
        cAvList -= (pAvPair->AvLen + sizeof(MSV1_0_AV_PAIR));

        if (cAvList <= 0)
        {
           return NULL;
        }

        pAvPair = (MSV1_0_AV_PAIR*) ((UCHAR*) pAvPair + pAvPair->AvLen + sizeof(MSV1_0_AV_PAIR));
    }
}

ULONG
SspAvlLen(
    IN MSV1_0_AV_PAIR* pAvList,
    IN ULONG cAvList
    )
{
    MSV1_0_AV_PAIR* pCurPair;

    //
    // find the EOL
    //

    pCurPair = SspAvlGet(pAvList, MsvAvEOL, cAvList);

    if (pCurPair == NULL)
    {
        return 0;
    }

    //
    // compute length (not forgetting the EOL pair)
    //

    return (ULONG)(((UCHAR*) pCurPair - (UCHAR*) pAvList) + sizeof(MSV1_0_AV_PAIR));
}

NTSTATUS
CreateTargetInfo(
    IN UNICODE_STRING* pTargetName,
    OUT STRING* pTargetInfo
    )
{
    UNICODE_STRING DomainName = {0};
    UNICODE_STRING ServerName = {0};
    ULONG i = 0;
    MSV1_0_AV_PAIR* pAV;

    //
    // check length of name to make sure it fits in my buffer
    //

    if (pTargetName->Length > (DNS_MAX_NAME_LENGTH + CNLEN + 2) * sizeof(WCHAR))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // init AV list in temp buffer
    //

    pAV = SspAvlInit(pTargetInfo->Buffer);

    if (!pAV)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // see if there's a NULL in the middle of the server name that indicates
    // that it's really a domain name followed by a server name
    //

    DomainName = *pTargetName;

    for (i = 0; i < (DomainName.Length / sizeof(WCHAR)); i++)
    {
        if (DomainName.Buffer[i] == L'\0')
        {
            //
            // take length of domain name without the NULL
            //

            DomainName.Length = (USHORT) i * sizeof(WCHAR);

            //
            // adjust server name and length to point after the domain name
            //

            ServerName.Length = (USHORT) (pTargetName->Length - (i + 1) * sizeof(WCHAR));
            ServerName.Buffer = pTargetName->Buffer + (i + 1);

            break;
        }
    }

    //
    // strip off possible trailing null after the server name
    //

    for (i = 0; i < (ServerName.Length / sizeof(WCHAR)); i++)
    {
        if (ServerName.Buffer[i] == L'\0')
        {
            ServerName.Length = (USHORT) i * sizeof(WCHAR);
            break;
        }
    }

    //
    // put both names in the AV list (if both exist)
    //

    if (!SspAvlAdd(pAV, MsvAvNbDomainName, &DomainName, pTargetInfo->MaximumLength))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ((ServerName.Length > 0) && !SspAvlAdd(pAV, MsvAvNbComputerName, &ServerName, pTargetInfo->MaximumLength))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // make the request point at AV list instead of names.
    //

    pTargetInfo->Length = (USHORT) SspAvlLen(pAV, pTargetInfo->MaximumLength);
    pTargetInfo->Buffer = (CHAR*) pAV;

    return STATUS_SUCCESS;
}

NTSTATUS
GetTargetInfo(
    IN ULONG TargetFlags,
    IN BOOLEAN bForceGuest,
    IN OPTIONAL UNICODE_STRING* pDnsDomainName,
    IN OPTIONAL UNICODE_STRING* pDnsComputerName,
    IN OPTIONAL UNICODE_STRING* pDnsTreeName,
    IN OPTIONAL UNICODE_STRING* pTargetName,
    IN OPTIONAL UNICODE_STRING* pComputerName,
    OUT UNICODE_STRING* pTargetInfo
    )
{
    TNtStatus Status;
    PMSV1_0_AV_PAIR pAV = NULL;
    ULONG cbAV = 0;

    ULONG AvFlags = 0;
    UNICODE_STRING* pDnsTargetName = NULL;


    if (TargetFlags == NTLMSSP_TARGET_TYPE_DOMAIN )
    {
        pDnsTargetName = pDnsDomainName;
    }
    else
    {
        pDnsTargetName = pDnsComputerName;
    }

    cbAV = ( pTargetInfo ? pTargetName->Length : 0 )
        + ( pComputerName ? pComputerName->Length : 0 )
        + ( pDnsComputerName ? pDnsComputerName->Length : 0 )
        + ( pDnsTargetName ? pDnsTargetName->Length : 0 )
        + ( pDnsTreeName ? pDnsTreeName->Length : 0)
        + sizeof( AvFlags ) + (sizeof( MSV1_0_AV_PAIR ) * 6)
        + sizeof( MSV1_0_AV_PAIR);

    pTargetInfo->Buffer = new WCHAR[cbAV];

    Status DBGCHK = pTargetInfo->Buffer ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pTargetInfo->Buffer, cbAV);

        pAV = SspAvlInit(pTargetInfo->Buffer);
        SspAvlAdd(
            pAV,
            MsvAvNbDomainName,
            pTargetName,
            cbAV
            );
        SspAvlAdd(
            pAV,
            MsvAvNbComputerName,
            pComputerName,
            cbAV
            );

        SspAvlAdd(
            pAV,
            MsvAvDnsDomainName,
            pDnsTargetName,
            cbAV
            );

        SspAvlAdd(
            pAV,
            MsvAvDnsComputerName,
            pDnsComputerName,
            cbAV
            );

        SspAvlAdd(
            pAV,
            MsvAvDnsTreeName,
            pDnsTreeName,
            cbAV
            );

        //
        // add in AvFlags into TargetInfo, if applicable.
        //

        if (bForceGuest)
        {
            AvFlags |= MSV1_0_AV_FLAG_FORCE_GUEST;
        }

        if (AvFlags)
        {
            UNICODE_STRING AvString;

            AvString.Buffer = (PWSTR)&AvFlags;
            AvString.Length = sizeof( AvFlags );
            AvString.MaximumLength = AvString.Length;

            SspAvlAdd(
                pAV,
                MsvAvFlags,
                &AvString,
                cbAV
                );
        }


        pTargetInfo->MaximumLength = pTargetInfo->Length = (USHORT) SspAvlLen(pAV, cbAV);
    }

    return Status;
}


NTSTATUS
SspConvertRelativeToAbsolute(
    IN VOID* pMessageBase,
    IN ULONG cbMessageSize,
    IN STRING32* pStringToRelocate,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString,
    OUT STRING* pOutputString
    )
{
    ULONG Offset;

    //
    // If the buffer is allowed to be null,
    //  check that special case.
    //

    if (AllowNullString && (pStringToRelocate->Length == 0))
    {
        pOutputString->MaximumLength = pOutputString->Length = pStringToRelocate->Length;
        pOutputString->Buffer = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Ensure the string in entirely within the message.
    //

    Offset = (ULONG)pStringToRelocate->Buffer;

    if (Offset >= cbMessageSize || Offset + pStringToRelocate->Length > cbMessageSize)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ensure the buffer is properly aligned.
    //

    if ( AlignToWchar
        && (!COUNT_IS_ALIGNED(Offset, ALIGN_WCHAR)
            || !COUNT_IS_ALIGNED(pStringToRelocate->Length, ALIGN_WCHAR)) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Finally make the pointer absolute.
    //

    pOutputString->Buffer = (CHAR*)(pMessageBase) + Offset;
    pOutputString->MaximumLength = pOutputString->Length = pStringToRelocate->Length ;

    return STATUS_SUCCESS;
}

VOID
SspCopyStringAsString32(
    IN VOID* pMessageBuffer,
    IN OPTIONAL STRING* pInString,
    IN OUT UCHAR** ppWhere,
    OUT STRING32* pOutString32
    )
{
    //
    // Copy the data to the Buffer
    //

    if (pInString && pInString->Buffer != NULL)
    {
        RtlCopyMemory(*ppWhere, pInString->Buffer, pInString->Length);
    }

    //
    // Build a descriptor to the newly copied data
    //

    pOutString32->Length = pOutString32->MaximumLength = pInString ? pInString->Length : 0;
    pOutString32->Buffer = (ULONG)(*ppWhere - (UCHAR*)(pMessageBuffer));


    //
    // Update Where to point past the copied data
    //

    *ppWhere += pInString ? pInString->Length : 0;
}


HRESULT
IsContinueNeeded(
    IN HRESULT hr
    )
{
    if (SEC_E_OK == hr)
    {
        return S_FALSE;
    }
    else if ((SEC_I_CONTINUE_NEEDED == hr) || (SEC_I_COMPLETE_AND_CONTINUE == hr))
    {
        return S_OK;
    }
    else
    {
        return hr;
    }
}

HRESULT
IsCompleteNeeded(
    IN HRESULT hr
    )
{
    if (SEC_E_OK == hr)
    {
        return S_FALSE;
    }
    else if ((SEC_I_COMPLETE_NEEDED == hr) || (SEC_I_COMPLETE_AND_CONTINUE == hr))
    {
        return S_OK;
    }
    else
    {
        return hr;
    }
}

HRESULT
CheckSecurityPackage(
    IN OPTIONAL PCSTR pszPackageName
    )
{
    THResult hRetval = S_OK;

    ULONG cPackages = 0;
    PSecPkgInfoA pPackageInfo = NULL;

    hRetval DBGCHK = EnumerateSecurityPackagesA(&cPackages, &pPackageInfo);

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "PackageCount: %d\n", cPackages);
        for (ULONG Index = 0; Index < cPackages ; Index++ )
        {
            DebugPrintf(SSPI_LOG, "*********Package %d:*************\n", Index);
            DebugPrintf(SSPI_LOG, "Name: %s Comment: %s\n", pPackageInfo[Index].Name, pPackageInfo[Index].Comment );
            DebugPrintf(SSPI_LOG, "Cap: %#x Version: %#x RPCid: %#x MaxToken: %#x\n\n",
                pPackageInfo[Index].fCapabilities,
                pPackageInfo[Index].wVersion,
                pPackageInfo[Index].wRPCID,
                pPackageInfo[Index].cbMaxToken);
        }
    }

    THResult hr;

    if (pPackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(pPackageInfo);
        pPackageInfo = NULL;
    }

    if (SUCCEEDED(hRetval) && pszPackageName)
    {
        hRetval DBGCHK = QuerySecurityPackageInfoA((SEC_CHAR *)pszPackageName, &pPackageInfo);

        if (SUCCEEDED(hRetval))
        {
            DebugPrintf(SSPI_LOG, "Name: %s Comment: %s\n", pPackageInfo->Name, pPackageInfo->Comment );
            DebugPrintf(SSPI_LOG, "Cap: %#x Version: %#x RPCid: %#x MaxToken: %#x\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken);
        }
    }

    if (pPackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(pPackageInfo);
    }

    return hRetval;
}


HRESULT
SetProcessOptions(
    IN HANDLE hLsa,
    IN ULONG MsvPackageId,
    IN ULONG ProcessOptions
    )
{
    THResult hRetval = E_FAIL;

    MSV1_0_SETPROCESSOPTION_REQUEST OptionsRequest;
    PVOID pResponse = NULL;
    ULONG cbResponse = 0;
    NTSTATUS ProtocolStatus = STATUS_UNSUCCESSFUL;
    
    RtlZeroMemory(&OptionsRequest, sizeof(OptionsRequest));

    OptionsRequest.MessageType = (MSV1_0_PROTOCOL_MESSAGE_TYPE) MsV1_0SetProcessOption;
    OptionsRequest.ProcessOptions = ProcessOptions; // MSV1_0_OPTION_ALLOW_BLANK_PASSWORD | MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT
    OptionsRequest.DisableOptions = FALSE;

    SspiPrint(SSPI_LOG, TEXT("SetProcessOptions %#x, PackageId %#x\n"), ProcessOptions, MsvPackageId);

    hRetval DBGCHK = LsaCallAuthenticationPackage(
                        hLsa,
                        MsvPackageId,
                        &OptionsRequest,
                        sizeof(OptionsRequest),
                        &pResponse,
                        &cbResponse,
                        &ProtocolStatus
                        );

    if (NT_SUCCESS(hRetval)) 
    {
        hRetval DBGCHK = ProtocolStatus;
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sockcomm.c ===
/*++

Copyright 1996-1997 Microsoft Corporation

Module Name:

    sockcomm.c

Abstract:

    Implements a set of common operations for socket communication

Revision History:

--*/

#include "sockcomm.h"

#include <stdio.h>
#include <stdlib.h>

BOOL
InitWinsock(
    VOID
    )
{
    ULONG nRes;
    WSADATA wsaData;
    WORD wVerRequested = 0x0101; // ver 1.1

    //
    // Init the sockets interface
    //

    nRes = WSAStartup(wVerRequested, &wsaData);
    if (nRes)
    {
        SetLastError(nRes);
        fprintf (stderr, "InitWinsock couldn't init winsock: %d\n", nRes);
        return (FALSE);
    }

    return (TRUE);
}

BOOL
TermWinsock(
    VOID
    )
{
    if (SOCKET_ERROR == WSACleanup())
        return (FALSE);
    else
        return (TRUE);
}

BOOL
SendMsg(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf
    )
/*++

 Routine Description:

    Sends a message over the socket by first sending a ULONG that
    represents the size of the message followed by the message itself.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    //
    // send the size of the message
    //

    if (!SendBytes(s, sizeof(cbBuf), &cbBuf))
        return (FALSE);

    //
    // send the body of the message
    //

    if (cbBuf)
    {
        if (!SendBytes(s, cbBuf, pBuf))
            return (FALSE);
    }

    return (TRUE);
}

BOOL
ReceiveMsg(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN OUT VOID* pBuf,
    OUT ULONG *pcbRead
    )
/*++

 Routine Description:

    Receives a message over the socket.  The first ULONG in the message
    will be the message size.  The remainder of the bytes will be the
    actual message.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    ULONG cbRead = 0;
    ULONG cbData = 0;

    *pcbRead = 0;

    //
    // find out how much data is in the message
    //

    if (!ReceiveBytes(s, sizeof(cbData), &cbData, &cbRead))
        return (FALSE);

    if (sizeof(cbData) != cbRead)
        return (FALSE);

    //
    // Read the full message
    //
    if (cbData)
    {
        if (!ReceiveBytes(s, cbData, pBuf, &cbRead))
            return (FALSE);

        if (cbRead != cbData)
            return (FALSE);

        *pcbRead = cbRead;
    }

    return (TRUE);
}

BOOL
SendBytes(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN VOID* pBuf
    )
{
    PBYTE pTemp = (BYTE*) pBuf;
    ULONG cbSent = 0;
    ULONG cbRemaining = cbBuf;

    if (0 == cbBuf)
        return (TRUE);

    while (cbRemaining)
    {
        cbSent = send(s, pTemp, cbRemaining, 0);
        if (SOCKET_ERROR == cbSent)
        {
            fprintf (stderr, "SendBytes send failed: %u\n", GetLastError());
            return FALSE;
        }

        pTemp += cbSent;
        cbRemaining -= cbSent;
    }

    return TRUE;
}

BOOL
ReceiveBytes(
    IN SOCKET s,
    IN ULONG cbBuf,
    IN OUT VOID* pBuf,
    OUT ULONG* pcbRead
    )
{
    PBYTE pTemp = (BYTE*) pBuf;
    ULONG cbRead = 0;
    ULONG cbRemaining = cbBuf;

    while (cbRemaining)
    {
        cbRead = recv(s, pTemp, cbRemaining, 0);
        if (0 == cbRead)
            break;

        if (SOCKET_ERROR == cbRead)
        {
            fprintf (stderr, "ReceiveBytes recv failed: %u\n", GetLastError());
            return FALSE;
        }

        cbRemaining -= cbRead;
        pTemp += cbRead;
    }

    *pcbRead = cbBuf - cbRemaining;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\sspioutput.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    sspioutput.cxx

Abstract:

    sspioutput

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspioutput.hxx"

TSspiLibarayGlobals g_SspiGlobals = {
    1,    // major version
    2,    // minor version
    0xF,  // debug mask
    TEXT("SSPI"), // debug prompt
    NULL, // no serialization
};

#if defined(UNICODE) || defined(_UNICODE)
#define isprint iswprint
#define SspiToChar SspiToCharW
#else
#define SspiToChar SspiToCharA
#endif

WCHAR SspiToCharW(IN UCHAR c)
{
    UCHAR* pChar = &c;

    if ((c >= ' ') && (c <= '~'))
    {
        return RtlAnsiCharToUnicodeChar(&pChar);
    }

    return TEXT('.');
}

CHAR SspiToCharA(IN UCHAR c)
{
    if ((c >= ' ') && (c <= '~'))
    {
        return c;
    }

    return TEXT('.');
}

VOID SspiSpaceIt(IN ULONG cchLen, IN TCHAR* buf)
{
    for (ULONG i = 0; i < cchLen; i++)
    {
        buf[i] = TEXT(' ');
    }
}

TCHAR SspiToHex(
    IN ULONG c
    )
{
    static PCTSTR pszDigits = TEXT("0123456789abcdef");
    static ULONG len = lstrlen(pszDigits);

    if (c <= len)
    { // c >= 0
        return pszDigits[c];
    }

    return TEXT('*');
}

VOID
SspiPrintHex(
    IN ULONG ulLevel,
    IN OPTIONAL PCTSTR pszBanner,
    IN ULONG cbBuffer,
    IN const VOID* pvbuffer
    )
{
    if (g_SspiGlobals.uDebugMask & ulLevel)
    {
        PCRITICAL_SECTION pCriticalSection = g_SspiGlobals.pCriticalSection;

        const UCHAR* pBuffer = reinterpret_cast<const UCHAR*>(pvbuffer);
        ULONG high = 0;
        ULONG low = 0;
        TCHAR szLine[256] = {0};
        ULONG i = 0;

        TCHAR szBanner[MAX_PATH * 4] = {0};

        DWORD dwPid = GetCurrentProcessId();
        DWORD dwTid = GetCurrentThreadId();

        _sntprintf(szBanner, COUNTOF(szBanner) - 1,
            g_SspiGlobals.pszDbgPrompt ? TEXT("%#x.%#x %s> %s %s") : TEXT("%#x.%#x%s> %s %s"),
            dwPid,
            dwTid,
            g_SspiGlobals.pszDbgPrompt ? g_SspiGlobals.pszDbgPrompt : TEXT(""),
            SspiLevel2Str(ulLevel),
            pszBanner ? pszBanner : TEXT(""));

        if (pCriticalSection)
        {
            EnterCriticalSection(pCriticalSection);
        }

        SspiOutputDebugStringPrint(szBanner, TEXT("\n"));

        SspiSpaceIt(72, szLine);

        for (i = 0; i < cbBuffer; i++)
        {
            high = pBuffer[i] / 16;
            low = pBuffer[i] % 16;

            szLine[3 * (i % 16)] = SspiToHex(high);
            szLine[3 * (i % 16) + 1] = SspiToHex(low);
            szLine [52 + (i % 16)] = SspiToChar(pBuffer[i]);

            if (i % 16 == 7  && i != (cbBuffer - 1))
            {
                szLine[3 * (i % 16) + 2] = TEXT('-');
            }

            if (i % 16 == 15)
            {
                SspiOutputDebugStringPrint(NULL, TEXT("  %s\n"), szLine);
                SspiSpaceIt(72, szLine);
            }
        }

        SspiOutputDebugStringPrint(NULL, TEXT("  %s\n"), szLine);

        if (pCriticalSection)
        {
            LeaveCriticalSection(pCriticalSection);
        }
    }
}

PCTSTR
SspiLevel2Str(
    IN ULONG ulLevel
    )
{
    PCTSTR pszText = NULL;

    switch (ulLevel)
    {
    case SSPI_WARN:
        pszText = TEXT("[warn]");
        break;

    case SSPI_ERROR:
        pszText = TEXT("[error]");
        break;

    case SSPI_LOG:
        pszText = TEXT("[log]");
        break;

    case SSPI_LOG_MORE:
        pszText = TEXT("[more]");
        break;
    case SSPI_MSG:
        pszText = TEXT("[msg]");
        break;

    default:
        pszText = TEXT("[invalid]");
        break;
    }

    return pszText;
}

VOID
SspiVOutputDebugStringPrint(
    IN OPTIONAL PCTSTR pszBanner,
    IN PCTSTR pszFmt,
    IN va_list pArgs
    )
{
    TCHAR szBuffer[4096] = {0};
    INT cbUsed = 0;

    cbUsed = _sntprintf(szBuffer, COUNTOF(szBuffer) - 1, TEXT("%s"), pszBanner ? pszBanner : TEXT(""));

    if (cbUsed >= 0)
    {
        _vsntprintf(szBuffer + cbUsed, sizeof(szBuffer) -1 - cbUsed, pszFmt, pArgs);
    }

    OutputDebugString(szBuffer);
}

VOID
SspiOutputDebugStringPrint(
    IN OPTIONAL PCTSTR pszBanner,
    IN PCTSTR pszFmt,
    IN ...
    )
{
    va_list marker;

    va_start(marker, pszFmt);

    SspiVOutputDebugStringPrint(pszBanner ? pszBanner : TEXT(""), pszFmt, marker);

    va_end(marker);
}

VOID
SspiPrint(
    IN ULONG ulLevel,
    IN PCTSTR pszFmt,
    IN ...
    )
{
    if (g_SspiGlobals.uDebugMask & ulLevel)
    {
        TCHAR szBanner[MAX_PATH] = {0};

        DWORD dwPid = GetCurrentProcessId();
        DWORD dwTid = GetCurrentThreadId();

        _sntprintf(szBanner, COUNTOF(szBanner) - 1,
            g_SspiGlobals.pszDbgPrompt ? TEXT("%#x.%#x %s> %s ") : TEXT("%#x.%#x%s> %s "),
            dwPid,
            dwTid,
            g_SspiGlobals.pszDbgPrompt ? g_SspiGlobals.pszDbgPrompt : TEXT(""), SspiLevel2Str(ulLevel));

        va_list marker;

        va_start(marker, pszFmt);

        SspiVOutputDebugStringPrint(szBanner, pszFmt, marker);

        va_end(marker);
    }
}

VOID
SspiLogOpen(
    IN PCTSTR pszPrompt,
    IN ULONG ulMask
    )
{
    g_SspiGlobals.uDebugMask = ulMask;
    g_SspiGlobals.pszDbgPrompt = pszPrompt;
}

VOID
SspiLogOpenSerialized(
    IN PCTSTR pszPrompt,
    IN ULONG ulMask,
    IN PCRITICAL_SECTION pCriticalSection
    )
{
    g_SspiGlobals.uDebugMask = ulMask;
    g_SspiGlobals.pszDbgPrompt = pszPrompt;
    g_SspiGlobals.pCriticalSection = pCriticalSection;
}

VOID
SspiLogClose(
    VOID
    )
{
    g_SspiGlobals.uDebugMask = 0;
    g_SspiGlobals.pszDbgPrompt = NULL;
}

VOID
SspiPrintSysTimeAsLocalTime(
    IN ULONG ulLevel,
    IN PCTSTR pszBanner,
    IN LARGE_INTEGER* pSysTime
    )
{
    TNtStatus NtStatus = STATUS_UNSUCCESSFUL;
    TIME_FIELDS TimeFields = {0};
    LARGE_INTEGER LocalTime = {0};

    NtStatus DBGCHK = RtlSystemTimeToLocalTime(pSysTime, &LocalTime);

    if (NT_SUCCESS(NtStatus))
    {
        RtlTimeToTimeFields(&LocalTime, &TimeFields);
        SspiPrint(ulLevel, TEXT("%s LocalTime(%ld/%ld/%ld %ld:%2.2ld:%2.2ld) SystemTime(H%8.8lx L%8.8lx)\n"),
            pszBanner,
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second,
            pSysTime->HighPart,
            pSysTime->LowPart);
    }
}

VOID
SspiPrintLocalTime(
    IN ULONG ulLevel,
    IN PCTSTR pszBanner,
    IN LARGE_INTEGER* pLocalTime
    )
{
    TIME_FIELDS TimeFields = {0};

    RtlTimeToTimeFields(pLocalTime, &TimeFields);
    SspiPrint(ulLevel, TEXT("%s LocalTime(%ld/%ld/%ld %ld:%2.2ld:%2.2ld) H%8.8lx L%8.8lx\n"),
        pszBanner,
        TimeFields.Month,
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        pLocalTime->HighPart,
        pLocalTime->LowPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\libtest\autolog\autolog.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    autolog.cxx

Abstract:

    autolog

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "autolog.hxx"

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TimeStamp CurrentTime = {0};

    AUTO_LOG_OPEN(TEXT("autolog.exe"));

    TNtStatus Status = STATUS_UNSUCCESSFUL;

    Status DBGCHK = STATUS_INVALID_PARAMETER;

    THResult hResult = E_FAIL;

    hResult DBGCHK = E_INVALIDARG;

    DBGCFG1(Status, STATUS_INVALID_PARAMETER);
    DBGCFG1(hResult, E_INVALIDARG);

    SspiPrint(SSPI_LOG, TEXT("No traces\n"));

    Status DBGCHK = STATUS_INVALID_PARAMETER;

    hResult DBGCHK = E_INVALIDARG;

    hResult DBGNOCHK = E_OUTOFMEMORY;

    Status DBGNOCHK = STATUS_NO_MEMORY;

    SspiPrint(SSPI_LOG, TEXT("With traces\n"));

    hResult DBGCHK = E_OUTOFMEMORY;

    hResult DBGCHK = S_OK;

    if (SUCCEEDED(hResult))
    {
        SspiPrint(SSPI_LOG, TEXT("This exe file name is %s\n"), argv[0]);
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        SspiPrintHex(SSPI_LOG, TEXT("CurrentTime"), sizeof(CurrentTime), &CurrentTime);
        SspiPrintSysTimeAsLocalTime(SSPI_LOG, TEXT("CurrentTime"), &CurrentTime);
    }

    if (SUCCEEDED(hResult))
    {
        SspiPrint(SSPI_ERROR, TEXT("can not be here\n"));
    }
    else if (FAILED(hResult))
    {
        SspiPrint(SSPI_LOG, TEXT("right\n"));
    }

    hResult DBGCHK = E_OUTOFMEMORY;

    Status DBGCHK = STATUS_NO_MEMORY;

    //
    // how to use exceptions
    //
    // add /EHa into sources
    //
    // USER_C_FLAGS=$(USER_C_FLAGS) /EHa
    //

    SET_DBGSTATE_TRANS_FUNC(DbgStateC2CppExceptionTransFunc);

    try
    {
        int* p = NULL;
        *p = 0;
    }
    catch (UINT code)
    {
        SspiPrint(SSPI_WARN, TEXT("Exception caught %#x\n"), code);
    }

    AUTO_LOG_CLOSE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\lib\utils.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    utils.cxx

Abstract:

    utils

Author:

    Larry Zhu   (LZhu)             December 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "utils.hxx"

#include <Sddl.h>

#define MAXDWORD    0xffffffff

NTSTATUS
CreateUnicodeStringFromAsciiz(
    IN PCSZ pszSourceString,
    OUT UNICODE_STRING* pDestinationString
    )
{
    TNtStatus Status;

    ANSI_STRING AnsiString;

    RtlInitAnsiString( &AnsiString, pszSourceString );

    Status DBGCHK = RtlAnsiStringToUnicodeString(
                        pDestinationString,
                        &AnsiString,
                        TRUE
                        );

    return Status;
}

VOID
PackStringAsString32(
    IN VOID* pvBufferBase,
    IN OUT STRING* pString
    )
{
    pString->Buffer = (CHAR*) (pString->Buffer - (CHAR*) pvBufferBase);
}

NTSTATUS
CreateString32FromAsciiz(
    IN VOID* pvBufferBase,
    IN PCSZ pszSourceString,
    OUT UNICODE_STRING* pDestinationString
    )
{
    TNtStatus Status;

    Status DBGCHK = CreateUnicodeStringFromAsciiz(pszSourceString, pDestinationString);

    if (NT_SUCCESS(Status))
    {
        PackStringAsString32(pvBufferBase, (STRING*) pDestinationString);
    }

    return Status;
}

VOID
RelocatePackString(
    IN OUT STRING* pString,
    IN OUT CHAR** ppWhere
    )
{
    RtlCopyMemory(*ppWhere, pString->Buffer, pString->Length);
    pString->Buffer = *ppWhere;
    *ppWhere += pString->Length;
}

VOID
RelocatePackUnicodeString(
    IN UNICODE_STRING* pString,
    IN OUT CHAR** ppWhere
    )
{
    RelocatePackString((STRING*) pString, ppWhere);
}

VOID
PackUnicodeStringAsUnicodeStringZ(
    IN UNICODE_STRING* pString,
    IN OUT WCHAR** ppWhere,
    OUT UNICODE_STRING* pDestString
    )
{
    RtlCopyMemory(*ppWhere, pString->Buffer, pString->Length);
    pDestString->Buffer = *ppWhere;

    pDestString->Length = pString->Length;
    pDestString->MaximumLength = pString->Length + sizeof(WCHAR);

    *ppWhere +=  pDestString->MaximumLength / sizeof(WCHAR);

    //
    // add unicode NULL
    //

    pDestString->Buffer[(pDestString->MaximumLength / sizeof(WCHAR)) - 1] = UNICODE_NULL;
}

VOID
PackString(
    IN STRING* pString,
    IN OUT CHAR** ppWhere,
    OUT STRING* pDestString
    )
{
    RtlCopyMemory(*ppWhere, pString->Buffer, pString->Length);
    pDestString->Buffer = *ppWhere;
    *ppWhere +=  pString->Length;

    pDestString->Length = pString->Length;
    pDestString->MaximumLength = pString->Length;
}

VOID
DebugPrintSysTimeAsLocalTime(
    IN ULONG ulLevel,
    IN PCSTR pszBanner,
    IN LARGE_INTEGER* pSysTime
    )
{
   TNtStatus NtStatus = STATUS_UNSUCCESSFUL;
   TIME_FIELDS TimeFields = {0};
   LARGE_INTEGER LocalTime = {0};

   NtStatus DBGCHK = RtlSystemTimeToLocalTime(pSysTime, &LocalTime);

   if (NT_SUCCESS(NtStatus))
   {
      RtlTimeToTimeFields(&LocalTime, &TimeFields);
      DebugPrintf(ulLevel, "%s LocalTime(%ld/%ld/%ld %ld:%2.2ld:%2.2ld) SystemTime(H%8.8lx L%8.8lx)\n",
          pszBanner,
          TimeFields.Month,
          TimeFields.Day,
          TimeFields.Year,
          TimeFields.Hour,
          TimeFields.Minute,
          TimeFields.Second,
          pSysTime->HighPart,
          pSysTime->LowPart);
   }
}

VOID
DebugPrintLocalTime(
    IN ULONG ulLevel,
    IN PCSTR pszBanner,
    IN LARGE_INTEGER* pLocalTime
    )
{
    TIME_FIELDS TimeFields = {0};

    RtlTimeToTimeFields(pLocalTime, &TimeFields);
    DebugPrintf(ulLevel, "%s LocalTime(%ld/%ld/%ld %ld:%2.2ld:%2.2ld) H%8.8lx L%8.8lx\n",
        pszBanner,
        TimeFields.Month,
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        pLocalTime->HighPart,
        pLocalTime->LowPart);
}

#define DESKTOP_ALL (DESKTOP_READOBJECTS | DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD | DESKTOP_JOURNALPLAYBACK | DESKTOP_ENUMERATE | DESKTOP_WRITEOBJECTS | DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | WINSTA_ENUMERATE | WINSTA_READSCREEN | STANDARD_RIGHTS_REQUIRED)

#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)

HRESULT
StartInteractiveClientProcessAsUser(
    IN HANDLE hToken,
    IN PTSTR pszCommandLine    // command line to execute
    )
{
    THResult hRetval = E_FAIL;

    HANDLE hDup = NULL;
    HDESK hdesk = NULL;
    HWINSTA hwinsta = NULL;
    HWINSTA hwinstaSave = NULL;
    PROCESS_INFORMATION pi = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, 0, 0};
    PSID pSid = NULL;
    STARTUPINFO si = {0};
    HANDLE hSystemToken = NULL;
    CHAR TokenUserInfoBuffer[MAX_PATH + sizeof(TOKEN_USER)] = {0}; // MAX_SID_SIZE is 256
    TOKEN_USER* pTokenUserInfo = (TOKEN_USER*) TokenUserInfoBuffer;
    ULONG cbReturn = 0;

    // Save a handle to the caller's current window station.

    hwinstaSave = GetProcessWindowStation();

    hRetval DBGCHK = hwinstaSave ? S_OK : GetLastErrorAsHResult();

    // Get the SID for the client's logon session.

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = GetLogonSIDOrUserSid(hToken, &pSid) ? S_OK : GetLastErrorAsHResult();
    }

    // Get a handle to the interactive window station.

    if (SUCCEEDED(hRetval))
    {
       hwinsta = OpenWindowStation(
                   TEXT("winsta0"),           // the interactive window station
                   FALSE,                     // handle is not inheritable
                   MAXIMUM_ALLOWED           // rights to read/write the DACL
                   );
       hRetval DBGCHK = hwinsta ? S_OK : GetLastErrorAsHResult();
    }

    // Allow logon SID full access to interactive window station.

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = AddAceToWindowStation(hwinsta, pSid) ? S_OK : GetLastErrorAsHResult();
    }

    // To get the correct default desktop, set the caller's
    // window station to the interactive window station.

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SetProcessWindowStation(hwinsta) ? S_OK : GetLastErrorAsHResult();
    }

    // Get a handle to the interactive desktop.

    if (SUCCEEDED(hRetval))
    {
        TImpersonation imper(NULL);

        hRetval DBGCHK = imper.Validate();

        if (SUCCEEDED(hRetval))
        {
            hdesk = OpenDesktop(
                        TEXT("default"), // the interactive window station
                        0,               // no interaction with other desktop processes
                        FALSE,           // handle is not inheritable
                        MAXIMUM_ALLOWED
                        );
            hRetval DBGCHK = hdesk ? S_OK : GetLastErrorAsHResult();
        }

        // Allow logon SID full access to interactive desktop.

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = AddAceToDesktop(hdesk, pSid) ? S_OK : GetLastErrorAsHResult();
        }
    }

    //
    // get the necessary privileges enabled
    //

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = GetSystemToken(&hSystemToken);
    }

    if (SUCCEEDED(hRetval))
    {
        TImpersonation imper(hSystemToken);

        hRetval DBGCHK = imper.Validate();

        // Allow logon SID full access to interactive desktop.

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = SetThreadDesktop(hdesk) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = GetTokenInformation(
                                hToken,
                                TokenUser,
                                TokenUserInfoBuffer,
                                sizeof(TokenUserInfoBuffer),
                                &cbReturn
                                ) ? S_OK : GetLastErrorAsHResult();
        }

        // Initialize the STARTUPINFO structure.
        // Specify that the process runs in the interactive desktop.

        if (SUCCEEDED(hRetval))
        {
            si.cb = sizeof(STARTUPINFO);
            si.lpDesktop = TEXT("winsta0\\default");

            hRetval DBGCHK = ConvertSidToStringSid(pTokenUserInfo->User.Sid, &si.lpTitle) ? S_OK : GetLastErrorAsHResult();
        }

        // Launch the process in the client's logon session.

        if (SUCCEEDED(hRetval))
        {
            DBGCFG1(hRetval, HRESULT_FROM_WIN32(ERROR_BAD_TOKEN_TYPE));

            hRetval DBGCHK = CreateProcessAsUser(
                                hToken,            // client's access token
                                NULL,              // file to execute
                                pszCommandLine,     // command line
                                NULL,              // pointer to process SECURITY_ATTRIBUTES
                                NULL,              // pointer to thread SECURITY_ATTRIBUTES
                                FALSE,             // handles are not inheritable
                                NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,   // creation flags
                                NULL,              // pointer to new environment block
                                NULL,              // name of current directory
                                &si,               // pointer to STARTUPINFO structure
                                &pi                // receives information about new process
                                ) ? S_OK : GetLastErrorAsHResult();

            if (FAILED(hRetval) && (ERROR_BAD_TOKEN_TYPE == HRESULT_CODE(hRetval)))
            {
                DebugPrintf(SSPI_WARN, "CreateProcessAsUser failed with ERROR_BAD_TOKEN_TYPE\n");

                hRetval DBGCHK = DuplicateTokenEx(
                                    hToken,
                                    TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &hDup
                                    ) ? S_OK : GetLastErrorAsHResult();

                if (SUCCEEDED(hRetval))
                {
                    hRetval DBGCHK = CreateProcessAsUser(
                                        hDup,              // client's access token
                                        NULL,              // file to execute
                                        pszCommandLine,     // command line
                                        NULL,              // pointer to process SECURITY_ATTRIBUTES
                                        NULL,              // pointer to thread SECURITY_ATTRIBUTES
                                        FALSE,             // handles are not inheritable
                                        NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,   // creation flags
                                        NULL,              // pointer to new environment block
                                        NULL,              // name of current directory
                                        &si,               // pointer to STARTUPINFO structure
                                        &pi                // receives information about new process
                                        ) ? S_OK : GetLastErrorAsHResult();
                }
            }
        }

        if (SUCCEEDED(hRetval))
        {
            SspiPrint(SSPI_LOG, TEXT("StartInteractiveClientProcessAsUser succeeded: process id %d(%#x), user is %s, pszCommandLine \"%s\"\n"), pi.dwProcessId, pi.dwProcessId, si.lpTitle, pszCommandLine);
        }

        if (si.lpTitle)
        {
            LocalFree(si.lpTitle);
        }
    }

    THResult hr;

    // Restore the caller's window station.

    if (hwinstaSave)
    {
        hr DBGCHK = SetProcessWindowStation(hwinstaSave) ? S_OK : GetLastErrorAsHResult();

        hr DBGCHK = CloseWindowStation(hwinstaSave) ? S_OK : GetLastErrorAsHResult();
    }

    if (hDup)
    {
        hr DBGCHK = CloseHandle(hDup) ? S_OK : GetLastErrorAsHResult();
    }

    if (hSystemToken)
    {
        hr DBGCHK = CloseHandle(hSystemToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (pi.hProcess != INVALID_HANDLE_VALUE)
    {
        // WaitForSingleObject(pi.hProcess, INFINITE);
        hr DBGCHK = CloseHandle(pi.hProcess) ? S_OK : GetLastErrorAsHResult();
    }

    if (pi.hThread != INVALID_HANDLE_VALUE)
    {
        hr DBGCHK = CloseHandle(pi.hThread) ? S_OK : GetLastErrorAsHResult();
    }

    // Close the handles to the interactive window station and desktop.

    if (hwinsta)
    {
        hr DBGCHK = CloseWindowStation(hwinsta) ? S_OK : GetLastErrorAsHResult();
    }

    if (hdesk)
    {
        DBGCFG1(hr, HRESULT_FROM_WIN32(ERROR_BUSY));

        hr DBGCHK = CloseDesktop(hdesk) ? S_OK : GetLastErrorAsHResult();
    }

    // Free the buffer for the logon SID.

    if (pSid)
    {
        FreeLogonSID(&pSid);
    }

    return hRetval;
}

BOOL AddAceToWindowStation(IN HWINSTA hwinsta, IN PSID psid)
{
   ACCESS_ALLOWED_ACE   *pace;
   ACL_SIZE_INFORMATION aclSizeInfo;
   BOOL                 bDaclExist;
   BOOL                 bDaclPresent;
   BOOL                 bSuccess = FALSE;
   DWORD                dwNewAclSize;
   DWORD                dwSidSize = 0;
   DWORD                dwSdSizeNeeded;
   PACL                 pacl;
   PACL                 pNewAcl;
   PSECURITY_DESCRIPTOR psd = NULL;
   PSECURITY_DESCRIPTOR psdNew = NULL;
   PVOID                pTempAce;
   SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
   unsigned int         i;

   __try
   {
      // Obtain the DACL for the window station.

      if (!GetUserObjectSecurity(
             hwinsta,
             &si,
             psd,
             dwSidSize,
             &dwSdSizeNeeded))
      {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
          {
             psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                           GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           dwSdSizeNeeded);

             if (psd == NULL)
                __leave;

             psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                               GetProcessHeap(),
                                               HEAP_ZERO_MEMORY,
                                               dwSdSizeNeeded);

             if (psdNew == NULL)
                __leave;

             dwSidSize = dwSdSizeNeeded;

             if (!GetUserObjectSecurity(
                       hwinsta,
                       &si,
                       psd,
                       dwSidSize,
                       &dwSdSizeNeeded))
                __leave;
          }
          else
             __leave;
      }

      // Create a new DACL.

      if (!InitializeSecurityDescriptor(
                psdNew,
                SECURITY_DESCRIPTOR_REVISION))
         __leave;

      // Get the DACL from the security descriptor.

      if (!GetSecurityDescriptorDacl(
                psd,
                &bDaclPresent,
                &pacl,
                &bDaclExist))
         __leave;

      // Initialize the ACL.

      ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
      aclSizeInfo.AclBytesInUse = sizeof(ACL);

      // Call only if the DACL is not NULL.

      if (pacl != NULL)
      {
         // get the file ACL size info
         if (!GetAclInformation(
                   pacl,
                   (PVOID)&aclSizeInfo,
                   sizeof(ACL_SIZE_INFORMATION),
                   AclSizeInformation))
            __leave;
      }

      // Compute the size of the new ACL.

      dwNewAclSize = aclSizeInfo.AclBytesInUse + (2 * sizeof(ACCESS_ALLOWED_ACE))
          + (2 * GetLengthSid(psid)) - (2 * sizeof(DWORD));

      // Allocate memory for the new ACL.

      pNewAcl = (PACL)HeapAlloc(
                        GetProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        dwNewAclSize);

      if (pNewAcl == NULL)
         __leave;

      // Initialize the new DACL.

      if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
         __leave;

      // If DACL is present, copy it to a new DACL.

      if (bDaclPresent)
      {
         // Copy the ACEs to the new ACL.
         if (aclSizeInfo.AceCount)
         {
            for (i=0; i < aclSizeInfo.AceCount; i++)
            {
               // Get an ACE.
               if (!GetAce(pacl, i, &pTempAce))
                  __leave;

               // Add the ACE to the new ACL.
               if (!AddAce(
                     pNewAcl,
                     ACL_REVISION,
                     MAXDWORD,
                     pTempAce,
                    ((PACE_HEADER)pTempAce)->AceSize))
                  __leave;
            }
         }
      }

      // Add the first ACE to the window station.

      pace = (ACCESS_ALLOWED_ACE *)HeapAlloc(
                                        GetProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) -
                                              sizeof(DWORD));

      if (pace == NULL)
         __leave;

      pace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
      pace->Header.AceFlags = CONTAINER_INHERIT_ACE |
                   INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
      pace->Header.AceSize  = (USHORT) (sizeof(ACCESS_ALLOWED_ACE) +
                   GetLengthSid(psid) - sizeof(DWORD));
      pace->Mask            = GENERIC_ACCESS;

      if (!CopySid(GetLengthSid(psid), &pace->SidStart, psid))
         __leave;

      if (!AddAce(
            pNewAcl,
            ACL_REVISION,
            MAXDWORD,
            (PVOID)pace,
            pace->Header.AceSize))
         __leave;

      // Add the second ACE to the window station.

      pace->Header.AceFlags = NO_PROPAGATE_INHERIT_ACE;
      pace->Mask = WINSTA_ALL;

      if (!AddAce(
            pNewAcl,
            ACL_REVISION,
            MAXDWORD,
            (PVOID)pace,
            pace->Header.AceSize))
         __leave;

      // Set a new DACL for the security descriptor.

      if (!SetSecurityDescriptorDacl(
                psdNew,
                TRUE,
                pNewAcl,
                FALSE))
         __leave;

      // Set the new security descriptor for the window station.

      if (!SetUserObjectSecurity(hwinsta, &si, psdNew))
         __leave;

      // Indicate success.

      bSuccess = TRUE;
   }
   __finally
   {
      // Free the allocated buffers.

      if (pace != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)pace);

      if (pNewAcl != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)pNewAcl);

      if (psd != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)psd);

      if (psdNew != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)psdNew);
   }

   return bSuccess;
}

BOOL AddAceToDesktop(IN HDESK hdesk, IN PSID psid)
{
   ACL_SIZE_INFORMATION aclSizeInfo;
   BOOL                 bDaclExist;
   BOOL                 bDaclPresent;
   BOOL                 bSuccess = FALSE;
   DWORD                dwNewAclSize;
   DWORD                dwSidSize = 0;
   DWORD                dwSdSizeNeeded;
   PACL                 pacl;
   PACL                 pNewAcl;
   PSECURITY_DESCRIPTOR psd = NULL;
   PSECURITY_DESCRIPTOR psdNew = NULL;
   PVOID                pTempAce;
   SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
   unsigned int         i;

   __try
   {
      // Obtain the security descriptor for the desktop object.

      if (!GetUserObjectSecurity(
            hdesk,
            &si,
            psd,
            dwSidSize,
            &dwSdSizeNeeded))
      {
         if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
         {
            psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                          GetProcessHeap(),
                                          HEAP_ZERO_MEMORY,
                                          dwSdSizeNeeded );

            if (psd == NULL)
               __leave;

            psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                              GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              dwSdSizeNeeded);

            if (psdNew == NULL)
               __leave;

            dwSidSize = dwSdSizeNeeded;

            if (!GetUserObjectSecurity(
                      hdesk,
                      &si,
                      psd,
                      dwSidSize,
                      &dwSdSizeNeeded))
               __leave;
         }
         else
            __leave;
      }

      // Create a new security descriptor.

      if (!InitializeSecurityDescriptor(
                psdNew,
                SECURITY_DESCRIPTOR_REVISION))
         __leave;

      // Obtain the DACL from the security descriptor.

      if (!GetSecurityDescriptorDacl(
                psd,
                &bDaclPresent,
                &pacl,
                &bDaclExist))
         __leave;

      // Initialize.

      ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
      aclSizeInfo.AclBytesInUse = sizeof(ACL);

      // Call only if NULL DACL.

      if (pacl != NULL)
      {
         // Determine the size of the ACL information.

         if (!GetAclInformation(
                   pacl,
                   (PVOID)&aclSizeInfo,
                   sizeof(ACL_SIZE_INFORMATION),
                   AclSizeInformation))
            __leave;
      }

      // Compute the size of the new ACL.

      dwNewAclSize = aclSizeInfo.AclBytesInUse +
            sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid(psid) - sizeof(DWORD);

      // Allocate buffer for the new ACL.

      pNewAcl = (PACL)HeapAlloc(
                        GetProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        dwNewAclSize);

      if (pNewAcl == NULL)
         __leave;

      // Initialize the new ACL.

      if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
         __leave;

      // If DACL is present, copy it to a new DACL.

      if (bDaclPresent)
      {
         // Copy the ACEs to the new ACL.
         if (aclSizeInfo.AceCount)
         {
            for (i=0; i < aclSizeInfo.AceCount; i++)
            {
               // Get an ACE.
               if (!GetAce(pacl, i, &pTempAce))
                  __leave;

               // Add the ACE to the new ACL.
               if (!AddAce(
                      pNewAcl,
                      ACL_REVISION,
                      MAXDWORD,
                      pTempAce,
                      ((PACE_HEADER)pTempAce)->AceSize))
                  __leave;
            }
         }
      }

      // Add ACE to the DACL.

      if (!AddAccessAllowedAce(
                pNewAcl,
                ACL_REVISION,
                DESKTOP_ALL,
                psid))
         __leave;

      // Set new DACL to the new security descriptor.

      if (!SetSecurityDescriptorDacl(
                psdNew,
                TRUE,
                pNewAcl,
                FALSE))
         __leave;

      // Set the new security descriptor for the desktop object.

      if (!SetUserObjectSecurity(hdesk, &si, psdNew))
         __leave;

      // Indicate success.

      bSuccess = TRUE;
   }
   __finally
   {
      // Free buffers.

      if (pNewAcl != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)pNewAcl);

      if (psd != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)psd);

      if (psdNew != NULL)
         HeapFree(GetProcessHeap(), 0, (PVOID)psdNew);
   }

   return bSuccess;
}

BOOL GetLogonSIDOrUserSid(IN HANDLE hToken, OUT PSID *ppsid)
{
   BOOL bSuccess = FALSE;
   DWORD dwIndex;
   DWORD dwLength = 0;
   PTOKEN_GROUPS ptg = NULL;

   *ppsid = NULL;

   // Get required buffer size and allocate the TOKEN_GROUPS buffer.

   if (!GetTokenInformation(
             hToken,         // handle to the access token
             TokenGroups,    // get information about the token's groups
             (PVOID) ptg,   // pointer to TOKEN_GROUPS buffer
             0,              // size of buffer
             &dwLength       // receives required buffer size
          ))
   {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
         goto Cleanup;

      ptg = (PTOKEN_GROUPS)HeapAlloc(GetProcessHeap(),
                             HEAP_ZERO_MEMORY, dwLength);

      if (ptg == NULL)
         goto Cleanup;
   }

   // Get the token group information from the access token.

   if (!GetTokenInformation(
             hToken,         // handle to the access token
             TokenGroups,    // get information about the token's groups
             (PVOID) ptg,   // pointer to TOKEN_GROUPS buffer
             dwLength,       // size of buffer
             &dwLength       // receives required buffer size
             ))
   {
      goto Cleanup;
   }

   // Loop through the groups to find the logon SID.

   for (dwIndex = 0; dwIndex < ptg->GroupCount; dwIndex++)
      if (0 != (ptg->Groups[dwIndex].Attributes & SE_GROUP_LOGON_ID))
      {
         // Found the logon SID; make a copy of it.

         dwLength = GetLengthSid(ptg->Groups[dwIndex].Sid);
         *ppsid = (PSID) HeapAlloc(GetProcessHeap(),
                             HEAP_ZERO_MEMORY, dwLength);
         if (*ppsid == NULL)
             goto Cleanup;
         if (!CopySid(dwLength, *ppsid, ptg->Groups[dwIndex].Sid))
         {
             HeapFree(GetProcessHeap(), 0, (PVOID)*ppsid);
             goto Cleanup;
         }
         break;
      }

   if (NULL == *ppsid)
   {
       ULONG cbUserInfo;
       PUCHAR pnSubAuthorityCount = 0;
       CHAR UserInfoBuffer[4096] = {0};
       PTOKEN_USER  pUserInfo = (PTOKEN_USER) UserInfoBuffer;

       SspiPrint(SSPI_WARN, TEXT("GetLogonSIDOrUserSid failed to find logon id, trying user sid\n"));

       if (!GetTokenInformation(
                hToken,
                TokenUser,
                UserInfoBuffer,
                sizeof(UserInfoBuffer),
                &cbUserInfo
                ))
       {
           goto Cleanup;
       }

       if (!IsValidSid(pUserInfo->User.Sid)) goto Cleanup;

       pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
       dwLength = GetSidLengthRequired(*pnSubAuthorityCount);

       *ppsid = (PSID) HeapAlloc(GetProcessHeap(),
                           HEAP_ZERO_MEMORY, dwLength);
       if (*ppsid == NULL)
           goto Cleanup;

       if (!CopySid(dwLength, *ppsid, pUserInfo->User.Sid))
       {
           HeapFree(GetProcessHeap(), 0, (PVOID)*ppsid);
           goto Cleanup;
       }
   }

   bSuccess = TRUE;

Cleanup:

   // Free the buffer for the token groups.

   if (ptg != NULL)
      HeapFree(GetProcessHeap(), 0, (PVOID)ptg);

   return bSuccess;
}

VOID FreeLogonSID(IN PSID *ppsid)
{
    HeapFree(GetProcessHeap(), 0, (PVOID)*ppsid);
}

/**
This function builds a Dacl which grants the creator of the objects
FILE_ALL_ACCESS and Everyone FILE_GENERIC_READ and FILE_GENERIC_WRITE
access to the object.

This Dacl allows for higher security than a NULL Dacl, which is common for
named-pipes, as this only grants the creator/owner write access to the
security descriptor, and grants Everyone the ability to "use" the named-pipe.
This scenario prevents a malevolent user from disrupting service by preventing
arbitrary access manipulation.
**/
BOOL
BuildNamedPipeAcl(
    IN OUT PACL pAcl,
    OUT PDWORD pcbAclSize
    )
{
    DWORD cbAclSize = 0;

    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaCreator = SECURITY_CREATOR_SID_AUTHORITY;

    BYTE BufEveryoneSid[32] = {0};
    BYTE BufOwnerSid[32] = {0};

    PSID pEveryoneSid = (PSID)BufEveryoneSid;
    PSID pOwnerSid = (PSID)BufOwnerSid;

    //
    // compute size of acl
    //
    cbAclSize = sizeof(ACL) + 2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) )
        + GetSidLengthRequired( 1 )   // well-known Everyone Sid
        + GetSidLengthRequired( 1 ) ; // well-known Creator Owner Sid

    if (*pcbAclSize < cbAclSize)
    {
        *pcbAclSize = cbAclSize;
        return FALSE;
    }

    *pcbAclSize = cbAclSize;

    //
    // intialize well known sids
    //

    if (!InitializeSid(pEveryoneSid, &siaWorld, 1)) return FALSE;

    *GetSidSubAuthority(pEveryoneSid, 0) = SECURITY_WORLD_RID;

    if (!InitializeSid(pOwnerSid, &siaCreator, 1)) return FALSE;

    *GetSidSubAuthority(pOwnerSid, 0) = SECURITY_CREATOR_OWNER_RID;

    if (!InitializeAcl(pAcl, cbAclSize, ACL_REVISION))
        return FALSE;

    if (!AddAccessAllowedAce(
            pAcl,
            ACL_REVISION,
            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
            pEveryoneSid
            ))
        return FALSE;

    return AddAccessAllowedAce(
                pAcl,
                ACL_REVISION,
                FILE_ALL_ACCESS,
                pOwnerSid
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\logon\subauth.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    logon.cxx

Abstract:

    logon

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "logon.hxx"

NTSTATUS
GetSubAuthLogonInfo(
    IN ULONG SubAuthId,
    IN BOOLEAN bUseNewSubAuthStyle,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation,
    OUT ULONG* pcbLogonInfo,
    OUT VOID** ppLognInfo
    )
{
    TNtStatus Status;

    PMSV1_0_LM20_LOGON pMsvNetAuthInfo = NULL;
    ULONG cbMsvNetAuthInfo;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING LmPassword;
    UCHAR LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;
    NT_CHALLENGE NtChallenge;

    DebugPrintf(SSPI_LOG, "GetSubAuthLogonInfo UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n",
        pUserName, pDomainName, pPassword, pWorkstation);

    *ppLognInfo = NULL;
    *pcbLogonInfo = 0;

    cbMsvNetAuthInfo = ROUND_UP_COUNT(sizeof(MSV1_0_SUBAUTH_LOGON), sizeof(ULONG_PTR))
        + pUserName->Length
        + pDomainName->Length
        + pWorkstation->Length
        + NT_RESPONSE_LENGTH
        + LM_RESPONSE_LENGTH;

    pMsvNetAuthInfo = (PMSV1_0_LM20_LOGON) new CHAR[cbMsvNetAuthInfo];

    Status DBGCHK = pMsvNetAuthInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        //
        // Start packing in the string
        //

        RtlZeroMemory(pMsvNetAuthInfo, cbMsvNetAuthInfo);

        pMsvNetAuthInfo->MessageType = bUseNewSubAuthStyle ? MsV1_0SubAuthLogon : MsV1_0NetworkLogon; // if set MsV1_0Lm20Logon, ignore ParameterControl

        //
        // Copy the user name into the authentication buffer
        //

        pMsvNetAuthInfo->UserName.Length = pUserName->Length;
        pMsvNetAuthInfo->UserName.MaximumLength = pMsvNetAuthInfo->UserName.Length;

        pMsvNetAuthInfo->UserName.Buffer = (PWSTR)( ((CHAR*)pMsvNetAuthInfo) + sizeof(MSV1_0_SUBAUTH_LOGON) ); // could be aligned here
        RtlCopyMemory(
            pMsvNetAuthInfo->UserName.Buffer,
            pUserName->Buffer,
            pUserName->Length
            );

        //
        // Copy the domain name into the authentication buffer
        //

        pMsvNetAuthInfo->LogonDomainName.Length = pDomainName->Length;
        pMsvNetAuthInfo->LogonDomainName.MaximumLength = pDomainName->Length ;

        pMsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR) ((PBYTE)(pMsvNetAuthInfo->UserName.Buffer)
            + pMsvNetAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            pMsvNetAuthInfo->LogonDomainName.Buffer,
            pDomainName->Buffer,
            pDomainName->Length
            );

        //
        // Copy the workstation name into the buffer
        //

        pMsvNetAuthInfo->Workstation.Length = pWorkstation->Length;

        pMsvNetAuthInfo->Workstation.MaximumLength = pMsvNetAuthInfo->Workstation.Length;

        pMsvNetAuthInfo->Workstation.Buffer = (PWSTR) ((PBYTE) (pMsvNetAuthInfo->LogonDomainName.Buffer)
            + pMsvNetAuthInfo->LogonDomainName.MaximumLength);

        RtlCopyMemory(
            pMsvNetAuthInfo->Workstation.Buffer,
            pWorkstation->Buffer,
            pWorkstation->Length
            );

        //
        // Now, generate the bits for the challenge
        //

        RtlGenRandom(&NtChallenge, sizeof(NtChallenge));


        RtlCopyMemory(pMsvNetAuthInfo->ChallengeToClient,
            &NtChallenge,
            MSV1_0_CHALLENGE_LENGTH);

        //
        // Set up space for response
        //

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer =
            (((PCHAR) pMsvNetAuthInfo->Workstation.Buffer)
             + pMsvNetAuthInfo->Workstation.MaximumLength);

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Length = NT_RESPONSE_LENGTH;

        pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength = NT_RESPONSE_LENGTH;

        RtlCalculateNtOwfPassword(
            pPassword,
            &PasswordHash
            );

        RtlCalculateNtResponse(
            &NtChallenge,
            &PasswordHash,
            (PNT_RESPONSE) pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer
            );

        //
        // Now do the painful LM compatible hash, so anyone who is maintaining
        // their account from a WfW machine will still have a password.
        //

        LmPassword.Buffer = (PCHAR) LmPasswordBuf;
        LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

        Status DBGCHK = RtlUpcaseUnicodeStringToOemString(
            &LmPassword,
            pPassword,
            FALSE
            );
    }

    if (NT_SUCCESS(Status))
    {
        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer =
           ((PCHAR) (pMsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer)
            + pMsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength);

        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length = LM_RESPONSE_LENGTH;
        pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength = LM_RESPONSE_LENGTH;

        RtlCalculateLmOwfPassword(
            LmPassword.Buffer,
            &LmPasswordHash
            );

        RtlZeroMemory(LmPassword.Buffer, LmPassword.Length);

        RtlCalculateLmResponse(
            &NtChallenge,
            &LmPasswordHash,
            (PLM_RESPONSE) pMsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer
            );

        if (bUseNewSubAuthStyle)
        {
            ((MSV1_0_SUBAUTH_LOGON*) pMsvNetAuthInfo)->SubAuthPackageId = SubAuthId;
        }
        else
        {
            pMsvNetAuthInfo->ParameterControl |= SubAuthId << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;
        }

        *ppLognInfo = pMsvNetAuthInfo;
        pMsvNetAuthInfo = NULL;
        *pcbLogonInfo = cbMsvNetAuthInfo;
    }

    if (pMsvNetAuthInfo)
    {
        delete [] pMsvNetAuthInfo;
    }

    return Status;
}

NTSTATUS
MsvSubAuthLsaLogon(
    IN HANDLE hLsa,
    IN ULONG PackageId,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG SubAuthId,
    IN BOOLEAN bUseNewSubAuthStyle,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation,
    OUT HANDLE* phToken
    )
{
    TNtStatus Status;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    VOID* pLogonInfo = NULL;
    ULONG cbLogonInfoSize = 0;

    LSA_STRING Name = {0};
    TOKEN_SOURCE SourceContext = {0};
    VOID* pProfile = NULL;
    ULONG cbProfileSize = 0;
    LUID LogonId = {0};
    QUOTA_LIMITS Quotas = {0};

    DebugPrintf(SSPI_LOG, "MsvSubAuthLsaLogon PackageId %#x, LogonType %#x, SubAuthId %#x, "
        "UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n",
        PackageId, LogonType, SubAuthId, pUserName,
        pDomainName, pPassword, pWorkstation);

    strncpy(
        SourceContext.SourceName,
        "ssptest",
        sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    Status DBGCHK = GetSubAuthLogonInfo(
        SubAuthId,
        bUseNewSubAuthStyle,
        pUserName,
        pDomainName,
        pPassword,
        pWorkstation,
        &cbLogonInfoSize,
        &pLogonInfo
        );

    if (NT_SUCCESS(Status))
    {
        SspiPrintHex(SSPI_LOG, TEXT("SubAuthInfo"), cbLogonInfoSize, pLogonInfo);

        Status DBGCHK = LsaLogonUser(
            hLsa,
            &Name,
            LogonType,
            PackageId,
            pLogonInfo,
            cbLogonInfoSize,
            NULL, // no token groups
            &SourceContext,
            (VOID**) &pProfile,
            &cbProfileSize,
            &LogonId,
            phToken,
            &Quotas,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", LogonId.HighPart, LogonId.LowPart);
        DebugPrintf(SSPI_LOG, "Token handle %p\n", *phToken);
        DebugPrintf(SSPI_LOG, "Quotas PagedPoolLimit %p, NonPagedPoolLimit %p, "
            "MinimumWorkingSetSize %p, MaximumWorkingSetSize %p, PagedPoolLimit %p\n",
            Quotas.PagedPoolLimit, Quotas.NonPagedPoolLimit,
            Quotas.MinimumWorkingSetSize, Quotas.MaximumWorkingSetSize,
            Quotas.PagedPoolLimit);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "TimeLimit", &Quotas.TimeLimit);

        if (MsV1_0InteractiveProfile  == *((ULONG*) pProfile))
        {
            MSV1_0_INTERACTIVE_PROFILE* pMsvInteractiveProfile = (MSV1_0_INTERACTIVE_PROFILE*) pProfile;
            DebugPrintf(SSPI_LOG, "interactive logon profile: "
                "LogCount %#x, BaddPasswordCount %#x, LogonScript %wZ, "
                "HomeDirectory %wZ, FullName %wZ, ProfilePath %wZ, "
                "HomeDriectoryDrive %wZ, LogonServer %wZ, UserFlags %#x\n",
                 pMsvInteractiveProfile->LogonCount,
                 pMsvInteractiveProfile->BadPasswordCount,
                 &pMsvInteractiveProfile->LogonScript,
                 &pMsvInteractiveProfile->HomeDirectory,
                 &pMsvInteractiveProfile->FullName,
                 &pMsvInteractiveProfile->ProfilePath,
                 &pMsvInteractiveProfile->HomeDirectoryDrive,
                 &pMsvInteractiveProfile->LogonServer,
                 pMsvInteractiveProfile->UserFlags);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "LogonTime ", &pMsvInteractiveProfile->LogonTime);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "KickOffTime ", &pMsvInteractiveProfile->KickOffTime );
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordLastSet ", &pMsvInteractiveProfile->PasswordLastSet );
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordCanChange ", &pMsvInteractiveProfile->PasswordCanChange );
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordMustChange ", &pMsvInteractiveProfile->PasswordMustChange );
        }
        else if (MsV1_0Lm20LogonProfile == *((ULONG*) pProfile))
        {
            MSV1_0_LM20_LOGON_PROFILE* pMsvLm20LogonProfile = (MSV1_0_LM20_LOGON_PROFILE*) pProfile;
            DebugPrintf(SSPI_LOG, "Lm20 logon profile: "
                "UserFlags %#x, LogonDomainName %wZ, LogonServer %wZ, UserParameters %#x\n",
                pMsvLm20LogonProfile->UserFlags,
                &pMsvLm20LogonProfile->LogonDomainName,
                &pMsvLm20LogonProfile->LogonServer,
                pMsvLm20LogonProfile->UserParameters);
            DebugPrintHex(SSPI_LOG, "UserSessionKey:", MSV1_0_USER_SESSION_KEY_LENGTH, pMsvLm20LogonProfile->UserSessionKey);
            DebugPrintHex(SSPI_LOG, "LanmanSessionKey:", MSV1_0_LANMAN_SESSION_KEY_LENGTH, pMsvLm20LogonProfile->LanmanSessionKey);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "KickOffTime", &pMsvLm20LogonProfile->KickOffTime);
            DebugPrintSysTimeAsLocalTime(SSPI_LOG, "LogoffTime", &pMsvLm20LogonProfile->LogoffTime);
        }
        else
        {
            DebugPrintf(SSPI_ERROR, "Unsupported profile type %#x\n", *((ULONG*) pProfile));
        }
    }

    if (pProfile)
    {
        LsaFreeReturnBuffer(pProfile);
    }

    return Status;
}

NTSTATUS
MsvSubAuthLogon(
    IN HANDLE hLsa,
    IN ULONG PackageId,
    IN ULONG SubAuthId,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pDomainName,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pWorkstation
    )
{
    TNtStatus Status;

    WCHAR LogonInfo[MAX_PATH] = {0};
    PMSV1_0_PASSTHROUGH_REQUEST pPassthroughRequest = NULL;
    ULONG cbRequest = 0;
    ULONG cbResponse = 0;
    PMSV1_0_PASSTHROUGH_RESPONSE pPassthroughResponse = NULL;
    MSV1_0_SUBAUTH_REQUEST* pSubAuthRequest = NULL;
    UNICODE_STRING MsvPackageName = {0};
    UCHAR* pWhere = NULL;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    SspiPrint(SSPI_LOG, TEXT("MsvSubAuthLsaLogon PackageId %#x, SubAuthId %#x(%d), ")
        TEXT("UserName %wZ, DomainName %wZ, Password %wZ, Workstation %wZ\n"),
        PackageId, SubAuthId, SubAuthId, pUserName, pDomainName, pPassword, pWorkstation);

    _snwprintf(LogonInfo, COUNTOF(LogonInfo) - 1, L"%wZ%wZ%wZ%wZ",
        pUserName, pDomainName, pPassword, pWorkstation);

    RtlInitUnicodeString(&MsvPackageName, L"NTLM");

    cbRequest = sizeof(MSV1_0_PASSTHROUGH_REQUEST)
        + ROUND_UP_COUNT(pDomainName->Length + sizeof(WCHAR), ALIGN_LPTSTR)
        + ROUND_UP_COUNT(MsvPackageName.Length + sizeof(WCHAR), ALIGN_LPTSTR)
        + ROUND_UP_COUNT(sizeof(MSV1_0_SUBAUTH_REQUEST), ALIGN_LPTSTR)
        + ROUND_UP_COUNT(wcslen(LogonInfo) * sizeof(WCHAR) + sizeof(WCHAR), ALIGN_LPTSTR);

    pPassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) new CHAR[cbRequest];

    Status DBGCHK = pPassthroughRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pPassthroughRequest, cbRequest);

        pWhere = (PUCHAR) (pPassthroughRequest + 1);

        pPassthroughRequest->MessageType = MsV1_0GenericPassthrough;

        pPassthroughRequest->DomainName = *pDomainName;
        pPassthroughRequest->DomainName.Buffer = (PWSTR) pWhere;
        RtlCopyMemory(
            pWhere,
            pDomainName->Buffer,
            pDomainName->Length
            );
        pWhere += ROUND_UP_COUNT(pDomainName->Length + sizeof(WCHAR), ALIGN_LPTSTR);

        pPassthroughRequest->PackageName = MsvPackageName;

        pPassthroughRequest->PackageName.Buffer = (PWSTR) pWhere;
        RtlCopyMemory(
            pWhere,
            MsvPackageName.Buffer,
            MsvPackageName.Length
            );
        pWhere += ROUND_UP_COUNT(MsvPackageName.Length + sizeof(WCHAR), ALIGN_LPTSTR);

        pPassthroughRequest->LogonData = pWhere;
        pPassthroughRequest->DataLength = ROUND_UP_COUNT(sizeof(MSV1_0_SUBAUTH_REQUEST), ALIGN_LPTSTR)
             + ROUND_UP_COUNT(wcslen(LogonInfo) * sizeof(WCHAR), ALIGN_LPTSTR);
        pSubAuthRequest = (MSV1_0_SUBAUTH_REQUEST*) pPassthroughRequest->LogonData;
        pSubAuthRequest->MessageType = MsV1_0SubAuth;

        pWhere = (UCHAR*) (pSubAuthRequest + 1);
        pSubAuthRequest->SubAuthPackageId = SubAuthId;
        pSubAuthRequest->SubAuthInfoLength = wcslen(LogonInfo) * sizeof(WCHAR);
        pSubAuthRequest->SubAuthSubmitBuffer = pWhere;

        RtlCopyMemory(
            pSubAuthRequest->SubAuthSubmitBuffer,
            LogonInfo,
            pSubAuthRequest->SubAuthInfoLength
            );

        pSubAuthRequest->SubAuthSubmitBuffer = (UCHAR*) (pWhere - (UCHAR*) pSubAuthRequest);

        SspiPrintHex(SSPI_LOG, TEXT("PassthroughRequest"), cbRequest, pPassthroughRequest);

        Status DBGCHK = LsaCallAuthenticationPackage(
            hLsa,
            PackageId,
            pPassthroughRequest,
            cbRequest,
            (PVOID *) &pPassthroughResponse,
            &cbResponse,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrintHex(SSPI_LOG, TEXT("ValidationData"), pPassthroughResponse->DataLength, pPassthroughResponse->ValidationData);
    }

    if (pPassthroughRequest)
    {
        delete [] pPassthroughRequest;
    }

    if (pPassthroughResponse)
    {
        LsaFreeReturnBuffer(pPassthroughResponse);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\logon\logon.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    logon.cxx

Abstract:

    logon

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "subauth.hxx"
#include "logon.hxx"

VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s [-p<package>] "
        "[-c<clientName>] [-C<clientRealm>] [-k<password>] [-n] "
        "[-t<logonType>] [-v<provider>] [-a<application>] "
        "[-i<processIdWhoseTokenIsUsedToImpersonate>] [-s<subAuthId>] "
        "[-l] [-2] [-f<flags>] [-g] [-o<processoptions>]\n"
        "Remarks: package default to NTLM, use -l to use LsaLogonUser, "
        "-2 to use NTLMv2, -n to use new subauthstyle -g use generic passthrough\n\n",
        pszApp);
    exit(-1);
}

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING Password = {0};
    UNICODE_STRING Application = {0};
    UNICODE_STRING Workstation = {0};
    DWORD dwLogonProvider = LOGON32_PROVIDER_DEFAULT;
    SECURITY_LOGON_TYPE LogonType = Interactive;

    BOOLEAN bUseLsaLogonUser = FALSE;
    PCSTR pszPackageName = NTLMSP_NAME_A;
    HANDLE hToken = NULL;
    BOOLEAN bUseNtlmv2 = FALSE;
    BOOLEAN bUseGenericPassThrough = FALSE;
    ULONG SubAuthId = 0;
    BOOLEAN bUseNewSubAuthStyle = FALSE;

    HANDLE hLsa = NULL;
    ULONG PackageId = 0;
    ULONG Flags = 0;
    ULONG ProcessOptions = 0;
    ULONG ProcessIdTokenUsedByClient = 0;

    TImpersonation* pImpersonation = NULL;
    HANDLE hImpToken = NULL;

    for (INT i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (argv[i][1])
            {
            case 'c':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ClientName);
                break;

            case 'C':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ClientRealm);
                break;

            case 'a':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Application);
                break;

            case 'g':
                bUseGenericPassThrough = TRUE;
                break;

            case 'k':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Password);
                break;

            case 'i':
                ProcessIdTokenUsedByClient = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'l':
                bUseLsaLogonUser = TRUE;
                break;

            case 't':
                LogonType = (SECURITY_LOGON_TYPE) strtol(argv[i] + 2, NULL, 0);
                break;

            case 'v':
                dwLogonProvider = (SECURITY_LOGON_TYPE) strtol(argv[i] + 2, NULL, 0);
                break;

            case 'f':
                Flags = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'o':
                ProcessOptions = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'p':
                pszPackageName = argv[i] + 2;
                break;

            case 's':
                SubAuthId = strtol(argv[i] + 2, NULL, 0);

                //
                // SubAuthId can not be zero
                //

                Status DBGCHK = SubAuthId ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
                break;

            case '2':
                bUseNtlmv2 = TRUE;
                break;

            case 'n':
                bUseNewSubAuthStyle = TRUE;
                break;

            case 'w':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Workstation);
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }
    
    if (NT_SUCCESS(Status) && ProcessIdTokenUsedByClient && (ProcessIdTokenUsedByClient != -1))
    {
        Status DBGCHK = GetProcessTokenByProcessId(ProcessIdTokenUsedByClient, &hImpToken);    
    }
    
    if (NT_SUCCESS(Status) && hImpToken)
    {
        pImpersonation = new TImpersonation(hImpToken);
    
        Status DBGCHK = pImpersonation ? pImpersonation->Validate() : E_OUTOFMEMORY;
    
        if (NT_SUCCESS(Status))
        {
            DebugPrintf(SSPI_LOG, "************** check client token data %p ******\n", hImpToken);

            Status DBGCHK = CheckUserData();
        }
    }

    if (NT_SUCCESS(Status) && ProcessOptions && (0 == _stricmp(NTLMSP_NAME_A, pszPackageName))) 
    {
        Status DBGCHK = GetLsaHandleAndPackageId(
                            pszPackageName,
                            &hLsa,
                            &PackageId
                            );

        if (NT_SUCCESS(Status)) 
        {
            Status DBGCHK = SetProcessOptions(hLsa, PackageId, ProcessOptions);
        }
    }

    if (NT_SUCCESS(Status) && (ClientName.Length || ClientRealm.Length || Password.Length))
    {
        if (!bUseLsaLogonUser)
        {
            Status DBGCHK = LogonUserWrapper(
                                ClientName.Buffer,
                                ClientRealm.Buffer,
                                Password.Buffer,
                                (DWORD) LogonType,
                                dwLogonProvider,
                                &hToken
                                );
        }
        else         
        {
            if (!hLsa) 
            {
                Status DBGCHK = GetLsaHandleAndPackageId(
                                    pszPackageName,
                                    &hLsa,
                                    &PackageId
                                    );
            }

            if (NT_SUCCESS(Status)) 
            {           
                if (0 == _stricmp(NTLMSP_NAME_A, pszPackageName))
                {
                    if (SubAuthId)
                    {
                        if (bUseGenericPassThrough)
                        {
                            Status DBGCHK = MsvSubAuthLogon(
                                                hLsa,
                                                PackageId,
                                                SubAuthId,
                                                &ClientName,
                                                &ClientRealm,
                                                &Password,
                                                &Workstation
                                                );
                        }
                        else
                        {
                            Status DBGCHK = MsvSubAuthLsaLogon(
                                                hLsa,
                                                PackageId,
                                                LogonType,
                                                SubAuthId,
                                                bUseNewSubAuthStyle,
                                                &ClientName,
                                                &ClientRealm,
                                                &Password,
                                                &Workstation,
                                                &hToken
                                                );
                        }
                    }
                    else
                    {
                        Status DBGCHK = MsvLsaLogonUser(
                                            hLsa,
                                            PackageId,
                                            LogonType,
                                            &ClientName,
                                            &ClientRealm,
                                            &Password,
                                            &Workstation,
                                            bUseNtlmv2 ? kNetworkLogonNtlmv2 : kNetworkLogonNtlmv1,
                                            &hToken
                                            );
                    }
                }
                else if (0 == _stricmp(MICROSOFT_KERBEROS_NAME_A, pszPackageName))
                {
                    Status DBGCHK = KrbLsaLogonUser(
                                        hLsa,
                                        PackageId,
                                        LogonType,
                                        &ClientName,
                                        &ClientRealm,
                                        &Password,
                                        Flags,
                                        &hToken
                                        );
                }
                else
                {
                    DebugPrintf(SSPI_WARN, "Using Msv wrapper for %s\n", pszPackageName);
                    Status DBGCHK = MsvLsaLogonUser(
                                        hLsa,
                                        PackageId,
                                        LogonType,
                                        &ClientName,
                                        &ClientRealm,
                                        &Password,
                                        &Workstation,
                                        bUseNtlmv2 ? kNetworkLogonNtlmv2 : kNetworkLogonNtlmv1,
                                        &hToken
                                        );
                }
            }
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = CheckUserToken(hToken);
        }
    }

    if (NT_SUCCESS(Status) && Application.Length && Application.Buffer && (hToken || hImpToken))
    {
        Status DBGCHK = StartInteractiveClientProcessAsUser(hToken ? hToken : hImpToken, Application.Buffer);
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "Operation succeeded\n");
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "Operation failed\n");
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (pImpersonation) 
    {
        delete pImpersonation;
    }

    RtlFreeUnicodeString(&ClientName);
    RtlFreeUnicodeString(&ClientRealm);
    RtlFreeUnicodeString(&Password);
    RtlFreeUnicodeString(&Workstation);
    RtlFreeUnicodeString(&Application);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\logonsess\logonsess.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    logonsess.cxx

Abstract:

    logonsess

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "logonsess.hxx"


VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s -l<LogonId.LowPart> -h<LogonId.HighPart>\n\n", pszApp);
    exit(-1);
}

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    HANDLE LogonHandle = NULL;
    ULONG PackageId = -1;

    LUID LogonId = {0};
    LUID* pLogonSessionList = &LogonId;
    ULONG cLogonSessionCount = 0;

    DebugLogOpen("logonsess.exe", SSPI_LOG | SSPI_WARN | SSPI_ERROR);

    for (INT i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (argv[i][1])
            {
            case 'l':
                cLogonSessionCount = 1;
                LogonId.LowPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'h':
                cLogonSessionCount = 1;
                LogonId.HighPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    if (cLogonSessionCount == 0)
    {
        Status DBGCHK = LsaEnumerateLogonSessions(&cLogonSessionCount, &pLogonSessionList);
    }

    for (UINT i = 0; (i < cLogonSessionCount) && NT_SUCCESS(Status); i++)
    {
        PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL;

        DebugPrintf(SSPI_LOG, "*********Getting Logonsession data for %#x:%#x**********\n", pLogonSessionList[i].HighPart, pLogonSessionList[i].LowPart);

        Status DBGCHK = LsaGetLogonSessionData(pLogonSessionList + i, &pLogonSessionData);
        if (NT_SUCCESS(Status))
        {
            DebugPrintLogonSessionData(SSPI_LOG, pLogonSessionData);
        }
        if (pLogonSessionData)
        {
            LsaFreeReturnBuffer(pLogonSessionData);
        }
    }

    if (pLogonSessionList != &LogonId)
    {
        LsaFreeReturnBuffer(pLogonSessionList);
    }

    DebugLogClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\msvlogon\msvlogon.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvlogon.cxx

Abstract:

    logon

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvlogon.hxx"

VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s [-p<ParameterControl>] -s<server> -S<server domain> "
        "-c<client name> -C<client realm> -k<password> -h<LogonId.highpart> -l<LognId.LowPart> "
        "-H<challeng HighPart> -L<challenge LowPart> -w<Workstation> -a<application>\n\n",
        pszApp);
    exit(-1);
}

NTSTATUS
GetMsvLogonInfo(
    IN HANDLE hLogonHandle,
    IN ULONG PackageId,
    IN LUID* pLogonId,
    IN ULONG ParameterControl,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pUserDomain,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pServerName,
    IN UNICODE_STRING* pServerDomain,
    IN UNICODE_STRING* pWorkstation,
    OUT ULONG* pcbLogonInfo,
    OUT MSV1_0_LM20_LOGON** ppLogonInfo
    )
{
    TNtStatus Status;
    NTSTATUS AuthPackageStatus = STATUS_UNSUCCESSFUL;

    MSV1_0_GETCHALLENRESP_REQUEST* pRequest = NULL;
    MSV1_0_GETCHALLENRESP_RESPONSE* pResponse = NULL;
    ULONG cbResponse = 0;
    ULONG cbRequest = 0;
    WCHAR* pWhere = NULL;
    UNICODE_STRING NtlmServerName = {0};
    ULONG cbLogonInfo = 0;
    MSV1_0_LM20_LOGON* pLogonInfo = NULL;

    NtlmServerName.Length = (pServerDomain->Length ? pServerDomain->Length + sizeof(WCHAR) : 0)
        + pServerName->Length;
    NtlmServerName.MaximumLength = NtlmServerName.Length + sizeof(WCHAR);

    NtlmServerName.Buffer = (PWSTR) new CHAR[NtlmServerName.MaximumLength];

    Status DBGCHK = NtlmServerName.Buffer ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(NtlmServerName.Buffer, NtlmServerName.MaximumLength);

        if (pServerDomain->Length)
        {
            RtlCopyMemory(NtlmServerName.Buffer, pServerDomain->Buffer, pServerDomain->Length);
            RtlCopyMemory(NtlmServerName.Buffer + (pServerDomain->Length / sizeof(WCHAR)) + 1,
                pServerName->Buffer, pServerName->Length);
        }
        else
        {
            RtlCopyMemory(NtlmServerName.Buffer, pServerName->Buffer, pServerName->Length);
        }

        cbRequest = ROUND_UP_COUNT(sizeof(MSV1_0_GETCHALLENRESP_REQUEST), sizeof(ULONG_PTR))
            + pUserName->Length + sizeof(WCHAR)
            + pUserDomain->Length + sizeof(WCHAR)
            + NtlmServerName.Length + sizeof(WCHAR)
            + pPassword->Length + sizeof(WCHAR);

        pRequest = (MSV1_0_GETCHALLENRESP_REQUEST*) new CHAR[cbRequest];

        Status DBGCHK = pRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pRequest, cbRequest);

        pWhere = (WCHAR*) (pRequest + 1);

        pRequest->MessageType = MsV1_0Lm20GetChallengeResponse;
        pRequest->ParameterControl = ParameterControl;
        pRequest->LogonId = *pLogonId;
        RtlCopyMemory(pRequest->ChallengeToClient, ChallengeToClient, MSV1_0_CHALLENGE_LENGTH);

        PackUnicodeStringAsUnicodeStringZ(pUserName, &pWhere, &pRequest->UserName);
        PackUnicodeStringAsUnicodeStringZ(pUserDomain, &pWhere, &pRequest->LogonDomainName);
        PackUnicodeStringAsUnicodeStringZ(&NtlmServerName, &pWhere, &pRequest->ServerName);
        PackUnicodeStringAsUnicodeStringZ(pPassword, &pWhere, &pRequest->Password);

        DebugPrintf(SSPI_LOG, "MsvLsaLogonUser PackageId %#x, "
            "UserName %wZ, DomainName %wZ, Password %wZ, "
            "ParameterControl %#x, LogonId %#x:%#x\n",
            PackageId, &pRequest->UserName, &pRequest->LogonDomainName, &pRequest->Password,
            pRequest->ParameterControl, pRequest->LogonId.HighPart,
            pRequest->LogonId.LowPart);

        DebugPrintHex(SSPI_LOG, "pRequest->ServerName:", pRequest->ServerName.MaximumLength, pRequest->ServerName.Buffer);
        DebugPrintHex(SSPI_LOG, "ChallengeToClient:", MSV1_0_CHALLENGE_LENGTH, pRequest->ChallengeToClient);

        Status DBGCHK = LsaCallAuthenticationPackage(
            hLogonHandle,
            PackageId,
            pRequest,
            cbRequest,
            (VOID**) &pResponse,
            &cbResponse,
            &AuthPackageStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = AuthPackageStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "GetMsvLogonInfo response LogonDomain %wZ, UserName %wZ\n",
            pResponse->LogonDomainName, pResponse->UserName);

        DebugPrintHex(SSPI_LOG, "CaseSensitiveChallengeResponse:",
            pResponse->CaseSensitiveChallengeResponse.Length,
            pResponse->CaseSensitiveChallengeResponse.Buffer);

        DebugPrintHex(SSPI_LOG, "CaseInsensitiveChallengeResponse:",
            pResponse->CaseInsensitiveChallengeResponse.Length,
            pResponse->CaseInsensitiveChallengeResponse.Buffer);

        DebugPrintHex(SSPI_LOG, "UserSessionKey:", MSV1_0_USER_SESSION_KEY_LENGTH, pResponse->UserSessionKey);
        DebugPrintHex(SSPI_LOG, "LanmanSessionKey:", MSV1_0_USER_SESSION_KEY_LENGTH, pResponse->LanmanSessionKey);

        cbLogonInfo = ROUND_UP_COUNT(sizeof(MSV1_0_LM20_LOGON), sizeof(ULONG_PTR))
            + pUserDomain->Length + sizeof(WCHAR)
            + pWorkstation->Length + sizeof(WCHAR)
            + pUserName->Length + sizeof(WCHAR)
            + pResponse->CaseSensitiveChallengeResponse.Length + sizeof(WCHAR)
            + pResponse->CaseInsensitiveChallengeResponse.Length + sizeof(WCHAR);

        pLogonInfo = (MSV1_0_LM20_LOGON*) new CHAR[cbLogonInfo];

        Status DBGCHK = pLogonInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pLogonInfo, cbLogonInfo);

        pLogonInfo->MessageType = MsV1_0NetworkLogon;

        pLogonInfo->ParameterControl = ParameterControl;
        RtlCopyMemory(pLogonInfo->ChallengeToClient, ChallengeToClient, MSV1_0_CHALLENGE_LENGTH);

        pWhere = (PWSTR) (pLogonInfo + 1);

        PackUnicodeStringAsUnicodeStringZ(pUserDomain, &pWhere, &pLogonInfo->LogonDomainName);
        PackUnicodeStringAsUnicodeStringZ(pUserName, &pWhere, &pLogonInfo->UserName);
        PackUnicodeStringAsUnicodeStringZ(pWorkstation, &pWhere, &pLogonInfo->Workstation);

        PackString(
            &pResponse->CaseSensitiveChallengeResponse,
            (CHAR**) &pWhere,
            &pLogonInfo->CaseSensitiveChallengeResponse
            );
        PackString(
            &pResponse->CaseSensitiveChallengeResponse,
            (CHAR**) &pWhere,
            &pLogonInfo->CaseSensitiveChallengeResponse
            );

        DebugPrintf(SSPI_LOG, "pLogonInfo ParameterControl %#x, LogonDomain %wZ, UserName %wZ, Workstation %wZ\n",
            pLogonInfo->ParameterControl,
            &pLogonInfo->LogonDomainName,
            &pLogonInfo->UserName,
            &pLogonInfo->Workstation);
        DebugPrintHex(SSPI_LOG, "ChallengeToClient:", MSV1_0_CHALLENGE_LENGTH, pLogonInfo->ChallengeToClient);

        DebugPrintHex(SSPI_LOG, "CaseSensitiveChallengeResponse:",
            pLogonInfo->CaseSensitiveChallengeResponse.Length,
            pLogonInfo->CaseSensitiveChallengeResponse.Buffer);

        DebugPrintHex(SSPI_LOG, "CaseInsensitiveChallengeResponse:",
            pLogonInfo->CaseInsensitiveChallengeResponse.Length,
            pLogonInfo->CaseInsensitiveChallengeResponse.Buffer);

        *ppLogonInfo = pLogonInfo;
        pLogonInfo = NULL;
        *pcbLogonInfo = cbLogonInfo;
    }

    if (pRequest)
    {
        delete [] pRequest;
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    if (pResponse)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    return Status;
}

NTSTATUS
MsvLsaLogon(
    IN HANDLE hLogonHandle,
    IN ULONG PackageId,
    IN LUID* pLogonId,
    IN ULONG ParameterControl,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pUserDomain,
    IN UNICODE_STRING* pPassword,
    IN UNICODE_STRING* pServerName,
    IN UNICODE_STRING* pServerDomain,
    IN UNICODE_STRING* pWorkstation,
    OUT HANDLE* pTokenHandle
    )
{
    TNtStatus Status;
    NTSTATUS SubStatus = STATUS_UNSUCCESSFUL;

    MSV1_0_LM20_LOGON* pLogonInfo = NULL;
    ULONG cbLogonInfoSize = 0;
    LSA_STRING Name = {0};

    TOKEN_SOURCE SourceContext = {0};
    VOID* pProfile = NULL;
    ULONG cbProfileSize = 0;
    LUID LogonId = {0};
    QUOTA_LIMITS Quotas = {0};


    Status DBGCHK = GetMsvLogonInfo(
        hLogonHandle,
        PackageId,
        pLogonId,
        ParameterControl,
        ChallengeToClient,
        pUserName,
        pUserDomain,
        pPassword,
        pServerName,
        pServerDomain,
        pWorkstation,
        &cbLogonInfoSize,
        &pLogonInfo
        );

    if (NT_SUCCESS(Status))
    {
        strncpy(
            SourceContext.SourceName,
            "ssptest",
            sizeof(SourceContext.SourceName)
            );
        NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

        //
        // Now call LsaLogonUser
        //

        RtlInitString(
            &Name,
            "ssptest"
            );

        Status DBGCHK = LsaLogonUser(
            hLogonHandle,
            &Name,
            Network,
            PackageId,
            pLogonInfo,
            cbLogonInfoSize,
            NULL, // no token groups
            &SourceContext,
            (VOID**) &pProfile,
            &cbProfileSize,
            &LogonId,
            pTokenHandle,
            &Quotas,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", LogonId.HighPart, LogonId.LowPart);
        DebugPrintf(SSPI_LOG, "TokenHandle %p\n", *pTokenHandle);
        DebugPrintProfileAndQuotas(SSPI_LOG, pProfile, &Quotas);
    }

    if (pProfile)
    {
        LsaFreeReturnBuffer(pProfile);
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    UNICODE_STRING UserName = {0};
    UNICODE_STRING UserDomain = {0};
    UNICODE_STRING Password = {0};
    UNICODE_STRING Application = {0};
    UNICODE_STRING ServerName = {0};
    UNICODE_STRING ServerDomain = {0};
    UNICODE_STRING Workstation = {0};
    ULONG ParameterControl = 0;
    LUID LogonId = {0};
    LUID ChallengeToClient = {0};

    C_ASSERT(MSV1_0_CHALLENGE_LENGTH == sizeof(LUID));

    HANDLE hToken = NULL;

    HANDLE hLogonHandle = NULL;
    ULONG PackageId = 0;

    RtlGenRandom(&ChallengeToClient, sizeof(ChallengeToClient));

    for (INT i = 1; NT_SUCCESS(Status) && (i < argc); i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (argv[i][1])
            {
            case 'c':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &UserName);
                break;

            case 'C':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &UserDomain);
                break;

            case 'a':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Application);
                break;

            case 'k':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Password);
                break;

            case 'p':
                ParameterControl = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'h':
                LogonId.HighPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'l':
                 LogonId.LowPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'H':
                ChallengeToClient.HighPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case 'L':
                ChallengeToClient.LowPart = strtol(argv[i] + 2, NULL, 0);
                break;

            case 's':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ServerName);
                break;

            case 'S':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &ServerDomain);
                break;

            case 'w':
                Status DBGCHK = CreateUnicodeStringFromAsciiz(argv[i] + 2, &Workstation);
                break;

            case '?':
            default:
                Usage(argv[0]);
                break;
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    DebugLogOpen(NULL, SSPI_LOG | SSPI_WARN | SSPI_ERROR);

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetLsaHandleAndPackageId(
            NTLMSP_NAME_A,
            &hLogonHandle,
            &PackageId
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = MsvLsaLogon(
            hLogonHandle,
            PackageId,
            &LogonId,
            ParameterControl,
            (UCHAR*) &ChallengeToClient,
            &UserName,
            &UserDomain,
            &Password,
            &ServerName,
            &ServerDomain,
            &Workstation,
            &hToken
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = CheckUserToken(hToken);
    }

    if (NT_SUCCESS(Status) && Application.Length && Application.Buffer)
    {
        Status DBGCHK = StartInteractiveClientProcessAsUser(hToken, Application.Buffer);
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "Operation succeeded\n");
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "Operation failed\n");
    }

    if (hLogonHandle)
    {
        LsaDeregisterLogonProcess(hLogonHandle);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    RtlFreeUnicodeString(&UserName);
    RtlFreeUnicodeString(&UserDomain);
    RtlFreeUnicodeString(&Password);
    RtlFreeUnicodeString(&ServerName);
    RtlFreeUnicodeString(&ServerDomain);
    RtlFreeUnicodeString(&Application);
    RtlFreeUnicodeString(&Workstation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\msvsharelevel\main.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    main

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "main.hxx"
#include "msvsharelevelcli.hxx"
#include "msvsharelevelsrv.hxx"

#include <sockcomm.h>
#include <transport.hxx>

VOID
Usage(
    IN PCTSTR pszApp
    )
{
    SspiPrint(SSPI_ERROR,
        TEXT("\n\nUsage: %s [-srvcomputerdomainname srvcomputerdomainname>] ")
        TEXT("[-supplieduser <user>] [-supplieddomain <domain>] [-suppliedpassword <password>] ")
        TEXT("[-serverhostname <serverhostname>] [-portnum <portnum>] [-nocheckclictxt] [-nochecksrvctxt] \n\n"), pszApp);
    exit(-1);
}

VOID
checkpoint(
    VOID
    )
{
    SspiPrint(SSPI_LOG, TEXT("checkpoint\n"));
    ASSERT(FALSE);
}

struct TClientParameter {
    AUTHENTICATE_MESSAGE* pAuthMessage;
    ULONG cbAuthMessage;
    NTLM_AUTHENTICATE_MESSAGE* pNtlmAuthMessage;
    PCSTR pszServer;
    USHORT ServerSocketPort;
};

DWORD WINAPI
ClientThread(
  IN PVOID pParameter   // thread data
  )
{
    THResult hRetval = S_OK;

    TClientParameter *pCliParam = (TClientParameter* ) pParameter;
    SOCKET ClientSocket = INVALID_SOCKET;
    ULONG MessageNum = 0;

    SspiPrint(SSPI_LOG, TEXT("ClientThread entering %#x\n"), g_MessageNumTlsIndex);

    hRetval DBGCHK = TlsSetValue(g_MessageNumTlsIndex, &MessageNum) ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ClientConnect(
            pCliParam->pszServer,
            pCliParam->ServerSocketPort,
            &ClientSocket
            );
    }

    if (SUCCEEDED(hRetval))
    {
         hRetval DBGCHK = WriteMessage(
             ClientSocket,
             pCliParam->cbAuthMessage,
             pCliParam->pAuthMessage
             );
    }

    if (SUCCEEDED(hRetval))
    {
         hRetval DBGCHK = WriteMessage(
             ClientSocket,
             sizeof(NTLM_AUTHENTICATE_MESSAGE),
             pCliParam->pNtlmAuthMessage
             );
    }

    if (INVALID_SOCKET != ClientSocket)
    {
        closesocket(ClientSocket);
    }

    SspiPrint(SSPI_LOG, TEXT("ClientThread leaving\n"));

    return hRetval;
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    ULONG mark = 1;
    CtxtHandle hCliCtxt;
    CtxtHandle hSrvCtxt;
    HANDLE hToken = NULL;
    SOCKET SocketListen = INVALID_SOCKET;
    SOCKET ServerSocket = INVALID_SOCKET;
    HANDLE hClientThread = NULL;

    SEC_WINNT_AUTH_IDENTITY SrvAuthData = {0};
    SEC_WINNT_AUTH_IDENTITY* pSrvAuth = NULL;
    SEC_WINNT_AUTH_IDENTITY_EXW* pCliAuth = NULL;
    UNICODE_STRING TargetInfo = {0};
    UNICODE_STRING TargetName = {0};
    AUTHENTICATE_MESSAGE* pAuthMessage = NULL;
    ULONG cbAuthMessage = 0;
    TClientParameter CliParam = {0};
    ULONG ClientThreadId = 0;
    ULONG MessageNum = 0;

    NTLM_AUTHENTICATE_MESSAGE NtlmAuthMessage = {0};

    UNICODE_STRING SrvDnsDomainName = {0};
    UNICODE_STRING SrvDnsComputerName = {0};
    UNICODE_STRING SrvDnsTreeName = {0};
    UNICODE_STRING SrvComputerName = {0};
    UNICODE_STRING SrvComputerDomainName = {0};

    PCTSTR pszClientName = NULL;
    PCTSTR pszClientDomain = NULL;
    PCTSTR pszClientPassword = NULL;
    PCTSTR pszServerName = NULL;
    PCTSTR pszServerDomain = NULL;
    PCTSTR pszServerPassword = NULL;

    PTSTR pszSrvCredPrincipal = NULL;
    PTSTR pszCliCredPrincipal = NULL;

    UNICODE_STRING UserName = {0};
    UNICODE_STRING Password = {0};
    UNICODE_STRING DomainName = {0};

    OEM_STRING CliOemDomainName = {0};
    OEM_STRING CliOemWorkstationName = {0};

    ULONG CliNegotiateFlags =
        NTLMSSP_NEGOTIATE_UNICODE
        | NTLMSSP_NEGOTIATE_OEM
        | NTLMSSP_REQUEST_TARGET
        | NTLMSSP_NEGOTIATE_NTLM
        | NTLMSSP_NEGOTIATE_ALWAYS_SIGN
        | NTLMSSP_NEGOTIATE_NTLM2
        | NTLMSSP_NEGOTIATE_IDENTIFY
        | NTLMSSP_NEGOTIATE_128;

    ULONG CliTargetFlags = NTLMSSP_TARGET_TYPE_SERVER; // NTLMSSP_TARGET_TYPE_DOMAIN
    BOOLEAN bCliForceGuest = FALSE;
    ULONG CliContextAttr = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY;
    ULONG SrvContextAttr = ASC_REQ_EXTENDED_ERROR;

    LUID* pCliCredLogonID = NULL;
    LUID CliCredLogonId = {0};
    LUID* pSrvCredLogonID = NULL;
    LUID SrvCredLogonId = {0};

    ULONG CliTargetDataRep = SECURITY_NATIVE_DREP;
    ULONG SrvTargetDataRep = SECURITY_NATIVE_DREP;
    BOOLEAN bCheckClientCtxt = TRUE;
    BOOLEAN bCheckServerCtxt = TRUE;
    BOOLEAN bServerCheckUserData = FALSE;
    BOOLEAN bServerCheckUserToken = FALSE;

    BOOLEAN bStartServer = TRUE;
    BOOLEAN bStartClient = TRUE;
    USHORT PortNum = 6217;
    PSTR pszServerHostName = NULL;
    UNICODE_STRING ServerHostName = {0};
    ANSI_STRING ServerAnsiName = {0};
    TPrivilege* pPriv = NULL;

    SspiLogOpen(TEXT("msv.exe"), SSPI_LOG | SSPI_WARN | SSPI_ERROR | SSPI_MSG);
    DebugLogOpen("msv", SSPI_LOG | SSPI_WARN | SSPI_ERROR | SSPI_MSG);

    SecInvalidateHandle(&hCliCtxt);
    SecInvalidateHandle(&hSrvCtxt);

    (VOID) RtlGenRandom(NtlmAuthMessage.ChallengeToClient, MSV1_0_CHALLENGE_LENGTH);

    argc--;

    while (argc)
    {
        if (!lstrcmp(argv[mark], TEXT("-srvcomputerdomainname")) && argc > 1)
        {
            argc--; mark++;
            RtlInitUnicodeString(&SrvComputerDomainName, argv[mark]);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-supplieduser")) && argc > 1)
        {
            argc--; mark++;
            RtlInitUnicodeString(&UserName, argv[mark]);
            pszClientName = UserName.Buffer;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-supplieddomain")) && argc > 1)
        {
            argc--; mark++;
            RtlInitUnicodeString(&DomainName, argv[mark]);
            pszClientDomain = DomainName.Buffer;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-suppliedpassword")) && argc > 1)
        {
            argc--; mark++;
            RtlInitUnicodeString(&Password, argv[mark]);
            pszClientPassword = Password.Buffer;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-serverhostname")) && argc > 1)
        {
            argc--; mark++;
            RtlInitUnicodeString(&ServerHostName, argv[mark]);
            Status DBGCHK = RtlUnicodeStringToAnsiString(&ServerAnsiName, &ServerHostName, TRUE);
            bStartServer = FALSE;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-portnum")) && argc > 1)
        {
            argc--; mark++;
            PortNum = (USHORT) lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-noserver")))
        {
            argc--; mark++;
            bStartServer = FALSE;
        }
        else if (!lstrcmp(argv[mark], TEXT("-noclient")))
        {
            argc--; mark++;
            bStartClient = FALSE;
        }
        else if (!lstrcmp(argv[mark], TEXT("-nocheckclictxt")))
        {
            argc--; mark++;
            bCheckClientCtxt = FALSE;
        }
        else if (!lstrcmp(argv[mark], TEXT("-nochecksrvctxt")))
        {
            argc--; mark++;
            bCheckServerCtxt = FALSE;
        }
        else if (!lstrcmp(argv[mark], TEXT("-h")))
        {
            argc--; mark++;
            Usage(argv[0]);
        }
        else
        {
            Usage(argv[0]);
        }
    }

    SOCKET Socket = INVALID_SOCKET;
    Status DBGCHK = InitWinsock() ? S_OK : GetLastErrorAsHResult();

    if (NT_SUCCESS(Status) && (TLS_OUT_OF_INDEXES == g_MessageNumTlsIndex))
    {
        g_MessageNumTlsIndex = TlsAlloc();
        Status DBGCHK = (TLS_OUT_OF_INDEXES != g_MessageNumTlsIndex) ? S_OK : GetLastErrorAsHResult();
    }

    if (NT_SUCCESS(Status) && bStartServer)
    {
        Status DBGCHK = ServerInit(PortNum, "msvsharelevel server", &SocketListen);
        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = TlsSetValue(g_MessageNumTlsIndex, &MessageNum) ? S_OK : GetLastErrorAsHResult();
        }

        //
        // server must hold TCB
        //

        if (NT_SUCCESS(Status))
        {
            pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
            Status DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;
        }
    }

    if (NT_SUCCESS(Status) && bStartClient)
    {
        if (pszClientName || pszClientDomain || pszClientPassword)
        {
            Status DBGCHK = GetAuthdataExWMarshalled(
                pszClientName,
                pszClientDomain,
                pszClientPassword,
                L"ntlm",
                &pCliAuth
                );
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = MsvChallenge(
                pszCliCredPrincipal,
                pCliCredLogonID,
                pCliAuth,
                &CliOemDomainName,
                &CliOemWorkstationName,
                CliNegotiateFlags,
                CliTargetFlags,
                bCliForceGuest,
                CliContextAttr,
                CliTargetDataRep,
                &Password,
                &UserName,
                &DomainName,
                (UCHAR*) NtlmAuthMessage.ChallengeToClient,
                &SrvDnsDomainName,
                &SrvDnsComputerName,
                &SrvDnsTreeName,
                &SrvComputerName,
                &SrvComputerDomainName,
                &cbAuthMessage,
                &pAuthMessage,
                &hCliCtxt,
                &CliContextAttr
                );
        }

        if (NT_SUCCESS(Status) && bCheckClientCtxt)
        {
            SspiPrint(SSPI_LOG, TEXT("***************Checking client ctxt handle*************\n"));
            Status DBGCHK = CheckSecurityContextHandle(&hCliCtxt);
        }

        if (NT_SUCCESS(Status))
        {
            CliParam.cbAuthMessage = cbAuthMessage;
            CliParam.pAuthMessage = pAuthMessage;
            CliParam.pNtlmAuthMessage = &NtlmAuthMessage;
            CliParam.pszServer = ServerAnsiName.Buffer;
            CliParam.ServerSocketPort = PortNum;

            hClientThread = CreateThread(
                NULL,  // no SD
                0,     // user default stack size
                ClientThread,
                &CliParam,  // thread parameter
                0,    // no creation flags
                &ClientThreadId
                );
            Status DBGCHK = hClientThread ? S_OK : GetLastErrorAsHResult();
        }
    }

    //
    // server must hold TCB for sharelevels
    //

    if (NT_SUCCESS(Status) && bStartServer)
    {
        BOOLEAN WasEnabled = FALSE;
        ULONG cbAuthMsg = 0;
        CHAR AuthMsg[NTLMSSP_MAX_MESSAGE_SIZE] = {0};
        NTLM_AUTHENTICATE_MESSAGE NtLmAuthMsg = {0};
        AUTHENTICATE_MESSAGE* pAuthMsg = (AUTHENTICATE_MESSAGE*) AuthMsg;

        ServerSocket = accept(SocketListen, NULL, NULL);
        Status DBGCHK = INVALID_SOCKET != ServerSocket ? S_OK : GetLastErrorAsHResult();

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = ReadMessage(
                ServerSocket,
                NTLMSSP_MAX_MESSAGE_SIZE,
                AuthMsg,
                &cbAuthMsg
                );
        }

        if (NT_SUCCESS(Status))
        {
            ULONG cbRead = 0;

            Status DBGCHK = ReadMessage(
                ServerSocket,
                sizeof(NtLmAuthMsg),
                &NtLmAuthMsg,
                &cbRead
                );
        }

        if (NT_SUCCESS(Status) && (pszServerName || pszServerDomain || pszServerPassword))
        {
            pSrvAuth = &SrvAuthData;
            GetAuthdata(
                pszServerName,
                pszServerDomain,
                pszServerPassword,
                &SrvAuthData
                );
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = MsvAuthenticate(
                pszSrvCredPrincipal,
                pSrvCredLogonID,
                pSrvAuth,
                SrvContextAttr,
                SrvTargetDataRep,
                cbAuthMsg,
                pAuthMsg,
                &NtLmAuthMsg,
                &hSrvCtxt,
                &SrvContextAttr
                );
        }

        if (NT_SUCCESS(Status) && bCheckServerCtxt)
        {
            SspiPrint(SSPI_LOG, TEXT("***************Checking server ctxt handle*************\n"));
            Status DBGCHK = CheckSecurityContextHandle(&hSrvCtxt);
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = ImpersonateSecurityContext(&hSrvCtxt);
        }

        if (NT_SUCCESS(Status) && bServerCheckUserData)
        {
            SspiPrint(SSPI_LOG, TEXT("**************Server checking user data via ImpersonateSecurityContext ******\n"));
            Status DBGCHK = CheckUserData();
        }

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = RevertSecurityContext(&hSrvCtxt);
        }

        if (NT_SUCCESS(Status) && bServerCheckUserToken)
        {
            Status DBGCHK = QuerySecurityContextToken(&hSrvCtxt, &hToken);
        }

        if (NT_SUCCESS(Status) && bServerCheckUserToken)
        {
            SspiPrint(SSPI_LOG, TEXT("**************Server checking user data via QuerySecurityContextToken ******\n"));
            Status DBGCHK = CheckUserToken(hToken);
        }
    }

    if (NT_SUCCESS(Status) && hClientThread)
    {
        Status DBGCHK = HResultFromWin32(WaitForSingleObject(hClientThread, INFINITE));
    }

    if (pPriv)
    {
        delete pPriv;
    }

    if (pCliAuth)
    {
        delete [] pCliAuth;
    }

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("Operation succeeded\n"));
    }
    else
    {
        SspiPrint(SSPI_ERROR, TEXT("Operation failed\n"));
    }

    TermWinsock();

    if (pAuthMessage)
    {
        FreeContextBuffer(pAuthMessage);
    }

    if (SecIsValidHandle(&hCliCtxt))
    {
        DeleteSecurityContext(&hCliCtxt);
    }

    if (SecIsValidHandle(&hSrvCtxt))
    {
        DeleteSecurityContext(&hSrvCtxt);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (TLS_OUT_OF_INDEXES != g_MessageNumTlsIndex)
    {
        TlsFree(g_MessageNumTlsIndex);
        g_MessageNumTlsIndex = TLS_OUT_OF_INDEXES;
    }

    if (hClientThread)
    {
        CloseHandle(hClientThread);
    }

    if (INVALID_SOCKET != SocketListen)
    {
        closesocket(SocketListen);
    }

    if (INVALID_SOCKET != ServerSocket)
    {
        closesocket(ServerSocket);
    }

    DebugLogClose();
    SspiLogClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\msvsharelevel\msvsharelevelsrv.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvsharelevelsrv.cxx

Abstract:

    msvsharelevel server

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvsharelevelsrv.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\msvsharelevel\msvsharelevelcli.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvsharelevelcli.cxx

Abstract:

    msvsharelevel client

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvsharelevelcli.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\namedpipes\namedpipes.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    namedpipes.cxx

Abstract:

    namedpipes

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "namedpipes.hxx"

PCTSTR g_pszPipeName = TEXT("pipetest");


HRESULT
GetClientImpToken(
    IN ULONG ProcessId,
    IN OPTIONAL PCWSTR pszS4uClientUpn,
    IN OPTIONAL PCWSTR pszS4uClientRealm,
    IN ULONG S4u2SelfFlags,
    OUT HANDLE* phToken
    )
{
    THResult hRetval = S_OK;

    UNICODE_STRING ClientUpn = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING Password = {0}; // ignored
    ULONG PackageId = 0;
    HANDLE hLsa = NULL;
    HANDLE hImpToken = NULL;

    TPrivilege* pPriv = NULL;

    *phToken = NULL;

    if (ProcessId)
    {
        hRetval DBGCHK = GetProcessTokenByProcessId(ProcessId, &hImpToken);
    }
    else if (pszS4uClientRealm || pszS4uClientUpn)
    {
        RtlInitUnicodeString(&ClientRealm, pszS4uClientRealm);
        RtlInitUnicodeString(&ClientUpn, pszS4uClientUpn);

        pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
        hRetval DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = GetLsaHandleAndPackageId(
                                MICROSOFT_KERBEROS_NAME_A,
                                &hLsa,
                                &PackageId
                                );
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = KrbLsaLogonUser(
                                hLsa,
                                PackageId,
                                Network,       // this would cause S4u2self to be used
                                &ClientUpn,
                                &ClientRealm,
                                &Password,     // ignored for s4u2self
                                S4u2SelfFlags, // Flags for s4u2self
                                &hImpToken
                                );
        }
    }

    if (SUCCEEDED(hRetval))
    {
        *phToken = hImpToken;
        hImpToken = NULL;
    }

    if (hImpToken)
    {
        CloseHandle(hImpToken);
    }

    if (pPriv)
    {
        delete pPriv;
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }

    return hRetval;
}

DWORD WINAPI ClientThread(IN PVOID pvParam)
{
    THResult hRetval = S_OK;

    CHAR Request[MAX_PATH] = {0};
    CHAR Reply[MAX_PATH] = {0};
    ULONG cbRead = 0;
    ULONG cbWritten = 0;
    HANDLE hToken = NULL;
    TImpersonation* pImper = NULL;
    HANDLE hPipe = INVALID_HANDLE_VALUE;
    SECURITY_ATTRIBUTES sa = {0};

    TClientThreadParam* pClientParam = (TClientThreadParam *) pvParam;

    SspiPrint(SSPI_LOG, TEXT("ClientThread entering processid %#x, pszPipeName %s, pszS4uClientRealm %s, pszS4uClientUpn %s, S4u2SelfFlags %#x, FlagsAndAttributes %#x\n"),
        pClientParam->ProcessId, pClientParam->pszPipeName, pClientParam->pszS4uClientRealm, pClientParam->pszS4uClientUpn, pClientParam->S4u2SelfFlags, pClientParam->FlagsAndAttributes);

    memset(Request, 0xef, sizeof(Request) - 1);

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL; // default Dacl of caller
    sa.bInheritHandle = TRUE;

    hRetval DBGCHK = GetClientImpToken(
                        pClientParam->ProcessId,
                        pClientParam->pszS4uClientUpn,
                        pClientParam->pszS4uClientRealm,
                        pClientParam->S4u2SelfFlags,
                        &hToken
                        );

    if (SUCCEEDED(hRetval) && hToken)
    {
        pImper = new TImpersonation(hToken);
        hRetval DBGCHK = pImper ? pImper->Validate() : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        SspiPrint(SSPI_LOG, TEXT("ClientPipeName %s\n"), pClientParam->pszPipeName);

        hRetval DBGCHK = WaitNamedPipe(
                            pClientParam->pszPipeName,
                            60000
                            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hPipe = CreateFile(
                    pClientParam->pszPipeName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                    &sa,
                    OPEN_EXISTING,
                    pClientParam->FlagsAndAttributes ? pClientParam->FlagsAndAttributes : (SECURITY_SQOS_PRESENT | SECURITY_IMPERSONATION),
                    NULL
                    );
        hRetval DBGCHK = (INVALID_HANDLE_VALUE != hPipe) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = WriteFile(
                            hPipe,               // handle to pipe
                            Request,             // buffer to write from
                            sizeof(Request) - 1, // number of bytes to write
                            &cbWritten,          // number of bytes written
                            NULL                 // not overlapped I/O
                            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReadFile(
                            hPipe,             // handle to pipe
                            Reply,             // buffer to receive data
                            sizeof(Reply),     // size of buffer
                            &cbRead,           // number of bytes read
                            NULL               // not overlapped I/O
                            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        SspiPrintHex(SSPI_LOG, TEXT("Reply"), cbRead, Reply);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (hPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPipe);
    }

    if (pImper)
    {
        delete pImper;
    }

    SspiPrint(SSPI_LOG, TEXT("ClientThread leaving %#x\n"), (HRESULT) hRetval);

    return (HRESULT) hRetval;
}

DWORD WINAPI ServerWokerThread(IN PVOID pvParam)
{
    THResult hRetval = S_OK;

    CHAR Request[MAX_PATH] = {0};
    CHAR Reply[MAX_PATH] = {0};
    ULONG cbBytesRead = 0;
    ULONG cbWritten = 0;
    HANDLE hToken = NULL;

    TServerWorkerThreadParam* pServerParam = (TServerWorkerThreadParam*) pvParam;

    SspiPrint(SSPI_LOG, TEXT("ServerWokerThread entering ServerPipe is %p, pszCommandLine %s\n"), pServerParam->hPipe, pServerParam->pszCommandLine);

    memset(Reply, 0xfe, sizeof(Reply) - 1);

    hRetval DBGCHK = ImpersonateNamedPipeClient(pServerParam->hPipe) ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReadFile(
                            pServerParam->hPipe, // handle to pipe
                            Request,             // buffer to receive data
                            sizeof(Request),     // size of buffer
                            &cbBytesRead,        // number of bytes read
                            NULL                 // not overlapped I/O
                            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        SspiPrintHex(SSPI_LOG, TEXT("Request"), cbBytesRead, Request);

        hRetval DBGCHK = WriteFile(
                            pServerParam->hPipe,             // handle to pipe
                            Reply,             // buffer to write from
                            sizeof(Reply) - 1, // number of bytes to write
                            &cbWritten,        // number of bytes written
                            NULL               // not overlapped I/O
                            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval) && pServerParam->pszCommandLine)
    {
        hRetval DBGCHK = OpenThreadToken(
                            GetCurrentThread(),
                            MAXIMUM_ALLOWED,
                            TRUE,
                            &hToken
                            ) ? S_OK : GetLastErrorAsHResult();
                
        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = StartInteractiveClientProcessAsUser(
                                hToken,
                                pServerParam->pszCommandLine
                                );
        }
    }

    RevertToSelf();

    if (hToken)
    {
        CloseHandle(hToken);
    }

    FlushFileBuffers(pServerParam->hPipe);
    DisconnectNamedPipe(pServerParam->hPipe);
    CloseHandle(pServerParam->hPipe);
    pServerParam->hPipe = INVALID_HANDLE_VALUE;

    SspiPrint(SSPI_LOG, TEXT("ServerWokerThread leaving %#x\n"), (HRESULT) hRetval);

    return (HRESULT) hRetval;
}

VOID
Usage(
    IN PCTSTR pszProgram
    )
{
    SspiPrint(SSPI_ERROR,
        TEXT("Usage: %s [-noclient] [-noserver] [-pipename <pipename>] [-application <application>]\n")
        TEXT("[-s4uclientupn <clientupn>] [-s4uclientrealm <clientrealm>] [-s4u2selfflags <flags>]\n")
        TEXT("[-clientprocessidtoimperonate <processid>] [-clientflagsandattributes <flagsandattributes>]\n"), pszProgram);
    exit(-1);
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    THResult hRetval = S_OK;

    INT mark = 1;

    BOOLEAN bStartClient = TRUE;
    BOOLEAN bStartServer = TRUE;

    PCTSTR pszPipeName = g_pszPipeName;
    ULONG tid = 0;
    HANDLE hClientThread = NULL;
    HANDLE hServerWorkerThread = NULL;
    TClientThreadParam ClientParam = {0};
    TCHAR szClientPipeName[MAX_PATH] = {0};
    TCHAR szServerPipeName[MAX_PATH] = {0};
    PTSTR pszServerHost = NULL;
    PTSTR pszCommandLine = NULL;
    SECURITY_ATTRIBUTES sa = {0};
    SECURITY_DESCRIPTOR sd = {0};
    BYTE AclBuf[ 64 ] = {0};
    DWORD cbAcl = sizeof(AclBuf);
    PACL pAcl = (PACL)AclBuf;

    argc--;

    while (argc)
    {
        if (!lstrcmp(argv[mark], TEXT("-port")) && (argc > 1))
        {
            argc--; mark++;
            pszPipeName = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-application")) && (argc > 1))
        {
            argc--; mark++;
            pszCommandLine = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-su4clientupn")) && (argc > 1))
        {
            argc--; mark++;
            ClientParam.pszS4uClientUpn = argv[mark];
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-clientflagsandattributes")) && (argc > 1))
        {
            argc--; mark++;
            ClientParam.FlagsAndAttributes = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-su42selfflags")) && (argc > 1))
        {
            argc--; mark++;
            ClientParam.S4u2SelfFlags = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-clientprocessidtoimperonate")) && (argc > 1))
        {
            argc--; mark++;
            ClientParam.ProcessId = lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-serverhost")) && (argc > 1))
        {
            argc--; mark++;
            pszServerHost = argv[mark];
            bStartServer = FALSE;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-noclient")))
        {
            argc--; mark++;
            bStartClient = FALSE;
        }
        else if (!lstrcmp(argv[mark],TEXT("-noserver")))
        {
            argc--; mark++;
            bStartServer = FALSE;
        }
        else
        {
            Usage(argv[0]);
        }
    }

    SspiLogOpen(TEXT("namedports.exe"), SSPI_LOG | SSPI_WARN | SSPI_ERROR);

    if (bStartClient)
    {
        ClientParam.pszPipeName = szClientPipeName;

        hRetval DBGCHK = _sntprintf(szClientPipeName, COUNTOF(szClientPipeName) - 1,
                            TEXT("\\\\%s\\pipe\\%s"),
                            pszServerHost ? pszServerHost : TEXT("."),
                            pszPipeName
                            ) > 0 ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval) && bStartServer)
    {
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = TRUE;

        hRetval DBGCHK = BuildNamedPipeAcl(pAcl, &cbAcl) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = _sntprintf(szServerPipeName, COUNTOF(szServerPipeName) - 1,
                                TEXT("\\\\.\\pipe\\%s"),
                                pszPipeName
                                ) > 0 ? S_OK : E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hRetval) && bStartClient)
    {
        hClientThread = CreateThread(NULL, 0, ClientThread, &ClientParam, 0, &tid);
        hRetval DBGCHK = hClientThread ? S_OK : GetLastErrorAsHResult();
    }

    while (SUCCEEDED(hRetval) && bStartServer)
    {
        TServerWorkerThreadParam ServerParam = {0};

        SspiPrint(SSPI_LOG, TEXT("Server waiting on pipe %s\n"), szServerPipeName);

        ServerParam.pszCommandLine = pszCommandLine;

        ServerParam.hPipe = CreateNamedPipe(
                                szServerPipeName,
                                PIPE_ACCESS_DUPLEX,
                                PIPE_TYPE_BYTE | PIPE_WAIT,
                                1,
                                4096, // output buffer size
                                4096, // input buffer size
                                NMPWAIT_USE_DEFAULT_WAIT, // timeout interval
                                &sa
                                );
        hRetval DBGCHK = (ServerParam.hPipe != INVALID_HANDLE_VALUE) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = ConnectNamedPipe(
                                ServerParam.hPipe,
                                NULL // no overlapped structure
                                ) ? S_OK : GetLastErrorAsHResult();
            if (FAILED(hRetval) && (ERROR_PIPE_CONNECTED == HRESULT_CODE(hRetval)))
            {
                hRetval DBGCHK = S_OK;
            }
        }

        if (SUCCEEDED(hRetval))
        {
            hServerWorkerThread = CreateThread(NULL, 0, ServerWokerThread, &ServerParam, 0, &tid);

            hRetval DBGCHK = hServerWorkerThread ? S_OK : GetLastErrorAsHResult();

            if (FAILED(hRetval))
            {
                CloseHandle(ServerParam.hPipe);
                ServerParam.hPipe = INVALID_HANDLE_VALUE;
            }
            else
            {
                (VOID) WaitForSingleObject(hServerWorkerThread, INFINITE);
            }

            if (hServerWorkerThread)
            {
                CloseHandle(hServerWorkerThread);
            }
        }
        else if (ServerParam.hPipe != INVALID_HANDLE_VALUE)
        {
            CloseHandle(ServerParam.hPipe);
        }
    }

    if (SUCCEEDED(hRetval) && hClientThread)
    {
        (VOID) WaitForSingleObject(hClientThread, INFINITE);
    }

    if (hClientThread)
    {
        CloseHandle(hClientThread);
    }

    SspiLogClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\namedports\namedports.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    namedports.cxx

Abstract:

    namedports

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <ntseapi.h>
#include <lsasspi.hxx>
#include "namedports.hxx"

extern "C" {
#include <zwapi.h>
}

#define PORT_MSG_DATA_MAX_TEXT_LENGTH 40

#if defined(UNICODE) || defined(_UNICODE)
#define lstrtol wcstol
#else
#define lstrtol strtol
#endif

struct PORT_MESSAGEX {
    PORT_MESSAGE portMsg;
    TCHAR Data[PORT_MSG_DATA_MAX_TEXT_LENGTH];
};

struct CLIENT_PARAM {
    UNICODE_STRING* pPortName;
    SECURITY_QUALITY_OF_SERVICE* pSQOS;
};

UNICODE_STRING g_PortName = CONSTANT_UNICODE_STRING(L"\\NAMED_PORTS_TEST");

DWORD 
WINAPI 
client(
    IN PVOID pParam
    )
{
    TNtStatus Status = STATUS_UNSUCCESSFUL;

    PORT_MESSAGEX req = {0};
    PORT_MESSAGEX rep = {0};
    PCTSTR pszTxt = TEXT("Hello Server, I am client");
    CLIENT_PARAM* pClientParam = (CLIENT_PARAM*) pParam;

    HANDLE hPort = NULL;

    memset(&req, 0xaa, sizeof(req));
    memset(&rep, 0xcc, sizeof(rep));

    req.portMsg.u2.s2.Type = LPC_REQUEST;
    req.portMsg.u1.s1.TotalLength = sizeof(req);
    req.portMsg.u1.s1.DataLength = min(lstrlen(pszTxt) + 1, PORT_MSG_DATA_MAX_TEXT_LENGTH) * sizeof(TCHAR);
    req.portMsg.u2.ZeroInit = 0L;
    RtlCopyMemory(req.Data, pszTxt, req.portMsg.u1.s1.DataLength);

    SspiPrint(SSPI_LOG, TEXT("client entering PortName %wZ\n"), pClientParam->pPortName);

    Status DBGCHK = ZwConnectPort(
        &hPort, // PortHandle
        pClientParam->pPortName, // PortName
        pClientParam->pSQOS, // SecurityQos
        NULL, // ClientView
        NULL, // ServerView 
        NULL, // MaxMessageLength
        NULL, // ConnectionInformation 
        NULL  // ConnectionInformationLength
        );

    if (NT_SUCCESS(Status))
    {
        SspiPrint(SSPI_LOG, TEXT("Client: ZwRequestWaitReplyPort...\n"));

        Status DBGCHK = ZwRequestWaitReplyPort(
            hPort, 
            (PORT_MESSAGE*)&req, 
            (PORT_MESSAGE*)&rep
            );

        if (NT_SUCCESS(Status))
        {
            SspiPrint(SSPI_LOG, TEXT("Client(): type %hd, id %hu, \"%s\"\n"), rep.portMsg.u2.s2.Type, rep.portMsg.MessageId, rep.Data);

            Sleep(1000);
        }
    }

    if (hPort)
    {
        ZwClose(hPort);
    }

    SspiPrint(SSPI_LOG, TEXT("client leaving\n"));

    return (NTSTATUS) Status;
}

VOID
Usage(
    IN PCTSTR pszProgram
    )
{
    SspiPrint(SSPI_ERROR, 
        TEXT("Usage: %s [-noclient] [-noserver] [-clientimpersonationlevel <level>]\n")
        TEXT("[-serverimpersonationlevel <level>] [-clientcontexttrackingmode <mode>]\n")
        TEXT("[-servercontexttrackingmode <mode>] [-clienteffectiveonly <effectiveonly>\n")
        TEXT("[-servereffectiveonly <effectiveonly>]\n"), pszProgram);
    exit(-1);
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    ULONG tid = 0;

    int mark = 1;

    PORT_MESSAGEX req = {0};
    HANDLE hPort = NULL;
    HANDLE hThread = NULL;
    HANDLE hPort2 = NULL;
    PCTSTR pszTxt = TEXT("Hello Client, I am server");
    BOOLEAN bStartClient = TRUE;
    BOOLEAN bStartServer = TRUE;

    SECURITY_QUALITY_OF_SERVICE csqos = {
        sizeof(SECURITY_QUALITY_OF_SERVICE), // Length 
        SecurityImpersonation, // ImpersonationLevel
        TRUE, // ContextTrackingMode
        TRUE  // EffectiveOnly
        };
    SECURITY_QUALITY_OF_SERVICE ssqos = {
        sizeof(SECURITY_QUALITY_OF_SERVICE), // Length 
        SecurityImpersonation, // ImpersonationLevel
        TRUE, // ContextTrackingMode
        TRUE  // EffectiveOnly
        };

    OBJECT_ATTRIBUTES oa = {
        sizeof(OBJECT_ATTRIBUTES), // Length
        NULL, // RootDirectory
        &g_PortName, // ObjectName
        0, // no Attributes
        NULL, // no SecurityDescriptor
        NULL, // SecurityQualityOfService
        };

    CLIENT_PARAM ClientParam = {&g_PortName, &csqos};

    argc--;

    while (argc)
    {
        if (!lstrcmp(argv[mark], TEXT("-port")) && (argc > 1))
        {
            argc--; mark++;
            RtlInitUnicodeString(&g_PortName, argv[mark]);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark], TEXT("-noclient")))
        {
            argc--; mark++;
            bStartClient = FALSE;
        }
        else if (!lstrcmp(argv[mark],TEXT("-noserver")))
        {
            argc--; mark++;
            bStartServer = FALSE;
        }
        else if (!lstrcmp(argv[mark],TEXT("-clientimpersonationlevel")))
        {
            argc--; mark++;
            csqos.ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL) lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark],TEXT("-serverimpersonationlevel")))
        {
            argc--; mark++;
            ssqos.ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL) lstrtol(argv[mark], NULL, 0);
            oa.SecurityQualityOfService = &ssqos;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark],TEXT("-clientcontexttrackingmode")))
        {
            argc--; mark++;
            csqos.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark],TEXT("-servercontexttrackingmode")))
        {
            argc--; mark++;
            ssqos.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) lstrtol(argv[mark], NULL, 0);
            oa.SecurityQualityOfService = &ssqos;
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark],TEXT("-clienteffectiveonly")))
        {
            argc--; mark++;
            csqos.EffectiveOnly = (BOOLEAN) lstrtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!lstrcmp(argv[mark],TEXT("-servereffectiveonly")))
        {
            argc--; mark++;
            ssqos.EffectiveOnly = (BOOLEAN) lstrtol(argv[mark], NULL, 0);
            oa.SecurityQualityOfService = &ssqos;
            argc--; mark++;
        }
        else
        {
            Usage(argv[0]);
        }
    }

    req.portMsg.u1.s1.DataLength = 4;
    req.Data[0] = 0xfe;

    SspiLogOpen(TEXT("namedports.exe"), SSPI_LOG | SSPI_WARN | SSPI_ERROR);
    DebugLogOpen("namedports.exe",  SSPI_LOG | SSPI_WARN | SSPI_ERROR);

    if (bStartServer)
    {
        Status DBGCHK = ZwCreatePort(
            &hPort, // PortHandle
            &oa, // ObjectAttributes  
            0, // MaxConnectionInfoLength
            sizeof(req), // MaxMessageLength
            0  // MaxPoolUsage
            );
    }

    if (NT_SUCCESS(Status) && bStartClient)
    {
        hThread = CreateThread(
            NULL,  // lpThreadAttributes
            0, // dwStackSize 
            client, // lpStartAddress 
            &ClientParam, // lpParameter
            0, // dwCreationFlags
            &tid // lpThreadId
            );
        Status DBGCHK = hThread ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    while (NT_SUCCESS(Status) && bStartServer)
    {
        SspiPrint(SSPI_LOG, TEXT("********Server ZwListenPort PortName %wZ...************\n"), ClientParam.pPortName);

        hPort2 = NULL;

        Status DBGCHK = ZwListenPort(
            hPort, 
            (PORT_MESSAGE*)&req
            );

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = ZwAcceptConnectPort(
                &hPort2, // PortHandle 
                NULL, // PortContext
                (PORT_MESSAGE*)&req, // ConnectionRequest
                TRUE, // AcceptConnection
                NULL, // ServerView
                NULL  // ClientView
                );

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = ZwCompleteConnectPort(hPort2);
            }

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = ZwReplyWaitReceivePort(
                    hPort2, // PortHandle
                    NULL, // PortContext
                    0, // ReplyMessage
                    (PORT_MESSAGE*)&req // ReceiveMessage
                    );
            }

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = NtImpersonateClientOfPort(
                    hPort2, 
                    (PPORT_MESSAGE)
                    &req
                    );
            }

            if (NT_SUCCESS(Status))
            {
                Status DBGCHK = CheckUserData();
            }

            if (NT_SUCCESS(Status))
            {
                SspiPrint(SSPI_LOG, TEXT("server(): type %hd, id %hu, \"%s\"\n"), req.portMsg.u2.s2.Type, req.portMsg.MessageId, req.Data);

                req.portMsg.u1.s1.DataLength = min(lstrlen(pszTxt) + 1, PORT_MSG_DATA_MAX_TEXT_LENGTH) * sizeof(TCHAR);
                RtlCopyMemory(req.Data, pszTxt, req.portMsg.u1.s1.DataLength);

                Status DBGCHK = ZwReplyPort(
                    hPort2, 
                    (PORT_MESSAGE*)&req
                    );
            }

            if (hPort2)
            {
                ZwClose(hPort2);
            }
        }
    }

    if (NT_SUCCESS(Status) && hThread)
    {
        (VOID) WaitForSingleObject(hThread, INFINITE);
    }

    if (hPort)
    {
        ZwClose(hPort);
    }

    if (hThread)
    {
        CloseHandle(hThread);
    }

    DebugLogClose();
    SspiLogClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\msvsubauth\subauth.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    subauth.cxx

Abstract:

    subauth

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lmcons.h>
#include <logonmsv.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#include "subauth.hxx"

NTSTATUS
NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID pLogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION pUserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO pValidationInfo,
    OUT PULONG pActionsPerformed
    )
{
    TNtStatus Status;

    DebugPrintf(SSPI_LOG, "Msv1_0SubAuthenticationRoutine in msvsubauth.dll: LogonLevel %#x, validating UserName %wZ, UserId %#x(%d)\n",
        LogonLevel, &pUserAll->UserName, pUserAll->UserId, pUserAll->UserId);

    Status DBGCHK = Msv1_0SubAuthenticationRoutine(
        LogonLevel,
        pLogonInformation,
        Flags,
        pUserAll,
        &pValidationInfo->WhichFields,
        &pValidationInfo->UserFlags,
        &pValidationInfo->Authoritative,
        &pValidationInfo->LogoffTime,
        &pValidationInfo->KickoffTime
        );
    if (NT_SUCCESS(Status))
    {
        pValidationInfo->UserId = pUserAll->UserId;
        *pActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;
    }

    return Status;
}

NTSTATUS
NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID pLogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION pUserAll,
    OUT PULONG pWhichFields,
    OUT PULONG pUserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER pLogoffTime,
    OUT PLARGE_INTEGER pKickoffTime
    )
{
    TNtStatus Status = STATUS_SUCCESS;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER PasswordDateSet;
    UNICODE_STRING LocalWorkstation;

    PNETLOGON_NETWORK_INFO LogonNetworkInfo;

    DebugPrintf(SSPI_LOG, "Msv1_0SubAuthenticationRoutine in msvsubauth.dll: LogonLevel %#x, validating UserName %wZ, UserId %#x(%d)\n",
        LogonLevel, &pUserAll->UserName, pUserAll->UserId, pUserAll->UserId);

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    *Authoritative = TRUE;
    *pUserFlags = 0;
    *pWhichFields = 0;

    (VOID) NtQuerySystemTime(&LogonTime);

    switch (LogonLevel)
    {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        //
        // This SubAuthentication package only supports network logons.
        //

        Status DBGCHK = STATUS_INVALID_INFO_CLASS;
        break;

    case NetlogonNetworkInformation:

        //
        // This SubAuthentication package doesn't support access via machine
        // accounts.
        //

        UserAccountControl = USER_NORMAL_ACCOUNT;

        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ((Flags & MSV1_0_PASSTHRU) == 0)
        {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) pLogonInformation;

        break;

    default:
        *Authoritative = TRUE;
        Status DBGCHK = STATUS_INVALID_INFO_CLASS;
    }

    //
    // If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //

    if (NT_SUCCESS(Status) && (UserAccountControl & pUserAll->UserAccountControl) == 0)
    {
        *Authoritative = FALSE;
        Status DBGCHK = STATUS_NO_SUCH_USER;
    }

    //
    // This SubAuthentication package doesn't allow guest logons.
    //

    if (NT_SUCCESS(Status) && (Flags & MSV1_0_GUEST_LOGON))
    {
        *Authoritative = FALSE;
        Status DBGCHK = STATUS_NO_SUCH_USER;
    }

    //
    // Ensure the account isn't locked out.
    //

    if (NT_SUCCESS(Status) && (pUserAll->UserId != DOMAIN_USER_RID_ADMIN &&
         (pUserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)))
    {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        if (pUserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
        {
            *Authoritative = FALSE;
        }
        else
        {
            *Authoritative = TRUE;
        }
        Status DBGCHK = STATUS_ACCOUNT_LOCKED_OUT;
    }

    //
    // Check the password.
    //

    if (NT_SUCCESS(Status) && FALSE /* VALIDATE THE USER'S PASSWORD HERE */)
    {

        Status DBGCHK = STATUS_WRONG_PASSWORD;

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        if (pUserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
        {
            *Authoritative = FALSE;
        }
        else
        {
            *Authoritative = TRUE;
        }
    }

    //
    // Prevent some things from effecting the Administrator user
    //

    if (NT_SUCCESS(Status))
    {
        if (pUserAll->UserId == DOMAIN_USER_RID_ADMIN)
        {
            //
            //  The administrator account doesn't have a forced logoff time.
            //

            pLogoffTime->HighPart = 0x7FFFFFFF;
            pLogoffTime->LowPart = 0xFFFFFFFF;

            pKickoffTime->HighPart = 0x7FFFFFFF;
            pKickoffTime->LowPart = 0xFFFFFFFF;
        }
        else
        {
            //
            // Check if the account is disabled.
            //

            if (pUserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
            {
                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them. Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //

                *Authoritative = FALSE;
                Status DBGCHK = STATUS_ACCOUNT_DISABLED;
            }

            //
            // Check if the account has expired.
            //

            if (NT_SUCCESS(Status) && (pUserAll->AccountExpires.QuadPart != 0) &&
                 (LogonTime.QuadPart >= pUserAll->AccountExpires.QuadPart))
            {
                *Authoritative = TRUE;
                Status DBGCHK = STATUS_ACCOUNT_EXPIRED;
            }

            //
            // The password is valid, check to see if the password is expired.
            //  (SAM will have appropriately set PasswordMustChange to reflect
            //  USER_DONT_EXPIRE_PASSWORD)
            //
            // If the password checked above is not the SAM password, you may
            // want to consider not checking the SAM password expiration times here.
            //

            if (NT_SUCCESS(Status) && (LogonTime.QuadPart >= pUserAll->PasswordMustChange.QuadPart))
            {
                if (pUserAll->PasswordLastSet.QuadPart == 0)
                {
                    Status DBGCHK = STATUS_PASSWORD_MUST_CHANGE;
                }
                else
                {
                    Status DBGCHK = STATUS_PASSWORD_EXPIRED;
                }
                *Authoritative = TRUE;
            }

            //
            // Validate the workstation the user logged on from.
            //
            // Ditch leading \\ on workstation name before passing it to SAM.
            //

            if (NT_SUCCESS(Status))
            {
                LocalWorkstation = LogonNetworkInfo->Identity.Workstation;
                if (LocalWorkstation.Length > 0 &&
                    LocalWorkstation.Buffer[0] == L'\\' &&
                    LocalWorkstation.Buffer[1] == L'\\')
                {
                    LocalWorkstation.Buffer += 2;
                    LocalWorkstation.Length -= 2 * sizeof(WCHAR);
                    LocalWorkstation.MaximumLength -= 2 * sizeof(WCHAR);
                }

                //
                //  To validate the user's logon hours as SAM does it, use this code,
                //  otherwise, supply your own checks below this code.
                //

                Status DBGCHK = AccountRestrictions(
                    pUserAll->UserId,
                    &LocalWorkstation,
                    (PUNICODE_STRING) &pUserAll->WorkStations,
                    &pUserAll->LogonHours,
                    pLogoffTime,
                    pKickoffTime
                    );
            }

            //
            // Validate if the user can log on from this workstation.
            //  (Supply subauthentication package specific code here.)

            if (NT_SUCCESS(Status) && LogonNetworkInfo->Identity.Workstation.Buffer == NULL)
            {
                Status DBGCHK = STATUS_INVALID_WORKSTATION;
                *Authoritative = TRUE;
            }
        }
    }

    //
    // The user is valid.
    //

    if (NT_SUCCESS(Status))
    {
        *Authoritative = TRUE;
        Status DBGCHK = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING pLogonWorkStation,
    IN PUNICODE_STRING pWorkStations
    )
{
    TNtStatus        NtStatus = STATUS_INVALID_WORKSTATION;

    PWCHAR          pWorkStationName;
    UNICODE_STRING  Unicode;
    UNICODE_STRING  WorkStationsListCopy;
    PWCHAR          pTmpBuffer;

    //
    // Local workstation is always allowed
    // If WorkStations field is 0 everybody is allowed
    //

    if ((pLogonWorkStation == NULL) ||
        (pLogonWorkStation->Length == 0) ||
        (pWorkStations->Length == 0))
    {
        return STATUS_SUCCESS;
    }

    //
    // WorkStationApiList points to our current location in the list of
    // WorkStations.
    //

    WorkStationsListCopy.Buffer = (PWSTR) new CHAR[pWorkStations->Length];

    NtStatus DBGCHK = WorkStationsListCopy.Buffer ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(NtStatus))
    {

        WorkStationsListCopy.MaximumLength = pWorkStations->Length;

        RtlCopyMemory(WorkStationsListCopy.Buffer, pWorkStations->Buffer, pWorkStations->Length);

        //
        // wcstok requires a string the first time it's called, and NULL
        // for all subsequent calls.  Use a temporary variable so we
        // can do this.
        //

        pTmpBuffer = WorkStationsListCopy.Buffer;

        while (pWorkStationName = wcstok(pTmpBuffer, L","))
        {
            pTmpBuffer = NULL;
            RtlInitUnicodeString(&Unicode, pWorkStationName);
            if (EqualComputerName(&Unicode, pLogonWorkStation))
            {
                NtStatus DBGCHK = STATUS_SUCCESS;
                break;
            }
        }
    }

    RtlFreeUnicodeString(&WorkStationsListCopy);

    return NtStatus;
}

NTSTATUS
AccountRestrictions(
    IN ULONG UserRid,
    IN PUNICODE_STRING pLogonWorkStation,
    IN PUNICODE_STRING pWorkStations,
    IN PLOGON_HOURS pLogonHours,
    OUT PLARGE_INTEGER pLogoffTime,
    OUT PLARGE_INTEGER pKickoffTime
    )
{
    TNtStatus NtStatus = STATUS_SUCCESS;

    static BOOLEAN GetForceLogoff = TRUE;
    static LARGE_INTEGER ForceLogoff = {0x7fffffff, 0xFFFFFFF};

#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000

    SYSTEMTIME CurrentTimeFields;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER CurrentUTCTime;
    LARGE_INTEGER MillisecondsIntoWeekXUnitsPerWeek;
    LARGE_INTEGER LargeUnitsIntoWeek;
    LARGE_INTEGER Delta100Ns;
    ULONG CurrentMsIntoWeek;
    ULONG LogoffMsIntoWeek;
    ULONG DeltaMs;
    ULONG MillisecondsPerUnit;
    ULONG CurrentUnitsIntoWeek;
    ULONG LogoffUnitsIntoWeek;
    USHORT i;
    TIME_ZONE_INFORMATION TimeZoneInformation;
    DWORD TimeZoneId;
    LARGE_INTEGER BiasIn100NsUnits;
    LONG BiasInMinutes;

    //
    // Only check for users other than the builtin ADMIN
    //

    if (UserRid != DOMAIN_USER_RID_ADMIN)
    {
        //
        // Scan to make sure the workstation being logged into is in the
        // list of valid workstations - or if the list of valid workstations
        // is null, which means that all are valid.
        //

        NtStatus DBGCHK = SampMatchworkstation(pLogonWorkStation, pWorkStations);

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Check to make sure that the current time is a valid time to log
            // on in the LogonHours.
            //
            // We need to validate the time taking into account whether we are
            // in daylight savings time or standard time.  Thus, if the logon
            // hours specify that we are able to log on between 9am and 5pm,
            // this means 9am to 5pm standard time during the standard time
            // period, and 9am to 5pm daylight savings time when in the
            // daylight savings time.  Since the logon hours stored by SAM are
            // independent of daylight savings time, we need to add in the
            // difference between standard time and daylight savings time to
            // the current time before checking whether this time is a valid
            // time to log on.  Since this difference (or bias as it is called)
            // is actually held in the form
            //
            // Standard time = Daylight savings time + Bias
            //
            // the Bias is a negative number.  Thus we actually subtract the
            // signed Bias from the Current Time.

            //
            // First, get the Time Zone Information.
            //

            TimeZoneId = GetTimeZoneInformation(&TimeZoneInformation);

            //
            // Next, get the appropriate bias (signed integer in minutes) to subtract from
            // the Universal Time Convention (UTC) time returned by NtQuerySystemTime
            // to get the local time.  The bias to be used depends whether we're
            // in Daylight Savings time or Standard Time as indicated by the
            // TimeZoneId parameter.
            //
            // local time  = UTC time - bias in 100Ns units
            //

            switch (TimeZoneId)
            {
            case TIME_ZONE_ID_UNKNOWN:

                //
                // There is no differentiation between standard and
                // daylight savings time.  Proceed as for Standard Time
                //

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_STANDARD:

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_DAYLIGHT:

                BiasInMinutes = TimeZoneInformation.DaylightBias;
                break;

            default:

                //
                // Something is wrong with the time zone information.  Fail
                // the logon request.
                //

                NtStatus DBGCHK = STATUS_INVALID_LOGON_HOURS;
                break;
            }

            if (NT_SUCCESS(NtStatus))
            {
                //
                // Convert the Bias from minutes to 100ns units
                //

                BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes) * 60 * 10000000;

                //
                // Get the UTC time in 100Ns units used by Windows Nt. This
                // time is GMT.
                //

                NtStatus DBGCHK = NtQuerySystemTime(&CurrentUTCTime);
            }

            if (NT_SUCCESS(NtStatus))
            {
                CurrentTime.QuadPart = CurrentUTCTime.QuadPart -
                              BiasIn100NsUnits.QuadPart;

                FileTimeToSystemTime((PFILETIME)&CurrentTime, &CurrentTimeFields);

                CurrentMsIntoWeek = (((( CurrentTimeFields.wDayOfWeek * 24 ) +
                                       CurrentTimeFields.wHour ) * 60 +
                                       CurrentTimeFields.wMinute ) * 60 +
                                       CurrentTimeFields.wSecond ) * 1000 +
                                       CurrentTimeFields.wMilliseconds;

                MillisecondsIntoWeekXUnitsPerWeek.QuadPart =
                    ((LONGLONG)CurrentMsIntoWeek) *
                    ((LONGLONG)pLogonHours->UnitsPerWeek);

                LargeUnitsIntoWeek.QuadPart =
                    MillisecondsIntoWeekXUnitsPerWeek.QuadPart / ((ULONG) MILLISECONDS_PER_WEEK);

                CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart;

                if ( !( pLogonHours->LogonHours[ CurrentUnitsIntoWeek / 8] &
                    ( 0x01 << ( CurrentUnitsIntoWeek % 8 ) ) ) )
                {
                    NtStatus DBGCHK = STATUS_INVALID_LOGON_HOURS;
                }
                else
                {
                    //
                    // Determine the next time that the user is NOT supposed to be logged
                    // in, and return that as LogoffTime.
                    //

                    i = 0;
                    LogoffUnitsIntoWeek = CurrentUnitsIntoWeek;
                    do
                    {
                        i++;

                        LogoffUnitsIntoWeek = (LogoffUnitsIntoWeek + 1) % pLogonHours->UnitsPerWeek;

                    }
                    while ( (i <= pLogonHours->UnitsPerWeek) &&
                        ( pLogonHours->LogonHours[LogoffUnitsIntoWeek / 8] & (0x01 << (LogoffUnitsIntoWeek % 8)) ) );

                    if (i > pLogonHours->UnitsPerWeek)
                    {
                        //
                        // All times are allowed, so there's no logoff
                        // time.  Return forever for both pLogoffTime and
                        // KickoffTime.
                        //

                        pLogoffTime->HighPart = 0x7FFFFFFF;
                        pLogoffTime->LowPart = 0xFFFFFFFF;

                        pKickoffTime->HighPart = 0x7FFFFFFF;
                        pKickoffTime->LowPart = 0xFFFFFFFF;

                    }
                    else
                    {
                        //
                        // LogoffUnitsIntoWeek points at which time unit the
                        // user is to log off.  Calculate actual time from
                        // the unit, and return it.
                        //
                        // CurrentTimeFields already holds the current
                        // time for some time during this week; just adjust
                        // to the logoff time during this week and convert
                        // to time format.
                        //

                        MillisecondsPerUnit = MILLISECONDS_PER_WEEK / pLogonHours->UnitsPerWeek;

                        LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

                        if (LogoffMsIntoWeek < CurrentMsIntoWeek)
                        {
                            DeltaMs = MILLISECONDS_PER_WEEK - (CurrentMsIntoWeek - LogoffMsIntoWeek) ;
                        }
                        else
                        {
                            DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek;
                        }

                        Delta100Ns.QuadPart = (LONGLONG) DeltaMs * 10000;

                        pLogoffTime->QuadPart = CurrentUTCTime.QuadPart + Delta100Ns.QuadPart;

                        //
                        // Grab the domain's ForceLogoff time.
                        //

                        if (GetForceLogoff)
                        {
                            NET_API_STATUS NetStatus;
                            LPUSER_MODALS_INFO_0 UserModals0;

                            NetStatus = NetUserModalsGet(NULL,
                                                         0,
                                                         (PBYTE *)&UserModals0);

                            if (NetStatus == 0)
                            {
                                GetForceLogoff = FALSE;

                                ForceLogoff = NetpSecondsToDeltaTime(UserModals0->usrmod0_force_logoff);

                                NetApiBufferFree(UserModals0);
                            }
                        }

                        //
                        // Subtract Domain->ForceLogoff from LogoffTime, and return
                        // that as KickoffTime.  Note that Domain->ForceLogoff is a
                        // negative delta.  If its magnitude is sufficiently large
                        // (in fact, larger than the difference between LogoffTime
                        // and the largest positive large integer), we'll get overflow
                        // resulting in a KickOffTime that is negative.  In this
                        // case, reset the KickOffTime to this largest positive
                        // large integer (i.e. "never") value.
                        //


                        pKickoffTime->QuadPart = pLogoffTime->QuadPart - ForceLogoff.QuadPart;

                        if (pKickoffTime->QuadPart < 0)
                        {
                            pKickoffTime->HighPart = 0x7FFFFFFF;
                            pKickoffTime->LowPart = 0xFFFFFFFF;
                        }
                    }
                }
            }
        }
    }
    else
    {
        //
        // Never kick administrators off
        //

        pLogoffTime->HighPart  = 0x7FFFFFFF;
        pLogoffTime->LowPart   = 0xFFFFFFFF;
        pKickoffTime->HighPart = 0x7FFFFFFF;
        pKickoffTime->LowPart  = 0xFFFFFFFF;
    }

    return NtStatus;
}

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    )
{
    LARGE_INTEGER DeltaTime;
    LARGE_INTEGER LargeSeconds;
    LARGE_INTEGER Answer;

    //
    // Special case TIMEQ_FOREVER (return a full scale negative)
    //

    if (Seconds == TIMEQ_FOREVER)
    {
        DeltaTime.LowPart = 0;
        DeltaTime.HighPart = (LONG) 0x80000000;
    }
    else
    {
        //
        // Convert seconds to 100ns units simply by multiplying by 10000000.
        //
        // Convert to delta time by negating.
        //

        LargeSeconds.LowPart = Seconds;
        LargeSeconds.HighPart = 0;

        Answer.QuadPart = LargeSeconds.QuadPart * 10000000;

        if (Answer.QuadPart < 0)
        {
            DeltaTime.LowPart = 0;
            DeltaTime.HighPart = (LONG) 0x80000000;
        }
        else
        {
            DeltaTime.QuadPart = -Answer.QuadPart;
        }
    }

    return DeltaTime;
}

BOOLEAN
EqualComputerName(
    IN PUNICODE_STRING pString1,
    IN PUNICODE_STRING pString2
    )
{
    WCHAR szComputer1[CNLEN + 1] = {0};
    WCHAR szComputer2[CNLEN + 1] = {0};
    CHAR szOemComputer1[CNLEN + 1] = {0};
    CHAR szOemComputer2[CNLEN + 1] = {0};

    //
    // Make sure the names are not too long
    //

    if ((pString1->Length > CNLEN*sizeof(WCHAR)) ||
        (pString2->Length > CNLEN*sizeof(WCHAR)))
    {
        return FALSE;
    }

    //
    // Copy them to null terminated strings
    //

    RtlCopyMemory(
        szComputer1,
        pString1->Buffer,
        pString1->Length
        );
    szComputer1[pString1->Length/sizeof(WCHAR)] = L'\0';

    RtlCopyMemory(
        szComputer2,
        pString2->Buffer,
        pString2->Length
        );

    szComputer2[pString2->Length/sizeof(WCHAR)] = L'\0';

    //
    // Convert the computer names to OEM
    //

    if (!CharToOemW(
            szComputer1,
            szOemComputer1
            ))
    {
        return FALSE;
    }

    if (!CharToOemW(
            szComputer2,
            szOemComputer2
            ))
    {
        return FALSE;
    }

    //
    // Do a case insensitive comparison of the oem computer names.
    //

    if (_stricmp(szOemComputer1, szOemComputer2) == 0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
    )
{
    TNtStatus Status;

    SspiPrint(SSPI_LOG, TEXT("Msv1_0SubAuthenticationRoutineGeneric\n"));

    Status DBGCHK = (ReturnBufferLength && ReturnBuffer ) ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;

    if (NT_SUCCESS(Status))
    {
        *ReturnBuffer = LocalAlloc(0, SubmitBufferLength);

        if (*ReturnBuffer)
        {
            *ReturnBufferLength = SubmitBufferLength;
            RtlCopyMemory(*ReturnBuffer, SubmitBuffer, SubmitBufferLength);
        }
        else
        {
            *ReturnBufferLength = 0;
        }

        SspiPrintHex(SSPI_LOG, TEXT("SubauthInfo"), SubmitBufferLength, SubmitBuffer);
    }

    return Status;
}

NTSTATUS
NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID pLogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION pUserAll,
    OUT PULONG pWhichFields,
    OUT PULONG pUserFlags,
    OUT PBOOLEAN pAuthoritative,
    OUT PLARGE_INTEGER pLogoffTime,
    OUT PLARGE_INTEGER pKickoffTime
    )
{
    return Msv1_0SubAuthenticationRoutine(
                LogonLevel,
                pLogonInformation,
                Flags,
                pUserAll,
                pWhichFields,
                pUserFlags,
                pAuthoritative,
                pLogoffTime,
                pKickoffTime
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\msvsharelevelcli.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvsharelevelcli.cxx

Abstract:

    msvsharelevel client

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvsharelevelcli.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\rpc\client\sspicli.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   kerbcli.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "sspitest.h"     // header file generated by MIDL compiler

int Usage(char* pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -a delegation address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o network options\n");
    fprintf(stderr, " -l authn level\n");
    fprintf(stderr, " -s authn service\n");
    fprintf(stderr, " -r recursiion level\n");
    fprintf(stderr, " -u username\n");
    fprintf(stderr, " -k password\n");
    fprintf(stderr, " -d domain\n");
    fprintf(stderr, " -x shutdown server\n");
    fprintf(stderr, " -# number of times to call\n");
    fprintf(stderr, " -t target principal\n");
    exit(1);
}

#ifndef UNLEN
#define UNLEN 256
#endif

int __cdecl
main (argc, argv)
    int argc;
    PSTR argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    PSTR pszProtocolSequence = "ncacn_ip_tcp";
    PSTR pszNetworkAddress = NULL;
    PSTR pszEndpoint = "30760";
    PSTR pszOptions = NULL;
    PSTR pszStringBinding = NULL;
    PSTR pszDelegationAddress = NULL;
    PSTR pszPrincipal = NULL;
    CHAR PrincipalBuffer[UNLEN] = {0};
    ULONG PrincipalLength;
    ULONG AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
    ULONG AuthnService = RPC_C_AUTHN_WINNT;
    ULONG RecursionLevel = 0;
    ULONG LoopCount = 1;
    BOOLEAN ShutdownService = FALSE;
    ULONG i;
    handle_t BindingHandle = NULL;
    SEC_WINNT_AUTH_IDENTITY_A sID = {0};

    sID.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // allow the user to override settings with command line switches
    for (i = 1; i < (ULONG) argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (tolower(*(argv[i] + 1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'a':  // network address
                pszDelegationAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 't':
                pszPrincipal = argv[++i];
                break;
            case 'u':
                sID.User = argv[++i];
                sID.UserLength = strlen(sID.User);
                break;
            case 'd':
                sID.Domain = argv[++i];
                sID.DomainLength = strlen(sID.Domain);
                break;
            case 'k':
                sID.Password = argv[++i];
                sID.PasswordLength = strlen(sID.Password);
                break;
            case 'l':
                AuthnLevel = strtol(argv[++i], NULL, 0);
                break;
            case 's':
                AuthnService = strtol(argv[++i], NULL, 0);
                break;
            case 'r':
                RecursionLevel = strtol(argv[++i], NULL, 0);
                  break;
            case '#':
                LoopCount = strtol(argv[++i], NULL, 0);
                break;
            case 'x':
                ShutdownService = TRUE;
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    //
    // If the principal is NULL, get it from the environment
    //

    if (pszPrincipal == NULL)
    {
        PSTR pszUserRealm;
        PSTR pszUserName;

        PrincipalBuffer[0] = '\0';

        pszUserRealm = getenv( "USERDOMAIN" );
        pszUserName  = getenv( "USERNAME" );
        if (pszUserRealm != NULL)
        {
            strcpy(PrincipalBuffer, pszUserRealm);
        }
        if ((pszUserRealm != NULL) &&
            (pszUserName != NULL))
        {
            strcat(PrincipalBuffer, "\\");
        }
        if (pszUserName != NULL)
        {
            strcat(PrincipalBuffer, pszUserName);
        }
        pszPrincipal = PrincipalBuffer;

    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
        pszProtocolSequence,
        pszNetworkAddress,
        pszEndpoint,
        pszOptions,
        &pszStringBinding);

    if (status)
    {
        printf("RpcStringBindingCompose returned %d\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);

    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
        &BindingHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned %d\n", status);
        exit(2);
    }


    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status)
    {
        printf("RpcStringFree returned %d\n", status);
        exit(2);
    }

    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, pszPrincipal);
    status = RpcBindingSetAuthInfo(BindingHandle,
        pszPrincipal,
        AuthnLevel,
        AuthnService,
        sID.UserLength || sID.DomainLength || sID.PasswordLength ? &sID : NULL,
        RPC_C_AUTHZ_NAME);

    if ( status )
    {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }

    //
    // Do the actual RPC calls to the server.
    //

    RpcTryExcept
    {
        for (i = 0; i < LoopCount; i++)
        {
            status = RemoteCall(
                BindingHandle,
                0,                      // no options for now
                pszDelegationAddress,
                pszProtocolSequence,
                pszEndpoint,
                pszPrincipal,
                pszNetworkAddress,
                AuthnLevel,
                AuthnService,
                RecursionLevel
                );
            if (status != 0)
            {
                printf("RemoteCall failed: 0x%x\n",status);
                break;
            }
        }

        if (ShutdownService)
        {
            Shutdown( BindingHandle );
        }
    }
    RpcExcept(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Runtime library reported an exception %d\n", RpcExceptionCode());

    } RpcEndExcept


    // The calls to the remote procedures are complete.
    // Free the binding handle

    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status)
    {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }

    return 0;
}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\rpc\server\sspiserv.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    sspiserv.cxx

Abstract:

    sspiserv

Author:

    Larry Zhu (LZhu)                       Januray 1, 2002

Revision History:

--*/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include <hresult.hxx>
#include <ntsecapi.h>
#include <output.hxx>
#include <lsasspi.hxx>

#include "sspitest.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -s authn service\n");
    fprintf(stderr, " -t target service principal name\n");
    exit(1);
}

HANDLE TerminateEvent;
ULONG AuthnService = RPC_C_AUTHN_GSS_NEGOTIATE;

INT __cdecl
main(
    INT argc,
    PSTR argv[]
    )
{
    RPC_STATUS status;
    PSTR pszProtocolSequence = "ncacn_ip_tcp";
    PSTR pszEndpoint = "10";
    PSTR pszOptions = NULL;
    PSTR pszStringBinding = NULL;
    PSTR PrincipalName = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (tolower(*(argv[i]+1)))
            {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 's':
                AuthnService = strtol(argv[++i], NULL, 0);
                break;
            case 't':
                PrincipalName = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEventA(
        NULL,  // No security attributes
        TRUE,  // Must be manually reset
        FALSE, // Initially not signaled
        NULL   // No name
        );

    if (TerminateEvent == NULL)
    {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    printf("Server using protseq %s endpoint %s\n", pszProtocolSequence, pszEndpoint);
    status = RpcServerUseProtseqEpA(
        (UCHAR*) pszProtocolSequence,
        3, // maximum concurrent calls
        (UCHAR*)pszEndpoint,
        0
        );
    if (status)
    {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(srv_sspitest_ServerIfHandle, 0, 0);
    if (status)
    {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    printf("RpcServerRegisterAuthInfoA AuthnService %#x, PrincipalName %s\n", AuthnService, PrincipalName);

    status = RpcServerRegisterAuthInfoA(
        (UCHAR*) PrincipalName,
        AuthnService,
        NULL,  // GetKeyFn
        NULL // Arg to GetKeyFn
        );

    if (status)
    {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerInqDefaultPrincNameA(
        AuthnService,
        (UCHAR**)&PrincipalName
        );
    if (status)
    {
        printf("RpcServerInqDefaultPrincName returned %d\n", status);
        exit(2);
    }

    printf("RpcServerInqDefaultPrincNameA obtained AuthnService %#x, PrincipalName %s\n", AuthnService, PrincipalName);

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(
        1, //MinimumCallThreads
        12345, // MaxCalls
        TRUE // DontWait
        );
    if (status)
    {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject(TerminateEvent, INFINITE);

    if ( WaitStatus != WAIT_OBJECT_0)
    {
        printf("Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError());
        return 2;
    }

    return ERROR_SUCCESS;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API
MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API
MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

ULONG
RecurseRemoteCall(
    ULONG Options,
    PSTR RemoteAddress,
    PSTR RemoteProtocol,
    PSTR RemoteEndpoint,
    PSTR Principal,
    PSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{
    PSTR pszStringBinding = NULL;
    RPC_STATUS status;
    handle_t BindingHandle;

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingComposeA(NULL,
        (UCHAR*) RemoteProtocol,
        (UCHAR*) RemoteAddress,
        (UCHAR*) RemoteEndpoint,
        NULL, // no network options
        (UCHAR**) &pszStringBinding);

    if (status)
    {
        printf("RpcStringBindingCompose returned %d\n", status);
        return(status);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);

    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBindingA((UCHAR*) pszStringBinding,
        &BindingHandle);

    RpcStringFree((UCHAR**) &pszStringBinding);

    if (status)
    {
        printf("RpcBindingFromStringBinding returned %d\n", status);
        return (status);
    }

    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, Principal);
    status = RpcBindingSetAuthInfoA(
        BindingHandle,
        (UCHAR*)Principal,
        AuthnLevel,
        AuthnService,
        NULL,  // no SID
        RPC_C_AUTHZ_NAME);

    if (status)
    {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        return( status );
    }

    //
    // Do the actual RPC calls to the server.
    //

    RpcTryExcept
    {
        status = RemoteCall(
            BindingHandle,
            Options,
            (UCHAR*) Address,
            (UCHAR*) RemoteProtocol,
            (UCHAR*) RemoteEndpoint,
            (UCHAR*) Principal,
            (UCHAR*) RemoteAddress,
            AuthnLevel,
            AuthnService,
            RecursionLevel
            );
        if (status != ERROR_SUCCESS)
        {
            printf("RemoteCall failed: 0x%x\n",status);
        }
    }
    RpcExcept(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Runtime library reported an exception %d\n", RpcExceptionCode());

    } RpcEndExcept

    // The calls to the remote procedures are complete.
    // Free the binding handle

    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status)
    {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }

    return status;
}

ULONG
srv_RemoteCall(
    handle_t BindingHandle,
    ULONG Options,
    UCHAR* RemoteAddress,
    UCHAR* RemoteProtocol,
    UCHAR* RemoteEndpoint,
    UCHAR* Principal,
    UCHAR* Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{
    RPC_STATUS RpcStatus;
    CHAR ClientName[100];
    ULONG NameLen = sizeof(ClientName);

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK )
    {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
        goto Cleanup;
    }
    GetUserName(ClientName,&NameLen);
    printf("Recursion %d: Client called: name = %s\n", RecursionLevel, ClientName);

    if (RecursionLevel != 0)
    {
        RpcStatus = RecurseRemoteCall(
            Options,
            (PSTR) RemoteAddress,
            (PSTR) RemoteProtocol,
            (PSTR) RemoteEndpoint,
            (PSTR) Principal,
            (PSTR) Address,
            AuthnLevel,
            AuthnSvc,
            RecursionLevel - 1
            );
    }
    (void) RpcRevertToSelf(); // could fail?

Cleanup:

    return(RpcStatus);
}

void
srv_Shutdown(
    handle_t BindingHandle
    )
{
    RPC_STATUS status;

    status = RpcMgmtStopServerListening(NULL);
    if (status)
    {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status)
    {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) )
    {
        printf("Couldn't SetEvent %ld\n", GetLastError());
    }
}

unsigned long srv_ReadRegistryValueData(
    /* [in] */ handle_t BindingHandle,
    /* [in] */ unsigned long RootKeyLower,
    /* [unique][string][in] */ unsigned char *pszRegistryKey,
    /* [unique][string][in] */ unsigned char *pszRegistryValue,
    /* [in] */ unsigned long cbBuf,
    /* [size_is][unique][out][in] */ unsigned char *pBuf,
    /* [out] */ unsigned long *pDataType,
    /* [out] */ unsigned long *pcbReturned)
{
    THResult hRetval;

    HKEY KeyRoot = ( HKEY ) (ULONG_PTR)((LONG)(0x80000000 | RootKeyLower));  // open registry key to Lsa\MSV1_0

    HKEY KeyHandle = NULL;

    ULONG RegValueType = 0;
    ULONG RegValue = 0;
    ULONG RegValueSize = 0;

    hRetval DBGCHK = HResultFromWin32(RpcImpersonateClient(BindingHandle));

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "*********srv_ReadRegistryValueData checking client user data************\n");
        hRetval DBGCHK = CheckUserData();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = HResultFromWin32(RegOpenKey(KeyRoot, (PSTR) pszRegistryKey, &KeyHandle));
    }

    if (SUCCEEDED(hRetval))
    {
        RegValueSize = sizeof(RegValue);

        hRetval DBGCHK = HResultFromWin32(
            RegQueryValueExA(
                KeyHandle,
                (PSTR) pszRegistryValue,
                0, // reserved
                &RegValueType,
                pBuf,
                &cbBuf
                ));
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "srv_ReadRegistryValueData KeyRoot %#x, Key %s, Value %s, type %#x\n", KeyRoot, pszRegistryKey, pszRegistryValue, RegValueType);
        DebugPrintHex(SSPI_LOG, "ValueData", cbBuf, pBuf);

        *pcbReturned = cbBuf;
    }

    (void) RpcRevertToSelf(); // could fail?

    return HRESULT_CODE(hRetval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\rights\rights.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rights.cxx

Abstract:

    rights

Author:

    Larry Zhu (LZhu)                      December 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "rights.hxx"

NTSTATUS
OpenPolicy(
    IN OPTIONAL PWSTR pszServer,
    IN DWORD DesiredAccess,
    IN PLSA_HANDLE phPolicy
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {0};
    LSA_UNICODE_STRING ServerString = {0};
    PLSA_UNICODE_STRING pServer = NULL;

    if (pszServer != NULL)
    {
        RtlInitUnicodeString(&ServerString, pszServer);
        pServer = &ServerString;
    }

    return LsaOpenPolicy(
        pServer,
        &ObjectAttributes,
        DesiredAccess,
        phPolicy
        );
}

BOOL
GetAccountSid(
    PCWSTR pszServer,
    PCWSTR pszAccount,
    PSID *ppSid
    )
{
    WCHAR szReferencedDomain[MAX_PATH + 1] = {0};
    DWORD cbSid = 0;               // initial allocation attempt
    DWORD cchReferencedDomain = 0; // initial allocation size
    SID_NAME_USE eUse;

    *ppSid = NULL;

    if (!LookupAccountName(
        pszServer,          // machine to lookup account on
        pszAccount,         // account to lookup
        NULL,               // SID of interest
        &cbSid,             // size of SID
        NULL,               // domain account was found on
        &cchReferencedDomain,
        &eUse
        ) && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
    {
        cchReferencedDomain = COUNTOF(szReferencedDomain) - 1;
        *ppSid = new CHAR[cbSid];
    }

    return *ppSid && LookupAccountName(
        pszServer,          // machine to lookup account on
        pszAccount,         // account to lookup
        *ppSid,             // SID of interest
        &cbSid,             // size of SID
        szReferencedDomain, // domain account was found on
        &cchReferencedDomain,
        &eUse
        );
}

NTSTATUS
SetAccountSystemAccess(
    LSA_HANDLE hPolicy,
    PSID pAccountSid,
    ULONG NewAccess
    )
{
    TNtStatus Status;

    LSA_HANDLE hAccount = NULL;

    ULONG PreviousAccess = 0;

    DBGCFG1(Status, STATUS_OBJECT_NAME_NOT_FOUND);

    Status DBGCHK = LsaOpenAccount(
        hPolicy,
        pAccountSid,
        ACCOUNT_ADJUST_SYSTEM_ACCESS | ACCOUNT_VIEW,
        &hAccount
        );

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
    {
        Status DBGCHK = LsaCreateAccount(
            hPolicy,
            pAccountSid,
            ACCOUNT_ADJUST_SYSTEM_ACCESS | ACCOUNT_VIEW,
            &hAccount
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaGetSystemAccessAccount(
            hAccount,
            &PreviousAccess
            );
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "SetSystemAccessToAccount setting SystemAccess from %#x to %#x\n", PreviousAccess, NewAccess);

        Status DBGCHK = LsaSetSystemAccessAccount(
            hAccount,
            NewAccess
            );
    }

    if (hAccount)
    {
        LsaClose(hAccount);
    }

    return Status;
}

VOID
Usage(
    IN PCWSTR pszProgramName
    )
{
    DebugPrintf(SSPI_LOG, "Usage:  %ws -a <account name> -p <privilege to add> -P <privilege to remove> -r <system access to set> -s <server name>\n", pszProgramName);
    DebugPrintf(SSPI_LOG, "example system access are SECURITY_ACCESS_INTERACTIVE_LOGON and SECURITY_ACCESS_DENY_SERVICE_LOGON\n");
    exit(1);
}

NTSTATUS
EnumRights(
    IN LSA_HANDLE hPolicy,
    IN PSID pAccountSid
    )
{
    TNtStatus Status;

    PPRIVILEGE_SET pPrivSet = {0};
    PUNICODE_STRING pPrivName = NULL;
    PUNICODE_STRING pPrivDisplayName = NULL;
    LSA_HANDLE hAccount = NULL;

    SHORT Language = 0;
    ULONG SystemAccess = 0;
    CHAR szLine[MAX_PATH] = {0};

    DebugPrintf(SSPI_LOG, "Enumerate logon rights and privileges for account:\n");

    Status DBGCHK = LsaOpenAccount(
        hPolicy,
        pAccountSid,
        ACCOUNT_ADJUST_SYSTEM_ACCESS | ACCOUNT_VIEW,
        &hAccount
        );

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaEnumeratePrivilegesOfAccount(
            hAccount,
            &pPrivSet
            );
    }

    for (ULONG i = 0; NT_SUCCESS(Status) && (i < pPrivSet->PrivilegeCount); i++)
    {
        pPrivName = NULL;
        pPrivDisplayName = NULL;
        INT cchUsed = 0;

        cchUsed = _snprintf(szLine, COUNTOF(szLine) - 1, "\nLUID %#x:%#x Attributes %#x ",
            pPrivSet->Privilege[i].Luid.HighPart,
            pPrivSet->Privilege[i].Luid.LowPart,
            pPrivSet->Privilege[i].Attributes);

        Status DBGCHK = LsaLookupPrivilegeName(
            hPolicy,
            &pPrivSet->Privilege[i].Luid,
            &pPrivName
            );

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = LsaLookupPrivilegeDisplayName(
                hPolicy,
                pPrivName,
                &pPrivDisplayName,
                &Language
                );
        }

        if (NT_SUCCESS(Status))
        {
            if (cchUsed >= 0)
            {
                _snprintf(szLine + cchUsed, COUNTOF(szLine) - 1 - cchUsed, "\tName = %wZ, Display name = %wZ, Language = %d\n",
                    pPrivName, pPrivDisplayName, Language);
            }
            DebugPrintf(SSPI_LOG, "Privilege %d\n%s\n", i, szLine);
        }

        if (pPrivDisplayName)
        {
            LsaFreeMemory(pPrivDisplayName->Buffer);
            LsaFreeMemory(pPrivDisplayName);
            pPrivDisplayName = NULL;
        }
        if (pPrivName)
        {
            LsaFreeMemory(pPrivName->Buffer);
            LsaFreeMemory(pPrivName);
            pPrivName = NULL;
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaGetSystemAccessAccount(
            hAccount,
            &SystemAccess
            );
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "System access for account = 0x%x\n", SystemAccess);
    }

    if (pPrivSet)
    {
        LsaFreeMemory(pPrivSet);
    }

    if (hAccount)
    {
        LsaClose(hAccount);
    }

    return Status;
}

VOID __cdecl
_tmain(
    IN INT argc,
    IN PTSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    PSID pSid = NULL;
    HANDLE hPolicy = NULL;

    PWSTR pszComputer = NULL;
    PWSTR pszAccount = NULL;
    UNICODE_STRING Privilege = {0};
    ULONG Access = 0;
    BOOLEAN bIsRemove = FALSE;
    BOOLEAN bSetLogonRights = FALSE;

    for (INT i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (*(argv[i] + 1))
            {
            case 'a':
                pszAccount = argv[++i];
                break;
            case 'p':
                RtlInitUnicodeString(&Privilege, argv[++i]);
                break;
            case 'P':
                RtlInitUnicodeString(&Privilege, argv[++i]);
                bIsRemove = TRUE;
                break;
            case 'r':
                bSetLogonRights = TRUE;
                Access = wcstol(argv[++i], NULL, 0);
                break;
            case 's':
                pszComputer = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    Status DBGCHK = OpenPolicy(
        pszComputer,          // target machine
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &hPolicy              // resultant policy handle
        );

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetAccountSid(
            NULL,       // default lookup logic
            pszAccount, // account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            ) ? S_OK : GetLastErrorAsHResult();
    }

    if (NT_SUCCESS(Status) && Privilege.Length && Privilege.Buffer)
    {
        if (!bIsRemove)
        {
            DebugPrintf(SSPI_LOG, "Adding Privilege %wZ\n", &Privilege);

            Status DBGCHK = LsaAddAccountRights(
                hPolicy,      // open policy handle
                pSid,         // target SID
                &Privilege,   // privileges
                1             // privilege count
                );
        }
        else
        {
            DebugPrintf(SSPI_LOG, "Removing Privilege %wZ\n", &Privilege);

            Status DBGCHK = LsaRemoveAccountRights(
                hPolicy,      // open policy handle
                pSid,         // target SID
                FALSE,        // do not disable all rights
                &Privilege,   // privileges
                1             // privilege count
                );
        }
    }

    if (NT_SUCCESS(Status) && bSetLogonRights)
    {
        Status DBGCHK = SetAccountSystemAccess(
            hPolicy,
            pSid,
            Access
            );
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "SystemAccess/Privilege is applied to account %ws on server %ws\n", pszAccount, pszComputer ? pszComputer : L"localhost");

        Status DBGCHK = EnumRights(hPolicy, pSid);
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "Failed to apply SystemAccess/Privilege to account %ws on server %ws\n", pszAccount, pszComputer ? pszComputer : L"localhost");
    }

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    if (pSid)
    {
        delete [] pSid;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\rpc\client2\sspicli.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    sspicli.cxx

Abstract:

    sspicli

Author:

    Larry Zhu (LZhu)                       Januray 1, 2002

Revision History:

--*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include <output.hxx>
#include <assert.h>
#include "sspitest.h"     // header file generated by MIDL compiler

#ifndef COUNTOF

#define COUNTOF(s) ( sizeof( (s) ) / sizeof( *(s) ) )

#endif // COUNTOF

INT Usage(PSTR pszProgramName)
{
    DebugPrintf(SSPI_ERROR, "Usage:  %s\n", pszProgramName);
    DebugPrintf(SSPI_ERROR, " -protocolsequence protocol_sequence\n");
    DebugPrintf(SSPI_ERROR, " -networkaddress network_address\n");
    DebugPrintf(SSPI_ERROR, " -delegationaddress delegation address\n");
    DebugPrintf(SSPI_ERROR, " -endpoint endpoint\n");
    DebugPrintf(SSPI_ERROR, " -networkoptions network options\n");
    DebugPrintf(SSPI_ERROR, " -authnlevel authn level\n");
    DebugPrintf(SSPI_ERROR, " -imperlevel impersonation level\n");
    DebugPrintf(SSPI_ERROR, " -authnservice authn service\n");
    DebugPrintf(SSPI_ERROR, " -user username\n");
    DebugPrintf(SSPI_ERROR, " -password password\n");
    DebugPrintf(SSPI_ERROR, " -domain domain\n");
    DebugPrintf(SSPI_ERROR, " -shutdown shutdownserver\n");
    DebugPrintf(SSPI_ERROR, " -serviceprincipalname target principal\n");
    exit(1);
}

#ifndef UNLEN
#define UNLEN 256
#endif

INT __cdecl
main(
    INT argc,
    PSTR argv[]
    )
{
    RPC_STATUS status;     // returned by RPC API function

    INT mark = 1;

    PSTR pszProtocolSequence = "ncacn_ip_tcp";
    PSTR pszNetworkAddress = NULL;
    PSTR pszEndpoint = "10";
    PSTR pszOptions = NULL;
    PSTR pszStringBinding = NULL;
    PSTR pszDelegationAddress = NULL;
    PSTR pszPrincipal = NULL;
    CHAR PrincipalBuffer[UNLEN] = {0};
    ULONG PrincipalLength;
    ULONG AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
    ULONG AuthnService = RPC_C_AUTHN_WINNT;
    BOOLEAN ShutdownService = FALSE;

    handle_t BindingHandle = NULL;

    SEC_WINNT_AUTH_IDENTITY_A sID = {0};
    ULONG RootKey = (ULONG) (ULONG_PTR) HKEY_LOCAL_MACHINE;

    UCHAR RegValue[MAX_PATH] = {0};
    ULONG RegValueType = 0;
    ULONG cbRegValue = 0;
    RPC_SECURITY_QOS SecurityQos = {0};

    PSTR pszKeys[] = {
        "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
        "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
        "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
    };
    PSTR pszValues[] = {
        "ntlmminclientsec",
        "ntlmminserversec",
        "Auth1"
    };

    sID.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    SecurityQos.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
    SecurityQos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    SecurityQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE; // RPC_C_IMP_LEVEL_IDENTIFY;

    assert(COUNTOF(pszKeys) == COUNTOF(pszValues));

    argc--;

    // allow the user to override settings with command line switches
    while (argc)
    {
        if (!strcmp(argv[mark], "-protocolsequence") && (argc > 1))
        {
            argc--; mark++;
            pszProtocolSequence = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-networkaddress") && (argc > 1))
        {
            argc--; mark++;
            pszNetworkAddress = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-delegationaddress") && (argc > 1))
        {
            argc--; mark++;
            pszDelegationAddress = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-endpoint") && (argc > 1))
        {
            argc--; mark++;
            pszEndpoint = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-networkoptions") && (argc > 1))
        {
            argc--; mark++;
            pszOptions = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serviceprincipalname") && (argc > 1))
        {
            argc--; mark++;
            pszPrincipal = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-user") && (argc > 1))
        {
            argc--; mark++;
            sID.User = (UCHAR*) argv[mark]; sID.UserLength = strlen((PSTR) sID.User);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-domain") && (argc > 1))
        {
            argc--; mark++;
            sID.Domain = (UCHAR*) argv[mark]; sID.DomainLength = strlen((PSTR) sID.Domain);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-password") && (argc > 1))
        {
            argc--; mark++;
            sID.Password = (UCHAR*) argv[mark]; sID.PasswordLength = strlen((PSTR) sID.Password);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-key1") && (argc > 1))
        {
            argc--; mark++;
            pszKeys[0] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-value1") && (argc > 1))
        {
            argc--; mark++;
            pszValues[0] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-key2") && (argc > 1))
        {
            argc--; mark++;
            pszKeys[1] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-value2") && (argc > 1))
        {
            argc--; mark++;
            pszValues[1] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-key3") && (argc > 1))
        {
            argc--; mark++;
            pszKeys[2] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-value3") && (argc > 1))
        {
            argc--; mark++;
            pszValues[2] = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-rootkey") && (argc > 1))
        {
            argc--; mark++;
            RootKey = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-authnlevel") && (argc > 1))
        {
            argc--; mark++;
            AuthnLevel = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-imperlevel") && (argc > 1))
        {
            argc--; mark++;
            SecurityQos.ImpersonationType = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-authnservice") && (argc > 1))
        {
            argc--; mark++;
            AuthnService = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-shutdown"))
        {
            argc--; mark++;
            ShutdownService = TRUE;
        }
        else if (!strcmp(argv[mark], "-h") || !strcmp(argv[mark], "-?"))
        {
            argc--; mark++;
            Usage(argv[0]);
        }
        else
        {
            Usage(argv[0]);
        }
    }

    //
    // If the principal is NULL, get it from the environment
    //

    if (pszPrincipal == NULL)
    {
        DebugPrintf(SSPI_WARN, "!!!!!!!!!!!!!!!Targeted service principal name is not provided!!!!!\n");
    }

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingComposeA(NULL,
        (UCHAR*) pszProtocolSequence,
        (UCHAR*) pszNetworkAddress,
        (UCHAR*) pszEndpoint,
        (UCHAR*) pszOptions,
        (UCHAR**) &pszStringBinding);

    if (status)
    {
        DebugPrintf(SSPI_LOG, "RpcStringBindingCompose returned %d\n", status);
        exit(2);
    }
    DebugPrintf(SSPI_LOG, "pszStringBinding = %s\n", pszStringBinding);

    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBindingA((UCHAR*) pszStringBinding,
        &BindingHandle);
    if (status)
    {
        DebugPrintf(SSPI_LOG, "RpcBindingFromStringBinding returned %d\n", status);
        exit(2);
    }

    status = RpcStringFreeA((UCHAR**) &pszStringBinding);   // remote calls done; unbind
    if (status)
    {
        DebugPrintf(SSPI_LOG, "RpcStringFree returned %d\n", status);
        exit(2);
    }

    //
    // Tell RPC to do the security thing.
    //

    DebugPrintf(SSPI_LOG,
        "Binding auth info user %s, userlen %#x, domain %s, domanlen %#x, password %s, passwordlen %#x, sid flag %#x, "
        "set to level %d, service %d, principal %s, SecurityQos.ImpersonationType %#x\n",
        sID.User, sID.UserLength, sID.Domain, sID.DomainLength, sID.Password, sID.PasswordLength, sID.Flags,
        AuthnLevel, AuthnService, pszPrincipal, SecurityQos.ImpersonationType);

    status = RpcBindingSetAuthInfoExA(BindingHandle,
        (UCHAR*) pszPrincipal,
        AuthnLevel,
        AuthnService,
        (sID.UserLength || sID.DomainLength || sID.PasswordLength) ? &sID : NULL,
        RPC_C_AUTHZ_NAME,
        &SecurityQos);

    if ( status )
    {
        DebugPrintf(SSPI_LOG, "RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }

    //
    // Do the actual RPC calls to the server.
    //

    RpcTryExcept
    {
        for (ULONG i = 0; i < COUNTOF(pszKeys); i++)
        {
            status = ReadRegistryValueData(
                BindingHandle,
                RootKey,
                (UCHAR*) pszKeys[i],
                (UCHAR*) pszValues[i],
                sizeof(RegValue),
                RegValue,
                &RegValueType,
                &cbRegValue
                );

            if (status == ERROR_SUCCESS)
            {
                DebugPrintf(SSPI_LOG, "RootKey %#x, Key %s, Value %s, RegValueType %#x, cbRegValue %#x\n",
                    RootKey, pszKeys[i], pszValues[i], RegValueType, cbRegValue);
                DebugPrintHex(SSPI_LOG, "RegValue", cbRegValue, RegValue);
            }
            else
            {
                DebugPrintf(SSPI_ERROR, "RootKey %#x, Key %s, Value %s, status %#x\n",
                    RootKey, pszKeys[i], pszValues[i], status);
            }
        }
        if (ShutdownService)
        {
            Shutdown( BindingHandle );
        }
    }
    RpcExcept(EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintf(SSPI_LOG, "Runtime library reported an exception %d\n", RpcExceptionCode());

    } RpcEndExcept


    // The calls to the remote procedures are complete.
    // Free the binding handle

    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status)
    {
        DebugPrintf(SSPI_LOG, "RpcBindingFree returned %d\n", status);
        exit(2);
    }

    return 0;
}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\msvsharelevelsrv.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msvsharelevelsrv.cxx

Abstract:

    msvsharelevel server

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "msvsharelevelsrv.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\sspi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sspi.cxx

Abstract:

    sspi

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspi.hxx"

#include "sspicli.hxx"
#include "sspisrv.hxx"

HRESULT
DoSspiServerWork(
    IN PCtxtHandle phSrvCtxt,
    IN SOCKET ServerSocket,
    IN SOCKET ClientSocket
    )
{
    THResult hRetval = E_FAIL;

    SecBufferDesc MessageDesc = {0};
    SecBuffer SecBuffers[3] = {0};
    CHAR DataBuffer[20] = {0};
    CHAR TokenBuffer[100] = {0};
    CHAR PaddingBlock[512] = {0};

    SecPkgContext_Sizes ContextSizes = {0};
    ULONG fQOP = 0;
    ULONG MessageSeqNo = 0;

    hRetval DBGCHK = QueryContextAttributesA(
                        phSrvCtxt,
                        SECPKG_ATTR_SIZES,
                        &ContextSizes
                        );

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ( (sizeof(TokenBuffer) >= ContextSizes.cbSecurityTrailer)
                            && (sizeof(TokenBuffer) >= ContextSizes.cbMaxSignature)
                            && (sizeof(PaddingBlock) >= ContextSizes.cbBlockSize) )
                        ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbMaxSignature;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;
        
        #if 0
        
        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;
        
        #endif
        
        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - 1;
        MessageDesc.ulVersion = 0;

        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 1 (token)\n");

        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer,
                            &SecBuffers[0].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 2 (data)\n");

        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer,
                            &SecBuffers[1].cbBuffer);
    }

    #if 0
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 3 (padding)\n");
    
        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer,
                            &SecBuffers[2].cbBuffer);
    }
    
    #endif    

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork VerifySignature %#x\n", MessageSeqNo);

        hRetval DBGCHK = VerifySignature(
                            phSrvCtxt,
                            &MessageDesc,
                            MessageSeqNo,
                            &fQOP
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - (ContextSizes.cbBlockSize > 1 ? 0 : 1);
        MessageDesc.ulVersion = 0;

        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 3 (token)\n");

        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer,
                            &SecBuffers[0].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 4 (data)\n");

        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer,
                            &SecBuffers[1].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 5 (padding)\n");
    
        hRetval DBGCHK = ReadMessage(ServerSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer,
                            &SecBuffers[2].cbBuffer);
    }
    

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork DecryptMessage %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = DecryptMessage(
                            phSrvCtxt,
                            &MessageDesc,
                            ++MessageSeqNo,
                            &fQOP
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers);
        MessageDesc.ulVersion = 0;

        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - (ContextSizes.cbBlockSize > 1 ? 0 : 1);
        MessageDesc.ulVersion = 0;

        DebugPrintf(SSPI_LOG, "DoSspiServerWork EncryptMessage %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = EncryptMessage(
                            phSrvCtxt,
                            fQOP,
                            &MessageDesc,
                            ++MessageSeqNo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts writing 1 (token)\n");
        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts writing 2 (data)\n");

        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts reading 3 (padding)\n");
    
        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbMaxSignature;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;
        
        #if 0
        
        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;
        
        #endif
        
        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - 1;
        MessageDesc.ulVersion = 0;

        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        DebugPrintf(SSPI_LOG, "DoSspiServerWork MakeSignature %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = MakeSignature(
                            phSrvCtxt,
                            fQOP,
                            &MessageDesc,
                            ++MessageSeqNo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts writing 4 (token)\n");

        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts writing 5 (data)\n");

        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer);
    }

    #if 0
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiServerWork starts writing 6 (padding)\n");
    
        hRetval DBGCHK = WriteMessage(ClientSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer);
    }

    #endif
    
    return hRetval;
}

HRESULT
DoSspiClientWork(
    IN PCtxtHandle phCliCtxt,
    IN SOCKET ServerSocket,
    IN SOCKET ClientSocket
    )
{
    THResult hRetval = E_FAIL;

    SecBufferDesc MessageDesc = {0};
    SecBuffer SecBuffers[3] = {0};
    CHAR DataBuffer[20] = {0};
    CHAR TokenBuffer[100] = {0};
    CHAR PaddingBlock[512] = {0};

    SecPkgContext_Sizes ContextSizes = {0};
    ULONG fQOP = 0;
    ULONG MessageSeqNo = 0;

    hRetval DBGCHK = QueryContextAttributesA(
                        phCliCtxt,
                        SECPKG_ATTR_SIZES,
                        &ContextSizes
                        );

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ( (sizeof(TokenBuffer) >= ContextSizes.cbSecurityTrailer)
                            && (sizeof(TokenBuffer) >= ContextSizes.cbMaxSignature) 
                            && (sizeof(PaddingBlock) >= ContextSizes.cbBlockSize) )
                        ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbMaxSignature;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        #if 0
        
        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        #endif
        
        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - 1;
        MessageDesc.ulVersion = 0;

        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        DebugPrintf(SSPI_LOG, "DoSspiClientWork MakeSignature %#x\n", MessageSeqNo);

        hRetval DBGCHK = MakeSignature(
                            phCliCtxt,
                            fQOP,
                            &MessageDesc,
                            MessageSeqNo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 1 (token)\n");

        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 2 (data)\n");

        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer);
    }

    #if 0
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 3 (padding)\n");
    
        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer);
    }
    
    #endif

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - (ContextSizes.cbBlockSize > 1 ? 0 : 1);
        MessageDesc.ulVersion = 0;

        memset(
            DataBuffer,
            0xeb,
            sizeof(DataBuffer)
            );

        DebugPrintf(SSPI_LOG, "DoSspiClientWork EncryptMessage %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = EncryptMessage(
                            phCliCtxt,
                            fQOP,
                            &MessageDesc,
                            ++MessageSeqNo
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 3 (token)\n");

        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 4 (data)\n");

        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts writing 5 (padding)\n");
    
        hRetval DBGCHK = WriteMessage(ServerSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer);
    }


    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - (ContextSizes.cbBlockSize > 1 ? 0 : 1);
        MessageDesc.ulVersion = 0;

        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 1 (token)\n");

        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer,
                            &SecBuffers[0].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 2 (data)\n");
        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer,
                            &SecBuffers[1].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 3 (padding)\n");

        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer,
                            &SecBuffers[2].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork DecryptMessage %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = DecryptMessage(
                            phCliCtxt,
                            &MessageDesc,
                            ++MessageSeqNo,
                            &fQOP
                            );    
    }

    if (SUCCEEDED(hRetval))
    {
        SecBuffers[0].pvBuffer = TokenBuffer;
        SecBuffers[0].cbBuffer = ContextSizes.cbMaxSignature;
        SecBuffers[0].BufferType = SECBUFFER_TOKEN;

        SecBuffers[1].pvBuffer = DataBuffer;
        SecBuffers[1].cbBuffer = sizeof(DataBuffer);
        SecBuffers[1].BufferType = SECBUFFER_DATA;

        #if 0
        
        SecBuffers[2].pvBuffer = PaddingBlock;
        SecBuffers[2].cbBuffer = ContextSizes.cbBlockSize > 1 ? ContextSizes.cbBlockSize : 0;
        SecBuffers[2].BufferType = SECBUFFER_PADDING;

        #endif
        
        MessageDesc.pBuffers = SecBuffers;
        MessageDesc.cBuffers = RTL_NUMBER_OF(SecBuffers) - 1;
        MessageDesc.ulVersion = 0;

        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 4 (token)\n");

        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[0].cbBuffer,
                            SecBuffers[0].pvBuffer,
                            &SecBuffers[0].cbBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 5 (data)\n");

        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[1].cbBuffer,
                            SecBuffers[1].pvBuffer,
                            &SecBuffers[1].cbBuffer);
    }

    #if 0
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork starts reading 6 (padding)\n");
    
        hRetval DBGCHK = ReadMessage(ClientSocket,
                            SecBuffers[2].cbBuffer,
                            SecBuffers[2].pvBuffer,
                            &SecBuffers[2].cbBuffer);
    }
    
    #endif
    
    
    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "DoSspiClientWork VerifySignature %#x\n", MessageSeqNo + 1);

        hRetval DBGCHK = VerifySignature(
                            phCliCtxt,
                            &MessageDesc,
                            ++MessageSeqNo,
                            &fQOP
                            );
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\sspicli.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sspicli.cxx

Abstract:

    sspicli

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspicli.hxx"

TSspiClientParam::TSspiClientParam(
    VOID
    ) : pszTargetName(NULL),
    pszPrincipal(NULL),
    pCredLogonID(NULL),
    pszPackageName(NTLMSP_NAME_A),
    pAuthData(NULL),
    ClientFlags(ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY),
    TargetDataRep(SECURITY_NATIVE_DREP),
    ClientActionFlags(0),
    ProcessIdTokenUsedByClient(-1),
    pszS4uClientUpn(NULL),
    pszS4uClientRealm(NULL),
    S4u2SelfFlags(0)
{
}

HRESULT
GetClientSecurityContextHandle(
    IN TSspiClientParam* pCliParam,
    IN SOCKET ServerSocket,
    IN SOCKET ClientSocket,
    IN PCredHandle phClientCred,
    IN ULONG cbInBuf,
    IN CHAR* pInBuf,
    IN ULONG cbOutBuf,
    IN CHAR* pOutBuf,
    OUT PCtxtHandle phClientCtxt
    )
{
    THResult hRetval = S_OK;

    SECURITY_STATUS ProtocolStatus;
    THResult hProtocolStatus;

    ULONG ContextAttributes = 0;
    TimeStamp Lifetime = {0};
    CtxtHandle hClientCtxt;
    ULONG cbRead = 0;

    SecBufferDesc OutBuffDesc = {0};
    SecBuffer OutSecBuff = {0};
    SecBufferDesc InBuffDesc = {0};
    SecBuffer InSecBuff = {0};

    BOOL bIsContinueNeeded = FALSE;

    SecInvalidateHandle(phClientCtxt);
    SecInvalidateHandle(&hClientCtxt);

    //
    // prepare output buffer
    //

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.pBuffers = &OutSecBuff;

    OutSecBuff.cbBuffer = cbOutBuf;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer = pOutBuf;

    //
    // prepare input buffer
    //

    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers = 1;
    InBuffDesc.pBuffers = &InSecBuff;

    InSecBuff.cbBuffer = cbRead;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer = pInBuf;

    DebugPrintf(SSPI_LOG, "GetClientSecurityContextHandle calling InitializeSecurityContextA "
        "pszTargetName %s, ClientFlags %#x, TargetDataRep %#x, CredHandle %#x:%#x\n",
        pCliParam->pszTargetName, pCliParam->ClientFlags, pCliParam->TargetDataRep,
        phClientCred->dwUpper, phClientCred->dwLower);

    hRetval DBGCHK = InitializeSecurityContextA(
                        phClientCred,
                        NULL,  // No Client context yet
                        pCliParam->pszTargetName,
                        pCliParam->ClientFlags,
                        0,     // Reserved 1
                        pCliParam->TargetDataRep,
                        NULL,  // No initial input token
                        0,     // Reserved 2
                        &hClientCtxt,
                        &OutBuffDesc,
                        &ContextAttributes,
                        &Lifetime
                        );

    bIsContinueNeeded = (S_OK == IsContinueNeeded(hRetval));

    DebugPrintf(SSPI_LOG, "GetClientSecurityContextHandle ISC bIsContinueNeeded %#x, hRetval %#x\n", bIsContinueNeeded, (HRESULT) hRetval);

    if (S_OK == IsCompleteNeeded(hRetval))
    {
        THResult hr;

        hr DBGCHK = CompleteAuthToken(&hClientCtxt, &OutBuffDesc);

        if (FAILED(hr)) // retain continue needed info
        {
            hRetval DBGNOCHK = hr;
        }
    }

    ProtocolStatus = (HRESULT) hRetval;
    hProtocolStatus DBGCHK = WriteMessage(ServerSocket,
                                sizeof(ProtocolStatus),
                                &ProtocolStatus);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = hProtocolStatus;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = WriteMessage(ServerSocket,
                            OutSecBuff.cbBuffer,
                            OutSecBuff.pvBuffer);
    }

    while (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReadMessage(ClientSocket,
                            sizeof(ProtocolStatus),
                            &ProtocolStatus,
                            &cbRead);

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = ProtocolStatus;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = ReadMessage(ClientSocket,
                                cbInBuf,
                                pInBuf,
                                &cbRead);
        }
        else
        {
            break; // break out
        }

        if (SUCCEEDED(hRetval) && !bIsContinueNeeded)
        {
            hRetval DBGCHK = (S_OK != IsContinueNeeded(ProtocolStatus)) ? S_OK : E_ACCESSDENIED;
            break;
        }

        if (SUCCEEDED(hRetval))
        {
            InSecBuff.cbBuffer = cbRead;
            OutSecBuff.cbBuffer = cbOutBuf;

            DebugPrintf(SSPI_LOG, "GetClientSecurityContextHandle calling InitializeSecurityContextA "
                "pszTargetName %s, ClientFlags %#x, TargetDataRep %#x, hClientCtxt %#x:%#x\n",
                pCliParam->pszTargetName, pCliParam->ClientFlags, pCliParam->TargetDataRep,
                hClientCtxt.dwUpper, hClientCtxt.dwLower);

            hRetval DBGCHK = InitializeSecurityContextA(
                                NULL,  // no cred handle
                                &hClientCtxt,
                                pCliParam->pszTargetName,
                                pCliParam->ClientFlags,
                                0,
                                pCliParam->TargetDataRep,
                                &InBuffDesc,
                                0,
                                &hClientCtxt,
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime
                                );
        }

        bIsContinueNeeded = (S_OK == IsContinueNeeded(hRetval));

        DebugPrintf(SSPI_LOG, "GetClientSecurityContextHandle ISC bIsContinueNeeded %#x, hRetval %#x\n", bIsContinueNeeded, (HRESULT) hRetval);

        if (S_OK == IsCompleteNeeded(hRetval))
        {
            THResult hr;

            hr DBGCHK = CompleteAuthToken(&hClientCtxt, &OutBuffDesc);

            if (FAILED(hr)) // retain continue needed info
            {
                hRetval DBGNOCHK = hr;
            }
        }

        //
        // is server listening?
        //

        if (SUCCEEDED(hRetval))
        {
            if (S_OK != IsContinueNeeded(ProtocolStatus)) // no
            {
                hRetval DBGCHK = (SEC_E_OK == (HRESULT) hRetval) ? S_OK : E_ACCESSDENIED;
                break;
            }
        }

        ProtocolStatus = (HRESULT) hRetval;
        hProtocolStatus DBGCHK = WriteMessage(ServerSocket,
                                    sizeof(ProtocolStatus),
                                    &ProtocolStatus);

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = hProtocolStatus;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = WriteMessage(ServerSocket,
                                OutSecBuff.cbBuffer,
                                OutSecBuff.pvBuffer);
        }
    }

    if (SUCCEEDED(hRetval))
    {
        TimeStamp CurrentTime = {0};

        DebugPrintf(SSPI_LOG, "***********Client authentication succeeded:**********\n");

        DebugPrintf(SSPI_LOG, "ClientContextHandle: %#x:%#x, ContextAttributes: %#x\n",
             hClientCtxt.dwUpper, hClientCtxt.dwLower, ContextAttributes);
        DebugPrintLocalTime(SSPI_LOG, "Lifetime", &Lifetime);

        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "Current Time", &CurrentTime);

        *phClientCtxt = hClientCtxt;
        SecInvalidateHandle(&hClientCtxt)
    }

    THResult hr;

    if (SecIsValidHandle(&hClientCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hClientCtxt);
    }

    return hRetval;
}

HRESULT
GetClientImpToken(
    IN ULONG ProcessId,
    IN PCSTR pszPackageName,
    IN OPTIONAL PCSTR pszS4uClientUpn,
    IN OPTIONAL PCSTR pszS4uClientRealm,
    IN ULONG S4u2SelfFlags,
    OUT HANDLE* phToken
    )
{
    THResult hRetval = S_OK;

    UNICODE_STRING ClientUpn = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING Password = {0}; // ignored
    ULONG PackageId = 0;
    HANDLE hLsa = NULL;
    HANDLE hImpToken = NULL;

    TPrivilege* pPriv = NULL;

    *phToken = NULL;

    if (ProcessId != -1)
    {
        hRetval DBGCHK = GetProcessTokenByProcessId(ProcessId, &hImpToken);
    }
    else if (pszS4uClientRealm || pszS4uClientUpn)
    {
        hRetval DBGCHK = !_stricmp(pszPackageName, MICROSOFT_KERBEROS_NAME_A) ? S_OK : E_INVALIDARG;

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = CreateUnicodeStringFromAsciiz(pszS4uClientRealm, &ClientRealm);
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = CreateUnicodeStringFromAsciiz(pszS4uClientUpn, &ClientUpn);
        }

        if (SUCCEEDED(hRetval))
        {
            pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
            hRetval DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = GetLsaHandleAndPackageId(
                                pszPackageName,
                                &hLsa,
                                &PackageId
                                );
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = KrbLsaLogonUser(
                                hLsa,
                                PackageId,
                                Network, // this would cause S4u2self to be used
                                &ClientUpn,
                                &ClientRealm,
                                &Password, // ignored for s4u2self
                                S4u2SelfFlags, // Flags for s4u2self
                                &hImpToken
                                );
        }
    }

    if (SUCCEEDED(hRetval))
    {
        *phToken = hImpToken;
        hImpToken = NULL;
    }

    THResult hr;
    
    if (hImpToken)
    {
        hr DBGCHK = CloseHandle(hImpToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (pPriv)
    {
        delete pPriv;
    }

    if (hLsa)
    {
        hr DBGCHK = LsaDeregisterLogonProcess(hLsa);
    }

    RtlFreeUnicodeString(&ClientRealm);
    RtlFreeUnicodeString(&ClientUpn);

    return hRetval;
}

HRESULT
SspiClientStart(
    IN TSspiClientThreadParam* pParameter,   // thread data
    IN SOCKET ServerSocket,
    IN SOCKET ClientSocket
    )
{
    THResult hRetval = S_OK;

    TSspiClientParam* pCliParam = NULL;
    CredHandle hClientCred;
    CtxtHandle hClientCtxt;
    CtxtHandle hServerCtxt;

    ULONG cbInBuf = 0;
    CHAR* pInBuf = NULL;
    ULONG cbOutBuf = 0;
    CHAR* pOutBuf = NULL;

    TImpersonation* pImpersonation = NULL;
    HANDLE hImpToken = NULL;

    ULONG cPackages = 0;
    PSecPkgInfoA pPackageInfo = NULL;
    HANDLE hImportToken = NULL;
    HANDLE hExportToken = NULL;
    SecBuffer MarshalledContext = {0};
    SecPkgContext_PackageInfoA ContextPackageInfo = {0};

    DebugPrintf(SSPI_LOG, "SspiClientStart entering\n");

    SecInvalidateHandle(&hClientCred);
    SecInvalidateHandle(&hClientCtxt);
    SecInvalidateHandle(&hServerCtxt);

    pCliParam = dynamic_cast<TSspiClientParam*>(pParameter);
    hRetval DBGCHK = pCliParam ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = GetClientImpToken(
                            pCliParam->ProcessIdTokenUsedByClient,
                            pCliParam->pszPackageName,
                            pCliParam->pszS4uClientUpn,
                            pCliParam->pszS4uClientRealm,
                            pCliParam->S4u2SelfFlags,
                            &hImpToken
                            );
    }

    if (SUCCEEDED(hRetval) && hImpToken)
    {
        pImpersonation = new TImpersonation(hImpToken);

        hRetval DBGCHK = pImpersonation ? pImpersonation->Validate() : E_OUTOFMEMORY;

        if (SUCCEEDED(hRetval))
        {
            DebugPrintf(SSPI_LOG, "************** check client token data %p ******\n", hImpToken);
            hRetval DBGCHK = CheckUserData();
        }
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = AcquireCredHandle(
                            pCliParam->pszPrincipal,
                            pCliParam->pCredLogonID,
                            pCliParam->pszPackageName,
                            pCliParam->pAuthData,
                            SECPKG_CRED_OUTBOUND,
                            &hClientCred
                            );
    }

    if (pImpersonation)
    {
        delete pImpersonation;
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiClientStart QuerySecurityPackageInfoA \"%s\"\n", pCliParam->pszPackageName);

        hRetval DBGCHK = QuerySecurityPackageInfoA(pCliParam->pszPackageName, &pPackageInfo);
    }

    if (SUCCEEDED(hRetval))
    {
        pInBuf = new CHAR[pPackageInfo->cbMaxToken + sizeof(ULONG_PTR)]; // allow length prefix
        hRetval DBGCHK = pInBuf ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        cbInBuf = pPackageInfo->cbMaxToken + sizeof(ULONG_PTR);
        RtlZeroMemory(pInBuf, cbInBuf);

        pOutBuf = new CHAR[pPackageInfo->cbMaxToken + sizeof(ULONG_PTR)]; // allow length prefix
        hRetval DBGCHK = pOutBuf ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        cbOutBuf = pPackageInfo->cbMaxToken + sizeof(ULONG_PTR);
        RtlZeroMemory(pOutBuf, cbOutBuf);

        hRetval DBGCHK = GetClientSecurityContextHandle(
                            pCliParam,
                            ServerSocket,
                            ClientSocket,
                            &hClientCred,
                            cbInBuf,
                            pInBuf,
                            cbOutBuf,
                            pOutBuf,
                            &hClientCtxt
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiClientStart Writing ClientActionFlags %#x\n", pCliParam->ClientActionFlags);
        hRetval DBGCHK = WriteMessage(ServerSocket,
            sizeof(pCliParam->ClientActionFlags),
            &pCliParam->ClientActionFlags);
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & SSPI_ACTION_NO_QCA) == 0))
    {
        hRetval DBGCHK = CheckSecurityContextHandle(&hClientCtxt);
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & SSPI_ACTION_NO_MESSAGES) == 0))
    {
        hRetval DBGCHK = DoSspiClientWork(
                            &hClientCtxt,
                            ServerSocket,
                            ClientSocket
                            );
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        DebugPrintf(SSPI_LOG, "*********Client Export/Import security contexts***********");

        hRetval DBGCHK = QueryContextAttributesA(
                            &hClientCtxt, // assuming client and server having the same package
                            SECPKG_ATTR_PACKAGE_INFO,
                            &ContextPackageInfo
                            );

        MarshalledContext.cbBuffer = cbInBuf;
        MarshalledContext.pvBuffer = pInBuf;

        hRetval DBGCHK = ReadMessage(ClientSocket,
                            MarshalledContext.cbBuffer,
                            MarshalledContext.pvBuffer,
                            &MarshalledContext.cbBuffer);
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        DebugPrintf(SSPI_LOG, "SspiClientStart calling ImportSecurityContextA pszPackageName %s\n",
            (ContextPackageInfo.PackageInfo ?
                ContextPackageInfo.PackageInfo->Name : pCliParam->pszPackageName));

        hRetval DBGCHK = ImportSecurityContextA(
                            (ContextPackageInfo.PackageInfo ?
                                ContextPackageInfo.PackageInfo->Name : pCliParam->pszPackageName),
                            &MarshalledContext,
                            NULL, // hImportToken
                            &hServerCtxt
                            );
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        RtlZeroMemory(&MarshalledContext, sizeof(MarshalledContext));

        DebugPrintf(SSPI_LOG, "SspiClientStart calling ExportSecurityContext\n");

        hRetval DBGCHK = ExportSecurityContext(
                            &hClientCtxt,
                            SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                            &MarshalledContext,
                            &hExportToken
                            );

        if (SUCCEEDED(hRetval))
        {
            SecInvalidateHandle(&hClientCtxt);

            hRetval DBGCHK = WriteMessage(ServerSocket,
                                MarshalledContext.cbBuffer,
                                MarshalledContext.pvBuffer);
        }

        if (MarshalledContext.pvBuffer)
        {
            FreeContextBuffer(MarshalledContext.pvBuffer);
        }
    }

    if (SUCCEEDED(hRetval) && ((pCliParam->ClientActionFlags & (SSPI_ACTION_NO_IMPORT_EXPORT | SSPI_ACTION_NO_IMPORT_EXPORT_MSG)) == 0))
    {
        hRetval DBGCHK = DoSspiServerWork(
                            &hServerCtxt,
                            ServerSocket,
                            ClientSocket
                            );
    }

    THResult hr;

    if (pPackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(pPackageInfo);
    }

    if (SecIsValidHandle(&hClientCred))
    {
        hr DBGCHK = FreeCredentialsHandle(&hClientCred);
    }

    if (SecIsValidHandle(&hClientCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hClientCtxt);
    }

    if (SecIsValidHandle(&hServerCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hServerCtxt);
    }

    if (ContextPackageInfo.PackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(ContextPackageInfo.PackageInfo);
    }

    if (pOutBuf)
    {
        delete [] pOutBuf;
    }

    if (pInBuf)
    {
        delete [] pInBuf;
    }

    if (hExportToken)
    {
        hr DBGCHK = CloseHandle(hExportToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (hImportToken)
    {
        hr DBGCHK = CloseHandle(hImportToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (hImpToken)
    {
        hr DBGCHK = CloseHandle(hImpToken) ? S_OK : GetLastErrorAsHResult();
    }

    DebugPrintf(SSPI_LOG, "SspiClientStart leaving %#x\n", (HRESULT) hRetval);

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\sspisrv.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sspisrv.cxx

Abstract:

    sspisrv

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspisrv.hxx"

TSspiServerParam::TSspiServerParam(
    VOID
    ) : m_hr(E_FAIL)
{
}

TSspiServerParam::TSspiServerParam(
    IN const TSsiServerMainLoopThreadParam* pSrvMainLoopParam
    ) : m_hr(E_FAIL)
{
    const TSspiServerMainParam* pSrvMaimParam = dynamic_cast<const TSspiServerMainParam*>(pSrvMainLoopParam);
    m_hr DBGCHK = pSrvMaimParam ? S_OK : E_INVALIDARG;
    if (SUCCEEDED(m_hr))
    {
        pszPrincipal = pSrvMaimParam->pszPrincipal;
        pCredLogonID = pSrvMaimParam->pCredLogonID;
        pszPackageName = pSrvMaimParam->pszPackageName;
        pAuthData = pSrvMaimParam->pAuthData;
        ServerFlags = pSrvMaimParam->ServerFlags;
        TargetDataRep = pSrvMaimParam->TargetDataRep;
        ServerActionFlags = pSrvMaimParam->ServerActionFlags;
        pszApplication = pSrvMaimParam->pszApplication;
    }
}

HRESULT
TSspiServerParam::Validate(
    VOID
    ) const
{
    return m_hr;
}

TSspiServerMainParam::TSspiServerMainParam(
    VOID
    ) : pszPrincipal(NULL),
    pCredLogonID(NULL),
    pszPackageName(NTLMSP_NAME_A),
    pAuthData(NULL),
    ServerFlags(ASC_REQ_EXTENDED_ERROR),
    TargetDataRep(SECURITY_NATIVE_DREP),
    ServerActionFlags(0),
    pszApplication(NULL)
{
}

HRESULT
SspiAcquireServerParam(
    IN TSsiServerMainLoopThreadParam *pSrvMainParam,
    OUT TSspiServerThreadParam** ppServerParam
    )
{
    TSspiServerParam* pSrvParam = NULL;
    THResult hRetval = S_OK;

    *ppServerParam = NULL;

    pSrvParam = new TSspiServerParam(pSrvMainParam);
    hRetval DBGCHK = pSrvParam ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        *ppServerParam = pSrvParam;
        pSrvParam = NULL;
    }

    if (pSrvParam)
    {
        delete pSrvParam;
    }

    return hRetval;
}

VOID
SspiReleaseServerParam(
    IN TSspiServerThreadParam* pServerParam
    )
{
    delete pServerParam;
}

HRESULT
GetServerSecurityContextHandle(
    IN TSspiServerParam* pSrvParam,
    IN SOCKET ClientSocket,
    IN PCredHandle phServerCred,
    IN ULONG cbInBuf,
    IN CHAR* pInBuf,
    IN ULONG cbOutBuf,
    IN CHAR* pOutBuf,
    OUT PCtxtHandle phServerCtxt
    )
{
    THResult hRetval = S_OK;
    THResult hProtocolStatus;
    SECURITY_STATUS ProtocolStatus;

    ULONG ContextAttributes = 0;
    TimeStamp Lifetime = {0};
    CtxtHandle hServerCtxt;

    ULONG cbRead = 0;

    SecBufferDesc OutBuffDesc = {0};
    SecBuffer OutSecBuff = {0};
    SecBufferDesc InBuffDesc = {0};
    SecBuffer InSecBuff = {0};

    BOOL bIsContinueNeeded = FALSE;

    SecInvalidateHandle(phServerCtxt);
    SecInvalidateHandle(&hServerCtxt);

    //
    // read ISC status code
    //

    hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                        sizeof(ProtocolStatus),
                        &ProtocolStatus,
                        &cbRead);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ProtocolStatus;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                            cbInBuf,
                            pInBuf,
                            &cbRead);
    }

    if (SUCCEEDED(hRetval))
    {
        //
        // prepare output buffer
        //

        OutBuffDesc.ulVersion = 0;
        OutBuffDesc.cBuffers = 1;
        OutBuffDesc.pBuffers = &OutSecBuff;

        OutSecBuff.cbBuffer = cbOutBuf;
        OutSecBuff.BufferType = SECBUFFER_TOKEN;
        OutSecBuff.pvBuffer = pOutBuf;

        //
        // prepare input buffer
        //

        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers = 1;
        InBuffDesc.pBuffers = &InSecBuff;

        InSecBuff.cbBuffer = cbRead;
        InSecBuff.BufferType = SECBUFFER_TOKEN;
        InSecBuff.pvBuffer = pInBuf;

        DebugPrintf(SSPI_LOG, "GetServerSecurityContextHandle calling AcceptSecurityContext "
            "ServerFlags %#x, TargetDataRep %#x, CredHandle %#x:%#x\n",
            pSrvParam->ServerFlags, pSrvParam->TargetDataRep,
            phServerCred->dwUpper, phServerCred->dwLower);

        hRetval DBGCHK = AcceptSecurityContext(
                            phServerCred,
                            NULL,   // No Server context yet
                            &InBuffDesc,
                            pSrvParam->ServerFlags,
                            pSrvParam->TargetDataRep,
                            &hServerCtxt,
                            &OutBuffDesc,
                            &ContextAttributes,
                            &Lifetime
                            );
    }

    bIsContinueNeeded = (S_OK == IsContinueNeeded(hRetval));

    if (S_OK == IsCompleteNeeded(hRetval))
    {
        THResult hr;

        hr DBGCHK = CompleteAuthToken(&hServerCtxt, &OutBuffDesc);

        if (FAILED(hr)) // retain continue needed info
        {
            hRetval DBGNOCHK = hr;
        }
    }

    ProtocolStatus = (HRESULT) hRetval;
    hProtocolStatus DBGCHK = WriteMessage(ClientSocket,
                                sizeof(ProtocolStatus),
                                &ProtocolStatus);

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = hProtocolStatus;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = WriteMessage(ClientSocket,
                            OutSecBuff.cbBuffer,
                            OutSecBuff.pvBuffer);
    }

    while (SUCCEEDED(hRetval) && bIsContinueNeeded)
    {
        hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                            sizeof(ProtocolStatus),
                            &ProtocolStatus,
                            &cbRead);

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = ProtocolStatus;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                                cbInBuf,
                                pInBuf,
                                &cbRead);
        }
        else
        {
            break;
        }

        if (SUCCEEDED(hRetval) && !bIsContinueNeeded)
        {
            break;
        }

        if (SUCCEEDED(hRetval))
        {
            InSecBuff.cbBuffer = cbRead;
            OutSecBuff.cbBuffer = cbOutBuf;

            DebugPrintf(SSPI_LOG, "GetServerSecurityContextHandle calling AcceptSecurityContext "
                "ServerFlags %#x, TargetDataRep %#x, hServerCtxt %#x:%#x\n",
                pSrvParam->ServerFlags, pSrvParam->TargetDataRep,
                hServerCtxt.dwUpper, hServerCtxt.dwLower);

            hRetval DBGCHK = AcceptSecurityContext(
                                NULL,  // no cred handle
                                &hServerCtxt,
                                &InBuffDesc,
                                pSrvParam->ServerFlags,
                                pSrvParam->TargetDataRep,
                                &hServerCtxt,  // can be just NULL
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime
                                );
        }

        bIsContinueNeeded = (S_OK == IsContinueNeeded(hRetval));

        if (S_OK == IsCompleteNeeded(hRetval))
        {
            THResult hr;

            hr DBGCHK = CompleteAuthToken(&hServerCtxt, &OutBuffDesc);

            if (FAILED(hr)) // retain continue needed info
            {
                hRetval DBGNOCHK = hr;
            }
        }

        ProtocolStatus = (HRESULT) hRetval;
        hProtocolStatus DBGCHK = WriteMessage(ClientSocket,
                                    sizeof(ProtocolStatus),
                                    &ProtocolStatus);

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = hProtocolStatus;
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval DBGCHK = WriteMessage(ClientSocket,
                                OutSecBuff.cbBuffer,
                                OutSecBuff.pvBuffer);
        }
    }

    if (SUCCEEDED(hRetval))
    {
        TimeStamp CurrentTime = {0};

        DebugPrintf(SSPI_LOG, "************Server authentication succeeded:************\n");

        DebugPrintf(SSPI_LOG, "ServerContextHandle: %#x:%#x, ContextAttributes: %#x\n",
             hServerCtxt.dwUpper, hServerCtxt.dwLower, ContextAttributes);
        DebugPrintLocalTime(SSPI_LOG, "Lifetime", &Lifetime);

        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "Current Time", &CurrentTime);

        *phServerCtxt = hServerCtxt;
        SecInvalidateHandle(&hServerCtxt)
    }

    THResult hr;

    if (SecIsValidHandle(&hServerCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hServerCtxt);
    }

    return hRetval;
}

HRESULT
SspiServerStart(
    IN TSspiServerThreadParam* pParameter,   // thread data
    IN SOCKET ClientSocket
    )
{
    THResult hRetval = S_OK;

    TSspiServerParam *pSrvParam = NULL;
    CredHandle hServerCred;
    CtxtHandle hServerCtxt;
    CtxtHandle hClientCtxt;

    ULONG cbInBuf = 0;
    CHAR* pInBuf = NULL;
    ULONG cbOutBuf = 0;
    CHAR* pOutBuf = NULL;
    ULONG cbRead = 0;
    ULONG ClientActionFlags = 0;

    ULONG cPackages = 0;
    PSecPkgInfoA pPackageInfo = NULL;
    HANDLE hToken = NULL;
    HANDLE hImportToken = NULL;
    HANDLE hExportToken = NULL;
    SecBuffer MarshalledContext = {0};
    UNICODE_STRING Application = {0};
    SecPkgContext_PackageInfoA ContextPackageInfo = {0};

    SecInvalidateHandle(&hServerCred);
    SecInvalidateHandle(&hServerCtxt);
    SecInvalidateHandle(&hClientCtxt);

    pSrvParam = dynamic_cast<TSspiServerParam*>(pParameter);
    hRetval DBGCHK = pSrvParam ? pSrvParam->Validate() : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = AcquireCredHandle(
                            pSrvParam->pszPrincipal,
                            pSrvParam->pCredLogonID,
                            pSrvParam->pszPackageName,
                            pSrvParam->pAuthData,
                            SECPKG_CRED_INBOUND,
                            &hServerCred
                            );
    }

    if (SUCCEEDED(hRetval) && pSrvParam->pszApplication)
    {
        hRetval DBGCHK = CreateUnicodeStringFromAsciiz(pSrvParam->pszApplication, &Application);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QuerySecurityPackageInfoA(pSrvParam->pszPackageName, &pPackageInfo);
    }

    if (SUCCEEDED(hRetval))
    {
        pInBuf = new CHAR[pPackageInfo->cbMaxToken + sizeof(ULONG_PTR)]; // allow length prefix
        hRetval DBGCHK = pInBuf ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        cbInBuf = pPackageInfo->cbMaxToken;
        RtlZeroMemory(pInBuf, cbInBuf);

        pOutBuf = new CHAR[pPackageInfo->cbMaxToken + sizeof(ULONG_PTR)]; // allow length prefix
        hRetval DBGCHK = pOutBuf ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        cbOutBuf = pPackageInfo->cbMaxToken;
        RtlZeroMemory(pOutBuf, cbOutBuf);

        hRetval DBGCHK = GetServerSecurityContextHandle(
                            pSrvParam,
                            ClientSocket,
                            &hServerCred,
                            cbInBuf,
                            pInBuf,
                            cbOutBuf,
                            pOutBuf,
                            &hServerCtxt
                            );
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                            sizeof(ClientActionFlags),
                            &ClientActionFlags,
                            &cbRead);
    }

    if (SUCCEEDED(hRetval) && ((pSrvParam->ServerActionFlags & SSPI_ACTION_NO_QCA) == 0))
    {
        hRetval DBGCHK = CheckSecurityContextHandle(&hServerCtxt);
    }

    if (SUCCEEDED(hRetval))
    {
        DebugPrintf(SSPI_LOG, "SspiServerStart ServerActionFlags %#x, ClientActionFlags %#x\n",
            pSrvParam->ServerActionFlags, ClientActionFlags);

        hRetval DBGCHK = ImpersonateSecurityContext(&hServerCtxt);
    }

    if (SUCCEEDED(hRetval) && ((pSrvParam->ServerActionFlags & SSPI_ACTION_NO_CHECK_USER_DATA) == 0))
    {
        DebugPrintf(SSPI_LOG, "************** check user data via ImpersonateSecurityContext ******\n");
        hRetval DBGCHK = CheckUserData();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = RevertSecurityContext(&hServerCtxt);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = QuerySecurityContextToken(&hServerCtxt, &hToken);
    }

    if (SUCCEEDED(hRetval) && ((pSrvParam->ServerActionFlags & SSPI_ACTION_NO_CHECK_USER_TOKEN) == 0))
    {
        DebugPrintf(SSPI_LOG, "************** check user data via QuerySecurityContextToken ******\n");
        hRetval DBGCHK = CheckUserToken(hToken);
    }

    if (SUCCEEDED(hRetval) && Application.Length && Application.Buffer)
    {
        hRetval DBGCHK = StartInteractiveClientProcessAsUser(
                            hToken,
                            Application.Buffer
                            );
    }

    if (SUCCEEDED(hRetval) && ((ClientActionFlags & SSPI_ACTION_NO_MESSAGES) == 0))
    {
        hRetval DBGCHK = DoSspiServerWork(
                            &hServerCtxt,
                            pSrvParam->ServerSocket,
                            ClientSocket
                            );
    }

    if (SUCCEEDED(hRetval) && ((ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        DebugPrintf(SSPI_LOG, "*********Server Export/Import security contexts***********");
        DebugPrintf(SSPI_LOG, "SspiServerStart calling ExportSecurityContext\n");

        hRetval DBGCHK = QueryContextAttributesA(
                            &hServerCtxt, // assuming client and server having the same package
                            SECPKG_ATTR_PACKAGE_INFO,
                            &ContextPackageInfo
                            );

        hRetval DBGCHK = ExportSecurityContext(
                            &hServerCtxt,
                            SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                            &MarshalledContext,
                            &hExportToken
                            );

        if (SUCCEEDED(hRetval))
        {
            SecInvalidateHandle(&hServerCtxt);
            hRetval DBGCHK = WriteMessage(ClientSocket,
                                MarshalledContext.cbBuffer,
                                MarshalledContext.pvBuffer
                                );
        }
        if (MarshalledContext.pvBuffer)
        {
            FreeContextBuffer(MarshalledContext.pvBuffer);
        }
    }

    if (SUCCEEDED(hRetval) && ((ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        MarshalledContext.cbBuffer = cbInBuf;
        MarshalledContext.pvBuffer = pInBuf;

        hRetval DBGCHK = ReadMessage(pSrvParam->ServerSocket,
                            MarshalledContext.cbBuffer,
                            MarshalledContext.pvBuffer,
                            &MarshalledContext.cbBuffer
                            );
    }

    if (SUCCEEDED(hRetval) && ((ClientActionFlags & SSPI_ACTION_NO_IMPORT_EXPORT) == 0))
    {
        DebugPrintf(SSPI_LOG, "SspiClientStart calling ImportSecurityContextA pszPackageName %s\n",
            (ContextPackageInfo.PackageInfo ?
                ContextPackageInfo.PackageInfo->Name : pSrvParam->pszPackageName));

        hRetval DBGCHK = ImportSecurityContextA(
                            (ContextPackageInfo.PackageInfo ?
                                ContextPackageInfo.PackageInfo->Name : pSrvParam->pszPackageName),
                            &MarshalledContext,
                            NULL, // &hImportToken,
                            &hClientCtxt
                            );
    }

    if (SUCCEEDED(hRetval) && ((ClientActionFlags & (SSPI_ACTION_NO_IMPORT_EXPORT | SSPI_ACTION_NO_IMPORT_EXPORT_MSG)) == 0))
    {
        hRetval DBGCHK = DoSspiClientWork(
                            &hClientCtxt,
                            pSrvParam->ServerSocket,
                            ClientSocket
                            );
    }

    THResult hr;

    if (pPackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(pPackageInfo);
    }

    if (SecIsValidHandle(&hServerCred))
    {
        hr DBGCHK = FreeCredentialsHandle(&hServerCred);
    }

    if (SecIsValidHandle(&hServerCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hServerCtxt);
    }

    if (SecIsValidHandle(&hClientCtxt))
    {
        hr DBGCHK = DeleteSecurityContext(&hClientCtxt);
    }

    if (ContextPackageInfo.PackageInfo)
    {
        hr DBGCHK = FreeContextBuffer(ContextPackageInfo.PackageInfo);
    }

    if (pOutBuf)
    {
        delete [] pOutBuf;
    }

    if (pInBuf)
    {
        delete [] pInBuf;
    }

    if (hToken)
    {
        hr DBGCHK = CloseHandle(hToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (hExportToken)
    {
        hr DBGCHK = CloseHandle(hExportToken) ? S_OK : GetLastErrorAsHResult();
    }

    if (hImportToken)
    {
        hr DBGCHK = CloseHandle(hImportToken) ? S_OK : GetLastErrorAsHResult();
    }

    RtlFreeUnicodeString(&Application);

    DebugPrintf(SSPI_LOG, "SspiServerStart leaving %#x\n", (HRESULT) hRetval);

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\sspi\main.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    main

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sspi.hxx"

#include "sspicli.hxx"
#include "sspisrv.hxx"

#include "main.hxx"

VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR,
        "\n\nUsage: %s [-noserver] [-noclient] [-targetname <target name>] \n"
        "[-clientsocketport <client port>] -serversocketport <server port> \n"
        "[-clientname <client>] [-clientdomain <client domain>] \n"
        "[-clientpassword <client password>] [-servername <server name>] \n"
        "[-serverpassword <server password>] [-serverhost <server host>] \n"
        "[-serverdomain <server domain>] [-clientprincipal <client principal name>] \n"
        "[-serverprincipal <server principal name> [-serverflags <server flag>] \n"
        "[-clientflags <client flag>] [-clientpackage <client package>] \n"
        "[-clientdatarep <client data rep>] [-serverdatarep <server data rep>] \n"
        "[-clientcredlogonidhighpart <client cred logon id highpart>] \n"
        "[-clientcredlogonidlowpart <client cred logon id lowpart>] \n"
        "[-clientpackagelist <package1,package2,!package3>\n"
        "[-serverpackagelist <package1,package2,!package3>\n"
        "[-servercredlogonidhighpart <server cred logon id highpart>] \n"
        "[-servercredlogonidlowpart <server cred logon id lowpart>] \n"
        "[-serverpackage <server package>] [-nomessages] \n"
        "[-noimportexport] [-noimportexportmsg] [-noserverqca] \n"
        "[-noclientqca] [-nocheckuserdata] [-nocheckusertoken] \n"
        "[-noclientpackagecheck] [-noserverpackagecheck] [-application <app>] \n"
        "[-s4uclientupn <s4u client upn>] [-s4uclientrealm <s4u client realm>] \n"
        "[-s4uflags <s4u2selfflags>] [-processidtokenusedbyclient <process id>] \n"
        "[-enabletcbpriv] [-quiet] [-messagelength <length>]\n\n", pszApp);
    exit(-1);
}

VOID
checkpoint(
    VOID
    )
{
    DebugPrintf(SSPI_LOG, "checkpoint\n");
    ASSERT(FALSE);
}

#if 0

HRESULT
GetAuthdata(
    IN OPTIONAL PCSTR pszUserName,
    IN OPTIONAL PCSTR pszDomainName,
    IN OPTIONAL PCSTR pszPassword,
    OUT SEC_WINNT_AUTH_IDENTITY_A* pAuthData
    )
{
    THResult hRetval = S_OK;

    pAuthData->Domain = (UCHAR*)pszDomainName;
    pAuthData->DomainLength = pszDomainName ? strlen(pszDomainName) : 0;
    pAuthData->Password = (UCHAR*)pszPassword;
    pAuthData->PasswordLength = pszPassword ? strlen(pszPassword) : 0;
    pAuthData->User = (UCHAR*)pszUserName;
    pAuthData->UserLength = pszUserName ? strlen(pszUserName) : 0;
    pAuthData->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    return hRetval;
}

#endif

VOID __cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    THResult hRetval = S_OK;

    ULONG mark = 1;

    BOOL bStartServer = TRUE;
    BOOL bStartClient = TRUE;
    BOOL bCheckClientPackage = TRUE;
    BOOL bCheckServerPackage = TRUE;

    TSspiServerMainParam SrvMainParam;
    TSspiClientParam CliParam;
    BOOLEAN bIsVerberose = TRUE;

    SEC_WINNT_AUTH_IDENTITY_EXA ClientAuthData = {0};
    SEC_WINNT_AUTH_IDENTITY_EXA ServerAuthData = {0};

    PCSTR pszClientName = NULL;
    PCSTR pszClientDomain = NULL;
    PCSTR pszClientPassword = NULL;
    PCSTR pszClientPackageList = NULL;
    PCSTR pszServerName = NULL;
    PCSTR pszServerDomain = NULL;
    PCSTR pszServerPassword = NULL;
    PCSTR pszServerPackageList = NULL;

    LUID ClientCredLogonId = {0};
    LUID ServerCredLogonId = {0};
    ULONG ClientTargetDataRep = SECURITY_NATIVE_DREP;
    ULONG ServerTargetDataRep = SECURITY_NATIVE_DREP;

    USHORT ServerSocketPort = kServerSocketPort;
    USHORT ClientSocketPort = kClientSocketPort;

    CRITICAL_SECTION DbgPrintCritSection = {0};

    BOOLEAN bEnableTcbPriv = FALSE;
    TPrivilege* pPriv = NULL;

    RtlInitializeCriticalSection(&DbgPrintCritSection);

    argc--;

    while (argc)
    {
        if (!strcmp(argv[mark], "-clientsocketport") && argc > 1)
        {
            argc--; mark++;
            ClientSocketPort = (USHORT) strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serversocketport") && argc > 1)
        {
            argc--; mark++;
            ServerSocketPort = (USHORT) strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientname") && argc > 1)
        {
            argc--; mark++;
            pszClientName = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientdomain") && argc > 1)
        {
            argc--; mark++;
            pszClientDomain = argv[mark];
            argc--; mark++;
        }

        else if (!strcmp(argv[mark], "-clientpassword") && argc > 1)
        {
            argc--; mark++;
            pszClientPassword = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-servername") && argc > 1)
        {
            argc--; mark++;
            pszServerName = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverdomain") && argc > 1)
        {
            argc--; mark++;
            pszServerDomain = argv[mark];
            argc--; mark++;
        }

        else if (!strcmp(argv[mark], "-serverpassword") && argc > 1)
        {
            argc--; mark++;
            pszServerPassword = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverhost") && argc > 1)
        {
            argc--; mark++;
            bStartServer = FALSE;
            CliParam.pszServer = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientpackage") && argc > 1)
        {
            argc--; mark++;
            CliParam.pszPackageName = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverpackage") && argc > 1)
        {
            argc--; mark++;
            SrvMainParam.pszPackageName = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-processidtokenusedbyclient") && argc > 1)
        {
            argc--; mark++;
            CliParam.ProcessIdTokenUsedByClient = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-s4uclientupn") && argc > 1)
        {
            argc--; mark++;
            CliParam.pszS4uClientUpn = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-s4uclientrealm") && argc > 1)
        {
            argc--; mark++;
            CliParam.pszS4uClientRealm = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientcredlogonidlowpart") && argc > 1)
        {
            argc--; mark++;
            ClientCredLogonId.LowPart = strtol(argv[mark], NULL, 0);
            CliParam.pCredLogonID = &ClientCredLogonId;
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientcredlogonidhighpart") && argc > 1)
        {
            argc--; mark++;
            ClientCredLogonId.HighPart = strtol(argv[mark], NULL, 0);
            CliParam.pCredLogonID = &ClientCredLogonId;
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-servercredlogonidhighpart") && argc > 1)
        {
            argc--; mark++;
            ServerCredLogonId.HighPart = strtol(argv[mark], NULL, 0);
            SrvMainParam.pCredLogonID = &ClientCredLogonId;
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-servercredlogonidlowpart") && argc > 1)
        {
            argc--; mark++;
            ServerCredLogonId.LowPart = strtol(argv[mark], NULL, 0);
            SrvMainParam.pCredLogonID = &ServerCredLogonId;
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-targetname") && argc > 1)
        {
            argc--; mark++;
            CliParam.pszTargetName = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientdatarep") && argc > 1)
        {
            argc--; mark++;
            ClientTargetDataRep = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverdatarep") && argc > 1)
        {
            argc--; mark++;
            ServerTargetDataRep = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverflags") && argc > 1)
        {
            argc--; mark++;
            SrvMainParam.ServerFlags = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientflags") && argc > 1)
        {
            argc--; mark++;
            CliParam.ClientFlags = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-s4uflags") && argc > 1)
        {
            argc--; mark++;
            CliParam.S4u2SelfFlags = strtol(argv[mark], NULL, 0);
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientprincipal") && argc > 1)
        {
            argc--; mark++;
            CliParam.pszPrincipal = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-clientpackagelist") && argc > 1)
        {
            argc--; mark++;
            pszClientPackageList = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverpackagelist") && argc > 1)
        {
            argc--; mark++;
            pszServerPackageList = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-serverprincipal") && argc > 1)
        {
            argc--; mark++;
            SrvMainParam.pszPrincipal = argv[mark];
            argc--; mark++;
        }
        else if (!strcmp(argv[mark], "-application") && argc > 1)
        {
            argc--; mark++;
            SrvMainParam.pszApplication = argv[mark];
            argc--; mark++;    
        }
        else if (!strcmp(argv[mark], "-messagelength") && argc > 1)
        {
            argc--; mark++;
            g_MsgHeaderLen = strtol(argv[mark], NULL, 0);
            argc--; mark++;    
        }
        else if (!strcmp(argv[mark], "-noserver"))
        {
            argc--; mark++;
            bStartServer = FALSE;
        }
        else if (!strcmp(argv[mark], "-noclient"))
        {
            argc--; mark++;
            bStartClient = FALSE;
        }
        else if (!strcmp(argv[mark], "-nocheckusertoken"))
        {
            argc--; mark++;
            SrvMainParam.ServerActionFlags |= SSPI_ACTION_NO_CHECK_USER_TOKEN;
        }
        else if (!strcmp(argv[mark], "-nocheckuserdata"))
        {
            argc--; mark++;
            SrvMainParam.ServerActionFlags |= SSPI_ACTION_NO_CHECK_USER_DATA;
        }
        else if (!strcmp(argv[mark], "-noserverqca"))
        {
            argc--; mark++;
            SrvMainParam.ServerActionFlags |= SSPI_ACTION_NO_QCA;
        }
        else if (!strcmp(argv[mark], "-noclientqca"))
        {
            argc--; mark++;
            CliParam.ClientActionFlags |= SSPI_ACTION_NO_QCA;
        }
        else if (!strcmp(argv[mark], "-nomessages"))
        {
            argc--; mark++;
            CliParam.ClientActionFlags |= SSPI_ACTION_NO_MESSAGES;
        }
        else if (!strcmp(argv[mark], "-noimportexportmsg"))
        {
            argc--; mark++;
            CliParam.ClientActionFlags |= SSPI_ACTION_NO_IMPORT_EXPORT_MSG;
        }
        else if (!strcmp(argv[mark], "-noimportexport"))
        {
            argc--; mark++;
            CliParam.ClientActionFlags |= SSPI_ACTION_NO_IMPORT_EXPORT;
        }
        else if (!strcmp(argv[mark], "-noclientpackagecheck"))
        {
            argc--; mark++;
            bCheckClientPackage = FALSE;
        }
        else if (!strcmp(argv[mark], "-noserverpackagecheck"))
        {
            argc--; mark++;
            bCheckServerPackage = FALSE;
        }
        else if (!strcmp(argv[mark], "-quiet"))
        {
            argc--; mark++;
            bIsVerberose = FALSE;        
        }
        else if (!strcmp(argv[mark], "-enabletcbpriv"))
        {
            argc--; mark++;
            bEnableTcbPriv = TRUE;       
        }        
        else if (!strcmp(argv[mark], "-h"))
        {
            argc--; mark++;
            Usage(argv[0]);
        }
        else
        {
            Usage(argv[0]);
        }
    }

    DebugLogOpenSerialized("sspi.exe", 
        bIsVerberose ? 
             SSPI_LOG | SSPI_WARN | SSPI_ERROR | SSPI_MSG
           : SSPI_ERROR, 
        &DbgPrintCritSection);

    SrvMainParam.ServerSocketPort = ServerSocketPort;

    CliParam.ClientSocketPort = ClientSocketPort;
    CliParam.ServerSocketPort = ServerSocketPort;

    if (bEnableTcbPriv) 
    {
        pPriv = new TPrivilege(SE_TCB_PRIVILEGE, TRUE);
        hRetval DBGCHK = pPriv ? pPriv->Validate() : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval) && bStartClient && bCheckClientPackage)
    {
        hRetval DBGCHK = CheckSecurityPackage(CliParam.pszPackageName);
    }

    if (SUCCEEDED(hRetval) && bStartServer && bCheckServerPackage
        && (!bCheckClientPackage
            || (0 != _stricmp(CliParam.pszPackageName, SrvMainParam.pszPackageName))))
    {
        hRetval DBGCHK = CheckSecurityPackage(SrvMainParam.pszPackageName);
    }

    if (SUCCEEDED(hRetval) && (pszClientName || pszClientDomain || pszClientPassword || pszClientPackageList))
    {
        CliParam.pAuthData = &ClientAuthData;
        DebugPrintf(SSPI_LOG, "Getting Client AuthData:\n");
        (VOID) GetAuthdataExA(
                    pszClientName,
                    pszClientDomain,
                    pszClientPassword,
                    pszClientPackageList,
                    &ClientAuthData
                    );
    }

    if (SUCCEEDED(hRetval) && (pszServerName || pszServerDomain || pszServerPassword || pszServerPackageList))
    {
        SrvMainParam.pAuthData = &ServerAuthData;
        DebugPrintf(SSPI_LOG, "Getting Server AuthData:\n");
        (VOID) GetAuthdataExA(
                    pszServerName,
                    pszServerDomain,
                    pszServerPassword,
                    pszServerPackageList,
                    &ServerAuthData
                    );
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval DBGCHK = SspiStartCS(
                            bStartServer ? &SrvMainParam : NULL,
                            bStartClient ? &CliParam : NULL
                            );
    }

    if (pPriv) 
    {
        delete pPriv;
    }

    DebugLogClose();

    DeleteCriticalSection(&DbgPrintCritSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\utest\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr


#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
#include <ntlmsp.h>
#include <ntlmssp.h>    // External definition of the NtLmSsp service
#include <dsgetdc.h>    // External definition of the NtLmSsp service

BOOLEAN QuietMode = FALSE; // Don't be verbose
extern BOOLEAN TestExt;

// BUGBUG Should be in the SDK?
#define MSV1_0_PACKAGE_NAMEW     L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;

    }

    printf( "\n" );
}

VOID
TestSspRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base SSPI functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus, TmpStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle, NewClientContextHandle;
    CtxtHandle ServerContextHandle, NewServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount,i;
    PSecPkgInfo PackageInfo;
    PSecPkgInfo pTmp;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];
    SecBuffer ExportedBuffer;

#if 0
    DWORD (WINAPI *pDsGetDcNameA)( LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA *);
    do {
        char szBuf[256];
        HINSTANCE  hLogonsrv = LoadLibraryA("logonsrv");
        PDOMAIN_CONTROLLER_INFOA ControllerInfo = NULL;
        ULONG NetStatus = 0;

        if (hLogonsrv == NULL)
        {
            wsprintfA(szBuf, "MSNP32: Logonsrv does not exist\n");
            OutputDebugStringA(szBuf);
            break;
        }

        pDsGetDcNameA = (DWORD (WINAPI *)(LPCSTR, LPCSTR, GUID *, 
                                                  LPCSTR, ULONG,
                                                  PDOMAIN_CONTROLLER_INFOA *))
                                GetProcAddress(hLogonsrv, "DsGetDcNameA");

        if (pDsGetDcNameA == NULL)
        {
            wsprintfA(szBuf, "MSNP32: Entrypoint DsGetDcNameA does not exist in Logonsrv.dll\n");
            OutputDebugStringA(szBuf);
            break;
        }

        NetStatus = (*pDsGetDcNameA)(NULL,
                             "NTDEV",
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_FLAT_NAME,
                             &ControllerInfo);

        if (hLogonsrv) FreeLibrary(hLogonsrv);

        if (NetStatus != 0)
        {
            wsprintfA(szBuf, "MSNP32: DsGetDcNameA returned 0x%x\n", NetStatus);
            OutputDebugStringA(szBuf);
            break;
        }

        if (ControllerInfo->DomainName != NULL)
        {
            wsprintfA(szBuf, "MSNP32: DsGetDcName returned DomainControllerName: \"%s\"\n", ControllerInfo->DomainControllerName );
            OutputDebugStringA(szBuf);
        }
        else
        {
            OutputDebugStringA("MSNP32: DsGetDcName returned NULL DomainName\n");
        }
    }while (FALSE);
#endif // #if 0

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );
    TmpStatus = GetLastError();

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< PackageCount; i++)
      {
        pTmp = (PackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pTmp->Name, pTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pTmp->fCapabilities,
                pTmp->wVersion,
                pTmp->wRPCID,
                pTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );
    TmpStatus = GetLastError();

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        TmpStatus = GetLastError();
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
// #define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME, // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        TmpStatus = GetLastError();
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    L"\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT | ISC_REQ_DATAGRAM,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT  | ISC_REQ_DATAGRAM,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
    }

    if ( NT_SUCCESS(SecStatus) )
    {
        if ( !QuietMode )
        {
            PrintTime("   Start:", ContextLifespan.tsStart );
            PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        }
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    // Export client context without deleting the old one.

    SecStatus = ExportSecurityContext(
                       &ClientContextHandle,
                       0,
                       &ExportedBuffer, 
                       NULL);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ExportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = ImportSecurityContext(
                        NTLMSP_NAME, // Package Name
                        &ExportedBuffer,
                        NULL,
                        &NewClientContextHandle);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = FreeContextBuffer(ExportedBuffer.pvBuffer);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeContextBuffer: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = QueryContextAttributes(
                    &NewClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    // Export client context while deleting the old one.

    SecStatus = ExportSecurityContext(
                       &ServerContextHandle,
                       SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                       &ExportedBuffer, 
                       NULL);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ExportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = ImportSecurityContext(
                        NTLMSP_NAME, // Package Name
                        &ExportedBuffer,
                        NULL,
                        &NewServerContextHandle);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = FreeContextBuffer(ExportedBuffer.pvBuffer);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeContextBuffer: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = QueryContextAttributes(
                    &NewServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    //
    // Delete only the client context. The server context has already been deleted.
    //

    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    //
    // Delete imported contexts
    //

    SecStatus = DeleteSecurityContext( &NewClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &NewServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR Password
    )
{
    NTSTATUS Status;
    PMSV1_0_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    UNICODE_STRING Name;
    STRING TempName;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    LogonInfoSize += (wcslen(UserName) + ((DomainName == NULL)? 0 : wcslen(DomainName)) + wcslen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PMSV1_0_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.Length = Name.Length;
    LogonInfo->UserName.MaximumLength = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitUnicodeString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.Length = Name.Length;
    LogonInfo->LogonDomainName.MaximumLength = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitUnicodeString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.Length = Name.Length;
    LogonInfo->Password.Length = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = MsV1_0InteractiveLogon;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: GetLastError = 0x%x\n",GetLastError());
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &TempName,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &TempName,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &TempName,
        NTLMSP_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &TempName,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&TempName, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &TempName,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &TempName,
                Interactive,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        return;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
        return;
    }

    ImpersonateLoggedOnUser( TokenHandle );
    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();
    NtClose(TokenHandle);



}

DWORD
JunkTest()
{
    return 1;
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    enum {
        NoAction,
        ConfigureService,
#define CONFIG_PARAM "/ConfigureService"
        TestSsp,
#define TESTSSP_PARAM "/TestSsp"
#define TESTSSP2_PARAM "/TestSsp:"
#define LOGON_PARAM "/TestLogon"
        TestLogon,
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /TestSsp
        //

        if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;

        //
        // Handle /TestSsp:
        //

        } else if ( _strnicmp( argument,
                              TESTSSP2_PARAM,
                              sizeof(TESTSSP2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;

            Iterations = strtoul( &argument[sizeof(TESTSSP2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        } else if ( _strnicmp( argument,
                              LOGON_PARAM,
                              sizeof(LOGON_PARAM)-1 ) == 0 ){
        //
        // Handle /TestLogon
        //
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;
            
            if (argc < i + 2)
            {
                goto Usage;
            }
            argument = argv[++i];
            Password = NetpAllocWStrFromStr( argument );
            argument = argv[++i];
            UserName = NetpAllocWStrFromStr( argument );
            if (i < argc)
            {
                argument = argv[++i];
                DomainName = NetpAllocWStrFromStr( argument );
            }
            else
            {
                DomainName = NULL;
            }

        } else {
        //
        // Handle all other parameters
        //

Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTSSP_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic SSPI.\n"
                "    " LOGON_PARAM "<Password> <UserName> [<DomainName>] - Test LogonUser.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) 
    {
        case TestSsp: 
        {
            for ( j=0; j<Iterations ; j++ ) {
                TestSspRoutine( DomainName, UserName, Password );
            }
            break;
        }
        case TestLogon: 
        {
            TestLogonRoutine( UserName, DomainName, Password );
        }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\test\tktlogon\tktlogon.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tktlogon.cxx

Abstract:

    ticket logon

Author:

    Larry Zhu (LZhu)                      January 1, 2002  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tktlogon.hxx"

VOID
Usage(
    IN PCSTR pszApp
    )
{
    DebugPrintf(SSPI_ERROR, "\n\nUsage: %s <LogonId.HighPart> <LogonId.LowPart> "
        "<serviceprincipal(host/machine@domain)>\n",
        pszApp);
    exit(-1);
}

NTSTATUS
GetTGT(
    IN HANDLE hLsa,
    IN ULONG PackageId,
    IN LUID* pLogonId,
    OUT KERB_EXTERNAL_TICKET** ppCacheEntry
    )
{
    TNtStatus Status;

    NTSTATUS SubStatus;

    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;

    ULONG ResponseSize;

    CacheRequest.MessageType = KerbRetrieveTicketMessage;
    CacheRequest.LogonId = *pLogonId;

    DebugPrintf(SSPI_LOG, "GetTgt PackageId %#x, LogonId %#x:%#x\n", PackageId, pLogonId->HighPart, pLogonId->LowPart);

    Status DBGCHK = LsaCallAuthenticationPackage(
        hLsa,
        PackageId,
        &CacheRequest,
        sizeof(CacheRequest),
        (VOID **) ppCacheEntry,
        &ResponseSize,
        &SubStatus
        );
    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

   return Status;
}

NTSTATUS
GetServiceTicket(
    IN HANDLE hLsa,
    IN ULONG ulPackageId,
    IN UNICODE_STRING* pServicePrincipal,
    IN LUID* pLogonId,
    IN BOOLEAN useCache,
    OUT KERB_RETRIEVE_TKT_RESPONSE** ppCacheResponse
    )
{
    TNtStatus Status;
    NTSTATUS SubStatus;

    VOID* pResponse;
    ULONG ResponseSize;

    KERB_RETRIEVE_TKT_REQUEST* pCacheRequest = NULL;
    ULONG cbCacheRequest = 0;
    UNICODE_STRING Target = {0};

    HANDLE hLogon = hLsa;
    ULONG PackageId = ulPackageId;

    cbCacheRequest = pServicePrincipal->Length
        + ROUND_UP_COUNT(sizeof(KERB_RETRIEVE_TKT_REQUEST), sizeof(ULONG_PTR));
    pCacheRequest = (KERB_RETRIEVE_TKT_REQUEST*) new CHAR[cbCacheRequest];

    Status DBGCHK = pCacheRequest ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pCacheRequest, cbCacheRequest);

        pCacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (PWSTR) (pCacheRequest + 1);
        Target.Length = pServicePrincipal->Length;
        Target.MaximumLength = pServicePrincipal->MaximumLength;

        pCacheRequest->LogonId = *pLogonId;

        RtlCopyMemory(
            Target.Buffer,
            pServicePrincipal->Buffer,
            pServicePrincipal->Length
            );

        pCacheRequest->TargetName = Target;

        if (!useCache)
        {
            pCacheRequest->CacheOptions = KERB_RETRIEVE_TICKET_DONT_USE_CACHE;
        }
        else
        {
            pCacheRequest->CacheOptions = 0;
        }

        DebugPrintf(SSPI_LOG, "ServicePrincipal: %wZ\n", &Target);

        Status DBGCHK = LsaCallAuthenticationPackage(
            hLsa,
            ulPackageId,
            pCacheRequest,
            pServicePrincipal->Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
            &pResponse,
            &ResponseSize,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        *ppCacheResponse = (KERB_RETRIEVE_TKT_RESPONSE*) pResponse;
        pResponse = NULL;
    }

    if (pCacheRequest)
    {
        delete [] pCacheRequest;
    }

    if (pResponse)
    {
        LsaFreeReturnBuffer(pResponse);
    }

   return NT_SUCCESS(Status) ? SubStatus : Status;
}

NTSTATUS
BuildAllocTicketLogonInfo(
    IN UCHAR* pTGTData,
    IN ULONG cbTGTDataLength,
    IN UCHAR* pTicketData,
    IN ULONG cbTicketDataLength,
    IN ULONG DataOffset,
    IN OUT ULONG *pLogonInfoSize,
    OUT KERB_TICKET_LOGON** ppLogonInfo
    )
{
    TNtStatus Status = STATUS_SUCCESS;

    UCHAR* pWhere = NULL;
    KERB_TICKET_LOGON* pLogonInfo = NULL;
    ULONG cbLogonInfoSize = *pLogonInfoSize;

    //assemble LogonInfo
    cbLogonInfoSize += cbTicketDataLength;

    if (cbTGTDataLength && pTGTData)
    {
        cbLogonInfoSize += cbTGTDataLength;
    }

    pLogonInfo = (KERB_TICKET_LOGON*) new CHAR[cbLogonInfoSize];

    Status DBGCHK = pLogonInfo ? STATUS_SUCCESS : STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(pLogonInfo, cbLogonInfoSize);

        pWhere = ((UCHAR*) pLogonInfo) + DataOffset;

        pLogonInfo->ServiceTicket = (UCHAR*) pWhere;
        pLogonInfo->ServiceTicketLength = cbTicketDataLength;

        RtlCopyMemory(pLogonInfo->ServiceTicket, pTicketData, cbTicketDataLength);

        pWhere += pLogonInfo->ServiceTicketLength;

        pLogonInfo->TicketGrantingTicketLength = cbTGTDataLength;

        if (pLogonInfo->TicketGrantingTicketLength)
        {
            pLogonInfo->TicketGrantingTicket = (UCHAR*) pWhere;
            RtlCopyMemory(pLogonInfo->TicketGrantingTicket, pTGTData, cbTGTDataLength);
        }

        *ppLogonInfo = pLogonInfo;
        pLogonInfo = NULL;
        *pLogonInfoSize = cbLogonInfoSize;
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}

NTSTATUS
LsaTicketLogon(
    IN HANDLE hLsa,
    IN ULONG ulPackageId,
    IN UCHAR* pTGTData,
    IN ULONG cbTGTDataLength,
    IN UCHAR* pTicketData,
    IN ULONG cbTicketDataLength,
    OUT LUID* pLogonId,
    OUT HANDLE* phUserToken
    )
{
    TNtStatus Status;

    SECURITY_LOGON_TYPE LogonType = Interactive;
    KERB_TICKET_LOGON* pLogonInfo = NULL;
    ULONG cbLogonInfoSize = sizeof(KERB_TICKET_LOGON);

    TOKEN_SOURCE SourceContext = {0};
    KERB_TICKET_PROFILE* pKerbTicketProfile = NULL;
    ULONG ProfileSize;
    STRING Name = {0};
    QUOTA_LIMITS Quotas = {0};
    NTSTATUS SubStatus;

    Status DBGCHK = BuildAllocTicketLogonInfo(
        pTGTData,
        cbTGTDataLength,
        pTicketData,
        cbTicketDataLength,
        sizeof(KERB_TICKET_LOGON),  //offset for data copy
        &cbLogonInfoSize, //initialized to struct size
        &pLogonInfo
        );

    if (NT_SUCCESS(Status))
    {
        pLogonInfo->MessageType = KerbTicketLogon;
        pLogonInfo->Flags = 0;

        strncpy(
            SourceContext.SourceName,
            "krlogind",
            sizeof(SourceContext.SourceName)
            );

        RtlInitString(&Name, "lzhu");

        Status DBGCHK = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaLogonUser(
            hLsa,
            &Name,
            LogonType,
            ulPackageId,
            pLogonInfo,
            cbLogonInfoSize,
            NULL,           // no token groups
            &SourceContext,
            (PVOID *) &pKerbTicketProfile,
            &ProfileSize,
            pLogonId,
            phUserToken,
            &Quotas,
            &SubStatus
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = SubStatus;
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", pLogonId->HighPart, pLogonId->LowPart);
        DebugPrintf(SSPI_LOG, "TokenHandle %p\n", *phUserToken);
        DebugPrintf(SSPI_LOG, "Quotas PagedPoolLimit %p, NonPagedPoolLimit %p, "
            "MinimumWorkingSetSize %p, MaximumWorkingSetSize %p, PagedPoolLimit %p\n",
            Quotas.PagedPoolLimit, Quotas.NonPagedPoolLimit,
            Quotas.MinimumWorkingSetSize, Quotas.MaximumWorkingSetSize,
            Quotas.PagedPoolLimit);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "TimeLimit", &Quotas.TimeLimit);

        KERB_INTERACTIVE_PROFILE* pKrbInteractiveProfile = &pKerbTicketProfile->Profile;
        DebugPrintf(SSPI_LOG, "interactive logon profile: "
            "LogCount %#x, BaddPasswordCount %#x, LogonScript %wZ, "
            "HomeDirectory %wZ, FullName %wZ, ProfilePath %wZ, "
            "HomeDriectoryDrive %wZ, LogonServer %wZ, UserFlags %#x\n",
             pKrbInteractiveProfile->LogonCount,
             pKrbInteractiveProfile->BadPasswordCount,
             &pKrbInteractiveProfile->LogonScript,
             &pKrbInteractiveProfile->HomeDirectory,
             &pKrbInteractiveProfile->FullName,
             &pKrbInteractiveProfile->ProfilePath,
             &pKrbInteractiveProfile->HomeDirectoryDrive,
             &pKrbInteractiveProfile->LogonServer,
             pKrbInteractiveProfile->UserFlags);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "LogonTime ", &pKrbInteractiveProfile->LogonTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "KickOffTime ", &pKrbInteractiveProfile->KickOffTime);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordLastSet ", &pKrbInteractiveProfile->PasswordLastSet);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordCanChange ", &pKrbInteractiveProfile->PasswordCanChange);
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "PasswordMustChange ", &pKrbInteractiveProfile->PasswordMustChange);
        DebugPrintHex(SSPI_LOG, "SessionKey:", sizeof(pKerbTicketProfile->SessionKey), &pKerbTicketProfile->SessionKey);
    }

    if (pKerbTicketProfile)
    {
        LsaFreeReturnBuffer(pKerbTicketProfile);
    }

    if (pLogonInfo)
    {
        delete [] pLogonInfo;
    }

    return Status;
}


NTSTATUS
KerbBuildKerbCredFromExternalTickets(
    IN PKERB_EXTERNAL_TICKET pTicket,
    IN PKERB_EXTERNAL_TICKET pDelegationTicket,
    OUT PUCHAR* pMarshalledKerbCred,
    OUT PULONG pcbKerbCredSize
    )
{
    TKerbErr KerbErr;

    KERB_CRED KerbCred;
    KERB_CRED_INFO_LIST CredInfo;
    KERB_ENCRYPTED_CRED EncryptedCred;
    KERB_CRED_TICKET_LIST TicketList;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    PUCHAR pMarshalledEncryptPart = NULL;
    ULONG MarshalledEncryptSize;
    ULONG ConvertedFlags;
    PKERB_TICKET pDecodedTicket = NULL;

    //
    // Initialize the structures so they can be freed later.
    //

    *pMarshalledKerbCred = NULL;
    *pcbKerbCredSize = 0;

    RtlZeroMemory(
        &KerbCred,
        sizeof(KERB_CRED)
        );

    RtlZeroMemory(
        &EncryptedCred,
        sizeof(KERB_ENCRYPTED_CRED)
        );
    RtlZeroMemory(
        &CredInfo,
        sizeof(KERB_CRED_INFO_LIST)
        );
    RtlZeroMemory(
        &TicketList,
        sizeof(KERB_CRED_TICKET_LIST)
        );

    KerbCred.version = KERBEROS_VERSION;
    KerbCred.message_type = KRB_CRED;


    //
    // Decode the ticket so we can put it in the structure (to re-encode it)
    //

    KerbErr DBGCHK = KerbUnpackData(
        pDelegationTicket->EncodedTicket,
        pDelegationTicket->EncodedTicketSize,
        KERB_TICKET_PDU,
        (PVOID *) &pDecodedTicket
        );

    //
    // First stick the ticket into the ticket list.
    //

    if (KERB_SUCCESS(KerbErr))
    {

        TicketList.next= NULL;
        TicketList.value = *pDecodedTicket;
        KerbCred.tickets = &TicketList;

        //
        // Now build the KERB_CRED_INFO for this ticket
        //

        CredInfo.value.key = * (PKERB_ENCRYPTION_KEY) &pDelegationTicket->SessionKey;
        KerbConvertLargeIntToGeneralizedTime(
            &CredInfo.value.endtime,
            NULL,
            &pDelegationTicket->EndTime
            );
        CredInfo.value.bit_mask |= endtime_present;

        KerbConvertLargeIntToGeneralizedTime(
            &CredInfo.value.starttime,
            NULL,
            &pDelegationTicket->StartTime
            );
        CredInfo.value.bit_mask |= KERB_CRED_INFO_starttime_present;

        KerbConvertLargeIntToGeneralizedTime(
            &CredInfo.value.KERB_CRED_INFO_renew_until,
            NULL,
            &pDelegationTicket->RenewUntil
            );
        CredInfo.value.bit_mask |= KERB_CRED_INFO_renew_until_present;
        ConvertedFlags = KerbConvertUlongToFlagUlong(pDelegationTicket->TicketFlags);
        CredInfo.value.flags.value = (PUCHAR) &ConvertedFlags;
        CredInfo.value.flags.length = 8 * sizeof(ULONG);
        CredInfo.value.bit_mask |= flags_present;

        KerbErr DBGCHK = KerbConvertKdcNameToPrincipalName(
            &CredInfo.value.principal_name,
            (PKERB_INTERNAL_NAME) pDelegationTicket->ClientName
            );
    }

    if (KERB_SUCCESS(KerbErr))
    {
        CredInfo.value.bit_mask |= principal_name_present;

        KerbErr DBGCHK = KerbConvertKdcNameToPrincipalName(
            &CredInfo.value.principal_name,
            (PKERB_INTERNAL_NAME) pDelegationTicket->ServiceName
            );
    }

    if (KERB_SUCCESS(KerbErr))
    {
        CredInfo.value.bit_mask |= principal_name_present;

        KerbErr DBGCHK = KerbConvertUnicodeStringToRealm(
            &CredInfo.value.principal_realm,
            &pDelegationTicket->DomainName
            );
    }

    //
    // The realms are the same, so don't allocate both
    //

    if (KERB_SUCCESS(KerbErr))
    {
        CredInfo.value.service_realm = CredInfo.value.service_realm;
        CredInfo.value.bit_mask |= principal_realm_present | service_realm_present;

        EncryptedCred.ticket_info = &CredInfo;

        //
        // Now encrypted the encrypted cred into the cred
        //

        KerbErr DBGCHK = KerbPackEncryptedCred(
            &EncryptedCred,
            &MarshalledEncryptSize,
            &pMarshalledEncryptPart
            );
    }

    //
    // If we are doing DES encryption, then we are talking with an non-NT
    // server. Hence, don't encrypt the kerb-cred.
    //

    if (KERB_SUCCESS(KerbErr))
    {
        if ((pTicket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_CRC) ||
            (pTicket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_MD5))
        {
            KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
            KerbCred.encrypted_part.cipher_text.value = pMarshalledEncryptPart;
            KerbCred.encrypted_part.encryption_type = 0;
            pMarshalledEncryptPart = NULL;
        }
        else
        {
            //
            // Now get the encryption overhead
            //

            KerbErr DBGCHK = KerbAllocateEncryptionBufferWrapper(
                pTicket->SessionKey.KeyType,
                MarshalledEncryptSize,
                &KerbCred.encrypted_part.cipher_text.length,
                &KerbCred.encrypted_part.cipher_text.value
                );

            //
            // Encrypt the data.
            //

            if (KERB_SUCCESS(KerbErr))
            {
                KerbErr DBGCHK = KerbEncryptDataEx(
                    &KerbCred.encrypted_part,
                    MarshalledEncryptSize,
                    pMarshalledEncryptPart,
                    pTicket->SessionKey.KeyType,
                    KERB_CRED_SALT,
                    (PKERB_ENCRYPTION_KEY) &pTicket->SessionKey
                    );
            }
        }
    }

    //
    // Now we have to marshall the whole KERB_CRED
    //

    if (KERB_SUCCESS(KerbErr))
    {
        KerbErr DBGCHK = KerbPackKerbCred(
            &KerbCred,
            pcbKerbCredSize,
            pMarshalledKerbCred
            );
    }

    if (pDecodedTicket != NULL)
    {
        KerbFreeData(
            KERB_TICKET_PDU,
            pDecodedTicket
            );
    }
    KerbFreePrincipalName(&CredInfo.value.service_name);

    KerbFreePrincipalName(&CredInfo.value.principal_name);

    KerbFreeRealm(&CredInfo.value.principal_realm);

    if (pMarshalledEncryptPart != NULL)
    {
        MIDL_user_free(pMarshalledEncryptPart);
    }
    if (KerbCred.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(KerbCred.encrypted_part.cipher_text.value);
    }

    return KerbMapKerbError(KerbErr);
}

NTSTATUS
TicketLogon(
   IN LUID* pLogonId,
   IN PCSTR pszServicePrincipal,
   OUT HANDLE* phToken
   )
{
    TNtStatus Status;

    HANDLE hLogon = NULL;
    ULONG PackageId = -1;

    KERB_EXTERNAL_TICKET* pTGTExternal = NULL;
    KERB_RETRIEVE_TKT_RESPONSE* pTicketCacheResponse = NULL;

    UNICODE_STRING ServicePrincipal = {0};

    UCHAR* pMarshalledTGT = NULL;
    ULONG ulTGTSize = 0;

    LUID UserId;

    Status DBGCHK = CreateUnicodeStringFromAsciiz(pszServicePrincipal, &ServicePrincipal);

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetLsaHandleAndPackageId(
            MICROSOFT_KERBEROS_NAME_A,
            &hLogon,
            &PackageId
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetTGT(
            hLogon,
            PackageId,
            pLogonId,
            &pTGTExternal
            );
    }

    //
    // get service pTicket
    //

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = GetServiceTicket(
            hLogon,
            PackageId,
            &ServicePrincipal,
            pLogonId,
            FALSE,
            &pTicketCacheResponse
            );
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintSysTimeAsLocalTime(SSPI_LOG, "StartTime: ", &pTGTExternal->StartTime);

        Status DBGCHK = KerbBuildKerbCredFromExternalTickets(
            &pTicketCacheResponse->Ticket,
            pTGTExternal,
            &pMarshalledTGT,
            &ulTGTSize
            );
    }

    if (NT_SUCCESS(Status))
    {
        Status DBGCHK = LsaTicketLogon(
            hLogon,
            PackageId,
            pMarshalledTGT,
            ulTGTSize,
            pTicketCacheResponse->Ticket.EncodedTicket,
            pTicketCacheResponse->Ticket.EncodedTicketSize,
            &UserId,
            phToken
            );
    }

    if (hLogon)
    {
        LsaDeregisterLogonProcess(hLogon);
    }

    if (pTGTExternal)
    {
        LsaFreeReturnBuffer(pTGTExternal);
    }

    if (pTicketCacheResponse)
    {
        LsaFreeReturnBuffer(pTicketCacheResponse);
    }

    if (pMarshalledTGT)
    {
        MIDL_user_free(pMarshalledTGT);
    }

    RtlFreeUnicodeString(&ServicePrincipal);

    return Status;
}

VOID
__cdecl
main(
    IN INT argc,
    IN PSTR argv[]
    )
{
    TNtStatus Status = STATUS_SUCCESS;
    HANDLE hToken = NULL;

    LUID LogonId = {0};

    if (argc != 4)
    {
        Usage(argv[0]);
    }

    LogonId.HighPart = strtol(argv[1], NULL, 0);
    LogonId.LowPart = strtol(argv[2], NULL, 0);

    DebugPrintf(SSPI_LOG, "LogonId %#x:%#x\n", LogonId.HighPart, LogonId.LowPart);
    DebugPrintf(SSPI_LOG, "service principal is %s\n", argv[3]);

    Status DBGCHK = TicketLogon(&LogonId, argv[3], &hToken);

    if (NT_SUCCESS(Status))
    {
        UNICODE_STRING Application = {0};

        Status DBGCHK = CreateUnicodeStringFromAsciiz("cmd.exe", &Application);

        if (NT_SUCCESS(Status))
        {
            Status DBGCHK = StartInteractiveClientProcessAsUser(hToken, Application.Buffer);
        }

        RtlFreeUnicodeString(&Application);
    }

    if (NT_SUCCESS(Status))
    {
        DebugPrintf(SSPI_LOG, "tktlogon succeeded\n");
    }
    else
    {
        DebugPrintf(SSPI_ERROR, "tktlogon failed\n");
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\pwdssp\pwdssp.h ===
#ifndef __PWDSSP_H__
#define __PWDSSP_H__

#define PWDSSP_NAME_A   "PWDSSP"
#define PWDSSP_NAME_W   L"PWDSSP"

#ifdef UNICODE
#define PWDSSP_NAME PWDSSP_NAME_W
#else
#define PWDSSP_NAME PWDSSP_NAME_A
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\pwdssp\pwdsspp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pwdsspp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-08-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __PWDSSPP_H__
#define __PWDSSPP_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <lm.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <dnsapi.h>
#include <ntdsa.h>

#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>

#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>

#include <kerberos.h>

#include "pwdssp.h"


BOOL
CacheInitialize(
    VOID
    );

BOOL
PwdCrackName(
    PWSTR DN,
    PWSTR FlatDomain,
    PWSTR FlatUser
    );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __PWDSSPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\pwdssp\tpwd.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       tpwd.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-08-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <rpc.h>
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>

#define SECURITY_WIN32
#include <security.h>
#include <pwdssp.h>

VOID
wgets(
    PWSTR s
    )
{
    CHAR Buffer[MAX_PATH ];

    gets(Buffer);
    MultiByteToWideChar(
        CP_ACP, 0,
        Buffer, -1,
        s, MAX_PATH );

}

void __cdecl main (int argc, char *argv[])
{
    SEC_WINNT_AUTH_IDENTITY_W Wide ;
    CredHandle Cred ;
    CtxtHandle Ctxt ;
    WCHAR Name[ MAX_PATH ];
    WCHAR Password[ 64 ];
    WCHAR Domain[ MAX_PATH ];
    SECURITY_STATUS scRet ;
    TimeStamp ts ;
    SecBufferDesc Input ;
    SecBuffer InputBuffer ;
    SecBufferDesc Output ;
    ULONG Flags ;
    CHAR Buffer[ MAX_PATH ];

    scRet = AcquireCredentialsHandleW(
                    NULL,
                    PWDSSP_NAME_W,
                    SECPKG_CRED_INBOUND,
                    NULL, NULL, NULL, NULL,
                    &Cred, &ts );

    if ( scRet != 0 )
    {
        printf("AcquireCredentialsHandleW failed with %x\n", scRet );
        exit(0);
    }


    do
    {
        ZeroMemory(Name, sizeof(Name));
        ZeroMemory(Password, sizeof(Password));
        ZeroMemory(Domain, sizeof(Domain));


        printf("Enter name, or 'quit' to quit>");
        wgets( Name );
        if ( wcscmp( Name, L"quit") == 0 )
        {
            break;
        }

        printf("Enter password>" );
        wgets( Password );

        printf("Enter domain>");
        wgets( Domain );

        //
        // Format "blob"
        //

        ZeroMemory( &Wide, sizeof( Wide ) );

        Wide.User = Name ;
        Wide.UserLength = wcslen( Name );
        if ( Domain[0] )
        {
            Wide.Domain = Domain ;
            Wide.DomainLength = wcslen( Domain );
        }
        else
        {
            Wide.Domain = NULL ;
            Wide.DomainLength = 0 ;
        }
        Wide.Password = Password ;
        Wide.PasswordLength = wcslen( Password );
        Wide.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ;

        InputBuffer.BufferType = SECBUFFER_TOKEN ;
        InputBuffer.pvBuffer = &Wide ;
        InputBuffer.cbBuffer = sizeof( Wide );

        Input.pBuffers = &InputBuffer;
        Input.cBuffers = 1;
        Input.ulVersion = 0;

        scRet = AcceptSecurityContext(
                    &Cred,
                    NULL,
                    &Input,
                    0,
                    SECURITY_NATIVE_DREP,
                    &Ctxt,
                    &Output,
                    &Flags,
                    &ts );

        if ( scRet != 0 )
        {
            printf(" FAILED, %x\n", scRet );
        }
        else
        {
            printf(" SUCCESS\n" );
            DeleteSecurityContext( &Ctxt );
        }



    } while ( 1 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\pwdssp\crack.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       crack.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-07-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "pwdsspp.h"



BOOL
CacheInitialize(
    VOID
    )
{
    return TRUE ;
}


BOOL
PwdCrackName(
    PWSTR DN,
    PWSTR FlatDomain,
    PWSTR FlatUser
    )
{
    WCHAR FlatName[ 128 ];
    WCHAR DnsDomain[ 256 ];
    DWORD DnsSize ;
    DWORD Size ;
    NTSTATUS Status ;
    DWORD DsError ;
    PWSTR Scan ;
    PVOID DsContext ;

    Size = sizeof( FlatName ) / sizeof(WCHAR) ;
    DnsSize = sizeof( DnsDomain ) / sizeof( WCHAR );

    DsContext = THSave();

    __try
    {
        Status = CrackSingleName(
                        DS_UNKNOWN_NAME,
                        0,
                        DN,
                        DS_NT4_ACCOUNT_NAME,
                        &DnsSize,
                        DnsDomain,
                        &Size,
                        FlatName,
                        &DsError );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        THRestore( DsContext );

        return FALSE ;
    }

    if ( DsError == DS_NAME_ERROR_DOMAIN_ONLY )
    {
        Size = sizeof( FlatName ) / sizeof( WCHAR ) ;

        DnsSize = sizeof( DnsDomain ) / sizeof( WCHAR );

        Status = CrackSingleName(
                            DS_UNKNOWN_NAME,
                            DS_NAME_FLAG_GCVERIFY,
                            DN,
                            DS_NT4_ACCOUNT_NAME,
                            &DnsSize,
                            DnsDomain,
                            &Size,
                            FlatName,
                            &DsError );

    }

    THRestore( DsContext );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( DsError == DS_NAME_NO_ERROR )
    {
        Scan = wcschr( FlatName, L'\\' );

        if ( Scan )
        {
            *Scan++ = L'\0' ;
            wcscpy(FlatDomain, FlatName );
            wcscpy(FlatUser, Scan );
        }
        else
        {
            wcscpy(FlatUser, FlatName );
            FlatDomain[0] = L'\0';
        }

        return TRUE ;

    }

    return FALSE ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\msv_sspi\utesta\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr

#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
#include <ntlmsp.h>    // External definition of the NtLmSsp service

BOOLEAN QuietMode = FALSE; // Don't be verbose

// BUGBUG Should be in the SDK?
#define MSV1_0_PACKAGE_NAMEW     L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define KERBEROS_PACKAGE_NAME "Kerberos"

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields = {0};

/*
        RtlTimeToTimeFields( &LocalTime, &TimeFields );
*/

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;

    }

    printf( "\n" );
}

VOID
TestLpcRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base LPC functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount,i;
    PSecPkgInfo PackageInfo;
    PSecPkgInfo pTmp;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< PackageCount; i++)
      {
        pTmp = (PackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pTmp->Name, pTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pTmp->fCapabilities,
                pTmp->wVersion,
                pTmp->wRPCID,
                pTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( KERBEROS_PACKAGE_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    KERBEROS_PACKAGE_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
#define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    KERBEROS_PACKAGE_NAME, // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    "\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    "\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
    }

    if ( NT_SUCCESS(SecStatus) )
    {
        if ( !QuietMode )
        {
            PrintTime("   Start:", ContextLifespan.tsStart );
            PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        }
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    "\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

/*
    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }
*/


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    enum {
        NoAction,
        ConfigureService,
#define CONFIG_PARAM "/ConfigureService"
        TestLpc,
#define TESTLPC_PARAM "/TestLpc"
#define TESTLPC2_PARAM "/TestLpc:"
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /TestLpc
        //

        if ( _stricmp( argument, TESTLPC_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;
            Iterations = 1;

        //
        // Handle /TestLpc:
        //

        } else if ( _strnicmp( argument,
                              TESTLPC2_PARAM,
                              sizeof(TESTLPC2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;

            Iterations = strtoul( &argument[sizeof(TESTLPC2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        } else {
        //
        // Handle all other parameters
        //

Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTLPC_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic LPC to NtLmSsp service.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {
    case TestLpc: {
        for ( j=0; j<Iterations ; j++ ) {
            TestLpcRoutine( DomainName, UserName, Password );
        }
        break;
    }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\pwdssp\pwdssp.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pwdssp.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-07-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include "pwdsspp.h"

typedef struct _PWD_CRED {
    DWORD   Ref;
} PWD_CRED, * PPWD_CRED;

typedef struct _PWD_CONTEXT {
    DWORD   Tag;
    HANDLE  Token;
} PWD_CONTEXT, *PPWD_CONTEXT ;

PWD_CRED            PwdGlobalAnsi;
PWD_CRED            PwdGlobalUnicode;

#define CONTEXT_TAG 'txtC'
#define ANONYMOUS_TOKEN ((HANDLE) 1)

SecPkgInfoA PwdInfoA = {    SECPKG_FLAG_CONNECTION |
                                SECPKG_FLAG_ACCEPT_WIN32_NAME,
                            1,
                            (WORD) -1,
                            768,
                            PWDSSP_NAME_A,
                            "Microsoft Clear Text Password Security Provider" };

SecPkgInfoW PwdInfoW = {    SECPKG_FLAG_CONNECTION |
                                SECPKG_FLAG_ACCEPT_WIN32_NAME,
                            1,
                            (WORD) -1,
                            768,
                            PWDSSP_NAME_W,
                            L"Microsoft Clear Text Password Security Provider" };




SecurityFunctionTableA  PwdTableA = {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesA,
        NULL,
        AcquireCredentialsHandleA,
        FreeCredentialsHandle,
        NULL,
        InitializeSecurityContextA,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesA,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoA,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        QuerySecurityContextToken
        };

SecurityFunctionTableW  PwdTableW = {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesW,
        NULL,
        AcquireCredentialsHandleW,
        FreeCredentialsHandle,
        NULL,
        InitializeSecurityContextW,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesW,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoW,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        QuerySecurityContextToken
        };


//#define PwdAlloc(x) LsaIAllocateHeap(x)
//#define PwdFree(x)  LsaIFreeHeap(x)
#define PwdAlloc(x) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,x)
#define PwdFree(x)  LocalFree(x)

NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password,
    IN ULONG VerifyFlags
    );

UNICODE_STRING AuthenticationPackage;

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Entry point
//
//  Arguments:  [hInstance]  --
//              [dwReason]   --
//              [lpReserved] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls( hInstance );
        RtlInitUnicodeString(&AuthenticationPackage, MICROSOFT_KERBEROS_NAME_W);

        if ( !CacheInitialize() ) {
            return FALSE;
        }
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   PwdpParseBuffers
//
//  Synopsis:   Parse out right buffer descriptor
//
//  Arguments:  [pMessage] --
//              [pToken]   --
//              [pEmpty]   --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
PwdpParseBuffers(
    PSecBufferDesc  pMessage,
    PSecBuffer *    pToken,
    PSecBuffer *    pEmpty)
{
    ULONG       i;
    PSecBuffer  pFirstBlank = NULL;
    PSecBuffer  pWholeMessage = NULL;


    for (i = 0 ; i < pMessage->cBuffers ; i++ )
    {
        if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
        {
            pWholeMessage = &pMessage->pBuffers[i];
            if (pFirstBlank)
            {
                break;
            }
        }
        else if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_EMPTY )
        {
            pFirstBlank = &pMessage->pBuffers[i];
            if (pWholeMessage)
            {
                break;
            }
        }
    }

    if (pToken)
    {
        *pToken = pWholeMessage;
    }

    if (pEmpty)
    {
        *pEmpty = pFirstBlank;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:   Get the credential handle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [GetKey]           --
//              [phCredential]     --
//              [PTimeStamp]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    if (_wcsicmp(pszPackageName, PWDSSP_NAME_W))
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( fCredentialUse & SECPKG_CRED_OUTBOUND )
    {
        return( SEC_E_NO_CREDENTIALS );
    }

    InterlockedIncrement( &PwdGlobalUnicode.Ref );

    phCredential->dwUpper = (ULONG_PTR) &PwdGlobalUnicode ;

    if ( ptsExpiry )
    {
        ptsExpiry->LowPart = (DWORD) 0xFFFFFFFF;
        ptsExpiry->HighPart = (DWORD) 0x7FFFFFFF;
    }

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:   ANSI entry
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [GetKey]           --
//              [phCredential]     --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{

    if (_stricmp(pszPackageName, PWDSSP_NAME_A))
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( fCredentialUse & SECPKG_CRED_OUTBOUND )
    {
        return( SEC_E_NO_CREDENTIALS );
    }

    InterlockedIncrement( &PwdGlobalAnsi.Ref );

    phCredential->dwUpper = (ULONG_PTR) &PwdGlobalAnsi ;

    if ( ptsExpiry )
    {
        ptsExpiry->LowPart = (DWORD) 0xFFFFFFFF;
        ptsExpiry->HighPart = (DWORD) 0x7FFFFFFF;
    }


    return(SEC_E_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeCredentialHandle
//
//  Synopsis:   Free a credential handle
//
//  Arguments:  [free] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    PPWD_CRED Cred;

    if ( (phCredential->dwUpper != (ULONG_PTR) &PwdGlobalAnsi ) &&
         (phCredential->dwUpper != (ULONG_PTR) &PwdGlobalUnicode ) )
    {
        return( SEC_E_INVALID_HANDLE );
    }

    Cred = (PPWD_CRED) phCredential->dwUpper ;

    InterlockedDecrement( &Cred->Ref );

    return( SEC_E_OK );

}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextW
//
//  Synopsis:   Initialize a security context (outbound) NOT SUPPORTED
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}


//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:   NOT SUPPORTED
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

PSEC_WINNT_AUTH_IDENTITY_A
PwdpMakeAnsiCopy(
    PSEC_WINNT_AUTH_IDENTITY_A  Ansi
    )
{
    PSEC_WINNT_AUTH_IDENTITY_A  New ;

    New = PwdAlloc( sizeof( SEC_WINNT_AUTH_IDENTITY_A ) +
                            Ansi->UserLength + 1 +
                            Ansi->DomainLength + 1 +
                            Ansi->PasswordLength + 1 );

    if ( New )
    {
        New->User = (PSTR) (New + 1);
        CopyMemory( New->User, Ansi->User, Ansi->UserLength );
        New->User[ Ansi->UserLength ] = '\0';

        New->Domain = New->User + Ansi->UserLength + 1 ;
        CopyMemory( New->Domain, Ansi->Domain, Ansi->DomainLength );
        New->Domain[ Ansi->DomainLength ] = '\0';

        New->Password = New->Domain + Ansi->DomainLength + 1 ;
        CopyMemory( New->Password, Ansi->Password, Ansi->PasswordLength );
        New->Password[ Ansi->PasswordLength ] = '\0';

    }

    return( New );
}

PSEC_WINNT_AUTH_IDENTITY_W
PwdpMakeWideCopy(
    PSEC_WINNT_AUTH_IDENTITY_W  Wide,
    BOOLEAN ValidateOnly
    )
{
    PSEC_WINNT_AUTH_IDENTITY_W  New ;
    ULONG FlatUserLength ;
    PWSTR FlatUser = NULL;
    WCHAR FlatDomain[ DNLEN + 2 ];
    SEC_WINNT_AUTH_IDENTITY_W Local ;

    if ( (Wide->Domain == NULL) )
    {
        if( ValidateOnly )
        {
            ULONG Index;

            Local = *Wide ;

            FlatUserLength = wcslen( Wide->User );

            for( Index = 0 ; Index < FlatUserLength ; Index++ )
            {
                if( Wide->User[ Index ] == '\\' )
                {
                    Local.Domain = Wide->User;
                    Local.DomainLength = Index;

                    Local.User = &(Wide->User[Index+1]);
                    Local.UserLength = FlatUserLength - Index - 1;
                    break;
                }
            }

        } else {

            FlatUserLength = wcslen( Wide->User ) + 1;
            if ( FlatUserLength < UNLEN+2 )
            {
                FlatUserLength = UNLEN + 2;
            }

            FlatUser = PwdAlloc(FlatUserLength * sizeof( WCHAR ));
            if ( FlatUser == NULL )
            {
                return NULL ;
            }
            if ( ! PwdCrackName( Wide->User,
                          FlatDomain,
                          FlatUser ) )
            {
                PwdFree( FlatUser );
                SetLastError( ERROR_NO_SUCH_USER );
                return NULL ;
            }

            Local = *Wide ;
            Local.User = FlatUser ;
            Local.Domain = FlatDomain ;
            Local.UserLength = wcslen( FlatUser );
            Local.DomainLength = wcslen( FlatDomain );
        }

        Wide = &Local ;

    }

    New = PwdAlloc( sizeof( SEC_WINNT_AUTH_IDENTITY_W ) +
                            (Wide->UserLength + 1) * sizeof(WCHAR) +
                            (Wide->DomainLength + 1) * sizeof(WCHAR) +
                            (Wide->PasswordLength + 1) * sizeof(WCHAR) );

    if ( New )
    {
        New->User = (PWSTR) (New + 1);
        CopyMemory( New->User, Wide->User, Wide->UserLength * 2 );
        New->User[ Wide->UserLength ] = L'\0';

        New->UserLength = Wide->UserLength;

        New->Domain = New->User + Wide->UserLength + 1 ;
        CopyMemory( New->Domain, Wide->Domain, Wide->DomainLength * 2 );
        New->Domain[ Wide->DomainLength ] = L'\0';

        New->DomainLength = Wide->DomainLength;

        New->Password = New->Domain + Wide->DomainLength + 1 ;
        CopyMemory( New->Password, Wide->Password, Wide->PasswordLength * 2);
        New->Password[ Wide->PasswordLength ] = '\0';

        New->PasswordLength = Wide->PasswordLength;

    }

    if ( Wide == &Local )
    {
        if( FlatUser != NULL )
        {
            PwdFree( FlatUser );
        }
    }

    return( New );

}



//+---------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:   Server side accept security context
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    PPWD_CONTEXT    Context ;
    PSecBuffer      Buffer ;
    DWORD           Type;
    PSEC_WINNT_AUTH_IDENTITY_W  Unknown ;
    PSEC_WINNT_AUTH_IDENTITY_A  Ansi;
    PSEC_WINNT_AUTH_IDENTITY_W  Unicode;
    HANDLE          Token;
    BOOL            Ret;

    if ( phCredential->dwUpper == (ULONG_PTR) &PwdGlobalAnsi )
    {
        Type = 1;
    }
    else
    {
        if ( phCredential->dwUpper == (ULONG_PTR) &PwdGlobalUnicode )
        {
            Type = 2;
        }
        else
        {
            return( SEC_E_INVALID_HANDLE );
        }
    }


    PwdpParseBuffers( pInput, &Buffer, NULL );

    if ( !Buffer )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    Unknown = (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer ;

    if ( Unknown->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE )
    {
        Type = 2 ;
    }

    if ( Type == 1 )
    {
        //
        // ANSI:
        //

        Ansi = PwdpMakeAnsiCopy( (PSEC_WINNT_AUTH_IDENTITY_A) Buffer->pvBuffer);

        if ( Ansi )
        {
            Ret = LogonUserA( Ansi->User, Ansi->Domain, Ansi->Password,
                             LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT,
                             &Token ) ;

            RtlSecureZeroMemory( Ansi->Password, Ansi->PasswordLength );
            PwdFree( Ansi );
        }
        else
        {
            Ret = FALSE ;
        }
    }
    else
    {
        BOOLEAN ValidateOnly = ((fContextReq & ASC_REQ_ALLOW_NON_USER_LOGONS) != 0);

        Unicode = PwdpMakeWideCopy(
                        (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer,
                        ValidateOnly
                        );

        if ( Unicode )
        {
            if( ValidateOnly )
            {
                PVOID DsContext = THSave();
                NTSTATUS Status;

                Status = VerifyCredentials(
                            Unicode->User,
                            Unicode->Domain,
                            Unicode->Password,
                            0
                            );

                THRestore( DsContext );

                if( NT_SUCCESS(Status) )
                {
                    Ret = TRUE;

                    Token = ANONYMOUS_TOKEN ;

                } else {
                    Ret = FALSE;
                }

            } else {
                Ret = LogonUserW(
                        Unicode->User,
                        Unicode->Domain,
                        Unicode->Password,
                        LOGON32_LOGON_NETWORK,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token
                        );
            }


            RtlSecureZeroMemory( Unicode->Password, Unicode->PasswordLength * sizeof(WCHAR) );
            PwdFree( Unicode );
        }
        else
        {
            Ret = FALSE ;

            if ( GetLastError() == ERROR_NO_SUCH_USER )
            {
                Unicode = (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer ;

                __try 
                {
                    if ( Unicode->PasswordLength == 0 )
                    {
                        Ret = TRUE ;
                        Token = ANONYMOUS_TOKEN ;
                    }
                }
                __except( EXCEPTION_EXECUTE_HANDLER )
                {
                    NOTHING ;
                }
            }
        }
    }

    if ( Ret )
    {
        Context = (PPWD_CONTEXT) PwdAlloc( sizeof( PWD_CONTEXT ) );

        if ( Context )
        {
            Context->Tag = CONTEXT_TAG ;

            Context->Token = Token ;

            phNewContext->dwUpper = (ULONG_PTR) Context ;

            return( SEC_E_OK );
        }

        if ( Token != ANONYMOUS_TOKEN )
        {
            CloseHandle( Token );
        }


        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    return( SEC_E_INVALID_TOKEN );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:   Deletes a security context
//
//  Arguments:  [phContext] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle  phContext )
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

#if DBG
    // What is the appropriate assert model?  This dll does not seem to
    // nt specific, win32 does not provide a model, and the crt requires
    // NDEBUG to set, which is not always the case.
    if (!Context) {
        OutputDebugStringA("[PWDSSP]: !!Error!! - Context is NULL\n");
        DebugBreak();
    }
#endif

    if ( Context->Tag == CONTEXT_TAG )
    {
        if ( Context->Token != ANONYMOUS_TOKEN )
        {
            CloseHandle( Context->Token );
        }

        PwdFree( Context );

        return( SEC_E_OK );
    }

    return( SEC_E_INVALID_HANDLE );

}

//+---------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:   Impersonate the security context
//
//  Arguments:  [impersonate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    PPWD_CONTEXT    Context;
    HANDLE  hThread;
    NTSTATUS Status ;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        if ( Context->Token != ANONYMOUS_TOKEN )
        {
            hThread = GetCurrentThread();

            if(SetThreadToken( &hThread, Context->Token ))
            {
                Status = SEC_E_OK ;
            } else {
                Status = SEC_E_NO_IMPERSONATION;
            }
        }
        else 
        {
            Status = NtImpersonateAnonymousToken(
                            NtCurrentThread() );

        }

        return( Status );

    }

    return( SEC_E_INVALID_HANDLE );
}



//+---------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:   Revert the security context
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        RevertToSelf();

        return( SEC_E_OK );

    }

    return( SEC_E_INVALID_HANDLE );

}

SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


//+---------------------------------------------------------------------------
//
//  Function:   PwdpCopyInfoW
//
//  Synopsis:   Helper - copy package info around
//
//  Arguments:  [ppPackageInfo] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PwdpCopyInfoW(
    PSecPkgInfoW *  ppPackageInfo)
{
    DWORD           cbTotal;
    PSecPkgInfoW    pInfo;
    PWSTR           pszCopy;

    cbTotal = sizeof(SecPkgInfoW) +
              (wcslen(PwdInfoW.Name) + wcslen(PwdInfoW.Comment) + 2) * 2;

    pInfo = PwdAlloc( cbTotal );

    if (pInfo)
    {
        *pInfo = PwdInfoW;

        pszCopy = (PWSTR) (pInfo + 1);

        pInfo->Name = pszCopy;

        wcscpy(pszCopy, PwdInfoW.Name);

        pszCopy += wcslen(PwdInfoW.Name) + 1;

        pInfo->Comment = pszCopy;

        wcscpy(pszCopy, PwdInfoW.Comment);

        *ppPackageInfo = pInfo;

        return(SEC_E_OK);

    }

    return(SEC_E_INSUFFICIENT_MEMORY);

}

//+---------------------------------------------------------------------------
//
//  Function:   PwdpCopyInfoA
//
//  Synopsis:   copy ansi package info around
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PwdpCopyInfoA(
    PSecPkgInfoA *  ppPackageInfo)
{
    DWORD           cbTotal;
    PSecPkgInfoA    pInfo;
    PSTR            pszCopy;

    cbTotal = sizeof(SecPkgInfoA) +
              strlen(PwdInfoA.Name) + strlen(PwdInfoA.Comment) + 2;

    pInfo = PwdAlloc( cbTotal );

    if (pInfo)
    {
        *pInfo = PwdInfoA;

        pszCopy = (PSTR) (pInfo + 1);

        pInfo->Name = pszCopy;

        strcpy(pszCopy, PwdInfoA.Name);

        pszCopy += strlen(PwdInfoA.Name) + 1;

        pInfo->Comment = pszCopy;

        strcpy(pszCopy, PwdInfoA.Comment);

        *ppPackageInfo = pInfo;

        return(SEC_E_OK);

    }

    return(SEC_E_INSUFFICIENT_MEMORY);

}


//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:   Enumerate packages in this DLL
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet;

    *ppPackageInfo = NULL;

    scRet = PwdpCopyInfoW(ppPackageInfo);
    if (SUCCEEDED(scRet))
    {
        *pcPackages = 1;
        return(scRet);
    }

    *pcPackages = 0;

    return(scRet);

}
//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:   Enumerate
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet;

    *ppPackageInfo = NULL;

    scRet = PwdpCopyInfoA(ppPackageInfo);
    if (SUCCEEDED(scRet))
    {
        *pcPackages = 1;
        return(scRet);
    }

    *pcPackages = 0;

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:   Query individual package info
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *               ppPackageInfo       // Receives package info
    )
{
    if (_wcsicmp(pszPackageName, PWDSSP_NAME_W))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(PwdpCopyInfoW(ppPackageInfo));
}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:   Same, ansi
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *               ppPackageInfo       // Receives package info
    )
{
    if (_stricmp(pszPackageName, PWDSSP_NAME_A))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(PwdpCopyInfoA(ppPackageInfo));
}


SECURITY_STATUS
SEC_ENTRY
MakeSignature(PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS
SEC_ENTRY
SealMessage(PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
UnsealMessage(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle phContext,              // Context to modify
    PSecBufferDesc pInput               // Input token to apply
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

SECURITY_STATUS
SEC_ENTRY
FreeContextBuffer(
    PVOID   p)
{
    if( p != NULL )
    {
        PwdFree( p );
    }

    return( SEC_E_OK );
}

SECURITY_STATUS
SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle phContext,
    PHANDLE Token)
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        *Token = Context->Token ;

        return( SEC_E_OK );

    }

    return( SEC_E_INVALID_HANDLE );

}


SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


PSecurityFunctionTableA
SEC_ENTRY
InitSecurityInterfaceA( VOID )
{
    return( &PwdTableA );
}

PSecurityFunctionTableW
SEC_ENTRY
InitSecurityInterfaceW( VOID )
{
    return( &PwdTableW );
}


NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password,
    IN ULONG VerifyFlags
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST pVerifyRequest;
    KERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest;

    ULONG cbVerifyRequest;

    PVOID pResponse = NULL;
    ULONG cbResponse;

    USHORT cbUserName;
    USHORT cbDomainName;
    USHORT cbPassword;

    NTSTATUS ProtocolStatus = STATUS_LOGON_FAILURE;
    NTSTATUS Status;

    cbUserName = (USHORT)(lstrlenW(UserName) * sizeof(WCHAR)) ;
    cbDomainName = (USHORT)(lstrlenW(DomainName) * sizeof(WCHAR)) ;
    cbPassword = (USHORT)(lstrlenW(Password) * sizeof(WCHAR)) ;



    cbVerifyRequest = sizeof(VerifyRequest) +
                        cbUserName +
                        cbDomainName +
                        cbPassword ;

    pVerifyRequest = &VerifyRequest;
    ZeroMemory( &VerifyRequest, sizeof(VerifyRequest) );


    pVerifyRequest->MessageType = KerbVerifyCredentialsMessage ;

    //
    // do the length, buffers, copy,  marshall dance.
    //

    pVerifyRequest->UserName.Length = cbUserName;
    pVerifyRequest->UserName.MaximumLength = cbUserName;
    pVerifyRequest->UserName.Buffer = UserName;

    pVerifyRequest->DomainName.Length = cbDomainName;
    pVerifyRequest->DomainName.MaximumLength = cbDomainName;
    pVerifyRequest->DomainName.Buffer = DomainName;

    pVerifyRequest->Password.Length = cbPassword;
    pVerifyRequest->Password.MaximumLength = cbPassword;
    pVerifyRequest->Password.Buffer = Password;

    pVerifyRequest->VerifyFlags = VerifyFlags;

    Status = I_LsaICallPackage(
                &AuthenticationPackage,
                pVerifyRequest,
                cbVerifyRequest,
                &pResponse,
                &cbResponse,
                &ProtocolStatus
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = ProtocolStatus;

Cleanup:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ber.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __BER_H__
#define __BER_H__


#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            (16 | BER_CONSTRUCTED)
#define BER_SET                 (17 | BER_CONSTRUCTED)

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_IA5STRING           0x16
#define BER_GRAPHIC_STRING      0x19

#define BER_UTC_TIME            23

typedef int (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\callback.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Created
//
//----------------------------------------------------------------------------
#define SECURITY_PACKAGE
#include <secint.h>

#define SCH_FLAG_READ_KEY       1
#define SCH_FLAG_WRITE_KEY      2

// Application process callbacks
#define SCH_SIGNATURE_CALLBACK              1
#define SCH_UPLOAD_CREDENTIAL_CALLBACK      2
#define SCH_UPLOAD_CERT_STORE_CALLBACK      3
#define SCH_ACQUIRE_CONTEXT_CALLBACK        4
#define SCH_RELEASE_CONTEXT_CALLBACK        5
#define SCH_DOWNLOAD_CERT_CALLBACK          6
#define SCH_GET_USER_KEYS                   7

typedef struct _SCH_CALLBACK_LIST
{
    DWORD                   dwTag;
    PLSA_CALLBACK_FUNCTION  pFunction;
} SCH_CALLBACK_LIST;

extern SCH_CALLBACK_LIST g_SchannelCallbacks[];
extern DWORD g_cSchannelCallbacks;

SECURITY_STATUS
PerformApplicationCallback(
    DWORD dwCallback,
    ULONG_PTR dwArg1,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput,
    BOOL fExpectOutput);

BOOL
DuplicateApplicationHandle(
    HANDLE   hAppHandle,
    LPHANDLE phLsaHandle);

SECURITY_STATUS
SerializeCertContext(
    PCCERT_CONTEXT pCertContext,
    PBYTE          pbBuffer,
    PDWORD         pcbBuffer);

SECURITY_STATUS
DeserializeCertContext(
    PCCERT_CONTEXT *ppCertContext,
    PBYTE           pbBuffer,
    DWORD           cbBuffer);

NTSTATUS
RemoteCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR     pwszContainer,
    LPCWSTR     pwszProvider,
    DWORD       dwProvType,
    DWORD       dwFlags);

BOOL
RemoteCryptReleaseContext(
    HCRYPTPROV  hProv,
    DWORD       dwFlags);

SP_STATUS
SignHashUsingCallback(
    HCRYPTPROV  hProv,
    DWORD       dwKeySpec,
    ALG_ID      aiHash,
    PBYTE       pbHash,
    DWORD       cbHash,
    PBYTE       pbSignature,
    PDWORD      pcbSignature,
    DWORD       fHashData);

SP_STATUS
SPGetUserKeys(
    PSPContext  pContext,
    DWORD       dwFlags);

VOID *
PvExtVirtualAlloc(DWORD cb);

SECURITY_STATUS
FreeExtVirtualAlloc(PVOID pv, SIZE_T cbMem);

SECURITY_STATUS
SPFreeUserAllocMemory(PVOID pv, SIZE_T cbMem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\cache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cache.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#include <sslcache.h>

#define SP_CACHE_MAGIC     0xCACE

#define SP_CACHE_FLAG_EMPTY                         0x00000001
#define SP_CACHE_FLAG_READONLY                      0x00000002
#define SP_CACHE_FLAG_MASTER_EPHEM                  0x00000004
#define SP_CACHE_FLAG_USE_VALIDATED                 0x00000010  // Whether user has validated client credential.

struct _SPContext;

typedef struct _SessCacheItem {

    DWORD               Magic;
    DWORD               dwFlags;

    LONG                cRef; 

    DWORD               ZombieJuju;
    DWORD               fProtocol;
    DWORD               CreationTime;
    DWORD               Lifespan;
    DWORD               DeferredJuju;

    // List of cache entries assigned to a particular cache index.
    LIST_ENTRY          IndexEntryList;

    // Global list of cache entries sorted by creation time.
    LIST_ENTRY          EntryList;

    // Process ID of process that owns this cache entry.
    ULONG               ProcessID;


    HMAPPER *           phMapper;

    // Handle to "Schannel" key container used to store the server's master 
    // secret. This will either be the one corresponding to the server's
    // credentials or the 512-bit ephemeral key.
    HCRYPTPROV          hMasterProv;

    // Master secret, from which all session keys are derived.
    HCRYPTKEY           hMasterKey;

    ALG_ID              aiCipher;
    DWORD               dwStrength;
    ALG_ID              aiHash;
    DWORD               dwCipherSuiteIndex;     // used for managing reconnects

    ExchSpec            SessExchSpec;
    DWORD               dwExchStrength;

    PCERT_CONTEXT       pRemoteCert;
    PUBLICKEY *         pRemotePublic;

    struct _SessCacheItem *pClonedItem;


    // Server Side Client Auth related items
    /* HLOCATOR */ 
    HLOCATOR            hLocator;
    SECURITY_STATUS     LocatorStatus;

    // Local credentials.
    PSPCredentialGroup  pServerCred; 
    PSPCredential       pActiveServerCred;
    CRED_THUMBPRINT     CredThumbprint;         // credential group
    CRED_THUMBPRINT     CertThumbprint;         // local certificate

    // Cipher level (domestic, export, sgc, etc);
    DWORD               dwCF;

    // Server certificate (pct only)
    DWORD               cbServerCertificate;
    PBYTE               pbServerCertificate;

    // cache ID (usually machine name or ip address)
    LPWSTR              szCacheID;
    LUID                LogonId; 

    // Session ID for this session
    DWORD               cbSessionID;    
    UCHAR               SessionID[SP_MAX_SESSION_ID];

    // Clear key (pct only)
    DWORD               cbClearKey;
    UCHAR               pClearKey[SP_MAX_MASTER_KEY];

    DWORD               cbKeyArgs;
    UCHAR               pKeyArgs[SP_MAX_KEY_ARGS];

    // This contains the client certificate that was sent to the server.
    PCCERT_CONTEXT      pClientCert;

    // When a client credential is created automatically, the credential
    // information is stored here.
    PSPCredential       pClientCred;

    DWORD               cbAppData;
    PBYTE               pbAppData;

} SessCacheItem, *PSessCacheItem;


typedef struct
{
    PLIST_ENTRY     SessionCache;

    DWORD           dwClientLifespan;
    DWORD           dwServerLifespan;
    DWORD           dwCleanupInterval;
    DWORD           dwCacheSize;
    DWORD           dwMaximumEntries;
    DWORD           dwUsedEntries;

    LIST_ENTRY      EntryList;
    RTL_RESOURCE    Lock;
    BOOL            LockInitialized;

} SCHANNEL_CACHE;

extern SCHANNEL_CACHE SchannelCache;

#define SP_CACHE_CLIENT_LIFESPAN    (10 * 3600 * 1000)  // 10 hours
#define SP_CACHE_SERVER_LIFESPAN    (10 * 3600 * 1000)  // 10 hours
#define SP_CACHE_CLEANUP_INTERVAL   (5 * 60 * 1000)     // 5 minutes
#define SP_MAXIMUM_CACHE_ELEMENTS   10000
#define SP_MASTER_KEY_CS_COUNT      50

extern BOOL g_fMultipleProcessClientCache;
extern BOOL g_fCacheInitialized;

// Perf counter values.
extern LONG g_cClientHandshakes;
extern LONG g_cServerHandshakes;
extern LONG g_cClientReconnects;
extern LONG g_cServerReconnects;


#define HasTimeElapsed(StartTime, CurrentTime, Interval)                \
            (((CurrentTime) > (StartTime) &&                            \
              (CurrentTime) - (StartTime) > (Interval)) ||              \
             ((CurrentTime) < (StartTime) &&                            \
              (CurrentTime) + (MAXULONG - (StartTime)) >= (Interval)))


/* SPInitSessionCache() */
/*  inits the internal cache to CacheSize items */
SP_STATUS SPInitSessionCache(VOID);

SP_STATUS
SPShutdownSessionCache(VOID);

// Reference and dereference cache items
LONG SPCacheReference(PSessCacheItem pItem);

LONG SPCacheDereference(PSessCacheItem pItem);

void
SPCachePurgeCredential(
    PSPCredentialGroup pCred);

void 
SPCachePurgeProcessId(
    ULONG ProcessId);

NTSTATUS
SPCachePurgeEntries(
    LUID *LoginId,
    ULONG ProcessID,
    LPWSTR pwszTargetName,
    DWORD Flags);

NTSTATUS
SPCacheGetInfo(
    LUID *  LogonId,
    LPWSTR  pszTargetName,
    DWORD   dwFlags,
    PSSL_SESSION_CACHE_INFO_RESPONSE pCacheInfo);

NTSTATUS
SPCacheGetPerfmonInfo(
    DWORD   dwFlags,
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo);

/* Retrieve item from cache by SessionID.  
 * Auto-Reference the item if successful */
BOOL SPCacheRetrieveBySession(
    struct _SPContext * pContext, 
    PBYTE pbSessionID, 
    DWORD cbSessionID, 
    PSessCacheItem *ppRetItem);

/* Retrieve item from cache by ID.  
 * Auto-Reference the item if successful */
BOOL 
SPCacheRetrieveByName(
    LPWSTR pwszName,
    PSPCredentialGroup pCredGroup,
    PSessCacheItem *ppRetItem);

/* find an empty cache item for use by a context */
BOOL
SPCacheRetrieveNew(
    BOOL                fServer,
    LPWSTR              pszTargetName,
    PSessCacheItem *   ppRetItem);

/* Locks a recently retrieved item into the cache */
BOOL 
SPCacheAdd(
    struct _SPContext * pContext);

void
SPCacheAssignNewServerCredential(
    PSessCacheItem pItem,
    PSPCredentialGroup pCred);

/* Helper for REDO sessions */
BOOL
SPCacheClone(PSessCacheItem *ppRetItem);

NTSTATUS
SetCacheAppData(
    PSessCacheItem pItem,
    PBYTE pbAppData,
    DWORD cbAppData);

NTSTATUS
GetCacheAppData(
    PSessCacheItem pItem,
    PBYTE *ppbAppData,
    DWORD *pcbAppData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\cert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cert.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//              01-05-98   jbanes   Use WinVerifyTrust to validate certs.
//
//----------------------------------------------------------------------------

#define SERIALNUMBER_LENGTH 16


DWORD 
MapOidToKeyExch(LPSTR szOid);

DWORD 
MapOidToCertType(LPSTR szOid);


SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    DWORD      dwCertEncodingType,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PCCERT_CONTEXT *ppCertContext);

SECURITY_STATUS
MapWinTrustError(
    SECURITY_STATUS Status, 
    SECURITY_STATUS DefaultError, 
    DWORD dwIgnoreErrors);

NTSTATUS
VerifyClientCertificate(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwCertFlags,
    DWORD           dwIgnoreErrors,
    LPCSTR          pszPolicyOID,
    PCCERT_CHAIN_CONTEXT *ppChainContext);   // optional

NTSTATUS
AutoVerifyServerCertificate(
    PSPContext      pContext);

NTSTATUS
VerifyServerCertificate(
    PSPContext  pContext,
    DWORD       dwCertFlags,
    DWORD       dwIgnoreErrors);

SECURITY_STATUS
SPCheckKeyUsage(
    PCCERT_CONTEXT  pCertContext, 
    PSTR            pszUsage,
    BOOL            fOnCertOnly,
    PBOOL           pfIsAllowed);

SP_STATUS  
SPPublicKeyFromCert(
    PCCERT_CONTEXT  pCert, 
    PUBLICKEY **    ppKey,
    ExchSpec *      pdwExchSpec);

SP_STATUS
RsaPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob);

SP_STATUS
DssPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob);

SP_STATUS
SPSerializeCertificate(
    DWORD           dwProtocol,         // in
    BOOL            fBuildChain,        // in
    PBYTE *         ppCertChain,        // out
    DWORD *         pcbCertChain,       // out
    PCCERT_CONTEXT  pCertContext,       // in
    DWORD           dwChainingFlags);   // in

SP_STATUS 
ExtractIssuerNamesFromStore(
    HCERTSTORE  hStore,
    PBYTE       pbIssuers,
    DWORD       *pcbIssuers);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#include <sha.h>
#include <md5.h>
#include <ssl3.h>

#define SP_CONTEXT_MAGIC   *(DWORD *)"!Tcp"

typedef struct _SPContext 
{
    DWORD               Magic;          /* tags structure */

    DWORD               State;          /* the current state the connection is in */

    DWORD               Flags;

    /* data for the context that can be used
     * to start a new session */
    PSessCacheItem      RipeZombie;   /* cacheable context that is being used  */
    PSPCredentialGroup  pCredGroup;
    PSPCredential       pActiveClientCred;
    LPWSTR              pszTarget;
    LPWSTR              pszCredentialName;

    DWORD               dwProtocol;
    DWORD               dwClientEnabledProtocols;

    CRED_THUMBPRINT     ContextThumbprint;

    //  Pointers to cipher info used
    // during transmission of bulk data.

    PCipherInfo         pCipherInfo;
    PCipherInfo         pReadCipherInfo;
    PCipherInfo         pWriteCipherInfo;
    PHashInfo           pHashInfo;
    PHashInfo           pReadHashInfo;
    PHashInfo           pWriteHashInfo;
    PKeyExchangeInfo    pKeyExchInfo;
 
    /* functions pointing to the various handlers for this protocol */
    SPDecryptMessageFn  Decrypt;
    SPEncryptMessageFn  Encrypt;
    SPProtocolHandlerFn ProtocolHandler;
    SPDecryptHandlerFn  DecryptHandler;
    SPInitiateHelloFn   InitiateHello;
    SPGetHeaderSizeFn   GetHeaderSize;

    /* session crypto state */

    // encryption key size.
    DWORD               KeySize;

    // Encryption states
    HCRYPTPROV          hReadProv;
    HCRYPTPROV          hWriteProv;
    HCRYPTKEY           hReadKey;
    HCRYPTKEY           hWriteKey;
    HCRYPTKEY           hPendingReadKey;
    HCRYPTKEY           hPendingWriteKey;

    HCRYPTKEY           hReadMAC;
    HCRYPTKEY           hWriteMAC;
    HCRYPTKEY           hPendingReadMAC;
    HCRYPTKEY           hPendingWriteMAC;

    // Packet Sequence counters.
    DWORD               ReadCounter;
    DWORD               WriteCounter;


    DWORD               cbConnectionID;
    UCHAR               pConnectionID[SP_MAX_CONNECTION_ID]; 
    
    DWORD               cbChallenge;
    UCHAR               pChallenge[SP_MAX_CHALLENGE];


    // Save copy of client hello to hash for verification.
    DWORD               cbClientHello;
    PUCHAR              pClientHello;
    DWORD               dwClientHelloProtocol;


    // Pending cipher info, used to generate keys
    PCipherInfo         pPendingCipherInfo;
    PHashInfo           pPendingHashInfo;
        

    // SSL3 specific items.
    
    UCHAR               bAlertLevel;        // Used for SSL3 & TLS1 alert messages
    UCHAR               bAlertNumber;

    BOOL                fExchKey; // Did we sent a Exchnage key message
    BOOL                fCertReq; //Did we request a certificatefor server and Should I need to send a cert for client
    BOOL                fInsufficientCred; //This will be TRUE when the pCred inside
                                            //pContext doesn't match the CR list. from the server.

    HCRYPTHASH          hMd5Handshake;
    HCRYPTHASH          hShaHandshake;

    PUCHAR              pbIssuerList;
    DWORD               cbIssuerList;


    PUCHAR              pbEncryptedKey;
    DWORD               cbEncryptedKey;

    PUCHAR              pbServerKeyExchange;        
    DWORD               cbServerKeyExchange;
    
    WORD                wS3CipherSuiteClient;
    WORD                wS3CipherSuiteServer;
    DWORD               dwPendingCipherSuiteIndex;

    UCHAR               rgbS3CRandom[CB_SSL3_RANDOM];
    UCHAR               rgbS3SRandom[CB_SSL3_RANDOM];

    DWORD               cSsl3ClientCertTypes;
    DWORD               Ssl3ClientCertTypes[SSL3_MAX_CLIENT_CERTS];

    // Server Gated Crypto
    DWORD               dwRequestedCF;

    // Allow cert chains for PCT1
    BOOL                fCertChainsAllowed; 

} SPContext, * PSPContext;


typedef struct _SPPackedContext 
{
    DWORD               Magic;
    DWORD               State;
    DWORD               Flags;
    DWORD               dwProtocol;

    CRED_THUMBPRINT     ContextThumbprint;

    DWORD               dwCipherInfo;
    DWORD               dwHashInfo;
    DWORD               dwKeyExchInfo;

    DWORD               dwExchStrength;

    DWORD               ReadCounter;
    DWORD               WriteCounter;

    ULARGE_INTEGER      hMasterProv;
    ULARGE_INTEGER      hReadKey;
    ULARGE_INTEGER      hWriteKey;
    ULARGE_INTEGER      hReadMAC;
    ULARGE_INTEGER      hWriteMAC;

    ULARGE_INTEGER      hLocator;
    DWORD               LocatorStatus;

    DWORD               cbSessionID;    
    UCHAR               SessionID[SP_MAX_SESSION_ID];

} SPPackedContext, *PSPPackedContext;


/* Flags */
#define CONTEXT_FLAG_CLIENT                 0x00000001
#define CONTEXT_FLAG_USE_SUPPLIED_CREDS     0x00000080  // Don't search for default credential.
#define CONTEXT_FLAG_MUTUAL_AUTH            0x00000100
#define CONTEXT_FLAG_EXT_ERR                0x00000200  /* Generate error message on error */
#define CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG 0x00000400  /* don't generate an INCOMPLETE CREDS message */
#define CONTEXT_FLAG_CONNECTION_MODE        0x00001000  /* as opposed to stream mode */
#define CONTEXT_FLAG_NOCACHE                0x00002000  /* do not look things up in the cache */
#define CONTEXT_FLAG_MANUAL_CRED_VALIDATION 0x00004000  // Don't validate server cert.
#define CONTEXT_FLAG_FULL_HANDSHAKE         0x00008000
#define CONTEXT_FLAG_NO_CERT_MAPPING        0x00010000
#define CONTEXT_FLAG_MAPPED                 0x40000000
#define CONTEXT_FLAG_SERIALIZED             0x80000000


#ifdef DBG
PSTR DbgGetNameOfCrypto(DWORD x);
#endif

PSPContext SPContextCreate(LPWSTR pszTarget);

BOOL
SPContextClean(PSPContext pContext);

BOOL SPContextDelete(PSPContext pContext);

SP_STATUS 
SPContextSetCredentials(
    PSPContext          pContext, 
    PSPCredentialGroup  pCred);

SP_STATUS
ContextInitCiphersFromCache(
    SPContext *pContext);

SP_STATUS
ContextInitCiphers(
    SPContext *pContext,
    BOOL fRead,
    BOOL fWrite);

SP_STATUS 
SPContextDoMapping(
    PSPContext pContext);

SP_STATUS
RemoveDuplicateIssuers(
    PBYTE  pbIssuers,
    PDWORD pcbIssuers);

SP_STATUS
SPContextGetIssuers(
    PSPCredentialGroup pCredGroup);

SP_STATUS
SPPickClientCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec);

SP_STATUS
SPPickServerCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec);

SP_STATUS DetermineClientCSP(PSPContext pContext);

typedef BOOL
(WINAPI * SERIALIZE_LOCATOR_FN)(
    HLOCATOR    Locator,
    HLOCATOR *  NewLocator);

SP_STATUS
SPContextSerialize(
    PSPContext  pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE *     ppBuffer,
    PDWORD      pcbBuffer,
    BOOL        fDestroyKeys);

SP_STATUS
SPContextDeserialize(
    PBYTE pbBuffer,
    PSPContext *ppContext);

BOOL
LsaContextDelete(PSPContext pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\debug.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __DEBUG_H__
#define __DEBUG_H__

extern DWORD   g_dwEventLogging;

#if DBG

extern DWORD   PctInfoLevel;
extern DWORD   PctTraceIndent;

extern DWORD   g_dwInfoLevel;
extern DWORD   g_dwDebugBreak;
extern HANDLE  g_hfLogFile;

#define DEB_ERROR           SP_LOG_ERROR
#define DEB_WARN            SP_LOG_WARNING
#define DEB_TRACE           SP_LOG_TRACE
#define DEB_BUFFERS         SP_LOG_BUFFERS

#define DebugLog(x) SPDebugLog x
#define SP_BEGIN(x) SPDebugLog(DEB_TRACE,"BEGIN:" x "\n"); PctTraceIndent++;
#define SP_RETURN(x) { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END  Line %d\n", __LINE__); return (x); }
#define SP_LOG_RESULT(x) SPLogErrorCode((x), __FILE__, __LINE__)
#define SP_END()    { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END:Line %d\n",  __LINE__); }
#define SP_BREAK()  { SPDebugLog(DEB_TRACE, "BREAK  Line %d\n",  __LINE__); }
#define LogDistinguishedName(a,b,c,d) SPLogDistinguishedName(a,b,c,d)

long    SPLogErrorCode(long, const char *, long);
void    SPDebugLog(long, const char *, ...);

void
InitDebugSupport(
    HKEY hGlobalKey);


void    DbgDumpHexString(const unsigned char*, DWORD);

#define DBG_HEX_STRING(l,p,c) if(g_dwInfoLevel & (l)) DbgDumpHexString((p), (c))

#define LOG_RESULT(x) SPLogErrorCode((x), __FILE__, __LINE__)

void
SPLogDistinguishedName(
    DWORD LogLevel,
    LPSTR pszLabel,
    PBYTE pbName,
    DWORD cbName);

#else

#define DebugLog(x)
#define SP_BEGIN(x) 
#define SP_RETURN(x) return (x)
#define SP_LOG_RESULT(x) x
#define SP_END()
#define SP_BREAK()
#define LOG_RESULT(x)
#define LogDistinguishedName(a,b,c,d) 

#endif



#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\cert509.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 



#define SERIALNUMBER_LENGTH 16

#define CF_VERIFY_SIG           1
#define CF_CERT_FROM_FILE       2

#define CERT_HEADER_LEN         17


BOOL
CrackCertificate(
    PBYTE               pbCertificate,
    DWORD               cbCertificate,
    PX509Certificate *  ppCertificate);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\cred.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cred.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#ifndef __CRED_H__
#define __CRED_H__

#define PCT_CRED_MAGIC  *(DWORD *)"CtcP"

typedef struct _CRED_THUMBPRINT
{
    DWORD LowPart;
    DWORD HighPart;
} CRED_THUMBPRINT, *PCRED_THUMBPRINT;

typedef struct _SPCredential
{
    PCCERT_CONTEXT      pCert;
    CRED_THUMBPRINT     CertThumbprint;

    HCRYPTPROV          hProv;
    HCRYPTPROV          hEphem512Prov;
    HCRYPTPROV          hEphem1024Prov;
    HCRYPTPROV          hRemoteProv;

    PROV_ENUMALGS_EX *  pCapiAlgs;      // Algs supported by hProv (server only)
    DWORD               cCapiAlgs;
    DWORD               fAppRemoteProv; // Does application own hRemoteProv?

    DWORD               dwCertFlags;    // Is this a server SGC cert?

    DWORD               dwKeySpec;
    ExchSpec            dwExchSpec;

    PPUBLICKEY          pPublicKey;

    PBYTE               pbSsl3SerializedChain;
    DWORD               cbSsl3SerializedChain;

    HCRYPTKEY           hTek;               // Ephemeral DH

    LIST_ENTRY          ListEntry;
} SPCredential, *PSPCredential;
          

typedef struct _SPCredentialGroup {
    DWORD               Magic;
    DWORD               grbitProtocol;
    DWORD               grbitEnabledProtocols;
    DWORD               dwFlags;
    DWORD               dwMinStrength;
    DWORD               dwMaxStrength;
    DWORD               cSupportedAlgs;
    ALG_ID *            palgSupportedAlgs;
    DWORD               dwSessionLifespan;
    ULONG               ProcessId; 

    // server-side only
    LONG                cMappers;
    HMAPPER **          pahMappers;
    HCERTSTORE          hApplicationRoots;  // Specified by application.
    HCERTSTORE          hUserRoots;         // Current user ROOT - monitored for changes
    PBYTE               pbTrustedIssuers;
    DWORD               cbTrustedIssuers;

    CRED_THUMBPRINT     CredThumbprint;     // Used when purging server cache entries.
    LONG                RefCount;

    DWORD               CredCount;
    LIST_ENTRY          CredList;
    RTL_RESOURCE        csCredListLock;

    LIST_ENTRY          GlobalCredList;
} SPCredentialGroup, * PSPCredentialGroup;


typedef struct _LSA_SCHANNEL_SUB_CRED
{
    PCCERT_CONTEXT      pCert;
    LPWSTR              pszPin;
    HCRYPTPROV          hRemoteProv;
    PVOID               pPrivateKey;
    DWORD               cbPrivateKey;
    LPSTR               pszPassword;
} LSA_SCHANNEL_SUB_CRED, *PLSA_SCHANNEL_SUB_CRED;

typedef struct _LSA_SCHANNEL_CRED
{
    DWORD           dwVersion;
    DWORD           cSubCreds;
    PLSA_SCHANNEL_SUB_CRED paSubCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           reserved;
} LSA_SCHANNEL_CRED, *PLSA_SCHANNEL_CRED;


#define LockCredentialExclusive(p)  RtlAcquireResourceExclusive(&(p)->csCredListLock, TRUE)
#define LockCredentialShared(p)     RtlAcquireResourceShared(&(p)->csCredListLock, TRUE)
#define UnlockCredential(p)         RtlReleaseResource(&(p)->csCredListLock)

BOOL
SslInitCredentialManager(VOID);

BOOL
SslFreeCredentialManager(VOID);

BOOL
SslCheckForGPEvent(void);

BOOL
IsValidThumbprint(
    PCRED_THUMBPRINT Thumbprint);

BOOL
IsSameThumbprint(
    PCRED_THUMBPRINT Thumbprint1,
    PCRED_THUMBPRINT Thumbprint2);

void
GenerateCertThumbprint(
    PCCERT_CONTEXT pCertContext,
    PCRED_THUMBPRINT Thumbprint);

NTSTATUS
GenerateRandomThumbprint(
    PCRED_THUMBPRINT Thumbprint);

BOOL
DoesCredThumbprintMatch(
    PSPCredentialGroup pCredGroup,
    PCRED_THUMBPRINT pThumbprint);

void
ComputeCredExpiry(
    PSPCredentialGroup pCredGroup,
    PTimeStamp ptsExpiry);

SP_STATUS
SPCreateCred(
    DWORD           dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred,
    PSPCredential   pCurrentCred,
    BOOL *          pfEventLogged);

SP_STATUS
SPCreateCredential(
   PSPCredentialGroup *ppCred,
   DWORD grbitProtocol,
   PLSA_SCHANNEL_CRED pSchannelCred);

SP_STATUS
AddCredentialToGroup(
    PSPCredentialGroup  pCredGroup, 
    PSPCredential       pCred);

SP_STATUS
IsCredentialInGroup(
    PSPCredentialGroup  pCredGroup, 
    PCCERT_CONTEXT      pCertContext,
    PBOOL               pfInGroup);

SECURITY_STATUS
UpdateCredentialFormat(
    PSCH_CRED pSchCred,         // in
    PLSA_SCHANNEL_CRED pCred);  // out

void
GlobalCheckForCertificateRenewal(void);

void
CheckForCredentialRenewal(
    PSPCredentialGroup pCredGroup);

BOOL
CheckForCertificateRenewal(
    DWORD dwProtocol,
    PCCERT_CONTEXT pCertContext,
    PCCERT_CONTEXT *ppNewCertificate);

NTSTATUS
FindDefaultMachineCred(
    PSPCredentialGroup *ppCred,
    DWORD dwProtocol);

BOOL
SPReferenceCredential(
    PSPCredentialGroup  pCred);

BOOL
SPDereferenceCredential(
    PSPCredentialGroup  pCred,
    BOOL fFreeRemoteHandle);

void
SPDeleteCred(
    PSPCredential pCred,
    BOOL fFreeRemoteHandle);

BOOL 
SPDeleteCredential(
    PSPCredentialGroup pCred,
    BOOL fFreeRemoteHandle);

// flag bit definitions
#define CRED_FLAG_NO_SYSTEM_MAPPER              0x00000004  // client cert mapping
#define CRED_FLAG_NO_SERVERNAME_CHECK           0x00000008  // server cert validation
#define CRED_FLAG_MANUAL_CRED_VALIDATION        0x00000010  // server cert validation
#define CRED_FLAG_NO_DEFAULT_CREDS              0x00000020  // client certificate selection
#define CRED_FLAG_UPDATE_ISSUER_LIST            0x00000040  // new settings have been downloaded from GPO
#define CRED_FLAG_DELETED                       0x00000080  // credential has been deleted by application.

#define CRED_FLAG_REVCHECK_END_CERT             0x00000100 
#define CRED_FLAG_REVCHECK_CHAIN                0x00000200 
#define CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT   0x00000400 
#define CRED_FLAG_IGNORE_NO_REVOCATION_CHECK    0x00000800
#define CRED_FLAG_IGNORE_REVOCATION_OFFLINE     0x00001000

#define CRED_FLAG_CHECK_FOR_RENEWAL             0x00002000
#define CRED_FLAG_DISABLE_RECONNECTS            0x00004000  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and Asn1 Module
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\encode.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       encode.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   Removed obsolete declarations.
//
//----------------------------------------------------------------------------

#ifndef _ENCODE_H_
#define _ENCODE_H_

/* tag definitions for ASN.1 encoding decoding */
#define INTEGER_TAG             0x02
#define CHAR_STRING_TAG         0x16
#define OCTET_STRING_TAG        0x04
#define BIT_STRING_TAG          0x03
#define UTCTIME_TAG             0x17
#define SEQUENCE_TAG            0x30
#define SET_OF_TAG              0x11
#define OBJECT_ID_TAG           0x06
#define NULL_TAG                0x05
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14
#define ATTRIBUTE_TAG           0xa0

/* definitions of maximum lengths needed for the ASN.1 encoded
   form of some of the common fields in a certificate */
#define MAXVALIDITYLEN          0x24
#define MAXKEYINFOLEN           0x50
#define MAXALGIDLEN             0x0A
#define MAXOBJIDLEN             0x0A
#define MAXNAMEVALUELEN         0x40
#define UTCTIMELEN              0x0F
#define MAXPUBKEYDATALEN        0x30
#define VERSIONLEN              0x03
#define MAXENCODEDSIGLEN        0x30
#define MAXHEADERLEN            0x08
#define MINHEADERLEN            0x03
#define MAXTIMELEN              0x20
#define MAXNAMELEN              0x60

/* definitions for scrubbing memory */
#define ALLBITSOFF              0x00
#define ALLBITSON               0xFF

/* prototypes for the functions in encode.c */
long EncodeLength(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAlgid(BYTE *pbEncoded, DWORD Algid, BOOL Writeflag);
long EncodeInteger(BYTE *pbEncoded, BYTE *pbInt, DWORD dwLen, BOOL Writeflag);
long EncodeString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeOctetString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeBitString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
//long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
long EncodeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeSetOfHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAttributeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeName(BYTE *pbEncoded, BYTE *pbName, DWORD dwLen, BOOL Writeflag);


long DecodeLength(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeAlgid(DWORD *pAlgid, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeSetOfHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeInteger(BYTE *pbInt, DWORD cbBuff, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded,BOOL Writeflag);
long DecodeOctetString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeBitString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeName(BYTE *pbName, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

long
EncodeAlgorithm(
    BYTE *  pbEncoded,
    DWORD   AlgId,
    BOOL    WriteFlag);

#define ALGTYPE_SIG_RSA_MD5      0x01
#define ALGTYPE_KEYEXCH_RSA_MD5  0x02
#define ALGTYPE_CIPHER_RC4_MD5   0x03
#define ALGTYPE_KEYEXCH_DH       0x04


long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag);


#ifndef SECURITY_LINUX
long
EncodeFileTime(
    BYTE *      pbEncoded,
    FILETIME    Time,
    BOOL        UTC,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
#endif /* SECURITY_LINUX */

#ifndef SECURITY_LINUX
long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long DecodeUTCTime(time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

#define DecodeFileTime DecodeUTCTime
#endif /* SECURITY_LINUX */

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded);

long
DecodeDN(
    PSTR    pName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag);

long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);


#endif  /* _ENCODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\defcreds.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       defcreds.h
//
//  Contents:   Declarations for schannel default credentials routines.
//
//  Classes:
//
//  Functions:
//
//  History:    12-06-97   jbanes   Created.
//
//----------------------------------------------------------------------------

NTSTATUS
AcquireDefaultClientCredential(
    PSPContext  pContext,
    BOOL        fCredManagerOnly);


NTSTATUS
QueryCredentialManagerForCert(
    PSPContext          pContext,
    LPWSTR              pszTarget);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\events.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        events.h
//
// Contents:    Schannel event log function declarations.
//
// History:     03-05-99   jbanes    Created
//
//------------------------------------------------------------------------

BOOL
SchInitializeEvents(void);

void
SchShutdownEvents(void);


void
LogSchannelStartedEvent(void);

void
LogGlobalAcquireContextFailedEvent(
    LPWSTR pwszName,
    DWORD Status);

void
LogCreateCredEvent(
    DWORD dwProtocol, 
    PLSA_SCHANNEL_CRED pSchannelCred);

void
LogCredPropertiesEvent(
    DWORD dwProtocol,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    PCCERT_CONTEXT pCertContext);

void
LogNoPrivateKeyEvent(
    DWORD dwProtocol);

void
LogCredAcquireContextFailedEvent(
    DWORD dwProtocol, 
    DWORD Status);

void
LogCreateCredFailedEvent(
    DWORD dwProtocol);

void
LogNoDefaultServerCredEvent(void);

void
LogNoCiphersSupportedEvent(void);

void
LogCipherMismatchEvent(void);

void
LogNoClientCertFoundEvent(void);

void
LogBogusServerCertEvent(
    PCCERT_CONTEXT pCertContext,
    LPWSTR pszServername,
    DWORD Status);

void
LogBogusClientCertEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status);

void
LogFastMappingFailureEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status);

void
LogCertMappingFailureEvent(
    DWORD Status);

void
LogHandshakeInfoEvent(
    DWORD dwProtocol,
    PCipherInfo pCipherInfo,
    PHashInfo pHashInfo,
    PKeyExchangeInfo pExchangeInfo,
    DWORD dwExchangeStrength);

void
LogIssuerOverflowEvent(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\oidenc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#ifndef __OIDENC_H__
#define __OIDENC_H__

#define szPublicTag   ".public"
#define szParamTag    ".params"
#define szPrivateTag  ".private"

#define MAX_OID_SIZE  64


#define szOID_RSA_RSA_Public szOID_RSA_RSA szPublicTag

#define szOID_INFOSEC_mosaicUpdatedSig_Public  szOID_INFOSEC_mosaicUpdatedSig  szPublicTag
#define szOID_INFOSEC_mosaicUpdatedSig_Params  szOID_INFOSEC_mosaicUpdatedSig  szParamTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Public szOID_INFOSEC_mosaicKMandUpdSig szPublicTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Params szOID_INFOSEC_mosaicKMandUpdSig szParamTag

#define szOID_DSA_Public      szOID_OIWSEC_dsa szPublicTag
#define szOID_DSA_Params      szOID_OIWSEC_dsa szParamTag
#define szOID_X957_DSA_Public szOID_X957_DSA   szPublicTag
#define szOID_X957_DSA_Params szOID_X957_DSA   szParamTag


#define szOID_RSA_ENCRYPT_RC4_MD5  szOID_RSA_ENCRYPT ".4"

#define szPrivateKeyFileEncode "PrivateKeyFileEncode"
#define szPrivateKeyInfoEncode "PrivateKeyInfoEncode"

#ifndef X509_ENHANCED_KEY_USAGE
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)

typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
  CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


#endif

#ifndef szOID_ENHANCED_KEY_USAGE
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#define szOID_NETSCAPE_SGC              "2.16.840.1.113730.4.1"


BOOL
WINAPI
InitSchannelAsn1(
        HMODULE hModule);
BOOL
WINAPI
ShutdownSchannelAsn1();

typedef struct _PRIVATE_KEY_FILE_ENCODE
{
    CRYPT_BIT_BLOB              EncryptedBlob;
    CRYPT_ALGORITHM_IDENTIFIER  Alg; 
} PRIVATE_KEY_FILE_ENCODE, *PPRIVATE_KEY_FILE_ENCODE;


#endif // __OIDENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\mapper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapper.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-15-96   RichardW     Created
//              12-23-97   jbanes       Added support for application mappers
//
//----------------------------------------------------------------------------

#ifndef __MAPPER_H__
#define __MAPPER_H__


HMAPPER *
SslGetMapper(
    BOOL    fDC);


DWORD
WINAPI
SslReferenceMapper(
    HMAPPER *   phMapper);          // in

DWORD
WINAPI
SslDereferenceMapper(
    HMAPPER *   phMapper);          // in

SECURITY_STATUS
WINAPI
SslGetMapperIssuerList(
    HMAPPER *   phMapper,           // in
    BYTE **     ppIssuerList,       // out
    DWORD *     pcbIssuerList);     // out

SECURITY_STATUS 
WINAPI
SslGetMapperChallenge(
    HMAPPER *   phMapper,           // in
    BYTE *      pAuthenticatorId,   // in
    DWORD       cbAuthenticatorId,  // in
    BYTE *      pChallenge,         // out
    DWORD *     pcbChallenge);      // out

SECURITY_STATUS 
WINAPI 
SslMapCredential(
    HMAPPER *   phMapper,           // in
    DWORD       dwCredentialType,   // in
    PCCERT_CONTEXT pCredential,     // in
    PCCERT_CONTEXT pAuthority,      // in
    HLOCATOR *  phLocator);         // out

SECURITY_STATUS 
WINAPI 
SslGetAccessToken(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator,           // in
    HANDLE *    phToken);           // out

SECURITY_STATUS 
WINAPI 
SslCloseLocator(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator);          // in


//
// Issuer cache used for many-to-one mapping.
//

#define ISSUER_CACHE_LIFESPAN   (10 * 60 * 1000)    // 10 minutes
#define ISSUER_CACHE_SIZE       100


typedef struct
{
    PLIST_ENTRY     Cache;

    DWORD           dwLifespan;
    DWORD           dwCacheSize;
    DWORD           dwMaximumEntries;
    DWORD           dwUsedEntries;

    LIST_ENTRY      EntryList;
    RTL_RESOURCE    Lock;
    BOOL            LockInitialized;

} ISSUER_CACHE;

extern ISSUER_CACHE IssuerCache;


typedef struct
{
    DWORD           CreationTime;

    PBYTE           pbIssuer;
    DWORD           cbIssuer;

    // List of cache entries assigned to a particular cache index.
    LIST_ENTRY      IndexEntryList;

    // Global list of cache entries sorted by creation time.
    LIST_ENTRY      EntryList;

} ISSUER_CACHE_ENTRY;


SP_STATUS
SPInitIssuerCache(void);

void
SPShutdownIssuerCache(void);

void
SPPurgeIssuerCache(void);

void
SPDeleteIssuerEntry(
    ISSUER_CACHE_ENTRY *pItem);

BOOL
SPFindIssuerInCache(
    PBYTE pbIssuer,
    DWORD cbIssuer);

void
SPExpireIssuerCacheElements(void);

void
SPAddIssuerToCache(
    PBYTE pbIssuer,
    DWORD cbIssuer);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\pct1msg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#ifndef __PCT1MSG_H__
#define __PCT1MSG_H__

#define PCT_CH_OFFSET_V1		(WORD)10
#define PCT_VERSION_1			(WORD)0x8001

/* message type codes */
#define PCT1_MSG_NOMSG               0x00
#define PCT1_MSG_CLIENT_HELLO		0x01
#define PCT1_MSG_SERVER_HELLO		0x02
#define PCT1_MSG_CLIENT_MASTER_KEY	0x03
#define PCT1_MSG_SERVER_VERIFY		0x04
#define PCT1_MSG_ERROR				0x05

#define PCT1_ET_OOB_DATA             0x01
#define PCT1_ET_REDO_CONN            0x02



#define PCT1_SESSION_ID_SIZE         32
#define PCT1_CHALLENGE_SIZE          32
#define PCT1_MASTER_KEY_SIZE         16
#define PCT1_RESPONSE_SIZE           32
#define PCT1_MAX_MESSAGE_LENGTH      0x3f00
#define PCT1_MAX_CLIENT_HELLO        256


#define PCT1_CERT_TYPE_FROM_CAPI2(s) X509_ASN_ENCODING
/*
 *
 * Useful Macros
 *
 */

#define LSBOF(x)    ((UCHAR) ((x) & 0xFF))
#define MSBOF(x)    ((UCHAR) (((x) >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/* external representations of algorithm specs */

typedef DWORD   ExtCipherSpec, *PExtCipherSpec;
typedef WORD    ExtHashSpec,   *PExtHashSpec;
typedef WORD    ExtCertSpec,   *PExtCertSpec;
typedef WORD    ExtExchSpec,   *PExtExchSpec;
typedef WORD    ExtSigSpec,    *PExtSigSpec;

typedef struct _Pct1CipherMap
{
    ALG_ID      aiCipher;
    DWORD       dwStrength;
    CipherSpec  Spec;
} Pct1CipherMap, *PPct1CipherMap;

typedef struct _Pct1HashMap
{
    ALG_ID      aiHash;
    CipherSpec  Spec;
} Pct1HashMap, *PPct1HashMap;

extern Pct1CipherMap Pct1CipherRank[];
extern DWORD Pct1NumCipher;

/* available hashes, in order of preference */
extern Pct1HashMap Pct1HashRank[];
extern DWORD Pct1NumHash;

extern CertTypeMap aPct1CertEncodingPref[];
extern DWORD cPct1CertEncodingPref;

extern KeyTypeMap aPct1LocalExchKeyPref[];

extern DWORD cPct1LocalExchKeyPref;

extern KeyTypeMap aPct1LocalSigKeyPref[];
extern DWORD cPct1LocalSigKeyPref;



typedef struct _PCT1_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} PCT1_MESSAGE_HEADER, * PPCT1_MESSAGE_HEADER;

typedef struct _PCT1_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} PCT1_MESSAGE_HEADER_EX, * PPCT1_MESSAGE_HEADER_EX;


typedef struct _PCT1_ERROR {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
    UCHAR               ErrorInfoMsb;
    UCHAR               ErrorInfoLsb;
    UCHAR               VariantData[1];
} PCT1_ERROR, * PPCT1_ERROR;


typedef struct _PCT1_CLIENT_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ChallengeData[PCT1_CHALLENGE_SIZE];
    UCHAR               OffsetMsb;
    UCHAR               OffsetLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               HashSpecsLenMsb;
    UCHAR               HashSpecsLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ExchSpecsLenMsb;
    UCHAR               ExchSpecsLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_HELLO, * PPCT1_CLIENT_HELLO;


typedef struct _PCT1_SERVER_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               RestartSessionOK;
    UCHAR               ClientAuthReq;
    ExtCipherSpec       CipherSpecData;
    ExtHashSpec         HashSpecData;
    ExtCertSpec         CertSpecData;
    ExtExchSpec         ExchSpecData;
    UCHAR               ConnectionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ClientSigSpecsLenMsb;
    UCHAR               ClientSigSpecsLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_HELLO, * PPCT1_SERVER_HELLO;

typedef struct _PCT1_CLIENT_MASTER_KEY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    ExtCertSpec         ClientCertSpecData;
    ExtSigSpec          ClientSigSpecData;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VerifyPreludeLenMsb;
    UCHAR               VerifyPreludeLenLsb;
    UCHAR               ClientCertLenMsb;
    UCHAR               ClientCertLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_MASTER_KEY, * PPCT1_CLIENT_MASTER_KEY;


typedef struct _PCT1_SERVER_VERIFY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_VERIFY, * PPCT1_SERVER_VERIFY;



/*
 *
 * Expanded Form Messages:
 *
 */

typedef struct _Pct1_Error {
	DWORD			Error;
	DWORD			ErrInfoLen;
	BYTE			*ErrInfo;
} Pct1Error, *PPct1_Error;

typedef struct _Pct1_Client_Hello {
    DWORD           cCipherSpecs;
    DWORD           cHashSpecs;
    DWORD           cCertSpecs;
    DWORD           cExchSpecs;
    DWORD           cbKeyArgSize;
	DWORD           cbSessionID;
	DWORD           cbChallenge;
    PUCHAR          pKeyArg;
    CipherSpec      * pCipherSpecs;
    HashSpec        * pHashSpecs;
    CertSpec        * pCertSpecs;
    ExchSpec        * pExchSpecs;
    UCHAR           SessionID[PCT1_SESSION_ID_SIZE];
	UCHAR           Challenge[PCT1_CHALLENGE_SIZE];
} Pct1_Client_Hello, * PPct1_Client_Hello;


typedef struct _Pct1_Server_Hello {
    DWORD           RestartOk;
    DWORD           ClientAuthReq;
    DWORD           CertificateLen;
    DWORD           ResponseLen;
    DWORD           cSigSpecs;
    DWORD           cCertSpecs;
	DWORD           cbConnectionID;
    UCHAR *         pCertificate;
    CipherSpec      SrvCipherSpec;
    HashSpec        SrvHashSpec;
    CertSpec        SrvCertSpec;
    ExchSpec        SrvExchSpec;
    SigSpec         * pClientSigSpecs;
    CertSpec        * pClientCertSpecs;
    UCHAR           ConnectionID[PCT1_SESSION_ID_SIZE];
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Hello, * PPct1_Server_Hello;

typedef struct _Pct1_Client_Master_Key {
    DWORD           ClearKeyLen;
    DWORD           EncryptedKeyLen;
    DWORD           KeyArgLen;
    DWORD           VerifyPreludeLen;
    DWORD           ClientCertLen;
    DWORD           ResponseLen;
    CertSpec        ClientCertSpec;
    SigSpec         ClientSigSpec;
    UCHAR           ClearKey[PCT1_MASTER_KEY_SIZE];
    PBYTE           pbEncryptedKey;
    UCHAR           KeyArg[PCT1_MASTER_KEY_SIZE];
    PUCHAR          pClientCert;
    PBYTE           pbResponse;
    UCHAR           VerifyPrelude[PCT1_RESPONSE_SIZE];
} Pct1_Client_Master_Key, * PPct1_Client_Master_Key;

typedef struct _Pct1_Server_Verify {
    UCHAR           SessionIdData[PCT1_SESSION_ID_SIZE];
    DWORD           ResponseLen;
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Verify, * PPct1_Server_Verify;

/*
 *
 * Pickling Prototypes
 *
 */

SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient);

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer);

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient);

SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer);

SP_STATUS
Pct1PackError(
    PPct1_Error               pCanonical,
    PSPBuffer              pCommOutput);

#endif /* __PCT1MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\pct1prot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1prot.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#ifndef _PCT1PROT_H_
#define _PCT1PROT_H_

/* keyexchange algs */
#define PCT1_EXCH_RSA_PKCS1          0x0001
#define PCT1_EXCH_RSA_PKCS1_TOKEN_DES     0x0002
#define PCT1_EXCH_RSA_PKCS1_TOKEN_DES3    0x0003
#define PCT1_EXCH_RSA_PKCS1_TOKEN_RC2     0x0004
#define PCT1_EXCH_RSA_PKCS1_TOKEN_RC4     0x0005

#define PCT1_EXCH_DH_PKCS3                0x0006
#define PCT1_EXCH_DH_PKCS3_TOKEN_DES      0x0007
#define PCT1_EXCH_DH_PKCS3_TOKEN_DES3     0x0008
#define PCT1_EXCH_FORTEZZA_TOKEN          0x0009

#define PCT1_EXCH_UNKNOWN                 0xffff


/* data encryption algs */
/* encryption alg masks */
#define PCT1_CIPHER_ALG           0xffff0000
#define PCT1_CIPHER_STRENGTH                0x0000ff00
#define PCT1_CSTR_POS                     8
#define PCT1_CIPHER_MAC           0x000000ff

/* specific algs */
#define PCT1_CIPHER_DES           0x00010000
#define PCT1_CIPHER_IDEA                    0x00020000
#define PCT1_CIPHER_RC2           0x00030000
#define PCT1_CIPHER_RC4           0x00040000
#define PCT1_CIPHER_2DES                  0x00050000
#define PCT1_CIPHER_3DES                  0x00060000
#define PCT1_CIPHER_SKIPJACK              0x01000000
#define PCT1_CIPHER_NONE                  0x00000000

#define PCT1_CIPHER_UNKNOWN               0xffffffff

/* data encryption strength specs */
#define PCT1_ENC_BITS_40                    0x00002800
#define PCT1_ENC_BITS_56                    0x00003800
#define PCT1_ENC_BITS_64                    0x00004000
#define PCT1_ENC_BITS_80                    0x00005000
#define PCT1_ENC_BITS_128                  0x00008000
#define PCT1_ENC_BITS_168                  0x0000a800
#define PCT1_ENC_BITS_192                  0x0000c000
/* mac strength specs */
#define PCT1_MAC_BITS_128                  0x00000040

/* hashing algs */
#define PCT1_HASH_MD5                     0x0001
#define PCT1_HASH_MD5_TRUNC_64          0x0002
#define PCT1_HASH_SHA                     0x0003
#define PCT1_HASH_SHA_TRUNC_80            0x0004
#define PCT1_HASH_DES_DM                  0x0005
#define PCT1_HASH_MD2                     0x0006
#define PCT1_HASH_UNKNOWN                 0xffff

/* certificate types */
#define PCT1_CERT_NONE                  0x0000
#define PCT1_CERT_X509                  0x0001
#define PCT1_CERT_PKCS7                 0x0002
#define PCT1_CERT_X509_CHAIN            0x0003

/* signature algorithms */
#define PCT1_SIG_NONE                     0x0000
#define PCT1_SIG_RSA_MD5                    0x0001
#define PCT1_SIG_RSA_SHA                  0x0002
#define PCT1_SIG_DSA_SHA                  0x0003

/* these are for internal use only */
#define PCT1_SIG_RSA_MD2                    0x0004
#define PCT1_SIG_RSA                0x0005
#define PCT1_SIG_RSA_SHAMD5               0x0006
#define PCT1_SIG_FORTEZZA_TOKEN           0x0007



/* key derivation separators */

#define PCT_CONST_CWK         "cwcwcwcwcw"
#define PCT_CONST_CWK_LEN      2

#define PCT_CONST_SWK         "svwsvwsvwsvwsvw"
#define PCT_CONST_SWK_LEN      3

#define PCT_CONST_CMK         "cmaccmaccmaccmaccmac"
#define PCT_CONST_CMK_LEN      4

#define PCT_CONST_SMK         "svmacsvmacsvmacsvmacsvmac"
#define PCT_CONST_SMK_LEN      5

#define PCT_CONST_SR            "svsvsvsvsv"
#define PCT_CONST_SR_LEN        2

#define PCT_CONST_SLK         "slslslslsl"
#define PCT_CONST_SLK_LEN      2

#define PCT_CONST_RESP      "srsrsrsrsr"
#define PCT_CONST_RESP_LEN    2

#define PCT_CONST_VP            "cvp"
#define PCT_CONST_VP_LEN        3
#define PCT_USE_CERT                    1
#define PCT_MAKE_MAC                    2

#define DERIVATION_BUFFER_SIZE      1024

/* data structs */

/* message constants and types */
#define PCT_MASTER_KEY_SIZE     16
#define PCT_SESSION_ID_SIZE     32
#define PCT_CHALLENGE_SIZE      32

#define PCT1_MAX_KEY_ARGS        8

#define RESPONSE_SIZE       32      /* allows for hash output growth */

#define PCT_MAX_SHAKE_LEN   32768    /* longest handshake message len */
/* implementation constants */

#define PCT_MAX_NUM_SEP   5
#define PCT_MAX_SEP_LEN   5

#define PCT1_MAX_CERT_SPECS     5
#define PCT1_MAX_SIG_SPECS      5
#define PCT1_MAX_EXCH_SPECS     5
#define PCT1_MAX_CIPH_SPECS     16
#define PCT1_MAX_HASH_SPECS     16

/* mismatch vector */

#define PCT_NUM_MISMATCHES    6

#define PCT_IMIS_CIPHER   1
#define PCT_IMIS_HASH         2
#define PCT_IMIS_CERT         4
#define PCT_IMIS_EXCH         8
#define PCT_IMIS_CL_CERT        16
#define PCT_IMIS_CL_SIG   32


SP_STATUS WINAPI
Pct1ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Pct1ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI 
Pct1DecryptHandler(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pAppOutput);

SP_STATUS WINAPI
Pct1GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI Pct1DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Pct1EncryptRaw(PSPContext  pContext,
                             PSPBuffer      pAppInput,
                             PSPBuffer      pCommOutput,
                             DWORD          dwFlags);

#define PCT1_ENCRYPT_ESCAPE 0x00000001


SP_STATUS WINAPI Pct1EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);



SP_STATUS Pct1SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Client_Hello pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1HandleError(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1GenerateError(PSPContext pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData);


SP_STATUS
WINAPI
GeneratePct1StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput);

SP_STATUS
Pct1CliRestart(PSPContext  pContext, 
              PPct1_Server_Hello pHello, 
              PSPBuffer pCommOutput);

SP_STATUS
Pct1SrvRestart(PSPContext           pContext, 
               PPct1_Client_Hello   pHello,
               PSPBuffer            pCommOutput);

VOID
Pct1ActivateSessionKeys(PSPContext pContext);

SP_STATUS
Pct1MakeSessionKeys(PSPContext pContext);

SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude
                               );

SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello);

SP_STATUS
Pct1ComputeResponse(
    PSPContext pContext,      
    PBYTE      pbChallenge,   
    DWORD      cbChallenge,   
    PBYTE      pbConnectionID,
    DWORD      cbConnectionID,
    PBYTE      pbSessionID,   
    DWORD      cbSessionID,   
    PBYTE      pbResponse,    
    PDWORD     pcbResponse);


#endif /* _PCT1PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\keyexch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyexch.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   CAPI integration.
//
//----------------------------------------------------------------------------

#ifndef __KEYEXCH_H__
#define __KEYEXCH_H__

typedef struct _SPContext SPContext;

typedef struct _PUBLICKEY
{
    BLOBHEADER *     pPublic;
    DWORD            cbPublic;
//    CRYPT_OBJID_BLOB Parameters;

} PUBLICKEY, *PPUBLICKEY;


SP_STATUS
MakeSessionKeys(
    SPContext * pContext,
    HCRYPTPROV  hProv, 
    HCRYPTKEY   hMasterKey);
 
VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size) ;

void ReverseInPlace(PUCHAR pByte, DWORD cbByte);


typedef 
SP_STATUS 
 (WINAPI * GenerateServerExchangeValueFn)(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out 
    DWORD *         pcbServerExchangeValue  // in/out
    );

typedef
SP_STATUS 
  (WINAPI * GenerateClientExchangeValueFn)(
    SPContext     * pContext,               // in / out
    PUCHAR          pServerExchangeValue,   // in 
    DWORD           pcbServerExchangeValue, // in
    PUCHAR          pClientClearValue,      // out 
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out 
    DWORD *         pcbClientExchangeValue  // in/out
    );

typedef
SP_STATUS
  (WINAPI * GenerateServerMasterKeyFn)(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
    );


typedef struct _KeyExchangeSystem {
    DWORD           Type;
    PSTR            pszName;
//    PrivateFromBlobFn               PrivateFromBlob;
    GenerateServerExchangeValueFn   GenerateServerExchangeValue;
    GenerateClientExchangeValueFn   GenerateClientExchangeValue;
    GenerateServerMasterKeyFn       GenerateServerMasterKey;
} KeyExchangeSystem, * PKeyExchangeSystem;


typedef struct kexchtoalg {
    ALG_ID  idAlg;
    KeyExchangeSystem *System;
} AlgToExch;

extern AlgToExch g_AlgToExchMapping[];
extern int g_iAlgToExchMappings;


#define DSA_SIGNATURE_SIZE      40
#define MAX_DSA_ENCODED_SIGNATURE_SIZE (DSA_SIGNATURE_SIZE + 100)

#define MAGIC_DSS1 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'1'<<24))
#define MAGIC_DSS2 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'2'<<24))
#define MAGIC_DSS3 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'3'<<24))
#define MAGIC_DH1  (             ((DWORD)'D'<<8) + ((DWORD)'H'<<16) + ((DWORD)'1'<<24))


/*
 * instantiations of systems
 */

extern KeyExchangeSystem keyexchPKCS;
extern KeyExchangeSystem keyexchDH;


// PROV_RSA_SCHANNEL handle used when building ClientHello messages.
extern HCRYPTPROV           g_hRsaSchannel;
extern PROV_ENUMALGS_EX *   g_pRsaSchannelAlgs;
extern DWORD                g_cRsaSchannelAlgs;

// PROV_DH_SCHANNEL handle used for client and server operations. This is 
// where the schannel ephemeral DH key lives.
extern HCRYPTPROV           g_hDhSchannelProv;
extern PROV_ENUMALGS_EX *   g_pDhSchannelAlgs;
extern DWORD                g_cDhSchannelAlgs;


#endif /* __KEYEXCH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN UINT cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\sigsys.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sigsys.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              10-21-96   jbanes   CAPI integration.
//
//----------------------------------------------------------------------------

#ifndef __SIGSYS_H__
#define __SIGSYS_H__

SP_STATUS 
SPVerifySignature(
    HCRYPTPROV  hProv,
    PPUBLICKEY  pPublic,
    ALG_ID      aiHash,
    PBYTE       pbData, 
    DWORD       cbData, 
    PBYTE       pbSig, 
    DWORD       cbSig,
    BOOL        fHashData);

SP_STATUS
SignHashUsingCred(
    PSPCredential pCred,
    ALG_ID        aiHash,
    PBYTE         pbHash,
    DWORD         cbHash,
    PBYTE         pbSignature,
    PDWORD        pcbSignature);

#endif /* __SIGSYS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\spbasei.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spbase.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <sslprgma.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <wchar.h>
#include <wincrypt.h>
#include <lmcons.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <alloca.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SECURITY_PACKAGE
#define MULTI_THREADED
#define SECURITY_WIN32
#include "schannel.h"
#include <security.h>
#include <spseal.h>
#include <sspi.h>
#include <wincred.h>
#include <secint.h>
#include <crypt.h>

/*
///////////////////////////////////////////////////////
//
// Private Headers
//
///////////////////////////////////////////////////////
*/

#include "spreg.h"
#include "debug.h"

#include "sperr.h"
#include "spdefs.h"

#include "keyexch.h"

#include <certmap.h>
#include "cred.h"
#include "sigsys.h"
#include "protocol.h"
#include "specmap.h"
#include "cache.h"
#include "context.h"
#include "cert.h"
#include "defcreds.h"
#include "protos.h"
#include "rng.h"
#include "callback.h"
#include "events.h"

#include "encode.h"

#include <ssl2msg.h>
#include <pct1msg.h>
#include <ssl3msg.h>
#include <ssl3key.h>
#include <tls1key.h>
#include <pct1prot.h>
#include <ssl2prot.h>

#include <sha.h>
#include <md2.h>
#include <rc2.h>
#include <rc4.h>

extern PLSA_SECPKG_FUNCTION_TABLE LsaTable;

#define PCT_INVALID_MAGIC       *(DWORD *)"eerF"

#if DBG

    void SPAssert(
        void *FailedAssertion,
        void *FileName,
        unsigned long LineNumber,
        char * Message);

    #define SP_ASSERT(x) \
            if (!(x)) \
            SPAssert(#x, __FILE__, __LINE__, NULL); else

#else // DBG

    #define SP_ASSERT(x)

#endif // DBG

#ifdef __cplusplus
}
#endif


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1ReverseBytes
//
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>


#ifdef __cplusplus
extern "C" {
#endif



//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    UNREFERENCED_PARAMETER(pDec);

    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\protocol.h ===
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_


typedef struct _SPContext SPContext, *PSPContext;


typedef struct _UNICipherMap {
    DWORD             CipherKind;
    DWORD             fProt;
    ALG_ID            aiHash;
    ALG_ID            aiCipher;
    DWORD             dwStrength;
    ExchSpec          KeyExch;
    ALG_ID            aiExch;
    DWORD             dwFlags;
} UNICipherMap, *PUNICipherMap;

// cipher map flag values
#define DOMESTIC_CIPHER_SUITE   0x00000001
#define EXPORT40_CIPHER_SUITE   0x00000002
#define EXPORT56_CIPHER_SUITE   0x00000004


extern DWORD g_ProtEnabled;

extern UNICipherMap UniAvailableCiphers[];
extern DWORD UniNumCiphers;

SP_STATUS WINAPI
ServerProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput);

SP_STATUS WINAPI
ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput);

SP_STATUS
GetSupportedCapiAlgs(
    HCRYPTPROV          hProv,
    PROV_ENUMALGS_EX ** ppAlgInfo,
    DWORD *             pcAlgInfo);

SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache);

SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    );



typedef SP_STATUS ( WINAPI * SPInitiateHelloFn)(
                    PSPContext             pContext,
                    PSPBuffer              pOutput,
                    BOOL                   fCache);

typedef SP_STATUS ( WINAPI * SPProtocolHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

typedef SP_STATUS ( WINAPI * SPDecryptHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);


typedef SP_STATUS ( WINAPI * SPDecryptMessageFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

typedef SP_STATUS ( WINAPI * SPEncryptMessageFn)(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);

typedef SP_STATUS ( WINAPI * SPGetHeaderSizeFn)(PSPContext pContext,
                                                PSPBuffer  pCommInput,
                                                DWORD *    pcbHeader);


/* State machine states */

#define SP_STATE_NONE                   0x00
#define PCT1_STATE_CLIENT_HELLO         0x01
#define PCT1_STATE_SERVER_HELLO         0x02
#define PCT1_STATE_CLIENT_MASTER_KEY    0x03
#define PCT1_STATE_SERVER_VERIFY        0x04
#define PCT1_STATE_ERROR                0x05
#define PCT1_STATE_RENEGOTIATE          0x06

#define SSL2_STATE_CLIENT_HELLO         0x11
#define SSL2_STATE_SERVER_HELLO         0x12
#define SSL2_STATE_CLIENT_MASTER_KEY    0x13
#define SSL2_STATE_CLIENT_FINISH        0x14
#define SSL2_STATE_SERVER_VERIFY        0x15
#define SSL2_STATE_SERVER_FINISH        0x16
#define SSL2_STATE_REQUEST_CERTIFICATE  0x17
#define SSL2_STATE_CLIENT_CERTIFICATE   0x18
#define SSL2_STATE_SERVER_RESTART       0x19
#define SSL2_STATE_CLIENT_RESTART       0x1a
#define SSL3_STATE_CLIENT_HELLO         0x1b
#define SSL3_STATE_CHANGE_CIPHER_SPEC   0x1c
#define SSL3_STATE_RESTART_CCS          0x1d
#define SSL3_STATE_RESTART_SERVER_FINISH 0x1e
#define SSL3_STATE_SERVER_FINISH        0x1f
#define UNI_STATE_RECVD_UNIHELLO        0xfe
#define UNI_STATE_CLIENT_HELLO          0xff
#define SSL3_STATE_CLIENT_FINISH        0x21
#define SSL3_STATE_RESTART_CLI_FINISH   0x22
#define SSL3_STATE_REDO_RESTART         0x24
#define SSL3_STATE_SERVER_CERTIFICATE   0x25
#define SSL3_STATE_SERVER_KEY_XCHANGE   0x26
#define SSL3_STATE_SERVER_CERTREQ       0x27
#define SSL3_STATE_SERVER_HELLO         0x29
#define SSL3_STATE_CLIENT_KEY_XCHANGE   0x31
#define SSL3_STATE_CERT_VERIFY          0x32
#define SSL3_STATE_FINISHED             0x33
#define SSL3_STATE_RESTART_SER_HELLO    0x36
#define SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC 0x37
#define SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT 0x38
#define SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER 0x39
#define SSL3_STATE_NO_CERT_ALERT        0x3a
#define SSL3_STATE_RENEGOTIATE           0x3b
#define SSL3_STATE_SGC_CERTIFICATE      0x3c


//these defines must not be touched... Please do not in this section...
// PROTECTED BY SSL3 SPECEFIC states
#define SSL3_STATE_GEN_START                0x80
#define SSL3_STATE_GEN_SERVER_HELLORESP     (SSL3_STATE_GEN_START + 1)
#define SSL3_STATE_GEN_SERVER_HELLO         (SSL3_STATE_GEN_START + 2)
#define SSL3_STATE_GEN_SERVER_HELLO_RESTART (SSL3_STATE_GEN_START + 3)
#define SSL3_STATE_GEN_SERVER_FINISH        (SSL3_STATE_GEN_START + 4)
#define SSL3_STATE_GEN_CLIENT_FINISH        (SSL3_STATE_GEN_START + 5)
#define SSL3_STATE_GEN_REDO                 (SSL3_STATE_GEN_START + 6)  
#define SSL3_STATE_GEN_HELLO_REQUEST        (SSL3_STATE_GEN_START + 7)
#define SSL3_STATE_CONNECTED_SERVER         (SSL3_STATE_GEN_START + 8)
#define TLS1_STATE_ERROR                    (SSL3_STATE_GEN_START + 9)
#define SSL3_STATE_GEN_END                  (SSL3_STATE_GEN_START + 10)

//PROTECTED AREA ENDS.................

#define SP_STATE_SHUTDOWN_PENDING   0x0000fffd  // We're building a CloseNotify alert. 
#define SP_STATE_SHUTDOWN           0x0000fffe  // We're shutting down.

#define SP_STATE_CONNECTED      0x0000ffff  /* We are connected, and are 
                                             * expecting data packets, otherwise
                                             * we are performing a protocol 
                                             * negotiation lower word contains
                                             * last message sent, implying what
                                             * the next word will be */


// UNIHELLO codes.

#define PCT_SSL_COMPAT                  0x8f
#define PCT_SSL_CERT_TYPE               0x80
#define PCT_SSL_HASH_TYPE               0x81
#define PCT_SSL_EXCH_TYPE               0x82
#define PCT_SSL_CIPHER_TYPE_1ST_HALF    0x83
#define PCT_SSL_CIPHER_TYPE_2ND_HALF    0x84

#define UNI_CK_PCT  SSL_MKFAST(PCT_SSL_COMPAT, MSBOF(PCT_VERSION_1), LSBOF(PCT_VERSION_1))
#define PCT_SSL_CERT_X509  SSL_MKFAST(0x80, 0x00, 0x00)
#define PCT_SSL_CERT_PKCS7 SSL_MKFAST(0x80, 0x00, 0x01)


#endif /* _PROTOCOL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

SP_STATUS GetDefaultIssuers(
    PBYTE pbIssuers,        // out
    DWORD *pcbIssuers);     // in, out

BOOL GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCert,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

BOOL LoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys);

BOOL SchannelInit(BOOL fAppProcess);
BOOL SchannelShutdown(VOID);

BOOL
SslGetClientProcess(ULONG *pProcessID);

BOOL
SslGetClientThread(ULONG *pThreadID);

BOOL
SslImpersonateClient(void);

NTSTATUS
SslGetClientLogonId(LUID *pLogonId);

PVOID SPExternalAlloc(DWORD cbLength);
VOID  SPExternalFree(PVOID pMemory);

extern HANDLE               g_hInstance;
extern RTL_CRITICAL_SECTION g_InitCritSec;
extern BOOL                 g_fSchannelInitialized;

// Pointer to FreeContextBuffer:SECUR32.DLL
extern FREE_CONTEXT_BUFFER_FN g_pFreeContextBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\spdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spdefs.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-23-97   jbanes   Added hash lengths.
//
//----------------------------------------------------------------------------

#define CALG_NULLCIPHER     (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_ANY | 0)

/* keyexchange algs */
#define SP_EXCH_RSA_PKCS1              0x0001
#define SP_EXCH_RSA_PKCS1_TOKEN_DES     0x0002
#define SP_EXCH_RSA_PKCS1_TOKEN_DES3    0x0003
#define SP_EXCH_RSA_PKCS1_TOKEN_RC2     0x0004
#define SP_EXCH_RSA_PKCS1_TOKEN_RC4     0x0005

#define SP_EXCH_DH_PKCS3                0x0006
#define SP_EXCH_DH_PKCS3_TOKEN_DES      0x0007
#define SP_EXCH_DH_PKCS3_TOKEN_DES3     0x0008
#define SP_EXCH_FORTEZZA_TOKEN          0x0009

#define SP_EXCH_UNKNOWN                 0xffff

/* certificate types */
#define PCT1_CERT_NONE                  0x0000
#define PCT1_CERT_X509                  0x0001
#define PCT1_CERT_PKCS7                 0x0002

/* signature algorithms */
#define SP_SIG_NONE               0x0000
#define SP_SIG_RSA_MD5                0x0001
#define SP_SIG_RSA_SHA                  0x0002
#define SP_SIG_DSA_SHA                  0x0003

/* these are for internal use only */
#define SP_SIG_RSA_MD2              0x0004
#define SP_SIG_RSA                      0x0005
#define SP_SIG_RSA_SHAMD5               0x0006
#define SP_SIG_FORTEZZA_TOKEN           0x0007


/* sizing of local structures */
#define SP_MAX_SESSION_ID           32
#define SP_MAX_MASTER_KEY           48
#define SP_MAX_MAC_KEY              48
#define SP_MAX_CACHE_ID             64
#define SP_MAX_CHALLENGE            32
#define SP_MAX_CONNECTION_ID        32
#define SP_MAX_KEY_ARGS             32
#define SP_MAX_BLOCKCIPHER_SIZE     16      // 16 bytes required for SSL3/Fortezza.
#define SP_MAX_DIGEST_LEN           32
#define SP_MAX_CREDS                20

#define SP_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)
/* tuning constants */

#define SP_DEF_SERVER_CACHE_SIZE        100
#define SP_DEF_CLIENT_CACHE_SIZE        10

#define SP_MIN_PRIVATE_KEY_FILE_SIZE    80

typedef LONG SP_STATUS;

#define CB_MD5_DIGEST_LEN   16
#define CB_SHA_DIGEST_LEN   20

#define SP_MAX_CAPI_ALGS    40


/* internal representations of algorithm specs */

typedef DWORD   CipherSpec, *PCipherSpec;
typedef DWORD   KeyExchangeSpec, *PKeyExchangeSpec;
typedef DWORD   HashSpec,   *PHashSpec;
typedef DWORD   CertSpec,   *PCertSpec;
typedef DWORD   ExchSpec,   *PExchSpec;
typedef DWORD   SigSpec,    *PSigSpec;


typedef struct _KeyTypeMap
{
    ALG_ID aiKeyAlg;             // CAPI2 Key type
    DWORD  Spec;     // Protocol Specific Type
} KeyTypeMap, *PKeyTypeMap;

typedef struct _CertTypeMap
{
    DWORD  dwCertEncodingType;             // CAPI2 Cert Encoding Type
    DWORD  Spec;     // Protocol Specific Type
} CertTypeMap, *PCertTypeMap;


typedef struct _SPBuffer {
    unsigned long cbBuffer;             /* Size of the buffer, in bytes */
    unsigned long cbData;               /* size of the actual data in the 
                                         * buffer, in bytes */
    void * pvBuffer;                    /* Pointer to the buffer */
} SPBuffer, * PSPBuffer;

#define SGC_KEY_SALT "SGCKEYSALT"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\specmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       specmap.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

struct _SPContext;

typedef struct csel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    PSTR                szName;
    ALG_ID              aiCipher;
    DWORD               dwBlockSize;        // bytes
    DWORD               dwStrength;         // key strength in bits
    DWORD               cbKey;              // required key material
    DWORD               cbSecret;           // bytes of secret key material
    DWORD               dwFlags;            // See flags field
} CipherInfo, *PCipherInfo;

#define CF_EXPORT       0x00000001          // This cipher is allowed for export use
#define CF_DOMESTIC     0x00000002          // This cipher is for domestic use only
#define CF_SGC          0x00000004          // This cipher is allowed with Server Gated Crypto
#define CF_FINANCE      0x00000008          // This cipher is allowed with SELECTIVE CRYPTO
#define CF_FASTSGC      0x00000010          // This indicates that the SGC type is fast
#define CF_RENEWED      0x00000020

typedef struct hsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    PSTR                szName;
    ALG_ID              aiHash;
    DWORD               cbCheckSum;         // bytes
} HashInfo, *PHashInfo;

typedef struct sigsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    SigSpec             Spec;
    PSTR                szName;

    ALG_ID              aiHash;
    ALG_ID              aiSig;
} SigInfo, *PSigInfo;


typedef struct kexch 
{
    ALG_ID              aiExch;
    DWORD               fProtocol;
    DWORD               fDefault;
    ExchSpec            Spec;
    PSTR                szName;
    KeyExchangeSystem * System;

} KeyExchangeInfo, *PKeyExchangeInfo;

typedef struct certsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    CertSpec            Spec;
    PSTR                szName;
} CertSysInfo, *PCertSysInfo;



PCipherInfo         GetCipherInfo(ALG_ID aiCipher, DWORD dwStrength);

PHashInfo           GetHashInfo(ALG_ID aiHash);

PKeyExchangeInfo    GetKeyExchangeInfo(ExchSpec Spec);

PKeyExchangeInfo    GetKeyExchangeInfoByAlg(ALG_ID aiExch);

PCertSysInfo        GetCertSysInfo(CertSpec Spec);

PSigInfo            GetSigInfo(SigSpec Spec);


KeyExchangeSystem * KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol);

BOOL GetBaseCipherSizes(DWORD *dwMin, DWORD *dwMax);

void 
GetDisplayCipherSizes(
    PSPCredentialGroup pCredGroup,
    DWORD *dwMin, 
    DWORD *dwMax);

BOOL IsCipherAllowed(
    SPContext * pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags);

BOOL 
IsCipherSuiteAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags,
    DWORD       dwSuiteFlags);

BOOL IsHashAllowed(
    SPContext * pContext, 
    PHashInfo   pHash,
    DWORD       dwProtocol);

BOOL IsExchAllowed(
    SPContext *      pContext, 
    PKeyExchangeInfo pExch,
    DWORD            dwProtocol);

BOOL IsAlgAllowed(
    PSPCredentialGroup pCred, 
    ALG_ID aiAlg);

BOOL BuildAlgList(PSPCredentialGroup pCred, ALG_ID *aalgRequestedAlgs, DWORD cRequestedAlgs);

BOOL
IsAlgSupportedCapi(
    DWORD               dwProtocol, 
    UNICipherMap *      pCipherMap,
    PROV_ENUMALGS_EX *  pCapiAlgs,
    DWORD               cCapiAlgs);

extern CipherInfo  g_AvailableCiphers[];
extern DWORD       g_cAvailableCiphers;

extern HashInfo    g_AvailableHashes[];
extern DWORD       g_cAvailableHashes;

extern CertSysInfo g_AvailableCerts[];
extern DWORD       g_cAvailableCerts;

extern SigInfo     g_AvailableSigs[];
extern DWORD       g_cAvailableSigs;

extern KeyExchangeInfo g_AvailableExch[];
extern DWORD           g_cAvailableExch;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\rng.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    11-05-97   jbanes   Modified to use static rsaenh.dll.
//
//----------------------------------------------------------------------------

NTSTATUS
GenerateRandomBits(
    PUCHAR      pRandomData,
    ULONG       cRandomData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\spverp.h ===
#define VER_SCHANNEL 1600
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\spreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spreg.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-97   jbanes   Remove CertificateAuthorities entry.
//
//----------------------------------------------------------------------------

#ifndef _SPREG_H_
#define _SPREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [System]
 *       [CurrentControlSet]
 *           [Control]
 *               [SecurityProviders]
 *                   [SCHANNEL]
 *                       EventLogging:REG_DWORD:   - Flag specifing event logging level
 *                       LogFile:REG_SZ:           - debug logfile name (Not published)
 *                       LogLevel:REG_SZ:          - debug logging level flags.
 *                       DebugBreak:REG_DWORD:     - Flag specifing what type of errors cause a debug break (Not published)
 *                       MaximumCacheSize:REG_DWORD - maximum number of cache elements
 *                       ClientCacheTime:REG_DWORD - time to expire client side cache elements
 *                       ServerCacheTime:REG_DWORD - time to expire server side cache elements
 *                       MultipleProcessClientCache:REG_DWORD - whether to support multi-process caching
 *
 *                       [Protocols]
 *                           [SSL2]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL3]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                           [PCT1]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *
 *                       [Ciphers]
 *                           [Cipher Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                           [RC4_128]
 *                               Enabled:REG_DWORD: - Is this Ciphers enabled
 *                       [Hashes]
 *                           [Hash Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                       [KeyExchangeAlgorithms]
 *                           [Exch Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *
 */

// FIPS registry entries
#define SP_REG_FIPS_BASE_KEY    TEXT("System\\CurrentControlSet\\Control\\Lsa")
#define SP_REG_FIPS_POLICY      TEXT("FipsAlgorithmPolicy")

/* Key Names */
#define SP_REG_KEY_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define SP_REG_KEY_PROTOCOL TEXT("Protocols")
#define SP_REG_KEY_CIPHERS  TEXT("Ciphers")
#define SP_REG_KEY_HASHES   TEXT("Hashes")
#define SP_REG_KEY_KEYEXCH  TEXT("KeyExchangeAlgorithms")

/* Value Names */
#define SP_REG_VAL_EVENTLOG  TEXT("EventLogging")
#define SP_REG_VAL_LOGFILE   "LogFile"
#define SP_REG_VAL_LOGLEVEL  TEXT("LogLevel")
#define SP_REG_VAL_BREAK     TEXT("DebugBreak")
#define SP_REG_VAL_MANUAL_CRED_VALIDATION TEXT("ManualCredValidation")
#define SP_REG_VAL_DISABLED_BY_DEFAULT TEXT("DisabledByDefault")
#define SP_REG_VAL_MULTI_PROC_CLIENT_CACHE TEXT("MultipleProcessClientCache")
#define SP_REG_VAL_SEND_ISSUER_LIST TEXT("SendTrustedIssuerList")
#define SP_REG_VAL_CERT_MAPPING_METHODS TEXT("CertificateMappingMethods")

#define SP_REG_VAL_MAXUMUM_CACHE_SIZE  TEXT("MaximumCacheSize")
#define SP_REG_VAL_CLIENT_CACHE_TIME   TEXT("ClientCacheTime")
#define SP_REG_VAL_SERVER_CACHE_TIME   TEXT("ServerCacheTime")
#define SP_REG_VAL_RNG_SEED            TEXT("RNGSeed")

// Issuer cache used with many-to-one certificate mapping
#define SP_REG_VAL_ISSUER_CACHE_SIZE  TEXT("IssuerCacheSize")
#define SP_REG_VAL_ISSUER_CACHE_TIME  TEXT("IssuerCacheTime")


#define SP_REG_VAL_ENABLED   TEXT("Enabled")
#define SP_REG_VAL_CACERT    TEXT("CACert")
#define SP_REG_VAL_CERT_TYPE TEXT("Type")

#define SP_REG_VAL_SERVER_TIMEOUT   TEXT("ServerHandshakeTimeout")

#define SP_REG_KEY_CLIENT    TEXT("Client")
#define SP_REG_KEY_SERVER    TEXT("Server")

#define SP_REG_KEY_PCT1      TEXT("PCT 1.0")
#define SP_REG_KEY_SSL2      TEXT("SSL 2.0")
#define SP_REG_KEY_SSL3      TEXT("SSL 3.0")
#define SP_REG_KEY_TLS1      TEXT("TLS 1.0")

#define MANUAL_CRED_VALIDATION_SETTING      FALSE
#define PCT_CLIENT_DISABLED_SETTING         TRUE
#define SSL2_CLIENT_DISABLED_SETTING        FALSE
#define DEFAULT_EVENT_LOGGING_SETTING       DEB_ERROR
#define DEFAULT_ENABLED_PROTOCOLS_SETTING   (SP_PROT_SSL2 | SP_PROT_SSL3 | SP_PROT_TLS1 | SP_PROT_UNI)

extern BOOL g_fManualCredValidation;

extern BOOL g_PctClientDisabledByDefault;
extern BOOL g_Ssl2ClientDisabledByDefault;

extern BOOL g_fFranceLocale;

extern BOOL g_fSendIssuerList;

#define SP_REG_CERTMAP_SUBJECT_FLAG     0X0001
#define SP_REG_CERTMAP_ISSUER_FLAG      0x0002
#define SP_REG_CERTMAP_UPN_FLAG         0x0004
#define SP_REG_CERTMAP_S4U2SELF_FLAG    0x0008

#define DEFAULT_CERTMAP_SETTING (SP_REG_CERTMAP_SUBJECT_FLAG    | \
                                 SP_REG_CERTMAP_ISSUER_FLAG     | \
                                 SP_REG_CERTMAP_UPN_FLAG        | \
                                 SP_REG_CERTMAP_S4U2SELF_FLAG)

extern DWORD g_dwCertMappingMethods;

extern BOOL g_SslS4U2SelfInitialized;

BOOL SPLoadRegOptions(void);
void SPUnloadRegOptions(void);


/* Event Logging Definitions */
#define SP_EVLOG_RESOURCE           0x0001
#define SP_EVLOG_ASSERT             0x0002
#define SP_EVLOG_ILLEGAL_MESSAGE    0x0004
#define SP_EVLOG_SECAUDIT           0x0008


#define SP_LOG_ERROR                0x0001
#define SP_LOG_WARNING              0x0002
#define SP_LOG_TRACE                0x0004
#define SP_LOG_ALLOC                0x0008
#define SP_LOG_RES                  0x0010

#define SP_LOG_TIMESTAMP            0x20000000
#define SP_LOG_BUFFERS              0x40000000
#define SP_LOG_FILE                 0x80000000

#define SP_BREAK_ERROR              0x0001
#define SP_BREAK_WARNING            0x0002
#define SP_BREAK_ENTRY              0x0004

#endif // _SPREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\sperr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sperr.c
//
//  Contents:   Schannel internal error codes.
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------


/* We really have to straighten out
 * the error message situation */
/* basic error codes, for transmission over the 
 * communications channel */
#define PCT_ERR_OK                      0x0000
#define PCT_ERR_BAD_CERTIFICATE         0x0001
#define PCT_ERR_CLIENT_AUTH_FAILED      0x0002
#define PCT_ERR_ILLEGAL_MESSAGE         0x0003
#define PCT_ERR_INTEGRITY_CHECK_FAILED  0x0004
#define PCT_ERR_SERVER_AUTH_FAILED      0x0005
#define PCT_ERR_SPECS_MISMATCH          0x0006
#define PCT_ERR_SSL_STYLE_MSG           0x00ff
#define PCT_ERR_RENEGOTIATE             0x0008
#define PCT_ERR_UNKNOWN_CREDENTIAL      0x0009
#define PCT_ERR_EXPIRED                 0x000a

/* internal error codes, for communications with
 * the application */
#define PCT_INT_BUFF_TOO_SMALL          0x40000000
#define PCT_INT_INCOMPLETE_MSG          0x40000001  /* this specifies to the comm layer to pass
                                                     * more data */

#define PCT_INT_DROP_CONNECTION    0x80000000
#define PCT_INT_BAD_CERT           (PCT_INT_DROP_CONNECTION | PCT_ERR_BAD_CERTIFICATE)
#define PCT_INT_CLI_AUTH           (PCT_INT_DROP_CONNECTION | PCT_ERR_CLIENT_AUTH_FAILED)
#define PCT_INT_ILLEGAL_MSG        (PCT_INT_DROP_CONNECTION | PCT_ERR_ILLEGAL_MESSAGE)
#define PCT_INT_MSG_ALTERED        0x80000101
#define PCT_INT_INTERNAL_ERROR     0xffffffff
#define PCT_INT_DATA_OVERFLOW      0x80000102
#define PCT_INT_SPECS_MISMATCH     (PCT_INT_DROP_CONNECTION | PCT_ERR_SPECS_MISMATCH)
#define PCT_INT_RENEGOTIATE        (PCT_INT_DROP_CONNECTION | PCT_ERR_RENEGOTIATE)
#define PCT_INT_UNKNOWN_CREDENTIAL (PCT_INT_DROP_CONNECTION | PCT_ERR_UNKNOWN_CREDENTIAL)
#define PCT_INT_EXPIRED            (PCT_INT_DROP_CONNECTION | PCT_ERR_EXPIRED)

#define SP_FATAL(s) (PCT_INT_DROP_CONNECTION & (s))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ssl3key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*	Owner 			:ramas
*	Date			:4/16/96
*	description		: Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/
#ifndef _SSL3KEY_H_
#define _SSL3KEY_H_

#define CB_SSL3_MAX_MAC_PAD 48
#define CB_SSL3_MD5_MAC_PAD 48
#define CB_SSL3_SHA_MAC_PAD 40

#define PAD1_CONSTANT 0x36
#define PAD2_CONSTANT 0x5c


SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext);

SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext);


#endif _SSL3KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ssl2prot.h ===
#ifndef _SSL2PROT_H_
#define _SSL2PROT_H_

SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl3ProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    );

SP_STATUS WINAPI
Ssl2GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI Ssl2DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl2EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);

SP_STATUS WINAPI Ssl3DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl3EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvHandleClientFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);
SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                              PUCHAR  pSrvHello,
                              DWORD cbMessage,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenRestart(PSPContext pContext,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvFinishClientRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerRestart(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PSsl2_Server_Hello pHello,
                                   PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliFinishRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2GenCliFinished(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS
Ssl2MakeSessionKeys(PSPContext pContext);


#endif /* _SSL2PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ssl2msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL2MSG_H__
#define __SSL2MSG_H__

typedef struct _Ssl2_Cipher_Tuple {
    UCHAR   C1;
    UCHAR   C2;
    UCHAR   C3;
} Ssl2_Cipher_Tuple, * PSsl2_Cipher_Tuple;

///////////////////////////////////////////////////////////////////
//
// Useful Macros
//
///////////////////////////////////////////////////////////////////

#define LSBOF(x)    ((UCHAR) ((x) & 0xFF))
#define MSBOF(x)    ((UCHAR) (((x) >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))



///////////////////////////////////////////////////////////////////
//
// Message Constants
//
///////////////////////////////////////////////////////////////////

#define SSL2_CLIENT_VERSION          0x0002
#define SSL2_SERVER_VERSION          0x0002

#define SSL2_CLIENT_VERSION_MSB      0x00
#define SSL2_CLIENT_VERSION_LSB      0x02

#define SSL2_SERVER_VERSION_MSB      0x00
#define SSL2_SERVER_VERSION_LSB      0x02

#define SSL2_MT_ERROR                0
#define SSL2_MT_CLIENT_HELLO         1
#define SSL2_MT_CLIENT_MASTER_KEY    2
#define SSL2_MT_CLIENT_FINISHED_V2   3
#define SSL2_MT_SERVER_HELLO         4
#define SSL2_MT_SERVER_VERIFY        5
#define SSL2_MT_SERVER_FINISHED_V2   6
#define SSL2_MT_REQUEST_CERTIFICATE  7
#define SSL2_MT_CLIENT_CERTIFICATE   8
#define SSL2_MT_CLIENT_DH_KEY        9
#define SSL2_MT_CLIENT_SESSION_KEY   10
#define SSL2_MT_CLIENT_FINISHED      11
#define SSL2_MT_SERVER_FINISHED      12

#define SSL_PE_NO_CIPHER            0x0001
#define SSL_PE_NO_CERTIFICATE       0x0002
#define SSL_PE_BAD_CERTIFICATE      0x0004
#define SSL_PE_UNSUPPORTED_CERTIFICATE_TYPE 0x0006


#define SSL_CT_X509_CERTIFICATE     0x01
#define SSL_CT_PKCS7_CERTIFICATE    0x02

#if DBG
#define SSL_CT_DEBUG_CERT           0x80
#endif

#define SSL2_MAX_CHALLENGE_LEN       32  /* max accepted challenge size */
#define SSL2_CHALLENGE_SIZE          16  /* default generated challenge size */
#define SSL2_SESSION_ID_LEN          16
#define SSL2_GEN_CONNECTION_ID_LEN   16  /* Dont change this, netscape requires 16 byte
                                          * id's */
#define SSL2_MAX_CONNECTION_ID_LEN   32
#define SSL3_SESSION_ID_LEN    32
#define SSL2_MAC_LENGTH              16
#define SSL2_MASTER_KEY_SIZE         16
#define SSL2_MAX_KEY_ARGS            8
#define SSL2_MAX_MESSAGE_LENGTH     32768
#define MAX_UNI_CIPHERS             64

#define SSL_MKFAST(a, b, c) (DWORD)(((a)<<16) | ((b)<<8) | (c))

#define SSL_MKSLOW(a) (UCHAR)((a>>16)& 0xff), (UCHAR)((a>>8)& 0xff), (UCHAR)((a)& 0xff)

#define SSL_RSA_WITH_RC4_128_MD5                SSL_MKFAST(0x00, 0x00,  0x04)
#define SSL_RSA_EXPORT_WITH_RC4_40_MD5          SSL_MKFAST(0x00, 0x00,  0x03)

#define SSL_CK_RC4_128_WITH_MD5                 SSL_MKFAST(0x01, 0x00,  0x80)
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5        SSL_MKFAST(0x02, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_WITH_MD5             SSL_MKFAST(0x03, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5    SSL_MKFAST(0x04, 0x00,  0x80)
#define SSL_CK_IDEA_128_CBC_WITH_MD5            SSL_MKFAST(0x05, 0x00,  0x80)
#define SSL_CK_DES_64_CBC_WITH_MD5              SSL_MKFAST(0x06, 0x00,  0x40)
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5        SSL_MKFAST(0x07, 0x00,  0xC0)
#define SSL_CK_NULL_WITH_MD5                    SSL_MKFAST(0x00, 0x00,  0x00)
#define SSL_CK_DES_64_CBC_WITH_SHA              SSL_MKFAST(0x06, 0x01,  0x40)
#define SSL_CK_DES_192_EDE3_WITH_SHA            SSL_MKFAST(0x07, 0x01,  0xC0)

#define SSL_CK_RC4_128_FINANCE64_WITH_MD5       SSL_MKFAST(0x08, 0x00, 0x80)

#ifdef ENABLE_NONE_CIPHER
#define SSL_CK_NONE                             SSL_MKFAST(0x09, 0x00,  0x00)
#endif



#define SSL_KEA_RSA                             {(UCHAR) 0x10, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES_EDE3         {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_RSA_TOKEN_WITH_RC4              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x02}
#define SSL_KEA_DH                              {(UCHAR) 0x11, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES               {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES_EDE3          {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_DH_ANON                         {(UCHAR) 0x12, (UCHAR) 0x00, (UCHAR) 0x00}

#define CRYPTO_RC4_128  0x00010080
#define CRYPTO_RC4_40   0x00020080
#define CRYPTO_RC2_128  0x00030080
#define CRYPTO_RC2_40   0x00040080
#define CRYPTO_IDEA_128 0x00050080
#define CRYPTO_NULL     0x00000000
#define CRYPTO_DES_64   0x00060040
#define CRYPTO_3DES_192 0x000700C0


extern CertTypeMap aSsl2CertEncodingPref[];
extern DWORD cSsl2CertEncodingPref;


typedef DWORD Ssl2_Cipher_Kind;

//typedef struct _Ssl2CipherMap {
//    Ssl2_Cipher_Kind  Kind;
//    ALG_ID            aiHash;
//    ALG_ID            aiCipher;
//    DWORD             dwStrength;
//    ExchSpec          KeyExch;
//    ALG_ID            aiKeyAlg;
//} Ssl2CipherMap, *PSsl2CipherMap;


typedef struct _SSL2_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} SSL2_MESSAGE_HEADER, * PSSL2_MESSAGE_HEADER;

typedef struct _SSL2_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} SSL2_MESSAGE_HEADER_EX, * PSSL2_MESSAGE_HEADER_EX;


typedef struct _SSL2_ERROR {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
} SSL2_ERROR, * PSSL2_ERROR;


typedef struct _SSL2_CLIENT_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               SessionIdLenMsb;
    UCHAR               SessionIdLenLsb;
    UCHAR               ChallengeLenMsb;
    UCHAR               ChallengeLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_HELLO, * PSSL2_CLIENT_HELLO;


typedef struct _SSL2_SERVER_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               SessionIdHit;
    UCHAR               CertificateType;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               ConnectionIdLenMsb;
    UCHAR               ConnectionIdLenLsb;
    UCHAR               VariantData[1];
} SSL2_SERVER_HELLO, * PSSL2_SERVER_HELLO;

typedef struct _SSL2_CLIENT_MASTER_KEY {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    Ssl2_Cipher_Tuple    CipherKind;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_MASTER_KEY, * PSSL2_CLIENT_MASTER_KEY;


typedef struct _SSL2_SERVER_VERIFY {
    UCHAR               MessageId;
    UCHAR               ChallengeData[SSL2_MAX_CHALLENGE_LEN];
} SSL2_SERVER_VERIFY, * PSSL2_SERVER_VERIFY;

typedef struct _SSL2_CLIENT_FINISHED {
    UCHAR               MessageId;
    UCHAR               ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
} SSL2_CLIENT_FINISHED, * PSSL2_CLIENT_FINISHED;

typedef struct _SSL2_SERVER_FINISHED {
    UCHAR               MessageId;
    UCHAR               SessionID[SSL2_SESSION_ID_LEN];
} SSL2_SERVER_FINISHED, * PSSL2_SERVER_FINISHED;



////////////////////////////////////////////////////
//
// Expanded Form Messages:
//
////////////////////////////////////////////////////

/* Rules for buffer in expanded form */
/* Only things which are going to be allocated
 * anyway, or are created statically are not created
 * as arrays */

typedef DWORD   CipherSpec;
typedef DWORD * PCipherSpec;

typedef struct _Ssl2_Client_Hello {
    DWORD         dwVer;
    DWORD           cCipherSpecs;
    DWORD           cbSessionID;
    DWORD           cbChallenge;
    UCHAR           SessionID[SSL3_SESSION_ID_LEN];   //NOTE: changed to 32 bytes long....
    UCHAR           Challenge[SSL2_MAX_CHALLENGE_LEN];
    Ssl2_Cipher_Kind CipherSpecs[MAX_UNI_CIPHERS]; /* points to static array */
} Ssl2_Client_Hello, * PSsl2_Client_Hello;

typedef struct _Ssl2_Server_Hello {
    DWORD           SessionIdHit;
    DWORD           CertificateType;
    DWORD           cbCertificate;
    DWORD           cCipherSpecs;
    DWORD           cbConnectionID;
    UCHAR           ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
    PUCHAR          pCertificate;       /* points to pre-created cert */
    Ssl2_Cipher_Kind *    pCipherSpecs; /* points to static array */
} Ssl2_Server_Hello, * PSsl2_Server_Hello;


typedef struct _Ssl2_Client_Master_Key {
    DWORD               ClearKeyLen;
    DWORD               EncryptedKeyLen;
    DWORD               KeyArgLen;
    Ssl2_Cipher_Kind    CipherKind;
    UCHAR               ClearKey[SSL2_MASTER_KEY_SIZE];
    UCHAR  *            pbEncryptedKey;
    UCHAR               KeyArg[SSL2_MASTER_KEY_SIZE];
} Ssl2_Client_Master_Key, * PSsl2_Client_Master_Key;

///////////////////////////////////////////////////
//
// Pickling Prototypes
//
///////////////////////////////////////////////////
SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello      pCanonical,
    PSPBuffer               pCommOutput);

SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer          pInput,
    PSsl2_Client_Hello *     ppClient);

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer);

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient);



#endif /* __SSL2MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ssl3.h ===
//+---------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3.h
//
//  Contents:   SSL 3 protocol constants
//
//  Classes:
//
//  Functions:
//
//  History:    11-19-97   jbanes    Created
//
//----------------------------------------------------------------------------

#ifndef __SSL3_H__
#define __SSL3_H__


#define CB_SSL3_SESSION_ID              32
#define CB_SSL3_RANDOM                  32
#define CB_SSL3_PRE_MASTER_SECRET       48
#define CB_SSL3_PROTOCOL                2
#define CB_SSL3_HEADER_SIZE             5
#define CB_SSL3_16_VECTOR               2

#define CB_SSL3_ISSUER_LENGTH           2
#define CB_SSL3_MASTER_KEY_BLOCK        112
#define SSL3_MAX_CLIENT_CERTS           4


#define SSL3_NULL_WITH_NULL_NULL                0x0000
#define SSL3_RSA_WITH_NULL_MD5                  0x0001
#define SSL3_RSA_WITH_NULL_SHA                  0x0002
#define SSL3_RSA_EXPORT_WITH_RC4_40_MD5         0x0003
#define SSL3_RSA_WITH_RC4_128_MD5               0x0004
#define SSL3_RSA_WITH_RC4_128_SHA               0x0005
#define SSL3_RSA_EXPORT_WITH_RC2_CBC_40_MD5     0x0006  
#define SSL3_RSA_WITH_DES_CBC_SHA               0x0009  
#define SSL3_RSA_WITH_3DES_EDE_CBC_SHA          0x000A  
#define SSL3_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA 0x001D

#define SSL3_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  0x0011
#define SSL3_DHE_DSS_WITH_DES_CBC_SHA           0x0012
#define SSL3_DHE_DSS_WITH_3DES_EDE_CBC_SHA      0x0013

#define TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA     0x0062
#define TLS_RSA_EXPORT1024_WITH_RC4_56_SHA      0x0064
#define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA 0x0063
#define TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA  0x0065
#define TLS_DHE_DSS_WITH_RC4_128_SHA            0x0066

#define SSL_RSA_FINANCE64_WITH_RC4_64_MD5       0x0080
#define SSL_RSA_FINANCE64_WITH_RC4_64_SHA       0x0081


#define SSL3_CERTTYPE_RSA_SIGN          1
#define SSL3_CERTTYPE_DSS_SIGN          2
#define SSL3_CERTTYPE_RSA_FIXED_DH      3
#define SSL3_CERTTYPE_DSS_FIXED_DH      4
#define SSL3_CERTTYPE_RSA_EPHEMERAL_DH  5
#define SSL3_CERTTYPE_DSS_EPHEMERAL_DH  6
#define SSL3_CERTTYPE_FORTEZZA_KEA      20

#define SSL3_CERTTYPE_MAX_COUNT         10


#define SSL3_HS_HELLO_REQUEST           0x00
#define SSL3_HS_CLIENT_HELLO            0x01
#define SSL3_HS_SERVER_HELLO            0x02
#define SSL3_HS_CERTIFICATE             0x0B
#define SSL3_HS_SERVER_KEY_EXCHANGE     0x0C
#define SSL3_HS_CERTIFICATE_REQUEST     0x0D
#define SSL3_HS_SERVER_HELLO_DONE       0x0E
#define SSL3_HS_CERTIFICATE_VERIFY      0x0F
#define SSL3_HS_CLIENT_KEY_EXCHANGE     0x10
#define SSL3_HS_FINISHED                0x14
#define SSL3_HS_SGC_CERTIFICATE         0x32

#define SSL3_CT_CHANGE_CIPHER_SPEC      20
#define SSL3_CT_ALERT                   21
#define SSL3_CT_HANDSHAKE               22 
#define SSL3_CT_APPLICATIONDATA         23
#define SSL3_NULL_WRAP                  15
#define SSL3_CLIENT_VERSION_MSB         0x03
#define SSL3_CLIENT_VERSION_LSB         0x00
#define TLS1_CLIENT_VERSION_LSB         0x01
#define CB_SSL3_CERT_VECTOR             3

// Alert levels
#define SSL3_ALERT_WARNING              1
#define SSL3_ALERT_FATAL                2

// Alert message types
#define SSL3_ALERT_CLOSE_NOTIFY         0
#define SSL3_ALERT_UNEXPECTED_MESSAGE   10
#define SSL3_ALERT_BAD_RECORD_MAC       20
#define SSL3_ALERT_DECOMPRESSION_FAIL   30
#define SSL3_ALERT_HANDSHAKE_FAILURE    40
#define SSL3_ALERT_NO_CERTIFICATE       41
#define SSL3_ALERT_BAD_CERTIFICATE      42
#define SSL3_ALERT_UNSUPPORTED_CERT     43
#define SSL3_ALERT_CERTIFICATE_REVOKED  44
#define SSL3_ALERT_CERTIFICATE_EXPIRED  45
#define SSL3_ALERT_CERTIFICATE_UNKNOWN  46
#define SSL3_ALERT_ILLEGAL_PARAMETER    47


#define SSL3_MAX_MESSAGE_LENGTH         0x4000
#define SSL3_MAX_ISSUER_LIST            0x3000
#define SSL3_CLIENT_VERSION             0x0300
#define TLS1_CLIENT_VERSION             0x0301


#endif //__SSL3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\ssl3msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3msg.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL3MSG_H__
#define __SSL3MSG_H__

#define CB_SSL3_CHANGE_CIPHER_SPEC      (sizeof(SWRAP) + 1)
#define CB_SSL3_CHANGE_CIPHER_SPEC_ONLY 1

#define CB_SSL3_FINISHED_MSG        (sizeof(FMWIRE))
#define CB_SSL3_FINISHED_MSG_ONLY   (sizeof(SHSH) + CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN)

#define CB_SSL3_ALERT                   (sizeof(SWRAP) +2)
#define CB_SSL3_ALERT_ONLY              2


#define SSL3_CHANGE_CIPHER_MSG  { 0x14, 0x03, 0x00, 0x00, 0x01, 0x01 }


#define FSsl3CipherClient() (0 != pContext->wS3CipherSuiteClient)
#define FSsl3CipherServer() (0 != pContext->wS3CipherSuiteServer)

#define FSsl3Cipher(fClient) ((fClient ? pContext->wS3CipherSuiteClient : pContext->wS3CipherSuiteServer))

#define MS24BOF(x)    ((UCHAR) ((x >> 16) & 0xFF) )

#define CHECK_PCT_RET_BREAK(Ret) if(PCT_ERR_OK != Ret)  \
                                 {                      \
                                     LOG_RESULT(Ret);   \
                                     break;             \
                                 }

typedef struct _OIDPROVMAP
{
    LPSTR   szOid;
    DWORD   dwExchSpec;
    DWORD   dwCertType;         // used for SSL 3.0 client auth
}  OIDPROVMAP, *POIDPROVMAP;

extern OIDPROVMAP g_CertTypes[];
extern DWORD g_cCertTypes;


typedef struct _shsh  //Structure hand shake header
{
    UCHAR   typHS;
    UCHAR   bcb24;
    UCHAR   bcbMSB;
    UCHAR   bcbLSB;
} SHSH;


typedef struct _swrap
{
    UCHAR  bCType;
    UCHAR  bMajor;
    UCHAR  bMinor;
    UCHAR  bcbMSBSize;
    UCHAR  bcbLSBSize;
//  UCHAR  rgb[];
} SWRAP;

typedef struct _ssh
{
    SHSH;
    UCHAR   bMajor;
    UCHAR   bMinor;
    UCHAR   rgbRandom[CB_SSL3_RANDOM];
    UCHAR   cbSessionId;
    UCHAR   rgbSessionId[CB_SSL3_SESSION_ID];
    UCHAR   wCipherSelectedMSB;
    UCHAR   wCipherSelectedLSB;
    UCHAR   bCMSelected;
} SSH;


typedef struct _alrt
{
    SWRAP;
    UCHAR bAlertLevel;
    UCHAR bAlertDesc;
} ALRT;


typedef struct _fm
{
    UCHAR   rgbMD5[CB_MD5_DIGEST_LEN];
    UCHAR   rgbSHA[CB_SHA_DIGEST_LEN];
} FM; //finished message

typedef struct _fmwire
{
    SWRAP;
    SHSH;
    FM;
} FMWIRE;

typedef struct _cert
{
    SHSH;
    UCHAR bcbClist24;
    UCHAR bcbMSBClist;
    UCHAR bcbLSBClist;
    UCHAR bcbCert24;
    UCHAR bcbMSBCert;
    UCHAR bcbLSBCert;
    UCHAR rgbCert[];
    /* followed by the real cert */
} CERT;

typedef struct _shwire
{
    PUCHAR  pcbCipher;
    PUCHAR  pCiperSpec;
    PUCHAR  pcbCompM;
    PUCHAR  pCompM;
    PUCHAR  pcbCert;
    PUCHAR  pCert;
    PUCHAR  pHelloDone;
} SHWIRE ;


SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Ssl3GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext             pContext,
    PSPBuffer               pOutput);

SP_STATUS WINAPI
GenerateTls1ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    DWORD                   dwProtocol);


SP_STATUS
Ssl3PackClientHello(PSPContext pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);



SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                                   PUCHAR pSrvHello,
                                   DWORD cbMessage,
                                   PSPBuffer  pCommOutput);
SP_STATUS Ssl3HandleServerFinish(PSPContext pContext,
                                   PUCHAR pSrvHello );


SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

BOOL FVerifyFinishedMessage(PSPContext  pContext, PUCHAR pb, BOOL fClient);

SP_STATUS
ParseAlertMessage(
    PSPContext pContext,
    PUCHAR pSrvHello,
    DWORD cbMessage);

SP_STATUS
Ssl3SelectCipher    (
    PSPContext pContext,
    WORD       wCipher
);

SP_STATUS
Ssl3SelectCipherEx(
    PSPContext pContext,
    DWORD *pCipherSpecs,
    DWORD cCipherSpecs);

void BuildAlertMessage(PBYTE pb, UCHAR bAlertLevel, UCHAR bAlertDesc);

SP_STATUS
Ssl3BuildFinishMessage(
    PSPContext pContext,
    BYTE *pbMd5Digest,
    BYTE *pbSHADigest,
    BOOL fClient);

SP_STATUS
Tls1BuildFinishMessage(
    PSPContext  pContext,       // in
    PBYTE       pbVerifyData,   // out
    DWORD       cbVerifyData,   // in
    BOOL        fClient);       // in

SP_STATUS
SPSetWrap(PSPContext pContext, PUCHAR pb, UCHAR bCType, DWORD wT, BOOL fClient, DWORD *pcbMessage);
void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, DWORD dwSize);

SP_STATUS
UpdateHandshakeHash(
    PSPContext pContext,
    PUCHAR pb,
    DWORD dwcb,
    BOOL fInit);

SP_STATUS
SPBuildS3FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient);

SP_STATUS
VerifyCCSAndFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);

SP_STATUS
Ssl3ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA);     // out

SP_STATUS
Tls1ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA);     // out

void BuildCertificateMessage(PBYTE pb, PBYTE rgbCert, DWORD dwCert);

SP_STATUS
BuildCCSAndFinishMessage(
    PSPContext pContext,
    PSPBuffer pBuffer,
    BOOL fClient);

VOID ComputeServerExchangeHashes(
    PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal) ;       // out

DWORD Ssl3CiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender);

SP_STATUS
UnwrapSsl3Message(
    PSPContext pContext,
    PSPBuffer MsgInput);

void SetWrapNoEncrypt(PUCHAR pb, UCHAR bCType, DWORD wT);

SP_STATUS Ssl3HandleCCS(PSPContext pContext,
                   PUCHAR pb,
                   DWORD cbMessage);
SP_STATUS
VerifyFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);

BOOL Ssl3ParseClientHello(
    PSPContext  pContext,
    PBYTE       pbMessage,
    DWORD       cbMessage,
    BOOL        fAttemptRestart,
    BOOL *      pfRestart);

SP_STATUS
SPBuildTlsAlertMessage(
    PSPContext  pContext,
    PSPBuffer   pCommOutput);

void
SetTls1Alert(
    PSPContext  pContext,
    BYTE        bAlertLevel,
    BYTE        bAlertNumber);

SP_STATUS
Ssl3CheckForExistingCred(PSPContext pContext);

#endif //__SSL3MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\sslcache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       sslcache.h
//
//  Contents:   Definitions of functions and data types that can be used 
//              to view and purge the schannel session cache.
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------


#ifndef __SSLCACHE_H__
#define __SSLCACHE_H__

//
//  SCHANNEL LsaCallAuthenticationPackage() submission and response
//  message types.
//

#define SSL_PURGE_CLIENT_ENTRIES                    0x00000001
#define SSL_PURGE_SERVER_ENTRIES                    0x00000002
#define SSL_PURGE_CLIENT_ALL_ENTRIES                0x00010000  // test use only
#define SSL_PURGE_SERVER_ALL_ENTRIES                0x00020000  // test use only
#define SSL_PURGE_SERVER_ENTRIES_DISCARD_LOCATORS   0x00040000  // test use only

#define SSL_RETRIEVE_CLIENT_ENTRIES                 0x00000001
#define SSL_RETRIEVE_SERVER_ENTRIES                 0x00000002

typedef struct _UNICODE_STRING_WOW64 
{
    USHORT Length;
    USHORT MaximumLength;
    DWORD  Buffer;
} UNICODE_STRING_WOW64;

// Used to purge entries from the session cache
typedef struct _SSL_PURGE_SESSION_CACHE_REQUEST 
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING ServerName;
    DWORD Flags;
} SSL_PURGE_SESSION_CACHE_REQUEST, *PSSL_PURGE_SESSION_CACHE_REQUEST;

typedef struct _SSL_PURGE_SESSION_CACHE_REQUEST_WOW64 
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING_WOW64 ServerName;
    DWORD Flags;
} SSL_PURGE_SESSION_CACHE_REQUEST_WOW64, *PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64;


// Used to request session cache info
typedef struct _SSL_SESSION_CACHE_INFO_REQUEST
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING ServerName;
    DWORD Flags;
} SSL_SESSION_CACHE_INFO_REQUEST, *PSSL_SESSION_CACHE_INFO_REQUEST;

typedef struct _SSL_SESSION_CACHE_INFO_REQUEST_WOW64
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING_WOW64 ServerName;
    DWORD Flags;
} SSL_SESSION_CACHE_INFO_REQUEST_WOW64, *PSSL_SESSION_CACHE_INFO_REQUEST_WOW64;

// Used to respond to session cache info request
typedef struct _SSL_SESSION_CACHE_INFO_RESPONSE
{
    DWORD   CacheSize;
    DWORD   Entries;
    DWORD   ActiveEntries;
    DWORD   Zombies;
    DWORD   ExpiredZombies;
    DWORD   AbortedZombies;
    DWORD   DeletedZombies;
} SSL_SESSION_CACHE_INFO_RESPONSE, *PSSL_SESSION_CACHE_INFO_RESPONSE;


// Used to request information for perfmon
typedef struct _SSL_PERFMON_INFO_REQUEST
{
    ULONG MessageType;
    DWORD Flags;
} SSL_PERFMON_INFO_REQUEST, *PSSL_PERFMON_INFO_REQUEST;

// Used to respond to perfmon info request
typedef struct _SSL_PERFMON_INFO_RESPONSE
{
    DWORD   ClientCacheEntries;
    DWORD   ServerCacheEntries;
    DWORD   ClientActiveEntries;
    DWORD   ServerActiveEntries;
    DWORD   ClientHandshakesPerSecond;
    DWORD   ServerHandshakesPerSecond;
    DWORD   ClientReconnectsPerSecond;
    DWORD   ServerReconnectsPerSecond;
} SSL_PERFMON_INFO_RESPONSE, *PSSL_PERFMON_INFO_RESPONSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\sslprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sslprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let schannel compile at warning level 4

Author:

    John Banes (jbanes)  05-Jun-2001

--*/


// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

//#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

//#pragma warning (disable: 4232)

// Cast truncates constant value

//#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

//#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

//#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

//#pragma warning (disable: 4328)

// Removal of unused inline functions

//#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\sslwow64.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       sslwow64.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-25-2000   jbanes   Created.
//
//----------------------------------------------------------------------------

typedef DWORD   SSLWOW64_PVOID;
typedef DWORD   SSLWOW64_PDWORD;
typedef DWORD   SSLWOW64_PCCERT_CONTEXT;
typedef DWORD   SSLWOW64_HCERTSTORE;
typedef DWORD   SSLWOW64_HCRYPTPROV;

typedef struct _SSLWOW64_SCHANNEL3_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paCred;
    SSLWOW64_HCERTSTORE hRootStore;

    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;

    DWORD               cSupportedAlgs;
    SSLWOW64_PDWORD     palgSupportedAlgs;

    DWORD               grbitEnabledProtocols;
    DWORD               dwMinimumCipherStrength;
    DWORD               dwMaximumCipherStrength;
    DWORD               dwSessionLifespan;
} SSLWOW64_SCHANNEL3_CRED;

typedef struct _SSLWOW64_SCHANNEL_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paCred;
    SSLWOW64_HCERTSTORE hRootStore;

    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;

    DWORD               cSupportedAlgs;
    SSLWOW64_PDWORD     palgSupportedAlgs;

    DWORD               grbitEnabledProtocols;
    DWORD               dwMinimumCipherStrength;
    DWORD               dwMaximumCipherStrength;
    DWORD               dwSessionLifespan;
    DWORD               dwFlags;
    DWORD               reserved;
} SSLWOW64_SCHANNEL_CRED;


typedef struct _SSLWOW64_SCH_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paSecret;
    SSLWOW64_PVOID      paPublic;
    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;
} SSLWOW64_SCH_CRED;

typedef struct _SSLWOW64_SCH_CRED_SECRET_PRIVKEY
{
    DWORD               dwType;
    SSLWOW64_PVOID      pPrivateKey;
    DWORD               cbPrivateKey;
    SSLWOW64_PVOID      pszPassword;
} SSLWOW64_SCH_CRED_SECRET_PRIVKEY;

typedef struct _SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD               dwType;
    DWORD               cbCertChain;
    SSLWOW64_PVOID      pCertChain;
} SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN;

typedef struct _SSLWOW64_CREDENTIAL_CERTIFICATE 
{
    DWORD               cbPrivateKey;
    SSLWOW64_PVOID      pPrivateKey;
    DWORD               cbCertificate;
    SSLWOW64_PVOID      pCertificate;
    SSLWOW64_PVOID      pszPassword;
} SSLWOW64_CREDENTIAL_CERTIFICATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\tls1key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner    :ramas
*   Date         :5/03/97
*   description        : Main Crypto functions for TLS1
*----------------------------------------------------------------------------*/
#ifndef _TLS1KEY_H_
#define _TLS1KEY_H_


SP_STATUS
SPBuildTls1FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient);

SP_STATUS
Tls1ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac);

SP_STATUS
Tls1MakeWriteSessionKeys(PSPContext pContext);

SP_STATUS
Tls1MakeReadSessionKeys(PSPContext pContext);

#define TLS1_LABEL_SERVER_WRITE_KEY     "server write key"
#define TLS1_LABEL_CLIENT_WRITE_KEY     "client write key"
#define CB_TLS1_WRITEKEY                16
#define TLS1_LABEL_MASTERSECRET         "master secret"
#define CB_TLS1_MASTERSECRET            13
#define TLS1_LABEL_KEYEXPANSION         "key expansion"
#define CB_TLS1_KEYEXPANSION            13 
#define TLS1_LABEL_IVBLOCK              "IV block"
#define CB_TLS1_IVBLOCK                 8
#define TLS1_LABEL_CLIENTFINISHED       "client finished"
#define TLS1_LABEL_SERVERFINISHED       "server finished"
#define CB_TLS1_LABEL_FINISHED          15
#define CB_TLS1_VERIFYDATA              12

#define TLS1_LABEL_EAP_KEYS             "client EAP encryption"
#define CB_TLS1_LABEL_EAP_KEYS          21

#define CBMD5DIGEST    16
#define CBSHADIGEST    20
#define CBBLOCKSIZE    64   //same for MD5 and SHA
#define CHIPAD         0x36
#define CHOPAD         0x5c

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    );

#endif //_TLS1KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\inc\_ssl3cli.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       _ssl3cli.h
//
//  Contents:   SSL3 function prototypes.
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------


SP_STATUS
SPVerifyFinishMsgCli(
    PSPContext pContext, 
    PBYTE       pbMsg, 
    BOOL        fClient
    );

void Ssl3StateConnected(PSPContext pContext);

SP_STATUS
BuildCertVerify(
    PSPContext      pContext,
    PBYTE           pb,
    DWORD *         pdwcbCertVerify
);

SP_STATUS SPProcessMessage
(
PSPContext  pContext,
BYTE bContentType,
PBYTE pbMsg,
DWORD cbMsg
);

SP_STATUS 
FormatIssuerList(
    PBYTE       pbInput,
    DWORD       cbInput,
    PBYTE       pbIssuerList,
    DWORD *     pcbIssuerList);

SP_STATUS SPGenerateResponse(
PSPContext pContext, 
PSPBuffer pCommOutput
);

DWORD  CbLenOfEncode(DWORD dw, PBYTE pbDst);

SP_STATUS SPGenerateSHResponse(PSPContext  pContext, PSPBuffer pOut);

SP_STATUS SPProcessHandshake(PSPContext pContext, PBYTE pb, DWORD cb);

SP_STATUS SPDigestSrvKeyX
(
PSPContext  pContext, 
PUCHAR pb, 
DWORD dwSrvHello
);

#define PbSessionid(pssh)  (((BYTE *)&pssh->cbSessionId) + 1)

SP_STATUS
ParseCertificateRequest
(
    PSPContext  pContext,
    PBYTE       pb,
    DWORD       dwcb
);


BOOL FNoInputState(DWORD dwState);

SP_STATUS
Ssl3SrvHandleUniHello(PSPContext  pContext,
                        PBYTE pb,
                        DWORD cbMsg
                        );

SP_STATUS
Ssl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);

SP_STATUS
ParseKeyExchgMsg(PSPContext  pContext, PBYTE pb);

BOOL Ssl3ParseCertificateVerify(PSPContext  pContext, PBYTE pbMessage, INT iMessageLen);

SP_STATUS
SPBuildHelloRequest
(
PSPContext  pContext,
PSPBuffer  pCommOutput
);

SP_STATUS
SPSsl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);

SP_STATUS
SPSsl3SrvGenRestart(
    PSPContext          pContext,
    PSPBuffer           pCommOutput);

void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb);

void 
BuildServerHelloDone(PBYTE pb);

SP_STATUS Ssl3BuildServerKeyExchange(
    PSPContext  pContext,
    PBYTE pbMessage,            // out
    PINT  piMessageLen) ;       // out

SP_STATUS
Ssl3BuildCertificateRequest(
    PBYTE pbIssuerList,         // in
    DWORD cbIssuerList,         // in
    PBYTE pbMessage,            // out
    DWORD *pdwMessageLen);      // out

SP_STATUS
SPSsl3SrvHandleClientHello(
    PSPContext pContext,
    PBYTE pb,
    BOOL fAttemptReconnect);

SP_STATUS
SPBuildCCSAndFinish
(
PSPContext  pContext,
PSPBuffer  pCommOutput
);

#define F_RESPONSE(State) (State > SSL3_STATE_GEN_START && State < SSL3_STATE_GEN_END)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\ctxtattr.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ctxtattr.c
//
//  Contents:   QueryContextAttribute and related functions.
//
//  Classes:
//
//  Functions:
//
//  History:    09-30-97   jbanes   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <pct1msg.h>
#include <tls1key.h>
#include <mapper.h>
#include <lsasecpk.h>

typedef struct {
    DWORD dwProtoId;
    LPCTSTR szProto;
    DWORD dwMajor;
    DWORD dwMinor;
} PROTO_ID;

const PROTO_ID rgProts[] = {
    { SP_PROT_SSL2_CLIENT, TEXT("SSL"), 2, 0 },
    { SP_PROT_SSL2_SERVER, TEXT("SSL"), 2, 0 },
    { SP_PROT_PCT1_CLIENT, TEXT("PCT"), 1, 0 },
    { SP_PROT_PCT1_SERVER, TEXT("PCT"), 1, 0 },
    { SP_PROT_SSL3_CLIENT, TEXT("SSL"), 3, 0 },
    { SP_PROT_SSL3_SERVER, TEXT("SSL"), 3, 0 },
    { SP_PROT_TLS1_CLIENT, TEXT("TLS"), 1, 0 },
    { SP_PROT_TLS1_SERVER, TEXT("TLS"), 1, 0 }
};

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryAccessToken
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ACCESS_TOKEN context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_AccessToken
//              {
//                  void SEC_FAR * AccessToken;
//              } SecPkgContext_AccessToken, SEC_FAR * PSecPkgContext_AccessToken;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryAccessToken(
    PSPContext pContext,
    PSecPkgContext_AccessToken pAccessToken)
{
    PSessCacheItem pZombie;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ACCESS_TOKEN)\n"));

    pZombie  = pContext->RipeZombie;

    if(pZombie == NULL || 
       pZombie->hLocator == 0)
    {
        if(pZombie->LocatorStatus)
        {
            return(SP_LOG_RESULT(pZombie->LocatorStatus));
        }
        else
        {
            return(SP_LOG_RESULT(SEC_E_NO_IMPERSONATION));
        }
    }

    pAccessToken->AccessToken = (VOID *)pZombie->hLocator;

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryAuthority
//
//  Synopsis:   Retrieves the SECPKG_ATTR_AUTHORITY context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_AuthorityW
//              {
//                  SEC_WCHAR SEC_FAR * sAuthorityName;
//              } SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryAuthority(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_Authority Authority;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    CERT_CONTEXT *  pCert;
    DWORD           cchIssuer;
    DWORD           cbIssuer;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_AUTHORITY)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_Authority );

    //
    // Obtain data from Schannel.
    //

    pCert = pContext->RipeZombie->pRemoteCert;
    if(NULL == pCert)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(pCert->pCertInfo->Issuer.cbData == 0 ||
       pCert->pCertInfo->Issuer.pbData == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(0 >= (cchIssuer = CertNameToStr(pCert->dwCertEncodingType,
                                       &pCert->pCertInfo->Issuer,
                                       CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                       NULL,
                                       0)))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    cbIssuer = (cchIssuer + 1) * sizeof(TCHAR);

    Authority.sAuthorityName = SPExternalAlloc(cbIssuer);
    if(Authority.sAuthorityName == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    if(0 >= CertNameToStr(pCert->dwCertEncodingType,
                          &pCert->pCertInfo->Issuer,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          Authority.sAuthorityName,
                          cchIssuer))
    {
        SPExternalFree(Authority.sAuthorityName);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }


    //
    // Copy buffers to client memory.
    //

    Status = LsaTable->AllocateClientBuffer(
                            NULL,
                            cbIssuer,
                            &pvClient);
    if(FAILED(Status))
    {
        SPExternalFree(Authority.sAuthorityName);
        return SP_LOG_RESULT(Status);
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbIssuer,
                            pvClient,
                            Authority.sAuthorityName);
    if(FAILED(Status))
    {
        SPExternalFree(Authority.sAuthorityName);
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    SPExternalFree(Authority.sAuthorityName);

    Authority.sAuthorityName = pvClient;


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &Authority );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryConnectionInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_CONNECTION_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_ConnectionInfo
//              {
//                  DWORD    dwProtocol;
//                  ALG_ID   aiCipher;
//                  DWORD    dwCipherStrength;
//                  ALG_ID   aiHash;
//                  DWORD    dwHashStrength;
//                  ALG_ID   aiExch;
//                  DWORD    dwExchStrength;
//              } SecPkgContext_ConnectionInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryConnectionInfo(
    PSPContext pContext,
    SecPkgContext_ConnectionInfo *pConnectionInfo)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_CONNECTION_INFO)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo   ||
        NULL == pContext->pKeyExchInfo)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    ZeroMemory(pConnectionInfo, sizeof(SecPkgContext_ConnectionInfo));

    pConnectionInfo->dwProtocol       = pContext->RipeZombie->fProtocol;
    if(pContext->pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        pConnectionInfo->aiCipher         = pContext->pCipherInfo->aiCipher;
        pConnectionInfo->dwCipherStrength = pContext->pCipherInfo->dwStrength;
    }
    pConnectionInfo->aiHash           = pContext->pHashInfo->aiHash;
    pConnectionInfo->dwHashStrength   = pContext->pHashInfo->cbCheckSum * 8;
    pConnectionInfo->aiExch           = pContext->pKeyExchInfo->aiExch;
    pConnectionInfo->dwExchStrength   = pContext->RipeZombie->dwExchStrength;

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryIssuerList
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ISSUER_LIST context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_IssuerListInfo
//              {
//                  DWORD   cbIssuerList;
//                  PBYTE   pIssuerList;
//              } SecPkgContext_IssuerListInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryIssuerList(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_IssuerListInfo IssuerList;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ISSUER_LIST)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_IssuerListInfo );

    //
    // Obtain data from Schannel.
    //

    // The issuer list is returned in the SSL3 wire format, which
    // consists of a bunch of issuer names, each prepended
    // with a two byte size (in big endian). Additionally, the list
    // is also prepended with a two byte list size (also in big
    // endian).
    IssuerList.cbIssuerList = pContext->cbIssuerList;
    IssuerList.pIssuerList  = pContext->pbIssuerList;


    //
    // Copy buffers to client memory.
    //

    if(IssuerList.cbIssuerList && IssuerList.pIssuerList)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                IssuerList.cbIssuerList,
                                &pvClient);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                IssuerList.cbIssuerList,
                                pvClient,
                                IssuerList.pIssuerList);
        if(FAILED(Status))
        {
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        IssuerList.pIssuerList = pvClient;
    }


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &IssuerList );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryIssuerListEx
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ISSUER_LIST_EX context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_IssuerListInfoEx
//              {
//                  PCERT_NAME_BLOB   	aIssuers;
//                  DWORD           	cIssuers;
//              } SecPkgContext_IssuerListInfoEx;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryIssuerListEx(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_IssuerListInfoEx IssuerListEx;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;
    DWORD           cIssuers;

    PBYTE           pbIssuerList;
    DWORD           cbIssuerList;
    PBYTE           pbIssuer;
    DWORD           cbIssuer;
    PBYTE           pbClientIssuer;
    PCERT_NAME_BLOB paIssuerBlobs;
    DWORD           cbIssuerBlobs;
    DWORD           i;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ISSUER_LIST_EX)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_IssuerListInfoEx );

    //
    // Obtain data from Schannel.
    //

    IssuerListEx.cIssuers = 0;
    IssuerListEx.aIssuers = NULL;

    if(pContext->pbIssuerList && pContext->cbIssuerList > 2)
    {
        pbIssuerList = pContext->pbIssuerList + 2;
        cbIssuerList = pContext->cbIssuerList - 2;

        // Count issuers.
        cIssuers = 0;
        pbIssuer = pbIssuerList;
        while(pbIssuer + 1 < pbIssuerList + cbIssuerList)
        {
            cbIssuer = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);
            pbIssuer += 2 + cbIssuer;
            cIssuers++;
        }

        // Allocate memory for list of blobs.
        cbIssuerBlobs = cIssuers * sizeof(CERT_NAME_BLOB);
        paIssuerBlobs = SPExternalAlloc(cbIssuerBlobs);
        if(paIssuerBlobs == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Allocate memory for issuer list.
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                cbIssuerBlobs + cbIssuerList,
                                &pvClient);
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            return SP_LOG_RESULT(Status);
        }

        // Copy the raw issuer list into client memory.
        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbIssuerList,
                                (PBYTE)pvClient + cbIssuerBlobs,
                                pbIssuerList );
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        // Build the issuer blob list.
        pbIssuer       = pbIssuerList;
        pbClientIssuer = (PBYTE)pvClient + cbIssuerBlobs;

        for(i = 0; i < cIssuers; i++)
        {
            paIssuerBlobs[i].pbData = pbClientIssuer + 2;
            paIssuerBlobs[i].cbData = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);

            pbIssuer       += 2 + paIssuerBlobs[i].cbData;
            pbClientIssuer += 2 + paIssuerBlobs[i].cbData;
        }

        // Copy the blob list into client memory.
        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbIssuerBlobs,
                                pvClient,
                                paIssuerBlobs );
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        SPExternalFree(paIssuerBlobs);

        IssuerListEx.cIssuers = cIssuers;
        IssuerListEx.aIssuers = pvClient;
    }


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &IssuerListEx );
    if(FAILED(Status))
    {
        if(pvClient) LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryKeyInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_KEY_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_KeyInfoW
//              {
//                  SEC_WCHAR SEC_FAR * sSignatureAlgorithmName;
//                  SEC_WCHAR SEC_FAR * sEncryptAlgorithmName;
//                  unsigned long       KeySize;
//                  unsigned long       SignatureAlgorithm;
//                  unsigned long       EncryptAlgorithm;
//              } SecPkgContext_KeyInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryKeyInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_KeyInfo *pKeyInfo;
    DWORD cchSigName;
    DWORD cbSigName;
    DWORD cchCipherName;
    DWORD cbCipherName;

    UNICODE_STRING UniString;
    ANSI_STRING AnsiString;

    NTSTATUS Status;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_KEY_INFO)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo   ||
        NULL == pContext->pKeyExchInfo)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    if (NULL == pContext->pCipherInfo->szName)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }


    pKeyInfo = (SecPkgContext_KeyInfo *)Buffer;

    ZeroMemory(pKeyInfo, sizeof(*pKeyInfo));

    pKeyInfo->KeySize            = pContext->pCipherInfo->dwStrength;
    pKeyInfo->EncryptAlgorithm   = pContext->pCipherInfo->aiCipher;
    pKeyInfo->SignatureAlgorithm = 0;


    cchSigName = lstrlenA(pContext->pKeyExchInfo->szName);
    cbSigName  = (cchSigName + 1) * sizeof(WCHAR);
    pKeyInfo->sSignatureAlgorithmName = LocalAlloc(LPTR, cbSigName);
    if(pKeyInfo->sSignatureAlgorithmName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto done;
    }

    RtlInitAnsiString(&AnsiString,
                      pContext->pKeyExchInfo->szName);

    UniString.Length = 0;
    UniString.MaximumLength = (USHORT)cbSigName;
    UniString.Buffer = pKeyInfo->sSignatureAlgorithmName;

    RtlAnsiStringToUnicodeString(&UniString,
                                 &AnsiString,
                                 FALSE);
    

    cchCipherName = lstrlenA(pContext->pCipherInfo->szName);
    cbCipherName  = (cchCipherName + 1) * sizeof(WCHAR);
    pKeyInfo->sEncryptAlgorithmName = LocalAlloc(LPTR, cbCipherName);
    if(pKeyInfo->sEncryptAlgorithmName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto done;
    }

    RtlInitAnsiString(&AnsiString,
                      pContext->pCipherInfo->szName);

    UniString.Length = 0;
    UniString.MaximumLength = (USHORT)cbCipherName;
    UniString.Buffer = pKeyInfo->sEncryptAlgorithmName;

    RtlAnsiStringToUnicodeString(&UniString,
                                 &AnsiString,
                                 FALSE);

    Status = PCT_ERR_OK;

done:

    if(Status != PCT_ERR_OK)
    {
        if(pKeyInfo->sSignatureAlgorithmName)
        {
            LocalFree(pKeyInfo->sSignatureAlgorithmName);
            pKeyInfo->sSignatureAlgorithmName = NULL;
        }
        if(pKeyInfo->sEncryptAlgorithmName)
        {
            LocalFree(pKeyInfo->sEncryptAlgorithmName);
            pKeyInfo->sEncryptAlgorithmName = NULL;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLifespan
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LIFESPAN context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_Lifespan
//              {
//                  TimeStamp tsStart;
//                  TimeStamp tsExpiry;
//              } SecPkgContext_Lifespan;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLifespan(
    PSPContext pContext,
    SecPkgContext_Lifespan *pLifespan)
{
    PCCERT_CONTEXT pCertContext;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LIFESPAN)\n"));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        Status = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(Status != PCT_ERR_OK)
        {
            SP_LOG_RESULT(Status);
            return SEC_E_INSUFFICIENT_MEMORY;
        }

        pLifespan->tsStart.QuadPart  = *((LONGLONG *)&pCertContext->pCertInfo->NotBefore);
        pLifespan->tsExpiry.QuadPart = *((LONGLONG *)&pCertContext->pCertInfo->NotAfter);

        CertFreeCertificateContext(pCertContext);
    }
    else
    {
        pLifespan->tsStart.QuadPart  = 0;
        pLifespan->tsExpiry.QuadPart = MAXTIMEQUADPART;
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLocalCertContext
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LOCAL_CERT_CONTEXT 
//              context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains a pointer to a CERT_CONTEXT
//              structure.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLocalCertContext(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;

    PCCERT_CONTEXT  pCertContext = NULL;
    SecBuffer       Input;
    SecBuffer       Output;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LOCAL_CERT_CONTEXT)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( PCCERT_CONTEXT );

    //
    // Obtain data from Schannel.
    //

    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        pCertContext = pContext->RipeZombie->pClientCert;
    }
    else
    {
        pCertContext = pContext->RipeZombie->pActiveServerCred->pCert;
    }


    //
    // Copy buffers to client memory.
    //

    if(pCertContext)
    {
        // Serialize the certificate context, as well as the associated
        // certificate store.
        Status = SerializeCertContext(pCertContext,
                                      NULL,
                                      &Input.cbBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }
        SafeAllocaAllocate(Input.pvBuffer, Input.cbBuffer);
        if(Input.pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        Status = SerializeCertContext(pCertContext,
                                      Input.pvBuffer,
                                      &Input.cbBuffer);
        if(FAILED(Status))
        {
            SafeAllocaFree(Input.pvBuffer);
            return SP_LOG_RESULT(Status);
        }

        // Call back into the user process in order to replicate the
        // certificate context and store over there.
        Input.BufferType = SECBUFFER_DATA;

        Status = PerformApplicationCallback(SCH_DOWNLOAD_CERT_CALLBACK,
                                            0,
                                            0,
                                            &Input,
                                            &Output,
                                            TRUE);
        SafeAllocaFree(Input.pvBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        pCertContext = *(PCCERT_CONTEXT *)(Output.pvBuffer);
        SPExternalFree(Output.pvBuffer);
    }

    //
    // Copy structure back to client memory.
    //

    if(pCertContext)
    {
        Status = LsaTable->CopyToClientBuffer( NULL,
                                               Size,
                                               Buffer,
                                               (PVOID)&pCertContext );
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryRemoteCertContext
//
//  Synopsis:   Retrieves the SECPKG_ATTR_REMOTE_CERT_CONTEXT 
//              context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains a pointer to a CERT_CONTEXT
//              structure.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryRemoteCertContext(
    PSPContext pContext,
    PVOID Buffer)
{
    PCCERT_CONTEXT pCertContext;
    SP_STATUS pctRet;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_REMOTE_CERT_CONTEXT)\n"));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        pctRet = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
        
        *(PCCERT_CONTEXT *)Buffer = pCertContext;

        return SEC_E_OK;
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLocalCred
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LOCAL_CRED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_LocalCredentialInfo
//              {
//                  DWORD   cbCertificateChain;
//                  PBYTE   pbCertificateChain;
//                  DWORD   cCertificates;
//                  DWORD   fFlags;
//                  DWORD   dwBits;
//              } SecPkgContext_LocalCredentialInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLocalCred(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_LocalCredentialInfo CredInfo;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    PCCERT_CONTEXT  pCert = NULL;
    PUBLICKEY *     pKey  = NULL;
    RSAPUBKEY *     pk = NULL;
    PSPCredential   pCred;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LOCAL_CRED)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_LocalCredentialInfo );

    //
    // Obtain data from Schannel.
    //

    ZeroMemory(&CredInfo, Size);

    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        pCred = pContext->pActiveClientCred;
    }
    else
    {
        pCred = pContext->RipeZombie->pActiveServerCred;
    }
    if(pCred)
    {
        pCert = pCred->pCert;
        pKey  = pCred->pPublicKey;
    }

    if(pCert)
    {
        CredInfo.fFlags |= LCRED_CRED_EXISTS;

        CredInfo.pbCertificateChain = pCert->pbCertEncoded;
        CredInfo.cbCertificateChain = pCert->cbCertEncoded;
        CredInfo.cCertificates = 1;

        // Compute number of bits in the certificate's public key.
        CredInfo.dwBits = 0;
        pk = (RSAPUBKEY *)((pKey->pPublic) + 1);
        if(pk)
        {
            CredInfo.dwBits = pk->bitlen;
        }
    }

    //
    // Copy buffers to client memory.
    //

    if(CredInfo.pbCertificateChain)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                CredInfo.cbCertificateChain,
                                &pvClient);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                CredInfo.cbCertificateChain,
                                pvClient,
                                CredInfo.pbCertificateChain);
        if(FAILED(Status))
        {
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        CredInfo.pbCertificateChain = pvClient;
    }

    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &CredInfo );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryRemoteCred
//
//  Synopsis:   Retrieves the SECPKG_ATTR_REMOTE_CRED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_LocalCredentialInfo
//              {
//                  DWORD   cbCertificateChain;
//                  PBYTE   pbCertificateChain;
//                  DWORD   cCertificates;
//                  DWORD   fFlags;
//                  DWORD   dwBits;
//              } SecPkgContext_LocalCredentialInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryRemoteCred(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_LocalCredentialInfo *pCredInfo;
    PCCERT_CONTEXT  pCertContext = NULL;
    PUBLICKEY *     pKey  = NULL;
    RSAPUBKEY *     pk    = NULL;
    SP_STATUS       pctRet;
    PBYTE           pbCert;
    
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_REMOTE_CRED)\n"));

    pCredInfo = (SecPkgContext_LocalCredentialInfo *)Buffer;

    ZeroMemory(pCredInfo, sizeof(*pCredInfo));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        pctRet = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    if(pCertContext)
    {
        pbCert = LocalAlloc(LPTR, pCertContext->cbCertEncoded);
        if(pbCert == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        memcpy(pbCert, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);

        pCredInfo->fFlags |= LCRED_CRED_EXISTS;

        pCredInfo->pbCertificateChain = pbCert;
        pCredInfo->cbCertificateChain = pCertContext->cbCertEncoded;
        pCredInfo->cCertificates = 1;
        pCredInfo->dwBits = 0;

        // Compute number of bits in the certificate's public key.
        pctRet = SPPublicKeyFromCert(pCertContext, &pKey, NULL);
        if(pctRet == PCT_ERR_OK)
        {
            pk = (RSAPUBKEY *)((pKey->pPublic) + 1);
            if(pk)
            {
                pCredInfo->dwBits = pk->bitlen;
            }

            SPExternalFree(pKey);
        }

        CertFreeCertificateContext(pCertContext);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryNames
//
//  Synopsis:   Retrieves the SECPKG_ATTR_NAMES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_NamesW
//              {
//                  SEC_WCHAR SEC_FAR * sUserName;
//              } SecPkgContext_NamesW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryNames(
    PSPContext pContext,
    SecPkgContext_Names *pNames)
{
    SECURITY_STATUS Status;
    PCCERT_CONTEXT  pCert = NULL;
    DWORD           cchSubject;
    DWORD           cbSubject;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_NAMES)\n"));

    //
    // Obtain data from Schannel.
    //

    if(pContext->RipeZombie->pbServerCertificate == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    Status = DeserializeCertContext(&pCert,
                                    pContext->RipeZombie->pbServerCertificate,
                                    pContext->RipeZombie->cbServerCertificate);
    if(Status != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(Status);
    }
        
    //
    // Build name string.
    //

    if(0 >= (cchSubject = CertNameToStr(pCert->dwCertEncodingType,
                                       &pCert->pCertInfo->Subject,
                                       CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                       NULL,
                                       0)))
    {
        CertFreeCertificateContext(pCert);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    cbSubject = (cchSubject + 1) * sizeof(TCHAR);

    pNames->sUserName = LocalAlloc(LPTR, cbSubject);
    if(pNames->sUserName == NULL)
    {
        CertFreeCertificateContext(pCert);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    if(0 >= CertNameToStr(pCert->dwCertEncodingType,
                          &pCert->pCertInfo->Subject,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          pNames->sUserName,
                          cchSubject))
    {
        CertFreeCertificateContext(pCert);
        LocalFree(pNames->sUserName);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    CertFreeCertificateContext(pCert);

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryPackageInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_PACKAGE_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_PackageInfoW
//              {
//                  PSecPkgInfoW PackageInfo;
//              } SecPkgContext_PackageInfoW, SEC_FAR * PSecPkgContext_PackageInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryPackageInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    PSecPkgContext_PackageInfoW pPackageInfo;
    SecPkgInfoW Info;
    DWORD cbName;
    DWORD cbComment;

    UNREFERENCED_PARAMETER(pContext);

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_PACKAGE_INFO)\n"));

    SpSslGetInfo(&Info);

    pPackageInfo = (PSecPkgContext_PackageInfoW)Buffer;

    cbName    = (lstrlen(Info.Name) + 1) * sizeof(WCHAR);
    cbComment = (lstrlen(Info.Comment) + 1) * sizeof(WCHAR);

    pPackageInfo->PackageInfo = LocalAlloc(LPTR, sizeof(SecPkgInfo) + cbName + cbComment);

    if(pPackageInfo->PackageInfo == NULL)
    {
        return SP_LOG_RESULT(STATUS_INSUFFICIENT_RESOURCES);
    }

    pPackageInfo->PackageInfo->wVersion      = Info.wVersion;
    pPackageInfo->PackageInfo->wRPCID        = Info.wRPCID;
    pPackageInfo->PackageInfo->fCapabilities = Info.fCapabilities;
    pPackageInfo->PackageInfo->cbMaxToken    = Info.cbMaxToken;

    pPackageInfo->PackageInfo->Name    = (LPWSTR)(pPackageInfo->PackageInfo + 1);
    pPackageInfo->PackageInfo->Comment = (LPWSTR)((PBYTE)pPackageInfo->PackageInfo->Name + cbName);

    lstrcpy(
        pPackageInfo->PackageInfo->Name,
        Info.Name);

    lstrcpy(
        pPackageInfo->PackageInfo->Comment,
        Info.Comment);

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryProtoInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_PROTO_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_ProtoInfoW
//              {
//                  SEC_WCHAR SEC_FAR * sProtocolName;
//                  unsigned long       majorVersion;
//                  unsigned long       minorVersion;
//              } SecPkgContext_ProtoInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryProtoInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_ProtoInfo *pProtoInfo;
    DWORD           index;
    DWORD           cbName;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_PROTO_INFO)\n"));

    pProtoInfo = (SecPkgContext_ProtoInfo *)Buffer;

    for(index = 0;
        index < sizeof(rgProts) / sizeof(PROTO_ID);
        index += 1)
    {
        if(pContext->RipeZombie->fProtocol == rgProts[index].dwProtoId)
        {
            break;
        }
    }
    if(index >= sizeof(rgProts) / sizeof(PROTO_ID))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    cbName = (lstrlen(rgProts[index].szProto) + 1) * sizeof(WCHAR);

    pProtoInfo->sProtocolName = LocalAlloc(LPTR, cbName);
    if(pProtoInfo->sProtocolName == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    lstrcpy(pProtoInfo->sProtocolName, rgProts[index].szProto);

    pProtoInfo->majorVersion  = rgProts[index].dwMajor;
    pProtoInfo->minorVersion  = rgProts[index].dwMinor;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQuerySizes
//
//  Synopsis:   Retrieves the SECPKG_ATTR_SIZES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_Sizes
//              {
//                  unsigned long cbMaxToken;
//                  unsigned long cbMaxSignature;
//                  unsigned long cbBlockSize;
//                  unsigned long cbSecurityTrailer;
//              } SecPkgContext_Sizes;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQuerySizes(
    PSPContext pContext,
    SecPkgContext_Sizes *pSizes)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_SIZES)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
            pSizes->cbMaxToken = SSL2_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 2 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += 1 + pContext->pCipherInfo->dwBlockSize; // 3 byte header
            }
            break;

        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
            pSizes->cbMaxToken = PCT1_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 2 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += 1 + pContext->pCipherInfo->dwBlockSize; // 3 byte header
            }
            break;

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
            pSizes->cbMaxToken = SSL3_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 5 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        default:
            pSizes->cbMaxToken = SSL3_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 0;
   }

    pSizes->cbMaxSignature = pContext->pHashInfo->cbCheckSum;
    pSizes->cbBlockSize    = pContext->pCipherInfo->dwBlockSize;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryStreamSizes
//
//  Synopsis:   Retrieves the SECPKG_ATTR_STREAM_SIZES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_StreamSizes
//              {
//                  unsigned long   cbHeader;
//                  unsigned long   cbTrailer;
//                  unsigned long   cbMaximumMessage;
//                  unsigned long   cBuffers;
//                  unsigned long   cbBlockSize;
//              } SecPkgContext_StreamSizes;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryStreamSizes(
    PSPContext pContext,
    SecPkgContext_StreamSizes *pStreamSizes)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_STREAM_SIZES)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
            pStreamSizes->cbMaximumMessage = SSL2_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 2 + pContext->pHashInfo->cbCheckSum;
            pStreamSizes->cbTrailer = 0;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbHeader += 1; // 3 byte header
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
            pStreamSizes->cbMaximumMessage = PCT1_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 2;
            pStreamSizes->cbTrailer = pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbHeader += 1; // 3 byte header
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
            pStreamSizes->cbMaximumMessage = SSL3_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 5;
            pStreamSizes->cbTrailer = pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        default:
            pStreamSizes->cbMaximumMessage = SSL3_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 0;
            pStreamSizes->cbTrailer = 0;
    }

    pStreamSizes->cbBlockSize = pContext->pCipherInfo->dwBlockSize;

    pStreamSizes->cBuffers = 4;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryEapKeyBlock
//
//  Synopsis:   Retrieves the SECPKG_ATTR_EAP_KEY_BLOCK context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_EapKeyBlock
//              {
//                  BYTE    rgbKeys[128];
//                  BYTE    rgbIVs[64];
//              } SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryEapKeyBlock(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_EapKeyBlock KeyBlock;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;

    HCRYPTHASH hHash;
    CRYPT_DATA_BLOB Data;
    UCHAR rgbRandom[CB_SSL3_RANDOM + CB_SSL3_RANDOM];
    DWORD cbRandom;
    DWORD cbData;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_EAP_KEY_BLOCK)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_EapKeyBlock );

    //
    // Obtain data from Schannel.
    //

    if(!(pContext->RipeZombie->fProtocol & SP_PROT_TLS1))
    {
        // This attribute is defined for TLS only.
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(!pContext->RipeZombie->hMasterKey)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    // Build random buffer.
    CopyMemory(rgbRandom, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
    CopyMemory(rgbRandom + CB_SSL3_RANDOM, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
    cbRandom = CB_SSL3_RANDOM + CB_SSL3_RANDOM;

    // rgbKeys = PRF(master_secret, "client EAP encryption", client_random + server_random);

    // Compute the PRF
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        CALG_TLS1PRF,
                        pContext->RipeZombie->hMasterKey,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return SEC_E_INTERNAL_ERROR;
    }

    Data.pbData = (PBYTE)TLS1_LABEL_EAP_KEYS;
    Data.cbData = CB_TLS1_LABEL_EAP_KEYS;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_LABEL,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }

    Data.pbData = rgbRandom;
    Data.cbData = cbRandom;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_SEED,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }

    cbData = sizeof(KeyBlock.rgbKeys);
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          KeyBlock.rgbKeys,
                          &cbData,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }
    SP_ASSERT(cbData == sizeof(KeyBlock.rgbKeys));

    CryptDestroyHash(hHash);


    // IVs = PRF("", "client EAP encryption", client_random + server_random)

    if(!PRF(NULL, 0,
            (PBYTE)TLS1_LABEL_EAP_KEYS, CB_TLS1_LABEL_EAP_KEYS,
            rgbRandom, sizeof(rgbRandom),
            KeyBlock.rgbIVs, sizeof(KeyBlock.rgbIVs)))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &KeyBlock );
    if(FAILED(Status))
    {
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryApplicationData
//
//  Synopsis:   Retrieves the SECPKG_ATTR_APP_DATA context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_SessionAppData
//              {
//                  DWORD dwFlags;
//                  DWORD cbAppData;
//                  PBYTE pbAppData;
//              } SecPkgContext_SessionAppData, *PSecPkgContext_SessionAppData;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryApplicationData(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_SessionAppData AppData;
    PBYTE pbAppData = NULL;
    DWORD cbAppData = 0;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID pvClient = NULL;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_APP_DATA)\n"));

    pContext = (PSPContext)ContextHandle;

    if(pContext == NULL || pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    //
    // Get application data from cache.
    //

    Status = GetCacheAppData(pContext->RipeZombie, &pbAppData, &cbAppData);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    //
    // Allocate memory for application data in application process.
    //

    if(pbAppData != NULL)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                cbAppData,
                                &pvClient);
        if(FAILED(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbAppData,
                                pvClient,
                                pbAppData);
        if(FAILED(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }


    //
    // Build output structure.
    //

    ZeroMemory(&AppData, sizeof(AppData));

    AppData.cbAppData = cbAppData;
    AppData.pbAppData = pvClient;


    //
    // Copy output structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           sizeof(SecPkgContext_SessionAppData),
                                           Buffer,
                                           &AppData);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    // Operation has succeeded, so consume this buffer.
    pvClient = NULL;


cleanup:

    if(pvClient)
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
    }

    if(pbAppData)
    {
        SPExternalFree(pbAppData);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQuerySessionInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_SESSION_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_SessionInfo
//              {
//                  DWORD dwFlags;
//                  DWORD cbSessionId;
//                  BYTE  rgbSessionId[32];
//              } SecPkgContext_SessionInfo, *PSecPkgContext_SessionInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQuerySessionInfo(
    PSPContext pContext,
    SecPkgContext_SessionInfo *pSessionInfo)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_SESSION_INFO)\n"));

    if (NULL == pContext->RipeZombie)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    ZeroMemory(pSessionInfo, sizeof(SecPkgContext_SessionInfo));

    if(!(pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE))
    {
        pSessionInfo->dwFlags = SSL_SESSION_RECONNECT;
    }

    pSessionInfo->cbSessionId = pContext->RipeZombie->cbSessionID;

    memcpy(pSessionInfo->rgbSessionId, pContext->RipeZombie->SessionID, pContext->RipeZombie->cbSessionID);

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The following attributes are supported by the Schannel
//              package:
//
//                  SECPKG_ATTR_AUTHORITY
//                  SECPKG_ATTR_CONNECTION_INFO
//                  SECPKG_ATTR_ISSUER_LIST
//                  SECPKG_ATTR_ISSUER_LIST_EX
//                  SECPKG_ATTR_KEY_INFO
//                  SECPKG_ATTR_LIFESPAN
//                  SECPKG_ATTR_LOCAL_CERT_CONTEXT
//                  SECPKG_ATTR_LOCAL_CRED
//                  SECPKG_ATTR_NAMES
//                  SECPKG_ATTR_PROTO_INFO
//                  SECPKG_ATTR_REMOTE_CERT_CONTEXT
//                  SECPKG_ATTR_REMOTE_CRED
//                  SECPKG_ATTR_SIZES
//                  SECPKG_ATTR_STREAM_SIZES
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaQueryContextAttributes(
    LSA_SEC_HANDLE Context,
    ULONG Attribute,
    PVOID Buffer)
{
    SECURITY_STATUS Status;
    PSPContext      pContext;

    pContext = (PSPContext)Context;

    switch(Attribute)
    {
        case SECPKG_ATTR_AUTHORITY :
            Status = SpQueryAuthority(Context, Buffer);
            break;

        case SECPKG_ATTR_ISSUER_LIST :
            Status = SpQueryIssuerList(Context, Buffer);
            break;

        case SECPKG_ATTR_ISSUER_LIST_EX:
            Status = SpQueryIssuerListEx(Context, Buffer);
            break;

//        case SECPKG_ATTR_KEY_INFO :
//            Status = SpQueryKeyInfo(Context, Buffer);
//            break;

//        case SECPKG_ATTR_LIFESPAN :
//            Status = SpQueryLifespan(Context, Buffer);
//            break;

        case SECPKG_ATTR_LOCAL_CERT_CONTEXT:
            Status = SpQueryLocalCertContext(Context, Buffer);
            break;

        case SECPKG_ATTR_LOCAL_CRED:
            Status = SpQueryLocalCred(Context, Buffer);
            break;

//        case SECPKG_ATTR_NAMES :
//            Status = SpQueryNames(Context, Buffer);
//            break;

//        case SECPKG_ATTR_PROTO_INFO:
//            Status = SpQueryProtoInfo(Context, Buffer);
//            break;

//        case SECPKG_ATTR_REMOTE_CERT_CONTEXT:
//            Status = SpQueryCertContext(Context, Buffer, FALSE);
//            break;

//        case SECPKG_ATTR_REMOTE_CRED:
//            Status = SpQueryRemoteCred(Context, Buffer);
//            break;

//        case SECPKG_ATTR_SIZES:
//            Status = SpQuerySizes(Context, Buffer);
//            break;

//        case SECPKG_ATTR_STREAM_SIZES:
//            Status = SpQueryStreamSizes(Context, Buffer);
//            break;

        case SECPKG_ATTR_EAP_KEY_BLOCK:
            Status = SpQueryEapKeyBlock(Context, Buffer);
            break;

//        case SECPKG_ATTR_MAPPED_CRED_ATTR:
//            Status = SpQueryMappedCredAttr(Context, Buffer);
//            break;

        case SECPKG_ATTR_APP_DATA:
            Status = SpQueryApplicationData(Context, Buffer);
            break;

        default:
            DebugLog((DEB_ERROR, "QueryContextAttributes(unsupported function %d)\n", Attribute));

            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpUserQueryContextAttributes
//
//  Synopsis:   User mode QueryContextAttribute.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpUserQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PSSL_USER_CONTEXT Context;
    PSPContext pContext;
    SECURITY_STATUS Status;

    Context = SslFindUserContext( ContextHandle );

    if(Context == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    pContext = Context->pContext;
    if(!pContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    switch(ContextAttribute)
    {
        case SECPKG_ATTR_CONNECTION_INFO:
            Status = SpQueryConnectionInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_KEY_INFO:
            Status = SpQueryKeyInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_LIFESPAN:
            Status = SpQueryLifespan(pContext, pBuffer);
            break;

        case SECPKG_ATTR_NAMES :
            Status = SpQueryNames(pContext, pBuffer);
            break;

        case SECPKG_ATTR_PACKAGE_INFO:
            Status = SpQueryPackageInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_PROTO_INFO:
            Status = SpQueryProtoInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_REMOTE_CERT_CONTEXT:
            Status = SpQueryRemoteCertContext(pContext, pBuffer);
            break;

        case SECPKG_ATTR_REMOTE_CRED:
            Status = SpQueryRemoteCred(pContext, pBuffer);
            break;

        case SECPKG_ATTR_SIZES:
            Status = SpQuerySizes(pContext, pBuffer);
            break;

        case SECPKG_ATTR_STREAM_SIZES:
            Status = SpQueryStreamSizes(pContext, pBuffer);
            break;

        case SECPKG_ATTR_ACCESS_TOKEN:
            Status = SpQueryAccessToken(pContext, pBuffer);
            break;

        case SECPKG_ATTR_SESSION_INFO:
            Status = SpQuerySessionInfo(pContext, pBuffer);
            break;

        default:
            DebugLog((DEB_ERROR, "QueryContextAttributes(unsupported function %d)\n", ContextAttribute));

            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetUseValidatedProp
//
//  Synopsis:   Sets the SECPKG_ATTR_USE_VALIDATED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain a DWORD indicating whether the 
//              credential currently associated with the context has been
//              validated for use.
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetUseValidatedProp(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    DWORD dwUseValidated;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_USE_VALIDATED)\n"));

    if(BufferSize < sizeof(DWORD))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof(DWORD),
                                             &dwUseValidated,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Use validated:%d\n", dwUseValidated));
    
    if(pContext->RipeZombie == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if(dwUseValidated)
    {
        pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_USE_VALIDATED;
    }
    else
    {
        pContext->RipeZombie->dwFlags &= ~SP_CACHE_FLAG_USE_VALIDATED;
    }

cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetCredentialNameProp
//
//  Synopsis:   Sets the SECPKG_ATTR_CREDENTIAL_NAME context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain the following structure:
//
//              typedef struct _SecPkgContext_CredentialNameW
//               {
//                  unsigned long CredentialType;
//                   SEC_WCHAR SEC_FAR *sCredentialName;
//              } SecPkgContext_CredentialNameW, SEC_FAR * PSecPkgContext_CredentialNameW;
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetCredentialNameProp(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    PSecPkgContext_CredentialNameW pCredentialStruct = NULL;
    SEC_WCHAR *pClientCredName = NULL;
    SEC_WCHAR *pCredName = NULL;
    DWORD_PTR Offset;
    NTSTATUS Status;
    ULONG i;
    BOOL fTerminated = FALSE;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_CREDENTIAL_NAME)\n"));

    //
    // Marshal over the credential name from the client address space.
    //

    if(BufferSize < sizeof(SecPkgContext_CredentialNameW))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if(BufferSize > sizeof(SecPkgContext_CredentialNameW) + 
                    CRED_MAX_DOMAIN_TARGET_NAME_LENGTH * sizeof(WCHAR))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    pCredentialStruct = SPExternalAlloc(BufferSize + sizeof(WCHAR));

    if(pCredentialStruct == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             BufferSize,
                                             pCredentialStruct,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    if(pCredentialStruct->CredentialType != CRED_TYPE_DOMAIN_CERTIFICATE)
    {
        DebugLog((DEB_ERROR, "Unexpected credential type %d\n", pCredentialStruct->CredentialType));
        Status = SEC_E_UNKNOWN_CREDENTIALS;
        goto cleanup;
    }

    // Get pointer to credential name in the client's address space.
    pClientCredName = pCredentialStruct->sCredentialName;

    if(!POINTER_IS_ALIGNED(pClientCredName, sizeof(WCHAR)))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if((PBYTE)pClientCredName < (PBYTE)Buffer + sizeof(SecPkgContext_CredentialNameW) ||
       (PBYTE)pClientCredName >= (PBYTE)Buffer + BufferSize)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    // Compute offset of credential name within the input buffer.
    Offset = (PBYTE)pClientCredName - (PBYTE)Buffer;

    // Build pointer to credential name in the local process.
    pCredName = (SEC_WCHAR *)((PBYTE)pCredentialStruct + Offset);

    // Ensure that the credential name is zero terminated.
    for(i = 0; i < (BufferSize - Offset) / sizeof(WCHAR); i++)
    {
        if(pCredName[i] == L'\0')
        {
            fTerminated = TRUE;
            break;
        }
    }
    if(!fTerminated)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Set client credential to '%ls'.\n", pCredName));


    //
    // Associate the specified credential with the current context.
    //

    pContext->pszCredentialName = SPExternalAlloc((lstrlenW(pCredName) + 1) * sizeof(WCHAR));
    if(pContext->pszCredentialName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    lstrcpyW(pContext->pszCredentialName, pCredName);


    Status = QueryCredentialManagerForCert(pContext, pCredName);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Credential assigned to context successfully.\n"));


cleanup:
    if(pCredentialStruct)
    {
        SPExternalFree(pCredentialStruct);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetApplicationData
//
//  Synopsis:   Sets the SECPKG_ATTR_APP_DATA context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain the following structure:
//
//              typedef struct _SecPkgContext_SessionAppData
//              {
//                  DWORD dwFlags;
//                  DWORD cbAppData;
//                  PBYTE pbAppData;
//              } SecPkgContext_SessionAppData, *PSecPkgContext_SessionAppData;
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetApplicationData(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    SecPkgContext_SessionAppData AppData;
    PBYTE pbAppData = NULL;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_APP_DATA)\n"));

    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }


    //
    // Marshal over the input structure from the client address space.
    //

    if(BufferSize < sizeof(SecPkgContext_SessionAppData))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof(SecPkgContext_SessionAppData),
                                             &AppData,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    //
    // Marshal over the application data from the client address space.
    //

    // Limit application data size to 64k.
    if(AppData.cbAppData > 0x10000)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if(AppData.cbAppData == 0 || AppData.pbAppData == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    pbAppData = SPExternalAlloc(AppData.cbAppData);

    if(pbAppData == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             AppData.cbAppData,
                                             pbAppData,
                                             AppData.pbAppData );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    //
    // Assign application data to cache entry.
    //

    Status = SetCacheAppData(pContext->RipeZombie,
                             pbAppData,
                             AppData.cbAppData);

    if(!FAILED(Status))
    {
        // The operation succeeded, so consume the application data.
        pbAppData = NULL;
    }


cleanup:
    if(pbAppData)
    {
        SPExternalFree(pbAppData);
    }

    return Status;
}


NTSTATUS
NTAPI 
SpSetContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    NTSTATUS    Status;
    PSPContext  pContext;

    pContext = (PSPContext)ContextHandle;

    switch(ContextAttribute)
    {
        case SECPKG_ATTR_USE_VALIDATED:
            DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_USE_VALIDATED)\n"));

            Status = STATUS_SUCCESS;
            break;

        case SECPKG_ATTR_CREDENTIAL_NAME:
            Status = SpSetCredentialNameProp(pContext, Buffer, BufferSize);
            break;

        case SECPKG_ATTR_TARGET_INFORMATION:
            DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_TARGET_INFORMATION)\n"));

            Status = STATUS_SUCCESS;
            break;

        case SECPKG_ATTR_APP_DATA:
            Status = SpSetApplicationData(pContext, Buffer, BufferSize);
            break;

        default:
            DebugLog((DEB_ERROR, "SetContextAttributes(unsupported function %d)\n", ContextAttribute));

            Status = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\ctxtapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ctxtapi.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"

#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>
#include <sslcache.h>
#include <lsasecpk.h>

NTSTATUS NTAPI
SslPurgeSessionCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);

NTSTATUS NTAPI
SslSessionCacheInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);

NTSTATUS NTAPI
SslGetPerfmonInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);


SECURITY_STATUS SEC_ENTRY
SpInitLsaModeContext(
    LSA_SEC_HANDLE      dwCredHandle,
    LSA_SEC_HANDLE      dwCtxtHandle,
    PSECURITY_STRING    pszTargetName,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    PLSA_SEC_HANDLE     pdwNewContext,
    PSecBufferDesc      pOutput,
    PULONG              pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    PSPContext          pContext = NULL;
    PSPCredentialGroup  pCred = NULL;
    SPBuffer            CommOut;
    SPBuffer            CommIn;
    PSecBuffer          pInToken = NULL;
    PSecBuffer          pOutToken = NULL;
    PSecBuffer          pExtra = NULL;

    DWORD       fAttr = ISC_RET_REPLAY_DETECT   |
                        ISC_RET_SEQUENCE_DETECT |
                        ISC_RET_CONFIDENTIALITY |
                        ISC_RET_STREAM;

    DWORD       fSchContext = CONTEXT_FLAG_CLIENT;
    int         i;

    SP_STATUS   pctRet = PCT_ERR_OK;

    UNREFERENCED_PARAMETER(TargetDataRep);

    #if DBG
        DebugLog((DEB_TRACE, "SpInitLsaModeContext(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
            dwCredHandle, dwCtxtHandle, pszTargetName, fContextReq,
            pInput, pdwNewContext, pOutput, pfContextAttr, ptsExpiry, pfMapContext,
            pContextData));
        if(pszTargetName)
        {
            DebugLog((DEB_TRACE, "pszTargetName:<%ls>\n",pszTargetName->Buffer));
        }
    #endif


    /* These flags are never allowed */
    if (fContextReq & (ISC_REQ_DELEGATE | ISC_REQ_PROMPT_FOR_CREDS ))
    {
        TRACE_EXIT( SpInitLsaModeContext, SEC_E_UNSUPPORTED_FUNCTION );

        return SP_LOG_RESULT( SEC_E_UNSUPPORTED_FUNCTION );
    }


    /* Initialize output buffer locations */
    for (i = 0; i < (int)pOutput->cBuffers; i++ )
    {
        switch( ( pOutput->pBuffers[i].BufferType ) & (~(SECBUFFER_ATTRMASK)))
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken && (fContextReq & ISC_REQ_ALLOCATE_MEMORY))
                    pOutToken = &pOutput->pBuffers[i];
                break;

            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    if ( pOutToken == NULL )
    {
        TRACE_EXIT( SpInitLsaModeContext, SEC_E_INVALID_TOKEN );

        return SP_LOG_RESULT( SEC_E_INVALID_TOKEN );
    }

    pOutToken->BufferType = SECBUFFER_TOKEN;

    if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
    {
        CommOut.pvBuffer = NULL;
        CommOut.cbBuffer = 0;
        CommOut.cbData = 0;

        fAttr |= ISC_RET_ALLOCATED_MEMORY;

        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }
    else
    {

        if ( pOutToken->pvBuffer == NULL )
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;

    if ( fContextReq & (ISC_REQ_EXTENDED_ERROR) )
    {
        fAttr       |= ISC_RET_EXTENDED_ERROR;
        fSchContext |= CONTEXT_FLAG_EXT_ERR;
    }

    if ( fContextReq & (ISC_REQ_CONNECTION) )
    {
        fAttr       |= ISC_REQ_CONNECTION;
        fSchContext |= CONTEXT_FLAG_CONNECTION_MODE;
    }

    if ( fContextReq & (ISC_REQ_MUTUAL_AUTH) )
    {
        // Validate the server certificate.
        fAttr       |= ISC_RET_MUTUAL_AUTH;
        fSchContext |= CONTEXT_FLAG_MUTUAL_AUTH;
        fSchContext &= ~CONTEXT_FLAG_MANUAL_CRED_VALIDATION;

        if ( fContextReq & (ISC_REQ_MANUAL_CRED_VALIDATION))
        {
            // These flags are mutually exclusive
            return SP_LOG_RESULT( SEC_E_UNSUPPORTED_FUNCTION );
        }
    }
    else
    {
        if ( fContextReq & (ISC_REQ_MANUAL_CRED_VALIDATION))
        {
            fAttr       |= ISC_RET_MANUAL_CRED_VALIDATION;
            fSchContext |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }

        // Turn off automatic credential validation if so specified in registry.
        if(g_fManualCredValidation)
        {
            fSchContext |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }
    }

    if ( fContextReq & (ISC_REQ_USE_SUPPLIED_CREDS))
    {
        fAttr       |= ISC_REQ_USE_SUPPLIED_CREDS;
        fSchContext |= CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG;
    }


    if( pfContextAttr )
    {
        *pfContextAttr = fAttr;
    }

    if ( dwCtxtHandle == 0 )
    {
        pContext = SPContextCreate( pszTargetName->Buffer );

        if(pContext == NULL)
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }
        pContext->Flags |= fSchContext;

        pCred = (PSPCredentialGroup) dwCredHandle ;

        if(pctRet == PCT_ERR_OK)
        {
            pctRet = SPContextSetCredentials(pContext, pCred);
        }

        if(pctRet != PCT_ERR_OK)
        {

            SPContextDelete(pContext);

            *pdwNewContext = 0;

            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet ));

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }


        pctRet = pContext->InitiateHello( pContext, &CommOut, TRUE);

        if ( (CommOut.cbBuffer == 0) &&
             (pctRet == PCT_INT_BUFF_TOO_SMALL) )
        {
            SPContextDelete(pContext);

            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );
            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

        if ( pctRet != PCT_ERR_OK )
        {
            SPContextDelete(pContext);

            *pdwNewContext = 0;

            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet) );

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
        {
            //
            // Easy:  The caller asked for us to allocate memory for them, so
            // let the LSA do it.
            //

            pOutToken->pvBuffer = CommOut.pvBuffer ;

        }
        else
        {
            //
            // The caller has a buffer that we're supposed to use.  Make sure we
            // can fit.
            //

            if ( (ULONG) CommOut.cbBuffer <= pOutToken->cbBuffer  )
            {
                RtlCopyMemory(  pOutToken->pvBuffer,
                                CommOut.pvBuffer,
                                CommOut.cbBuffer );
            }
            else
            {
                DebugLog(( DEB_TRACE, "Supplied buffer is too small\n" ));

                SPContextDelete( pContext );

                TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );
                return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
            }

        }

        *pdwNewContext = (LSA_SEC_HANDLE) pContext ;

        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbData;

        #if DBG
            DebugLog((
                DEB_TRACE,
                "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pOutToken->BufferType,
                pOutToken->pvBuffer,
                pOutToken->cbBuffer));

            if(pOutToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
            }
        #endif

    }
    else
    {
        /* Initialize input buffer locations */
        for (i = 0; i < (int)pInput->cBuffers; i++ )
        {
            switch( (pInput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) )
            {
                case SECBUFFER_TOKEN:
                case SECBUFFER_TOKEN | SECBUFFER_READONLY:
                    pInToken = &pInput->pBuffers[i];
                    break;

                case SECBUFFER_EMPTY:
                    if(!pInToken)
                    {
                        pInToken = &pInput->pBuffers[i];
                    }
                    else if(!pExtra)
                    {
                        pExtra = &pInput->pBuffers[i];
                    }
                break;

                case SECBUFFER_DATA:
                case SECBUFFER_STREAM_HEADER:
                case SECBUFFER_STREAM_TRAILER:
                default:
                    break;
            }
        }

        #if DBG
            if(pInToken)
            {
                DebugLog((
                    DEB_TRACE,
                    "Input:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pInToken->BufferType,
                    pInToken->pvBuffer,
                    pInToken->cbBuffer));

                if(pInToken->pvBuffer)
                {
                    DBG_HEX_STRING(DEB_BUFFERS, pInToken->pvBuffer, pInToken->cbBuffer);
                }
            }
            if(pExtra)
            {
                DebugLog((
                    DEB_TRACE,
                    "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pExtra->BufferType,
                    pExtra->pvBuffer,
                    pExtra->cbBuffer));
            }
        #endif

        if(pInToken == NULL)
        {
            CommIn.pvBuffer = NULL;
            CommIn.cbBuffer = 0;
            CommIn.cbData   = 0;
        }
        else
        {
            CommIn.pvBuffer = pInToken->pvBuffer;
            CommIn.cbBuffer = pInToken->cbBuffer;
            CommIn.cbData   = pInToken->cbBuffer;
        }

        pContext = (PSPContext) dwCtxtHandle ;
        if ( dwCredHandle )
        {
            pCred = (PSPCredentialGroup) dwCredHandle ;
        }

        if( pContext == NULL || pCred == NULL )
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INVALID_HANDLE );

            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }

        pContext->Flags |= fSchContext;

        pctRet = SPContextSetCredentials(pContext, pCred);

        if(pctRet == PCT_ERR_OK)
        {
            pctRet = pContext->ProtocolHandler( pContext,
                                                &CommIn,
                                                &CommOut);
        }


        if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            if(pExtra)
            {
                pExtra->BufferType = SECBUFFER_MISSING | SECBUFFER_UNMAPPED ;
                pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
                pExtra->pvBuffer = NULL ;
            }
        }
        else
        {
            pOutToken->pvBuffer = CommOut.pvBuffer;
            pOutToken->cbBuffer = CommOut.cbData;
        }

        if(pctRet == PCT_INT_BUFF_TOO_SMALL)
        {
            pOutToken->BufferType |= SECBUFFER_UNMAPPED;
        }

        #if DBG
            if(pOutToken)
            {
                DebugLog((
                    DEB_TRACE,
                    "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pOutToken->BufferType,
                    pOutToken->pvBuffer,
                    pOutToken->cbBuffer));

                if(pOutToken->pvBuffer)
                {
                    DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
                }
            }
            if(pExtra)
            {
                DebugLog((
                    DEB_TRACE,
                    "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pExtra->BufferType,
                    pExtra->pvBuffer,
                    pExtra->cbBuffer));
            }
        #endif


        if(!SP_FATAL(pctRet))
        {
            *pdwNewContext = dwCtxtHandle ;
        }

        if(PCT_ERR_OK != pctRet)
        {
            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet ));

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        if(pInToken)
        {
            if(CommIn.cbData < pInToken->cbBuffer && pExtra)
            {
                pExtra->BufferType = SECBUFFER_EXTRA | SECBUFFER_UNMAPPED ;
                pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
                pExtra->pvBuffer = NULL ;
            }
        }
    }

    if ( (pContext->State == SP_STATE_CONNECTED) &&
         ( (pContext->Flags & CONTEXT_FLAG_MAPPED) == 0 ) )
    {
        //
        // Need to map the context back down to the user process.  It
        // doesn't get any scarier than this:
        //

        *pfMapContext = TRUE ;

        DebugOut(( DEB_TRACE, "Mapping context to usermode\n" ));

        pctRet = SPContextSerialize(pContext,
                                    SslRelocateToken,
                                    (PUCHAR *) &pContextData->pvBuffer,
                                    &pContextData->cbBuffer,
                                    TRUE);
        if(PCT_ERR_OK != pctRet)
        {
            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        pContext->Flags |= CONTEXT_FLAG_MAPPED ;

        LogHandshakeInfoEvent(pContext->RipeZombie->fProtocol,
                              pContext->pCipherInfo,
                              pContext->pHashInfo,
                              pContext->pKeyExchInfo,
                              pContext->RipeZombie->dwExchStrength);
    }

    if(ptsExpiry != NULL)
    {
        if(pContext->RipeZombie->pRemoteCert != NULL)
        {
            ptsExpiry->QuadPart = *((LONGLONG *)&pContext->RipeZombie->pRemoteCert->pCertInfo->NotAfter);
        }
        else
        {
            ptsExpiry->QuadPart = MAXTIMEQUADPART;
        }
    }

    if(pContext->State == SP_STATE_CONNECTED ||
       pContext->State == SP_STATE_SHUTDOWN)
    {
        return SEC_E_OK;
    }
    else
    {
        return SEC_I_CONTINUE_NEEDED;
    }
}


SECURITY_STATUS SEC_ENTRY
SpMoveContextToUser(    ULONG       dwCtxtHandle,
                        PSecBuffer  pContextBuffer)
{
    UNREFERENCED_PARAMETER(dwCtxtHandle);
    UNREFERENCED_PARAMETER(pContextBuffer);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS
SEC_ENTRY
SpDeleteContext(
    LSA_SEC_HANDLE dwCtxtHandle)
{
    PSPContext  pContext ;

    DebugLog((DEB_TRACE, "SpDeleteContext(0x%x)\n", dwCtxtHandle));

    pContext = (PSPContext) dwCtxtHandle ;

    SPContextDelete( pContext );

    return( SEC_E_OK );
}


SECURITY_STATUS
SEC_ENTRY
SpApplyControlToken(
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput)
{
    PSPContext pContext;
    PSecBuffer Buffer ;

    DebugLog((DEB_TRACE, "SpApplyControlToken(0x%x, 0x%x)\n", dwCtxtHandle, pInput));

    pContext = (PSPContext) dwCtxtHandle ;

    if ( pInput->cBuffers != 1 )
    {
        return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
    }

    Buffer = pInput->pBuffers ;

    if(Buffer->cbBuffer < sizeof(DWORD))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    switch(*(DWORD *)Buffer->pvBuffer)
    {
        case SCHANNEL_RENEGOTIATE:
        {
            PDWORD  RedoData;

            DebugLog((DEB_TRACE, "SCHANNEL_RENEGOTIATE\n"));

            if(Buffer->cbBuffer < sizeof(DWORD) * 2)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }

            RedoData = (DWORD *)Buffer->pvBuffer;

            pContext->State = RedoData[1];

            pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

            return SEC_E_OK;
        }

        case SCHANNEL_SHUTDOWN:
            DebugLog((DEB_TRACE, "SCHANNEL_SHUTDOWN\n"));
            pContext->State = SP_STATE_SHUTDOWN_PENDING;
            return SEC_E_OK;

        case SCHANNEL_ALERT:
        {
            SCHANNEL_ALERT_TOKEN *pAlertToken;

            DebugLog((DEB_TRACE, "SCHANNEL_TLS1_ALERT\n"));

            if(Buffer->cbBuffer < sizeof(SCHANNEL_ALERT_TOKEN))
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }
            pAlertToken = (SCHANNEL_ALERT_TOKEN *)Buffer->pvBuffer;

            // Alerts are only supported in SSL3 and TLS1
            if(!(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1))
            {
                return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
            }

            // Reality check alert values.
            if(pAlertToken->dwAlertType   >= 0x100 || 
               pAlertToken->dwAlertNumber >= 0x100)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }

            SetTls1Alert(pContext, 
                         (BYTE)pAlertToken->dwAlertType,
                         (BYTE)pAlertToken->dwAlertNumber);

            #if DBG
                DebugLog((DEB_TRACE,
                          "AlertLevel:0x%x, AlertNumber:0x%x\n",
                          pAlertToken->dwAlertType,
                          pAlertToken->dwAlertNumber));
            #endif

            return SEC_E_OK;
        }

        case SCHANNEL_SESSION:
        {
            SCHANNEL_SESSION_TOKEN *pSessionToken;
            SECURITY_STATUS Status = SEC_E_UNSUPPORTED_FUNCTION;

            DebugLog((DEB_TRACE, "SCHANNEL_SESSION\n"));
    
            if(pContext->RipeZombie == NULL)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
            }
    
            if(Buffer->cbBuffer < sizeof(SCHANNEL_SESSION_TOKEN))
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }
            pSessionToken = (SCHANNEL_SESSION_TOKEN *)Buffer->pvBuffer;
    
            if(pSessionToken->dwFlags & SSL_SESSION_DISABLE_RECONNECTS)
            {
                // Disable reconnects
                pContext->RipeZombie->ZombieJuju = FALSE;
                Status = SEC_E_OK;
            }

            if(pSessionToken->dwFlags & SSL_SESSION_ENABLE_RECONNECTS)
            {
                // Enable reconnects
                if(pContext->RipeZombie->DeferredJuju)
                {
                    pContext->RipeZombie->ZombieJuju = TRUE;
                    pContext->RipeZombie->DeferredJuju = FALSE;
                    Status = SEC_E_OK;
                }
            }

            return Status;
        }

        default:
            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
}


VOID
SEC_ENTRY
SpLogonTerminated(PLUID  pLogonId)
{
    UNREFERENCED_PARAMETER(pLogonId);

    return;
}


SECURITY_STATUS SEC_ENTRY
SpAcceptLsaModeContext(
                            LSA_SEC_HANDLE  dwCredHandle,
                            LSA_SEC_HANDLE  dwCtxtHandle,
                            PSecBufferDesc  pInput,
                            ULONG           fContextReq,
                            ULONG           TargetDataRep,
                            PLSA_SEC_HANDLE pdwNewContext,
                            PSecBufferDesc  pOutput,
                            PULONG          pfContextAttr,
                            PTimeStamp      ptsExpiry,
                            PBYTE           pfMapContext,
                            PSecBuffer      pContextData)
{
    PSPContext  pContext = NULL;
    PSPCredentialGroup pCred = NULL;
    SPBuffer CommOut;
    SPBuffer CommIn;
    PSecBuffer pInToken = NULL;
    PSecBuffer pOutToken = NULL;
    PSecBuffer pExtra = NULL;
    unsigned long fAttr = ASC_RET_REPLAY_DETECT | 
                          ASC_RET_SEQUENCE_DETECT | 
                          ASC_RET_CONFIDENTIALITY |
                          ASC_RET_STREAM;

    DWORD         fSchContext = 0;
    int i;
    SP_STATUS pctRet = PCT_ERR_OK;

    UNREFERENCED_PARAMETER(TargetDataRep);

    TRACE_ENTER( SpAcceptLsaModeContext );

#if DBG
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
            dwCredHandle, dwCtxtHandle, pInput, fContextReq, pdwNewContext,
            pOutput, pfContextAttr, ptsExpiry, pfMapContext, pContextData));
#endif


    // This flag is never allowed
    if(fContextReq & ASC_REQ_DELEGATE)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_UNSUPPORTED_FUNCTION );
        return SEC_E_UNSUPPORTED_FUNCTION;
    }

    if ( fContextReq & ASC_REQ_MUTUAL_AUTH )
    {
        fSchContext |= CONTEXT_FLAG_MUTUAL_AUTH;
    }

    if ( fContextReq & ASC_REQ_NO_TOKEN )
    {
        fSchContext |= CONTEXT_FLAG_NO_CERT_MAPPING;
        fAttr |= ASC_RET_NO_TOKEN;
    }

    /* Initialize input buffer locations */
    for (i = 0; i < (int)pInput->cBuffers; i++ )
    {
        switch( pInput->pBuffers[i].BufferType & (~(SECBUFFER_ATTRMASK)) )
        {
            case SECBUFFER_TOKEN:
                pInToken = &pInput->pBuffers[i];
                break;

            case SECBUFFER_EMPTY:
                if(!pInToken)
                {
                    pInToken = &pInput->pBuffers[i];
                }
                else if(!pExtra)
                {
                    pExtra = &pInput->pBuffers[i];
                }
                break;

            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    #if DBG
        if(pInToken)
        {
            DebugLog((
                DEB_TRACE,
                "Input:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pInToken->BufferType,
                pInToken->pvBuffer,
                pInToken->cbBuffer));

            if(pInToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pInToken->pvBuffer, pInToken->cbBuffer);
            }
        }
        if(pExtra)
        {
            DebugLog((
                DEB_TRACE,
                "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pExtra->BufferType,
                pExtra->pvBuffer,
                pExtra->cbBuffer));
        }
    #endif


    /* Initialize output buffer locations */

    for (i = 0; i < (int) pOutput->cBuffers; i++ )
    {
        switch( pOutput->pBuffers[i].BufferType & (~(SECBUFFER_ATTRMASK)) )
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken && (fContextReq & ASC_REQ_ALLOCATE_MEMORY))
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    if(pOutToken == NULL)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INVALID_TOKEN );

        return SEC_E_INVALID_TOKEN;
    }

    if ( !pExtra )
    {
        DebugOut(( DEB_TRACE, " Warning - no Empty security buffer\n"));
    }

    pOutToken->BufferType = SECBUFFER_TOKEN;

    if(pInToken && pInToken->BufferType == SECBUFFER_TOKEN)
    {
        CommIn.pvBuffer = pInToken->pvBuffer;
        CommIn.cbBuffer = pInToken->cbBuffer;
        CommIn.cbData   = pInToken->cbBuffer;
    }
    else
    {
        CommIn.pvBuffer = NULL;
        CommIn.cbBuffer = 0;
        CommIn.cbData = 0;
    }

    if (fContextReq & ASC_REQ_ALLOCATE_MEMORY)
    {
        fAttr |= ASC_RET_ALLOCATED_MEMORY;
        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;

    if (fContextReq & (ASC_REQ_EXTENDED_ERROR))
    {
        fAttr       |= ASC_RET_EXTENDED_ERROR;
        fSchContext |= CONTEXT_FLAG_EXT_ERR;
    }

    if ( fContextReq & (ASC_REQ_CONNECTION) )
    {
        fAttr       |= ASC_RET_CONNECTION;
        fSchContext |= CONTEXT_FLAG_CONNECTION_MODE;
    }

    if (pfContextAttr)
    {
        *pfContextAttr = fAttr;
    }

    if ( dwCtxtHandle == 0 )
    {
        pContext = SPContextCreate(NULL);
        if (pContext == NULL)
        {
            TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SEC_E_INSUFFICIENT_MEMORY;
        }

    }
    else
    {
        pContext = (PSPContext) dwCtxtHandle ;
    }

    if ( dwCredHandle == 0 )
    {
        pCred = NULL ;
    }
    else
    {
        pCred = (PSPCredentialGroup) dwCredHandle ;
    }

    if ( (pContext == NULL) || (pCred == NULL) )
    {
        if ( dwCtxtHandle == 0 )
        {
            SPContextDelete( pContext );
        }

        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INVALID_HANDLE );

        return( SEC_E_INVALID_HANDLE );
    }

    pctRet = SPContextSetCredentials(pContext, pCred);

    pContext->Flags |= fSchContext;

    if ( pctRet == PCT_ERR_OK )
    {
        pctRet = pContext->ProtocolHandler( pContext, &CommIn, &CommOut);
    }

    if ( dwCtxtHandle == 0 )
    {
        if ( pctRet != PCT_ERR_OK )
        {
            SPContextDelete( pContext );
        }
        else
        {
            *pdwNewContext = (LSA_SEC_HANDLE) pContext ;
        }
    }
    else
    {
        *pdwNewContext = (LSA_SEC_HANDLE) pContext ;
    }

    if (CommOut.cbData == 0 && pctRet == PCT_INT_BUFF_TOO_SMALL)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    if (pctRet == PCT_INT_INCOMPLETE_MSG)
    {
        if(pExtra)
        {
            pExtra->BufferType = SECBUFFER_MISSING | SECBUFFER_UNMAPPED ;
            pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
            pExtra->pvBuffer = NULL ;

            DebugOut(( DEB_TRACE, "Incomplete message, needs %d more bytes\n",
                            pExtra->cbBuffer ));

        }
        else
        {
            DebugOut(( DEB_TRACE, "No Empty buffer for returning missing info!\n" ));
        }
    }
    else
    {
        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbData;
    }

    if(pctRet == PCT_INT_BUFF_TOO_SMALL)
    {
        pOutToken->BufferType |= SECBUFFER_UNMAPPED;
    }

    if(pOutToken->cbBuffer == 0)
    {
        // Don't return an output token if the output buffer is
        // empty. Also, make sure that the extended error flag is
        // turned off.
        pOutToken->BufferType = SECBUFFER_EMPTY;

        if(pfContextAttr)
        {
            *pfContextAttr &= ~ASC_RET_EXTENDED_ERROR;
        }
    }

    if (PCT_ERR_OK != pctRet)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, PctTranslateError( pctRet ) );

        return PctTranslateError(pctRet);
    }

    if(pInToken)
    {
        if (CommIn.cbData < pInToken->cbBuffer && pExtra)
        {
            pExtra->BufferType = SECBUFFER_EXTRA | SECBUFFER_UNMAPPED ;
            pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
            pExtra->pvBuffer = NULL ;

            DebugOut(( DEB_TRACE, "Extra data, needs to be mapped back: %d\n", pExtra->cbBuffer ));
        }
    }

    if ( (pContext->State == SP_STATE_CONNECTED) &&
         ( (pContext->Flags & CONTEXT_FLAG_MAPPED) == 0 ) )
    {
        //
        // Need to map the context back down to the user process.  It
        // doesn't get any scarier than this:
        //

        *pfMapContext = TRUE ;

        DebugOut(( DEB_TRACE, "Mapping context to usermode\n" ));

        pctRet = SPContextSerialize(pContext,
                                    SslRelocateToken,
                                    (PUCHAR *) &pContextData->pvBuffer,
                                    &pContextData->cbBuffer,
                                    TRUE);

        if (PCT_ERR_OK != pctRet)
        {
            TRACE_EXIT( SpAcceptLsaModeContext, PctTranslateError( pctRet ) );

            return PctTranslateError(pctRet);
        }

        pContext->Flags |= CONTEXT_FLAG_MAPPED ;

        LogHandshakeInfoEvent(pContext->RipeZombie->fProtocol,
                              pContext->pCipherInfo,
                              pContext->pHashInfo,
                              pContext->pKeyExchInfo,
                              pContext->RipeZombie->dwExchStrength);
    }


    #if DBG
        if(pOutToken)
        {
            DebugLog((
                DEB_TRACE,
                "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pOutToken->BufferType,
                pOutToken->pvBuffer,
                pOutToken->cbBuffer));

            if(pOutToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
            }
        }
        if(pExtra)
        {
            DebugLog((
                DEB_TRACE,
                "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pExtra->BufferType,
                pExtra->pvBuffer,
                pExtra->cbBuffer));
        }

        if(pContext->State == SP_STATE_CONNECTED)
        {
            DebugLog((DEB_TRACE, "Server handshake complete\n"));
        }
    #endif

    if(ptsExpiry != NULL)
    {
        if(pContext->RipeZombie->pRemoteCert != NULL)
        {
            ptsExpiry->QuadPart = *((LONGLONG *)&pContext->RipeZombie->pRemoteCert->pCertInfo->NotAfter);
        }
        else
        {
            ptsExpiry->QuadPart = MAXTIMEQUADPART;
        }
    }

    if(pContext->State == SP_STATE_CONNECTED &&
       pContext->RipeZombie->hLocator)
    {
        // Certificate mapping was successful.
        *pfContextAttr |= ASC_RET_MUTUAL_AUTH;
    }

    if(pContext->State == SP_STATE_CONNECTED ||
       pContext->State == SP_STATE_SHUTDOWN)
    {
        return SEC_E_OK;
    }
    else
    {
        return SEC_I_CONTINUE_NEEDED;
    }
}


NTSTATUS
SpCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PULONG Request ;

    if((ProtocolSubmitBuffer == NULL) || (SubmitBufferLength < sizeof(ULONG)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    Request = (PULONG) ProtocolSubmitBuffer ;

    if ( *Request == SSL_LOOKUP_CERT_MESSAGE )
    {
        return SslDoClientRequest(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    } 

    else if ( *Request == SSL_LOOKUP_EXTERNAL_CERT_MESSAGE &&
              ClientBufferBase == ProtocolSubmitBuffer)
    {
        // This function is only allowed to be called from the 
        // lsass.exe process.
        return SslMapExternalCredential(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    } 

    else if( *Request == SSL_CACHE_INFO_MESSAGE )
    {
        return SslSessionCacheInfo(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    }

    else if( *Request == SSL_PURGE_CACHE_MESSAGE )
    {
        return SslPurgeSessionCache(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    }

    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
SpCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    ULONG MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if((ProtocolSubmitBuffer == NULL) || (SubmitBufferLength < sizeof(ULONG)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((ULONG *)(ProtocolSubmitBuffer));


    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;


    //
    // Process message as appropriate.
    //

    switch(MessageType)
    {
    case SSL_PURGE_CACHE_MESSAGE:
        return SslPurgeSessionCache(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    case SSL_CACHE_INFO_MESSAGE:
        return SslSessionCacheInfo(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    case SSL_PERFMON_INFO_MESSAGE:
        return SslGetPerfmonInfo(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    default:
        return( SEC_E_UNSUPPORTED_FUNCTION );
    }
}


NTSTATUS NTAPI
SslPurgeSessionCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    SECPKG_CALL_INFO CallInfo;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    SSL_PURGE_SESSION_CACHE_REQUEST PurgeRequest;
    PSSL_PURGE_SESSION_CACHE_REQUEST pPurgeRequest;

    UNREFERENCED_PARAMETER(ClientRequest);

    //
    // Verify the request.
    //

    DebugLog((DEB_TRACE, "Purging session cache\n"));

    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if(CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64 pRequest;

        if(SubmitBufferSize < sizeof(SSL_PURGE_SESSION_CACHE_REQUEST_WOW64))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64)ProtocolSubmitBuffer;

        memset(&PurgeRequest, 0, sizeof(PurgeRequest));
        PurgeRequest.MessageType = pRequest->MessageType;
        PurgeRequest.LogonId     = pRequest->LogonId;
        PurgeRequest.Flags       = pRequest->Flags;

        PurgeRequest.ServerName.Length = pRequest->ServerName.Length;
        PurgeRequest.ServerName.MaximumLength = pRequest->ServerName.MaximumLength;
        PurgeRequest.ServerName.Buffer = (PVOID) UlongToPtr(pRequest->ServerName.Buffer);

        pPurgeRequest = &PurgeRequest;
    }
    else
    {
        if (SubmitBufferSize < sizeof(SSL_PURGE_SESSION_CACHE_REQUEST))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pPurgeRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST) ProtocolSubmitBuffer;
    }



    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE(&pPurgeRequest->ServerName);


    //
    // Find the callers logon id & TCB status
    //

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Verify the caller has TCB privilege if they want to purge someone
    // else's session cache entries.
    //

    if(!RtlIsZeroLuid(&pPurgeRequest->LogonId) ||
       (pPurgeRequest->Flags & SSL_PURGE_CLIENT_ALL_ENTRIES) ||
       (pPurgeRequest->Flags & SSL_PURGE_SERVER_ALL_ENTRIES))
    {
        if(!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }
    }


    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if(RtlIsZeroLuid(&pPurgeRequest->LogonId))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        LogonId = &pPurgeRequest->LogonId;
    }


    //
    // Purge the requested cache entries.
    //

    Status = SPCachePurgeEntries(LogonId,
                                 ClientInfo.ProcessID,
                                 pPurgeRequest->ServerName.Buffer,
                                 pPurgeRequest->Flags);


    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
SslSessionCacheInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    SECPKG_CALL_INFO CallInfo;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    SSL_SESSION_CACHE_INFO_REQUEST InfoRequest;
    PSSL_SESSION_CACHE_INFO_REQUEST pInfoRequest;
    PSSL_SESSION_CACHE_INFO_RESPONSE pInfoResponse = NULL;
    DWORD cbInfoResponse;
    PVOID pvClient;

    UNREFERENCED_PARAMETER(ClientRequest);

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;



    //
    // Verify the request.
    //

    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if(CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PSSL_SESSION_CACHE_INFO_REQUEST_WOW64 pRequest;

        if(SubmitBufferSize < sizeof(SSL_SESSION_CACHE_INFO_REQUEST_WOW64))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pRequest = (PSSL_SESSION_CACHE_INFO_REQUEST_WOW64)ProtocolSubmitBuffer;

        memset(&InfoRequest, 0, sizeof(InfoRequest));
        InfoRequest.MessageType = pRequest->MessageType;
        InfoRequest.LogonId     = pRequest->LogonId;
        InfoRequest.Flags       = pRequest->Flags;

        InfoRequest.ServerName.Length = pRequest->ServerName.Length;
        InfoRequest.ServerName.MaximumLength = pRequest->ServerName.MaximumLength;
        InfoRequest.ServerName.Buffer = (PVOID) UlongToPtr(pRequest->ServerName.Buffer);

        pInfoRequest = &InfoRequest;
    }
    else
    {
        if (SubmitBufferSize < sizeof(SSL_SESSION_CACHE_INFO_REQUEST))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pInfoRequest = (PSSL_SESSION_CACHE_INFO_REQUEST)ProtocolSubmitBuffer;
    }


    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE(&pInfoRequest->ServerName);


    //
    // Find the callers logon id & TCB status
    // 

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &pInfoRequest->LogonId ) )
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // else's session cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &pInfoRequest->LogonId;
    }

    pInfoResponse = SPExternalAlloc(sizeof(SSL_SESSION_CACHE_INFO_RESPONSE));
    if(pInfoResponse == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = SPCacheGetInfo(LogonId,
                            pInfoRequest->ServerName.Buffer,
                            pInfoRequest->Flags,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    cbInfoResponse = sizeof(SSL_SESSION_CACHE_INFO_RESPONSE);

    //
    // Copy the response data to the client process.
    //

    Status = LsaTable->AllocateClientBuffer(
                NULL,
                cbInfoResponse,
                &pvClient);

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbInfoResponse,
                            pvClient,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        goto Cleanup;
    }

    *ProtocolReturnBuffer = pvClient;
    *ReturnBufferLength   = cbInfoResponse;


Cleanup:

    if(pInfoResponse)
    {
        SPExternalFree(pInfoResponse);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
SslGetPerfmonInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    PSSL_PERFMON_INFO_REQUEST pInfoRequest;
    PSSL_PERFMON_INFO_RESPONSE pInfoResponse = NULL;
    DWORD cbInfoResponse;
    PVOID pvClient;

    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ClientBufferBase);

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Verify the request.
    //

    if (SubmitBufferSize < sizeof(SSL_PERFMON_INFO_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pInfoRequest = (PSSL_PERFMON_INFO_REQUEST)ProtocolSubmitBuffer;

    pInfoResponse = SPExternalAlloc(sizeof(SSL_PERFMON_INFO_RESPONSE));
    if(pInfoResponse == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = SPCacheGetPerfmonInfo(pInfoRequest->Flags,
                                   pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    cbInfoResponse = sizeof(SSL_PERFMON_INFO_RESPONSE);

    //
    // Copy the response data to the client process.
    //

    Status = LsaTable->AllocateClientBuffer(
                NULL,
                cbInfoResponse,
                &pvClient);

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbInfoResponse,
                            pvClient,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        goto Cleanup;
    }

    *ProtocolReturnBuffer = pvClient;
    *ReturnBufferLength   = cbInfoResponse;


Cleanup:

    if(pInfoResponse)
    {
        SPExternalFree(pInfoResponse);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


NTSTATUS
SpCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{


    //
    // NOTE: if other sensitive request types are to be supported,
    // this routine should filter them out prior to calling SpCallPackage.
    // This is required because untrusted code has the opportunity for
    // making genericpassthrough requests.
    //

    PULONG Request ;

    if((ProtocolSubmitBuffer == NULL) || (SubmitBufferLength < sizeof(ULONG)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    Request = (PULONG) ProtocolSubmitBuffer ;

    if ( *Request != SSL_LOOKUP_CERT_MESSAGE )
        return SEC_E_UNSUPPORTED_FUNCTION;

    return SpCallPackage(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus
                    );
}



SECURITY_STATUS SEC_ENTRY
SpShutdown(void)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
SpSystemLogon( PSECURITY_STRING    pName,
               DWORD               cbKey,
               PBYTE               pbKey,
               DWORD *             pdwHandle,
               PTimeStamp          ptsExpiry)
{
    UNREFERENCED_PARAMETER(pName);
    UNREFERENCED_PARAMETER(cbKey);
    UNREFERENCED_PARAMETER(pbKey);
    UNREFERENCED_PARAMETER(pdwHandle);
    UNREFERENCED_PARAMETER(ptsExpiry);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
SpGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    UNREFERENCED_PARAMETER(pLogonId);
    UNREFERENCED_PARAMETER(fFlags);
    UNREFERENCED_PARAMETER(ppUserInfo);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}





//+---------------------------------------------------------------------------
//
//  Function:   SpSaveCredentials
//
//  Synopsis:   Store credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpSaveCredentials(  LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    UNREFERENCED_PARAMETER(dwCredHandle);
    UNREFERENCED_PARAMETER(pCredentials);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpGetCredentials
//
//  Synopsis:   Get Credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpGetCredentials(   LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    UNREFERENCED_PARAMETER(dwCredHandle);
    UNREFERENCED_PARAMETER(pCredentials);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpDeleteCredentials
//
//  Synopsis:   Delete stored creds (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pKey]         --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpDeleteCredentials(LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pKey)
{
    UNREFERENCED_PARAMETER(dwCredHandle);
    UNREFERENCED_PARAMETER(pKey);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\callback.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Created
//
//----------------------------------------------------------------------------
#include "sslp.h"

SECURITY_STATUS
NTAPI
SPSignatureCallback(
    ULONG_PTR hProv,
    ULONG_PTR aiHash,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
UploadCertContextCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
UploadCertStoreCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
RemoteCryptAcquireContextCallback(
    ULONG_PTR dwProvType,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
RemoteCryptReleaseContextCallback(
    ULONG_PTR hProv,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
DownloadCertContextCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
GetUserKeysCallback(
    ULONG_PTR dwLsaContext,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SCH_CALLBACK_LIST g_SchannelCallbacks[] =
{
    { SCH_SIGNATURE_CALLBACK,               SPSignatureCallback               },
    { SCH_UPLOAD_CREDENTIAL_CALLBACK,       UploadCertContextCallback         },
    { SCH_UPLOAD_CERT_STORE_CALLBACK,       UploadCertStoreCallback           },
    { SCH_ACQUIRE_CONTEXT_CALLBACK,         RemoteCryptAcquireContextCallback },
    { SCH_RELEASE_CONTEXT_CALLBACK,         RemoteCryptReleaseContextCallback },
    { SCH_DOWNLOAD_CERT_CALLBACK,           DownloadCertContextCallback       },
    { SCH_GET_USER_KEYS,                    GetUserKeysCallback               },
};

DWORD g_cSchannelCallbacks = sizeof(g_SchannelCallbacks) / sizeof(SCH_CALLBACK_LIST);

//+---------------------------------------------------------------------------
//
//  Function:   PerformApplicationCallback
//
//  Synopsis:   Call back to the application process.
//
//  Arguments:  [dwCallback]    --  Callback function number.
//              [dwArg1]        --
//              [dwArg2]        --
//              [pInput]        --
//              [pOutput]       --
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PerformApplicationCallback(
    DWORD dwCallback,
    ULONG_PTR dwArg1,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput,
    BOOL fExpectOutput)
{
    SECURITY_STATUS Status;
    PVOID pvBuffer;

    if(LsaTable == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    pOutput->BufferType = SECBUFFER_EMPTY;
    pOutput->pvBuffer   = NULL;
    pOutput->cbBuffer   = 0;

    try
    {
        Status = LsaTable->ClientCallback((PCHAR)ULongToPtr(dwCallback), // Sundown: dwCallback is a function number.
                                          dwArg1,
                                          dwArg2,
                                          pInput,
                                          pOutput);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    if ( !NT_SUCCESS( Status ) )
    {
        return SP_LOG_RESULT( Status );
    }
    if(Status != SEC_E_OK)
    {
        SP_LOG_RESULT( Status );
        return SEC_E_INTERNAL_ERROR;
    }

    if(pOutput->pvBuffer && pOutput->cbBuffer)
    {
        pvBuffer = SPExternalAlloc(pOutput->cbBuffer);
        if(pvBuffer == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

        Status = LsaTable->CopyFromClientBuffer(NULL,
                                                pOutput->cbBuffer,
                                                pvBuffer,
                                                pOutput->pvBuffer );

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree(pvBuffer);
            return SP_LOG_RESULT( Status );
        }

        Status = SPFreeUserAllocMemory(pOutput->pvBuffer, pOutput->cbBuffer);

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree(pvBuffer);
            return SP_LOG_RESULT( Status );
        }

        pOutput->pvBuffer = pvBuffer;
    } 
    else if(fExpectOutput)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    return Status;
}

#if 0
// This helper function is called by the LSA process in order to duplicate
// a handle belonging to the application process.
BOOL
DuplicateApplicationHandle(
    HANDLE   hAppHandle,
    LPHANDLE phLsaHandle)
{
    SECPKG_CALL_INFO CallInfo;
    HANDLE  hAppProcess;
    HANDLE  hLsaProcess;
    BOOL    fResult;

    // Get handle to application process.
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        return FALSE;
    }
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE,
                              FALSE,
                              CallInfo.ProcessId);
    if(hAppProcess == NULL)
    {
        return FALSE;
    }

    // Get handle to lsa process.
    hLsaProcess = GetCurrentProcess();


    // Duplicate handle
    fResult = DuplicateHandle(hAppProcess,
                              hAppHandle,
                              hLsaProcess,
                              phLsaHandle,
                              0, FALSE,
                              DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);

    CloseHandle(hAppProcess);
    CloseHandle(hLsaProcess);

    return fResult;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   RemoteCryptAcquireContextCallback
//
//  Synopsis:   Obtain a CSP context handle, using the information passed
//              in the input buffer.
//
//  Arguments:  [dwProvType]    --  Provider type.
//              [dwFlags]       --  Flags.
//              [pInput]        --  Buffer containing provider info.
//              [pOutput]       --  Buffer containing CSP context handle.
//
//  History:    09-24-97   jbanes   Created
//
//  Notes:      The structure of the input buffer is as follows:
//
//                  cbContainerName
//                  cbProvName
//                  wszContainerName
//                  wszProvName
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
RemoteCryptAcquireContextCallback(
    ULONG_PTR dwProvType,       // in
    ULONG_PTR dwFlags,          // in
    SecBuffer *pInput,          // in
    SecBuffer *pOutput)         // out
{
    LPWSTR      pwszContainerName;
    DWORD       cbContainerName;
    LPWSTR      pwszProvName;
    DWORD       cbProvName;
    HCRYPTPROV  hProv;
    LPBYTE      pbBuffer;
    DWORD       cbBuffer;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "RemoteCryptAcquireContextCallback\n"));

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    if(pInput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    // Parse input buffer.
    pbBuffer = pInput->pvBuffer;
    cbBuffer = pInput->cbBuffer;

    if(cbBuffer < sizeof(DWORD) * 2)
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_MESSAGE);
    }

    cbContainerName = *(DWORD *)pbBuffer;
    pbBuffer += sizeof(DWORD);

    cbProvName = *(DWORD *)pbBuffer;
    pbBuffer += sizeof(DWORD);

    if(cbBuffer < sizeof(DWORD) * 2 + cbContainerName + cbProvName)
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_MESSAGE);
    }

    if(cbContainerName)
    {
        pwszContainerName = (LPWSTR)pbBuffer;
    }
    else
    {
        pwszContainerName = NULL;
    }
    pbBuffer += cbContainerName;

    if(cbProvName)
    {
        pwszProvName = (LPWSTR)pbBuffer;
    }
    else
    {
        pwszProvName = NULL;
    }


    // HACKHACK - clear the smart-card specific flag.
    dwFlags &= ~CERT_SET_KEY_CONTEXT_PROP_ID;


    DebugLog((SP_LOG_TRACE, "Container:%ls\n",     pwszContainerName));
    DebugLog((SP_LOG_TRACE, "Provider: %ls\n",     pwszProvName));
    DebugLog((SP_LOG_TRACE, "Type:     0x%8.8x\n", dwProvType));
    DebugLog((SP_LOG_TRACE, "Flags:    0x%8.8x\n", dwFlags));

    // Attempt to get CSP context handle.
    if(!CryptAcquireContextW(&hProv,
                             pwszContainerName,
                             pwszProvName,
                             (DWORD) dwProvType,
                             (DWORD) dwFlags))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    // Allocate memory for the output buffer.
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(HCRYPTPROV);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Place hProv in output buffer.
    *(HCRYPTPROV *)pOutput->pvBuffer = hProv;

    return SEC_E_OK;
}


NTSTATUS
RemoteCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR     pwszContainerName,
    LPCWSTR     pwszProvName,
    DWORD       dwProvType,
    DWORD       dwFlags)
{
    SecBuffer Input;
    SecBuffer Output;
    DWORD cbContainerName;
    DWORD cbProvName;
    PBYTE pbBuffer;
    SECURITY_STATUS scRet;

    // Build input buffer.
    if(pwszContainerName)
    {
        cbContainerName = (lstrlenW(pwszContainerName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbContainerName = 0;
    }
    if(pwszProvName)
    {
        cbProvName = (lstrlenW(pwszProvName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbProvName = 0;
    }

    Input.BufferType  = SECBUFFER_DATA;
    Input.cbBuffer    = sizeof(DWORD) + 
                        sizeof(DWORD) +
                        cbContainerName +
                        cbProvName;
    SafeAllocaAllocate(Input.pvBuffer, Input.cbBuffer);
    if(Input.pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pbBuffer = Input.pvBuffer;

    *(DWORD *)pbBuffer = cbContainerName;
    pbBuffer += sizeof(DWORD);
    *(DWORD *)pbBuffer = cbProvName;
    pbBuffer += sizeof(DWORD);

    CopyMemory(pbBuffer, pwszContainerName, cbContainerName);
    pbBuffer += cbContainerName;

    CopyMemory(pbBuffer, pwszProvName, cbProvName);
    pbBuffer += cbProvName;


    // Do callback.
    scRet = PerformApplicationCallback( SCH_ACQUIRE_CONTEXT_CALLBACK,
                                        dwProvType,
                                        dwFlags,
                                        &Input,
                                        &Output,
                                        TRUE);
    if(!NT_SUCCESS(scRet))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x calling remote CryptAcquireContext\n", scRet));
        SafeAllocaFree(Input.pvBuffer);
        return scRet;
    }

    // Get hProv from output buffer.
    *phProv = *(HCRYPTPROV *)Output.pvBuffer;

    DebugLog((SP_LOG_TRACE, "Remote CSP handle retrieved (0x%x)\n", *phProv));

    SafeAllocaFree(Input.pvBuffer);
    SPExternalFree(Output.pvBuffer);

    return SEC_E_OK;
}


SECURITY_STATUS
RemoteCryptReleaseContextCallback(
    ULONG_PTR hProv,        // in
    ULONG_PTR dwFlags,      // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    UNREFERENCED_PARAMETER(pInput);

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "RemoteCryptReleaseContextCallback\n"));

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    if(!CryptReleaseContext((HCRYPTPROV)hProv, (DWORD)dwFlags))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    return SEC_E_OK;
}


BOOL
RemoteCryptReleaseContext(
    HCRYPTPROV  hProv,
    DWORD       dwFlags)
{
    SecBuffer Input;
    SecBuffer Output;
    DWORD Status;

    Input.BufferType = SECBUFFER_DATA;
    Input.cbBuffer   = 0;
    Input.pvBuffer   = NULL;

    Status = PerformApplicationCallback(SCH_RELEASE_CONTEXT_CALLBACK,
                                        (ULONG_PTR) hProv,
                                        (ULONG_PTR) dwFlags,
                                        &Input,
                                        &Output,
                                        FALSE);
    if(!NT_SUCCESS(Status))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x releasing crypto context!\n", Status));
        SetLastError(Status);
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   UploadCertContextCallback
//
//  Synopsis:   Transfer a cert context structure from the application
//              process to the LSA process.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//
//              [pInput]    -- Buffer containing a cert context structure.
//
//              [pOutput]   -- Buffer containing the serialized certificate
//                             context, etc.
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  HCRYPTPROV  hProv;
//                  DWORD       cbSerializedCertContext;
//                  PVOID       pvSerializedCertContext;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UploadCertContextCallback(
    ULONG_PTR Argument1,        // in
    ULONG_PTR Argument2,        // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    PCCERT_CONTEXT  pCertContext;
    HCRYPTPROV      hProv;

    DWORD           cbProvHandle;
    DWORD           cbCertContext;
    PBYTE           pbBuffer;
    SECURITY_STATUS scRet = SEC_E_UNKNOWN_CREDENTIALS;

    UNREFERENCED_PARAMETER(Argument1);
    UNREFERENCED_PARAMETER(Argument2);

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "UploadCertContextCallback\n"));

    if(pInput->cbBuffer != sizeof(PCCERT_CONTEXT *) || pInput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_MESSAGE);
    }
    
    pCertContext = *(PCCERT_CONTEXT *)pInput->pvBuffer;

    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;
    pOutput->BufferType = SECBUFFER_DATA;

    // Attempt to read the hProv associated with the cert context.
    cbProvHandle = sizeof(HCRYPTPROV);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_HANDLE_PROP_ID,
                                          (PVOID)&hProv,
                                          &cbProvHandle))
    {
        hProv = 0;
        cbProvHandle = sizeof(HCRYPTPROV);
    }

    // Determine the size of the serialized cert context.
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    NULL,
                    &cbCertContext))
    {
        scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto Return;
    }


    //
    // Build output buffer.
    //

    // Allocate memory for the output buffer.
    pOutput->cbBuffer = sizeof(HCRYPTPROV) +
                        sizeof(DWORD) + cbCertContext;
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Return;
    }
    pbBuffer = pOutput->pvBuffer;

    // Place hProv in output buffer.
    *(HCRYPTPROV *)pbBuffer = hProv;
    pbBuffer += sizeof(HCRYPTPROV);

    // Place certificate context in output buffer.
    *(DWORD *)pbBuffer = cbCertContext;
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    pbBuffer + sizeof(DWORD),
                    &cbCertContext))
    {
        scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto Return;
    }

    scRet = SEC_E_OK;


Return:

    if(!NT_SUCCESS(scRet) && (NULL != pOutput->pvBuffer))
    {
        SECURITY_STATUS Status;

        Status = FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        SP_ASSERT(NT_SUCCESS(Status));
    }

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   UploadCertStoreCallback
//
//  Synopsis:   Transfer a cert store from the application
//              process to the LSA process, in the form of a serialized
//              certificate store.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//
//              [pInput]    -- Buffer containing a HCERTSTORE handle.
//
//              [pOutput]   -- Buffer containing the serialized cert store.
//
//  History:    02-03-98   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD       cbSerializedCertStore;
//                  PVOID       pvSerializedCertStore;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UploadCertStoreCallback(
    ULONG_PTR Argument1,    // in
    ULONG_PTR Argument2,    // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    HCERTSTORE      hStore;
    CRYPT_DATA_BLOB SaveBlob;
    DWORD           cbCertStore;
    PBYTE           pbBuffer;

    UNREFERENCED_PARAMETER(Argument1);
    UNREFERENCED_PARAMETER(Argument2);

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "UploadCertStoreCallback\n"));

    pOutput->cbBuffer = 0;
    pOutput->pvBuffer = NULL;
    pOutput->BufferType = SECBUFFER_DATA;

    if(pInput->cbBuffer != sizeof(HCERTSTORE) || pInput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    hStore = *(HCERTSTORE *)pInput->pvBuffer;


    // Determine the size of the serialized store.
    SaveBlob.cbData = 0;
    SaveBlob.pbData = NULL;
    if(!CertSaveStore(hStore,
                      X509_ASN_ENCODING,
                      CERT_STORE_SAVE_AS_STORE,
                      CERT_STORE_SAVE_TO_MEMORY,
                      (PVOID)&SaveBlob,
                      0))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }
    cbCertStore = SaveBlob.cbData;


    //
    // Build output buffer.
    //

    // Allocate memory for the output buffer.
    pOutput->cbBuffer = sizeof(DWORD) + cbCertStore;
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    pbBuffer = pOutput->pvBuffer;

    // Place certificate store in output buffer.
    *(DWORD *)pbBuffer = cbCertStore;
    SaveBlob.cbData = cbCertStore;
    SaveBlob.pbData = pbBuffer + sizeof(DWORD);
    if(!CertSaveStore(hStore,
                      X509_ASN_ENCODING,
                      CERT_STORE_SAVE_AS_STORE,
                      CERT_STORE_SAVE_TO_MEMORY,
                      (PVOID)&SaveBlob,
                      0))
    {
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    return SEC_E_OK;
}


SP_STATUS
SignHashUsingCallback(
    HCRYPTPROV  hProv,
    DWORD       dwKeySpec,
    ALG_ID      aiHash,
    PBYTE       pbHash,
    DWORD       cbHash,
    PBYTE       pbSignature,
    PDWORD      pcbSignature,
    DWORD       fHashData)
{
    SecBuffer Input;
    SecBuffer Output;
    SP_STATUS pctRet;

    //
    // Build input buffer.
    //

    Input.BufferType  = SECBUFFER_DATA;
    Input.cbBuffer    = sizeof(DWORD) * 2 + cbHash;
    Input.pvBuffer    = SPExternalAlloc(Input.cbBuffer);
    if(Input.pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    memcpy(Input.pvBuffer, (PBYTE)&dwKeySpec, sizeof(DWORD));
    memcpy((PBYTE)Input.pvBuffer + sizeof(DWORD), (PBYTE)&fHashData, sizeof(DWORD));
    memcpy((PBYTE)Input.pvBuffer + sizeof(DWORD) * 2,
           pbHash,
           cbHash);


    //
    // Callback into application process.
    //

    pctRet = PerformApplicationCallback(SCH_SIGNATURE_CALLBACK,
                                        hProv,
                                        aiHash,
                                        &Input,
                                        &Output,
                                        TRUE);

    SPExternalFree(Input.pvBuffer);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    if(Output.cbBuffer > *pcbSignature)
    {
        *pcbSignature = Output.cbBuffer;
        SPExternalFree(Output.pvBuffer);
        return SP_LOG_RESULT(SEC_E_BUFFER_TOO_SMALL);
    }

    *pcbSignature = Output.cbBuffer;
    memcpy(pbSignature, Output.pvBuffer, Output.cbBuffer);

    SPExternalFree(Output.pvBuffer);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SPSignatureCallback
//
//  Synopsis:   Perform signature, using application's hProv
//
//  Arguments:  [hProv]     --
//              [aiHash]    --
//              [pInput]    --
//              [pOutput]   --
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:    This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SPSignatureCallback(ULONG_PTR hProv,            // in
                    ULONG_PTR aiHash,           // in
                    SecBuffer *pInput,      // in
                    SecBuffer *pOutput)     // out
{
    HCRYPTHASH  hHash;
    DWORD       dwKeySpec;
    DWORD       fHashData;
    PBYTE       pbHash;
    DWORD       cbHash;
    SP_STATUS   pctRet;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "SPSignatureCallback\n"));

    //
    // Parse input buffer.
    //

    if(pInput->cbBuffer < sizeof(DWORD) * 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    memcpy(&dwKeySpec, pInput->pvBuffer, sizeof(DWORD));
    memcpy(&fHashData, (PBYTE)pInput->pvBuffer + sizeof(DWORD), sizeof(DWORD));

    pbHash = (PBYTE)pInput->pvBuffer + sizeof(DWORD) * 2;
    cbHash = pInput->cbBuffer - sizeof(DWORD) * 2;


    //
    // Prepare hash object.
    //

    if(!CryptCreateHash(hProv, (ALG_ID)aiHash, 0, 0, &hHash))
    {
        SP_LOG_RESULT( GetLastError() );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }
    if(!fHashData)
    {
        // set hash value
        if(!CryptSetHashParam(hHash, HP_HASHVAL, pbHash, 0))
        {
            SP_LOG_RESULT( GetLastError() );
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }
    else
    {
        if(!CryptHashData(hHash, pbHash, cbHash, 0))
        {
            SP_LOG_RESULT( GetLastError() );
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }


    //
    // Sign hash.
    //

    pOutput->BufferType = SECBUFFER_DATA;

    // Get size of signature
    if(!CryptSignHash(hHash, dwKeySpec, NULL, 0, NULL, &pOutput->cbBuffer))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return pctRet;
    }

    // Allocate memory
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        CryptDestroyHash(hHash);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Sign hash.
    if(!CryptSignHash(hHash, dwKeySpec, NULL, 0, pOutput->pvBuffer, &pOutput->cbBuffer))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return pctRet;
    }

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DownloadCertContextCallBack
//
//  Synopsis:   Transfer a cert context structure from the application
//              process to the LSA process, in the form of a serialized
//              certificate store.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//              [pInput]    --
//              [pOutput]   --
//
//  History:    09-26-97   jbanes   Created
//
//  Notes:      The structure of the input buffer is as follows:
//
//                  DWORD       cbSerializedCertStore;
//                  PVOID       pvSerializedCertStore;
//                  DWORD       cbSerializedCertContext;
//                  PVOID       pvSerializedCertContext;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
DownloadCertContextCallback(
    ULONG_PTR Argument1,    // in
    ULONG_PTR Argument2,    // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    PCCERT_CONTEXT  pCertContext;
    SECURITY_STATUS scRet;

    UNREFERENCED_PARAMETER(Argument1);
    UNREFERENCED_PARAMETER(Argument2);

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "DownloadCertContextCallback\n"));

    // Allocate memory for output buffer.
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(PVOID);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
    }

    // Deserialize buffer.
    scRet = DeserializeCertContext(&pCertContext,
                                   pInput->pvBuffer,
                                   pInput->cbBuffer);
    if(FAILED(scRet))
    {
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return SP_LOG_RESULT( scRet );
    }

    // Place cert context pointer in output buffer.
    *(PCCERT_CONTEXT *)pOutput->pvBuffer = pCertContext;


    return SEC_E_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SerializeCertContext
//
//  Synopsis:   Serialize the specified certificate context, along with its
//              associated certificate store.
//
//  Arguments:  [pCertContext]  --
//              [pbBuffer]      --
//              [pcbBuffer]     --
//
//  History:    09-26-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD       cbSerializedCertStore
//                  PVOID       pvSerializedCertStore
//                  DWORD       cbSerializedCertContext
//                  PVOID       pvSerializedCertContext
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SerializeCertContext(
    PCCERT_CONTEXT pCertContext,    // in
    PBYTE          pbBuffer,        // out
    PDWORD         pcbBuffer)       // out
{
    CRYPT_DATA_BLOB SaveBlob;
    DWORD           cbCertContext;
    DWORD           cbCertStore;
    DWORD           cbBuffer;

    if(pCertContext == NULL)
    {
        *pcbBuffer = 0;
        return SEC_E_OK;
    }

    // Determine the size of the serialized cert context.
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    NULL,
                    &cbCertContext))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    // Determine the size of the serialized store.
    if(pCertContext->hCertStore)
    {
        SaveBlob.cbData = 0;
        SaveBlob.pbData = NULL;
        if(!CertSaveStore(pCertContext->hCertStore,
                          X509_ASN_ENCODING,
                          CERT_STORE_SAVE_AS_STORE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          (PVOID)&SaveBlob,
                          0))
        {
            return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        }
        cbCertStore = SaveBlob.cbData;
    }
    else
    {
        cbCertStore = 0;
    }

    cbBuffer = sizeof(DWORD) + cbCertContext +
               sizeof(DWORD) + cbCertStore;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = cbBuffer;
        return SEC_E_OK;
    }

    if(*pcbBuffer < cbBuffer)
    {
        return SP_LOG_RESULT(SEC_E_BUFFER_TOO_SMALL);
    }

    // Set output values.
    *pcbBuffer = cbBuffer;


    // Place certificate store in output buffer.
    *(DWORD *)pbBuffer = cbCertStore;
    if(pCertContext->hCertStore)
    {
        SaveBlob.cbData = cbCertStore;
        SaveBlob.pbData = pbBuffer + sizeof(DWORD);
        if(!CertSaveStore(pCertContext->hCertStore,
                          X509_ASN_ENCODING,
                          CERT_STORE_SAVE_AS_STORE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          (PVOID)&SaveBlob,
                          0))
        {
            return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        }
    }
    pbBuffer += sizeof(DWORD) + cbCertStore;

    // Place certificate context in output buffer.
    *(DWORD UNALIGNED *)pbBuffer = cbCertContext;
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    pbBuffer + sizeof(DWORD),
                    &cbCertContext))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    return SEC_E_OK;
}

SECURITY_STATUS
DeserializeCertContext(
    PCCERT_CONTEXT *ppCertContext,  // out
    PBYTE           pbBuffer,       // in
    DWORD           cbBuffer)       // in
{
    CRYPT_DATA_BLOB Serialized;
    HCERTSTORE  hStore;
    DWORD cbCertContext;

    if(cbBuffer < sizeof(DWORD))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    //
    // Deserialize certificate store.
    //

    Serialized.cbData = *(DWORD *)pbBuffer;
    Serialized.pbData = pbBuffer + sizeof(DWORD);

    if(cbBuffer < sizeof(DWORD) + Serialized.cbData)
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    hStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                            X509_ASN_ENCODING,
                            0,
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                            &Serialized);
    if(hStore == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }
    pbBuffer += sizeof(DWORD) + Serialized.cbData;
    cbBuffer -= sizeof(DWORD) + Serialized.cbData;


    //
    // Deserialize certificate context.
    //

    if(cbBuffer < sizeof(DWORD))
    {
        CertCloseStore(hStore, 0);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    cbCertContext = *(DWORD UNALIGNED *)pbBuffer;

    if(cbBuffer < sizeof(DWORD) + cbCertContext)
    {
        CertCloseStore(hStore, 0);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    if(!CertAddSerializedElementToStore(hStore,
                                        pbBuffer + sizeof(DWORD),
                                        cbCertContext,
                                        CERT_STORE_ADD_USE_EXISTING,
                                        0,
                                        CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                        NULL,
                                        ppCertContext))
    {
        CertCloseStore(hStore, 0);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    if(!CertCloseStore(hStore, 0))
    {
        SP_LOG_RESULT(GetLastError());
    }

    return SEC_E_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SPGetApplicationKeys
//
//  Synopsis:   Callback to the user process and retrieve the user encryption
//              keys.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [dwFlags]   --  SCH_FLAG_READ_KEY, SCH_FLAG_WRITE_KEY
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
SPGetUserKeys(
    PSPContext  pContext,
    DWORD       dwFlags)
{
    PBYTE pbBuffer;
    PBYTE pbReadKey;
    DWORD cbReadKey;
    PBYTE pbWriteKey;
    DWORD cbWriteKey;
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;
    BOOL fWow64Client = FALSE;

#ifdef _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    //
    // Call back into the application process and get the keys, in the
    // form of 2 opaque blobs.
    //

    DebugLog((SP_LOG_TRACE, "SPGetUserKeys: 0x%p, %d\n", pContext, dwFlags));

    if(LsaTable == NULL)
    {
        // We're probably being called from the application process.
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }


#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        scRet = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(scRet);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    if(fWow64Client)
    {
        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = sizeof(pContext->ContextThumbprint);
        Input.pvBuffer   = &pContext->ContextThumbprint;
    }
    else
    {
        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;
    }

    scRet = PerformApplicationCallback( SCH_GET_USER_KEYS,
                                        (ULONG_PTR) pContext,
                                        (ULONG_PTR) dwFlags,
                                        &Input,
                                        &Output,
                                        TRUE);
    if(!NT_SUCCESS(scRet))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x retrieving user keys\n", scRet));
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    //
    // Parse output buffer
    //

    pbBuffer = Output.pvBuffer;

    if(Output.cbBuffer < sizeof(DWORD) * 4)
    {
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        pContext->ReadCounter = *(PDWORD)pbBuffer;
    }
    pbBuffer += sizeof(DWORD);

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        pContext->WriteCounter = *(PDWORD)pbBuffer;
    }
    pbBuffer += sizeof(DWORD);

    cbReadKey = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    cbWriteKey = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    if(Output.cbBuffer < sizeof(DWORD) * 4 + cbReadKey + cbWriteKey)
    {
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }

    pbReadKey = pbBuffer;
    pbBuffer += cbReadKey;

    pbWriteKey = pbBuffer;
    pbBuffer += cbWriteKey;

    SP_ASSERT(pbBuffer - (PBYTE)Output.pvBuffer == (INT)Output.cbBuffer);

    //
    // Place keys into context structure.
    //

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(cbReadKey)
        {
            if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                               pbReadKey,
                               cbReadKey,
                               0,
                               CRYPT_EXPORTABLE,
                               &pContext->hReadKey))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = PCT_INT_INTERNAL_ERROR;
                goto done;
            }
        }
        else
        {
            pContext->hReadKey = 0;
        }
    }

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(cbWriteKey)
        {
            if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                               pbWriteKey,
                               cbWriteKey,
                               0,
                               CRYPT_EXPORTABLE,
                               &pContext->hWriteKey))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = PCT_INT_INTERNAL_ERROR;
                goto done;
            }
        }
        else
        {
            pContext->hWriteKey = 0;
        }
    }

done:

    SPExternalFree(Output.pvBuffer);

    return scRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUserKeysCallback
//
//  Synopsis:   Find the user context that corresponds to the passed in LSA
//              context, serialize the encryption keys, and return them in
//              the output buffer.
//
//  Arguments:  [dwLsaContext]  --  Pointer to LSA Schannel context.
//              [dwFlags]       --  SCH_FLAG_READ_KEY, SCH_FLAG_WRITE_KEY
//              [pInput]        --  Not used.
//              [pOutput]       --  (output) Serialized keys.
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD   dwReadSequence;
//                  DWORD   dwWriteSequence;
//                  DWORD   cbReadKey;
//                  BYTE    rgbReadKey[];
//                  DWORD   cbWriteKey;
//                  BYTE    rgbWriteKey[];
//
//----------------------------------------------------------------------------
SECURITY_STATUS
GetUserKeysCallback(
    ULONG_PTR dwLsaContext,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    DWORD       cbReadKey  = 0;
    DWORD       cbWriteKey = 0;
    DWORD       cbData;
    PBYTE       pbBuffer;
    DWORD       cbBuffer;
    PSPContext  pContext;
    PSSL_USER_CONTEXT pUserContext;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "GetUserKeysCallback\n"));

    //
    // Find the user context.
    //

    if(pInput->pvBuffer != NULL &&
       pInput->cbBuffer == sizeof(CRED_THUMBPRINT))
    {
        // Search for matching context thumbprint.
        pUserContext = SslFindUserContextEx((PCRED_THUMBPRINT)pInput->pvBuffer);
        if(pUserContext == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }
    }
    else
    {
        // Search for matching lsa context
        pUserContext = SslFindUserContext(dwLsaContext);
        if(pUserContext == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }
    }

    pContext = pUserContext->pContext;
    if(pContext == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INTERNAL_ERROR );
    }

    //
    // Compute size of output buffer.
    //

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            if(!pContext->hReadKey)
            {
                return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
            }
            if(!CryptExportKey(pContext->hReadKey,
                               0, OPAQUEKEYBLOB, 0,
                               NULL,
                               &cbReadKey))
            {
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
        }
        else
        {
            cbReadKey = 0;
        }
    }

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            if(!pContext->hWriteKey)
            {
                return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
            }
            if(!CryptExportKey(pContext->hWriteKey,
                               0, OPAQUEKEYBLOB, 0,
                               NULL,
                               &cbWriteKey))
            {
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
        }
        else
        {
            cbWriteKey = 0;
        }
    }

    cbBuffer = sizeof(DWORD) +
               sizeof(DWORD) +
               sizeof(DWORD) + cbReadKey +
               sizeof(DWORD) + cbWriteKey;

    // Allocate memory for output buffer.
    pbBuffer = PvExtVirtualAlloc( cbBuffer);
    if(pbBuffer == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
    }
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = cbBuffer;
    pOutput->pvBuffer   = pbBuffer;

    //
    // Serialize keys.
    //

    *(PDWORD)pbBuffer = pContext->ReadCounter;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = pContext->WriteCounter;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = cbReadKey;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = cbWriteKey;
    pbBuffer += sizeof(DWORD);

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            cbData = cbReadKey;
            if(!CryptExportKey(pContext->hReadKey,
                               0, OPAQUEKEYBLOB, 0,
                               pbBuffer,
                               &cbData))
            {
                FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
            if(!CryptDestroyKey(pContext->hReadKey))
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
        pContext->hReadKey = 0;
    }
    pbBuffer += cbReadKey;


    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            cbData = cbWriteKey;
            if(!CryptExportKey(pContext->hWriteKey,
                               0, OPAQUEKEYBLOB, 0,
                               pbBuffer,
                               &cbData))
            {
                FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
            if(!CryptDestroyKey(pContext->hWriteKey))
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
        pContext->hWriteKey = 0;
    }
    pbBuffer += cbWriteKey;

    return SEC_E_OK;
}


// Always called from callback routine (in the application process).
VOID *
PvExtVirtualAlloc(DWORD cb)
{
    SECURITY_STATUS Status;
    PVOID pv = NULL;
    SIZE_T Size = cb;

    Status = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &pv,
                            0,
                            &Size,
                            MEM_COMMIT,
                            PAGE_READWRITE);
    if(!NT_SUCCESS(Status))
    {
        pv = NULL;
    }

    DebugLog((DEB_TRACE, "SslCallbackVirtualAlloc: 0x%x bytes at 0x%x\n", cb, pv));

    return(pv);
}

// Always called from callback routine (in the application process),
// typically when an error occurs and we're cleaning up.
SECURITY_STATUS
FreeExtVirtualAlloc(PVOID pv, SIZE_T cbMem)
{
    cbMem = 0;
    return(NtFreeVirtualMemory(GetCurrentProcess(),
                                &pv,
                                &cbMem,
                                MEM_RELEASE));
}

// Always called from the LSA process, when freeing memory allocated
// by a callback function.
SECURITY_STATUS
SPFreeUserAllocMemory(PVOID pv, SIZE_T cbMem)
{
    SECPKG_CALL_INFO CallInfo;

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        SECURITY_STATUS Status;
        HANDLE hProcess;

        hProcess = OpenProcess(PROCESS_VM_OPERATION,
                               FALSE,
                               CallInfo.ProcessId);
        if(hProcess == NULL)
        {
            return SP_LOG_RESULT(GetLastError());
        }

        cbMem = 0;
        Status = NtFreeVirtualMemory(hProcess,
                                     &pv,
                                     &cbMem,
                                     MEM_RELEASE);
        if(!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
        }

        CloseHandle(hProcess);
    }

    DebugLog((DEB_TRACE, "SslCallbackVirtualFree: 0x%x bytes at 0x%x\n", cbMem, pv));

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\credapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       credapi.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-18-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include "mapper.h"
#include "rpc.h"
#include <sslwow64.h>

typedef struct _SCH_CRED_SECRET {
    union {
        SCH_CRED_SECRET_CAPI        Capi;
        SCH_CRED_SECRET_PRIVKEY     PrivKey;
    } u;
} SCH_CRED_SECRET, * PSCH_CRED_SECRET ;

extern CHAR CertTag[ 13 ];

//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Ansi or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString;
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;
    TemporaryString.Buffer = NULL;


    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            *DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize > 0xFFFF) ||
                 ((SourceSize - CharacterSize) > 0xFFFF)
                 )
            {
                Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) LocalAlloc(LPTR, SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                SP_LOG_RESULT(Status);
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;
            }
            else
            {
                NTSTATUS Status1;
                Status1 = RtlAnsiStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            TRUE
                            );      // allocate destination
                if (!NT_SUCCESS(Status1))
                {
                    Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer != NULL)
    {
        //
        // Free this if we failed and were doing unicode or if we weren't
        // doing unicode
        //

        if ((DoUnicode && !NT_SUCCESS(Status)) || !DoUnicode)
        {
            LocalFree(TemporaryString.Buffer);
        }
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   Accept Credentials - logon notification
//
//  Arguments:  [LogonType]         --
//              [UserName]          --
//              [PrimaryCred]       --
//              [SupplementalCreds] --
//
//  History:    10-04-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{
    UNREFERENCED_PARAMETER(LogonType);
    UNREFERENCED_PARAMETER(UserName);
    UNREFERENCED_PARAMETER(PrimaryCred);
    UNREFERENCED_PARAMETER(SupplementalCreds);

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpMapSchPublic
//
//  Synopsis:   Maps a public key credential into LSA memory
//
//  Arguments:  [pRemotePubs] --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
SpMapSchPublic(
    PVOID   pRemotePubs
    )
{
    SECURITY_STATUS Status ;
    SCH_CRED_PUBLIC_CERTCHAIN Pub, * pPub ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( SCH_CRED_PUBLIC_CERTCHAIN ),
                                             &Pub,
                                             pRemotePubs );

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    // Reality check
    if(Pub.cbCertChain > 0x00100000)
    {
        return( NULL );
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            Pub.cbCertChain );

    if ( pPub )
    {
        pPub->dwType = Pub.dwType ;
        pPub->cbCertChain = Pub.cbCertChain ;
        pPub->pCertChain = (PUCHAR) ( pPub + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Pub.cbCertChain,
                                                 pPub->pCertChain,
                                                 Pub.pCertChain );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        return( pPub );
    }

    if ( pPub )
    {
        SPExternalFree( pPub );
    }

    return( NULL );
}

#ifdef _WIN64
PVOID
SpWow64MapSchPublic(
    SSLWOW64_PVOID pRemotePubs)
{
    SECURITY_STATUS Status;
    SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN Pub;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN ),
                                             &Pub,
                                             ULongToPtr(pRemotePubs));
    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    // Reality check
    if(Pub.cbCertChain > 0x00100000)
    {
        return( NULL );
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            Pub.cbCertChain );

    if ( pPub )
    {
        pPub->dwType = Pub.dwType ;
        pPub->cbCertChain = Pub.cbCertChain ;
        pPub->pCertChain = (PUCHAR) ( pPub + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Pub.cbCertChain,
                                                 pPub->pCertChain,
                                                 ULongToPtr(Pub.pCertChain));
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        return( pPub );
    }

    if ( pPub )
    {
        SPExternalFree( pPub );
    }

    return( NULL );
}
#endif // _WIN64


PVOID
SpMapSchCred(
    PVOID   pRemoteCred )
{
    SCH_CRED_SECRET Cred ;
    SECURITY_STATUS Status ;
    DWORD   Size ;
    DWORD   dwType;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( DWORD ),
                                             &Cred,
                                             pRemoteCred );

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    dwType = Cred.u.Capi.dwType;

    switch ( dwType )
    {
        case SCHANNEL_SECRET_TYPE_CAPI:
            Size = sizeof( SCH_CRED_SECRET_CAPI );
            break;

        case SCHANNEL_SECRET_PRIVKEY:
            Size = sizeof( SCH_CRED_SECRET_PRIVKEY );
            break;

        default:
            DebugOut(( DEB_ERROR, "Caller specified an unknown cred type\n" ));
            return( NULL );
    }

    if ( Size )
    {
        Status = LsaTable->CopyFromClientBuffer(NULL,
                                                Size,
                                                &Cred,
                                                pRemoteCred );
    }
    else
    {
        Status = SEC_E_INVALID_HANDLE ;
    }
    if(dwType != Cred.u.Capi.dwType)
    {
        Status = SEC_E_INVALID_HANDLE ;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    if(Cred.u.Capi.dwType == SCHANNEL_SECRET_TYPE_CAPI)
    {
        SCH_CRED_SECRET_CAPI *pCapiCred;

        pCapiCred = SPExternalAlloc( Size );
        if ( !pCapiCred )
        {
            return( NULL );
        }

        pCapiCred->dwType = Cred.u.Capi.dwType;
        pCapiCred->hProv  = Cred.u.Capi.hProv;

        return( pCapiCred );
    }

    if(Cred.u.Capi.dwType == SCHANNEL_SECRET_PRIVKEY)
    {
        UCHAR   Password[ MAX_PATH + 1 ];
        DWORD   PasswordLen = 0;
        SCH_CRED_SECRET_PRIVKEY *pCred;

        //
        //  The password is the painful part.  Since it is a string, we don't know
        //  how long it is.  So, we have to take a stab at it:
        //

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 MAX_PATH,
                                                 Password,
                                                 Cred.u.PrivKey.pszPassword );

        if ( !NT_SUCCESS( Status ) )
        {
            return( NULL );
        }

        Password[ MAX_PATH ] = '\0';

        PasswordLen = lstrlenA( (LPSTR)Password );

        // Reality check private key length.
        if(Cred.u.PrivKey.cbPrivateKey > 0x10000)
        {
            return( NULL );
        }

        Size = PasswordLen + 1 + Cred.u.PrivKey.cbPrivateKey +
                sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

        pCred = SPExternalAlloc(  Size );

        if ( !pCred )
        {
            return( NULL );
        }

        pCred->dwType = Cred.u.PrivKey.dwType ;
        pCred->cbPrivateKey = Cred.u.PrivKey.cbPrivateKey ;
        pCred->pPrivateKey = (PBYTE) ( pCred + 1 );
        pCred->pszPassword = (LPSTR) (pCred->pPrivateKey + pCred->cbPrivateKey );

        RtlCopyMemory( pCred->pszPassword, Password, PasswordLen + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 pCred->cbPrivateKey,
                                                 pCred->pPrivateKey,
                                                 Cred.u.PrivKey.pPrivateKey );

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree( pCred );
            return( NULL );
        }

        return( pCred );
    }

    return( NULL );
}

#ifdef _WIN64
PVOID
SpWow64MapSchCred(
    SSLWOW64_PVOID pRemoteCred )
{
    SSLWOW64_SCH_CRED_SECRET_PRIVKEY LocalCred;
    SCH_CRED_SECRET_PRIVKEY *pCred;
    CHAR Password[MAX_PATH + 1];
    DWORD PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD dwType;
    DWORD Size;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( DWORD ),
                                             &dwType,
                                             ULongToPtr(pRemoteCred));

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    if(dwType != SCHANNEL_SECRET_PRIVKEY)
    {
        DebugOut(( DEB_ERROR, "Caller specified an unknown cred type\n" ));
        return( NULL );
    }

    Status = LsaTable->CopyFromClientBuffer(NULL,
                                            sizeof(SSLWOW64_SCH_CRED_SECRET_PRIVKEY),
                                            &LocalCred,
                                            ULongToPtr(pRemoteCred));
    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    //
    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             ULongToPtr(LocalCred.pszPassword));

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = lstrlenA( Password );

    // Reality check private key length.
    if(LocalCred.cbPrivateKey > 0x10000)
    {
        return( NULL );
    }

    Size = PasswordLen + 1 + LocalCred.cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pCred = SPExternalAlloc(  Size );

    if ( !pCred )
    {
        return( NULL );
    }

    pCred->dwType = SCHANNEL_SECRET_PRIVKEY;
    pCred->cbPrivateKey = LocalCred.cbPrivateKey ;
    pCred->pPrivateKey = (PBYTE) ( pCred + 1 );
    pCred->pszPassword = (LPSTR) (pCred->pPrivateKey + pCred->cbPrivateKey );

    RtlCopyMemory( pCred->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pCred->cbPrivateKey,
                                             pCred->pPrivateKey,
                                             ULongToPtr(LocalCred.pPrivateKey));

    if ( !NT_SUCCESS( Status ) )
    {
        SPExternalFree( pCred );
        return( NULL );
    }

    return( pCred );
}
#endif // _WIN64


VOID
SpFreeVersion2Certificate(
    SCH_CRED *  pCred
    )
{
    DWORD i;

    for ( i = 0 ; i < pCred->cCreds ; i++ )
    {
        if ( pCred->paSecret[ i ] )
        {
            SPExternalFree( pCred->paSecret[ i ] );
        }

        if ( pCred->paPublic[ i ] )
        {
            SPExternalFree( pCred->paPublic[ i ] );
        }
    }

    SPExternalFree( pCred );
}

VOID
SpFreeVersion3Certificate(
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    DWORD i;

    if(pSchannelCred->paSubCred)
    {
        for(i = 0; i < pSchannelCred->cSubCreds; i++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred = pSchannelCred->paSubCred + i;

            if(pSubCred->pCert)
            {
                CertFreeCertificateContext(pSubCred->pCert);
            }
            if(pSubCred->pszPin)
            {
                SPExternalFree(pSubCred->pszPin);
            }
            if(pSubCred->pPrivateKey)
            {
                SPExternalFree(pSubCred->pPrivateKey);
            }
            if(pSubCred->pszPassword)
            {
                SPExternalFree(pSubCred->pszPassword);
            }
            memset(pSubCred, 0, sizeof(LSA_SCHANNEL_SUB_CRED));
        }
        SPExternalFree((PVOID)pSchannelCred->paSubCred);
        pSchannelCred->paSubCred = NULL;
    }

    if(pSchannelCred->hRootStore)
    {
        CertCloseStore(pSchannelCred->hRootStore, 0);
        pSchannelCred->hRootStore = 0;
    }

    if(pSchannelCred->palgSupportedAlgs)
    {
        SPExternalFree(pSchannelCred->palgSupportedAlgs);
        pSchannelCred->palgSupportedAlgs = 0;
    }

    ZeroMemory(pSchannelCred, sizeof(SCHANNEL_CRED));
}


SECURITY_STATUS
SpMapProtoCredential(
    SSL_CREDENTIAL_CERTIFICATE *pSslCert,
    PSCH_CRED *ppSchCred)
{
    SCH_CRED *                  pCred = NULL;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub  = NULL;
    SCH_CRED_SECRET_PRIVKEY *   pPriv = NULL;
    CHAR    Password[ MAX_PATH + 1 ];
    DWORD   PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD Size;

#if DBG
    DebugLog((DEB_TRACE, "SpMapProtoCredential\n"));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)pSslCert, sizeof(SSL_CREDENTIAL_CERTIFICATE));
#endif


    //
    // Map over the certificate.
    // 

    // Reality check
    if(pSslCert->cbCertificate > 0x00100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            pSslCert->cbCertificate );

    if ( pPub == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub->dwType      = SCH_CRED_X509_CERTCHAIN;
    pPub->cbCertChain = pSslCert->cbCertificate;
    pPub->pCertChain  = (PUCHAR) ( pPub + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbCertificate,
                                             pPub->pCertChain,
                                             pSslCert->pCertificate );
    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Map over the private key and password.
    //
    //

    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             pSslCert->pszPassword );

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = lstrlenA( Password );

    // Reality check private key length.
    if(pSslCert->cbPrivateKey > 0x100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    Size = PasswordLen + 1 + pSslCert->cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pPriv = SPExternalAlloc(  Size );

    if(pPriv == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPriv->dwType       = SCHANNEL_SECRET_PRIVKEY;
    pPriv->cbPrivateKey = pSslCert->cbPrivateKey ;
    pPriv->pPrivateKey  = (PBYTE) ( pPriv + 1 );
    pPriv->pszPassword  = (LPSTR) (pPriv->pPrivateKey + pPriv->cbPrivateKey );

    RtlCopyMemory( pPriv->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbPrivateKey,
                                             pPriv->pPrivateKey,
                                             pSslCert->pPrivateKey );

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Allocate SCH_CRED structure.
    //

    pCred = SPExternalAlloc(sizeof(SCH_CRED) + 2 * sizeof(PVOID));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pCred->dwVersion = SCH_CRED_VERSION ;
    pCred->cCreds    = 1 ;
    pCred->paSecret  = (PVOID) ( pCred + 1 );
    pCred->paPublic  = (PVOID) ( pCred->paSecret + 1 );

    pCred->paSecret[0] = pPriv;
    pCred->paPublic[0] = pPub;

    *ppSchCred = pCred;

    return SEC_E_OK;

error:
    if(pCred) SPExternalFree(pCred);
    if(pPub)  SPExternalFree(pPub);
    if(pPriv) SPExternalFree(pPriv);

    return Status;
}


#ifdef _WIN64
SECURITY_STATUS
SpWow64MapProtoCredential(
    SSLWOW64_CREDENTIAL_CERTIFICATE *pSslCert,
    PSCH_CRED *ppSchCred)
{
    SCH_CRED *                  pCred = NULL;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub  = NULL;
    SCH_CRED_SECRET_PRIVKEY *   pPriv = NULL;
    CHAR    Password[ MAX_PATH + 1 ];
    DWORD   PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD Size;

#if DBG
    DebugLog((DEB_TRACE, "SpWow64MapProtoCredential\n"));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)pSslCert, sizeof(SSLWOW64_CREDENTIAL_CERTIFICATE));
#endif


    //
    // Map over the certificate.
    // 

    // Reality check
    if(pSslCert->cbCertificate > 0x00100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            pSslCert->cbCertificate );

    if ( pPub == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub->dwType      = SCH_CRED_X509_CERTCHAIN;
    pPub->cbCertChain = pSslCert->cbCertificate;
    pPub->pCertChain  = (PUCHAR) ( pPub + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbCertificate,
                                             pPub->pCertChain,
                                             ULongToPtr(pSslCert->pCertificate));
    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Map over the private key and password.
    //
    //

    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             ULongToPtr(pSslCert->pszPassword));

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = lstrlenA( Password );

    // Reality check private key length.
    if(pSslCert->cbPrivateKey > 0x100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    Size = PasswordLen + 1 + pSslCert->cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pPriv = SPExternalAlloc(  Size );

    if(pPriv == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPriv->dwType       = SCHANNEL_SECRET_PRIVKEY;
    pPriv->cbPrivateKey = pSslCert->cbPrivateKey ;
    pPriv->pPrivateKey  = (PBYTE) ( pPriv + 1 );
    pPriv->pszPassword  = (LPSTR) (pPriv->pPrivateKey + pPriv->cbPrivateKey );

    RtlCopyMemory( pPriv->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbPrivateKey,
                                             pPriv->pPrivateKey,
                                             ULongToPtr(pSslCert->pPrivateKey));

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Allocate SCH_CRED structure.
    //

    pCred = SPExternalAlloc(sizeof(SCH_CRED) + 2 * sizeof(PVOID));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pCred->dwVersion = SCH_CRED_VERSION ;
    pCred->cCreds    = 1 ;
    pCred->paSecret  = (PVOID) ( pCred + 1 );
    pCred->paPublic  = (PVOID) ( pCred->paSecret + 1 );

    pCred->paSecret[0] = pPriv;
    pCred->paPublic[0] = pPub;

    *ppSchCred = pCred;

    return SEC_E_OK;

error:
    if(pCred) SPExternalFree(pCred);
    if(pPub)  SPExternalFree(pPub);
    if(pPriv) SPExternalFree(pPriv);

    return Status;
}
#endif // _WIN64


SECURITY_STATUS
SpMapVersion2Certificate(
    PVOID       pvAuthData,
    SCH_CRED * *ppCred
    )
{
    SECURITY_STATUS Status ;
    SCH_CRED    Cred;
    PSCH_CRED   pCred;
    DWORD       Size;
    DWORD       i;
    BOOL        Failed = FALSE ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                            sizeof( SCH_CRED ),
                                            &Cred,
                                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

#if DBG
    DebugLog((DEB_TRACE, "SpMapVersion2Certificate: %d certificates in cred\n", Cred.cCreds));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)&Cred, sizeof(SCH_CRED));
#endif

    // Reality check credential count.
    if(Cred.cCreds > 100)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    Size = sizeof( SCH_CRED ) + (2 * Cred.cCreds * sizeof( PVOID ) );

    pCred = SPExternalAlloc( Size );
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pCred->dwVersion = Cred.dwVersion ;
    pCred->cCreds = Cred.cCreds ;
    pCred->paSecret = (PVOID) ( pCred + 1 );
    pCred->paPublic = (PVOID) ( pCred->paSecret + Cred.cCreds );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( PVOID ) * Cred.cCreds,
                                             pCred->paSecret,
                                             Cred.paSecret );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 sizeof( PVOID ) * Cred.cCreds,
                                                 pCred->paPublic,
                                                 Cred.paPublic );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        SPExternalFree( pCred );

        return( Status );
    }

    //
    // Ok.  We have pCred in local memory, with a chain of cert/private key
    // stuff hanging off of it.  We now have to map in each one.  Happy, happy.
    //

    for ( i = 0 ; i < Cred.cCreds ; i++ )
    {
        pCred->paSecret[i] = SpMapSchCred( pCred->paSecret[i] );

        if ( pCred->paSecret[i] == NULL )
        {
            Failed = TRUE ;
        }
    }

    for ( i = 0 ; i < Cred.cCreds ; i++ )
    {
        pCred->paPublic[i] = SpMapSchPublic( pCred->paPublic[i] );

        if ( pCred->paPublic[i] == NULL )
        {
            Failed = TRUE ;
        }
    }

    if ( Failed )
    {
        SpFreeVersion2Certificate( pCred );

        pCred = NULL ;

        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS) ;
    }

    *ppCred = pCred ;

    return( Status );
}


#ifdef _WIN64
SECURITY_STATUS
SpWow64MapVersion2Certificate(
    PVOID       pvAuthData,
    SCH_CRED * *ppCred
    )
{
    SECURITY_STATUS Status ;
    SSLWOW64_SCH_CRED Cred;
    PSCH_CRED   pCred;
    DWORD       Size;
    BOOL        Failed = FALSE ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                            sizeof( SSLWOW64_SCH_CRED ),
                                            &Cred,
                                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

#if DBG
    DebugLog((DEB_TRACE, "SpMapVersion2Certificate: %d certificates in cred\n", Cred.cCreds));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)&Cred, sizeof(SCH_CRED));
#endif

    if(Cred.cCreds > 100)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    if(Cred.cCreds > 1)
    {
        // Only support a single certificate, which is all that anyone
        // ever uses anyway.
        Cred.cCreds = 1;
    }

    Size = sizeof( SCH_CRED ) + (2 * Cred.cCreds * sizeof( PVOID ) );

    pCred = SPExternalAlloc( Size );
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pCred->dwVersion = Cred.dwVersion;
    pCred->cCreds    = Cred.cCreds;

    if(pCred->cCreds > 0)
    {
        SSLWOW64_PVOID ClientSecret = 0;
        SSLWOW64_PVOID ClientPublic = 0;

        pCred->paSecret = (PVOID) ( pCred + 1 );
        pCred->paPublic = (PVOID) ( pCred->paSecret + Cred.cCreds );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 sizeof(SSLWOW64_PVOID),
                                                 &ClientSecret,
                                                 ULongToPtr(Cred.paSecret));

        if ( NT_SUCCESS( Status ) )
        {
            Status = LsaTable->CopyFromClientBuffer( NULL,
                                                     sizeof(SSLWOW64_PVOID),
                                                     &ClientPublic,
                                                     ULongToPtr(Cred.paPublic));
        }

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree( pCred );

            return( Status );
        }

        pCred->paSecret[0] = SpWow64MapSchCred(ClientSecret);

        if ( pCred->paSecret[0] == NULL )
        {
            Failed = TRUE ;
        }

        pCred->paPublic[0] = SpWow64MapSchPublic(ClientPublic);

        if ( pCred->paPublic[0] == NULL )
        {
            Failed = TRUE ;
        }
    }

    if ( Failed )
    {
        SpFreeVersion2Certificate( pCred );

        pCred = NULL ;

        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS) ;
    }

    *ppCred = pCred ;

    return( Status );
}
#endif // _WIN64


// Selectively enable the unified protocol.
DWORD
EnableUnifiedProtocol(DWORD dwPackageType, DWORD dwProtocol)
{
    DWORD cProts = 0;

    // Disable unified.
    dwProtocol &= ~SP_PROT_UNI;

    if(dwPackageType & SP_PROT_UNI)
    {
        // Count enabled protocols.
        if(dwProtocol & SP_PROT_PCT1) cProts++;
        if(dwProtocol & SP_PROT_SSL2) cProts++;
        if(dwProtocol & (SP_PROT_SSL3 | SP_PROT_TLS1)) cProts++;

        // Enable unified if multiple protocols enabled.
        if(cProts > 1)
        {
            if(dwPackageType & SP_PROT_CLIENTS)
            {
                dwProtocol |= SP_PROT_UNI_CLIENT;
            }
            else
            {
                dwProtocol |= SP_PROT_UNI_SERVER;
            }
        }
    }

    return dwProtocol;
}


typedef struct _V3_SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
} V3_SCHANNEL_CRED;


//+---------------------------------------------------------------------------
//
//  Function:   SpMapVersion3Certificate
//
//  Synopsis:   Maps a version 3 schannel credential into LSA memory
//
//  Arguments:  [pvAuthData] -- pointer to cred in application process
//              [pCred]      -- pointer to cred in LSA process
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:      The credential consists of the following structure. Note
//              that all CryptoAPI 2.0 handles must be mapped over as well,
//              via the callback mechanism.
//
//              typedef struct _SCHANNEL_CRED
//              {
//                  DWORD           dwVersion;
//                  DWORD           cCreds;
//                  PCCERT_CONTEXT  *paCred;
//                  HCERTSTORE      hRootStore;
//
//                  DWORD            cMappers;
//                  struct _HMAPPER  **aphMappers;
//
//                  DWORD           cSupportedAlgs;
//                  ALG_ID          *palgSupportedAlgs;
//
//                  DWORD           grbitEnabledProtocols;
//                  DWORD           dwMinimumCipherStrength;
//                  DWORD           dwMaximumCipherStrength;
//                  DWORD           dwSessionLifespan;
//
//              } SCHANNEL_CRED, *PSCHANNEL_CRED;
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SpMapVersion3Certificate(
    PVOID pvAuthData,           // in
    DWORD dwVersion,            // in
    PLSA_SCHANNEL_CRED pCred)   // out
{
    PCERT_CONTEXT * pLocalCredList = NULL;
    HCERTSTORE      hStore = NULL;
    CRYPT_DATA_BLOB Serialized;
    SCHANNEL_CRED   LocalCred;
    SecBuffer       Input;
    SecBuffer       Output;
    PBYTE           pbBuffer;
    DWORD           cbBuffer;
    DWORD           cbData;
    SECURITY_STATUS scRet;
    DWORD           Size;
    DWORD           iCred;

    Output.pvBuffer = NULL;

    //
    // Copy over the SCHANNEL_CRED structure.
    //

    if(dwVersion == SCH_CRED_V3)
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(V3_SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        LocalCred.dwFlags  = 0;
        LocalCred.reserved = 0;

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion3Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(V3_SCHANNEL_CRED));
#endif
    }
    else
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion4Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SCHANNEL_CRED));
#endif
    }


    //
    // DWORD           dwVersion;
    //

    memset(pCred, 0, sizeof(LSA_SCHANNEL_CRED));

    pCred->dwVersion = LocalCred.dwVersion;


    //
    // DWORD           cCreds;
    // PCCERT_CONTEXT  *paCred;
    //

    if(LocalCred.cCreds && LocalCred.paCred)
    {
        Size = LocalCred.cCreds * sizeof(PVOID);

        // Reality check credential count.
        if(LocalCred.cCreds > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Make local copy of application cred list.
        pLocalCredList = SPExternalAlloc(Size);
        if(pLocalCredList == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
        scRet = LsaTable->CopyFromClientBuffer(
                                    NULL,
                                    Size,
                                    pLocalCredList,
                                    (PCERT_CONTEXT *)LocalCred.paCred);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        // Allocate memory for our cred list.
        pCred->cSubCreds = LocalCred.cCreds;
        pCred->paSubCred = SPExternalAlloc(pCred->cSubCreds * sizeof(LSA_SCHANNEL_SUB_CRED));
        if(pCred->paSubCred == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Create an in-memory certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                               0, 0,
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                               0);
        if(hStore == NULL)
        {
            SP_LOG_RESULT(GetLastError());
            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto cleanup;
        }

        // Copy over each certificate context.
        for(iCred = 0; iCred < LocalCred.cCreds; iCred++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred;

            pSubCred = pCred->paSubCred + iCred;

            Input.BufferType  = SECBUFFER_DATA;
            Input.cbBuffer    = sizeof(PVOID);
            Input.pvBuffer    = (PVOID)&pLocalCredList[iCred];

            scRet = PerformApplicationCallback(SCH_UPLOAD_CREDENTIAL_CALLBACK,
                                               0, 0,
                                               &Input,
                                               &Output,
                                               TRUE);
            if(!NT_SUCCESS(scRet))
            {
                Output.pvBuffer = NULL;
                goto cleanup;
            }

            pbBuffer = Output.pvBuffer;
            cbBuffer = Output.cbBuffer;

            if(pbBuffer == NULL ||
               cbBuffer < sizeof(HCRYPTPROV) + sizeof(DWORD))
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }

            // Parse hProv.
            pSubCred->hRemoteProv = *(HCRYPTPROV *)pbBuffer;
            pbBuffer += sizeof(HCRYPTPROV);
            cbBuffer -= sizeof(HCRYPTPROV);

            // Parse certificate context length.
            cbData = *(DWORD *)pbBuffer;
            pbBuffer += sizeof(DWORD);
            cbBuffer -= sizeof(DWORD);

            // Parse certificate context.
            if(cbBuffer < cbData)
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }
            if(!CertAddSerializedElementToStore(hStore,
                                                pbBuffer,
                                                cbData,
                                                CERT_STORE_ADD_ALWAYS,
                                                0,
                                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                                NULL,
                                                &pSubCred->pCert))
            {
                scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
                goto cleanup;
            }

            // Free the output buffer.
            SPExternalFree(Output.pvBuffer);
            Output.pvBuffer = NULL;
        }
    }


    //
    // HCERTSTORE      hRootStore;
    //

    if(LocalCred.hRootStore != NULL)
    {
        Input.BufferType  = SECBUFFER_DATA;
        Input.cbBuffer    = sizeof(HCERTSTORE);
        Input.pvBuffer    = (PVOID)&LocalCred.hRootStore;

        scRet = PerformApplicationCallback(SCH_UPLOAD_CERT_STORE_CALLBACK,
                                           0, 0,
                                           &Input,
                                           &Output,
                                           TRUE);
        if(scRet != SEC_E_OK)
        {
            goto cleanup;
        }

        pbBuffer = Output.pvBuffer;
        cbBuffer = Output.cbBuffer;

        if(pbBuffer == NULL || cbBuffer < sizeof(DWORD))
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }

        // Parse certificate store.
        Serialized.cbData = *(DWORD *)pbBuffer;
        Serialized.pbData = pbBuffer + sizeof(DWORD);
        if(cbBuffer - sizeof(DWORD) < Serialized.cbData)
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCred->hRootStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                           X509_ASN_ENCODING,
                                           0, 0,
                                           &Serialized);
        if(pCred->hRootStore == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto cleanup;
        }

        // Free the output buffer.
        SPExternalFree(Output.pvBuffer);
        Output.pvBuffer = NULL;
    }


    //
    // DWORD           cSupportedAlgs;
    // ALG_ID          *palgSupportedAlgs;
    //

    if(LocalCred.cSupportedAlgs && LocalCred.palgSupportedAlgs)
    {
        // Reality check.
        if(LocalCred.cSupportedAlgs > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        Size = LocalCred.cSupportedAlgs * sizeof(ALG_ID);

        pCred->cSupportedAlgs    = LocalCred.cSupportedAlgs;
        pCred->palgSupportedAlgs = SPExternalAlloc(Size);
        if(pCred->palgSupportedAlgs == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               Size,
                                               pCred->palgSupportedAlgs,
                                               LocalCred.palgSupportedAlgs);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }
    }


    //
    // DWORD           grbitEnabledProtocols;
    // DWORD           dwMinimumCipherStrength;
    // DWORD           dwMaximumCipherStrength;
    // DWORD           dwSessionLifespan;
    // DWORD           dwFlags;
    // DWORD           reserved;
    //

    pCred->grbitEnabledProtocols   = LocalCred.grbitEnabledProtocols;
    pCred->dwMinimumCipherStrength = LocalCred.dwMinimumCipherStrength;
    pCred->dwMaximumCipherStrength = LocalCred.dwMaximumCipherStrength;
    pCred->dwSessionLifespan       = LocalCred.dwSessionLifespan;
    pCred->dwFlags                 = LocalCred.dwFlags;
    pCred->reserved                = LocalCred.reserved;


    scRet = SEC_E_OK;

cleanup:

    if(Output.pvBuffer)
    {
        SPExternalFree(Output.pvBuffer);
    }
    if(pLocalCredList)
    {
        SPExternalFree(pLocalCredList);
    }
    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(!NT_SUCCESS(scRet))
    {
        SpFreeVersion3Certificate(pCred);
    }

    return scRet;
}

#ifdef _WIN64
SECURITY_STATUS
SpWow64MapVersion3Certificate(
    PVOID pvAuthData,           // in
    DWORD dwVersion,            // in
    PLSA_SCHANNEL_CRED pCred)   // out
{
    SSLWOW64_PCCERT_CONTEXT *pLocalCredList = NULL;
    HCERTSTORE      hStore = NULL;
    CRYPT_DATA_BLOB Serialized;
    SSLWOW64_SCHANNEL_CRED LocalCred;
    SecBuffer       Input;
    SecBuffer       Output;
    PBYTE           pbBuffer;
    DWORD           cbBuffer;
    DWORD           cbData;
    SECURITY_STATUS scRet;
    DWORD           Size;
    DWORD           iCred;

    Output.pvBuffer = NULL;

    //
    // Copy over the SCHANNEL_CRED structure.
    //

    if(dwVersion == SCH_CRED_V3)
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SSLWOW64_SCHANNEL3_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        LocalCred.dwFlags  = 0;
        LocalCred.reserved = 0;

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion3Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SSLWOW64_SCHANNEL_CRED));
#endif
    }
    else
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SSLWOW64_SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion4Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SSLWOW64_SCHANNEL_CRED));
#endif
    }


    //
    // DWORD           dwVersion;
    //

    memset(pCred, 0, sizeof(LSA_SCHANNEL_CRED));

    pCred->dwVersion = LocalCred.dwVersion;


    //
    // DWORD           cCreds;
    // PCCERT_CONTEXT  *paCred;
    //

    if(LocalCred.cCreds && LocalCred.paCred)
    {
        Size = LocalCred.cCreds * sizeof(SSLWOW64_PCCERT_CONTEXT);

        // Reality check credential count.
        if(LocalCred.cCreds > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Make local copy of application cred list.
        pLocalCredList = SPExternalAlloc(Size);
        if(pLocalCredList == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
        scRet = LsaTable->CopyFromClientBuffer(
                                    NULL,
                                    Size,
                                    pLocalCredList,
                                    ULongToPtr(LocalCred.paCred));
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        // Allocate memory for our cred list.
        pCred->cSubCreds = LocalCred.cCreds;
        pCred->paSubCred = SPExternalAlloc(pCred->cSubCreds * sizeof(LSA_SCHANNEL_SUB_CRED));
        if(pCred->paSubCred == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Create an in-memory certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                               0, 0,
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                               0);
        if(hStore == NULL)
        {
            SP_LOG_RESULT(GetLastError());
            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto cleanup;
        }

        // Copy over each certificate context.
        for(iCred = 0; iCred < LocalCred.cCreds; iCred++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred;

            pSubCred = pCred->paSubCred + iCred;

            Input.BufferType  = SECBUFFER_DATA;
            Input.cbBuffer    = sizeof(SSLWOW64_PCCERT_CONTEXT);
            Input.pvBuffer    = (PVOID)&pLocalCredList[iCred];

            scRet = PerformApplicationCallback(SCH_UPLOAD_CREDENTIAL_CALLBACK,
                                               0, 0,
                                               &Input,
                                               &Output,
                                               TRUE);
            if(!NT_SUCCESS(scRet))
            {
                Output.pvBuffer = NULL;
                goto cleanup;
            }

            pbBuffer = Output.pvBuffer;
            cbBuffer = Output.cbBuffer;

            if(pbBuffer == NULL ||
               cbBuffer < sizeof(HCRYPTPROV) + sizeof(DWORD))
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }

            // Parse hProv.
            pSubCred->hRemoteProv = *(SSLWOW64_HCRYPTPROV *)pbBuffer;
            pbBuffer += sizeof(SSLWOW64_HCRYPTPROV);
            cbBuffer -= sizeof(SSLWOW64_HCRYPTPROV);

            // Parse certificate context length.
            cbData = *(DWORD *)pbBuffer;
            pbBuffer += sizeof(DWORD);
            cbBuffer -= sizeof(DWORD);

            // Parse certificate context.
            if(cbBuffer < cbData)
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }
            if(!CertAddSerializedElementToStore(hStore,
                                                pbBuffer,
                                                cbData,
                                                CERT_STORE_ADD_ALWAYS,
                                                0,
                                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                                NULL,
                                                &pSubCred->pCert))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = SEC_E_UNKNOWN_CREDENTIALS;
                goto cleanup;
            }

            // Free the output buffer.
            SPExternalFree(Output.pvBuffer);
            Output.pvBuffer = NULL;
        }
    }


    //
    // HCERTSTORE      hRootStore;
    //

    if(LocalCred.hRootStore)
    {
        Input.BufferType  = SECBUFFER_DATA;
        Input.cbBuffer    = sizeof(SSLWOW64_HCERTSTORE);
        Input.pvBuffer    = (PVOID)&LocalCred.hRootStore;

        scRet = PerformApplicationCallback(SCH_UPLOAD_CERT_STORE_CALLBACK,
                                           0, 0,
                                           &Input,
                                           &Output,
                                           TRUE);
        if(scRet != SEC_E_OK)
        {
            goto cleanup;
        }

        pbBuffer = Output.pvBuffer;
        cbBuffer = Output.cbBuffer;

        if(pbBuffer == NULL || cbBuffer < sizeof(DWORD))
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }

        // Parse certificate store.
        Serialized.cbData = *(DWORD *)pbBuffer;
        Serialized.pbData = pbBuffer + sizeof(DWORD);
        if(cbBuffer - sizeof(DWORD) < Serialized.cbData)
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCred->hRootStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                           X509_ASN_ENCODING,
                                           0, 0,
                                           &Serialized);
        if(pCred->hRootStore == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto cleanup;
        }

        // Free the output buffer.
        SPExternalFree(Output.pvBuffer);
        Output.pvBuffer = NULL;
    }


    //
    // DWORD           cSupportedAlgs;
    // ALG_ID          *palgSupportedAlgs;
    //

    if(LocalCred.cSupportedAlgs && LocalCred.palgSupportedAlgs)
    {
        // Reality check.
        if(LocalCred.cSupportedAlgs > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        Size = LocalCred.cSupportedAlgs * sizeof(ALG_ID);

        pCred->cSupportedAlgs    = LocalCred.cSupportedAlgs;
        pCred->palgSupportedAlgs = SPExternalAlloc(Size);
        if(pCred->palgSupportedAlgs == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               Size,
                                               pCred->palgSupportedAlgs,
                                               ULongToPtr(LocalCred.palgSupportedAlgs));
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }
    }


    //
    // DWORD           grbitEnabledProtocols;
    // DWORD           dwMinimumCipherStrength;
    // DWORD           dwMaximumCipherStrength;
    // DWORD           dwSessionLifespan;
    // DWORD           dwFlags;
    // DWORD           reserved;
    //

    pCred->grbitEnabledProtocols   = LocalCred.grbitEnabledProtocols;
    pCred->dwMinimumCipherStrength = LocalCred.dwMinimumCipherStrength;
    pCred->dwMaximumCipherStrength = LocalCred.dwMaximumCipherStrength;
    pCred->dwSessionLifespan       = LocalCred.dwSessionLifespan;
    pCred->dwFlags                 = LocalCred.dwFlags;
    pCred->reserved                = LocalCred.reserved;


    scRet = SEC_E_OK;

cleanup:

    if(Output.pvBuffer)
    {
        SPExternalFree(Output.pvBuffer);
    }
    if(pLocalCredList)
    {
        SPExternalFree(pLocalCredList);
    }
    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(!NT_SUCCESS(scRet))
    {
        SpFreeVersion3Certificate(pCred);
    }

    return scRet;
}
#endif // _WIN64


SECURITY_STATUS
SpMapAuthIdentity(
    PVOID pAuthData,
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentity = NULL;
    SEC_WINNT_AUTH_IDENTITY_EX32 AuthIdentity32 = {0};
    BOOLEAN DoUnicode = TRUE;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
    NTSTATUS Status;
    CRED_MARSHAL_TYPE CredType;
    PCERT_CREDENTIAL_INFO pCertInfo = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    HCERTSTORE hStore = 0;
    CRYPT_HASH_BLOB HashBlob;
    BOOL fImpersonating = FALSE;
    BOOL fWow64Client = FALSE;

#ifdef _WIN64
    SECPKG_CALL_INFO CallInfo;

    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    DebugLog((DEB_TRACE, "SpMapAuthIdentity\n"));


    //
    // Initialize.
    //

    RtlInitUnicodeString(
        &UserName,
        NULL);

    RtlInitUnicodeString(
        &Password,
        NULL);


    // 
    // Copy over the SEC_WINNT_AUTH_IDENTITY_EX structure from client memory.
    //

    pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW)SPExternalAlloc(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));
    if(pAuthIdentity == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto cleanup;
    }
 
    if(fWow64Client)
    {
        Status = LsaTable->CopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EX32),
                    &AuthIdentity32,
                    pAuthData);

        if (!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }

        pAuthIdentity->Version = AuthIdentity32.Version;
        pAuthIdentity->Length = (AuthIdentity32.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EX) ?
                              sizeof(SEC_WINNT_AUTH_IDENTITY_EX) : AuthIdentity32.Length);

        pAuthIdentity->UserLength = AuthIdentity32.UserLength;
        pAuthIdentity->User = (PWSTR) UlongToPtr(AuthIdentity32.User);
        pAuthIdentity->DomainLength = AuthIdentity32.DomainLength ;
        pAuthIdentity->Domain = (PWSTR) UlongToPtr( AuthIdentity32.Domain );
        pAuthIdentity->PasswordLength = AuthIdentity32.PasswordLength ;
        pAuthIdentity->Password = (PWSTR) UlongToPtr( AuthIdentity32.Password );
        pAuthIdentity->Flags = AuthIdentity32.Flags ;
        pAuthIdentity->PackageListLength = AuthIdentity32.PackageListLength ;
        pAuthIdentity->PackageList = (PWSTR) UlongToPtr( AuthIdentity32.PackageList );
    }
    else
    {
        Status = LsaTable->CopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                    pAuthIdentity,
                    pAuthData);

        if (!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }

    if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
    {
        DoUnicode = FALSE;
    }


    //
    // Copy over the user name and password.
    //

    if (pAuthIdentity->User != NULL)
    {
        Status = CopyClientString(
                        pAuthIdentity->User,
                        pAuthIdentity->UserLength,
                        DoUnicode,
                        &UserName);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto cleanup;
        }
    }

    if (pAuthIdentity->Password != NULL)
    {
        Status = CopyClientString(
                        pAuthIdentity->Password,
                        pAuthIdentity->PasswordLength,
                        DoUnicode,
                        &Password);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto cleanup;
        }
    }


    //
    // Extract the certificate thumbprint.
    //

    if(!CredIsMarshaledCredentialW(UserName.Buffer))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }

    if(!CredUnmarshalCredentialW(UserName.Buffer,
                                 &CredType,
                                 &pCertInfo))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }
    if(CredType != CertCredential)
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }


    //
    // Look up the certificate in the MY certificate store.
    //

    fImpersonating = SslImpersonateClient();

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_CURRENT_USER |
                           CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                           L"MY");
    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS; 
        goto cleanup;
    }

    HashBlob.cbData = sizeof(pCertInfo->rgbHashOfCert);
    HashBlob.pbData = pCertInfo->rgbHashOfCert;

    pCertContext = CertFindCertificateInStore(hStore, 
                                              X509_ASN_ENCODING, 
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DebugLog((DEB_ERROR, "Certificate designated by authority info was not found in certificate store (0x%x).\n", GetLastError()));
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }

    //
    // Build sub cred structure and attach it to the credential.
    //

    pSchannelCred->paSubCred = SPExternalAlloc(sizeof(LSA_SCHANNEL_SUB_CRED));
    if(pSchannelCred->paSubCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pSchannelCred->paSubCred[0].pCert = pCertContext;

    pSchannelCred->paSubCred[0].pszPin = Password.Buffer;
    Password.Buffer = NULL;

    pSchannelCred->cSubCreds = 1;

    Status = STATUS_SUCCESS;

cleanup:

    if(pAuthIdentity)
    {
        SPExternalFree(pAuthIdentity);
    }

    if(UserName.Buffer)
    {
        LocalFree(UserName.Buffer);
    }
    if(Password.Buffer)
    {
        LocalFree(Password.Buffer);
    }

    if(pCertInfo)
    {
        CredFree(pCertInfo);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   SpCommonAcquireCredentialsHandle
//
//  Synopsis:   Common AcquireCredentialsHandle function.
//
//  Arguments:  [Type]             -- Type expected (Unified v. specific)
//              [pLogonID]         --
//              [pvAuthData]       --
//              [pvGetKeyFn]       --
//              [pvGetKeyArgument] --
//              [pdwHandle]        --
//              [ptsExpiry]        --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SpCommonAcquireCredentialsHandle(
    ULONG            Type,
    PLUID            pLogonID,
    PVOID            pvAuthData,
    PVOID            pvGetKeyFn,
    PVOID            pvGetKeyArgument,
    PLSA_SEC_HANDLE  pdwHandle,
    PTimeStamp       ptsExpiry)
{
    SP_STATUS           pctRet;
    PSPCredentialGroup  pCredGroup;
    LSA_SCHANNEL_CRED   SchannelCred;
    PSCH_CRED           pSchCred;
    SECURITY_STATUS     Status;
    SSL_CREDENTIAL_CERTIFICATE SslCert;
    DWORD               dwVersion;
    SECPKG_CLIENT_INFO  ClientInfo;

#ifdef _WIN64
    SECPKG_CALL_INFO    CallInfo;
    BOOL                fWow64Client = FALSE;
#endif

    UNREFERENCED_PARAMETER(pLogonID);
    UNREFERENCED_PARAMETER(pvGetKeyFn);
    UNREFERENCED_PARAMETER(pvGetKeyArgument);

    TRACE_ENTER( SpCommonAcquireCredentialsHandle );

    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    Status = LsaTable->GetClientInfo( &ClientInfo );
    if (!NT_SUCCESS( Status ))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }


    //
    // Got to have an impersonation level token in order to call ACH.
    // This check used to be in lsa, but moved here to enable
    // some S4Uproxy scenarios to work w/o tcb.
    //


    if (ClientInfo.ImpersonationLevel <= SecurityIdentification)
    {   
        Status = SEC_E_NO_CREDENTIALS;
        return SP_LOG_RESULT(Status);
    }   


    __try
    {
        // Default to null credential
        memset(&SchannelCred, 0, sizeof(SchannelCred));
        SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;


        if ( pvAuthData )
        {
            //
            // Read in the first few bytes of data so we can see what's there.
            //

            Status = LsaTable->CopyFromClientBuffer( NULL,
                                                sizeof( SSL_CREDENTIAL_CERTIFICATE ),
                                                &SslCert,
                                                pvAuthData );

            if ( !NT_SUCCESS( Status ) )
            {
                return( Status );
            }

            dwVersion = SslCert.cbPrivateKey;


            //
            // Ok, see what kind of blob we got:
            //

            switch(dwVersion)
            {
            case SEC_WINNT_AUTH_IDENTITY_VERSION:

                //
                // The application passed in a SEC_WINNT_AUTH_IDENTITY_EXW 
                // structure. 
                //

                Status = SpMapAuthIdentity(pvAuthData, &SchannelCred);

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }
                break;


            case SCH_CRED_V3:
            case SCHANNEL_CRED_VERSION:

                //
                // The application is using modern (version 3) credentials.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapVersion3Certificate(pvAuthData, dwVersion, &SchannelCred);
                }
                else
#endif
                {
                    Status = SpMapVersion3Certificate(pvAuthData, dwVersion, &SchannelCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                // Selectively enable the unified protocol.
                SchannelCred.grbitEnabledProtocols = EnableUnifiedProtocol(
                                                            Type,
                                                            SchannelCred.grbitEnabledProtocols);
                break;


            case SCH_CRED_V1:
            case SCH_CRED_V2:

                //
                // Okay, it's a V1 or V2 style request.  Map it in, following
                // its scary chains.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapVersion2Certificate(pvAuthData, &pSchCred);
                }
                else
#endif
                {
                    Status = SpMapVersion2Certificate(pvAuthData, &pSchCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }


                //
                // Convert this version 2 credential to a version 3 credential.
                //

                Status = UpdateCredentialFormat(pSchCred, &SchannelCred);

                SpFreeVersion2Certificate( pSchCred );

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                break;


            default:

                //
                // A really old-style credential.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapProtoCredential((SSLWOW64_CREDENTIAL_CERTIFICATE *)&SslCert, &pSchCred);
                }
                else
#endif
                {
                    Status = SpMapProtoCredential(&SslCert, &pSchCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }


                //
                // Convert this version 2 credential to a version 3 credential.
                //

                Status = UpdateCredentialFormat(pSchCred, &SchannelCred);

                SpFreeVersion2Certificate( pSchCred );

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                break;
            }

            // Set the legacy flags if this is an old-style credential.
            if(dwVersion != SCHANNEL_CRED_VERSION && 
               dwVersion != SEC_WINNT_AUTH_IDENTITY_VERSION)
            {
                SchannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
                SchannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    if(pvAuthData == NULL && (Type & SP_PROT_SERVERS))
    {
        //
        // A server is creating credential without specifying any
        // authentication data, so attempt to acquire a default
        // machine credential.
        //

        Status = FindDefaultMachineCred(&pCredGroup, Type);
        if(!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Unable to create default server credential (0x%x)\n", Status));
            return Status;
        }

        ComputeCredExpiry(pCredGroup, ptsExpiry);

        *pdwHandle = (LSA_SEC_HANDLE) pCredGroup;

        return SEC_E_OK;
    }


    pctRet = SPCreateCredential( &pCredGroup,
                                 Type,
                                 &SchannelCred );

    SpFreeVersion3Certificate( &SchannelCred );

    if (PCT_ERR_OK == pctRet)
    {
        ComputeCredExpiry(pCredGroup, ptsExpiry);

        *pdwHandle = (LSA_SEC_HANDLE) pCredGroup;

        return SEC_E_OK;
    }

    return PctTranslateError(pctRet);
}


SECURITY_STATUS
SEC_ENTRY
SpUniAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonID,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PLSA_SEC_HANDLE     pdwHandle,
            PTimeStamp          ptsExpiry)
{
    DWORD Type;

    UNREFERENCED_PARAMETER(psPrincipal);

    DebugLog((DEB_TRACE, "SpUniAcquireCredentialsHandle(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
        fCredentials, pLogonID, pvAuthData,
        pvGetKeyFn, pvGetKeyArgument, pdwHandle, ptsExpiry));


    if ( fCredentials & SECPKG_CRED_INBOUND )
    {
        Type = SP_PROT_UNI_SERVER ;
    }
    else if ( fCredentials & SECPKG_CRED_OUTBOUND )
    {
        Type = SP_PROT_UNI_CLIENT ;
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
    return( SpCommonAcquireCredentialsHandle(   Type,
                                                pLogonID,
                                                pvAuthData,
                                                pvGetKeyFn,
                                                pvGetKeyArgument,
                                                pdwHandle,
                                                ptsExpiry ) );
}


SECURITY_STATUS
SEC_ENTRY
SpQueryCredentialsAttributes(
    LSA_SEC_HANDLE dwCredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    PSPCredentialGroup  pCred;
    ULONG Size;
    PVOID pvClient = NULL;
    DWORD cbClient;
    SECURITY_STATUS Status;
    BOOL fWow64Client = FALSE;

#ifdef _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    typedef struct _SecPkgCred_SupportedAlgsWow64
    {
        DWORD           cSupportedAlgs;
        SSLWOW64_PVOID  palgSupportedAlgs;
    } SecPkgCred_SupportedAlgsWow64, *PSecPkgCred_SupportedAlgsWow64;

    union {
        SecPkgCred_SupportedAlgs        SupportedAlgs;
        SecPkgCred_SupportedAlgsWow64   SupportedAlgsWow64;
        SecPkgCred_CipherStrengths      CipherStrengths;
        SecPkgCred_SupportedProtocols   SupportedProtocols;
    } LocalBuffer;

    pCred = (PSPCredentialGroup)dwCredHandle;

    if(pCred == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }


#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    __try
    {
        switch (dwAttribute)
        {
            case SECPKG_ATTR_SUPPORTED_ALGS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_SUPPORTED_ALGS)\n"));
                if(fWow64Client)
                {
                    Size = sizeof(SecPkgCred_SupportedAlgsWow64);
                }
                else
                {
                    Size = sizeof(SecPkgCred_SupportedAlgs);
                }
                break;

            case SECPKG_ATTR_CIPHER_STRENGTHS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_CIPHER_STRENGTHS)\n"));
                Size = sizeof(SecPkgCred_CipherStrengths);
                break;

            case SECPKG_ATTR_SUPPORTED_PROTOCOLS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_SUPPORTED_PROTOCOLS)\n"));
                Size = sizeof(SecPkgCred_SupportedProtocols);
                break;

            default:
                DebugLog((DEB_WARN, "QueryCredentialsAttributes(unsupported function %d)\n", dwAttribute));

                return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
        }


        // Copy structure from client memory, just in case any of this
        // stuff is in/out.
        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Size,
                                                 &LocalBuffer,
                                                 Buffer );
        if(FAILED(Status))
        {
            return Status;
        }


        switch (dwAttribute)
        {
            case SECPKG_ATTR_SUPPORTED_ALGS:
            {
                cbClient = pCred->cSupportedAlgs * sizeof(ALG_ID);

                // Allocate client memory for algorithm list.
                Status = LsaTable->AllocateClientBuffer(NULL, cbClient, &pvClient);
                if(FAILED(Status))
                {
                    return Status;
                }

                if(fWow64Client)
                {
                    LocalBuffer.SupportedAlgsWow64.cSupportedAlgs = pCred->cSupportedAlgs;
                    LocalBuffer.SupportedAlgsWow64.palgSupportedAlgs = PtrToUlong(pvClient);
                }
                else
                {
                    LocalBuffer.SupportedAlgs.cSupportedAlgs = pCred->cSupportedAlgs;
                    LocalBuffer.SupportedAlgs.palgSupportedAlgs = pvClient;
                }

                // Copy algorithm list to client memory.
                Status = LsaTable->CopyToClientBuffer(
                                        NULL,
                                        cbClient,
                                        pvClient,
                                        pCred->palgSupportedAlgs);
                if(FAILED(Status))
                {
                    LsaTable->FreeClientBuffer(NULL, pvClient);
                    return Status;
                }
                break;
            }

            case SECPKG_ATTR_CIPHER_STRENGTHS:
                GetDisplayCipherSizes(pCred,
                                      &LocalBuffer.CipherStrengths.dwMinimumCipherStrength,
                                      &LocalBuffer.CipherStrengths.dwMaximumCipherStrength);
                break;

            case SECPKG_ATTR_SUPPORTED_PROTOCOLS:
                LocalBuffer.SupportedProtocols.grbitProtocol = pCred->grbitEnabledProtocols;
                break;

        }

        // Copy structure back to client memory.
        Status = LsaTable->CopyToClientBuffer( NULL,
                                               Size,
                                               Buffer,
                                               &LocalBuffer );
        if(FAILED(Status))
        {
            if(pvClient) LsaTable->FreeClientBuffer(NULL, pvClient);
            return Status;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return SEC_E_OK;
}


SECURITY_STATUS
SEC_ENTRY
SpFreeCredentialsHandle(LSA_SEC_HANDLE dwHandle)
{
    PSPCredentialGroup  pCred;
    SECPKG_CALL_INFO CallInfo;

    DebugLog((DEB_TRACE, "SpFreeCredentialsHandle(0x%x)\n", dwHandle));

    pCred = (PSPCredentialGroup) dwHandle ;

    __try
    {
        if (pCred)
        {
            // Delete all mention of this credential from the cache.
            SPCachePurgeCredential(pCred);

            // Was this call made from the LSA cleanup code? In other
            // words, did the application terminate without cleaning up
            // properly? If so, then throw away all unreferenced zombies
            // associated with that process.
            if(LsaTable->GetCallInfo(&CallInfo))
            {
                if(CallInfo.Attributes & SECPKG_CALL_CLEANUP)
                {
                    SPCachePurgeProcessId(pCred->ProcessId);
                }
            }

            pCred->dwFlags |= CRED_FLAG_DELETED;

            SPDereferenceCredential(pCred, TRUE);

            return(SEC_E_OK);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"




#if DBG         // NOTE:  This file not compiled for retail builds





DEBUG_KEY   SslDebugKeys[] = { {DEB_ERROR,            "Error"},
                               {DEB_WARN,             "Warning"},
                               {DEB_TRACE,            "Trace"},
                               {DEB_TRACE_FUNC,       "Func"},
                               {DEB_TRACE_CRED,       "Cred"},
                               {DEB_TRACE_CTXT,       "Ctxt"},
                               {DEB_TRACE_MAPPER,     "Mapper"},
                               {0, NULL}
                             };

DEFINE_DEBUG2( Ssl );

void
InitDebugSupport(
    HKEY hGlobalKey)
{
    static BOOL fFirstTime = TRUE;
    CHAR  szFileName[MAX_PATH];
    CHAR  szDirectoryName[MAX_PATH];
    DWORD dwSize;
    DWORD dwType;
    DWORD err;
    DWORD fVal;
    HKEY hkBase;
    DWORD disp;


    SslInitDebug(SslDebugKeys);

//    SslInfoLevel |= DEB_TRACE_MAPPER ;

    if(hGlobalKey)
    {
        // We're running in the lsass.exe process.
        hkBase = hGlobalKey;
    }
    else
    {
        err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             SP_REG_KEY_BASE,
                             0,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ,
                             NULL,
                             &hkBase,
                             &disp);
        if(err)
        {
            DebugLog((DEB_WARN,"Failed to open SCHANNEL key: 0x%x\n", err));
            return;
        }
    }

    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkBase, SP_REG_VAL_LOGLEVEL, NULL, &dwType, (PUCHAR)&fVal, &dwSize);
    if(!err) 
    {
        g_dwInfoLevel = fVal;
    }


    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkBase, SP_REG_VAL_BREAK, NULL, &dwType, (PUCHAR)&fVal, &dwSize);
    if(!err) 
    {
        g_dwDebugBreak = fVal;
    }

    if(g_hfLogFile)
    {
        CloseHandle(g_hfLogFile);
        g_hfLogFile = NULL;
    }
    dwSize = 255;
    err = RegQueryValueExA(hkBase, SP_REG_VAL_LOGFILE, NULL, &dwType, (PUCHAR)szDirectoryName, &dwSize);
    
    if(!err)
    {
        if(hGlobalKey)
        {
            strcpy(szFileName, szDirectoryName);
            strcat(szFileName, "\\Schannel.log");
        }
        else
        {
            sprintf(szFileName,"%s\\Schannel_%d.log",szDirectoryName,GetCurrentProcessId());
        }

        g_hfLogFile = CreateFileA(szFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL, OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if(g_hfLogFile)
        {
            SetFilePointer(g_hfLogFile, 0, 0, FILE_END);
        }

        if(fFirstTime == TRUE)
        {
            SYSTEMTIME stTime;

            GetLocalTime(&stTime);

            DebugLog((SP_LOG_ERROR, "==== SCHANNEL LOG INITIATED %d/%d/%d %02d:%02d:%02d ====\n",
                            stTime.wMonth, stTime.wDay, stTime.wYear,
                            stTime.wHour, stTime.wMinute, stTime.wSecond));

            dwSize = sizeof(szFileName);
            if(GetModuleFileNameA(NULL, szFileName, dwSize) != 0)
            {
                DebugLog((SP_LOG_ERROR, "Module name:%s\n", szFileName));
            }
        }
        fFirstTime = FALSE;
    }

    if(hGlobalKey == NULL)
    {
        RegCloseKey(hkBase);
    }
}

VOID
UnloadDebugSupport(
    VOID
    )
{
    SslUnloadDebug();
}
#else // DBG

#pragma warning(disable:4206)   // Disable the empty translation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\libmain.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//              8-13-95   TerenceS   Mutated to PCT
//              1-19-97   jbanes     Remove dead code
//
//----------------------------------------------------------------------------

#include "sslp.h"

HANDLE g_hInstance = NULL;


BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    BOOL fRet;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(lpReserved);

    if(dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;

        DisableThreadLibraryCalls( hInstance );

        Status = RtlInitializeCriticalSection(&g_InitCritSec);
        if(!NT_SUCCESS(Status))
        {
            return FALSE;
        }

        // We do nothing during attach, we
        // init on first call.

    }
    else if(dwReason == DLL_PROCESS_DETACH)
    {
        // We shutdown schannel if it's
        // not shut down.
        fRet = SchannelShutdown();

        RtlDeleteCriticalSection(&g_InitCritSec);

#if DBG
        UnloadDebugSupport();
#endif 

        return fRet;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\init.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       init.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//              8-13-95   TerenceS   Mutated to PCT
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <basetyps.h>
#include <oidenc.h>
#include <userenv.h>

RTL_CRITICAL_SECTION    g_InitCritSec;
BOOL                    g_fSchannelInitialized = FALSE;

void LoadSecurityDll(void);
void UnloadSecurityDll(void);


// MyStrToL
//      Can't use CRT routines, so steal from the C runtime sources

DWORD MyStrToL(CHAR *InStr)
{
    DWORD dwVal = 0;

    while(*InStr)
    {
        dwVal = (10 * dwVal) + (*InStr - '0');
        InStr++;
    }

    return dwVal;
}

/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

--*/
void
IsSchEncryptionPermitted(VOID)
{
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;
    BOOL fAllowed = TRUE;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c)
    {
        fAllowed = FALSE;
        goto Ret;
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        fAllowed = FALSE;
        goto Ret;
    }

    CountryValue = (ULONG) MyStrToL(CountryCode);

    if (CountryValue == CTRY_FRANCE)
    {
        fAllowed = FALSE;
    }      
Ret:

    if(FALSE == fAllowed)  
    {
        // Disable PCT in France.
        g_ProtEnabled &= ~(SP_PROT_PCT1);
        g_fFranceLocale = TRUE;
    }
}


/*****************************************************************************/
BOOL 
SchannelInit(BOOL fAppProcess)
{
    DWORD Status;

    if(g_fSchannelInitialized) return TRUE;

    RtlEnterCriticalSection(&g_InitCritSec);

    if(g_fSchannelInitialized)
    {
        RtlLeaveCriticalSection(&g_InitCritSec);
        return TRUE;
    }

    DisableThreadLibraryCalls( g_hInstance );

    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT, SAFEALLOCA_USE_DEFAULT, NULL, NULL);

    // Read configuration parameters from registry.
    if(!fAppProcess)
    {
        IsSchEncryptionPermitted();
        SPLoadRegOptions();
    }
#if DBG
    else
    {
        InitDebugSupport(NULL);
    }
#endif

    if(!fAppProcess)
    {
        SchInitializeEvents();
    }

    if(!CryptAcquireContextA(&g_hRsaSchannel,
                             NULL,
                             NULL,
                             PROV_RSA_SCHANNEL,
                             CRYPT_VERIFYCONTEXT))
    {
        g_hRsaSchannel = 0;
        Status = GetLastError();
        DebugLog((DEB_ERROR, "Could not open static PROV_RSA_SCHANNEL: %x\n", Status));

        if(!fAppProcess)
        {
            LogGlobalAcquireContextFailedEvent(L"RSA", Status);
        }

        RtlLeaveCriticalSection(&g_InitCritSec);
        return FALSE;
    }
    if(!fAppProcess && g_hRsaSchannel)
    {
        GetSupportedCapiAlgs(g_hRsaSchannel,
                             &g_pRsaSchannelAlgs,
                             &g_cRsaSchannelAlgs);
    }

    if(!CryptAcquireContext(&g_hDhSchannelProv,
                            NULL,
                            NULL,
                            PROV_DH_SCHANNEL,
                            CRYPT_VERIFYCONTEXT))
    {
        g_hDhSchannelProv = 0;
        Status = GetLastError();
        DebugLog((DEB_WARN, "Could not open PROV_DH_SCHANNEL: %x\n", Status));

        if(!fAppProcess)
        {
            LogGlobalAcquireContextFailedEvent(L"DSS", Status);
        }

        CryptReleaseContext(g_hRsaSchannel, 0);
        RtlLeaveCriticalSection(&g_InitCritSec);
        return FALSE;
    }
    if(!fAppProcess && g_hDhSchannelProv)
    {
        GetSupportedCapiAlgs(g_hDhSchannelProv,
                             &g_pDhSchannelAlgs,
                             &g_cDhSchannelAlgs);
    }

    InitSchannelAsn1(g_hInstance);

    LoadSecurityDll();

    if(!fAppProcess)
    {
        SPInitSessionCache();
        SslInitCredentialManager();
        SslInitSystemMapper();
    }

    g_fSchannelInitialized = TRUE;

    if(!fAppProcess)
    {
        LogSchannelStartedEvent();
    }

    RtlLeaveCriticalSection(&g_InitCritSec);

    return TRUE;
}

BOOL SchannelShutdown(VOID)
{
    BOOL fAppProcess = (LsaTable == NULL);

    RtlEnterCriticalSection(&g_InitCritSec);

    if(!g_fSchannelInitialized)
    {
        RtlLeaveCriticalSection(&g_InitCritSec);
        return TRUE;
    }

    SPShutdownSessionCache();

    UnloadSecurityDll();

    if(!fAppProcess)
    {
        SslFreeCredentialManager();
    }

    ShutdownSchannelAsn1();

    SchShutdownEvents();

    SPUnloadRegOptions();

    g_fSchannelInitialized = FALSE;

    RtlLeaveCriticalSection(&g_InitCritSec);

    return TRUE;
}


HINSTANCE g_hSecur32;
FREE_CONTEXT_BUFFER_FN g_pFreeContextBuffer;

void LoadSecurityDll(void)
{
    g_hSecur32 = LoadLibrary(TEXT("secur32.dll"));
    if(g_hSecur32)
    {
        g_pFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)GetProcAddress(
                                    g_hSecur32, 
                                    "FreeContextBuffer");
    }
    else
    {
        g_pFreeContextBuffer = NULL;
    }
}

void UnloadSecurityDll(void)
{
    if(g_hSecur32)
    {
        FreeLibrary(g_hSecur32);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\mapper.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapper.c
//
//  Contents:   Implements the DS Mapping Layer
//
//  Classes:
//
//  Functions:
//
//  History:    10-15-96   RichardW   Created
//
//  Notes:      The code here has two forks.  One, the direct path, for when
//              the DLL is running on a DC, and the second, for when we're
//              running elsewhere and remoting through the generic channel
//              to the DC.
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <dnsapi.h>
#include <certmap.h>
#include <align.h>
#include <ntmsv1_0.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "wincrypt.h"
#include <msaudite.h>
#include <mapper.h>
#include <kerberos.h>
#include <sidfilter.h>
#include <lsaitf.h>

 LONG WINAPI
SslLocalRefMapper(
    PHMAPPER    Mapper);

 LONG WINAPI
SslLocalDerefMapper(
    PHMAPPER    Mapper);

 DWORD WINAPI
SslLocalGetIssuerList(
    IN PHMAPPER Mapper,
    IN PVOID    Reserved,
    OUT PBYTE   pIssuerList,
    OUT PDWORD  IssuerListLength);

 DWORD WINAPI
SslLocalGetChallenge(
    IN PHMAPPER Mapper,
    IN PUCHAR   AuthenticatorId,
    IN DWORD    AuthenticatorIdLength,
    OUT PUCHAR  Challenge,
    OUT DWORD * ChallengeLength);

 DWORD WINAPI
SslLocalMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator);

 DWORD WINAPI
SslRemoteMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator);

 DWORD WINAPI
SslLocalCloseLocator(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator);

 DWORD WINAPI
SslLocalGetAccessToken(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator,
    OUT HANDLE *Token);

MAPPER_VTABLE   SslLocalTable = { SslLocalRefMapper,
                                  SslLocalDerefMapper,
                                  SslLocalGetIssuerList,
                                  SslLocalGetChallenge,
                                  SslLocalMapCredential,
                                  SslLocalGetAccessToken,
                                  SslLocalCloseLocator
                                };

MAPPER_VTABLE   SslRemoteTable = {SslLocalRefMapper,
                                  SslLocalDerefMapper,
                                  SslLocalGetIssuerList,
                                  SslLocalGetChallenge,
                                  SslRemoteMapCredential,
                                  SslLocalGetAccessToken,
                                  SslLocalCloseLocator
                                };


typedef struct _SSL_MAPPER_CONTEXT {
    HMAPPER     Mapper ;
    LONG        Ref ;

} SSL_MAPPER_CONTEXT, * PSSL_MAPPER_CONTEXT ;


NTSTATUS
WINAPI
SslBuildCertLogonRequest(
    PCCERT_CHAIN_CONTEXT pChainContext,
    DWORD dwMethods,
    PSSL_CERT_LOGON_REQ *ppRequest,
    PDWORD pcbRequest);

NTSTATUS
WINAPI
SslMapCertAtDC(
    IN     PUNICODE_STRING DomainName,
    IN     VOID const *pCredential,
    IN     DWORD cbCredential,
    IN     BOOL IsDC,
       OUT PUCHAR *UserPac,
       OUT PULONG UserPacLen,
       OUT PMSV1_0_PASSTHROUGH_RESPONSE * DcResponse);

SECURITY_STRING SslNullString = { 0, sizeof( WCHAR ), L"" };

HANDLE SslLogonHandle = NULL;
ULONG SslKerberosPackageId = 0;
ULONG SslMsvPackageId = 0;
TOKEN_GROUPS *SslPackageSid = 0;

NTSTATUS
SslInitSystemMapper(void)
{
    NTSTATUS Status;
    ULONG Dummy;
    LSA_STRING Name;

    //
    // Get handle to Kerberos package.
    //

    Status = LsaRegisterLogonProcess(
                &SslPackageNameA,
                &SslLogonHandle,
                &Dummy
                );

    if(!NT_SUCCESS(Status))
    {
        return SP_LOG_RESULT(Status);
    }

    RtlInitString(&Name, 
                  MICROSOFT_KERBEROS_NAME_A );

    Status = LsaLookupAuthenticationPackage(
                SslLogonHandle,
                &Name,
                &SslKerberosPackageId
                );

    if (!NT_SUCCESS(Status))
    {
        return SP_LOG_RESULT(Status);
    }


    //
    // Get handle to NTLM package.
    //

    RtlInitString(&Name, 
                  MSV1_0_PACKAGE_NAME );

    Status = LsaLookupAuthenticationPackage(
                SslLogonHandle,
                &Name,
                &SslMsvPackageId
                );

    if (!NT_SUCCESS(Status))
    {
        return SP_LOG_RESULT(Status);
    }


    //
    // Build schannel package SID.
    //

    {
        SID_IDENTIFIER_AUTHORITY PackageSidAuthority = SECURITY_NT_AUTHORITY;
        BYTE  PackageSidBuffer[ SECURITY_MAX_SID_SIZE ];
        PSID  PackageSid = (PSID)PackageSidBuffer;
        ULONG Length;

        RtlInitializeSid(PackageSid, &PackageSidAuthority, 2);
        *(RtlSubAuthoritySid(PackageSid, 0)) = SECURITY_PACKAGE_BASE_RID;
        *(RtlSubAuthoritySid(PackageSid, 1)) = UNISP_RPC_ID;
    
        Length = RtlLengthSid(PackageSid);
    
        SslPackageSid = LocalAlloc(LPTR, sizeof(TOKEN_GROUPS) + Length);
        if(SslPackageSid == NULL)
        {
            return SP_LOG_RESULT(STATUS_INSUFFICIENT_RESOURCES);
        }
    
        SslPackageSid->GroupCount = 1;
        SslPackageSid->Groups[0].Sid = (PSID)&SslPackageSid->Groups[1];
        SslPackageSid->Groups[0].Attributes = SE_GROUP_MANDATORY          |
                                              SE_GROUP_ENABLED_BY_DEFAULT |
                                              SE_GROUP_ENABLED;
    
        RtlCopySid(Length, SslPackageSid->Groups[0].Sid, PackageSid);
    }

    g_SslS4U2SelfInitialized = TRUE;

    return STATUS_SUCCESS;
}


PHMAPPER
SslGetMapper(
    BOOL Ignored
    )
{
    PSSL_MAPPER_CONTEXT Context ;
    NT_PRODUCT_TYPE ProductType ;
    BOOL DC ;

    UNREFERENCED_PARAMETER(Ignored);

    if ( RtlGetNtProductType( &ProductType ) )
    {
        DC = (ProductType == NtProductLanManNt );
    }
    else
    {
        return NULL ;
    }

    Context = (PSSL_MAPPER_CONTEXT) SPExternalAlloc( sizeof( SSL_MAPPER_CONTEXT ) );

    if ( Context )
    {
        Context->Mapper.m_dwMapperVersion = MAPPER_INTERFACE_VER ;
        Context->Mapper.m_dwFlags         = SCH_FLAG_SYSTEM_MAPPER ;
        Context->Mapper.m_Reserved1       = NULL ;

        Context->Ref = 0;


        if ( DC )
        {
            Context->Mapper.m_vtable = &SslLocalTable ;
        }
        else
        {
            Context->Mapper.m_vtable = &SslRemoteTable ;
        }

        return &Context->Mapper ;
    }
    else
    {
        return NULL ;
    }
}


LONG
WINAPI
SslLocalRefMapper(
    PHMAPPER    Mapper
    )
{
    PSSL_MAPPER_CONTEXT Context ;

    Context = (PSSL_MAPPER_CONTEXT) Mapper ;

    if ( Context == NULL )
    {
        return( -1 );
    }

    DebugLog(( DEB_TRACE_MAPPER, "Ref of Context %x\n", Mapper ));

    return( InterlockedIncrement( &Context->Ref ) );

}

LONG
WINAPI
SslLocalDerefMapper(
    PHMAPPER    Mapper
    )
{
    PSSL_MAPPER_CONTEXT Context ;
    DWORD RefCount;

    Context = (PSSL_MAPPER_CONTEXT) Mapper ;

    if ( Context == NULL )
    {
        return( -1 );
    }

    DebugLog(( DEB_TRACE_MAPPER, "Deref of Context %x\n", Mapper ));

    RefCount = InterlockedDecrement( &Context->Ref );

    if(RefCount == 0)
    {
        SPExternalFree(Context);
    }

    return RefCount;
}

DWORD
WINAPI
SslLocalGetIssuerList(
    IN PHMAPPER Mapper,
    IN PVOID    Reserved,
    OUT PBYTE   pIssuerList,
    OUT PDWORD  IssuerListLength
    )
{
    UNREFERENCED_PARAMETER(Mapper);
    UNREFERENCED_PARAMETER(Reserved);

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalGetIssuerList\n" ));

    return( (DWORD)GetDefaultIssuers(pIssuerList, IssuerListLength) );
}


DWORD
WINAPI
SslLocalGetChallenge(
    IN PHMAPPER Mapper,
    IN PUCHAR   AuthenticatorId,
    IN DWORD    AuthenticatorIdLength,
    OUT PUCHAR  Challenge,
    OUT DWORD * ChallengeLength
    )
{
    UNREFERENCED_PARAMETER(Mapper);
    UNREFERENCED_PARAMETER(AuthenticatorId);
    UNREFERENCED_PARAMETER(AuthenticatorIdLength);
    UNREFERENCED_PARAMETER(Challenge);
    UNREFERENCED_PARAMETER(ChallengeLength);

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalGetChallenge\n" ));

    return (DWORD)SEC_E_UNSUPPORTED_FUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetTokenUserSid
//
//  Synopsis:   Obtain the user SID from the specified user token
//
//  Arguments:  [hUserToken]    --  User token.
//              [ppUserSid]     --  Returned SID.
//
//  History:    10-08-2001   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
GetTokenUserSid(
    IN      HANDLE  hUserToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;

    *ppUserSid = NULL;

    if(hUserToken == NULL)
    {
        return FALSE;
    }

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hUserToken,// identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) 
    {
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
        {
            // try again with the specified buffer size
            SlowBuffer = (LPBYTE)SPExternalAlloc(cbBuffer);

            if(SlowBuffer != NULL) 
            {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hUserToken,// identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) 
    {
        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = SPExternalAlloc( cbSid );

        if(*ppUserSid != NULL) 
        {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if(!fSuccess) 
    {
        if(*ppUserSid) 
        {
            SPExternalFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
    {
        SPExternalFree(SlowBuffer);
    }

    return fSuccess;
}


SECURITY_STATUS
SslCreateTokenFromPac(
    PUCHAR  AuthInfo,
    ULONG   AuthInfoLength,
    PUNICODE_STRING Domain,
    PLUID   NewLogonId,
    PHANDLE NewToken
    )
{
    NTSTATUS Status ;
    LUID LogonId ;
    HANDLE TokenHandle ;
    NTSTATUS SubStatus ;
    SECURITY_STRING PacUserName ;

    //
    // Get the marshalled blob into a more useful form:
    //

    PacUserName.Buffer = NULL ;

    Status = LsaTable->ConvertAuthDataToToken(
                            AuthInfo,
                            AuthInfoLength,
                            SecurityImpersonation,
                            &SslTokenSource,
                            Network,
                            Domain,
                            &TokenHandle,
                            &LogonId,
                            &PacUserName,
                            &SubStatus
                            );

    if ( NT_SUCCESS( Status ) )
    {
        PSID pSid;
        
        if(!GetTokenUserSid(TokenHandle, &pSid))
        {
            pSid = NULL;
        }

        LsaTable->AuditLogon(
                        STATUS_SUCCESS,
                        STATUS_SUCCESS,
                        &PacUserName,
                        Domain,
                        NULL,
                        pSid,
                        Network,
                        &SslTokenSource,
                        &LogonId );

        if(pSid)
        {
            SPExternalFree(pSid);
        }
    }
    else 
    {
        LsaTable->AuditLogon(
                        Status,
                        Status,
                        &SslNullString,
                        &SslNullString,
                        NULL,
                        NULL,
                        Network,
                        &SslTokenSource,
                        &LogonId );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }


    *NewToken = TokenHandle ;
    *NewLogonId = LogonId ;


    if ( PacUserName.Buffer )
    {
        LsaTable->FreeLsaHeap( PacUserName.Buffer );
    }

    return Status ;
}

#define ISSUER_HEADER       L"<I>"
#define CCH_ISSUER_HEADER   3
#define SUBJECT_HEADER      L"<S>"
#define CCH_SUBJECT_HEADER  3


//+---------------------------------------------------------------------------
//
//  Function:   SslGetNameFromCertificate
//
//  Synopsis:   Extracts the UPN name from the certificate
//
//  Arguments:  [pCert]         --
//              [ppszName]      --
//              [pfMachineCert] --
//
//  History:    8-8-2000   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslGetNameFromCertificate(
    PCCERT_CONTEXT  pCert,
    PWSTR *         ppszName,
    BOOL *          pfMachineCert)
{
    ULONG ExtensionIndex;
    PWSTR pszName;
    DWORD cbName;

    *pfMachineCert = FALSE;

    //
    // See if cert has UPN in AltSubjectName->otherName
    //

    pszName = NULL;

    for(ExtensionIndex = 0; 
        ExtensionIndex < pCert->pCertInfo->cExtension; 
        ExtensionIndex++)
    {
        if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            PCERT_ALT_NAME_INFO AltName = NULL;
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            
            if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                NULL,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];

                    if((CERT_ALT_NAME_OTHER_NAME == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        PCERT_NAME_VALUE PrincipalNameBlob = NULL;
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            NULL,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {
                            pszName = LocalAlloc(LPTR, PrincipalNameBlob->Value.cbData + sizeof(WCHAR));
                            if(pszName != NULL)
                            {
                                CopyMemory(pszName, PrincipalNameBlob->Value.pbData, PrincipalNameBlob->Value.cbData);
                            }

                            LocalFree(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;

                            if(pszName == NULL)
                            {
                                LocalFree(AltName);
                                return STATUS_NO_MEMORY;
                            }
                        }
                        if(pszName)
                        {
                            break;
                        }
                    }
                }
                LocalFree(AltName);
                AltName = NULL;

                if(pszName)
                {
                    break;
                }
            }
        }
    }


    //
    // See if cert has DNS in AltSubjectName->pwszDNSName
    //

    if(pszName == NULL)
    {
        for(ExtensionIndex = 0; 
            ExtensionIndex < pCert->pCertInfo->cExtension; 
            ExtensionIndex++)
        {
            if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                      szOID_SUBJECT_ALT_NAME2) == 0)
            {
                PCERT_ALT_NAME_INFO AltName = NULL;
                DWORD               AltNameStructSize = 0;
                ULONG               CertAltNameIndex = 0;
            
                if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                    X509_ALTERNATE_NAME,
                                    pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                    pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                    CRYPT_DECODE_ALLOC_FLAG,
                                    NULL,
                                    (PVOID)&AltName,
                                    &AltNameStructSize))
                {

                    for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                    {
                        PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];

                        if((CERT_ALT_NAME_DNS_NAME == AltNameEntry->dwAltNameChoice) &&
                           (NULL != AltNameEntry->pwszDNSName))
                        {
                            // We found a DNS!
                            cbName = (lstrlen(AltNameEntry->pwszDNSName) + 1) * sizeof(WCHAR);

                            pszName = LocalAlloc(LPTR, cbName);
                            if(pszName == NULL)
                            {
                                LocalFree(AltName);
                                return STATUS_NO_MEMORY;
                            }

                            CopyMemory(pszName, AltNameEntry->pwszDNSName, cbName);
                            *pfMachineCert = TRUE;
                            break;
                        }
                    }
                    LocalFree(AltName);
                    AltName = NULL;

                    if(pszName)
                    {
                        break;
                    }
                }
            }
        }
    }


    //
    // There was no UPN in the AltSubjectName, so look for
    // one in the Subject Name, in case this is a B3 compatability
    // cert.
    //

    if(pszName == NULL)
    {
        ULONG Length;

        Length = CertGetNameString( pCert,
                                    CERT_NAME_ATTR_TYPE,
                                    0,
                                    szOID_COMMON_NAME,
                                    NULL,
                                    0 );

        if(Length)
        {
            pszName = LocalAlloc(LPTR, Length * sizeof(WCHAR));

            if(!pszName)
            {
                return STATUS_NO_MEMORY ;
            }

            if ( !CertGetNameStringW(pCert,
                                    CERT_NAME_ATTR_TYPE,
                                    0,
                                    szOID_COMMON_NAME,
                                    pszName,
                                    Length))
            {
                LocalFree(pszName);
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }

    
    if(pszName)
    {
        *ppszName = pszName;
    }
    else
    {
        return STATUS_NOT_FOUND;
    }

    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SslTryS4U2Self
//
//  Synopsis:   Creates a user token via the Kerberos S4U2Self mechanism.
//              This should work even cross-forest, provided that all of the
//              DC's are running Whistler. Pretty cool!
//
//  Arguments:  [pChainContext] --
//              [UserToken]     --
//
//  History:    06-13-2002   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryS4U2Self(
    IN  PCCERT_CHAIN_CONTEXT pChainContext,
    OUT HANDLE *UserToken
    )
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    BOOL fMachineCert;
    PWSTR pszUserName = NULL;
    PCERT_SIMPLE_CHAIN pSimpleChain;
    PCCERT_CONTEXT pCert;

    PKERB_S4U_LOGON LogonInfo = NULL;
    ULONG LogonInfoSize = sizeof(KERB_S4U_LOGON);
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    QUOTA_LIMITS Quotas;


    *UserToken = NULL;

    if(!g_SslS4U2SelfInitialized)
    {
        return SP_LOG_RESULT(STATUS_NOT_SUPPORTED);
    }


    //
    // Get the client name from the cert
    //

    pSimpleChain = pChainContext->rgpChain[0];

    pCert = pSimpleChain->rgpElement[0]->pCertContext;

    Status = SslGetNameFromCertificate(pCert, &pszUserName, &fMachineCert);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    if(fMachineCert)
    {
        // S4U2Self doesn't work with machine accounts.
        Status = STATUS_NOT_FOUND;
        goto cleanup;
    }

    DebugLog(( DEB_TRACE_MAPPER, "Looking for UPN name %ws\n", pszUserName ));


    //
    // Build logon info structure.
    //

    LogonInfoSize = sizeof(KERB_S4U_LOGON) +
                    (lstrlen(pszUserName) + 1) * sizeof(WCHAR);

    LogonInfo = (PKERB_S4U_LOGON) LocalAlloc(LPTR, LogonInfoSize);
    if (NULL == LogonInfo)
    {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    LogonInfo->MessageType = KerbS4ULogon;

    LogonInfo->ClientUpn.Buffer = (LPWSTR)(LogonInfo + 1);
    LogonInfo->ClientUpn.Length = (USHORT)(lstrlen(pszUserName)) * sizeof(WCHAR);
    LogonInfo->ClientUpn.MaximumLength = LogonInfo->ClientUpn.Length + sizeof(WCHAR);

    memcpy((PUCHAR)(LogonInfo + 1), 
           pszUserName, 
           LogonInfo->ClientUpn.MaximumLength);


    //
    // Attempt to log the user on.
    //

    Status = LsaLogonUser(
                SslLogonHandle,
                &SslPackageNameA,
                Network,
                SslKerberosPackageId,
                LogonInfo,
                LogonInfoSize,
                SslPackageSid,
                &SslTokenSource,
                (PVOID *)&Profile,
                &ProfileSize,
                &LogonId,
                UserToken,
                &Quotas,
                &SubStatus
                );

    if (NT_SUCCESS(Status))
    {
        Status = SubStatus;
    }

    if (!NT_SUCCESS(Status)) 
    {
        goto cleanup;
    }

    Status = LsaISetTokenDacl(*UserToken);

cleanup:

    if(Profile)
    {
        LsaFreeReturnBuffer(Profile);
    }

    if(LogonInfo)
    {
        LocalFree(LogonInfo);
    }
    
    if(pszUserName)
    {
        LocalFree(pszUserName);
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   SslTryUpn
//
//  Synopsis:   Tries to find the user by UPN encoded in Cert
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryUpn(
    PCCERT_CONTEXT User,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain
    )
{
    NTSTATUS Status ;
    UNICODE_STRING Upn = {0, 0, NULL};
    UNICODE_STRING Cracked = {0};
    UNICODE_STRING DnsDomain = {0};
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    BOOL fMachineCert;
    PWSTR pszName = NULL;
    PWSTR pszServiceName = NULL;
    DWORD cchServiceName;


    *ReferencedDomain = NULL ;


    //
    // Get the client name from the cert
    //

    Status = SslGetNameFromCertificate(User, &pszName, &fMachineCert);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // now, try and find this guy:
    //

    if(fMachineCert)
    {
        // Search for "host/foo.com".
        cchServiceName = lstrlenW(L"host/") + lstrlenW(pszName);

        SafeAllocaAllocate(pszServiceName, (cchServiceName + 1) * sizeof(WCHAR));

        if(pszServiceName == NULL)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            lstrcpyW(pszServiceName, L"host/");
            lstrcatW(pszServiceName, pszName);

            RtlInitUnicodeString(&Upn, pszServiceName);

            DebugLog(( DEB_TRACE_MAPPER, "Looking for SPN name %ws\n", Upn.Buffer ));
    
            Status = LsaTable->GetAuthDataForUser( &Upn,
                                                   SecNameSPN,
                                                   NULL,
                                                   AuthData,
                                                   AuthDataLen,
                                                   &FlatName );
    
            if ( FlatName.Length )
            {
                LsaTable->AuditAccountLogon(
                            SE_AUDITID_ACCOUNT_MAPPED,
                            (BOOLEAN) NT_SUCCESS( Status ),
                            &SslPackageName,
                            &Upn,
                            &FlatName,
                            Status );
    
                LsaTable->FreeLsaHeap( FlatName.Buffer );
            }
        }
    }
    else
    {
        // Search for "username@foo.com".
        RtlInitUnicodeString(&Upn, pszName);
        
        DebugLog(( DEB_TRACE_MAPPER, "Looking for UPN name %ws\n", Upn.Buffer ));

        Status = LsaTable->GetAuthDataForUser( &Upn,
                                               SecNameFlat,
                                               NULL,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &Upn,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }
    }


    if ( Status == STATUS_NOT_FOUND )
    {
        UNICODE_STRING DomainName;
        BOOL NameMatch;

        //
        // Do the hacky check of seeing if this is our own domain, and
        // if so, try opening the user as a flat, SAM name.
        //

        if(fMachineCert)
        {
            PWSTR pPeriod;
            WCHAR ch;
            
            pPeriod = wcschr( pszName, L'.' );

            if(pPeriod)
            {
                RtlInitUnicodeString( &DomainName, pPeriod + 1 );

                SslGlobalReadLock();
                NameMatch = RtlEqualUnicodeString(&DomainName, &SslGlobalDnsDomainName, TRUE);
                SslGlobalReleaseLock();

                if(NameMatch)
                {
                    ch = *(pPeriod + 1);

                    *pPeriod       = L'$';
                    *(pPeriod + 1) = L'\0';

                    RtlInitUnicodeString(&Upn, pszName);

                    DebugLog(( DEB_TRACE_MAPPER, "Looking for machine name %ws\n", Upn.Buffer ));

                    // Search for "computer$".
                    Status = LsaTable->GetAuthDataForUser( &Upn,
                                                           SecNameSamCompatible,
                                                           NULL,
                                                           AuthData,
                                                           AuthDataLen,
                                                           NULL );

                    *pPeriod = L'.';
                    *(pPeriod + 1) = ch;
                }
            }
        }
        else
        {
            PWSTR AtSign;
            
            AtSign = wcschr( pszName, L'@' );

            if ( AtSign )
            {
                RtlInitUnicodeString( &DomainName, AtSign + 1 );

                SslGlobalReadLock();
                NameMatch = RtlEqualUnicodeString(&DomainName, &SslGlobalDnsDomainName, TRUE);
                SslGlobalReleaseLock();

                if(NameMatch)
                {
                    *AtSign = L'\0';

                    RtlInitUnicodeString(&Upn, pszName);

                    DebugLog(( DEB_TRACE_MAPPER, "Looking for user name %ws\n", Upn.Buffer ));

                    // Search for "username".
                    Status = LsaTable->GetAuthDataForUser( &Upn,
                                                           SecNameSamCompatible,
                                                           NULL,
                                                           AuthData,
                                                           AuthDataLen,
                                                           NULL );

                    *AtSign = L'@';
                }
            }
        }

        if (Status == STATUS_NOT_FOUND )
        {
            if(fMachineCert)
            {
                RtlInitUnicodeString(&Upn, pszServiceName);

                DebugLog(( DEB_TRACE_MAPPER, "Cracking name %ws at GC\n", Upn.Buffer ));

                Status = LsaTable->CrackSingleName(
                                    DS_SERVICE_PRINCIPAL_NAME,
                                    TRUE,
                                    &Upn,
                                    NULL,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );
            }
            else
            {
                RtlInitUnicodeString(&Upn, pszName);

                DebugLog(( DEB_TRACE_MAPPER, "Cracking name %ws at GC\n", Upn.Buffer ));

                Status = LsaTable->CrackSingleName(
                                    DS_USER_PRINCIPAL_NAME,
                                    TRUE,
                                    &Upn,
                                    NULL,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );
            }

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

        }

    }

    if(pszName)
    {
        LocalFree(pszName);
    }

    if(pszServiceName)
    {
        SafeAllocaFree(pszServiceName);
    }

    return Status ;
}



void
ConvertNameString(UNICODE_STRING *Name)
{
    PWSTR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to ",".  This should be 
    // done by the CertNameToStr APIs, but that won't happen for a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = L',';
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = (USHORT)(wcslen( Name->Buffer ) * sizeof( WCHAR ));
}

//+---------------------------------------------------------------------------
//
//  Function:   SslTryCompoundName
//
//  Synopsis:   Tries to find the user by concatenating the issuer and subject
//              names, and looking for an AlternateSecurityId.
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryCompoundName(
    PCCERT_CONTEXT User,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain 
    )
{
    UNICODE_STRING CompoundName ;
    ULONG Length ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    PWSTR Current ;
    UNICODE_STRING Cracked = {0};
    UNICODE_STRING DnsDomain = {0};
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    const DWORD dwNameToStrFlags = CERT_X500_NAME_STR | 
                                   CERT_NAME_STR_NO_PLUS_FLAG | 
                                   CERT_NAME_STR_CRLF_FLAG;

    *ReferencedDomain = NULL ;

    IssuerLength = CertNameToStr( User->dwCertEncodingType,
                                   &User->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );

    Length = CertNameToStr( User->dwCertEncodingType,
                            &User->pCertInfo->Subject,
                            dwNameToStrFlags,
                            NULL,
                            0 );

    if ( ( IssuerLength == 0 ) ||
         ( Length == 0 ) )
    {
        return STATUS_NO_MEMORY ;
    }

    CompoundName.MaximumLength = (USHORT) (Length + IssuerLength +
                                 CCH_ISSUER_HEADER + CCH_SUBJECT_HEADER) *
                                 sizeof( WCHAR ) ;

    SafeAllocaAllocate( CompoundName.Buffer, CompoundName.MaximumLength );

    if ( CompoundName.Buffer )
    {
        wcscpy( CompoundName.Buffer, ISSUER_HEADER );
        Current = CompoundName.Buffer + CCH_ISSUER_HEADER ;

        IssuerLength = CertNameToStrW( User->dwCertEncodingType,
                                   &User->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   Current,
                                   IssuerLength );

        Current += IssuerLength - 1 ;
        wcscpy( Current, SUBJECT_HEADER );
        Current += CCH_SUBJECT_HEADER ;

        Length = CertNameToStrW( User->dwCertEncodingType,
                            &User->pCertInfo->Subject,
                            dwNameToStrFlags,
                            Current,
                            Length );

        ConvertNameString(&CompoundName);

        Status = LsaTable->GetAuthDataForUser( &CompoundName,
                                               SecNameAlternateId,
                                               &SslNamePrefix,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &CompoundName,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }

        if ( Status == STATUS_NOT_FOUND )
        {
            Status = LsaTable->CrackSingleName(
                                    DS_ALT_SECURITY_IDENTITIES_NAME,
                                    TRUE,
                                    &CompoundName,
                                    &SslNamePrefix,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

        }

        SafeAllocaFree( CompoundName.Buffer );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    return Status ;


}

//+---------------------------------------------------------------------------
//
//  Function:   SslTryIssuer
//
//  Synopsis:   Tries to find a user that has an issuer mapped to it.
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryIssuer(
    PBYTE pIssuer,
    DWORD cbIssuer,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain
    )
{
    UNICODE_STRING IssuerName ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    UNICODE_STRING Cracked = { 0 };
    UNICODE_STRING DnsDomain = { 0 };
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    const DWORD dwNameToStrFlags = CERT_X500_NAME_STR | 
                                   CERT_NAME_STR_NO_PLUS_FLAG | 
                                   CERT_NAME_STR_CRLF_FLAG;
    CERT_NAME_BLOB Issuer;
    BOOL fReferral = FALSE;

    *ReferencedDomain = NULL ;

    //
    // See if issuer is in cache. If so, then we know that this issuer
    // doesn't map to a user account.
    //

    if(SPFindIssuerInCache(pIssuer, cbIssuer))
    {
        return STATUS_NOT_FOUND;
    }

    LogDistinguishedName(DEB_TRACE, "SslTryIssuer: %s\n", pIssuer, cbIssuer);


    //
    // Attempt to map the issuer.
    //

    Issuer.pbData = pIssuer;
    Issuer.cbData = cbIssuer;

    IssuerLength = CertNameToStr( CRYPT_ASN_ENCODING,
                                  &Issuer,
                                  dwNameToStrFlags,
                                  NULL,
                                  0 );

    if ( IssuerLength == 0 )
    {
        return STATUS_NO_MEMORY ;
    }

    IssuerName.MaximumLength = (USHORT)(CCH_ISSUER_HEADER + IssuerLength) * sizeof( WCHAR ) ;

    SafeAllocaAllocate( IssuerName.Buffer, IssuerName.MaximumLength );

    if ( IssuerName.Buffer )
    {
        wcscpy( IssuerName.Buffer, ISSUER_HEADER );

        IssuerLength = CertNameToStrW(CRYPT_ASN_ENCODING,
                                     &Issuer,
                                     dwNameToStrFlags,
                                     IssuerName.Buffer + CCH_ISSUER_HEADER,
                                     IssuerLength );

        ConvertNameString(&IssuerName);



        Status = LsaTable->GetAuthDataForUser( &IssuerName,
                                               SecNameAlternateId,
                                               &SslNamePrefix,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName  );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &IssuerName,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }

        if ( Status == STATUS_NOT_FOUND )
        {
            Status = LsaTable->CrackSingleName(
                                    DS_ALT_SECURITY_IDENTITIES_NAME,
                                    TRUE,
                                    &IssuerName,
                                    &SslNamePrefix,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                    fReferral = TRUE;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

            if(!fReferral)
            {
                // No mapping was found for this issuer, and no referral 
                // either. Add this issuer to the issuer cache, so that
                // we don't attempt to map it again (until the cache entry
                // expires).
                SPAddIssuerToCache(pIssuer, cbIssuer);
            }
        }

        SafeAllocaFree(IssuerName.Buffer);
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SslMapCertToUserPac
//
//  Synopsis:   Maps a certificate to a user (hopefully) and the PAC,
//
//  Arguments:  [Request]       --
//              [RequestLength] --
//              [UserPac]       --
//              [UserPacLen]    --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslMapCertToUserPac(
    IN PSSL_CERT_LOGON_REQ Request,
    IN ULONG RequestLength,
    OUT PUCHAR * UserPac,
    OUT PULONG UserPacLen, 
    OUT PWSTR * ReferencedDomain
    )
{
    PCCERT_CONTEXT User ;
    NTSTATUS Status = STATUS_LOGON_FAILURE;
    NTSTATUS SubStatus = STATUS_NOT_FOUND;
    ULONG i;

    *ReferencedDomain = NULL;

    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertToUserPac called\n" ));


    //
    // Validate logon request.
    //

    if(RequestLength < sizeof(SSL_CERT_LOGON_REQ))
    {
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }

    if(Request->Length > RequestLength)
    {
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }


    //
    // Extract certificate from request.
    //

    if((Request->OffsetCertificate > RequestLength) ||
       (Request->CertLength > 0x10000) ||
       (Request->OffsetCertificate + Request->CertLength > RequestLength))
    {
        return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
    }

    User = CertCreateCertificateContext( X509_ASN_ENCODING,
                                         (PBYTE)Request + Request->OffsetCertificate,
                                         Request->CertLength );

    if ( !User )
    {
        Status = STATUS_NO_MEMORY ;

        goto Cleanup ;
    }


    //
    // First, try the UPN
    //


    if((Request->Flags & REQ_UPN_MAPPING) &&
       (g_dwCertMappingMethods & SP_REG_CERTMAP_UPN_FLAG))
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying UPN mapping\n" ));

        Status = SslTryUpn( User, 
                            UserPac, 
                            UserPacLen,
                            ReferencedDomain );

        if ( NT_SUCCESS( Status ) ||
             ( *ReferencedDomain ) )
        {
            goto Cleanup;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Swing and a miss.  Try the constructed issuer+subject name
    //

    
    if((Request->Flags & REQ_SUBJECT_MAPPING) &&
       (g_dwCertMappingMethods & SP_REG_CERTMAP_SUBJECT_FLAG))
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying Subject mapping\n" ));

        Status = SslTryCompoundName( User, 
                                     UserPac, 
                                     UserPacLen,
                                     ReferencedDomain );

        if ( NT_SUCCESS( Status ) ||
             ( *ReferencedDomain ) )
        {
            goto Cleanup;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));

        // Return error code from issuer+subject name mapping
        // in preference to the error code from many-to-one mapping.
        SubStatus = Status;
    }


    //
    // Strike two.  Try the issuer for a many-to-one mapping:
    //

    if((Request->Flags & REQ_ISSUER_MAPPING) &&
       (g_dwCertMappingMethods & SP_REG_CERTMAP_ISSUER_FLAG))
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying issuer mapping\n" ));

        if((Request->Flags & REQ_ISSUER_CHAIN_MAPPING) && (Request->CertCount > 0))
        {
            if(sizeof(SSL_CERT_LOGON_REQ) +
               (Request->CertCount - 1) * sizeof(SSL_CERT_NAME_INFO) > RequestLength)
            {
                Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
                goto Cleanup;
            }

            // Loop through each issuer in the certificate chain.
            for(i = 0; i < Request->CertCount; i++)
            {
                DWORD IssuerOffset = Request->NameInfo[i].IssuerOffset;
                DWORD IssuerLength = Request->NameInfo[i].IssuerLength;

                if((IssuerOffset > RequestLength) ||
                   (IssuerLength > 0x10000) ||
                   (IssuerOffset + IssuerLength > RequestLength))
                {
                    return SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
                }

                Status = SslTryIssuer( (PBYTE)Request + Request->NameInfo[i].IssuerOffset, 
                                       Request->NameInfo[i].IssuerLength,
                                       UserPac, 
                                       UserPacLen,
                                       ReferencedDomain );

                if ( NT_SUCCESS( Status ) ||
                     ( *ReferencedDomain ) )
                {
                    goto Cleanup;
                }
            }
        }
        else
        {
            // Extract the issuer name from the certificate and try
            // to map it.
            Status = SslTryIssuer( User->pCertInfo->Issuer.pbData,
                                   User->pCertInfo->Issuer.cbData, 
                                   UserPac, 
                                   UserPacLen,
                                   ReferencedDomain );

            if ( NT_SUCCESS( Status ) ||
                 ( *ReferencedDomain ) )
            {
                goto Cleanup;
            }
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Certificate mapping failed. Decide what error code to return.
    //

    if(Status == STATUS_OBJECT_NAME_COLLISION ||
       SubStatus == STATUS_OBJECT_NAME_COLLISION)
    {
        Status = SEC_E_MULTIPLE_ACCOUNTS;
    }
    else if(Status != STATUS_NO_MEMORY)
    {
        Status = STATUS_LOGON_FAILURE ;
    }


Cleanup:

    if ( User )
    {
        CertFreeCertificateContext( User );
    }

    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertToUserPac returned 0x%x\n", Status ));

    return Status ;
}


DWORD
WINAPI
MapperVerifyClientChain(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwMapperFlags,
    DWORD *         pdwMethods,
    NTSTATUS *      pVerifyStatus,
    PCCERT_CHAIN_CONTEXT *ppChainContext)   // optional
{
    DWORD dwCertFlags    = 0;
    DWORD dwIgnoreErrors = 0;
    NTSTATUS Status;

    *pdwMethods    = 0;
    *pVerifyStatus = STATUS_SUCCESS;

    DebugLog(( DEB_TRACE_MAPPER, "Checking to see if cert is verified.\n" ));

    if(dwMapperFlags & SCH_FLAG_REVCHECK_END_CERT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    if(dwMapperFlags & SCH_FLAG_REVCHECK_CHAIN)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    if(dwMapperFlags & SCH_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    if(dwMapperFlags & SCH_FLAG_IGNORE_NO_REVOCATION_CHECK)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(dwMapperFlags & SCH_FLAG_IGNORE_REVOCATION_OFFLINE)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;

    if(dwMapperFlags & SCH_FLAG_NO_VALIDATION)
    {
        DebugLog((DEB_TRACE, "Skipping certificate validation.\n"));

        if(ppChainContext != NULL)
        {
            CERT_CHAIN_PARA          ChainPara;

            ZeroMemory(&ChainPara, sizeof(ChainPara));
            ChainPara.cbSize = sizeof(ChainPara);

            if(!CertGetCertificateChain(
                                    NULL,                       // hChainEngine
                                    pCertContext,               // pCertContext
                                    NULL,                       // pTime
                                    pCertContext->hCertStore,   // hAdditionalStore
                                    &ChainPara,                 // pChainPara
                                    dwCertFlags,                // dwFlags
                                    NULL,                       // pvReserved
                                    ppChainContext))            // ppChainContext
            {
                Status = SP_LOG_RESULT(GetLastError());
                return Status;
            }
        }
    }
    else
    {
        // Check to see if the certificate chain is properly signed all the way
        // up and that we trust the issuer of the root certificate.
        Status = VerifyClientCertificate(pCertContext, 
                                         dwCertFlags, 
                                         dwIgnoreErrors,
                                         CERT_CHAIN_POLICY_SSL, 
                                         ppChainContext);
        if(Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_WARN, "Client certificate failed to verify with SSL policy (0x%x)\n", Status));
            LogBogusClientCertEvent(pCertContext, Status);
            return Status;
        }
    }

    // Turn on Subject and Issuer mapping.
    *pdwMethods |= REQ_SUBJECT_MAPPING | REQ_ISSUER_MAPPING;


    if(dwMapperFlags & SCH_FLAG_NO_VALIDATION)
    {
        // Turn on UPN mapping.
        *pdwMethods |= REQ_UPN_MAPPING;
    }
    else
    {
        // Check to see if the certificate chain is valid for UPN mapping.
        Status = VerifyClientCertificate(pCertContext, 
                                         dwCertFlags, 
                                         dwIgnoreErrors,
                                         CERT_CHAIN_POLICY_NT_AUTH,
                                         NULL);
        if(Status == STATUS_SUCCESS)
        {
            // Turn on UPN mapping.
            *pdwMethods |= REQ_UPN_MAPPING;
        }
        else
        {
            DebugLog((DEB_WARN, "Client certificate failed to verify with NT_AUTH policy (0x%x)\n", Status));
            LogFastMappingFailureEvent(pCertContext, Status);
            *pVerifyStatus = Status;
        }
    }

    DebugLog((DEB_TRACE, "Client certificate verified with methods: 0x%x\n", *pdwMethods));

    return SEC_E_OK;
}


DWORD
WINAPI
SslLocalMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator
    )
{
    PCCERT_CONTEXT pCert = (PCERT_CONTEXT)pCredential;
    PMSV1_0_PASSTHROUGH_RESPONSE Response = NULL ;
    PSSL_CERT_LOGON_REQ pRequest = NULL;
    PSSL_CERT_LOGON_RESP CertResp ;
    DWORD cbRequest;
    PUCHAR Pac = NULL ;
    ULONG PacLength ;
    PUCHAR DirectPac = NULL ;
    PUCHAR IndirectPac = NULL ;
    PUCHAR ExpandedPac = NULL ;
    ULONG ExpandedPacLength ;
    NTSTATUS Status ;
    NTSTATUS VerifyStatus ;
    HANDLE Token ;
    LUID LogonId ;
    DWORD dwMethods ;
    PWSTR ReferencedDomain ;
    UNICODE_STRING DomainName ;
    UNICODE_STRING AccountDomain = { 0 };
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    UNREFERENCED_PARAMETER(pAuthority);

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalMapCredential, context %x\n", Mapper ));

    if ( CredentialType != X509_ASN_CHAIN )
    {
        return( (DWORD)SEC_E_UNKNOWN_CREDENTIALS );
    }

    //
    // Validate client certificate, and obtain pointer to 
    // entire certificate chain.
    //

    Status = MapperVerifyClientChain(pCert,
                                     Mapper->m_dwFlags,
                                     &dwMethods,
                                     &VerifyStatus,
                                     &pChainContext);
    if(Status != STATUS_SUCCESS)
    {
        return Status;
    }

    //
    // Attempt to logon via Kerberos S4U2Self.
    //

    if((dwMethods & REQ_UPN_MAPPING) &&
       (g_dwCertMappingMethods & SP_REG_CERTMAP_S4U2SELF_FLAG))
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying S4U2Self mapping\n" ));

        Status = SslTryS4U2Self(pChainContext, &Token);

        if ( NT_SUCCESS( Status ) )
        {
            CertFreeCertificateChain(pChainContext);
            pChainContext = NULL;

            *phLocator = (HLOCATOR) Token ;

            return Status;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Build the logon request.
    //

    Status = SslBuildCertLogonRequest(pChainContext,
                                      dwMethods,
                                      &pRequest,
                                      &cbRequest);

    CertFreeCertificateChain(pChainContext);
    pChainContext = NULL;

    if(FAILED(Status))
    {
        return Status;
    }


    //
    // Attempt to find the user locally.
    //

    Status = SslMapCertToUserPac(
                pRequest,
                cbRequest,
                &Pac,
                &PacLength,
                &ReferencedDomain );

    if(NT_SUCCESS(Status))
    {
        // Free this PAC later using LsaTable->FreeLsaHeap.
        DirectPac = Pac;
    }
    
    if ( !NT_SUCCESS( Status ) &&
         ( ReferencedDomain != NULL ) )
    {
        //
        // Didn't find it at this DC, but another domain appears to
        // have the mapping.  Forward it there:
        //

        RtlInitUnicodeString( &DomainName, ReferencedDomain );

        Status = SslMapCertAtDC(
                    &DomainName,
                    pRequest,
                    pRequest->Length,
                    TRUE,
                    &Pac,
                    &PacLength,
                    &Response );

        if ( NT_SUCCESS( Status ) )
        {
            // Free this later using MIDL_user_free.
            IndirectPac = Pac;

            CertResp = (PSSL_CERT_LOGON_RESP) Response->ValidationData ;

            //
            // older servers (pre 2010 or so) won't return the full structure,
            // so we need to examine it carefully.

            if ( CertResp->Length - CertResp->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
            {
                AccountDomain = SslDomainName ;
            }
            else 
            {
                if ( CertResp->DomainLength < 65536 )
                {
                    AccountDomain.Length = (USHORT) CertResp->DomainLength ;
                    AccountDomain.MaximumLength = AccountDomain.Length ;
                    AccountDomain.Buffer = (PWSTR) (((PUCHAR) CertResp) + CertResp->OffsetDomain );
                }
                else 
                {
                    AccountDomain = SslDomainName ;
                }
            }
        }

        LsaTable->FreeLsaHeap( ReferencedDomain );

    }
    else
    {
        AccountDomain = SslDomainName ;
    }


    //
    // Expand the domain local groups.
    //

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaTable->ExpandAuthDataForDomain(
                                Pac,
                                PacLength,
                                NULL,
                                &ExpandedPac,
                                &ExpandedPacLength );

        if ( NT_SUCCESS( Status ) )
        {
            Pac = ExpandedPac ;
            PacLength = ExpandedPacLength ;
        }   
    }


    // 
    // Create the user token.
    //

    if ( NT_SUCCESS( Status ) )
    {
        VerifyStatus = STATUS_SUCCESS;

        Status = SslCreateTokenFromPac( Pac,
                                        PacLength,
                                        &AccountDomain,
                                        &LogonId,
                                        &Token );

        if ( NT_SUCCESS( Status ) )
        {
            *phLocator = (HLOCATOR) Token ;
        }
    }


    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if(Response)
    {
        LsaTable->FreeReturnBuffer(Response);
    }

    if(DirectPac)
    {
        LsaTable->FreeLsaHeap(DirectPac);
    }

    if(IndirectPac)
    {
        MIDL_user_free(IndirectPac);
    }

    if(ExpandedPac)
    {
        LsaTable->FreeLsaHeap(ExpandedPac);
    }

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "Certificate mapping failed (0x%x)\n", Status));

        LogCertMappingFailureEvent(Status);

        if(!NT_SUCCESS(VerifyStatus))
        {
            // Return certificate validation error code, unless the mapper
            // error has already been mapped to a proper sspi error code.
            if(HRESULT_FACILITY(Status) != FACILITY_SECURITY)
            {
                Status = VerifyStatus;
            }
        }
    }

    return ( Status );
}


NTSTATUS
NTAPI
SslDoClientRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status ;
    PSSL_CERT_LOGON_REQ Request ;
    PSSL_CERT_LOGON_RESP Response, IndirectResponse ;
    PUCHAR Pac = NULL ;
    ULONG PacLength ;
    PUCHAR DirectPac = NULL ;
    PUCHAR IndirectPac = NULL ;
    PUCHAR ExpandedPac = NULL ;
    ULONG ExpandedPacLength ;
    PWSTR ReferencedDomain = NULL;
    PWSTR FirstDot ;
    UNICODE_STRING DomainName = { 0 };
    PMSV1_0_PASSTHROUGH_RESPONSE MsvResponse = NULL ;
    SECPKG_CALL_INFO CallInfo;

    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ClientBufferBase);

    DebugLog(( DEB_TRACE_MAPPER, "Handling request to do mapping\n" ));

    if ( ARGUMENT_PRESENT( ProtocolReturnBuffer ) )
    {
        *ProtocolReturnBuffer = NULL ;
    }

    // 
    // Attempt to map the certificate locally.
    //

    Request = (PSSL_CERT_LOGON_REQ) ProtocolSubmitBuffer ;

    Status = SslMapCertToUserPac(
                    Request,
                    SubmitBufferLen,
                    &Pac,
                    &PacLength,
                    &ReferencedDomain );

    DebugLog(( DEB_TRACE_MAPPER, "Local lookup returns %x\n", Status ));

    if(NT_SUCCESS(Status))
    {
        // Free this PAC later using LsaTable->FreeLsaHeap.
        DirectPac = Pac;
    }

    if(!NT_SUCCESS(Status) &&
       (ReferencedDomain != NULL))
    {
        BOOL NameMatch;

        //
        // Didn't find it at this DC, but another domain appears to
        // have the mapping.  Forward it there:
        //

        RtlInitUnicodeString( &DomainName, ReferencedDomain );

        SslGlobalReadLock();

        DsysAssert(!RtlEqualUnicodeString(&DomainName, &SslGlobalDnsDomainName, TRUE));
        DsysAssert(!RtlEqualUnicodeString(&DomainName, &SslDomainName, TRUE));

        NameMatch = (RtlEqualUnicodeString(&DomainName, &SslGlobalDnsDomainName, TRUE) ||
                     RtlEqualUnicodeString(&DomainName, &SslDomainName, TRUE));

        SslGlobalReleaseLock();

        if(NameMatch)
        {
            DebugLog(( DEB_TRACE_MAPPER, "GC is out of sync, bailing on this user\n" ));
            Status = STATUS_LOGON_FAILURE ;

        }
        else if(LsaTable->GetCallInfo(&CallInfo) &&
               (CallInfo.Attributes & SECPKG_CALL_RECURSIVE))
        {
            DebugLog(( DEB_ERROR, "Certificate mapper is recursing!\n" ));

        }
        else
        {
            DebugLog(( DEB_TRACE_MAPPER, "Mapping certificate at DC for domain %ws\n", 
                       ReferencedDomain ));

            Status = SslMapCertAtDC(
                        &DomainName,
                        Request,
                        Request->Length,
                        TRUE,
                        &Pac,
                        &PacLength,
                        &MsvResponse );

            if ( NT_SUCCESS( Status ) )
            {
                // Free this later using MIDL_user_free.
                IndirectPac = Pac;

                IndirectResponse = (PSSL_CERT_LOGON_RESP) MsvResponse->ValidationData ;

                FirstDot = wcschr( ReferencedDomain, L'.' );

                if ( FirstDot )
                {
                    *FirstDot = L'\0';
                    RtlInitUnicodeString( &DomainName, ReferencedDomain );
                }

                if ( IndirectResponse->Length - IndirectResponse->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
                {
                    //
                    // use the first token from the referenced domain
                    //

                    NOTHING ;
                }
                else 
                {
                    if ( IndirectResponse->DomainLength < 65536 )
                    {
                        DomainName.Length = (USHORT) IndirectResponse->DomainLength ;
                        DomainName.MaximumLength = DomainName.Length ;
                        DomainName.Buffer = (PWSTR) (((PUCHAR) IndirectResponse) + IndirectResponse->OffsetDomain );
                    }
                    else 
                    {
                        NOTHING ;
                    }
                }
            }

        }

    }
    else 
    {
        DomainName = SslDomainName ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        //
        // expand resource groups
        //

        Status = LsaTable->ExpandAuthDataForDomain(
                                Pac,
                                PacLength,
                                NULL,
                                &ExpandedPac,
                                &ExpandedPacLength );

        if ( NT_SUCCESS( Status ) )
        {
            Pac = ExpandedPac ;
            PacLength = ExpandedPacLength ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        *ReturnBufferLength = 0;
        *ProtocolStatus = Status ;

        Status = STATUS_SUCCESS ;

        goto Cleanup ;

    }


#ifdef ROGUE_DC
    if(DirectPac)
    {
        // We're a rogue user DC, so let's add some bogus SIDs to the PAC.
        // Yo ho ho.
        DebugLog((DEB_TRACE, "SslDoClientRequest: Calling SslInstrumentRoguePac\n"));

        Status = SslInstrumentRoguePac(&Pac, &PacLength);
        ExpandedPac = Pac;
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SslDoClientRequest: Failed SslInstrumentRoguePac 0x%x\n", Status));
            goto Cleanup;
        }
    }
#endif


    //
    // Construct the response blob:
    //

    Response = VirtualAlloc(
                    NULL,
                    sizeof( SSL_CERT_LOGON_RESP ) + PacLength + DomainName.Length,
                    MEM_COMMIT,
                    PAGE_READWRITE );

    if ( Response )
    {
        Response->MessageType = SSL_LOOKUP_CERT_MESSAGE;
        Response->Length = sizeof( SSL_CERT_LOGON_RESP ) + 
                            PacLength + DomainName.Length ;

        Response->OffsetAuthData = sizeof( SSL_CERT_LOGON_RESP );
        Response->AuthDataLength = PacLength ;

        RtlCopyMemory(
            ( Response + 1 ),
            Pac,
            PacLength );

        Response->OffsetDomain = sizeof( SSL_CERT_LOGON_RESP ) + PacLength ;
        Response->DomainLength = DomainName.Length ;

        RtlCopyMemory( (PUCHAR) Response + Response->OffsetDomain,
                       DomainName.Buffer,
                       DomainName.Length );

        *ProtocolReturnBuffer = Response ;
        *ReturnBufferLength = Response->Length ;
        *ProtocolStatus = STATUS_SUCCESS ;

        Status = STATUS_SUCCESS ;

    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

Cleanup:

    if(MsvResponse)
    {
        LsaTable->FreeReturnBuffer( MsvResponse );
    }

    if(DirectPac)
    {
        LsaTable->FreeLsaHeap(DirectPac);
    }

    if(IndirectPac)
    {
        MIDL_user_free(IndirectPac);
    }

    if(ExpandedPac)
    {
        LsaTable->FreeLsaHeap(ExpandedPac);
    }

    if(ReferencedDomain)
    {
        LsaTable->FreeLsaHeap(ReferencedDomain);
    }

    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   SslBuildCertLogonRequest
//
//  Synopsis:   Builds a certificate logon request to send to the server.
//
//  Arguments:  [pChainContext] --
//              [dwMethods]     --
//              [ppRequest]     --
//              [pcbRequest]    --
//
//  History:    2-26-2001   Jbanes      Created
//
//  Notes:      The certificate data that this function builds
//              looks something like this:
//
//              typedef struct _SSL_CERT_LOGON_REQ {
//                  ULONG MessageType ;
//                  ULONG Length ;
//                  ULONG OffsetCertficate ;
//                  ULONG CertLength ;
//                  ULONG Flags;
//                  ULONG CertCount;
//                  SSL_CERT_NAME_INFO NameInfo[1];
//              } SSL_CERT_LOGON_REQ, * PSSL_CERT_LOGON_REQ ;
//
//              <client certificate>
//              <issuer #1 name>
//              <issuer #2 name>
//              ...
//
//----------------------------------------------------------------------------
NTSTATUS
WINAPI
SslBuildCertLogonRequest(
    PCCERT_CHAIN_CONTEXT pChainContext,
    DWORD dwMethods,
    PSSL_CERT_LOGON_REQ *ppRequest,
    PDWORD pcbRequest)
{
    PCERT_SIMPLE_CHAIN pSimpleChain;
    PCCERT_CONTEXT pCert;
    PCCERT_CONTEXT pCurrentCert;
    PSSL_CERT_LOGON_REQ pCertReq = NULL;
    DWORD Size;
    DWORD Offset;
    DWORD CertCount;
    ULONG i;


    //
    // Compute the request size.
    //

    pSimpleChain = pChainContext->rgpChain[0];

    pCert = pSimpleChain->rgpElement[0]->pCertContext;

    Size = sizeof(SSL_CERT_LOGON_REQ) + 
           pCert->cbCertEncoded;

    CertCount = 0;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;

        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }

            Size += sizeof(SSL_CERT_NAME_INFO);
        }

        Size += pCurrentCert->pCertInfo->Issuer.cbData;
        CertCount++;
    }

    Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );


    // 
    // Build the request.
    //

    pCertReq = (PSSL_CERT_LOGON_REQ)LocalAlloc(LPTR, Size);

    if ( !pCertReq )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Offset = sizeof(SSL_CERT_LOGON_REQ) + (CertCount - 1) * sizeof(SSL_CERT_NAME_INFO);

    pCertReq->MessageType = SSL_LOOKUP_CERT_MESSAGE;
    pCertReq->Length = Size;
    pCertReq->OffsetCertificate = Offset;
    pCertReq->CertLength = pCert->cbCertEncoded;
    pCertReq->Flags = dwMethods | REQ_ISSUER_CHAIN_MAPPING;

    RtlCopyMemory((PBYTE)pCertReq + Offset,
                  pCert->pbCertEncoded,
                  pCert->cbCertEncoded);
    Offset += pCert->cbCertEncoded;

    pCertReq->CertCount = CertCount;

    for(i = 0; i < CertCount; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;

        pCertReq->NameInfo[i].IssuerOffset = Offset;
        pCertReq->NameInfo[i].IssuerLength = pCurrentCert->pCertInfo->Issuer.cbData;

        RtlCopyMemory((PBYTE)pCertReq + Offset,
                      pCurrentCert->pCertInfo->Issuer.pbData,
                      pCurrentCert->pCertInfo->Issuer.cbData);
        Offset += pCurrentCert->pCertInfo->Issuer.cbData;
    }

    Offset = ROUND_UP_COUNT( Offset, ALIGN_DWORD );

#if DBG
    DsysAssert(Offset == Size);
#endif

    //
    // Return completed request.
    //

    *ppRequest = pCertReq;
    *pcbRequest = Size;

    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SslMapCertAtDC
//
//  Synopsis:   Maps a certificate to a user (hopefully) and the PAC,
//
//  Arguments:  [DomainName]    --
//              [pCredential]   --
//              [cbCredential]  --
//              [DcResponse]    --
//
//  History:    5-11-1998   RichardW    Created
//              2-26-2001   Jbanes      Added certificate chaining support.
//
//  Notes:      The request that gets sent to the DC looks something
//              like this:
//
//              typedef struct _MSV1_0_PASSTHROUGH_REQUEST {
//                  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
//                  UNICODE_STRING DomainName;
//                  UNICODE_STRING PackageName;
//                  ULONG DataLength;
//                  PUCHAR LogonData;
//                  ULONG Pad ;
//              } MSV1_0_PASSTHROUGH_REQUEST, *PMSV1_0_PASSTHROUGH_REQUEST;
//
//              <domain name>
//              <package name>
//              [ padding ]
//
//              <credential>
//              [ padding ]
//
//----------------------------------------------------------------------------
NTSTATUS
WINAPI
SslMapCertAtDC(
    IN     PUNICODE_STRING DomainName,
    IN     VOID const *pCredential,
    IN     DWORD cbCredential,
    IN     BOOL IsDC,
       OUT PUCHAR *UserPac,
       OUT PULONG UserPacLen,
       OUT PMSV1_0_PASSTHROUGH_RESPONSE * DcResponse)
{
    NTSTATUS Status ;
    PMSV1_0_PASSTHROUGH_REQUEST Request ;
    PMSV1_0_PASSTHROUGH_RESPONSE Response = NULL;
    PSSL_CERT_LOGON_RESP CertResp ;
    DWORD Size ;
    DWORD RequestSize ;
    DWORD ResponseSize ;
    PUCHAR Where ;
    NTSTATUS SubStatus ;
#if DBG
    DWORD CheckSize2 ;
#endif
    PSID pTrustSid = NULL;
    PUCHAR Pac = NULL;
    ULONG PacLength;

    DebugLog(( DEB_TRACE_MAPPER, "Remote call to DC to do the mapping\n" ));


    //
    // Validate the input parameters.
    //

    if(cbCredential > 0x4000)
    {
        return SEC_E_ILLEGAL_MESSAGE;
    }


    //
    // Verify that the target DC is in the same forest. Cross-forest 
    // certificate mapping is not supported, except via the S4U2Self
    // mechanism.
    
    if(IsDC)
    {
        BOOL fWithinForest = TRUE;

        Status = LsaIIsDomainWithinForest(DomainName,
                                          &fWithinForest,
                                          NULL,
                                          &pTrustSid,
                                          NULL,
                                          NULL,
                                          NULL);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SslMapCertAtDC: LsaIIsDomainWithinForest failed 0x%x\n", Status));
            goto cleanup;
        }
        if (!fWithinForest)
        {
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            DebugLog((DEB_ERROR, "SslMapCertAtDC: Target DC is outside forest - fail request 0x%x\n", Status));
            goto cleanup;
        }
    }


    //
    // Build the request to send to the DC.
    //

    Size = cbCredential;

    Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );

    RequestSize =   DomainName->Length +
                    SslLegacyPackageName.Length ;

    RequestSize = ROUND_UP_COUNT( RequestSize, ALIGN_DWORD );

#if DBG
    CheckSize2 = RequestSize ;
#endif

    RequestSize += sizeof( MSV1_0_PASSTHROUGH_REQUEST ) +
                   Size ;


    SafeAllocaAllocate( (PMSV1_0_PASSTHROUGH_REQUEST)Request, RequestSize );

    if ( !Request )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto cleanup;
    }

    Where = (PUCHAR) (Request + 1);

    Request->MessageType = MsV1_0GenericPassthrough ;
    Request->DomainName = *DomainName ;
    Request->DomainName.Buffer = (LPWSTR) Where ;

    RtlCopyMemory( Where,
                   DomainName->Buffer,
                   DomainName->Length );

    Where += DomainName->Length ;

    Request->PackageName = SslLegacyPackageName ;
    Request->PackageName.Buffer = (LPWSTR) Where ;
    RtlCopyMemory( Where,
                   SslLegacyPackageName.Buffer,
                   SslLegacyPackageName.Length );

    Where += SslLegacyPackageName.Length ;

    Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );

#if DBG
    DsysAssert( (((PUCHAR) Request) + CheckSize2 + sizeof( MSV1_0_PASSTHROUGH_REQUEST ) ) 
                                == (PUCHAR) Where );
#endif

    Request->LogonData = Where ;
    Request->DataLength = Size ;

    RtlCopyMemory(  Request->LogonData,
                    pCredential,
                    cbCredential );


    //
    // Now, call through to our DC:
    //

    Status = LsaCallAuthenticationPackage(
                SslLogonHandle,
                SslMsvPackageId,
                Request,
                RequestSize,
                &Response,
                &ResponseSize,
                &SubStatus );

    SafeAllocaFree( Request );
    Request = NULL;

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned status 0x%x\n", Status ));
        goto cleanup;
    }

    if ( !NT_SUCCESS( SubStatus ) )
    {
        DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned sub-status 0x%x\n", SubStatus ));
        Status = SubStatus;
        goto cleanup;
    }


    //
    // Extract out the returned PAC and perform SID filtering
    //

    CertResp = (PSSL_CERT_LOGON_RESP) Response->ValidationData ;

    PacLength = CertResp->AuthDataLength;
    Pac = MIDL_user_allocate( PacLength );
    if(Pac == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    memcpy(Pac, ((PUCHAR)CertResp) + CertResp->OffsetAuthData, PacLength);

    Status = SslCheckPacForSidFiltering(
                    pTrustSid,
                    &Pac,
                    &PacLength);

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_TRACE_MAPPER, "SslCheckPacForSidFiltering returned status 0x%x\n", Status ));
        goto cleanup;
    }
    

    //
    // Set output parameters.
    //

    *UserPac = Pac;
    *UserPacLen = PacLength;
    Pac = NULL;

    *DcResponse = Response;
    Response = NULL;


    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned 0x%x\n", Status ));

    Status = STATUS_SUCCESS;


cleanup:

    if(Pac)
    {
        MIDL_user_free(Pac);
    }

    if(pTrustSid)
    {
        MIDL_user_free(pTrustSid);
    }

    if(Response)
    {
        LsaTable->FreeReturnBuffer(Response);
    }

    return Status;
}


NTSTATUS
NTAPI
SslMapExternalCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PSSL_EXTERNAL_CERT_LOGON_REQ Request;
    PSSL_EXTERNAL_CERT_LOGON_RESP Response;
    NT_PRODUCT_TYPE ProductType;
    BOOL DC;
    HMAPPER Mapper;
    NTSTATUS Status;
    HANDLE hUserToken = NULL;

    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ClientBufferBase);

    DebugLog(( DEB_TRACE_MAPPER, "SslMapExternalCredential\n" ));

    //
    // Validate the input parameters.
    //

    if ( ARGUMENT_PRESENT( ProtocolReturnBuffer ) )
    {
        *ProtocolReturnBuffer = NULL ;
    }

    if(SubmitBufferLen < sizeof(SSL_EXTERNAL_CERT_LOGON_REQ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    Request = (PSSL_EXTERNAL_CERT_LOGON_REQ) ProtocolSubmitBuffer ;

    if(Request->Length != sizeof(SSL_EXTERNAL_CERT_LOGON_REQ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }


    //
    // Attempt to map the certificate.
    //

    if(RtlGetNtProductType(&ProductType))
    {
        DC = (ProductType == NtProductLanManNt);
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
        goto cleanup;
    }

    memset(&Mapper, 0, sizeof(Mapper));

    Mapper.m_dwFlags = SCH_FLAG_SYSTEM_MAPPER | Request->Flags;

    if(DC)
    {
        Status = SslLocalMapCredential( &Mapper,
                                        Request->CredentialType,
                                        Request->Credential,
                                        NULL,
                                        (PHLOCATOR)&hUserToken);
    }
    else
    {
        Status = SslRemoteMapCredential(&Mapper,
                                        Request->CredentialType,
                                        Request->Credential,
                                        NULL,
                                        (PHLOCATOR)&hUserToken);
    }

    if(!NT_SUCCESS(Status))
    {
        *ReturnBufferLength = 0;
        *ProtocolStatus = Status;
        Status = STATUS_SUCCESS;
        goto cleanup;
    }


    //
    // Build the response.
    //

    Response = VirtualAlloc(
                    NULL,
                    sizeof(SSL_EXTERNAL_CERT_LOGON_RESP),
                    MEM_COMMIT,
                    PAGE_READWRITE);

    if ( Response )
    {
        Response->MessageType = SSL_LOOKUP_EXTERNAL_CERT_MESSAGE;
        Response->Length = sizeof(SSL_EXTERNAL_CERT_LOGON_RESP);
        Response->UserToken = hUserToken;
        Response->Flags = 0;

        *ProtocolReturnBuffer = Response;
        *ReturnBufferLength = Response->Length;
        *ProtocolStatus = STATUS_SUCCESS;
        hUserToken = NULL;

        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

cleanup:

    if(hUserToken)
    {
        CloseHandle(hUserToken);
    }

    DebugLog(( DEB_TRACE_MAPPER, "SslRemoteMapCredential returns 0x%x\n", Status ));

    return Status;
}


DWORD
WINAPI
SslRemoteMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator
    )
{
    PCCERT_CONTEXT pCert = (PCERT_CONTEXT)pCredential;
    NTSTATUS Status ;
    NTSTATUS VerifyStatus ;
    HANDLE Token ;
    LUID LogonId = { 0 };
    PMSV1_0_PASSTHROUGH_RESPONSE Response ;
    PSSL_CERT_LOGON_RESP CertResp ;
    UNICODE_STRING AccountDomain ;
    DWORD dwMethods;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PSSL_CERT_LOGON_REQ pRequest = NULL;
    DWORD cbRequest;
    PUCHAR Pac = NULL;
    ULONG PacLength;

    UNREFERENCED_PARAMETER(pAuthority);

    DebugLog(( DEB_TRACE_MAPPER, "SslRemoteMapCredential, context %x\n", Mapper ));

    if ( CredentialType != X509_ASN_CHAIN )
    {
        return( (DWORD)SEC_E_UNKNOWN_CREDENTIALS );
    }


    //
    // Validate client certificate, and obtain pointer to 
    // entire certificate chain.
    //

    Status = MapperVerifyClientChain(pCert,
                                     Mapper->m_dwFlags,
                                     &dwMethods,
                                     &VerifyStatus,
                                     &pChainContext);
    if(Status != STATUS_SUCCESS)
    {
        return Status;
    }


    //
    // Attempt to logon via Kerberos S4U2Self.
    //

    if((dwMethods & REQ_UPN_MAPPING) &&
       (g_dwCertMappingMethods & SP_REG_CERTMAP_S4U2SELF_FLAG))
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying S4U2Self mapping\n" ));

        Status = SslTryS4U2Self(pChainContext, &Token);

        if ( NT_SUCCESS( Status ) )
        {
            CertFreeCertificateChain(pChainContext);
            pChainContext = NULL;

            *phLocator = (HLOCATOR) Token ;

            return Status;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Build the logon request.
    //

    Status = SslBuildCertLogonRequest(pChainContext,
                                      dwMethods,
                                      &pRequest,
                                      &cbRequest);

    CertFreeCertificateChain(pChainContext);
    pChainContext = NULL;

    if(FAILED(Status))
    {
        return Status;
    }


    //
    // Send the request to the DC.
    //

    Status = SslMapCertAtDC(
                &SslDomainName,
                pRequest,
                cbRequest,
                FALSE,
                &Pac,
                &PacLength,
                &Response );

    LocalFree(pRequest);
    pRequest = NULL;

    if ( !NT_SUCCESS( Status ) )
    {
        LsaTable->AuditLogon(
                    Status,
                    VerifyStatus,
                    &SslNullString,
                    &SslNullString,
                    NULL,
                    NULL,
                    Network,
                    &SslTokenSource,
                    &LogonId );

        LogCertMappingFailureEvent(Status);

        if(!NT_SUCCESS(VerifyStatus))
        {
            // Return certificate validation error code, unless the mapper
            // error has already been mapped to a proper sspi error code.
            if(HRESULT_FACILITY(Status) != FACILITY_SECURITY)
            {
                Status = VerifyStatus;
            }
        }

        return Status ;
    }

    //
    // Ok, we got mapping data.  Try to use it:
    //

    CertResp = (PSSL_CERT_LOGON_RESP) Response->ValidationData ;

    //
    // older servers (pre 2010 or so) won't return the full structure,
    // so we need to examine it carefully.

    if ( CertResp->Length - CertResp->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
    {
        AccountDomain = SslDomainName ;
    }
    else 
    {
        if ( CertResp->DomainLength < 65536 )
        {
            AccountDomain.Length = (USHORT) CertResp->DomainLength ;
            AccountDomain.MaximumLength = AccountDomain.Length ;
            AccountDomain.Buffer = (PWSTR) (((PUCHAR) CertResp) + CertResp->OffsetDomain );
        }
        else 
        {
            AccountDomain = SslDomainName ;
        }
    }

    Status = SslCreateTokenFromPac( Pac,
                                    PacLength,
                                    &AccountDomain,
                                    