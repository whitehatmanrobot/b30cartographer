   { L"CCSID01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CCSID01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CCSID01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CCSID01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CCSID01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CCSID01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CCSID01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"chinese", 936, 936, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"cn-big5", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CN-GB", 936, 936, MIMECONTF_MIME_LATEST },
    { L"CP00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CP00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CP01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CP01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CP01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CP01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CP01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CP01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CP01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CP01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CP01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CP01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"cp037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"cp1025", 1251, 21025, MIMECONTF_MIME_LATEST },
    { L"CP1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"cp1256", 1256, 1256, MIMECONTF_MIME_LATEST },
    { L"CP273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"CP278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"CP280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"CP284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"CP285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"cp290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"cp297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"cp367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"cp367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"cp423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"cp424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"cp437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"CP500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"cp819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"cp819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"cp852", 1250, 852, MIMECONTF_MIME_LATEST},
    { L"cp852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"cp855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"cp857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"cp858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"cp860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"cp861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"cp862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"cp863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"cp864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"cp865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"cp866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"cp866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"cp869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"CP870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"CP871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"cp875", 1253, 875, MIMECONTF_MIME_LATEST },
    { L"cp880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"CP905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"cp930", 932, 50930, MIMECONTF_MIME_LATEST },
    { L"cp933", 949, 50933, MIMECONTF_MIME_LATEST },
    { L"cp935", 936, 50935, MIMECONTF_MIME_LATEST },
    { L"cp937", 950, 50937, MIMECONTF_MIME_LATEST },
    { L"cp939", 932, 50939, MIMECONTF_MIME_LATEST },
    { L"csASCII", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"csASCII", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"csbig5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"csEUCKR", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"csEUCPkdFmtJapanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csIBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"csIBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"csIBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"csIBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"csIBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"csIBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"csIBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"csIBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"csIBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"csIBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"csIBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"csIBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"csIBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"csIBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"csIBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"csIBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"csIBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"csIBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"csIBMThai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"csISO2022JP", 932, 50221, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO2022KR", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO58GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"csISOLatin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"csISOLatin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"csISOLatin5", 1251, 28595, MIMECONTF_MIME_IE4},
    { L"csISOLatin9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"csISOLatinArabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"csISOLatinArabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"csISOLatinCyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinGreek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinHebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKOI8R", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKSC56011987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csPC8CodePage437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"csShiftJIS", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csUnicode11UTF7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csWindows31J", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"cyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"DIN_66003", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"DOS-720", 1256, 720, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-862", 1255, 862, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-874", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ebcdic-cp-ar1", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-be", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ca", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ch", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-DK", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-es", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fi", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fr", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gb", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gr", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-he", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-is", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-it", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-nl", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-NO", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-roece", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-se", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-tr", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-us", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-wt", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-yu", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-Cyrillic", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"ebcdic-de-273+euro", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"ebcdic-dk-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-es-284+euro", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fi-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fr-297+euro", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"ebcdic-gb-285+euro", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"ebcdic-international-500+euro", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"ebcdic-is-871+euro", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"ebcdic-it-280+euro", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-JP-kana", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"ebcdic-Latin9--euro", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"ebcdic-no-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-se-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-us-37+euro", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"ECMA-114", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ECMA-114", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ECMA-118", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ELOT_928", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-kr", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"euc-kr", 949, 949, MIMECONTF_MIME_IE4 },
    { L"Extended_UNIX_Code_Packed_Format_for_Japanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB_2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB18030", 936, 54936, MIMECONTF_MIME_LATEST}, 
    { L"GB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GBK", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"greek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"greek8", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hz-gb-2312", 936, 52936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"IBM00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"IBM00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"IBM01047", 1252, 1047, MIMECONTF_MIME_LATEST },
    { L"IBM01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"IBM01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"IBM01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"IBM01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"IBM01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"IBM01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"IBM01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"IBM01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"IBM01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"IBM01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"IBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"IBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"IBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"IBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"IBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"IBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"IBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"IBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"IBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"IBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"IBM367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"IBM367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"IBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"IBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"IBM437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"IBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ibm737", 1252, 737, MIMECONTF_MIME_LATEST},
    { L"ibm775", 1257, 775, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"IBM852", 1250, 852, MIMECONTF_MIME_LATEST },
    { L"IBM852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"IBM855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"IBM857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"IBM860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"IBM861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"IBM862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"IBM863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"IBM864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"IBM865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"IBM866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"IBM866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"IBM869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"IBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"IBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"IBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"IBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"IBM-Thai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"irv", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 1252,  MIMECONTF_MIME_IE4},
    { L"iso_8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso_8859-1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"iso_8859-1:1987", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso_8859-1:1987", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso_8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso_8859-2:1987", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-3:1988", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-4:1988", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5:1988", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-6", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-6:1987", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6:1987", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-7",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-7:1987",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8:1988", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8-I", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9:1989", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9:1989", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-2022-jp", 932, 50220, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-jpeuc", 932, 51932, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-kr-7", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-7bit", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-8", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"iso-2022-kr-8bit", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 20127, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso8859-1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso8859-1", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-8859-1", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso-8859-11", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-13", 1257, 28603, MIMECONTF_MIME_LATEST},
    { L"iso-8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-3", 1254, 28593, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-6", 1256, 28596, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-7", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ISO-8859-8 Visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"ISO-8859-8 Visual", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"iso-8859-8-i", 1255, 38598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-100", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-ir-100", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-ir-101", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-109", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"iso-ir-110", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-126",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-127", 1256, 28596, MIMECONTF_MIME_LATEST },
    { L"iso-ir-127", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"iso-ir-138", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-144", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-148", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-ir-148", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-149", 949, 949, MIMECONTF_MIME_LATEST},
    { L"iso-ir-58", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-6", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"iso-ir-6", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"Johab", 1361, 1361, MIMECONTF_MIME_LATEST},
    { L"koi", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"koi8", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8r", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8-r", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-ru", 1251, 21866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-u", 1251, 21866, MIMECONTF_MIME_LATEST},
    { L"korean", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601_1987", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks_c_5601-1987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ks_c_5601-1989", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC_5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks-c5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks-c-5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"l1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"l2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"l4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"l5", 1251, 28595, MIMECONTF_MIME_IE4 },
    { L"l9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"latin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"latin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin5", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"latin5", 1254, 1254, MIMECONTF_MIME_IE4},
    { L"latin9", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"macintosh", 1252, 10000, MIMECONTF_MIME_LATEST},
    { L"ms_Kanji", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"NS_4551-1", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"PC-Multilingual-850+euro", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"SEN_850200_B", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"shift_jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"shift-jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"sjis", 932, 932, MIMECONTF_MIME_LATEST},
    { L"Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"TIS-620", 874, 874, MIMECONTF_MIME_LATEST},
    { L"unicode", 1200, 1200, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"unicode-2-0-utf-8",1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicodeFFFE", 1200, 1201, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"us", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"us-ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us-ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"utf-16", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"UTF-16BE", 1200, 1201, MIMECONTF_MIME_LATEST },
    { L"UTF-16LE", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"visual", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"windows-1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1252", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1253", 1253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Windows-1254", 1254, 1254, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1255", 1255, 1255, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1256", 1256, 1256, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1257", 1257, 1257, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1258", 1258, 1258, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-874", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-ansi", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Chinese-CNS", 950, 20000, MIMECONTF_MIME_LATEST},
    { L"x-Chinese-Eten", 950, 20002, MIMECONTF_MIME_LATEST},
    { L"x-cp1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp20001", 1252, 20001, MIMECONTF_MIME_LATEST },
    { L"x-cp20003", 1252, 20003, MIMECONTF_MIME_LATEST },
    { L"x-cp20004", 1252, 20004, MIMECONTF_MIME_LATEST },
    { L"x-cp20005", 1252, 20005, MIMECONTF_MIME_LATEST },
    { L"x-cp20261", 1252, 20261, MIMECONTF_MIME_LATEST },
    { L"x-cp20269", 1252, 20269, MIMECONTF_MIME_LATEST },
    { L"x-cp20936", 1252, 20936, MIMECONTF_MIME_LATEST },
    { L"x-cp20949", 1252, 20949, MIMECONTF_MIME_LATEST },
    { L"x-cp21027", 1252, 21027, MIMECONTF_MIME_LATEST },
    { L"x-cp50227", 1252, 50227, MIMECONTF_MIME_LATEST },
    { L"x-cp50229", 1252, 50229, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-JapaneseAndUSCanada", 932, 50931, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-KoreanExtended", 949, 20833, MIMECONTF_MIME_LATEST },
    { L"x-euc", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"x-euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Europa", 1252, 29001, MIMECONTF_MIME_LATEST},
    { L"x-IA5", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"x-IA5-German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"x-iscii-as", 57006, 57006, MIMECONTF_MIME_LATEST},
    { L"x-iscii-be", 57003, 57003, MIMECONTF_MIME_LATEST},
    { L"x-iscii-de", 57002, 57002, MIMECONTF_MIME_LATEST},
    { L"x-iscii-gu", 57010, 57010, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ka", 57008, 57008, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ma", 57009, 57009, MIMECONTF_MIME_LATEST},
    { L"x-iscii-or", 57007, 57007, MIMECONTF_MIME_LATEST},
    { L"x-iscii-pa", 57011, 57011, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ta", 57004, 57004, MIMECONTF_MIME_LATEST},
    { L"x-iscii-te", 57005, 57005, MIMECONTF_MIME_LATEST},
    { L"x-mac-arabic", 1256, 10004, MIMECONTF_MIME_LATEST},
    { L"x-mac-ce", 1250, 10029, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesesimp", 936, 10008, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesetrad", 950, 10002, MIMECONTF_MIME_LATEST},
    { L"x-mac-croatian", 1250, 10082, MIMECONTF_MIME_LATEST}, 
    { L"x-mac-cyrillic", 1251, 10007, MIMECONTF_MIME_LATEST},
    { L"x-mac-greek", 1253, 10006, MIMECONTF_MIME_LATEST},
    { L"x-mac-hebrew", 1255, 10005, MIMECONTF_MIME_LATEST},
    { L"x-mac-icelandic", 1252, 10079, MIMECONTF_MIME_LATEST},
    { L"x-mac-japanese", 932, 10001, MIMECONTF_MIME_LATEST},
    { L"x-mac-korean", 949, 10003, MIMECONTF_MIME_LATEST},
    { L"x-mac-romanian", 1250, 10010, MIMECONTF_MIME_LATEST},
    { L"x-mac-thai", 874, 10021, MIMECONTF_MIME_LATEST},
    { L"x-mac-turkish", 1254, 10081, MIMECONTF_MIME_LATEST},
    { L"x-mac-ukrainian", 1251, 10017, MIMECONTF_MIME_LATEST},
    { L"x-ms-cp932", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-sjis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"x-unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST},
    { L"x-unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-unicode-2-0-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-user-defined", 50000, 50000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-x-big5", 950, 950, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
//  { Charset, CodePage, InternetEncoding, Flags }
};

// Hard code sorted table by code page description and family code page.

MIMECODEPAGE MimeCodePage[] =
{
//  { CodePage, HeaderCharset, BodyCharset, WebCharset, FixedWidthFont, ProportionalFont, Description, FamilyCodePage, Flags }
    { 864, NULL, L"IBM864", NULL, 0, 0, IDS_DESC_864, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 708, NULL, L"ASMO-708", NULL, 0, 0, IDS_DESC_708, 1256, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 708, NULL, L"ASMO-708", NULL, 0, 0, IDS_DESC_708, 1256, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51256, NULL, L"_autodetect_arabic", L"windows-1256", 0,  0, IDS_DESC_51256, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT },
    { 720, NULL, L"DOS-720", NULL, 0, 0, IDS_DESC_720, 1256, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 720, NULL, L"DOS-720", NULL, 0, 0, IDS_DESC_720, 1256, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28596, NULL, L"iso-8859-6", NULL, 0, 0, IDS_DESC_28596, 1256, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10004, NULL, L"x-mac-arabic", NULL, 0, 0, IDS_DESC_10004, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1256, NULL, L"windows-1256", NULL, IDS_FONT_ARABIC_FIXED, IDS_FONT_ARABIC_PROP, IDS_DESC_1256, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1256, NULL, L"windows-1256", L"windows-1256", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1256, 0, 0x00000707| MIMECONTF_MIME_IE4},
    { 50001, NULL, L"_autodetect_all", NULL, 0, 0, IDS_DESC_50001, 0, 0x00000007|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 775, NULL, L"ibm775", NULL, 0, 0, IDS_DESC_775, 1257, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28594, NULL, L"iso-8859-4", NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28594, NULL, L"iso-8859-4", NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000301|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1257, L"windows-1257", L"windows-1257", L"windows-1257", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1257, NULL, L"iso-8859-4", L"windows-1257", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 852, NULL, L"ibm852", NULL, 0, 0, IDS_DESC_852, 1250, 0x00000202|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28592, NULL, L"iso-8859-2", NULL, 0, 0, IDS_DESC_28592, 1250, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10029, NULL, L"x-mac-ce", NULL, 0, 0, IDS_DESC_10029, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1250, L"windows-1250", L"iso-8859-2", L"windows-1250", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1250, NULL, L"iso-8859-2", L"windows-1250", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50936, NULL, L"_autodetect_chs", NULL, 0, 0, IDS_DESC_50936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT },
    { 51936, NULL, L"EUC-CN", NULL, 0, 0, IDS_DESC_51936, 936, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT|MIMECONTF_IMPORT},
    { 54936, NULL, L"GB18030", NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_54936, 936, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 936, NULL, L"gb2312", NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_936, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 20936, NULL, L"x-cp20936", NULL, 0, 0, IDS_DESC_20936, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 52936, NULL, L"hz-gb-2312", NULL, 0, 0, IDS_DESC_52936, 936, 0x00000303|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50227, NULL, L"x-cp50227", NULL, 0, 0, IDS_DESC_50227, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10008, NULL, L"x-mac-chinesesimp", NULL, 0, 0, IDS_DESC_10008, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50950, NULL, L"_autodetect_cht", NULL, 0, 0, IDS_DESC_50950, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 950, NULL, L"big5", NULL, IDS_FONT_TAIWAN_FIXED, IDS_FONT_TAIWAN_PROP, IDS_DESC_950, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20000, NULL, L"x-Chinese-CNS", NULL, 0, 0, IDS_DESC_20000, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20002, NULL, L"x-Chinese-Eten", NULL, 0, 0, IDS_DESC_20002, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50229, NULL, L"x-cp50229", NULL, 0, 0, IDS_DESC_50229, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10002, NULL, L"x-mac-chinesetrad", NULL, 0, 0, IDS_DESC_10002, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10082, NULL, L"x-mac-croatian", NULL, 0, 0, IDS_DESC_10082, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51251, NULL, L"_auto_detect_cyrillic", L"windows-1251", 0, 0, IDS_DESC_51251, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 866, NULL, L"cp866", NULL, 0, 0, IDS_DESC_866, 1251, 0x00000202|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28595, NULL, L"iso-8859-5", NULL, 0, 0, IDS_DESC_28595, 1251, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20866, NULL, L"koi8-r", NULL, 0, 0, IDS_DESC_20866, 1251, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 21866, NULL, L"koi8-u", NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 21866, NULL, L"koi8-ru", NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10007, NULL, L"x-mac-cyrillic", NULL, 0, 0, IDS_DESC_10007, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1251, L"windows-1251", L"koi8-r", L"windows-1251", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1251, NULL, L"koi8-r", L"windows-1251", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28603, NULL, L"iso-8859-13", NULL, 0, 0, IDS_DESC_28603, 1257, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 29001, NULL, L"x-Europa", NULL, 0, 0, IDS_DESC_29001, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 21027, NULL, L"x-cp21027", NULL, 0, 0, IDS_DESC_21027, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 863, NULL, L"IBM863", NULL, 0, 0, IDS_DESC_863, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20106, NULL, L"x-IA5-German", NULL, 0, 0, IDS_DESC_20106, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51253, NULL, L"_auto_detect_greek", L"windows-1253", 0, 0, IDS_DESC_51253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT},
    { 737, NULL, L"ibm737", NULL, 0, 0, IDS_DESC_737, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28597, NULL, L"iso-8859-7", NULL, 0, 0, IDS_DESC_28597, 1253, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10006, NULL, L"x-mac-greek", NULL, 0, 0, IDS_DESC_10006, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1253, L"windows-1253", L"iso-8859-7", L"windows-1253", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1253, NULL, L"iso-8859-7", L"windows-1253", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 869, NULL, L"ibm869", NULL, 0, 0, IDS_DESC_869, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 862, NULL, L"DOS-862", NULL, 0, 0, IDS_DESC_862, 1255, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 862, NULL, L"DOS-862", NULL, 0, 0, IDS_DESC_862, 1255, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 38598, NULL, L"iso-8859-8-i", NULL, 0, 0, IDS_DESC_38598, 1255, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28598, NULL, L"iso-8859-8", NULL, 0, 0, IDS_DESC_28598, 1255, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10005, NULL, L"x-mac-hebrew", NULL, 0, 0, IDS_DESC_10005, 1255, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1255, NULL, L"windows-1255", NULL, IDS_FONT_HEBREW_FIXED, IDS_FONT_HEBREW_PROP, IDS_DESC_1255, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1255, NULL, L"iso-8859-8", L"windows-1255", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1255, 0, 0x00000707|MIMECONTF_MIME_IE4},
    { 20003, NULL, L"x-cp20003", NULL, 0, 0, IDS_DESC_20003, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20420, NULL, L"IBM420", NULL, 0, 0, IDS_DESC_20420, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20880, NULL, L"IBM880", NULL, 0, 0, IDS_DESC_20880, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 21025, NULL, L"cp1025", NULL, 0, 0, IDS_DESC_21025, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20277, NULL, L"IBM277", NULL, 0, 0, IDS_DESC_20277, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1142, NULL, L"IBM01142", NULL, 0, 0, IDS_DESC_1142, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20278, NULL, L"IBM278", NULL, 0, 0, IDS_DESC_20278, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1143, NULL, L"IBM01143", NULL, 0, 0, IDS_DESC_1143, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20297, NULL, L"IBM297", NULL, 0, 0, IDS_DESC_20297, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1147, NULL, L"IBM01147", NULL, 0, 0, IDS_DESC_1147, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20273, NULL, L"IBM273", NULL, 0, 0, IDS_DESC_20273, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1141, NULL, L"IBM01141", NULL, 0, 0, IDS_DESC_1141, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20423, NULL, L"IBM423", NULL, 0, 0, IDS_DESC_20423, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 875, NULL, L"cp875", NULL, 0, 0, IDS_DESC_875, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20424, NULL, L"IBM424", NULL, 0, 0, IDS_DESC_20424, 1255, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20871, NULL, L"IBM871", NULL, 0, 0, IDS_DESC_20871, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1149, NULL, L"IBM01149", NULL, 0, 0, IDS_DESC_1149, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 500, NULL, L"IBM500", NULL, 0, 0, IDS_DESC_500, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1148, NULL, L"IBM01148", NULL, 0, 0, IDS_DESC_1148, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20280, NULL, L"IBM280", NULL, 0, 0, IDS_DESC_20280, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1144, NULL, L"IBM01144", NULL, 0, 0, IDS_DESC_1144, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50930, NULL, L"cp930", NULL, 0, 0, IDS_DESC_50930, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50939, NULL, L"cp939", NULL, 0, 0, IDS_DESC_50939, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50931, NULL, L"x-EBCDIC-JapaneseAndUSCanada", NULL, 0, 0, IDS_DESC_50931, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20290, NULL, L"IBM290", NULL, 0, 0, IDS_DESC_20290, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50933, NULL, L"cp933", NULL, 0, 0, IDS_DESC_50933, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20833, NULL, L"x-EBCDIC-KoreanExtended", NULL, 0, 0, IDS_DESC_20833, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 870, NULL, L"IBM870", NULL, 0, 0, IDS_DESC_870, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50935, NULL, L"cp935", NULL, 0, 0, IDS_DESC_50935, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20284, NULL, L"IBM284", NULL, 0, 0, IDS_DESC_20284, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1145, NULL, L"IBM01145", NULL, 0, 0, IDS_DESC_1145, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20838, NULL, L"IBM-Thai", NULL, 0, 0, IDS_DESC_20838, 874, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50937, NULL, L"cp937", NULL, 0, 0, IDS_DESC_50937, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20905, NULL, L"IBM905", NULL, 0, 0, IDS_DESC_20905, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1026, NULL, L"IBM1026", NULL, 0, 0, IDS_DESC_1026, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20285, NULL, L"IBM285", NULL, 0, 0, IDS_DESC_20285, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1146, NULL, L"IBM01146", NULL, 0, 0, IDS_DESC_1146, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 37, NULL, L"IBM037", NULL, 0, 0, IDS_DESC_37, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1140, NULL, L"IBM01140", NULL, 0, 0, IDS_DESC_1140, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1047, NULL, L"IBM01047", NULL, 0, 0, IDS_DESC_1047, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20924, NULL, L"IBM00924", NULL, 0, 0, IDS_DESC_20924, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 861, NULL, L"ibm861", NULL, 0, 0, IDS_DESC_861, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10079, NULL, L"x-mac-icelandic", NULL, 0, 0, IDS_DESC_10079, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57006, NULL, L"x-iscii-as", NULL, 0, 0, IDS_DESC_57006, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57003, NULL, L"x-iscii-be", NULL, 0, 0, IDS_DESC_57003, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57002, NULL, L"x-iscii-de", NULL, IDS_FONT_DEVANAGARI_FIXED, IDS_FONT_DEVANAGARI_PROP, IDS_DESC_57002, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57010, NULL, L"x-iscii-gu", NULL, 0, 0, IDS_DESC_57010, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57008, NULL, L"x-iscii-ka", NULL, 0, 0, IDS_DESC_57008, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57009, NULL, L"x-iscii-ma", NULL, 0, 0, IDS_DESC_57009, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57007, NULL, L"x-iscii-or", NULL, 0, 0, IDS_DESC_57007, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57011, NULL, L"x-iscii-pa", NULL, 0, 0, IDS_DESC_57011, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57004, NULL, L"x-iscii-ta", NULL, IDS_FONT_TAMIL_FIXED, IDS_FONT_TAMIL_PROP, IDS_DESC_57004, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57005, NULL, L"x-iscii-te", NULL, 0, 0, IDS_DESC_57005, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20269, NULL, L"x-cp20269", NULL, 0, 0, IDS_DESC_20269, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50932, NULL, L"_autodetect", NULL, 0, 0, IDS_DESC_50932, 932, 0x00000007|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT},
    { 51932, NULL, L"euc-jp", NULL, 0, 0, IDS_DESC_51932, 932, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50220, NULL, L"iso-2022-jp", NULL, 0, 0, IDS_DESC_50220, 932, 0x00000101|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20932, NULL, L"EUC-JP", NULL, 0, 0, IDS_DESC_20932, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50221, NULL, L"iso-2022-jp", L"csISO2022JP", 0, 0, IDS_DESC_50221, 932, 0x00000301|MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT},
    { 50221, NULL, L"_iso-2022-jp$ESC", L"csISO2022JP", 0, 0, IDS_DESC_50221, 932, 0x00000301|MIMECONTF_MIME_IE4|MIMECONTF_EXPORT},
    { 50222, NULL, L"iso-2022-jp", NULL, 0, 0, IDS_DESC_50222, 932, MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT},
    { 50222, NULL, L"_iso-2022-jp$SIO", L"iso-2022-jp", 0, 0, IDS_DESC_50222, 932, MIMECONTF_MIME_IE4|MIMECONTF_EXPORT},
    { 10001, NULL, L"x-mac-japanese", NULL, 0, 0, IDS_DESC_10001, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 932, NULL, L"iso-2022-jp", L"shift_jis", IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, IDS_DESC_932, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 949, NULL, L"ks_c_5601-1987", NULL, IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_949, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 949, L"euc-kr", L"euc-kr", L"ks_c_5601-1987", IDS_FONT_KOREAN_FIXED4, IDS_FONT_KOREAN_PROP4, IDS_DESC_949, 0, 0x00000707| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50949, NULL, L"_autodetect_kr", NULL, 0, 0, IDS_DESC_50949, 949, 0x00000001|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT},
    { 51949, NULL, L"euc-kr", NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT|MIMECONTF_MAILNEWS|MIMECONTF_SAVABLE_MAILNEWS},
    { 51949, NULL, L"euc-kr", NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50225, L"euc-kr", L"iso-2022-kr", L"iso-2022-kr", 0, 0, IDS_DESC_50225, 949, 0x00000001|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50225, NULL, L"iso-2022-kr", L"iso-2022-kr", 0, 0, IDS_DESC_50225, 949, 0x00000101| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1361, NULL, L"Johab", NULL,IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_1361, 949, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10003, NULL, L"x-mac-korean", NULL, 0, 0, IDS_DESC_10003, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20949, NULL, L"x-cp20949", NULL, 0, 0, IDS_DESC_20949, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28593, NULL, L"iso-8859-3", NULL, 0, 0, IDS_DESC_28593, 1254, 0x00000501|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28605, NULL, L"iso-8859-15", NULL, 0, 0, IDS_DESC_28605, 1252, 0x00000701|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 865, NULL, L"IBM865", NULL, 0, 0, IDS_DESC_865, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20108, NULL, L"x-IA5-Norwegian", NULL, 0, 0, IDS_DESC_20108, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 855, NULL, L"IBM855", NULL, 0, 0, IDS_DESC_855, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 437, NULL, L"IBM437", NULL, 0, 0, IDS_DESC_437, 1252, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 858, NULL, L"IBM00858", NULL, 0, 0, IDS_DESC_858, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 860, NULL, L"IBM860", NULL, 0, 0, IDS_DESC_860, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10010, NULL, L"x-mac-romanian", NULL, 0, 0, IDS_DESC_10010, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20107, NULL, L"x-IA5-Swedish", NULL, 0, 0, IDS_DESC_20107, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20261, NULL, L"x-cp20261", NULL, 0, 0, IDS_DESC_20261, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20001, NULL, L"x-cp20001", NULL, 0, 0, IDS_DESC_20001, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20004, NULL, L"x-cp20004", NULL, 0, 0, IDS_DESC_20004, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 10021, NULL, L"x-mac-thai", NULL, IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_10021, 874, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 874, NULL, L"windows-874", NULL, IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_874, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 874, NULL, L"windows-874", NULL, IDS_FONT_THAI_FIXED2, IDS_FONT_THAI_PROP2, IDS_DESC_874, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 857, NULL, L"ibm857", NULL, 0, 0, IDS_DESC_857, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28599, NULL, L"iso-8859-9", NULL, 0, 0, IDS_DESC_28599, 1254, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT|MIMECONTF_EXPORT},    
    { 10081, NULL, L"x-mac-turkish", NULL, 0, 0, IDS_DESC_10081, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1254, L"windows-1254", L"iso-8859-9", L"windows-1254", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10017, NULL, L"x-mac-ukrainian", NULL, 0, 0, IDS_DESC_10017, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1254, NULL, L"iso-8859-9", L"iso-8859-9", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1200, NULL, L"unicode", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1200, 0, 0x00000204|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1201, NULL, L"unicodeFFFE",   NULL, 0, 0, IDS_DESC_1201, 1200, 0x00000000|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 65000, NULL, L"utf-7", NULL, 0, 0, IDS_DESC_65000, 1200, 0x00000101|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 65001, NULL, L"utf-8", NULL, 0, 0, IDS_DESC_65001, 1200, 0x00000303|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20127, NULL, L"us-ascii", NULL, 0, 0, IDS_DESC_20127, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT|MIMECONTF_MAILNEWS|MIMECONTF_SAVABLE_MAILNEWS},
    { 50000, NULL, L"x-user-defined", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_UNICODE_PROP, IDS_DESC_50000, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1258, NULL, L"windows-1258", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1258, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20005, NULL, L"x-cp20005", NULL, 0, 0, IDS_DESC_20005, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1252, NULL, L"iso-8859-1", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252_IE4, 0, 0x00000707| MIMECONTF_MIME_IE4},
    { 850, NULL, L"ibm850", NULL, 0, 0, IDS_DESC_850, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20105, NULL, L"x-IA5", NULL, 0, 0, IDS_DESC_20105, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28591, NULL, L"iso-8859-1", NULL, 0, 0, IDS_DESC_28591, 1252, 0x00000703|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10000, NULL, L"macintosh", NULL, 0, 0, IDS_DESC_10000, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1252, L"Windows-1252", L"iso-8859-1", L"Windows-1252", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0},
//  { CodePage, HeaderCharset, BodyCharset, WebCharset, FixedWidthFont, ProportionalFont, Description, FamilyCodePage, Flags }

}; 


#ifdef UNIX
/* Convert from little endian to big endian format */
#define CONVERTLONG(a,b,c,d) (((unsigned long )a) + \
                           ((unsigned long )b << 8) + \
                           ((unsigned long )c << 16) + \
                           ((unsigned long )d << 24))
#endif /* UNIX */

//
//  Globals
//
CMimeDatabase *g_pMimeDatabase = NULL;

//
//  CMimeDatabase implementation
//
STDAPI CMimeDatabase::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    HRESULT hr = S_OK;
    if (pcCodePage)
    {
        *pcCodePage = 0;
        for (int i=0;i<ARRAYSIZE(MimeCodePage);i++)
        {
            if (MimeCodePage[i].dwFlags & dwMimeSource)
               (*pcCodePage)++;
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

STDAPI CMimeDatabase::GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo )
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfo called."));

    for (idx=0; idx < ARRAYSIZE(MimeCodePage); idx++)
    {
        if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
            (MimeCodePage[idx].dwFlags & dwMimeSource))
            break;
    }

    if (idx < ARRAYSIZE(MimeCodePage))
    {
        hr = GetCodePageInfoWithIndex(idx, LangId, pcpInfo);
    }

    return hr;
}


STDAPI CMimeDatabase::GetCodePageInfoWithIndex(UINT uidx, LANGID LangId, PMIMECPINFO pcpInfo)
{    
    HRESULT hr = E_FAIL;
    LANGID langid = LangId;
    CHARSETINFO rCharsetInfo;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfoWithIndex called."));

    if (uidx >= ARRAYSIZE(MimeCodePage))
        return hr;  

    if (!_LoadStringExW(g_hInst, MimeCodePage[uidx].uidDescription, pcpInfo->wszDescription, MAX_MIMECP_NAME, langid))
    {
            // Last try, switch to English, US
            langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            if (!_LoadStringExW(g_hInst, MimeCodePage[uidx].uidDescription, pcpInfo->wszDescription, MAX_MIMECP_NAME, langid))
                return hr;
    }

    if ((0 == MimeCodePage[uidx].uidFixedWidthFont || 0 == MimeCodePage[uidx].uidProportionalFont))         
    {
        pcpInfo->wszFixedWidthFont[0] = 0;
        pcpInfo->wszProportionalFont[0] = 0;

        if (0 != MimeCodePage[uidx].uiFamilyCodePage)
        {
            for (UINT j = 0; j < ARRAYSIZE(MimeCodePage); j++)
            {
                if (MimeCodePage[uidx].uiFamilyCodePage == MimeCodePage[j].uiCodePage)
                {
                    _LoadStringExW(g_hInst, MimeCodePage[j].uidFixedWidthFont, pcpInfo->wszFixedWidthFont, MAX_MIMEFACE_NAME, langid);
                    _LoadStringExW(g_hInst, MimeCodePage[j].uidProportionalFont, pcpInfo->wszProportionalFont, MAX_MIMEFACE_NAME, langid);
                    break;
                }
            }
        }

    }
    else
    {
        _LoadStringExW(g_hInst, MimeCodePage[uidx].uidFixedWidthFont, pcpInfo->wszFixedWidthFont, MAX_MIMEFACE_NAME, langid);
        _LoadStringExW(g_hInst, MimeCodePage[uidx].uidProportionalFont, pcpInfo->wszProportionalFont, MAX_MIMEFACE_NAME,langid);
    }


    // Copy internal buffer information
    pcpInfo->dwFlags = MimeCodePage[uidx].dwFlags;
    pcpInfo->uiCodePage = MimeCodePage[uidx].uiCodePage;
    if (MimeCodePage[uidx].uiFamilyCodePage)
        pcpInfo->uiFamilyCodePage = MimeCodePage[uidx].uiFamilyCodePage;
    else
        pcpInfo->uiFamilyCodePage = MimeCodePage[uidx].uiCodePage;
    MLStrCpyNW(pcpInfo->wszBodyCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (MimeCodePage[uidx].wszWebCharset)
        MLStrCpyNW(pcpInfo->wszWebCharset, MimeCodePage[uidx].wszWebCharset, MAX_MIMECSET_NAME);
    else
        MLStrCpyNW(pcpInfo->wszWebCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (MimeCodePage[uidx].wszHeaderCharset)
        MLStrCpyNW(pcpInfo->wszHeaderCharset, MimeCodePage[uidx].wszHeaderCharset, MAX_MIMECSET_NAME);
    else
        MLStrCpyNW(pcpInfo->wszHeaderCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (0 != TranslateCharsetInfo(IntToPtr_(LPDWORD, pcpInfo->uiFamilyCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
        pcpInfo->bGDICharset = (BYTE)rCharsetInfo.ciCharset;
    else
        pcpInfo->bGDICharset = DEFAULT_CHARSET;

    if (1200 == pcpInfo->uiFamilyCodePage || 50000 == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiFamilyCodePage)) // 50000 means user defined
    {
       if (TRUE == CheckFont(pcpInfo->bGDICharset))
       {
           if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID_NLS;
           else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID_NLS;
       }
       else
       {
           if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
           else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
       }

    }

        
    hr = S_OK;

    return hr;
}


STDAPI CMimeDatabase::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    int idx = -1;
    int iStart, iEnd, iMiddle, iCmpResult;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCharsetInfo called."));

    iStart = 0;
    iEnd = ARRAYSIZE(MimeCharSet) - 1;

    while (iStart <= iEnd)
    {
        iMiddle = (iStart + iEnd) / 2;
        iCmpResult = MLStrCmpIW(Charset, MimeCharSet[iMiddle].szCharset);
        if (iCmpResult < 0)
            iEnd = iMiddle - 1;
        else if (iCmpResult > 0)
            iStart = iMiddle + 1;
        else
        {
            if (MimeCharSet[iMiddle].dwFlags & dwMimeSource)
            {
                idx = iMiddle;                
            }
            else
                // !!! Tricky, search neighbors for correct data which matches MIME version
                // Only works for now, if we have data over two versions, we have to change here
                if ((iMiddle+1 <= iEnd) && 
                    MimeCharSet[iMiddle+1].dwFlags & dwMimeSource &&
                    !MLStrCmpIW(Charset, MimeCharSet[iMiddle+1].szCharset))
                {
                    idx = iMiddle+1;
                }
                else 
                    if ((iMiddle-1 >= 0) &&
                        MimeCharSet[iMiddle-1].dwFlags & dwMimeSource &&
                        !MLStrCmpIW(Charset, MimeCharSet[iMiddle-1].szCharset))
                    {
                
                        idx = iMiddle-1;
                    }
                    else
                    {
                        idx = ARRAYSIZE(MimeCharSet);
                    }
            break;
        }
    }


    if (0 <= idx && idx < ARRAYSIZE(MimeCharSet) && pcsetInfo )
    {
        MLStrCpyNW(pcsetInfo->wszCharset, MimeCharSet[idx].szCharset, MAX_MIMECSET_NAME);
        pcsetInfo->uiCodePage = MimeCharSet[idx].uiCodePage;
        pcsetInfo->uiInternetEncoding = MimeCharSet[idx].uiInternetEncoding;
        hr = S_OK;
    }

    return hr;
}

int CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelf, NEWTEXTMETRICEX *lpntm, int iFontType, LPARAM lParam)
{
    LOGFONT *lplf;
    BOOL *lpfOK = (BOOL *)lParam;

    lplf = &(lpelf->elfLogFont);
    // We don't use non TrueType fonts
    if (iFontType == DEVICE_FONTTYPE || iFontType == RASTER_FONTTYPE)
        return 1;   // keep going but don't use this font

    // We don't use the SYMBOL, Mac Charset fonts
    if(lplf->lfCharSet == SYMBOL_CHARSET || lplf->lfCharSet == MAC_CHARSET)
        return 1;

    // We don't handle vertical fonts
    if (TEXT('@') == lplf->lfFaceName[0])
        return 1;

    *lpfOK = TRUE;
    return 0;       // stop enumeration if we find any
}

BOOL CMimeDatabase::CheckFont(BYTE bGDICharset)
{
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::CheckFont called."));

    // It is safe to assume that system always support DEFAULT_CHAR and ANSI_CHARSET
    if ((DEFAULT_CHARSET == bGDICharset) || (ANSI_CHARSET == bGDICharset))
        fRet = TRUE;
    else
    {
        HDC     hDC;
        LOGFONT lf;
        HWND    hWnd;

        hWnd = GetTopWindow(GetDesktopWindow());
        hDC = GetDC(hWnd);

        if (NULL != hDC)
        {
            lf.lfFaceName[0] = TEXT('\0');
            lf.lfPitchAndFamily = 0;
            lf.lfCharSet = bGDICharset;
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)&fRet, 0);
        }
        ReleaseDC(hWnd, hDC);
    }
    return fRet;
}

// validates all cps that are in the same
// family of the given codepage
STDAPI CMimeDatabase::ValidateCP(UINT uiCodePage)
{
    UINT i;

    for (i = 0; i < ARRAYSIZE(MimeCodePage); i++)
    {
        if (MimeCodePage[i].uiFamilyCodePage == uiCodePage)
            MimeCodePage[i].dwFlags |=  MIMECONTF_VALID|MIMECONTF_VALID_NLS;
    }
        
    return S_OK; // never fail?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\lcinit.cpp ===
/*
 * Automatic language and codepage detector
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Unicode support; Charmaps in data file.
 */
#include "private.h"
#include <strsafe.h>
/****************************************************************/



Histogram::Histogram (const PFileHistogramSection pHS, const PHIdx pMap)
: m_nDimensionality((UCHAR)pHS->m_dwDimensionality),
  m_nEdgeSize((UCHAR)pHS->m_dwEdgeSize),
  m_nCodePage((USHORT)pHS->m_dwCodePage),
  m_pMap(pMap),
  m_panElts((HElt *)&pHS[1])    // table follows header struct  in the file
{
    // #elements = #unique character values ^ #dimensions

    m_nElts = 1;
    for (UCHAR i = 0; i < m_nDimensionality; i++)
        m_nElts *= m_nEdgeSize;
}

DWORD
Histogram::Validate (DWORD nBytes) const
{
    if ( nBytes < m_nElts * sizeof(HElt) ||
         m_nDimensionality > 4 )
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    return NO_ERROR;
}

Histogram::Histogram (const Histogram &H, const PHIdx pMap)
: m_nDimensionality(H.m_nDimensionality),
  m_nEdgeSize(H.m_nEdgeSize),
  m_nCodePage(H.m_nCodePage),
  m_nElts(H.m_nElts),
  m_pMap(pMap),
  m_panElts(H.m_panElts)
//
// Clone a histogram but use a different Charmap.
{
}

Histogram::~Histogram (void)
//
// The pointer members point to the mapped file and do not need to be freed.
{
}

/****************************************************************/

Language::Language (PLCDetect pL, int nLangID, int nCodePages, int nRangeID)
: m_pLC(pL),
  m_nLangID(nLangID),
  m_nCodePages(nCodePages),
  m_nRangeID(nRangeID)
{
}

Language7Bit::Language7Bit (PLCDetect pL, int nLangID, int nCodePages)
: Language(pL, nLangID, nCodePages),
  m_pLangHistogram(NULL)
{
    memset ((void *)m_ppCodePageHistogram, 0, sizeof(m_ppCodePageHistogram));
}

Language7Bit::~Language7Bit (void)
{
    if (m_pLangHistogram)
        delete m_pLangHistogram;

    for (int i = 0; i < MAXSUBLANG; i++)
        if (m_ppCodePageHistogram[i])
            delete m_ppCodePageHistogram[i];
}

DWORD
Language7Bit::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
//
// Add the raw histogram at *pHS in the mapped file to this language object.  
// The histograms must be for 7-bit detection.
{
    DWORD hr = NO_ERROR;

    PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

    if (nIdx == 0)
    {
        // The first histogram for a language is its language-detection table.

        if ( (m_pLangHistogram = new Histogram (pHS, pMap)) == NULL)
            return ERROR_OUTOFMEMORY;

        if ((hr = m_pLangHistogram->Validate (nBytes)) != NO_ERROR)
            return hr;
    }
    else
    {
        // Each subsequent histogram is a code page detection table.

        if (nIdx - 1 >= m_nCodePages)
            return ERROR_INTERNAL_DB_CORRUPTION;

        Histogram *pH;

        if ((pH = new Histogram (pHS, pMap)) == NULL)
            return ERROR_OUTOFMEMORY;

        if ((hr = pH->Validate (nBytes)) != NO_ERROR)
            return hr;

        m_ppCodePageHistogram[nIdx - 1] = pH;

        // Cache for the scoring vector math

        m_paHElt[nIdx - 1] = pH->Array();
    }

    return hr;
}

/****************************************************************/

Language8Bit::Language8Bit (PLCDetect pL, int nLangID, int nCodePages)
: Language(pL, nLangID, nCodePages)
{
    memset ((void *)m_ppHistogram, 0, sizeof(m_ppHistogram));
}

Language8Bit::~Language8Bit (void)
{
    for (int i = 0; i < MAXSUBLANG; i++)
        if (m_ppHistogram[i])
            delete m_ppHistogram[i];
}

DWORD
Language8Bit::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
//
// Add the raw histogram at *pHS to this language object.  
// This language is known to use 8-bit detection.
{
    DWORD hr = NO_ERROR;

    PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

    // The histograms are the direct language-code page tables

    if (nIdx >= m_nCodePages)
        return ERROR_INTERNAL_DB_CORRUPTION;

    Histogram *pH;

    if ((pH = new Histogram (pHS, pMap)) == NULL)
        return ERROR_OUTOFMEMORY;

    if ((hr = pH->Validate (nBytes)) != NO_ERROR)
        return hr;

    m_ppHistogram[nIdx] = pH;

    return hr;
}

/****************************************************************/

LanguageUnicode::LanguageUnicode (PLCDetect pL, int nLangID, 
    int nSubLangs, int nRangeID)
: Language(pL, nLangID, nSubLangs, nRangeID)
{
    memset ((void *)m_ppSubLangHistogram, 0, sizeof(m_ppSubLangHistogram));
}

LanguageUnicode::~LanguageUnicode (void)
{
    for (int i = 0; i < MAXSUBLANG; i++)
        if (m_ppSubLangHistogram[i])
            delete m_ppSubLangHistogram[i];
}

DWORD
LanguageUnicode::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
{
    DWORD hr = NO_ERROR;

    // All histograms for are sublanguage detection

    if (nIdx >= m_nSubLangs)
        return ERROR_INTERNAL_DB_CORRUPTION;

    // Get the custom charmap used for scoring this sublanguage group

    PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

    Histogram *pH;

    if ((pH = new Histogram (pHS, pMap)) == NULL)
        return ERROR_OUTOFMEMORY;

    if ((hr = pH->Validate (nBytes)) != NO_ERROR)
        return hr;

    m_ppSubLangHistogram[nIdx] = pH;

    m_paHElt[nIdx] = pH->Array();

    return hr;
}

/****************************************************************/

LCDetect::LCDetect (HMODULE hM)
: m_hModule(hM),
  m_nCharmaps(0),
  m_n7BitLanguages(0),
  m_n8BitLanguages(0),
  m_nUnicodeLanguages(0),
  m_n7BitLangsRead(0),
  m_n8BitLangsRead(0),
  m_nUnicodeLangsRead(0),
  m_nMapsRead(0),
  m_nHistogramsRead(0),
  m_nScoreIdx(0),
  m_pp7BitLanguages(NULL),
  m_pp8BitLanguages(NULL),
  m_ppUnicodeLanguages(NULL),
  m_ppCharmaps(NULL),
  m_pv(NULL),
  m_hmap(0),
  m_hf(0),
  m_pHU27Bit(0)
{
}

LCDetect::~LCDetect ()
{
    delete m_pHU27Bit;

    for (unsigned int i = 0; i < m_n7BitLanguages; i++)
        delete m_pp7BitLanguages[i];
    delete m_pp7BitLanguages;

    for (i = 0; i < m_n8BitLanguages; i++)
        delete m_pp8BitLanguages[i];
    delete m_pp8BitLanguages;

    for (i = 0; i < m_nUnicodeLanguages; i++)
        delete m_ppUnicodeLanguages[i];
    delete m_ppUnicodeLanguages;

    for (i = 0; i < m_nCharmaps; i++)
        delete m_ppCharmaps[i];
    delete m_ppCharmaps;

    if (m_pv)
        UnmapViewOfFile (m_pv);

    CloseHandle (m_hmap);
    CloseHandle (m_hf);
}

DWORD
LCDetect::Initialize7BitLanguage (PFileLanguageSection pLS, PLanguage *ppL)
//
// Set *ppL to the Language object created from this section.
{
    // nRecordCount is lang histogram (1) + # of code page histograms

    if ( m_n7BitLangsRead >= m_n7BitLanguages || pLS->m_dwRecordCount < 1)
        return ERROR_INTERNAL_DB_CORRUPTION;

    PLanguage7Bit pL = new Language7Bit (this, pLS->m_dwLangID, pLS->m_dwRecordCount - 1);

    if (pL == NULL)
        return ERROR_OUTOFMEMORY;


    // Each 7-bit lang uses one score index slot per code page.
    // The range starts with the 7-bit langs, since both the 8-bit
    // and Unicode langs follow it.

    if (m_n7BitLangsRead == 0 && m_nScoreIdx != 0)
        return ERROR_INTERNAL_DB_CORRUPTION;;

    pL->SetScoreIdx(m_nScoreIdx);

    m_nScoreIdx += pLS->m_dwRecordCount - 1;    // skip 1st record (Language)

    m_pp7BitLanguages[ m_n7BitLangsRead++ ] = pL;

    *ppL = pL;

    return NO_ERROR;
}

DWORD
LCDetect::Initialize8BitLanguage (PFileLanguageSection pLS, Language **ppL)
//
// Set *ppL to the Language object created from this section.
{
    // nRecordCount is # of combined language / code page histograms

    if ( m_n8BitLangsRead >= m_n8BitLanguages || pLS->m_dwRecordCount < 1)
        return ERROR_INTERNAL_DB_CORRUPTION;

    PLanguage8Bit pL = new Language8Bit (this, pLS->m_dwLangID, pLS->m_dwRecordCount);

    if (pL == NULL)
        return ERROR_OUTOFMEMORY;


    // The 8-bit score indices follow the 7-bit languages

    // Each 8-bit lang uses a score index slot for each of its code pages,
    // since all the code pages are scored in the initial scoring pass.
    // The number of slots is the number of code page histograms, which is
    // one less than the number of records following this language.

    pL->SetScoreIdx(m_nScoreIdx);
    m_nScoreIdx += pLS->m_dwRecordCount;


    m_pp8BitLanguages[ m_n8BitLangsRead++ ] = pL;

    *ppL = pL;

    return NO_ERROR;
}

DWORD
LCDetect::InitializeUnicodeLanguage (PFileLanguageSection pLS, Language **ppL)
//
// Set *ppL to the Language object created from this section.
{
    // nRecordCount is # of sublanguage histograms

    if ( m_nUnicodeLangsRead >= m_nUnicodeLanguages ||
         pLS->m_dwUnicodeRangeID >= m_nUnicodeLanguages )
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    PLanguageUnicode pL = new LanguageUnicode (this, pLS->m_dwLangID, 
                        pLS->m_dwRecordCount, pLS->m_dwUnicodeRangeID);

    if (pL == NULL)
        return ERROR_OUTOFMEMORY;


    // The Unicode score indices follow the 7-bit languages, and overlay the
    // 8-bit slots since they aren't used at the same time.

    if (m_nUnicodeLangsRead == 0 && GetN8BitLanguages() > 0)
        m_nScoreIdx = Get8BitLanguage(0)->GetScoreIdx();

    // Each Unicode entry uses exactly one score index.  SBCS subdetection
    // (Latin group) uses the slots for the corresponding 7-bit languages,
    // and Unicode subdetection (CJK) uses the slots already defined for the
    // Unicode sub-languages.

    pL->SetScoreIdx(m_nScoreIdx);

    m_nScoreIdx++;

    // For Unicode, the range ID is used as the Language array index.

    m_ppUnicodeLanguages[ pLS->m_dwUnicodeRangeID ] = pL;
    m_nUnicodeLangsRead++;

    *ppL = pL;

    return NO_ERROR;
}

DWORD
LCDetect::LoadLanguageSection (void *pv, int nSectionSize, PLanguage *ppL)
//
// A language section begins the definition of data for a language.
// Each language has exactly one of these records.  One or more
// histogram sections follow each language, and are always associated
// with the language of the preceding language section.
//
// Set *ppL to the Language object created from this section.
{
    DWORD hr = NO_ERROR;

    PFileLanguageSection pLS;

    pLS = (PFileLanguageSection)&((char *)pv)[sizeof(FileSection)];

    switch ( pLS->m_dwDetectionType ) {

    case DETECT_7BIT:
        hr = Initialize7BitLanguage (pLS, ppL);
        break;

    case DETECT_8BIT:
        hr = Initialize8BitLanguage (pLS, ppL);
        break;

    case DETECT_UNICODE:
        hr = InitializeUnicodeLanguage (pLS, ppL);
        break;
    }

    return hr;
}

DWORD
LCDetect::LoadHistogramSection (void *pv, int nSectionSize, Language *pL)
{
    PFileHistogramSection pHS;

    pHS = (PFileHistogramSection)&((char *)pv)[sizeof(FileSection)];

    int nBytes = nSectionSize - sizeof(FileSection) - sizeof(*pHS);

    return pL->AddHistogram ( pHS, nBytes, m_nHistogramsRead++);
}

DWORD
LCDetect::LoadMapSection (void *pv, int nSectionSize)
{
    PFileMapSection pMS;

    pMS = (PFileMapSection)&((char *)pv)[sizeof(FileSection)];

    int nBytes = nSectionSize - sizeof(FileSection) - sizeof(*pMS);

    if (m_nMapsRead >= m_nCharmaps)
        return ERROR_INTERNAL_DB_CORRUPTION;

    PCharmap pM = new Charmap (pMS);

    if (pM == NULL)
        return ERROR_OUTOFMEMORY;

    m_ppCharmaps[ m_nMapsRead++ ]  = pM;

    return NO_ERROR;
}

DWORD
LCDetect::BuildState (DWORD nFileSize)
//
// Build the detection structures from the mapped training file image at *m_pv
{
    PLanguage pL;
    PFileHeader pFH;
    PFileSection pFS;

    DWORD hr = NO_ERROR;

    // Validate header

    pFH = (PFileHeader) m_pv;

    if ( nFileSize < sizeof(*pFH) || 
         pFH->m_dwAppSig != APP_SIGNATURE ||
         pFH->m_dwVersion != APP_VERSION ||
         pFH->m_dwHdrSizeBytes >= nFileSize ||
         pFH->m_dwN7BitLanguages == 0 ||
         pFH->m_dwN8BitLanguages == 0 ||
         pFH->m_dwNUnicodeLanguages == 0 ||
         pFH->m_dwNCharmaps == 0 )
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Allocate language pointer table per header

    m_n7BitLanguages = pFH->m_dwN7BitLanguages;
    m_pp7BitLanguages = new PLanguage7Bit [m_n7BitLanguages];

    m_n8BitLanguages = pFH->m_dwN8BitLanguages;
    m_pp8BitLanguages = new PLanguage8Bit [m_n8BitLanguages];

    m_nUnicodeLanguages = pFH->m_dwNUnicodeLanguages;
    m_ppUnicodeLanguages = new PLanguageUnicode [m_nUnicodeLanguages];

    m_nCharmaps = pFH->m_dwNCharmaps;
    m_ppCharmaps = new PCharmap [m_nCharmaps];

    if ( m_pp7BitLanguages == NULL || 
         m_pp8BitLanguages == NULL || 
         m_ppUnicodeLanguages == NULL ||
         m_ppCharmaps == NULL )
    {
        return ERROR_OUTOFMEMORY;
    }

    // Clear, because not all slots may be assigned
    memset (m_ppUnicodeLanguages, 0, sizeof(PLanguageUnicode) * m_nUnicodeLanguages);

    // Remember other header info

    m_LCDConfigureDefault.nMin7BitScore = pFH->m_dwMin7BitScore;
    m_LCDConfigureDefault.nMin8BitScore = pFH->m_dwMin8BitScore;
    m_LCDConfigureDefault.nMinUnicodeScore = pFH->m_dwMinUnicodeScore;
    m_LCDConfigureDefault.nRelativeThreshhold = pFH->m_dwRelativeThreshhold;
    m_LCDConfigureDefault.nDocPctThreshhold = pFH->m_dwDocPctThreshhold;
    m_LCDConfigureDefault.nChunkSize = pFH->m_dwChunkSize;

    // Position to first section

    pFS = (PFileSection) &((char *)m_pv)[pFH->m_dwHdrSizeBytes];

    // Read and process each file section

    while ( hr == NO_ERROR ) {

        // check alignment

        if (((DWORD_PTR)pFS & 3) != 0) {
            hr = ERROR_INTERNAL_DB_CORRUPTION;
            break;
        }

        // zero-length section marks end of data

        if (pFS->m_dwSizeBytes == 0)
            break;

        if ( &((char *)pFS)[pFS->m_dwSizeBytes] >= &((char *)m_pv)[nFileSize]) {
            hr = ERROR_INTERNAL_DB_CORRUPTION;
            break;
        }

        switch ( pFS->m_dwType ) {

        case SECTION_TYPE_LANGUAGE:                             // sets pL
            hr = LoadLanguageSection ((void*)pFS, pFS->m_dwSizeBytes, &pL);
            m_nHistogramsRead = 0;
            break;

        case SECTION_TYPE_HISTOGRAM:                            // uses pL
            hr = LoadHistogramSection ((void*)pFS, pFS->m_dwSizeBytes, pL);
            break;

        case SECTION_TYPE_MAP:
            hr = LoadMapSection ((void*)pFS, pFS->m_dwSizeBytes);
            break;

        default:                    // ignore unrecognized sections
            break;
        }

        pFS = (PFileSection) &((char *)pFS)[pFS->m_dwSizeBytes];
    }

    if (hr != NO_ERROR)
        return hr;

    if ( m_nMapsRead != m_nCharmaps )
        return ERROR_INTERNAL_DB_CORRUPTION;


    // Set up quick-reference arrays used by the scoring inner loops

    for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
        m_paHElt7Bit[i] = Get7BitLanguage(i)->GetLangHistogram()->Array();

    m_nHElt8Bit = 0;
    for (i = 0; i < GetN8BitLanguages(); i++) 
    {
        PLanguage8Bit pL = Get8BitLanguage(i);

        for (int j = 0; j < pL->NCodePages(); j++)
            m_paHElt8Bit[m_nHElt8Bit++] = pL->GetHistogram(j)->Array();
    }

    // Set up the Histogram used for ScoreVectorW() for scoring Unicode
    // text for 7-bit language detection.  Clone the first 7-bit language
    // histogram and replace its map with CHARMAP_U27BIT.

    m_pHU27Bit = new Histogram ( *Get7BitLanguage(0)->GetLangHistogram(),
                                 GetMap(CHARMAP_U27BIT));

    return hr;
}


DWORD
LCDetect::LoadState (void)
//
// Overall initialization and state loading.  Open the compiled training
// file from its fixed location in the System32 directory, and assemble
// in-memory detection tables from its contents.
{
    DWORD hr = NO_ERROR;
    DWORD nFileSize;
#define MODULENAMELEN 100
    char szFilename[MODULENAMELEN+50], *p;

    // Find out if NT or Windows

    OSVERSIONINFOA OSVersionInfo;
    int nOSWinNT = 0;
    OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );
    if ( GetVersionExA( &OSVersionInfo ) )
        nOSWinNT = OSVersionInfo.dwPlatformId;

    // Open the training data file,
    // look in the directory that contains the DLL.

    if (GetModuleFileNameA (m_hModule, szFilename, MODULENAMELEN) == 0)
        return GetLastError();

    if ( (p = strrchr (szFilename, '\\')) != NULL ||
         (p = strrchr (szFilename, ':')) != NULL )
    {
        *++p = 0;
    }
    else
        *szFilename = 0;
    //*STRSAFE*     strcat (szFilename, DETECTION_DATA_FILENAME);
    hr = StringCchCatA(szFilename , ARRAYSIZE(szFilename),  DETECTION_DATA_FILENAME);
    if (!SUCCEEDED(hr))
    {
       return E_FAIL;
    }

    if ((m_hf = CreateFileA (szFilename, GENERIC_READ, FILE_SHARE_READ, 
                    NULL, OPEN_EXISTING, 
                    FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) 
    {
        return E_FAIL;
    }

    if ((nFileSize = GetFileSize (m_hf, NULL)) == 0xffffffff) {
        hr = GetLastError();
        CloseHandle (m_hf);
        return hr;
    }

    // Virtual-map the file

    if ( nOSWinNT == VER_PLATFORM_WIN32_NT )
        m_hmap = CreateFileMapping (m_hf, NULL, PAGE_READONLY, 0, nFileSize, NULL);
    else
        m_hmap = CreateFileMappingA (m_hf, NULL, PAGE_READONLY, 0, nFileSize, NULL);

    if (m_hmap == NULL) {
        hr = GetLastError();
        CloseHandle (m_hf);
        return hr;
    }

    if ((m_pv = MapViewOfFile (m_hmap, FILE_MAP_READ, 0, 0, 0 )) == NULL) {
        hr = GetLastError();
        CloseHandle (m_hmap);
        CloseHandle (m_hf);
        return hr;
    }
        
    // Build the in-memory structures from the file

    hr = BuildState (nFileSize);

    return hr;
}

/****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\lcdetect.cpp ===
/*
 * Automatic language and codepage detector
 * 
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Added Unicode support and rewrote
 *                                    scoring to use vector math.
 * 
 * This is the runtime detector.
 * 
 * See the comments in lcdcomp.cpp for a description of the compilation
 * process and training data format.
 *
 * See design.txt for a description of the detection and scoring algorithm.
 *
 * Performance note:  60-80% of execution time in this code is AddVector(),
 * which is probably memory-cycle bound by its random data access, but is
 * still a candidate for further optimizing with an intrinsic vector operator,
 * should one become available.
 * 
 * to-do (as needed):
 * - Adjust 7-bit and 8-bit scores to make them more comparable
 * - detect UTF-8 in the SBCS entry point, via heuristic and via
 *   subdetection as 7-bit lang and as Unicode.
 */

#include "private.h"

// This is all the global (per-process) state
//
// It is set at DLL process init and its contents are const after that.

LCDetect * g_pLCDetect;

#ifdef DEBUG_LCDETECT
int g_fDebug;
#endif

/****************************************************************/

static inline unsigned int
FindHighIdx (const int *pn, unsigned int n)
//
// Return the INDEX of the highest-valued integer in the given array.
{
    int nMax = 0;
    unsigned int nIdx = 0;

    for (unsigned int i = 0; i < n; i++)
    {
        if (pn[i] > nMax)
        {
            nMax = pn[i];
            nIdx = i;
        }
    }

    return nIdx;
}

/****************************************************************/

void
CScores::SelectCodePages (void)
//
// Find the highest scoring code page for each language, and remove
// all the other scores from the array such that the array contains
// exactly one score per detected language instead of one score per
// code page per language.
//
// When multiple scores are present for different code pages of the same
// language, this function combines the scores into a single score.
// The resulting entry will have the code page of the top-scoring code page
// for the various entries for that language, and the score and char count
// will be the SUM of the scores and char counts for ALL the entries for
// that language.
//
// For example, if the input contains:
//      Lang        Codepage    Score   Char count
//      Russian     1251        42      200
//      Russian     20866       69      300
//
// Then on output, the array will contain only one score for Russian:
//      Russian     20866       111     500
//
// This overwrites the entries in place, and sets m_nUsed to the resulting
// number of active slots.
//
// The scores are already grouped by language, no need to sort by language.
//
// After return, the score array must NOT be referenced via ScoreIdx()
// because the index of the entries has changed.
{
    // The score indices no longer matter, remove slots that scored zero.

    RemoveZeroScores ();

    if (m_nUsed == 0)
        return;

    // Select top score per language.  This is fundamentally dependent
    // on the score array already being ordered by language.  This won't
    // combine scores for the same language as both a 7-bit and 8-bit lang,
    // but that's not worth fixing.

    int maxscore = 0;                   // highest score for a given language
    int totalscore = m_p[0].GetScore(); // sum of scores  " "
    int totalchars = m_p[0].GetCharCount();// sum of character counts  " "

    int nReturned = 0;          // index and ultimate count of elts returned
    unsigned int maxscoreidx = 0; // array index of the top-scoring code page,
                                  // *** for the current language ***

    for (unsigned int i = 1; i < m_nUsed; i++) {
        if (m_p[i-1].GetLang() != m_p[i].GetLang())
        {
            // [i] indicates a different language from the previous entry
            
            // Add the entry for the previous language to the result
            // by copying the slot for its highest-scoring code page,
            // and overwriting its score and char count with the sum counts.

            m_p[maxscoreidx].SetScore(totalscore);
            m_p[maxscoreidx].SetCharCount(totalchars);
            m_p[nReturned++] = m_p[maxscoreidx];

            // Start remembering the top and total scores for the new lang.

            maxscore = m_p[i].GetScore();
            totalscore = m_p[i].GetScore();
            totalchars = m_p[i].GetCharCount();
            maxscoreidx = i;        // remember which [] had the top score
        }
        else 
        {
            // Accumulate more scores for the same language

            if (m_p[i].GetScore() > maxscore) {
                maxscore = m_p[i].GetScore();
                maxscoreidx = i;
            }
            totalscore += m_p[i].GetScore();
            totalchars += m_p[i].GetCharCount();
        }
    }

    // Process the the last language.  Return the slot from its
    // highest-scoring code page.

    if (m_nUsed > 0)
    {
        m_p[maxscoreidx].SetScore(totalscore);
        m_p[maxscoreidx].SetCharCount(totalchars);
        m_p[nReturned++] = m_p[maxscoreidx];
    }

    m_nUsed = nReturned;
}

/****************************************************************/

static void __fastcall
AddVector (int *pS, const PHElt *pH, int idx, unsigned int nScores)
//
// Add the score vector for a single n-gram to the running sum score
// vector at pS.
//
// On return, paS[0..nScores-1] is filled with the sum scores for each
// language.
//
// **** PERFORMANCE NOTE ****
//
// This is the critical inner-loop of the entire subsystem.
// 
// Code generation and performance have been checked for various code
// organization.  Ironically, making AddVector() a true function is
// FASTER than inlining it because when inlined, the registers are used
// for the OUTER loop variables and the inner loop here does approximately
// twice as many memory references per pass.
//
// On x86, all four loop variables are registered, and each pass makes only
// three memory references, which is optimal for the given representation.
// 
// Future note: the histogram tables could be pivoted to collect all the
// scores for each n-gram in a block; that would eliminate the double 
// indirection through ph and reduce the memory refs to two per pass.
{
    nScores++;      // makes faster end-test

    while (--nScores != 0)
        *pS++ += (*pH++)[idx];
}

static inline void
ScoreUnigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a unigram histogram.  Each individual character is
// mapped to a histogram slot to yield a score for that character in each
// language.
{
    if (nCh < 1)
        return;

    const PHIdx pMap = pH->GetMap();

    unsigned char *p = (unsigned char *)pcsz;

    while (nCh-- > 0)
        AddVector (paS, paH, pMap[*p++], nScores);
}

static inline void
ScoreUnigramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.  Only difference is the use of a map that maps the
// full 64K WCHAR space into the histogram index range.
{
    if (nCh < 1)
        return;

    const PHIdx pMap = pH->GetMap();

    while (nCh-- > 0)
        AddVector (paS, paH, pMap[*pcwsz++], nScores);
}

static inline void
ScoreDigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a digram histogram.  Each adjacent pair of characters
// are mapped to the index range and the mapped values combined to form an
// array index unique to that digram.  The scores for that array slot are
// summed for each language.
{
    if (nCh < 2)
        return;

    unsigned char *p = (unsigned char *)pcsz;

    const PHIdx pMap = pH->GetMap();

    unsigned char ch1 = pMap[*p++];

    while (nCh-- > 1)
    {
        unsigned char ch2 = pMap[*p++];

        AddVector (paS, paH, ch1 * pH->EdgeSize() + ch2, nScores);

        ch1 = ch2;
    }
}

static inline void
ScoreTrigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a trigram histogram.  Each adjacent three-letter set 
// of characters are mapped to the index range and the mapped values combined
// to form an array index unique to that trgram.
{
    if (nCh < 3)
        return;

    unsigned char *p = (unsigned char *)pcsz;

    const PHIdx pMap = pH->GetMap();

    unsigned char ch1 = pMap[*p++];
    unsigned char ch2 = pMap[*p++];

    while (nCh-- > 2)
    {
        unsigned char ch3 = pMap[*p++];
        debug(printf("  '%c%c%c':",unmapch(ch1),unmapch(ch2),unmapch(ch3)));

        int idx = ((ch1 * pH->EdgeSize()) + ch2) * pH->EdgeSize() + ch3;
        ch1 = ch2;
        ch2 = ch3;

        AddVector (paS, paH, idx, nScores);

        debug(for (UINT i = 0; i < nScores; i++) printf(" %3d", paH[i][idx]));
        debug(printf("\n"));
    }
}

static inline void
ScoreTrigramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.
{
    if (nCh < 3)
        return;

    const PHIdx pMap = pH->GetMap();

    unsigned char ch1 = pMap[*pcwsz++];
    unsigned char ch2 = pMap[*pcwsz++];

    while (nCh-- > 2)
    {
        unsigned char ch3 = pMap[*pcwsz++];

        int idx = ((ch1 * pH->EdgeSize()) + ch2) * pH->EdgeSize() + ch3;
        ch1 = ch2;
        ch2 = ch3;

        AddVector (paS, paH, idx, nScores);
    }
}

static inline void
ScoreNgramVector (LPCSTR pcsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for any dimension of n-gram.  Get "N" from the
// dimensionality of the histogram.
//
//  Each adjacent n-letter set of characters are mapped to the index range
// and the scores the reference summed for each language.  This code is
// never used for the current data file, instead an optimized scoring
// loop exists for each existing case.  This exists to enable trying
// different dimension scoring without requiring a new DLL.
{
    if (nCh < pH->Dimensionality())
        return;

    unsigned char *p = (unsigned char *)pcsz;

    const PHIdx pMap = pH->GetMap();

    // Fill the pipeline

    int idx = 0;
    if (pH->Dimensionality() >= 2)
        idx = idx * pH->EdgeSize() + pMap[*p++];
    if (pH->Dimensionality() >= 3)
        idx = idx * pH->EdgeSize() + pMap[*p++];
    if (pH->Dimensionality() >= 4)
        idx = idx * pH->EdgeSize() + pMap[*p++];

    unsigned int nLoopCount = nCh - (pH->Dimensionality() - 1);

    while (nLoopCount-- > 0)
    {
        idx = (idx * pH->EdgeSize() + pMap[*p++]) % pH->NElts();

        AddVector (paS, paH, idx, nScores);
    }
}

static inline void
ScoreNgramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.
{
    if (nCh < pH->Dimensionality())
        return;

    const PHIdx pMap = pH->GetMap();

    // Fill the pipeline

    int idx = 0;
    if (pH->Dimensionality() >= 2)
        idx = idx * pH->EdgeSize() + pMap[*pcwsz++];
    if (pH->Dimensionality() >= 3)
        idx = idx * pH->EdgeSize() + pMap[*pcwsz++];
    if (pH->Dimensionality() >= 4)
        idx = idx * pH->EdgeSize() + pMap[*pcwsz++];

    unsigned int nLoopCount = nCh - (pH->Dimensionality() - 1);

    while (nLoopCount-- > 0)
    {
        idx = (idx * pH->EdgeSize() + pMap[*pcwsz++]) % pH->NElts();

        AddVector (paS, paH, idx, nScores);
    }
}

void
ScoreVector (LPCSTR pcsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score a string into an array of scores using an array of histograms
//
// Each character n-gram is mapped to a histogram slot to yield a score
// for that character in each array at paH.
//
// On return, paS[0..nScores-1] is filled with the sum scores.
{
    memset (paS, 0, sizeof(int) * nScores);

    switch (pH->Dimensionality()) 
    {
    case 1:
        ScoreUnigramVector (pcsz, nCh, pH, paS, paH, nScores);
        break;

    case 2:
        ScoreDigramVector (pcsz, nCh, pH, paS, paH, nScores);
        break;

    case 3:
        ScoreTrigramVector (pcsz, nCh, pH, paS, paH, nScores);
        break;

    default:
        ScoreNgramVector (pcsz, nCh, pH, paS, paH, nScores);
        break;
    }
}

void
ScoreVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
    int *paS, const PHElt *paH, unsigned int nScores)
//
// Score a string into an array of scores using an array of histograms.
{
    memset (paS, 0, sizeof(int) * nScores);

    switch (pH->Dimensionality()) 
    {
    case 1:
        ScoreUnigramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
        break;

    case 3:
        ScoreTrigramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
        break;

    default:
        ScoreNgramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
        break;
    }
}

void
LCDetect::Score7Bit (LPCSTR pcszText, int nChars, CScores &S) const
//
// Do 7-bit language detection.  Compute scores for all 7-bit languages
// and store the raw language score in S at the language's base score-idx.
//
// Fill in only the first score slot per language.  Uses ScoreIdx() for
// the first code page, but does not detect or set the code page.
{
    const PHistogram pH = Get7BitLanguage(0)->GetLangHistogram();

    debug(printf("       "));
    debug(for(unsigned int x=0;x<GetN7BitLanguages();x++)printf(" %3d", Get7BitLanguage(x)->LanguageID()));
    debug(printf("\n"));

    int sc[MAXSCORES];

    // Compute the raw score vector

    ScoreVector (pcszText, nChars, pH, sc, m_paHElt7Bit, GetN7BitLanguages());


    // Fill in the CScores array from it

    for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
    {
        PLanguage7Bit pL = Get7BitLanguage(i);

        CScore &s = S.Ref(pL->GetScoreIdx());

        s.SetLang(pL);
        s.SetCodePage(0);
        s.SetScore(sc[i]);
        s.SetCharCount(nChars);
    }
}

void
LCDetect::Score8Bit (LPCSTR pcszText, int nChars, CScores &S) const
//
// Do 8-bit detection.  Compute a combined language / code page score
// for each trained language / code page combination for the 8-bit languages.
// Store all the raw scores in S at the language+each codepage score-idx.
//
// May store multiple entries in S for each language, one per code page.
{
    const PHistogram pH = Get8BitLanguage(0)->GetHistogram(0);

    int sc[MAXSCORES];

    // Compute the raw score vector

    ScoreVector (pcszText, nChars, pH, sc, m_paHElt8Bit, m_nHElt8Bit);

    // Fill in the CScores array from it

    int nSc = 0;
    for (unsigned int i = 0; i < GetN8BitLanguages(); i++)
    {
        PLanguage8Bit pL = Get8BitLanguage(i);

        for (int j = 0; j < pL->NCodePages(); j++)
        {
            CScore &s = S.Ref(pL->GetScoreIdx() + j);

            s.SetLang(pL);
            s.SetCodePage(pL->GetCodePage(j));
            s.SetScore( sc[ nSc++ ] );
            s.SetCharCount(nChars);
        }
    }
}

void
LCDetect::ScoreLanguageAsSBCS (LPCWSTR wcs, int nch, CScores &S) const
//
// This scores Unicode text known to contain mostly characters in the
// script ranges used for 7-bit languages.  This uses a special mapping,
// m_pH727Bit, that converts n-grams in the WCHAR text directly to the same
// mapping output space used for 7-bit language detection.  It is then scored
// using the same language-only histograms used for 7-bit SBCS detection.
//
// The output is the same as if Score7Bit() had been called on the SBCS
// equivalent to this text.  The same slots in S are filled in, using the
// 7-bit score indices, NOT the Unicode language score indices.
{
    debug(printf("    scoring as SBCS\n"));

    debug(printf("       "));
    debug(for(unsigned int x=0;x<GetN7BitLanguages();x++)printf(" %3d", Get7BitLanguage(x)->LanguageID()));
    debug(printf("\n"));

    // Call ScoreVectorW(), passing the histogram set up or the WCHAR map.

    int sc[MAXSCORES];

    // Compute the raw score vector

    ScoreVectorW (wcs, nch, m_pHU27Bit, sc, m_paHElt7Bit,GetN7BitLanguages());


    // Fill in the CScores array from it

    for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
    {
        PLanguage7Bit pL = Get7BitLanguage(i);

        CScore &s = S.Ref(pL->GetScoreIdx());

        s.SetLang(pL);
        s.SetCodePage(0);
        s.SetScore(sc[i]);
        s.SetCharCount(nch);
    }
}

////////////////////////////////////////////////////////////////

void
Language::ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const 
//
// The default handler for scoring the code page for text for which the
// language is already known.  Initially used only for Unicode.
{
    idx = 0; 
    S.SetCodePage(0); 
}

void
Language7Bit::ScoreCodePage (LPCSTR pStr, int nCh, CScore &S, int &idx) const
//
// Detect the code page for text whose language has already been detected
// and is indicated in S.  Set S.CodePage(), do not change other
// fields of S.  
//
// Set idx to the index of the high-scoring code page.  The caller uses this
// to place the score in the correct ScoreIdx slot.
//
// Note that the arg is a single CScore, not an array.  The CScore S is
// filled in with the score of the high-scoring code page, and no information
// about the other code pages is returned.
{
    if (NCodePages() == 1)
    {
        // If lang is trained with only one codepage, just return it.

        idx = 0;
        S.SetCodePage(GetCodePage(0));

        debug(printf("  score code page: only one; cp=%d\n",GetCodePage(0)));
    }

    debug(printf("scoring 7-bit code pages: "));

    int sc[MAXSUBLANG];

    // Compute the raw score vector

    ScoreVector (pStr, nCh, GetCodePageHistogram(0),
            sc, GetPHEltArray(), NCodePages());

    // Find the high-scoring code page and fill in S with its values

    idx = FindHighIdx (sc, NCodePages());

    debug(printf("selecting cp=%d idx=%d\n", GetCodePage(idx), idx));

    S.SetCodePage (GetCodePage(idx));
}

void
LanguageUnicode::ScoreSublanguages (LPCWSTR wcs, int nch, CScores &S) const
//
// Score wcs for each sub-language and add the raw scores to S.
// The scores are not qualified at this time.
// 
// Relevant only for Unicode language groups that require subdetection,
// initially CJK.
{
    if (m_nSubLangs == 0)
        return;

    debug(printf("    scoring Unicode sublanguages:\n"));

    int sc[MAXSUBLANG];

    // Compute the raw score vector

    ScoreVectorW (wcs, nch, GetHistogram(0), sc, m_paHElt, m_nSubLangs);

    // Fill in the CScores array from it

    for (int i = 0; i < NSubLangs(); i++)
    {
        PLanguageUnicode pSL = GetSublanguage(i);

        CScore &s = S.Ref(pSL->GetScoreIdx());
        s.SetLang (pSL);
        s.SetScore (sc[i]);
        s.SetCharCount (nch);
        s.SetCodePage (0);

        debug(printf("      lang=%d score=%d\n", pSL->LanguageID(), sc[i]));
    }
}

int
LCDetect::ChooseDetectionType (LPCSTR pcszText, int nChars) const
//
// Histogram the raw char values to determine whether to use 7-bit or
// 8-bit detection for this block.
{
    // Count the proportion of chars < vs. >= 0x80

    int nHi = 0;

    for (int i = nChars; i-- > 0; )
        nHi += ((unsigned char)*pcszText++) & 0x80;

    nHi /= 0x80;
    int nLo = nChars - nHi;

    // Make sure there is sufficient data to make a good choice

    // work here -- try  if abs(nHi - nLo) < 10

    if (nHi + nLo < 10)
        return DETECT_NOTDEFINED;

    if (nHi * 2 > nLo)
        return DETECT_8BIT;
    else
        return DETECT_7BIT;
}

void
LCDetect::ScoreLanguageA (LPCSTR pStr, int nChars, CScores &S) const
//
//
// Score the text at pStr for each language that it potentially contains.
//
// Add the scores to S at the ScoreIdx() for each language and codepage
// combination.
// 
// This adds all the raw scores for either all the 7-bit or all the
// 8-bit entries, depending on which category the rough initial analysis
// indicates.  At this time, there are no entries for which both methods
// are required.
//
// For 7-bit detection, code page is always set to 0 and the language's score
// is placed in the 0'th slot for each language.  The caller later scores
// code pages if needed, and fills the remaining slots.
// 
// For 8-bit detection, scores are generated for each code page and all
// ScoreIdx() slots are used.
{
    switch (ChooseDetectionType (pStr, nChars)) {

    case DETECT_7BIT:
        Score7Bit (pStr, nChars, S);
        break;

    case DETECT_8BIT:
        Score8Bit (pStr, nChars, S);
        break;
    }
}

void
LCDetect::ScoreLanguageW (LPCWSTR wcs, int nch, CScores &S, PCLCDConfigure pC) const
//
// Score the text at wcs for each language that it potentially contains.
//
// Add the scores to S at the ScoreIdx() for each language.
// 
// This first determines the Unicode script groups represented in wcs.
// Each WCHAR is mapped through CHARMAP_UNICODE to yield its "language group
// ID".  The IDs for each char are counted and the top scoring IDs indicate
// the probable languages or language groups.  Note that unlike all other
// use of n-gram scoring, NO WEIGHTS are associated with the IDs -- whichever
// group contains the most raw chars, wins.
// 
// Some languages are indicated by presence of characters in a particular
// script group; these scores are immediately added to S.
// 
// For script groups that indicate multiple languages, subdetection within
// the group is done only when the score for the group exceeds a threshhold
// that indicates the sub-detected languages are likely to be included in
// the final result.  This is purely a performance optimization, not to
// be confused with the uniform score threshhold applied by the caller.
//
// The "Group" entries themselves are never included in the result; they
// exist only to invoke subdetection.
//
// In many cases even a single Unicode character provides sufficient
// identification of script and language, so there is no minimum
// qualification for scores in the script ranges that indicate a
// specific language by range alone.
{
    // Score the chars according to the Unicode script group they belong to.
    // The array indices are the raw outputs of the primary Unicode Charmap
    // NOT to be confused with the ScoreIdx() of each language.  Further,
    // the scores are the simple count of the characters in each script
    // range, and are NOT weighted by any histogram.
    
    // In this initial step, the simple majority of characters per range
    // determines which further detection steps to take.

    const PHIdx map = GetMap (CHARMAP_UNICODE);

    int anScore[MAXSCORES];
    memset (anScore, 0, sizeof(int) * GetNUnicodeLanguages());

    for (int x = 0; x < nch; x++)
        anScore[map[wcs[x]]]++;

    debug(printf("    char_ignore score=%d\n",anScore[HIDX_IGNORE]));

    // Ignore scores for chars that correlate with no language

    anScore[HIDX_IGNORE] = 0;


    // Identify the scores that qualify a language for immediate inclusion
    // in the result, or that qualify a language group for further detection.


    // Find the high score to use as a relative threshhold for inclusion.
    
    int nMaxScore = 0;

    for (unsigned int i = 0; i < GetNUnicodeLanguages(); i++)
    {
        if (anScore[i] > nMaxScore)
            nMaxScore = anScore[i];
    }

    debug(printf("  unicode range max score=%d\n",nMaxScore));

    // Process all individual and group scores above a threshhold.

    // The threshhold logic is different from the logic for SBCS/DBCS
    // detection, because presence of even a single character in certain
    // Unicode script ranges can be a strong correct indicator for a
    // specific language.  The threshhold for subdetected scores is
    // higher, since that is a statistical result; single characters
    // are not as strong an indicator.

    // Set the threshhold for subdetecting.

    int nRelThresh = 1 + (nMaxScore * pC->nRelativeThreshhold) / 100;


    for (i = 0; i < GetNUnicodeLanguages(); i++)
    {
        // Threshhold for any range is at least this many raw chars in range.

        if (anScore[i] >= 2)
        {
            PLanguageUnicode pL = GetUnicodeLanguage(i);

            debug(printf("  using lang=%d score=%d:\n", pL->LanguageID(), anScore[i]));

            if (pL->LanguageID() == LANGID_UNKNOWN)
            {
                // DO NOTHING -- text is an unknown language

                debug(printf("    lang=unknown\n"));

            }
            else if (pL->NSubLangs() > 0)
            {
                // Subdetect language within a Unicode group, and add all the
                // unqualified raw scores directly to S.

                pL->ScoreSublanguages (wcs, nch, S);
            }
            else if ( pL->LanguageID() == LANGID_LATIN_GROUP &&
                      anScore[i] >= nRelThresh )
            {
                // Subdetect Latin/Western languages, and add all the
                // unqualified raw scores to S.
                
                ScoreLanguageAsSBCS (wcs, nch, S);
            } 
            else
            {
                debug(printf("    range identifies language\n"));

                // This range identifies a specific language; add it.

                CScore &s = S.Ref(pL->GetScoreIdx());
                s.SetLang (pL);
                s.SetScore (anScore[i] * UNICODE_DEFAULT_CHAR_SCORE);
                s.SetCharCount (nch);
                s.SetCodePage (0);
            }
        }
    }
}

/****************************************************************/

DWORD
LCDetect::DetectA (LPCSTR pStr, int nInputChars, 
    PLCDScore paScores, int *pnScores,
    PCLCDConfigure pLCDC) const
//
// Do SBCS / DBCS detection.  Detect language and code page of pStr, 
// fill paScores[] with the result and set *pnScores to the result count.
// On input, *pnScores is the available capacity of paScores.
//
// The text at pStr is broken into chunks, typically several hundred
// bytes.  
//
// In the first phase, each chunk is scored by language.  The scores for 
// a single chunk are qualified by both an absolute threshhold and by a 
// threshhold based on the high score of just that chunk.  Scores exceeding
// the threshhold are remembered towards the second phase; other scores
// are discarded.  
//
// For each score that will be remembered, if a code page is not already
// known for it then the code page for the chunk is determined and included
// with the score.  Note that the score refers only to the language, NOT
// to the confidence of the code page.
// 
// In the second phase, the combined scores for all chunks are examined.
// The scores are further qualified by a relative threshhold.  Only
// languages with scores exceeding the threshhold are included in the
// final result; the remainder are discarded.
//
// The two-step process is designed to yield good results for input containing
// text in multiple languages, or containing a high portion of whitespace or
// symbol characters that correlate with no language.  It also is designed
// to optimally handle tie-cases whether due to similar languages or to
// mixed-language input, and to avoid applying threshholds based on
// absolute scores.
//
// The presumption is that each chunk, generally, represents text in a single
// language, and no matter what the absolute high score is, its high score
// most likely is for that language.  The point of the first phase is to
// identify all the languages that are known with some confidence to be
// represented in the text.  For a given chunk, multiple languages scores may
// meet this criteria and be remembered towards the result.  Specifically,
// when a tie occurs, BOTH scores are always included.  (Choosing just one
// would be wrong too often to be worthwhile.)
//
// The point of the second phase is to filter out the noise allowed by the
// first phase.
{
    TScores<MAXSCORES> SChunk;      // Scores for one chunk at a time
    TScores<MAXSCORES> SAll;        // Qualified scores for ultimate result

    if (pLCDC == NULL)              // Use the default config if not specified
        pLCDC = &m_LCDConfigureDefault;

    if (*pnScores == 0)
        return NO_ERROR;

#define MAX_INPUT (USHRT_MAX-1)
    // CScore.NChars() is a USHORT to save space+time, so only this # of chars
    // can be accepted per call or the scoring would overflow.

    nInputChars = min (nInputChars, MAX_INPUT);
    debug(printf("LCD_Detect: detecting %d chars\n", nInputChars));

    // The first loop processed fixed-size chunks and accumulates all the
    // credibly-detected languages in SAll.  This is the "coarse" accuracy
    // qualification:  detect the language of text blocks small enough to
    // typically be in *one* language, and remember only the highest scoring
    // language for that chunk.  Then generate a multivalued result that
    // shows the distribution of language in the doc, instead of simply
    // returning the dominant language.  This is necessary because it is
    // much harder to determine the sole language than to determine the
    // multivalued result.

    int nProcessed = 0;

    while (nProcessed < nInputChars)
    {
        SChunk.Reset();             // reset is cheaper than constructing

        // Process nChunkSize worth of text if that will leave at least
        // another nChunkSize piece for the final pass.  If that would
        // leave a smaller final chunk, go ahead and process the entire
        // remaining input.

        int nch = nInputChars - nProcessed;

        if (nch >= pLCDC->nChunkSize * 2)
            nch = pLCDC->nChunkSize;


        debug(printf("\nStarting chunk: %d ch\n\"%.*s\"\n", nch, nch, &pStr[nProcessed]));

        ScoreLanguageA (&pStr[nProcessed], nch, SChunk);

        // Compute the threshhold for inclusion of each score in the
        // overall result.

        int nRelThresh = 1 + (SChunk.FindHighScore().GetScore() * pLCDC->nRelativeThreshhold) / 100;
        int nThresh7 = max (pLCDC->nMin7BitScore * nch, nRelThresh);
        int nThresh8 = max (pLCDC->nMin8BitScore * nch, nRelThresh);

        debug(printf("high score=%d min7=%d thresh7=%d thresh8=%d\n", SChunk.FindHighScore().GetScore(),pLCDC->nMin7BitScore*nch,nThresh7,nThresh8));

        // Qualify each score, remember only scores well-above the noise.

        for (unsigned int i = 0; i < SChunk.NElts(); i++)
        {
            CScore &s = SChunk.Ref(i);
            PLanguage pL = s.GetLang();

//          debug(if (s.GetScore()) printf("  raw: lang=%d score=%d cp=%d\n",pL->LanguageID(),s.GetScore(),s.GetCodePage()));

            if ( (s.GetScore() >= nThresh7 && pL->Type() == DETECT_7BIT) ||
                 (s.GetScore() >= nThresh8 && pL->Type() == DETECT_8BIT) )
            {
                debug(printf("    qual: lang=%d score=%d cp=%d\n",pL->LanguageID(),s.GetScore(),s.GetCodePage()));

                // If code page is not already set, detect it, and store
                // the score for this language using the scoreidx slot 
                // for that code page.  Store no score in the slots for
                // other code pages for the same language.

                int idx = 0;

                if (s.GetCodePage() == 0)
                    pL->ScoreCodePage (&pStr[nProcessed], nch, s, idx);

                // Remember this score for the overall results

                SAll.Ref(i + idx) += s;
            }
        }

        nProcessed += nch;
    }

    // SAll has entries for each unique { lang ID, code page }
    // with the char count and total raw score (not normalized per char) 
    // for those chunks whose score qualifies as a confident result and
    // that contributed to the entry.

    // Select the top-scoring code page for each language
    // and remove all other code page scores.
    
    debug(printf("Selecting top-scoring code pages\n"));

    SAll.SelectCodePages ();

    // Sort by decreasing score

    SAll.SortByScore ();

    // Build the client return structure
    //      Language ID
    //      Code page
    //      Doc percent 0-100
    //      Confidence 0-100

    int nScoresReturned = 0;

    for (unsigned i = 0; i < SAll.NElts() && nScoresReturned < *pnScores; i++)
    {
        CScore &s = SAll.Ref(i);

        LCDScore R;

        R.nLangID = s.GetLang()->LanguageID();
        R.nCodePage = s.GetCodePage();

        // Percent of doc for which this language scored above the
        // confidence threshhold, even if not 1st place for that chunk.

        R.nDocPercent = (s.GetCharCount() * 100) / nProcessed;

        debug(printf("s.CharCount=%d nProcessed=%d\n", s.GetCharCount(), nProcessed));

        // Confidence is the raw score for all the chunks for which this
        // language was detected above the confidence threshhold, divided
        // by the number of characters in those chunks.
        
        R.nConfidence = s.GetScore() / s.GetCharCount();

        debug(printf("Examining: lang=%d cp=%d docpct=%d\n", R.nLangID, R.nCodePage, R.nDocPercent));

        // Return only scores for languages detected in over a
        // minimum % of the doc.

        if (R.nDocPercent > pLCDC->nDocPctThreshhold)
        {
            debug(printf("  returning score\n"));
            paScores[nScoresReturned++] = R;
        }
    }

    debug(printf("Returning %d scores\n", nScoresReturned));

    *pnScores = nScoresReturned;

    return NO_ERROR;
}

DWORD
LCDetect::DetectW (LPCWSTR pwStr, int nInputChars,
    PLCDScore paScores, int *pnScores, PCLCDConfigure pLCDC) const
// 
// WCHAR (Unicode) version of LCD_Detect.  Score into paScores, one score
// per language.
{
    if (pLCDC == NULL)              // Use the default config if not specified
        pLCDC = &m_LCDConfigureDefault;

    if (*pnScores == 0)
        return NO_ERROR;

    // CScore.NChars() is a USHORT to save space+time, so only this # of chars
    // can be accepted per call or the scoring would overflow.

    nInputChars = min (nInputChars, MAX_INPUT);
    debug(printf("LCD_DetectW: detecting %d chars\n", nInputChars));

    TScores<MAXSCORES> SChunk;      // Raw score for one chunk at a time
    TScores<MAXSCORES> SAll;        // Qualifying scores for final result

    // SChunk is defined outside the loop since it's cheaper to Reset() it
    // than to reconstruct it each time.

    int nProcessed = 0;

    // Process one chunk of the input per loop

    while (nProcessed < nInputChars)
    {
        SChunk.Reset();


        // Process nChunkSize worth of text if that will leave at least
        // another nChunkSize piece for the final pass.  If that would
        // leave a smaller final chunk, go ahead and process the entire
        // remaining input.

        int nch = nInputChars - nProcessed;

        if (nch >= pLCDC->nChunkSize * 2)
            nch = pLCDC->nChunkSize;


        debug(printf("\nStarting chunk: %d ch\n", nch));

        // Compute the raw scores for the chunk.
        // This automatically includes the sub-detected language scores
        // for the Latin/Western group and Unicode groups, <<< when the 
        // group itself >>> scores above the inclusion threshhold.
        // But, the sub-detected scores themselves still need to be
        // qualified.

        ScoreLanguageW (&pwStr[nProcessed], nch, SChunk, pLCDC);

        // Compute the threshhold for inclusion of each score in the
        // overall result.

        int nRelThresh = 1 + (SChunk.FindHighScore().GetScore() * pLCDC->nRelativeThreshhold) / 100;
        int nThresh7 = max (pLCDC->nMin7BitScore * nch, nRelThresh);
        int nThreshU = max (pLCDC->nMinUnicodeScore * nch, nRelThresh);

        debug(printf("scores: nElts=%d rel=%d%% high=%d min=%d min7=%d minU=%d\n", SChunk.NElts(), pLCDC->nRelativeThreshhold, SChunk.FindHighScore().GetScore(), nRelThresh,nThresh7,nThreshU));

        // Qualify each score, remember only scores well-above the noise.

        for (unsigned int i = 0; i < SChunk.NElts(); i++)
        {
            CScore &s = SChunk.Ref(i);
            PLanguage pL = s.GetLang();

            if ( (s.GetScore() >= nThresh7 && pL->Type() == DETECT_7BIT) ||
                 (s.GetScore() >= nThreshU && pL->Type() == DETECT_UNICODE) )
            {
                debug(printf("    using lang=%d score=%d nch=%d\n",pL->LanguageID(),s.GetScore(),s.GetCharCount()));

                // Remember this score for the overall results

                SAll.Ref(i) += s;
            }
        }

        nProcessed += nch;
    }

    // SAll has entries for each unique language with char count and total
    // raw score (not normalized per char) for those chunks whose score
    // qualifies as a confident result.

    // SAll may contain entries only for 7-bit and Unicode languages,
    // at most one entry per unique Win32 language ID
    
    debug(printf("Selecting scores for result:\n"));

    // Sort by decreasing score

    SAll.SortByScore ();

    // Build the client return structure
    //      Language ID
    //      Code page
    //      Doc percent 0-100
    //      Confidence 0-100

    int nScoresReturned = 0;

    for (unsigned i = 0; i < SAll.NElts() && nScoresReturned < *pnScores; i++)
    {
        CScore &s = SAll.Ref(i);

        LCDScore R;

        R.nLangID = s.GetLang()->LanguageID();
        R.nCodePage = s.GetCodePage();

        // Percent of doc for which this language scored above the
        // confidence threshhold, even if not 1st place for that chunk.

        R.nDocPercent = (s.GetCharCount() * 100) / nProcessed;

        // Confidence is the raw score for all the chunks for which this
        // language was detected above the confidence threshhold, divided
        // by the number of characters in those chunks.
        
        R.nConfidence = s.GetScore() / s.GetCharCount();

        debug(printf("  testing: lang=%d nch=%d docpct=%d\n", R.nLangID,s.GetCharCount(),R.nDocPercent));

        // Return only scores for languages detected in over a
        // minimum % of the doc.

        if (R.nDocPercent > pLCDC->nDocPctThreshhold)
        {
            debug(printf("  returning score\n"));
            paScores[nScoresReturned++] = R;
        }
    }

    debug(printf("Returning %d scores\n", nScoresReturned));

    *pnScores = nScoresReturned;

    return NO_ERROR;
}

/****************************************************************/
/****************************************************************/

#if 0
// Export functions

BOOL APIENTRY 
DllMain (HANDLE hM, DWORD ul_reason, LPVOID lpReserved)
{
    switch (ul_reason) {

    case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls( (HINSTANCE)hM );

            LCDetect *pLC = new LCDetect ( (HMODULE)hM );
            if (pLC == NULL)
                return FALSE;

            if (pLC->LoadState() != NO_ERROR)
            {
                delete pLC;
                return FALSE;
            }

            g_pLCDetect = pLC;
        }
        return TRUE;

    case DLL_PROCESS_DETACH:
        if (g_pLCDetect != NULL)
            delete (LCDetect *)g_pLCDetect;
        g_pLCDetect = NULL;
        return TRUE;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
#endif 

extern "C" void WINAPI 
LCD_GetConfig (PLCDConfigure pLCDC)
{
    if (g_pLCDetect)
        *pLCDC = g_pLCDetect->GetConfig();
}

extern "C" DWORD WINAPI
LCD_Detect (LPCSTR pStr, int nInputChars, 
    PLCDScore paScores, int *pnScores,
    PCLCDConfigure pLCDC)
// 
// Score into paScores, one score per language, "qualifying" scores only.
// Return ranked by decreasing score.
{
    if (g_pLCDetect == NULL)
        return ERROR_INVALID_FUNCTION;

    return g_pLCDetect->DetectA(pStr, nInputChars, paScores, pnScores, pLCDC);
}

extern "C" DWORD WINAPI
LCD_DetectW (LPCWSTR wcs, int nInputChars,
    PLCDScore paScores, int *pnScores,
    PCLCDConfigure pLCDC)
{
    if (g_pLCDetect == NULL)
        return ERROR_INVALID_FUNCTION;

    return g_pLCDetect->DetectW(wcs, nInputChars, paScores, pnScores, pLCDC);
}

extern "C" void WINAPI
LCD_SetDebug (int f)
{
#ifdef DEBUG_LCDETECT
    g_fDebug = f;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mimereg.cpp ===
#include "private.h"
#include <strsafe.h>
#ifdef UNIX
/* Convert from little endian to big endian format */
#define CONVERTLONG(a,b,c,d) (((unsigned long )a) + \
                           ((unsigned long )b << 8) + \
                           ((unsigned long )c << 16) + \
                           ((unsigned long )d << 24))
#endif /* UNIX */

//
//  Globals
//
CMimeDatabaseReg *g_pMimeDatabaseReg = NULL;

//
//  Globals
//
PRFC1766INFOA   g_pRfc1766Reg = NULL;
UINT            g_cRfc1766Reg = 0, g_cMaxRfc1766 = 0;

//
//  Functions
//
void CMimeDatabaseReg::BuildRfc1766Table(void)
{
    HKEY hKey = NULL;
    DWORD dwIndex, dwType, cInfo, cbMaxValueLen, cbLCID, cb;
    TCHAR szLCID[8], sz[MAX_RFC1766_NAME +  MAX_LOCALE_NAME + 1];

    DebugMsg(DM_TRACE, TEXT("CRfc1766::BuildRfc1766Table called."));
    EnterCriticalSection(&g_cs);
    if (NULL == g_pRfc1766Reg)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_RFC1766, 0, KEY_READ, &hKey))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, NULL, NULL, NULL, &cInfo, &cbMaxValueLen, NULL, NULL, NULL))
            {
                g_pRfc1766Reg = (PRFC1766INFOA)LocalAlloc(LPTR, sizeof(RFC1766INFOA) * cInfo);
                if (NULL != g_pRfc1766Reg)
                {
                    g_cRfc1766Reg = 0;
                    g_cMaxRfc1766 = cInfo;
                    dwIndex = 0;
                    while (g_cRfc1766Reg < g_cMaxRfc1766)
                    {
                        LONG lRet;

                        cbLCID = ARRAYSIZE(szLCID) - 2;
                        cb = sizeof(sz);
                        lRet = RegEnumValue(hKey, dwIndex++, szLCID + 2, &cbLCID, 0, &dwType, (LPBYTE)sz, &cb);
                        if (ERROR_SUCCESS == lRet)
                        {
                            int iLCID;

                            szLCID[0] = TEXT('0');
                            szLCID[1] = TEXT('x');
                            // StrToInt
                            if (iLCID = HexToNum(szLCID + 2))
                            {
                                g_pRfc1766Reg[g_cRfc1766Reg].lcid = (LCID)iLCID;
                                if (REG_SZ == dwType)
                                {
                                    TCHAR *psz = sz;

                                    while (*psz)
                                    {
                                        if (TEXT(';') == *psz)
                                        {
                                            *psz = TEXT('\0');
                                            break;
                                        }
                                        psz = CharNext(psz);
                                    }
                                    lstrcpyn(g_pRfc1766Reg[g_cRfc1766Reg].szRfc1766, sz, MAX_RFC1766_NAME);
                                    lstrcpyn(g_pRfc1766Reg[g_cRfc1766Reg].szLocaleName, psz + 1, MAX_LOCALE_NAME);
                                    g_cRfc1766Reg++;
                                }
                            }
                        }
                        else if (ERROR_NO_MORE_ITEMS == lRet)
                            break;
                    }
                }
            }
            RegCloseKey(hKey);
        }
    }
    LeaveCriticalSection(&g_cs);
}

void CMimeDatabaseReg::FreeRfc1766Table(void)
{
    DebugMsg(DM_TRACE, TEXT("CRfc1766::FreeRfc1766Table called."));
    EnterCriticalSection(&g_cs);
    if (NULL != g_pRfc1766Reg)
    {
        LocalFree(g_pRfc1766Reg);
        g_pRfc1766Reg = NULL;
        g_cRfc1766Reg = g_cMaxRfc1766 = 0;
    }
    LeaveCriticalSection(&g_cs);
}

void CMimeDatabaseReg::EnsureRfc1766Table(void)
{
    // Ensure g_pRfc1766 is initialized
    if (NULL == g_pRfc1766Reg)
        BuildRfc1766Table();
}


STDAPI CMimeDatabaseReg::LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    EnsureRfc1766Table();
    if (NULL != pszRfc1766 && 0 < iMaxLength)
    {
        for (i = 0; i < g_cRfc1766Reg; i++)
        {
            if (g_pRfc1766Reg[i].lcid == Locale)
                break;
        }
        if (i < g_cRfc1766Reg)
        {
            lstrcpyn(pszRfc1766, g_pRfc1766Reg[i].szRfc1766, iMaxLength);
            hr = S_OK;
        }
        else
        {
            TCHAR sz[MAX_RFC1766_NAME];

            if (GetLocaleInfoA(Locale, LOCALE_SABBREVLANGNAME, sz, ARRAYSIZE(sz)))
            {
                CharLowerA(sz);
                if (!lstrcmpA(sz, TEXT("cht")))
                    lstrcpynA(pszRfc1766, TEXT("zh-cn"), iMaxLength);
                else if (!lstrcmpA(sz, TEXT("chs")))
                    lstrcpynA(pszRfc1766, TEXT("zh-tw"), iMaxLength);
                else if (!lstrcmpA(sz, TEXT("jpn")))
                    lstrcpynA(pszRfc1766, TEXT("ja"), iMaxLength);
                else
                {
                    sz[2] = TEXT('\0');
                    lstrcpynA(pszRfc1766, sz, iMaxLength);
                }
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}    

STDAPI CMimeDatabaseReg::LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pwszRfc1766 && 0 < nChar)
    {
        TCHAR sz[MAX_RFC1766_NAME];

        hr = LcidToRfc1766A(Locale, (LPSTR)sz, ARRAYSIZE(sz));
        if (S_OK == hr)
        {
            int i;

            for (i = 0; i < nChar - 1; i++)
            {
                pwszRfc1766[i] = (WCHAR)sz[i];
                if (L'\0' == pwszRfc1766[i])
                    break;
            }
            if (i == nChar - 1)
                pwszRfc1766[i] = L'\0';            
        }
    }
    return hr;
}    

STDAPI CMimeDatabaseReg::Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    EnsureRfc1766Table();
    if (NULL != pLocale && NULL != pszRfc1766)
    {
        for (i = 0; i < g_cRfc1766Reg; i++)
        {
            if (!lstrcmpi(g_pRfc1766Reg[i].szRfc1766, pszRfc1766))
                break;
        }
        if (i < g_cRfc1766Reg)
        {
            *pLocale = g_pRfc1766Reg[i].lcid;
            hr = S_OK;
        }
        else
        {
            if (2 < lstrlen(pszRfc1766))
            {
                TCHAR sz[3];

                sz[0] = pszRfc1766[0];
                sz[1] = pszRfc1766[1];
                sz[2] = TEXT('\0');
                for (i = 0; i < g_cRfc1766Reg; i++)
                {
                    if (!lstrcmpi(g_pRfc1766Reg[i].szRfc1766, sz))
                        break;                
                }
                if (i < g_cRfc1766Reg)
                {
                    *pLocale = g_pRfc1766Reg[i].lcid;
                    hr = S_FALSE;
                }
                else
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}

STDAPI CMimeDatabaseReg::Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pLocale && NULL != pwszRfc1766)
    {
        int i;
        TCHAR sz[MAX_RFC1766_NAME];

        for (i = 0; i < MAX_RFC1766_NAME - 1; i++)
        {
            sz[i] = (TCHAR)pwszRfc1766[i];
            if (TEXT('\0') == sz[i])
                break;
        }
        if (i == MAX_RFC1766_NAME -1)
            sz[i] = TEXT('\0');

        hr = Rfc1766ToLcidA(pLocale, (LPCSTR)sz);
    }
    return hr;
}


//
//  CMimeDatabase implementation
//
CMimeDatabaseReg::CMimeDatabaseReg()
{
    DebugMsg(DM_TRACE, TEXT("constructor of CMimeDatabase 0x%08x"), this);
    _pCodePage = NULL;
    _cCodePage = _cMaxCodePage = 0;
    _pCharset = NULL;
    _cCharset = _cMaxCharset = 0;
    _fAllCPCached = FALSE;
    InitializeCriticalSection(&_cs);
}

CMimeDatabaseReg::~CMimeDatabaseReg()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CMimeDatabase 0x%08x"), this);
    FreeMimeDatabase();
    DeleteCriticalSection(&_cs);
}

void CMimeDatabaseReg::BuildCodePageMimeDatabase(void)
{
    HKEY hKey = NULL;
    DWORD cInfo, cbMaxSubKeyLen;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::BuildCodePageMimeDatabase called."));
    // Open CodePage Mime Database Key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CODEPAGE, 0, KEY_READ, &hKey))
    {
        ASSERT(NULL != hKey);
        if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cInfo, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            if (NULL == _pCodePage)
            {
                _pCodePage = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cInfo);
                if (NULL != _pCodePage)
                    _cMaxCodePage = cInfo;

            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }

}

void CMimeDatabaseReg::BuildCharsetMimeDatabase(void)
{
    HKEY hKey = NULL;
    DWORD cInfo, cbMaxSubKeyLen;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::BuildCharsetMimeDatabase called."));
    // Open Charset Mime Database Key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CHARSET, 0, KEY_READ, &hKey))
    {
        ASSERT(NULL != hKey);
        if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cInfo, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            if (NULL == _pCharset)
            {
                _pCharset = (PMIMECSETINFO)LocalAlloc(LPTR, sizeof(MIMECSETINFO) * cInfo);
                if (NULL != _pCharset)
                    _cMaxCharset = cInfo;
            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
}

void CMimeDatabaseReg::FreeMimeDatabase(void)
{
    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::FreeMimeDatabase called."));
    EnterCriticalSection(&_cs);
    if (NULL != _pCodePage)
    {
        LocalFree(_pCodePage);
        _pCodePage = NULL;
        _cCodePage = _cMaxCodePage = 0;
    }
    if (NULL != _pCharset)
    {
        LocalFree(_pCharset);
        _pCharset = NULL;
        _cCharset = _cMaxCharset = 0;
    }
    LeaveCriticalSection(&_cs);
    FreeRfc1766Table();
}

STDAPI CMimeDatabaseReg::EnumCodePageInfo(void)
{
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    MIMECPINFO CPInfo;
    TCHAR szCodePage[15];
    HRESULT hr = S_OK;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::EnumCodePageInfo called."));
    EnterCriticalSection(&_cs);
    if (FALSE == _fAllCPCached)
    {
        if (NULL == _pCodePage)
            BuildCodePageMimeDatabase();
        if (_pCodePage)
        {
            // Open CodePage Mime Database Key
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CODEPAGE, 0, KEY_READ, &hKey))
            {
                ASSERT(NULL != hKey);
                while (ERROR_SUCCESS == RegEnumKey(hKey, dwIndex++, szCodePage, ARRAYSIZE(szCodePage)))
                {
                    UINT uiCodePage = MLStrToInt(szCodePage);
    
                    if (0 <= FindCodePageFromCache(uiCodePage))
                        continue;

                    if (TRUE == FindCodePageFromRegistry(uiCodePage, &CPInfo))
                    {
                        _pCodePage[_cCodePage] = CPInfo;
                        _cCodePage++;
                    }
                }
                _fAllCPCached = TRUE;
                RegCloseKey(hKey);
                hKey = NULL;
            }
            if (0 < _cCodePage)
                QSortCodePageInfo(0, _cCodePage-1);

            // Fill empty font face field base on its FamilyCodePage
            for (UINT i = 0; i < _cCodePage; i++)
            {
                UINT uiFamily;
                WCHAR wszFixed[MAX_MIMEFACE_NAME], wszProp[MAX_MIMEFACE_NAME];

                uiFamily = 0;
                wszFixed[0] = wszProp[0] = TEXT('\0');

                if (TEXT('\0') == _pCodePage[i].wszFixedWidthFont[0] || TEXT('\0') == _pCodePage[i].wszProportionalFont[0])
                {
                    if (uiFamily != _pCodePage[i].uiFamilyCodePage)
                    {
                        for (UINT j = 0; j < _cCodePage; j++)
                        {
                            if (_pCodePage[i].uiFamilyCodePage == _pCodePage[j].uiCodePage)
                            {
                                uiFamily = _pCodePage[j].uiCodePage;
                                MLStrCpyNW(wszFixed, _pCodePage[j].wszFixedWidthFont, MAX_MIMEFACE_NAME);
                                MLStrCpyNW(wszProp, _pCodePage[j].wszProportionalFont, MAX_MIMEFACE_NAME);
                                break;
                            }
                        }                
                    }
                    MLStrCpyNW(_pCodePage[i].wszFixedWidthFont, wszFixed, MAX_MIMEFACE_NAME);
                    MLStrCpyNW(_pCodePage[i].wszProportionalFont, wszProp, MAX_MIMEFACE_NAME);                    
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&_cs);

    return hr;
}

STDAPI CMimeDatabaseReg::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    EnterCriticalSection(&_cs);
    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    *pcCodePage = _cMaxCodePage;
    LeaveCriticalSection(&_cs);
    return NOERROR;
}

STDAPI CMimeDatabaseReg::GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo)
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfo called."));
    if (NULL != pcpInfo)
    {
        EnterCriticalSection(&_cs);
        if (NULL == _pCodePage)
            BuildCodePageMimeDatabase();

        if (_pCodePage)
        {
            idx = FindCodePageFromCache(uiCodePage);
            if (0 > idx)
            {
                MIMECPINFO CPInfo = {0};

                if (TRUE == FindCodePageFromRegistry(uiCodePage, &CPInfo))
                {
                    if (CPInfo.uiCodePage != CPInfo.uiFamilyCodePage)
                    {
                        idx = FindCodePageFromCache(CPInfo.uiFamilyCodePage);
                        if (0 > idx)
                        {
                            MIMECPINFO FamilyCPInfo;

                            if (TRUE == FindCodePageFromRegistry(CPInfo.uiFamilyCodePage, &FamilyCPInfo))
                            {
                                idx = _cCodePage;
                                _pCodePage[_cCodePage] = FamilyCPInfo;
                                _cCodePage++;
                            }
                        }
                        MLStrCpyNW(CPInfo.wszFixedWidthFont, _pCodePage[idx].wszFixedWidthFont, MAX_MIMEFACE_NAME);
                        MLStrCpyNW(CPInfo.wszProportionalFont, _pCodePage[idx].wszProportionalFont, MAX_MIMEFACE_NAME);
                    }
                    _pCodePage[_cCodePage] = CPInfo;
                    _cCodePage++;
                    QSortCodePageInfo(0, _cCodePage-1);
                    idx = FindCodePageFromCache(uiCodePage);
                }
            }
            if (0 <= idx)
            {
                *pcpInfo = _pCodePage[idx];
                hr = S_OK;
            }
            LeaveCriticalSection(&_cs);
        }
    }
    return hr;
}

int CMimeDatabaseReg::FindCodePageFromCache(UINT uiCodePage)
{
    UINT i;
    int iRet = -1;

    for (i = 0; i < _cCodePage; i++)
    {
        if (_pCodePage[i].uiCodePage == uiCodePage)
        {
            iRet = i;
            break;
        }
    }
    return iRet;
}

BOOL CMimeDatabaseReg::FindCodePageFromRegistry(UINT uiCodePage, PMIMECPINFO pcpInfo)
{
    HKEY hKey;
    DWORD dw, cb;
    TCHAR szKey[256],  sz[MAX_MIMECP_NAME];
    BOOL fRet = FALSE;
    HRESULT hr = E_FAIL;

    //*STRSAFE*     wsprintf(szKey, TEXT("%s\\%d"), REGSTR_KEY_MIME_DATABASE_CODEPAGE, uiCodePage);
    hr = StringCchPrintf(szKey , ARRAYSIZE(szKey),  TEXT("%s\\%d"), REGSTR_KEY_MIME_DATABASE_CODEPAGE, uiCodePage);
    if (!SUCCEEDED(hr))
    {
       return FALSE;
    }
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey))
    {
        TCHAR *psz, *pszComma;
        CHARSETINFO rCharsetInfo;

        pcpInfo->uiCodePage = uiCodePage;

        cb = sizeof(dw);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_FAMILY, 0, NULL, (LPBYTE)&dw, &cb))
            pcpInfo->uiFamilyCodePage = (UINT)dw;
        else
            pcpInfo->uiFamilyCodePage = pcpInfo->uiCodePage;

        cb = sizeof(dw);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_LEVEL, 0, NULL, (LPBYTE)&dw, &cb))
#ifdef UNIX
        {
           BYTE* px = (BYTE*)&dw;
           pcpInfo->dwFlags = CONVERTLONG(px[0], px[1], px[2], px[3]);
        }
#else
            pcpInfo->dwFlags = dw;
#endif /* UNIX */
        else
            pcpInfo->dwFlags = 0;

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_DESCRIPTION, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszDescription, ARRAYSIZE(pcpInfo->wszDescription));
        else
        {
            TCHAR szDef[MAX_MIMECP_NAME];
            HRESULT hr;

            LoadString(g_hInst, IDS_MIME_LANG_DEFAULT, szDef, ARRAYSIZE(szDef));
            //*STRSAFE*             wsprintf(sz, szDef, pcpInfo->uiCodePage);
            hr = StringCchPrintf(sz , ARRAYSIZE(sz),  szDef, pcpInfo->uiCodePage);
            if (!SUCCEEDED(hr))
            {
                RegCloseKey(hKey);
                return FALSE;
            }
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszDescription, ARRAYSIZE(pcpInfo->wszDescription));
        }

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_FIXEDWIDTHFONT, NULL, NULL, (LPBYTE)sz, &cb))
        {
            psz = sz;
            pszComma =  MLStrChr(sz, TEXT(','));
            if (NULL != pszComma)               // If there are multiple font name
            {
                if (uiCodePage != g_uACP)
                    psz = pszComma + 1;         // Take right side(English) fontname for non-native codepage info
                else
                    *pszComma = TEXT('\0');     // Take left side(DBCS) fontname for native codepage info
            }
            if (lstrlen(psz) >= MAX_MIMEFACE_NAME)
                psz[MAX_MIMEFACE_NAME-1] = TEXT('\0');
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pcpInfo->wszFixedWidthFont, ARRAYSIZE(pcpInfo->wszFixedWidthFont));
        }
        else
            pcpInfo->wszFixedWidthFont[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_PROPORTIONALFONT, NULL, NULL, (LPBYTE)sz, &cb))
        {
            psz = sz;
            pszComma = MLStrChr(sz, TEXT(','));
            if (NULL != pszComma)               // If there are multiple font name
            {
                if (uiCodePage != g_uACP)
                    psz = pszComma + 1;         // Take right side(English) fontname for non-native codepage info
                else
                    *pszComma = TEXT('\0');     // Take left side(DBCS) fontname for native codepage info
            }
            if (lstrlen(psz) >= MAX_MIMEFACE_NAME)
                psz[MAX_MIMEFACE_NAME-1] = TEXT('\0');
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pcpInfo->wszProportionalFont, ARRAYSIZE(pcpInfo->wszProportionalFont));
        }
        else
            pcpInfo->wszProportionalFont[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_BODYCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszBodyCharset, ARRAYSIZE(pcpInfo->wszBodyCharset));
        else
            pcpInfo->wszBodyCharset[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_HEADERCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszHeaderCharset, ARRAYSIZE(pcpInfo->wszHeaderCharset));
        else
            MLStrCpyNW(pcpInfo->wszHeaderCharset, pcpInfo->wszBodyCharset, MAX_MIMECSET_NAME);

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_WEBCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszWebCharset, ARRAYSIZE(pcpInfo->wszWebCharset));
        else
            MLStrCpyNW(pcpInfo->wszWebCharset, pcpInfo->wszBodyCharset, MAX_MIMECSET_NAME);

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_PRIVCONVERTER, NULL, NULL, (LPBYTE)sz, &cb))
            pcpInfo->dwFlags |= MIMECONTF_PRIVCONVERTER;

        if (0 != TranslateCharsetInfo(IntToPtr_(LPDWORD, pcpInfo->uiFamilyCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
            pcpInfo->bGDICharset = (BYTE)rCharsetInfo.ciCharset;
        else
            pcpInfo->bGDICharset = DEFAULT_CHARSET;


        if (1200 == pcpInfo->uiFamilyCodePage || 50000 == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiFamilyCodePage)) // 50000 means user defined
        {
            if (TRUE == CheckFont(pcpInfo->bGDICharset))
            {
                if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID;
                else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID;
            }
            else
            {
                if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
                else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
            }

        }
        RegCloseKey(hKey);
        fRet = TRUE;
    }
    return fRet;
}

STDAPI CMimeDatabaseReg::GetCodePageInfoWithIndex(UINT uidx, PMIMECPINFO pcpInfo)
{
    HRESULT hr = NOERROR;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfoWithIndex called."));
    EnterCriticalSection(&_cs);
    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    if (uidx < _cCodePage && _pCodePage)
        *pcpInfo = _pCodePage[uidx];
    else
        hr = E_FAIL;
    LeaveCriticalSection(&_cs);
    return hr;
}

STDAPI CMimeDatabaseReg::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCharsetInfo called."));
    if (NULL != pcsetInfo)
    {
        EnterCriticalSection(&_cs);
        if (NULL == _pCharset)
            BuildCharsetMimeDatabase();
        if (_pCharset)
        {
            idx = FindCharsetFromCache(Charset);
            if (0 > idx)
                idx = FindCharsetFromRegistry(Charset, FALSE);
            if (0 <= idx)
            {
                *pcsetInfo = _pCharset[idx];
                hr = S_OK;
            }
        }
        LeaveCriticalSection(&_cs);
    }
    return hr;
}

int CMimeDatabaseReg::FindCharsetFromCache(BSTR Charset)
{
    int iStart, iEnd, iMiddle, iCmpResult, iRet = -1;

    iStart = 0;
    iEnd = _cCharset - 1;
    while (iStart <= iEnd)
    {
        iMiddle = (iStart + iEnd) / 2;
        iCmpResult = MLStrCmpIW(Charset, _pCharset[iMiddle].wszCharset);
        if (iCmpResult < 0)
            iEnd = iMiddle - 1;
        else if (iCmpResult > 0)
            iStart = iMiddle + 1;
        else
        {
            iRet = iMiddle;
            break;
        }
    }
    return iRet;
}

int CMimeDatabaseReg::FindCharsetFromRegistry(BSTR Charset, BOOL fFromAlias)
{
    HKEY hKey;
    TCHAR szKey[256], szCharset[MAX_MIMECSET_NAME];
    int iRet = -1;
    HRESULT hr = E_FAIL;

    WideCharToMultiByte(CP_ACP, 0, Charset, -1, szCharset, ARRAYSIZE(szCharset), NULL, NULL);
    //*STRSAFE*     lstrcpy(szKey, REGSTR_KEY_MIME_DATABASE_CHARSET);
    hr = StringCchCopy(szKey , ARRAYSIZE(szKey),  REGSTR_KEY_MIME_DATABASE_CHARSET);
    if (!SUCCEEDED(hr))
    {
       return iRet;
    }
    //*STRSAFE*     lstrcat(szKey, TEXT("\\"));
    hr = StringCchCat(szKey , ARRAYSIZE(szKey),  TEXT("\\"));
    if (!SUCCEEDED(hr))
    {
       return iRet;
    }
    //*STRSAFE*     lstrcat(szKey, szCharset);
    hr = StringCchCat(szKey , ARRAYSIZE(szKey),  szCharset);
    if (!SUCCEEDED(hr))
    {
       return iRet;
    }
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey))
    {
        DWORD cb, dw;
        TCHAR sz[MAX_MIMECSET_NAME];
        WCHAR wsz[MAX_MIMECSET_NAME];

        cb = sizeof(sz);
        if (FALSE == fFromAlias && ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_ALIASTO, NULL, NULL, (LPBYTE)sz, &cb))
        {
            MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, ARRAYSIZE(wsz));
            iRet = FindCharsetFromCache(wsz);
            if (0 > iRet)
                iRet = FindCharsetFromRegistry(wsz, TRUE);
            if (0 <= iRet)
            {
                MLStrCpyNW(_pCharset[_cCharset].wszCharset, Charset, MAX_MIMECSET_NAME);
                _pCharset[_cCharset].uiCodePage = _pCharset[iRet].uiCodePage;
                _pCharset[_cCharset].uiInternetEncoding = _pCharset[iRet].uiInternetEncoding;
                _cCharset++;
                QSortCharsetInfo(0, _cCharset-1);
                iRet = FindCharsetFromCache(Charset);
            }
        }
        else
        {
            MLStrCpyNW(_pCharset[_cCharset].wszCharset, Charset, MAX_MIMECSET_NAME);
            cb = sizeof(dw);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_CODEPAGE, 0, NULL, (LPBYTE)&dw, &cb))
            {
                _pCharset[_cCharset].uiCodePage = (UINT)dw;
                cb = sizeof(dw);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_INETENCODING, 0, NULL, (LPBYTE)&dw, &cb))
                {
                    _pCharset[_cCharset].uiInternetEncoding = (UINT)dw;
                    _cCharset++;
                    QSortCharsetInfo(0, _cCharset-1);
                    iRet = FindCharsetFromCache(Charset);
                }
            }
        }
        RegCloseKey(hKey);
    }
    return iRet;
}


BOOL CMimeDatabaseReg::CheckFont(BYTE bGDICharset)
{
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::CheckFont called."));
    if (DEFAULT_CHARSET == bGDICharset)
        fRet = TRUE;
    else
    {
        HDC     hDC;
        LOGFONT lf;
        HWND    hWnd;

        hWnd = GetTopWindow(GetDesktopWindow());
        hDC = GetDC(hWnd);

        if (NULL != hDC)
        {
            lf.lfFaceName[0] = TEXT('\0');
            lf.lfPitchAndFamily = 0;
            lf.lfCharSet = bGDICharset;
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)&fRet, 0);
        }
        ReleaseDC(hWnd, hDC);
    }
    return fRet;
}

void CMimeDatabaseReg::QSortCodePageInfo(LONG left, LONG right)
{
    register LONG i, j;
    WCHAR k[MAX_MIMECP_NAME];
    MIMECPINFO t;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::QSortCodePageInfo called."));
    i = left;
    j = right;
    StringCchCopyW(k, ARRAYSIZE(k), _pCodePage[(left + right) / 2].wszDescription);

    do  
    {
        while(MLStrCmpIW(_pCodePage[i].wszDescription, k) < 0 && i < right)
            i++;
        while (MLStrCmpIW(_pCodePage[j].wszDescription, k) > 0 && j > left)
            j--;

        if (i <= j)
        {
            t = _pCodePage[i];
            _pCodePage[i] = _pCodePage[j];
            _pCodePage[j] = t;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSortCodePageInfo(left, j);
    if (i < right)
        QSortCodePageInfo(i, right);
}

void CMimeDatabaseReg::QSortCharsetInfo(LONG left, LONG right)
{
    register LONG i, j;
    WCHAR k[MAX_MIMECSET_NAME];
    MIMECSETINFO t;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::QSortCharsetInfo called."));
    i = left;
    j = right;
    StringCchCopyW(k, ARRAYSIZE(k), _pCharset[(left + right) / 2].wszCharset);

    do  
    {
        while(MLStrCmpIW(_pCharset[i].wszCharset, k) < 0 && i < right)
            i++;
        while (MLStrCmpIW(_pCharset[j].wszCharset, k) > 0 && j > left)
            j--;

        if (i <= j)
        {
            t = _pCharset[i];
            _pCharset[i] = _pCharset[j];
            _pCharset[j] = t;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSortCharsetInfo(left, j);
    if (i < right)
        QSortCharsetInfo(i, right);
}

// validates all cps that are in the same
// family of the given codepage
STDAPI CMimeDatabaseReg::ValidateCP(UINT uiCodePage)
{
    UINT i;

    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    //
    // just look into already cached codepages
    // 
    for (i = 0; i < _cCodePage; i++)
    {
        if (_pCodePage[i].uiFamilyCodePage == uiCodePage)
            _pCodePage[i].dwFlags |=  MIMECONTF_VALID|MIMECONTF_VALID_NLS;
    }
        
    return S_OK; // never fail?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\lccommon.h ===
/*
 * Declarations common to compiler and detector.
 *
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Added Unicode support, and persisting
 *                                    Charmaps in the data file.
 */

#ifndef __INC_LCDCOMP_COMMON_H
#define __INC_LCDCOMP_COMMON_H

/****************************************************************/

// Compiled detection data file, in lcdetect.dll module directory
#define DETECTION_DATA_FILENAME "mlang.dat"

// Limits
#define MAX7BITLANG 30
#define MAX8BITLANG 30
#define MAXUNICODELANG 30
#define MAXSUBLANG 5            // max # of sublanguages or codepages per lang
#define MAXCHARMAPS 10          // max # of Charmaps, overall


// Special case entries for the training script and detector.
// These language IDs are never returned by the detector.

#define LANGID_UNKNOWN      0x400
#define LANGID_LATIN_GROUP  0x401
#define LANGID_CJK_GROUP    0x402

// Value type of a histogram array index.
// This is the output value of the SBCS/DBCS or WCHAR reduction mapping,
// and is used as the index into the n-gram arrays and for the Unicode
// language group IDs.
// 
typedef unsigned char HIdx;
typedef HIdx *PHIdx;
#define HIDX_MAX UCHAR_MAX      // keep consistent w/ HIdx

// Fixed index values for mapped characters
#define HIDX_IGNORE     0
#define HIDX_EXTD       1
#define HIDX_LETTER_A   2
#define HIDX_LETTER_Z   (HIDX_LETTER_A + 25)


// Value type of a histogram element
typedef unsigned char HElt;
typedef HElt *PHElt;
#define HELT_MAX UCHAR_MAX      // keep consistent w/ HElt


#define LANG7_DIM 3             // 7-bit language uses trigrams

// Fixed IDs of the Charmaps
#define CHARMAP_UNICODE  0      // Built from RANGE directives
#define CHARMAP_7BITLANG 1      // Built from CHARMAP 1
#define CHARMAP_8BITLANG 2      // From CHARMAP 2
#define CHARMAP_CODEPAGE 3      // From CHARMAP 3
#define CHARMAP_U27BIT 4        // Built internally for Unicode to 7-bit lang
#define CHARMAP_NINTERNAL 5     // First ID for dynamic subdetection maps


#define DEFAULT_7BIT_EDGESIZE 28
#define DEFAULT_8BIT_EDGESIZE 155


#define UNICODE_DEFAULT_CHAR_SCORE  50

/****************************************************************/

// Compiled file format.

// These declarations directly define the raw file format.
// Be careful making changes here, and be sure to change the
// header version number when appropriate.

#define APP_SIGNATURE 0x5444434C    // "LCDT"
#define APP_VERSION   2

enum SectionTypes {             // for m_dwType below
    SECTION_TYPE_LANGUAGE = 1,  // any language definition
    SECTION_TYPE_HISTOGRAM = 2, // any histogram
    SECTION_TYPE_MAP = 3        // any character mapping table
};

enum DetectionType {            // SBCS/DBCS detection types
    DETECT_NOTDEFINED = 0, 
    DETECT_7BIT,
    DETECT_8BIT,
    DETECT_UNICODE,
        
    DETECT_NTYPES
};

// FileHeader -- one-time header at start of file

typedef struct FileHeader {
    DWORD   m_dwAppSig;         // 'DTCT'
    DWORD   m_dwVersion;
    DWORD   m_dwHdrSizeBytes;   // byte offset of 1st real section
    DWORD   m_dwN7BitLanguages;
    DWORD   m_dwN8BitLanguages;
    DWORD   m_dwNUnicodeLanguages;
    DWORD   m_dwNCharmaps;
    DWORD   m_dwMin7BitScore;
    DWORD   m_dwMin8BitScore;
    DWORD   m_dwMinUnicodeScore;
    DWORD   m_dwRelativeThreshhold;
    DWORD   m_dwDocPctThreshhold;
    DWORD   m_dwChunkSize;
} FileHeader;
typedef FileHeader *PFileHeader;

// FileSection -- common header that begins each file section

typedef struct FileSection {
    DWORD   m_dwSizeBytes;      // section size incl. header (offset to next)
    DWORD   m_dwType;           // type of entry this section
} FileSection;
typedef FileSection *PFileSection;

// FileLanguageSection -- 1st entry of sequence for an SBCS/DBCS language
//
// Followed by 1 or more histogram sections

typedef struct FileLanguageSection {
    // preceded by struct FileSection
    DWORD   m_dwDetectionType;
    DWORD   m_dwLangID;
    DWORD   m_dwUnicodeRangeID; // Unicode range mapping value for this lang
    DWORD   m_dwRecordCount;    // # of histograms following this record
} FileLanguageSection;
typedef FileLanguageSection *PFileLanguageSection;

// FileHistogramSection -- entry for one histogram (SBCS/DBCS or WCHAR)

typedef struct FileHistogramSection {
    // preceded by struct FileSection
    union {
        DWORD   m_dwCodePage;   // for 7 or 8-bit, Codepage this indicates
        DWORD   m_dwRangeID;    // for Unicode, the sublanguage group ID
    };
    DWORD   m_dwDimensionality;
    DWORD   m_dwEdgeSize;
    DWORD   m_dwMappingID;      // ID of Charmap to use
    // HElt m_Elts[]
} FileHistogramSection;
typedef struct FileHistogramSection *PFileHistogramSection;

// FileMapSection -- entry for one character map (SBCS/DBCS or WCHAR)

typedef struct FileMapSection {
    // preceded by struct FileSection
    DWORD   m_dwID;             // ID by which hardwired code finds the table
    DWORD   m_dwSize;           // size of table (256 or 65536)
    DWORD   m_dwNUnique;        // # of unique output values
    // HIdx m_map[]
} FileMapSection;
typedef struct FileMapSection *PFileMapSection;

////////////////////////////////////////////////////////////////

// LangNames - lookup table to get from English-localized names to a Win32
// primary language ID.

struct LangNames {
    LPCSTR          pcszName;
    unsigned short  nLangID;
};
LPCSTR GetLangName (int id);
int GetLangID (LPCSTR pcszName);
extern const struct LangNames LangNames[];

////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mimedb.h ===
#ifndef _MIMEDB_H_
#define _MIMEDB_H_

#define ALLOC_BLOCK             10

typedef struct tagMIMECODEPAGE {
   UINT    uiCodePage;
   LPWSTR  wszHeaderCharset;
   LPWSTR  wszBodyCharset;
   LPWSTR  wszWebCharset;
   UINT    uidFixedWidthFont;  
   UINT    uidProportionalFont;
   UINT    uidDescription;     
   UINT    uiFamilyCodePage;
   DWORD   dwFlags;
} MIMECODEPAGE;

typedef struct tagMIMEREGCHARSET
{
    LPCWSTR szCharset;
    UINT uiCodePage;
    UINT uiInternetEncoding;
    DWORD   dwFlags;
}   MIMECHARSET;

typedef struct tagMIMERFC1766
{
    LCID    LcId;
    LPCWSTR szRfc1766;
    UINT    uidLCID;
    DWORD   dwFlags;
}   MIMERFC1766;


extern MIMECODEPAGE MimeCodePage[];
extern const MIMERFC1766  MimeRfc1766[];
extern const MIMECHARSET  MimeCharSet[];


#ifdef  __cplusplus
//
//  CMimeDatabase declaration without IMimeDatabase Interface
//
class CMimeDatabase     // This would support IMimeDatabase when available
{
    MIMECONTF dwMimeSource;
public:
    // Possible IMimeDatabase methods
    STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    STDMETHODIMP EnumCodePageInfo(void);
    STDMETHODIMP GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCodePageInfoWithIndex(UINT uidx, LANGID LangId, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    STDMETHODIMP ValidateCP(UINT uiCodePage);
    STDMETHODIMP SetMimeDBSource(MIMECONTF dwSource)
    {        
        if ((dwSource != MIMECONTF_MIME_IE4) &&
            (dwSource != MIMECONTF_MIME_LATEST) &&
            (dwSource != MIMECONTF_MIME_REGISTRY))
        {
            return E_INVALIDARG;
        }
        dwMimeSource = dwSource;
        return S_OK;
    }
    CMimeDatabase(void)
    {
        dwMimeSource = MIMECONTF_MIME_LATEST;
    }


protected:
    void FreeMimeDatabase(void);
    BOOL CheckFont(BYTE bGDICharset);


};

//
//  Globals
//
extern CMimeDatabase    *g_pMimeDatabase;
//
//  CMimeDatabase declaration without IMimeDatabase Interface
//

class CMimeDatabaseReg     // This would support IMimeDatabase when available
{
public:
    // Possible IMimeDatabase methods
    STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    STDMETHODIMP EnumCodePageInfo(void);
    STDMETHODIMP GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCodePageInfoWithIndex(UINT uidx, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    STDMETHODIMP ValidateCP(UINT uiCodePage);
    STDMETHODIMP LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength);
    STDMETHODIMP LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar);
    STDMETHODIMP Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766);
    STDMETHODIMP Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766);
    void EnsureRfc1766Table(void);

    // Constructor & Destructor
    CMimeDatabaseReg();
    ~CMimeDatabaseReg();

protected:
    void BuildCodePageMimeDatabase(void);
    void BuildCharsetMimeDatabase(void);
    void FreeMimeDatabase(void);
    int FindCodePageFromCache(UINT uiCodePage);
    BOOL FindCodePageFromRegistry(UINT uiCodePage, MIMECPINFO *pCPInfo);
    int FindCharsetFromCache(BSTR Charset);
    int FindCharsetFromRegistry(BSTR Charset, BOOL fFromAlias);
    BOOL CheckFont(BYTE bGDICharset);
    void QSortCodePageInfo(LONG left, LONG right);
    void QSortCharsetInfo(LONG left, LONG right);
    void BuildRfc1766Table(void);
    void FreeRfc1766Table(void);

    CRITICAL_SECTION _cs;

    BOOL            _fAllCPCached;    
    PMIMECPINFO     _pCodePage;
    UINT            _cCodePage;
    UINT            _cMaxCodePage;
    PMIMECSETINFO   _pCharset;
    UINT            _cCharset;
    UINT            _cMaxCharset;
};

extern CMimeDatabaseReg    *g_pMimeDatabaseReg;

#endif  // __cplusplus


#endif  // _MIMEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlatl.h ===
#ifndef _MLATL_H_
#define _MLATL_H_

#define _ATL_FREE_THREADED
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#endif //_MLATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlang.cpp ===
#include "private.h"
#include "mlmain.h"
#include "cpdetect.h"
#include "codepage.h"

STDAPI CMultiLanguage::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetNumberOfCodePageInfo(pcCodePage);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo)
{

    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCodePageInfo(uiCodePage, GetSystemDefaultLangID(), pcpInfo);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage)
{
        HRESULT hr = S_OK;
        int idx = 0;

        DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetFamilyCodePage called."));

        while(MimeCodePage[idx].uiCodePage)
        {
            if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
                (MimeCodePage[idx].dwFlags & dwMimeSource))
                break;
            idx++;
        }

        if (MimeCodePage[idx].uiCodePage)
        {
            if (MimeCodePage[idx].uiFamilyCodePage)
                *puiFamilyCodePage = MimeCodePage[idx].uiFamilyCodePage;
            else
                *puiFamilyCodePage = uiCodePage;
        }
        else
        {
            hr = E_FAIL;
            *puiFamilyCodePage = 0;
        }
        return hr;
}

STDAPI CMultiLanguage::EnumCodePages(DWORD grfFlags, IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumCodePages called."));
    *ppEnumCodePage = NULL;

    // Return IE4 MIME DB data in IMultiLanguage    
    CEnumCodePage *pCEnumCodePage = new CEnumCodePage(grfFlags, GetSystemDefaultLangID(), MIMECONTF_MIME_IE4);

    if (NULL != pCEnumCodePage)
    {
        HRESULT hr = pCEnumCodePage->QueryInterface(IID_IEnumCodePage, (void**)ppEnumCodePage);
        pCEnumCodePage->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumCodePages(DWORD grfFlags, LANGID LangId, IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumCodePages called."));
    *ppEnumCodePage = NULL;

    CEnumCodePage *pCEnumCodePage = new CEnumCodePage(grfFlags, LangId, dwMimeSource);
    if (NULL != pCEnumCodePage)
    {
        HRESULT hr = pCEnumCodePage->QueryInterface(IID_IEnumCodePage, (void**)ppEnumCodePage);
        pCEnumCodePage->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumScripts(DWORD dwFlags, LANGID LangId, IEnumScript **ppEnumScript)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::EnumScripts called."));
    *ppEnumScript = NULL;

    CEnumScript *pCEnumScript = new CEnumScript(dwFlags, LangId, dwMimeSource);
    if (NULL != pCEnumScript)
    {
        HRESULT hr = pCEnumScript->QueryInterface(IID_IEnumScript, (void**)ppEnumScript);
        pCEnumScript->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCharsetInfo(Charset, pcsetInfo);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::IsConvertINetStringAvailable called."));
    return IsConvertINetStringAvailable(dwSrcEncoding, dwDstEncoding);
}

STDAPI CMultiLanguage::ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringEx called."));
    return ConvertINetString(lpdwMode, dwSrcEncoding, dwDstEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringToUnicode called."));
    return ConvertINetMultiByteToUnicode(lpdwMode, dwEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPWSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringFromUnicode called."));
    return ConvertINetUnicodeToMultiByte(lpdwMode, dwEncoding, (LPCWSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringReset(void)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::Reset called."));
    return ConvertINetReset();
}

STDAPI CMultiLanguage::GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766FromLcid called."));

    if (NULL != pbstrRfc1766)
    {
        WCHAR wsz[MAX_RFC1766_NAME];

        hr = LcidToRfc1766W(Locale, wsz, ARRAYSIZE(wsz));
        if (SUCCEEDED(hr))
            *pbstrRfc1766 = SysAllocString(wsz);
        else
            *pbstrRfc1766 = NULL;
    }
    return hr;
}

STDAPI CMultiLanguage::GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetLcidFromRfc1766 called."));
    return Rfc1766ToLcidW(pLocale, bstrRfc1766);   
}

STDAPI CMultiLanguage::EnumRfc1766(IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumRfc1766 called."));
    *ppEnumRfc1766 = NULL;

    CEnumRfc1766 *pCEnumRfc1766 = new CEnumRfc1766(dwMimeSource,GetSystemDefaultLangID());
    if (NULL != pCEnumRfc1766)
    {
        HRESULT hr = pCEnumRfc1766->QueryInterface(IID_IEnumRfc1766, (void**)ppEnumRfc1766);
        pCEnumRfc1766->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumRfc1766(LANGID LangId, IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumRfc1766 called."));
    *ppEnumRfc1766 = NULL;

    CEnumRfc1766 *pCEnumRfc1766 = new CEnumRfc1766(dwMimeSource, LangId);
    if (NULL != pCEnumRfc1766)
    {
        HRESULT hr = pCEnumRfc1766->QueryInterface(IID_IEnumRfc1766, (void**)ppEnumRfc1766);
        pCEnumRfc1766->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage::GetRfc1766Info(LCID Locale, PRFC1766INFO pRfc1766Info)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766Info called."));


    if (NULL != pRfc1766Info)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            pRfc1766Info->lcid = MimeRfc1766[i].LcId;
            MLStrCpyNW(pRfc1766Info->wszRfc1766, MimeRfc1766[i].szRfc1766, MAX_RFC1766_NAME);
            _LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                 MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDAPI CMultiLanguage2::GetRfc1766Info(LCID Locale, LANGID LangId, PRFC1766INFO pRfc1766Info)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766Info called."));


    if (NULL != pRfc1766Info)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            if (!LangId)
                LangId = GetSystemDefaultLangID();

            pRfc1766Info->lcid = MimeRfc1766[i].LcId;
            MLStrCpyNW(pRfc1766Info->wszRfc1766, MimeRfc1766[i].szRfc1766, MAX_RFC1766_NAME);

            if (!_LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                 MAX_LOCALE_NAME, LangId))
            {
                    _LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                         MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
            }
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDAPI CMultiLanguage::CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset)
{
    HRESULT hr;
    IClassFactory* pClassObj;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::CreateCharsetConvert called."));

    if (SUCCEEDED(hr = _Module.GetClassObject(CLSID_CMLangConvertCharset, IID_IClassFactory, (void**)&pClassObj)))
    {
        hr = pClassObj->CreateInstance(NULL, IID_IMLangConvertCharset, (void**)ppMLangConvertCharset);
        pClassObj->Release();
    }

    if (ppMLangConvertCharset && FAILED(hr))
        *ppMLangConvertCharset = NULL;

    if (NULL != *ppMLangConvertCharset)
        hr = (*ppMLangConvertCharset)->Initialize(uiSrcCodePage, uiDstCodePage, dwProperty);

    return hr;
}

STDAPI CMultiLanguage2::ConvertStringInIStream(LPDWORD lpdwMode, DWORD dwFlag, WCHAR *lpFallBack, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertStringInIStream called."));
    return ConvertINetStringInIStream(lpdwMode,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut,dwFlag,lpFallBack);
}

STDAPI CMultiLanguage2::ConvertStringToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertBufferStringToUnicodeEx called."));
    return ConvertINetMultiByteToUnicodeEx(lpdwMode, dwEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPWSTR)pDstStr, (LPINT)pcDstSize, dwFlag, lpFallBack);
}

STDAPI CMultiLanguage2::ConvertStringFromUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertBufferStringFromUnicodeEx called."));
    return ConvertINetUnicodeToMultiByteEx(lpdwMode, dwEncoding, (LPCWSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize, dwFlag, lpFallBack);
}

STDAPI CMultiLanguage2::DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::DetectCodepageInIStream called. "));
    return _DetectCodepageInIStream(dwFlag, uiPrefWinCodepage, pstmIn, lpEncoding, pnScores);
}

STDAPI CMultiLanguage2::DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::DetectInputCodepage called. "));
    return _DetectInputCodepage(dwFlag, uiPrefWinCodepage, pSrcStr, pcSrcSize, lpEncoding, pnScores);
}

STDAPI CMultiLanguage2::ValidateCodePage(UINT uiCodePage, HWND hwnd)
{
    return ValidateCodePageEx(uiCodePage, hwnd, 0);
}
// this is private function to serve both for IML2 and IML3
STDAPI CMultiLanguage2::ValidateCodePageEx(UINT uiCodePage, HWND hwnd, DWORD dwfIODControl)
{
    MIMECPINFO cpInfo;
    CLSID      clsid;
    UINT       uiFamCp;
    HRESULT    hr;
    
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ValidateCodePage called. "));
    
    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    EnterCriticalSection(&g_cs);
    if (NULL == g_pCpMRU)
        if (g_pCpMRU = new CCpMRU)
            g_pCpMRU->Init();
    LeaveCriticalSection(&g_cs);

    if (g_pCpMRU && g_pCpMRU->dwCpMRUEnable)
        g_pCpMRU->UpdateCPMRU(uiCodePage);

    if (cpInfo.dwFlags & MIMECONTF_VALID)
        return S_OK;

    // always handle family codepage because a caller
    // of this function is not generally aware if
    // the codepage is primary one. i.e., they can
    // call with cp=20268 to validate the entire 1251
    // family.
    //
    uiFamCp = cpInfo.uiFamilyCodePage;

    // Bug 394904, IOD won't be able to get us gb18030 support, 
    // so we won't ask UrlMon for CHS langpack if gb2312 is valid
    if (uiCodePage == CP_18030)
    {
        g_pMimeDatabase->GetCodePageInfo(uiFamCp, 0x409, &cpInfo);

        if (cpInfo.dwFlags & MIMECONTF_VALID)
            return S_FALSE;
    }
    
    // Ignore IOD check on NT5
    if (g_bIsNT5)
    {
        // Currently, NT5 doesn't install 20127 and 28605 NLS files.
        // We should prevent langpack installation loop and let clients resolve 
        // them with CP_ACP in case of 20127 and 28605 validation.
        // This hack can be removed once NT5 bundles these NLS files by default.
        if ((uiCodePage == CP_20127 || uiCodePage == CP_ISO_8859_15) && IsValidCodePage(uiFamCp))
            return E_FAIL;
        hr = IsNTLangpackAvailable(uiFamCp);
        if (hr != S_OK)
            return hr;
    }
    else
    {
        // check if JIT langpack is enabled.
        //
        hr = EnsureIEStatus();
        if (hr == S_OK) 
        {
            if (!m_pIEStat || m_pIEStat->IsJITEnabled() != TRUE)
            {
                // the codepage is neither valid or installable
                return S_FALSE;
            }
        }
    }    

    if (hwnd == NULL)
    {
        hwnd = GetForegroundWindow();   
    }

    // Special handling for NT.
    if (g_bIsNT5)
    {
        DWORD   dwInstallLpk = 1;
        HKEY    hkey;
        DWORD   dwAction = 0;

        // HKCR\\Software\\Microsoft\internet explorer\\international
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_INTERNATIONAL,
                         NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwAction)) 
        {
            DWORD dwType = REG_DWORD;
            DWORD dwSize = sizeof(DWORD);

            if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_NT5LPK, 0, &dwType, (LPBYTE)&dwInstallLpk, &dwSize))
            {
                dwInstallLpk = 1;
                RegSetValueEx(hkey, REG_KEY_NT5LPK, 0, REG_DWORD, (LPBYTE)&dwInstallLpk, sizeof(dwInstallLpk));
            }
            RegCloseKey(hkey);
        }

        hr = S_FALSE;

        // Pops up NT5 langpack dialog box if langpack is enabled or user selects it from encoding menu
        if (dwInstallLpk || (dwfIODControl & CPIOD_FORCE_PROMPT))
        {
            LPCDLGTEMPLATE pTemplate;
            HRSRC   hrsrc;
            INT_PTR iRet;
            LANGID  LangId = GetNT5UILanguage();

            dwInstallLpk |= uiFamCp << 16;

            // Load correct resource to match NT5 UI language
            hrsrc = FindResourceExW(g_hInst, (LPCWSTR) RT_DIALOG, (LPCWSTR) MAKEINTRESOURCE(IDD_DIALOG_LPK), LangId);

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            
            // Pack LPARAM, code page value in HIWORD, installation flag in LOWORD
            if (hrsrc &&
                (pTemplate = (LPCDLGTEMPLATE)LoadResource(g_hInst, hrsrc)))
            {
                iRet = DialogBoxIndirectParamW(g_hInst, pTemplate,
                   hwnd, LangpackDlgProc, (LPARAM) dwInstallLpk);
            }
            else 
                iRet = DialogBoxParamW(g_hInst, (LPCWSTR) MAKEINTRESOURCE(IDD_DIALOG_LPK), hwnd, LangpackDlgProc, (LPARAM) dwInstallLpk); 

            if (iRet)
            {
                hr = _InstallNT5Langpack(hwnd, uiFamCp);
                if (S_OK == hr)
                {                
                    WCHAR wszLangInstall[MAX_PATH];
                    WCHAR wszNT5LangPack[1024];
                    

                    // Fall back to English (US) if we don't have a specific language resource
                    if (!_LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId) ||
                        !_LoadStringExW(g_hInst, IDS_NT5_LANGPACK, wszNT5LangPack, ARRAYSIZE(wszNT5LangPack), LangId))
                    {
                        LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                        _LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId);
                        _LoadStringExW(g_hInst, IDS_NT5_LANGPACK, wszNT5LangPack, ARRAYSIZE(wszNT5LangPack), LangId);
                    }
                
                    MessageBoxW(hwnd, wszNT5LangPack, wszLangInstall, MB_OK);
                }
            }
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }


        goto SKIP_IELANGPACK;
    }

    // Initiate JIT using CLSID give to the langpack
    hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
    if (SUCCEEDED(hr))
    {
        hr = InstallIEFeature(hwnd, &clsid, dwfIODControl);
    }

    // if JIT returns S_OK, we now have everything installed
    // then we'll validate the codepage and add font
    // NOTE: there can be more than codepage to validate here,
    //      for example, PE langpack contains more than one 
    //      NLS file to get greek, cyrillic and Turkish at the
    //      same time.
    if (hr == S_OK)
    {
        hr = _ValidateCPInfo(uiFamCp);
        if (SUCCEEDED(hr))
        {
            _AddFontForCP(uiFamCp);
        }
    }
    
SKIP_IELANGPACK:      
    return hr;
}


// IMultiLanguage2::GetCodePageDescription
//
// Provide native code page description in UNICODE.
// If not resource is vailable for the specified LCID, 
// we'll try the primary language first, then English.
// In this case, we'll return S_FALSE to caller.
STDAPI CMultiLanguage2::GetCodePageDescription(
    UINT uiCodePage,        // Specifies the required code page for description.
    LCID lcid,              // Specifies locale ID for prefered language.
    LPWSTR lpWideCharStr,   // Points to a buffer that receives the code page description.
    int cchWideChar)        // Specifies the size, in wide characters, of the buffer 
                            // pointed by lpWideCharStr.
{
    HRESULT hr = E_FAIL;
    UINT    CountCPId;
    UINT    i = 0, j = 0;

    g_pMimeDatabase->GetNumberOfCodePageInfo(&CountCPId);
    
    if (cchWideChar == 0)
    {
        return E_INVALIDARG;
    }        

    while (i < CountCPId)
    {
        if (MimeCodePage[j].dwFlags & dwMimeSource)
        {
            if ((MimeCodePage[j].uiCodePage == uiCodePage))
            {
                if (_LoadStringExW(g_hInst, MimeCodePage[j].uidDescription, lpWideCharStr,
                            cchWideChar, LANGIDFROMLCID(lcid))) 
                {
                    hr = S_OK;
                }
                else // Resource not find in the specificed language
                {
                        if (_LoadStringExW(g_hInst, MimeCodePage[j].uidDescription, lpWideCharStr,
                            cchWideChar, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)))
                        {
                            hr = S_FALSE;                
                        }
                }
                break;
            }  
            i++;
        }
        j++;
    }
    
    if (i >= CountCPId) // Code page description is not available in MLANG
    {
        hr = E_INVALIDARG;
    }

    return (hr);
}

STDAPI CMultiLanguage2::IsCodePageInstallable(UINT uiCodePage)
{
    MIMECPINFO cpInfo;
    UINT       uiFamCp;
    HRESULT    hr;
    
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::IsCPInstallable called. "));

    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    // if it's already valid, no need to check if it's installable
    if (cpInfo.dwFlags & MIMECONTF_VALID)
    {
        hr = S_OK;
    }
    else
    {        
        uiFamCp = cpInfo.uiFamilyCodePage;

        // it is currently not valid, if NT5, ignore IOD check
        if (g_bIsNT5)
        {
            hr = IsNTLangpackAvailable(uiFamCp);
        }
        else
        {
            // now check to see if the cp can be IOD
            hr = EnsureIEStatus();
        
            // we'll return FALSE if we couldn't get IOD status
            if (hr == S_OK)
            {
                if (!m_pIEStat || !m_pIEStat->IsJITEnabled())
                    hr = S_FALSE;
            }

            // then see if we have langpack for
            // the family codepage
            if (hr == S_OK)
            {
                CLSID      clsid;
                // clsid is just used for place holder
                hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
            }
        }
    }
    return hr;
}

STDAPI CMultiLanguage2::SetMimeDBSource(MIMECONTF dwSource)
{        
        if ((dwSource != MIMECONTF_MIME_IE4) &&
            (dwSource != MIMECONTF_MIME_LATEST) &&
            (dwSource != MIMECONTF_MIME_REGISTRY))
        {
            return E_INVALIDARG;
        }

        if (dwSource & MIMECONTF_MIME_REGISTRY)
        {
            EnterCriticalSection(&g_cs);
            if (!g_pMimeDatabaseReg)
            {
                g_pMimeDatabaseReg = new CMimeDatabaseReg;
            }
            LeaveCriticalSection(&g_cs);
        }

        dwMimeSource = dwSource;
        if (NULL != m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(dwSource);
        return S_OK;
}

CMultiLanguage2::CMultiLanguage2(void)
{
        DllAddRef();
        
        CComCreator< CComPolyObject< CMultiLanguage > >::CreateInstance( NULL, IID_IMultiLanguage, (void **)&m_pIML );

        m_pMimeDatabase = new CMimeDatabase;
        dwMimeSource = MIMECONTF_MIME_LATEST;
        if (m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(MIMECONTF_MIME_LATEST);

        m_pIEStat = NULL;
}

CMultiLanguage2::~CMultiLanguage2(void)
{
        if (m_pIML)
        {
            m_pIML->Release();
            m_pIML = NULL;
        }

        if (m_pMimeDatabase)
        {
            delete m_pMimeDatabase;
        }

        if (m_pIEStat)
        {
            delete m_pIEStat;
        }

        DllRelease();
}

STDAPI CMultiLanguage2::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
        if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)         
        {
            if (NULL != g_pMimeDatabaseReg)
                return g_pMimeDatabaseReg->GetNumberOfCodePageInfo(pcCodePage);
            else
                return E_FAIL;
        }    
        else
        {    
            if (NULL != m_pMimeDatabase)
                return m_pMimeDatabase->GetNumberOfCodePageInfo(pcCodePage);
            else
                return E_FAIL;
        }
}

STDAPI CMultiLanguage2::GetNumberOfScripts(UINT *pnScripts)
{
    if (pnScripts)
        *pnScripts = g_cScript;

    return NOERROR;
}


STDAPI CMultiLanguage2::GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo)
{
    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg)
            return g_pMimeDatabaseReg->GetCodePageInfo(uiCodePage, pcpInfo);
        else
            return E_FAIL;
    }
    else
    {
        if (m_pMimeDatabase)
            return m_pMimeDatabase->GetCodePageInfo(uiCodePage, LangId, pcpInfo);
        else
            return E_FAIL;
    }
}

// Optimized for performance
// Skip unecessary resource loading
STDAPI CMultiLanguage2::GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage)
{
        HRESULT hr = S_OK;
        int idx = 0;

        if (puiFamilyCodePage)
            *puiFamilyCodePage = 0;
        else
            return E_INVALIDARG;

        DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::GetFamilyCodePage called."));
        // Keep registry version IE4 implementation
        if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
        {

            if (NULL != g_pMimeDatabaseReg)
            {
                MIMECPINFO cpInfo;
                hr = g_pMimeDatabaseReg->GetCodePageInfo(uiCodePage, &cpInfo);
                if (S_OK == hr)
                    *puiFamilyCodePage = cpInfo.uiFamilyCodePage;
            }
        }
        else
        {
            while(MimeCodePage[idx].uiCodePage)
            {
                if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
                    (MimeCodePage[idx].dwFlags & dwMimeSource))
                    break;
                idx++;
            }

            if (MimeCodePage[idx].uiCodePage)
            {
                if (MimeCodePage[idx].uiFamilyCodePage)
                    *puiFamilyCodePage = MimeCodePage[idx].uiFamilyCodePage;
                else
                    *puiFamilyCodePage = uiCodePage;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        return hr;
}

STDAPI CMultiLanguage2::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg)
            return g_pMimeDatabaseReg->GetCharsetInfo(Charset, pcsetInfo);
        else
            return E_FAIL;
    }

    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCharsetInfo(Charset, pcsetInfo);
    else
        return E_FAIL;
}

//
// System default code page stack
//
// We support following code pages for outbound encoding detection
//      Windows  : 1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 932, 949, 950, 936
//      Unicode  : 65001, 65000, 1200
//      ISO      : 28591, 28592, 20866, 21866, 28595, 28597, 28593, 28594, 28596, 28598, 38598, 28605, 28599
//      Others   : 20127, 50220, 50221, 50222, 51932, 51949, 50225, 52936
//
// Default priorities
//       20127 > Windows single byte code page> ISO > Windows DBCS code page > Others > Unicode
//
UINT SysPreCp[] = 
    {20127, 
    1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 
    28591, 28592, 20866, 21866, 28595, 28597, 28593, 28594, 28596, 28598, 38598, 28605, 28599,
    932, 949, 950, 936,
    50220, 50221, 50222, 51932, 51949, 50225, 52936, 
    65001, 65000, 1200 };
            
//
// IMultiLanguage3
// Outbound encoding detection for plain Unicode text encoding detection
// We ride on CMultiLanguage2 class to implement this funciton
//
STDAPI CMultiLanguage2::DetectOutboundCodePage(
            DWORD   dwFlags,                // Flags control our behaviour
            LPCWSTR lpWideCharStr,          // Source Unicode string
            UINT    cchWideChar,            // Source Unicode character size
            UINT*   puiPreferredCodePages,  // Preferred code page array  
            UINT    nPreferredCodePages,    // Number of preferred code pages
            UINT*   puiDetectedCodePages,   // Detected code page arrayNumber of detected code pages
            UINT*   pnDetectedCodePages,    // [in] Maxium number of code pages we can return
                                            // [out] Num of detected code pages
            WCHAR*  lpSpecialChar           // Optional NULL terminated Unicode string for client specified special chars
            )
{
    DWORD dwCodePages = 0, dwCodePagesExt = 0;
    LONG lNum1 = 0, lNum2 = 0;
    HRESULT hr = E_FAIL;
    UINT ui;
    DWORD dwStrFlags;
    LPWSTR lpwszTmp = NULL;

    // Parameter checks
    if (!cchWideChar || !lpWideCharStr || !puiDetectedCodePages || !*pnDetectedCodePages)
        return E_INVALIDARG;

    // We need extra buffer to perform best fit char filtering
    if (dwFlags & MLDETECTF_FILTER_SPECIALCHAR)
        lpwszTmp = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cchWideChar);

    // String sniffing for CJK, HINDI and BESTFIT
    dwStrFlags = OutBoundDetectPreScan((WCHAR *)lpWideCharStr, cchWideChar, lpwszTmp, lpSpecialChar);

    hr = GetStrCodePagesEx(lpwszTmp? lpwszTmp:lpWideCharStr, cchWideChar, 0, &dwCodePages, &lNum1, CPBITS_WINDOWS|CPBITS_STRICT);
    if (SUCCEEDED(hr))
        hr = GetStrCodePagesEx(lpwszTmp? lpwszTmp:lpWideCharStr, cchWideChar, 0, &dwCodePagesExt,&lNum2, CPBITS_EXTENDED|CPBITS_STRICT);

    // Clear bits if it is not a complete pass
    if ((UINT)lNum1 != cchWideChar)
        dwCodePages = 0;

    if ((UINT)lNum2 != cchWideChar)
        dwCodePagesExt = 0;

    if (lpwszTmp)
        LocalFree(lpwszTmp);

    // If Hindi, we don't return any non-Unicode code pages since there is no offical ones 
    // and we don't recomment client to render Hindi text in ANSI
    if (dwStrFlags & (FS_HINDI|FS_PUA))
    {
        dwCodePages = 0;
        dwCodePagesExt = 0;
    }    

    dwCodePagesExt |= FS_MLANG_65001;
    dwCodePagesExt |= FS_MLANG_65000;
    dwCodePagesExt |= FS_MLANG_1200;

    if (dwCodePagesExt & FS_MLANG_28598)
        dwCodePagesExt |= FS_MLANG_38598;
    if (dwCodePagesExt & FS_MLANG_50220)
        dwCodePagesExt |= FS_MLANG_50221|FS_MLANG_50222;


    if (SUCCEEDED(hr))
    {    
        DWORD dwTempCodePages;
        DWORD dwTempCodePages2;
        UINT nCp = 0;

        // Pick preferred code pages first
        if (nPreferredCodePages && puiPreferredCodePages)
        for (ui=0; nCp<*pnDetectedCodePages && (dwCodePages | dwCodePagesExt) && ui<nPreferredCodePages; ui++)
        {
            if (S_OK == CodePageToCodePagesEx(puiPreferredCodePages[ui], &dwTempCodePages, &dwTempCodePages2))
            {
                if (dwTempCodePages & dwCodePages)
                {
                    puiDetectedCodePages[nCp] = puiPreferredCodePages[ui];
                    dwCodePages &= ~dwTempCodePages;
                    nCp++;

                }
                else if (dwTempCodePages2 & dwCodePagesExt)
                {
                    puiDetectedCodePages[nCp] = puiPreferredCodePages[ui];
                    dwCodePagesExt &= ~dwTempCodePages2;
                    nCp++;
                }
            }
        }

        // Fill in non-preferred code pages if we still have space in destination buffer
        if (!((dwFlags & MLDETECTF_PREFERRED_ONLY) && nPreferredCodePages && puiPreferredCodePages))
        {
            for (ui=0; nCp<*pnDetectedCodePages && (dwCodePages | dwCodePagesExt) && ui < sizeof(SysPreCp)/sizeof(UINT); ui++)
            {
                if (S_OK == CodePageToCodePagesEx(SysPreCp[ui], &dwTempCodePages, &dwTempCodePages2))
                {
                    if (dwTempCodePages & dwCodePages)
                    {
                        puiDetectedCodePages[nCp] = SysPreCp[ui];
                        dwCodePages &= ~dwTempCodePages;
                        nCp++;

                    }
                    else if (dwTempCodePages2 & dwCodePagesExt)
                    {
                        puiDetectedCodePages[nCp] = SysPreCp[ui];
                        dwCodePagesExt &= ~dwTempCodePages2;
                        nCp++;
                    }
                }
            }
        }

        
        // Smart adjustment for DBCS
        // If string doesn't contains CJK characters, we bump up UTF8
        if (!(dwFlags & MLDETECTF_PRESERVE_ORDER) && !(dwStrFlags & FS_CJK) && (puiDetectedCodePages[0] == 932||
            puiDetectedCodePages[0] == 936||puiDetectedCodePages[0] == 950||puiDetectedCodePages[0] == 949))
        {
            for (ui = 1; ui < nCp; ui++)
            {
                if (puiDetectedCodePages[ui] == 65001) //Swap
                {
                    MoveMemory((LPVOID)(puiDetectedCodePages+1), (LPVOID)(puiDetectedCodePages), ui*sizeof(UINT));
                    puiDetectedCodePages[0] = 65001;
                    break;
                }
            }
        }

        // Check validation
        if (dwFlags & MLDETECTF_VALID || dwFlags & MLDETECTF_VALID_NLS)
        {
            MIMECPINFO cpInfo;
            UINT * puiBuffer = puiDetectedCodePages;

            if (!g_pMimeDatabase)
                BuildGlobalObjects();

            if (g_pMimeDatabase)
            {
                for (ui = 0; ui < nCp; ui++)
                {
                    if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(puiDetectedCodePages[ui], 0x0409, &cpInfo)))
                    {
                        if ((cpInfo.dwFlags & MIMECONTF_VALID)  || 
                            ((cpInfo.dwFlags & MIMECONTF_VALID_NLS) && (dwFlags & MLDETECTF_VALID_NLS)))
                        {
                            // In place adjustment
                            *puiBuffer = puiDetectedCodePages[ui];
                            puiBuffer++;
                        }
                    }
                }
                nCp =(UINT) (puiBuffer-puiDetectedCodePages);                
            }
        }

        // Be nice, clean up detection buffer for client
        if (nCp < *pnDetectedCodePages)
            ZeroMemory(&puiDetectedCodePages[nCp], *pnDetectedCodePages-nCp);

        *pnDetectedCodePages = nCp;
    }

    return hr;
    
}

// IStream object
STDAPI CMultiLanguage2::DetectOutboundCodePageInIStream(
            DWORD        dwFlags,                // Detection flags
            IStream*     pStmIn,                 // IStream object pointer
            UINT*        puiPreferredCodePages,  // Preferred code page array  
            UINT         nPreferredCodePages,    // Num of preferred code pages
            UINT*        puiDetectedCodePages,   // Buffer for detection result
            UINT*        pnDetectedCodePages,    // [in] Maxium number of code pages we can return
                                                 // [out] Num of detected code pages
            WCHAR*       lpSpecialChar           // Optional NULL terminated Unicode string for client specified special chars
            )                               

{
    HRESULT hr;
    LARGE_INTEGER  libOrigin = { 0, 0 };
    ULARGE_INTEGER ulPos = {0, 0};
    ULONG   ulSrcSize;
    CHAR    *pStr;    

    // Get buffer size
    hr = pStmIn->Seek(libOrigin, STREAM_SEEK_END,&ulPos);

    if (SUCCEEDED(hr))
    {
        ulSrcSize = ulPos.LowPart ;
        if (pStr=(char *)LocalAlloc(LPTR, ulSrcSize))
        {
            // Reset the pointer
            hr = pStmIn->Seek(libOrigin, STREAM_SEEK_SET, NULL);
            if (S_OK == hr)
            {
                hr = pStmIn->Read(pStr, ulSrcSize, &ulSrcSize);
                if (S_OK == hr)
                    hr = DetectOutboundCodePage(dwFlags, (LPCWSTR)pStr, ulSrcSize/sizeof(WCHAR), puiPreferredCodePages, 
                                                nPreferredCodePages, puiDetectedCodePages, pnDetectedCodePages, lpSpecialChar);
            }
            LocalFree(pStr);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mllbcons.cpp ===
// MLLBCons.cpp : Implementation of CMLLBCons
#include "private.h"
#include "mllbcons.h"
#ifdef ASTRIMPL
#include "mlswalk.h"
#endif
#include "mlstrbuf.h"

/////////////////////////////////////////////////////////////////////////////
// Line Break Character Table

const WCHAR awchNonBreakingAtLineEnd[] = {
    0x0028, // LEFT PARENTHESIS
    0x005B, // LEFT SQUARE BRACKET
    0x007B, // LEFT CURLY BRACKET
    0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x2018, // LEFT SINGLE QUOTATION MARK
    0x201C, // LEFT DOUBLE QUOTATION MARK
    0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x2045, // LEFT SQUARE BRACKET WITH QUILL
    0x207D, // SUPERSCRIPT LEFT PARENTHESIS
    0x208D, // SUBSCRIPT LEFT PARENTHESIS
    0x226A, // MUCH LESS THAN
    0x3008, // LEFT ANGLE BRACKET
    0x300A, // LEFT DOUBLE ANGLE BRACKET
    0x300C, // LEFT CORNER BRACKET
    0x300E, // LEFT WHITE CORNER BRACKET
    0x3010, // LEFT BLACK LENTICULAR BRACKET
    0x3014, // LEFT TORTOISE SHELL BRACKET
    0x3016, // LEFT WHITE LENTICULAR BRACKET
    0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
    0x301A, // LEFT WHITE SQUARE BRACKET
    0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
    0xFD3E, // ORNATE LEFT PARENTHESIS
    0xFE35, // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    0xFE37, // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    0xFE39, // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
    0xFE3B, // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
    0xFE3D, // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
    0xFE3F, // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
    0xFE41, // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    0xFE43, // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
    0xFE59, // SMALL LEFT PARENTHESIS
    0xFE5B, // SMALL LEFT CURLY BRACKET
    0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
    0xFF08, // FULLWIDTH LEFT PARENTHESIS
    0xFF1C, // FULLWIDTH LESS-THAN SIGN
    0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
    0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
    0xFF62, // HALFWIDTH LEFT CORNER BRACKET
    0xFFE9  // HALFWIDTH LEFTWARDS ARROW
};

const WCHAR awchNonBreakingAtLineStart[] = {
    0x0029, // RIGHT PARENTHESIS
    0x002D, // HYPHEN
    0x005D, // RIGHT SQUARE BRACKET
    0x007D, // RIGHT CURLY BRACKET
    0x00AD, // OPTIONAL HYPHEN
    0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x02C7, // CARON
    0x02C9, // MODIFIER LETTER MACRON
    0x055D, // ARMENIAN COMMA
    0x060C, // ARABIC COMMA
    0x2013, // EN DASH
    0x2014, // EM DASH
    0x2016, // DOUBLE VERTICAL LINE
    0x201D, // RIGHT DOUBLE QUOTATION MARK
    0x2022, // BULLET
    0x2025, // TWO DOT LEADER
    0x2026, // HORIZONTAL ELLIPSIS
    0x2027, // HYPHENATION POINT
    0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x2046, // RIGHT SQUARE BRACKET WITH QUILL
    0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
    0x208E, // SUBSCRIPT RIGHT PARENTHESIS
    0x226B, // MUCH GREATER THAN
    0x2574, // BOX DRAWINGS LIGHT LEFT
    0x3001, // IDEOGRAPHIC COMMA
    0x3002, // IDEOGRAPHIC FULL STOP
    0x3003, // DITTO MARK
    0x3005, // IDEOGRAPHIC ITERATION MARK
    0x3009, // RIGHT ANGLE BRACKET
    0x300B, // RIGHT DOUBLE ANGLE BRACKET
    0x300D, // RIGHT CORNER BRACKET
    0x300F, // RIGHT WHITE CORNER BRACKET
    0x3011, // RIGHT BLACK LENTICULAR BRACKET
    0x3015, // RIGHT TORTOISE SHELL BRACKET
    0x3017, // RIGHT WHITE LENTICULAR BRACKET
    0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
    0x301B, // RIGHT WHITE SQUARE BRACKET
    0x301E, // DOUBLE PRIME QUOTATION MARK
    0x3041, // HIRAGANA LETTER SMALL A
    0x3043, // HIRAGANA LETTER SMALL I
    0x3045, // HIRAGANA LETTER SMALL U
    0x3047, // HIRAGANA LETTER SMALL E
    0x3049, // HIRAGANA LETTER SMALL O
    0x3063, // HIRAGANA LETTER SMALL TU
    0x3083, // HIRAGANA LETTER SMALL YA
    0x3085, // HIRAGANA LETTER SMALL YU
    0x3087, // HIRAGANA LETTER SMALL YO
    0x308E, // HIRAGANA LETTER SMALL WA
    0x309B, // KATAKANA-HIRAGANA VOICED SOUND MARK
    0x309C, // KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
    0x309D, // HIRAGANA ITERATION MARK
    0x309E, // HIRAGANA VOICED ITERATION MARK
    0x30A1, // KATAKANA LETTER SMALL A
    0x30A3, // KATAKANA LETTER SMALL I
    0x30A5, // KATAKANA LETTER SMALL U
    0x30A7, // KATAKANA LETTER SMALL E
    0x30A9, // KATAKANA LETTER SMALL O
    0x30C3, // KATAKANA LETTER SMALL TU
    0x30E3, // KATAKANA LETTER SMALL YA
    0x30E5, // KATAKANA LETTER SMALL YU
    0x30E7, // KATAKANA LETTER SMALL YO
    0x30EE, // KATAKANA LETTER SMALL WA
    0x30F5, // KATAKANA LETTER SMALL KA
    0x30F6, // KATAKANA LETTER SMALL KE
    0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0x30FD, // KATAKANA ITERATION MARK
    0x30FE, // KATAKANA VOICED ITERATION MARK
    0xFD3F, // ORNATE RIGHT PARENTHESIS
    0xFE30, // VERTICAL TWO DOT LEADER
    0xFE31, // VERTICAL EM DASH
    0xFE33, // VERTICAL LOW LINE
    0xFE34, // VERTICAL WAVY LOW LINE
    0xFE36, // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    0xFE38, // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    0xFE3A, // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
    0xFE3C, // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
    0xFE3E, // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
    0xFE40, // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    0xFE42, // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
    0xFE44, // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
    0xFE4F, // WAVY LOW LINE
    0xFE50, // SMALL COMMA
    0xFE51, // SMALL IDEOGRAPHIC COMMA
    0xFE5A, // SMALL RIGHT PARENTHESIS
    0xFE5C, // SMALL RIGHT CURLY BRACKET
    0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
    0xFF09, // FULLWIDTH RIGHT PARENTHESIS
    0xFF0C, // FULLWIDTH COMMA
    0xFF0E, // FULLWIDTH FULL STOP
    0xFF1E, // FULLWIDTH GREATER-THAN SIGN
    0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
    0xFF40, // FULLWIDTH GRAVE ACCENT
    0xFF5C, // FULLWIDTH VERTICAL LINE
    0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
    0xFF5E, // FULLWIDTH TILDE
    0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
    0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
    0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA
    0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
    0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
    0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
    0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
    0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
    0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
    0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
    0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
    0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
    0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0xFF9E, // HALFWIDTH KATAKANA VOICED SOUND MARK
    0xFF9F, // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
    0xFFEB  // HALFWIDTH RIGHTWARDS ARROW
};

const WCHAR awchRomanInterWordSpace[] = {
    0x0009, // TAB
    0x0020, // SPACE
    0x2002, // EN SPACE
    0x2003, // EM SPACE
    0x2004, // THREE-PER-EM SPACE
    0x2005, // FOUR-PER-EM SPACE
    0x2006, // SIX-PER-EM SPACE
    0x2007, // FIGURE SPACE
    0x2008, // PUNCTUATION SPACE
    0x2009, // THIN SPACE
    0x200A, // HAIR SPACE
    0x200B  // ZERO WIDTH SPACE
};

BOOL ScanWChar(const WCHAR awch[], int nArraySize, WCHAR wch)
{
    int iMin = 0;
    int iMax = nArraySize - 1;

    while (iMax - iMin >= 2)
    {
        int iTry = (iMax + iMin + 1) / 2;
        if (wch < awch[iTry])
            iMax = iTry;
        else if  (wch > awch[iTry])
            iMin = iTry;
        else
            return TRUE;
    }

    return (wch == awch[iMin] || wch == awch[iMax]);
}

#ifdef MLLBCONS_DEBUG
void TestTable(const WCHAR awch[], int nArraySize)
{
    int nDummy;

    for (int i = 0; i < nArraySize - 1; i++)
    {
        if (awch[i] >= awch[i + 1])
            nDummy = 0;
    }

    int cFound = 0;
    for (int n = 0; n < 0x10000; n++)
    {
        if (ScanWChar(awch, nArraySize, n))
        {
            cFound++;
            for (i = 0; i < nArraySize; i++)
            {
                if (awch[i] == n)
                    break;
            }
            ASSERT(i < nArraySize);
        }
    }
    ASSERT(cFound == nArraySize);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLLBCons

STDMETHODIMP CMLLBCons::BreakLineML(IMLangString* pSrcMLStr, long lSrcPos, long lSrcLen, long cMinColumns, long cMaxColumns, long* plLineLen, long* plSkipLen)
{
#ifdef MLLBCONS_DEBUG
    TestTable(awchNonBreakingAtLineEnd, ARRAYSIZE(awchNonBreakingAtLineEnd));
    TestTable(awchNonBreakingAtLineStart, ARRAYSIZE(awchNonBreakingAtLineStart));
    TestTable(awchRomanInterWordSpace, ARRAYSIZE(awchRomanInterWordSpace));
#endif
    ASSERT_THIS;
    ASSERT_READ_PTR(pSrcMLStr);
    ASSERT_WRITE_PTR_OR_NULL(plLineLen);
    ASSERT_WRITE_PTR_OR_NULL(plSkipLen);

    HRESULT hr;
    IMLangStringWStr* pMLStrWStr;
    long lStrLen;
    long lBreakPos = -1; // Break at default position(cMaxColumns)
    long lSkipLen = 0;
    long lPrevBreakPos = 0;
    long lPrevSkipLen = 0;

    if (SUCCEEDED(hr = pSrcMLStr->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrWStr)) &&
        SUCCEEDED(hr = pSrcMLStr->GetLength(&lStrLen)) &&
        SUCCEEDED(hr = ::RegularizePosLen(lStrLen, &lSrcPos, &lSrcLen)))
    {
        long cColumns = 0;
#ifndef ASTRIMPL
        long lSrcPosTemp = lSrcPos;
        long lSrcLenTemp = lSrcLen;
#endif
        long lCandPos = 0;
        struct {
            unsigned fDone : 1;
            unsigned fInSpaces : 1;
            unsigned fFEChar : 1;
            unsigned fInFEChar : 1;
            unsigned fBreakByEndOfLine : 1;
            unsigned fNonBreakNext : 1;
            unsigned fHaveCandPos : 1;
            unsigned fSlashR : 1;
        } Flags = {0, 0, 0, 0, 0, 0, 0, 0};
#ifdef ASTRIMPL
        CCharType<CT_CTYPE3, 128> ct3;
        CMLStrWalkW StrWalk(pMLStrWStr, lSrcPos, lSrcLen);
#else

        LCID locale;
        hr = pMLStrWStr->GetLocale(0, -1, &locale, NULL, NULL);
        CCharType<CT_CTYPE3, 128> ct3(locale);
#endif


#ifdef ASTRIMPL
        while (StrWalk.Lock(hr))
        {
                ct3.Flush();

                for (int iCh = 0; iCh < StrWalk.GetCCh(); iCh++)
                {
                    const WCHAR wch = StrWalk.GetStr()[iCh];
                    const WORD wCharType3 = ct3.GetCharType(pSrcMLStr, StrWalk.GetPos() + iCh, StrWalk.GetLen() - iCh, &hr);
                    if (FAILED(hr))
                        break;
#else
        while (lSrcLenTemp > 0 && SUCCEEDED(hr))
        {
            WCHAR* pszBuf;
            long cchBuf;
            long lLockedLen;

            ct3.Flush();

            if (SUCCEEDED(hr = pMLStrWStr->LockWStr(lSrcPosTemp, lSrcLenTemp, MLSTR_READ, 0, &pszBuf, &cchBuf, &lLockedLen)))
            {
                for (int iCh = 0; iCh < cchBuf; iCh++)
                {
                    const WCHAR wch = pszBuf[iCh];
                    const WORD wCharType3 = ct3.GetCharType(pszBuf + iCh, cchBuf - iCh);
#endif
                    const int nWidth = (wCharType3 & C3_HALFWIDTH) ? 1 : 2;

                    if (wch == L'\r' && !Flags.fSlashR)
                    {
                        Flags.fSlashR = TRUE;
                    }
                    else if (wch == L'\n' || Flags.fSlashR) // End of line
                    {
                        Flags.fDone = TRUE;
                        Flags.fBreakByEndOfLine = TRUE;
                        if (Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = FALSE;
                            lBreakPos = lCandPos;
                            lSkipLen++; // Skip spaces and line break character
                        }
                        else
                        {
#ifdef ASTRIMPL
                            lBreakPos = StrWalk.GetPos() + iCh; // Break at right before the end of line
#else
                            lBreakPos = lSrcPosTemp + iCh; // Break at right before the end of line
#endif
                            if (Flags.fSlashR)
                                lBreakPos--;

                            lSkipLen = 1; // Skip line break character
                        }
                        if (wch == L'\n' && Flags.fSlashR)
                            lSkipLen++;
                        break;
                    }
                    else if (ScanWChar(awchRomanInterWordSpace, ARRAYSIZE(awchRomanInterWordSpace), wch)) // Spaces
                    {
                        if (!Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = TRUE;
#ifdef ASTRIMPL
                            lCandPos = StrWalk.GetPos() + iCh; // Break at right before the spaces
#else
                            lCandPos = lSrcPosTemp + iCh; // Break at right before the spaces
#endif
                            lSkipLen = 0;
                        }
                        Flags.fInSpaces = TRUE;
                        lSkipLen++; // Skip continuous spaces after breaking
                    }
                    else // Other characters
                    {
                        Flags.fFEChar = ((wCharType3 & (C3_KATAKANA | C3_HIRAGANA | C3_FULLWIDTH | C3_IDEOGRAPH)) != 0);

                        if ((Flags.fFEChar || Flags.fInFEChar) && !Flags.fNonBreakNext && !Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = TRUE;
#ifdef ASTRIMPL
                            lCandPos = StrWalk.GetPos() + iCh; // Break at right before or after the FE char
#else
                            lCandPos = lSrcPosTemp + iCh; // Break at right before or after the FE char
#endif
                            lSkipLen = 0;
                        }
                        Flags.fInFEChar = Flags.fFEChar;
                        Flags.fInSpaces = FALSE;

                        if (Flags.fHaveCandPos)
                        {
                            Flags.fHaveCandPos = FALSE;
                            if (!ScanWChar(awchNonBreakingAtLineStart, ARRAYSIZE(awchNonBreakingAtLineStart), wch))
                                lBreakPos = lCandPos;
                        }

                        if (cColumns + nWidth > cMaxColumns)
                        {
                            Flags.fDone = TRUE;
                            if (Flags.fNonBreakNext && lPrevSkipLen)
                            {
                                lBreakPos = lPrevBreakPos;
                                lSkipLen = lPrevSkipLen;
                            }
                            break;
                        }

                        Flags.fNonBreakNext = ScanWChar(awchNonBreakingAtLineEnd, ARRAYSIZE(awchNonBreakingAtLineEnd), wch);
                        
                        if (Flags.fNonBreakNext)
                        {
                            // Need to remember previous break postion in case the line been terminated by the max columns
                            lPrevBreakPos = lBreakPos;
                            lPrevSkipLen = lSkipLen;
                        }
                    }

                    cColumns += nWidth;
                }
#ifdef ASTRIMPL
                StrWalk.Unlock(hr);

                if (Flags.fDone && SUCCEEDED(hr))
                    break;
#else
                HRESULT hrTemp = pMLStrWStr->UnlockWStr(pszBuf, 0, NULL, NULL);
                if (FAILED(hrTemp) && SUCCEEDED(hr))
                    hr = hrTemp;

                if (Flags.fDone && SUCCEEDED(hr))
                    break;

                lSrcPosTemp += lLockedLen;
                lSrcLenTemp -= lLockedLen;
            }
#endif
        }

        pMLStrWStr->Release();

        if (Flags.fHaveCandPos)
            lBreakPos = lCandPos;

        if (SUCCEEDED(hr) && !Flags.fBreakByEndOfLine && lBreakPos - lSrcPos < cMinColumns)
        {
            lBreakPos = min(lSrcLen, cMaxColumns) + lSrcPos; // Default breaking
            lSkipLen = 0;
        }

        if (SUCCEEDED(hr) && !Flags.fDone)
        {
            if (Flags.fInSpaces)
            {
                lBreakPos = lSrcLen - lSkipLen;
            }
            else
            {
                lBreakPos = lSrcLen;
                lSkipLen = 0;
            }
            if (Flags.fSlashR)
            {
                lBreakPos--;
                lSkipLen++;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (plLineLen)
            *plLineLen = lBreakPos - lSrcPos;
        if (plSkipLen)
            *plSkipLen = lSkipLen;
    }
    else
    {
        if (plLineLen)
            *plLineLen = 0;
        if (plSkipLen)
            *plSkipLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLLBCons::BreakLineW(LCID locale, const WCHAR* pszSrc, long cchSrc, long lMaxColumns, long* pcchLine, long* pcchSkip)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchLine);
    ASSERT_WRITE_PTR_OR_NULL(pcchSkip);

    HRESULT hr = S_OK;
    IMLangStringWStr* pMLStrW;

    if (SUCCEEDED(hr = PrepareMLStrClass()) &&
        SUCCEEDED(hr = m_pMLStrClass->CreateInstance(NULL, IID_IMLangStringWStr, (void**)&pMLStrW)))
    {
        CMLStrBufConstStackW StrBuf((LPWSTR)pszSrc, cchSrc);
        long lLineLen;
        long lSkipLen;
    
        hr = pMLStrW->SetStrBufW(0, -1, &StrBuf, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pMLStrW->SetLocale(0, -1, locale);

        if (SUCCEEDED(hr))
            hr = BreakLineML(pMLStrW, 0, -1, 0, lMaxColumns, (pcchLine || pcchSkip) ? &lLineLen : NULL, (pcchSkip) ? &lSkipLen : NULL);

        if (SUCCEEDED(hr) && pcchLine)
            hr = pMLStrW->GetWStr(0, lLineLen, NULL, 0, pcchLine, NULL);

        if (SUCCEEDED(hr) && pcchSkip)
            hr = pMLStrW->GetWStr(lLineLen, lSkipLen, NULL, 0, pcchSkip, NULL);

        pMLStrW->Release();
    }

    if (FAILED(hr))
    {
        if (pcchLine)
            *pcchLine = 0;
        if (pcchSkip)
            *pcchSkip = 0;
    }

    return hr;
}

STDMETHODIMP CMLLBCons::BreakLineA(LCID locale, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long lMaxColumns, long* pcchLine, long* pcchSkip)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchLine);
    ASSERT_WRITE_PTR_OR_NULL(pcchSkip);

    HRESULT hr = S_OK;
    IMLangStringAStr* pMLStrA;

    if (uCodePage == 50000)
        uCodePage = 1252;

    if (SUCCEEDED(hr = PrepareMLStrClass()) &&
        SUCCEEDED(hr = m_pMLStrClass->CreateInstance(NULL, IID_IMLangStringAStr, (void**)&pMLStrA)))
    {
        CMLStrBufConstStackA StrBuf((LPSTR)pszSrc, cchSrc);
        long lLineLen;
        long lSkipLen;
    
        hr = pMLStrA->SetStrBufA(0, -1, uCodePage, &StrBuf, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pMLStrA->SetLocale(0, -1, locale);

        if (SUCCEEDED(hr))
            hr = BreakLineML(pMLStrA, 0, -1, 0, lMaxColumns, (pcchLine || pcchSkip) ? &lLineLen : NULL, (pcchSkip) ? &lSkipLen : NULL);

        if (SUCCEEDED(hr) && pcchLine)
            hr = pMLStrA->GetAStr(0, lLineLen, uCodePage, NULL, NULL, 0, pcchLine, NULL);

        if (SUCCEEDED(hr) && pcchSkip)
            hr = pMLStrA->GetAStr(lLineLen, lSkipLen, uCodePage, NULL, NULL, 0, pcchSkip, NULL);

        pMLStrA->Release();
    }

    if (FAILED(hr))
    {
        if (pcchLine)
            *pcchLine = 0;
        if (pcchSkip)
            *pcchSkip = 0;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlflink.cpp ===
// MLFLink.cpp : Implementation of CMLFLink
#include "private.h"
#include "mlmain.h"
#include "codepage.h"

#ifdef UNIX
inline WORD READWINTELWORD(WORD w)
{
  return ( w << 8 | w >> 8 );
}

inline DWORD READWINTELDWORD(DWORD dw)
{
  return READWINTELWORD( (WORD)(dw >> 16 )) | ((DWORD)READWINTELWORD( dw & 0xffff)) << 16;
}
#else
#define READWINTELWORD
#define READWINTELDWORD
#endif

IMLangFontLink *g_pMLFLink = NULL;

CMLFLink::CCodePagesCache* CMLFLink::m_pCodePagesCache = NULL;
CMLFLink::CFontMappingCache* CMLFLink::m_pFontMappingCache = NULL;
CMLFLink2::CFontMappingCache2* CMLFLink2::m_pFontMappingCache2 = NULL;

// Strings to identify regular font
const char szRegular[]    = "Regular";
const char szNormal[]     = "Normal";

// font table
FONTINFO *g_pfont_table = NULL;

// Unicode range table for non Windows code page code points
// Data is provided by NT international group.
URANGEFONT g_urange_table[] = {
{0x0108, 0x010B, 0},
{0x0114, 0x0115, 0},
{0x011C, 0x011D, 0},
{0x0120, 0x0121, 0},
{0x0124, 0x0125, 0},
{0x0128, 0x0129, 0},
{0x012C, 0x012D, 0},
{0x0134, 0x0135, 0},
{0x014E, 0x014F, 0},
{0x015C, 0x015D, 0},
{0x0168, 0x0169, 0},
{0x016C, 0x016D, 0},
{0x0174, 0x0177, 0},
{0x017F, 0x0191, 0},
{0x0193, 0x019F, 0},
{0x01A2, 0x01AE, 0},
{0x01B1, 0x01CD, 0},
{0x01CF, 0x01CF, 0},
{0x01D1, 0x01D1, 0},
{0x01D3, 0x01D3, 0},
{0x01D5, 0x01D5, 0},
{0x01D7, 0x01D7, 0},
{0x01D9, 0x01D9, 0},
{0x01DB, 0x01DB, 0},
{0x01DD, 0x01F5, 0},
{0x01FA, 0x0217, 0},
{0x0250, 0x0250, 0},
{0x0252, 0x0260, 0},
{0x0262, 0x02A8, 0},
{0x02B0, 0x02C5, 0},
{0x02C8, 0x02C8, 0},
{0x02CC, 0x02CC, 0},
{0x02CE, 0x02CF, 0},
{0x02D1, 0x02D7, 0},
{0x02DE, 0x02DE, 0},
{0x02E0, 0x02E9, 0},
{0x0302, 0x0302, 0},
{0x0304, 0x0308, 0},
{0x030A, 0x0322, 0},
{0x0324, 0x0345, 0},
{0x0360, 0x0361, 0},
{0x0374, 0x0375, 0},
{0x037A, 0x037A, 0},
{0x037E, 0x037E, 0},
{0x0387, 0x0387, 0},
{0x03D0, 0x03D6, 0},
{0x03DA, 0x03DA, 0},
{0x03DC, 0x03DC, 0},
{0x03DE, 0x03DE, 0},
{0x03E0, 0x03E0, 0},
{0x03E2, 0x03F3, 0},
{0x0460, 0x0486, 0},
{0x0492, 0x04C4, 0},
{0x04C7, 0x04C8, 0},
{0x04CB, 0x04CC, 0},
{0x04D0, 0x04EB, 0},
{0x04EE, 0x04F5, 0},
{0x04F8, 0x04F9, 0},
{0x0531, 0x0556, 0},
{0x0559, 0x055F, 0},
{0x0561, 0x0587, 0},
{0x0589, 0x0589, 0},
{0x0591, 0x05A1, 0},
{0x05A3, 0x05AF, 0},
{0x05C4, 0x05C4, 0},
{0x0660, 0x066D, 0},
{0x0670, 0x067D, 0},
{0x067F, 0x0685, 0},
{0x0687, 0x0697, 0},
{0x0699, 0x06AE, 0},
{0x06B0, 0x06B7, 0},
{0x06BA, 0x06BE, 0},
{0x06C0, 0x06CE, 0},
{0x06D0, 0x06ED, 0},
{0x06F0, 0x06F9, 0},
{0x0901, 0x0903, 0},
{0x0905, 0x0939, 0},
{0x093C, 0x094D, 0},
{0x0950, 0x0954, 0},
{0x0958, 0x0970, 0},
{0x0981, 0x0983, 0},
{0x0985, 0x098C, 0},
{0x098F, 0x0990, 0},
{0x0993, 0x09A8, 0},
{0x09AA, 0x09B0, 0},
{0x09B2, 0x09B2, 0},
{0x09B6, 0x09B9, 0},
{0x09BC, 0x09BC, 0},
{0x09BE, 0x09C4, 0},
{0x09C7, 0x09C8, 0},
{0x09CB, 0x09CD, 0},
{0x09D7, 0x09D7, 0},
{0x09DC, 0x09DD, 0},
{0x09DF, 0x09E3, 0},
{0x09E6, 0x09FA, 0},
{0x0A02, 0x0A02, 0},
{0x0A05, 0x0A0A, 0},
{0x0A0F, 0x0A10, 0},
{0x0A13, 0x0A28, 0},
{0x0A2A, 0x0A30, 0},
{0x0A32, 0x0A33, 0},
{0x0A35, 0x0A36, 0},
{0x0A38, 0x0A39, 0},
{0x0A3C, 0x0A3C, 0},
{0x0A3E, 0x0A42, 0},
{0x0A47, 0x0A48, 0},
{0x0A4B, 0x0A4D, 0},
{0x0A59, 0x0A5C, 0},
{0x0A5E, 0x0A5E, 0},
{0x0A66, 0x0A74, 0},
{0x0A81, 0x0A83, 0},
{0x0A85, 0x0A8B, 0},
{0x0A8D, 0x0A8D, 0},
{0x0A8F, 0x0A91, 0},
{0x0A93, 0x0AA8, 0},
{0x0AAA, 0x0AB0, 0},
{0x0AB2, 0x0AB3, 0},
{0x0AB5, 0x0AB9, 0},
{0x0ABC, 0x0AC5, 0},
{0x0AC7, 0x0AC9, 0},
{0x0ACB, 0x0ACD, 0},
{0x0AD0, 0x0AD0, 0},
{0x0AE0, 0x0AE0, 0},
{0x0AE6, 0x0AEF, 0},
{0x0B01, 0x0B03, 0},
{0x0B05, 0x0B0C, 0},
{0x0B0F, 0x0B10, 0},
{0x0B13, 0x0B28, 0},
{0x0B2A, 0x0B30, 0},
{0x0B32, 0x0B33, 0},
{0x0B36, 0x0B39, 0},
{0x0B3C, 0x0B43, 0},
{0x0B47, 0x0B48, 0},
{0x0B4B, 0x0B4D, 0},
{0x0B56, 0x0B57, 0},
{0x0B5C, 0x0B5D, 0},
{0x0B5F, 0x0B61, 0},
{0x0B66, 0x0B70, 0},
{0x0B82, 0x0B83, 0},
{0x0B85, 0x0B8A, 0},
{0x0B8E, 0x0B90, 0},
{0x0B92, 0x0B95, 0},
{0x0B99, 0x0B9A, 0},
{0x0B9C, 0x0B9C, 0},
{0x0B9E, 0x0B9F, 0},
{0x0BA3, 0x0BA4, 0},
{0x0BA8, 0x0BAA, 0},
{0x0BAE, 0x0BB5, 0},
{0x0BB7, 0x0BB9, 0},
{0x0BBE, 0x0BC2, 0},
{0x0BC6, 0x0BC8, 0},
{0x0BCA, 0x0BCD, 0},
{0x0BD7, 0x0BD7, 0},
{0x0BE7, 0x0BF2, 0},
{0x0C01, 0x0C03, 0},
{0x0C05, 0x0C0C, 0},
{0x0C0E, 0x0C10, 0},
{0x0C12, 0x0C28, 0},
{0x0C2A, 0x0C33, 0},
{0x0C35, 0x0C39, 0},
{0x0C3E, 0x0C44, 0},
{0x0C46, 0x0C48, 0},
{0x0C4A, 0x0C4D, 0},
{0x0C55, 0x0C56, 0},
{0x0C60, 0x0C61, 0},
{0x0C66, 0x0C6F, 0},
{0x0C82, 0x0C83, 0},
{0x0C85, 0x0C8C, 0},
{0x0C8E, 0x0C90, 0},
{0x0C92, 0x0CA8, 0},
{0x0CAA, 0x0CB3, 0},
{0x0CB5, 0x0CB9, 0},
{0x0CBE, 0x0CC4, 0},
{0x0CC6, 0x0CC8, 0},
{0x0CCA, 0x0CCD, 0},
{0x0CD5, 0x0CD6, 0},
{0x0CDE, 0x0CDE, 0},
{0x0CE0, 0x0CE1, 0},
{0x0CE6, 0x0CEF, 0},
{0x0D02, 0x0D03, 0},
{0x0D05, 0x0D0C, 0},
{0x0D0E, 0x0D10, 0},
{0x0D12, 0x0D28, 0},
{0x0D2A, 0x0D39, 0},
{0x0D3E, 0x0D43, 0},
{0x0D46, 0x0D48, 0},
{0x0D4A, 0x0D4D, 0},
{0x0D57, 0x0D57, 0},
{0x0D60, 0x0D61, 0},
{0x0D66, 0x0D6F, 0},
{0x0E81, 0x0E82, 0},
{0x0E84, 0x0E84, 0},
{0x0E87, 0x0E88, 0},
{0x0E8A, 0x0E8A, 0},
{0x0E8D, 0x0E8D, 0},
{0x0E94, 0x0E97, 0},
{0x0E99, 0x0E9F, 0},
{0x0EA1, 0x0EA3, 0},
{0x0EA5, 0x0EA5, 0},
{0x0EA7, 0x0EA7, 0},
{0x0EAA, 0x0EAB, 0},
{0x0EAD, 0x0EB9, 0},
{0x0EBB, 0x0EBD, 0},
{0x0EC0, 0x0EC4, 0},
{0x0EC6, 0x0EC6, 0},
{0x0EC8, 0x0ECD, 0},
{0x0ED0, 0x0ED9, 0},
{0x0EDC, 0x0EDD, 0},
{0x0F00, 0x0F47, 0},
{0x0F49, 0x0F69, 0},
{0x0F71, 0x0F8B, 0},
{0x0F90, 0x0F95, 0},
{0x0F97, 0x0F97, 0},
{0x0F99, 0x0FAD, 0},
{0x0FB1, 0x0FB7, 0},
{0x0FB9, 0x0FB9, 0},
{0x10A0, 0x10C5, 0},
{0x10D0, 0x10F6, 0},
{0x10FB, 0x10FB, 0},
{0x1100, 0x1159, 0},
{0x115F, 0x11A2, 0},
{0x11A8, 0x11F9, 0},
{0x1E00, 0x1E9B, 0},
{0x1EA0, 0x1EF9, 0},
{0x1F00, 0x1F15, 0},
{0x1F18, 0x1F1D, 0},
{0x1F20, 0x1F45, 0},
{0x1F48, 0x1F4D, 0},
{0x1F50, 0x1F57, 0},
{0x1F59, 0x1F59, 0},
{0x1F5B, 0x1F5B, 0},
{0x1F5D, 0x1F5D, 0},
{0x1F5F, 0x1F7D, 0},
{0x1F80, 0x1FB4, 0},
{0x1FB6, 0x1FC4, 0},
{0x1FC6, 0x1FD3, 0},
{0x1FD6, 0x1FDB, 0},
{0x1FDD, 0x1FEF, 0},
{0x1FF2, 0x1FF4, 0},
{0x1FF6, 0x1FFE, 0},
{0x2000, 0x200B, 0},
{0x2011, 0x2012, 0},
{0x2017, 0x2017, 0},
{0x201B, 0x201B, 0},
{0x201F, 0x201F, 0},
{0x2023, 0x2024, 0},
{0x2028, 0x202E, 0},
{0x2031, 0x2031, 0},
{0x2034, 0x2034, 0},
{0x2036, 0x2038, 0},
{0x203C, 0x2046, 0},
{0x206A, 0x2070, 0},
{0x2075, 0x207E, 0},
{0x2080, 0x2080, 0},
{0x2085, 0x208E, 0},
{0x20A0, 0x20A9, 0},
{0x20D0, 0x20E1, 0},
{0x2100, 0x2102, 0},
{0x2104, 0x2104, 0},
{0x2106, 0x2108, 0},
{0x210A, 0x2112, 0},
{0x2114, 0x2115, 0},
{0x2117, 0x2120, 0},
{0x2123, 0x2125, 0},
{0x2127, 0x212A, 0},
{0x212C, 0x2138, 0},
{0x2155, 0x215A, 0},
{0x215F, 0x215F, 0},
{0x216C, 0x216F, 0},
{0x217A, 0x2182, 0},
{0x219A, 0x21D1, 0},
{0x21D3, 0x21D3, 0},
{0x21D5, 0x21EA, 0},
{0x2201, 0x2201, 0},
{0x2204, 0x2206, 0},
{0x2209, 0x220A, 0},
{0x220C, 0x220E, 0},
{0x2210, 0x2210, 0},
{0x2212, 0x2214, 0},
{0x2216, 0x2219, 0},
{0x221B, 0x221C, 0},
{0x2221, 0x2222, 0},
{0x2224, 0x2224, 0},
{0x2226, 0x2226, 0},
{0x222D, 0x222D, 0},
{0x222F, 0x2233, 0},
{0x2238, 0x223B, 0},
{0x223E, 0x2247, 0},
{0x2249, 0x224B, 0},
{0x224D, 0x2251, 0},
{0x2253, 0x225F, 0},
{0x2262, 0x2263, 0},
{0x2268, 0x2269, 0},
{0x226C, 0x226D, 0},
{0x2270, 0x2281, 0},
{0x2284, 0x2285, 0},
{0x2288, 0x2294, 0},
{0x2296, 0x2298, 0},
{0x229A, 0x22A4, 0},
{0x22A6, 0x22BE, 0},
{0x22C0, 0x22F1, 0},
{0x2300, 0x2300, 0},
{0x2302, 0x2311, 0},
{0x2313, 0x237A, 0},
{0x2400, 0x2424, 0},
{0x2440, 0x244A, 0},
{0x24B6, 0x24CF, 0},
{0x24EA, 0x24EA, 0},
{0x254C, 0x254F, 0},
{0x2575, 0x2580, 0},
{0x2590, 0x2591, 0},
{0x25A2, 0x25A2, 0},
{0x25AA, 0x25B1, 0},
{0x25B4, 0x25B5, 0},
{0x25B8, 0x25BB, 0},
{0x25BE, 0x25BF, 0},
{0x25C2, 0x25C5, 0},
{0x25C9, 0x25CA, 0},
{0x25CC, 0x25CD, 0},
{0x25D2, 0x25E1, 0},
{0x25E6, 0x25EE, 0},
{0x2600, 0x2604, 0},
{0x2607, 0x2608, 0},
{0x260A, 0x260D, 0},
{0x2610, 0x2613, 0},
{0x261A, 0x261B, 0},
{0x261D, 0x261D, 0},
{0x261F, 0x263F, 0},
{0x2641, 0x2641, 0},
{0x2643, 0x265F, 0},
{0x2662, 0x2662, 0},
{0x2666, 0x2666, 0},
{0x266B, 0x266B, 0},
{0x266E, 0x266E, 0},
{0x2701, 0x2704, 0},
{0x2706, 0x2709, 0},
{0x270C, 0x2727, 0},
{0x2729, 0x274B, 0},
{0x274D, 0x274D, 0},
{0x274F, 0x2752, 0},
{0x2756, 0x2756, 0},
{0x2758, 0x275E, 0},
{0x2761, 0x2767, 0},
{0x2776, 0x2794, 0},
{0x2798, 0x27AF, 0},
{0x27B1, 0x27BE, 0},
{0x3004, 0x3004, 0},
{0x3018, 0x301C, 0},
{0x3020, 0x3020, 0},
{0x302A, 0x3037, 0},
{0x303F, 0x303F, 0},
{0x3094, 0x3094, 0},
{0x3099, 0x309A, 0},
{0x30F7, 0x30FA, 0},
{0x312A, 0x312C, 0},
{0x3190, 0x319F, 0},
{0x322A, 0x3230, 0},
{0x3233, 0x3238, 0},
{0x323A, 0x3243, 0},
{0x3280, 0x32A2, 0},
{0x32A9, 0x32B0, 0},
{0x32C0, 0x32CB, 0},
{0x32D0, 0x32FE, 0},
{0x3300, 0x3302, 0},
{0x3304, 0x330C, 0},
{0x330E, 0x3313, 0},
{0x3315, 0x3317, 0},
{0x3319, 0x3321, 0},
{0x3324, 0x3325, 0},
{0x3328, 0x332A, 0},
{0x332C, 0x3335, 0},
{0x3337, 0x333A, 0},
{0x333C, 0x3348, 0},
{0x334B, 0x334C, 0},
{0x334E, 0x3350, 0},
{0x3352, 0x3356, 0},
{0x3358, 0x3376, 0},
{0x337F, 0x337F, 0},
{0x3385, 0x3387, 0},
{0x33CB, 0x33CC, 0},
{0x33D4, 0x33D4, 0},
{0x33D7, 0x33D7, 0},
{0x33D9, 0x33DA, 0},
{0x33E0, 0x33FE, 0},
{0xFB00, 0xFB06, 0},
{0xFB13, 0xFB17, 0},
{0xFB1E, 0xFB36, 0},
{0xFB38, 0xFB3C, 0},
{0xFB3E, 0xFB3E, 0},
{0xFB40, 0xFB41, 0},
{0xFB43, 0xFB44, 0},
{0xFB46, 0xFBB1, 0},
{0xFBD3, 0xFD3F, 0},
{0xFD50, 0xFD8F, 0},
{0xFD92, 0xFDC7, 0},
{0xFDF0, 0xFDFB, 0},
{0xFE20, 0xFE23, 0},
{0xFE32, 0xFE32, 0},
{0xFE58, 0xFE58, 0},
{0xFE70, 0xFE72, 0},
{0xFE74, 0xFE74, 0},
{0xFE76, 0xFEFC, 0},
{0xFEFF, 0xFEFF, 0},
{0xFFA0, 0xFFBE, 0},
{0xFFC2, 0xFFC7, 0},
{0xFFCA, 0xFFCF, 0},
{0xFFD2, 0xFFD7, 0},
{0xFFDA, 0xFFDC, 0},
{0xFFE8, 0xFFEE, 0},
{0xFFFD, 0xFFFD, 0}
};

const struct {
    int         nCharSet;
    UINT        uCodePage;
    DWORD       dwCodePages;
    SCRIPT_ID   sid[3];
} g_CharSetTransTable[] = 
{
    ANSI_CHARSET,        1252, FS_LATIN1,   sidAsciiLatin,  sidLatin,   sidDefault,  
    EASTEUROPE_CHARSET,  1250, FS_LATIN2,   sidAsciiLatin,  sidLatin,   sidDefault,  
    RUSSIAN_CHARSET,     1251, FS_CYRILLIC, sidCyrillic,    sidDefault, sidDefault,
    GREEK_CHARSET,       1253, FS_GREEK,    sidGreek,       sidDefault, sidDefault,
    TURKISH_CHARSET,     1254, FS_TURKISH,  sidAsciiLatin,  sidLatin,   sidDefault,
    HEBREW_CHARSET,      1255, FS_HEBREW,   sidHebrew,      sidDefault, sidDefault,
    ARABIC_CHARSET,      1256, FS_ARABIC,   sidArabic,      sidDefault, sidDefault,
    BALTIC_CHARSET,      1257, FS_BALTIC,   sidAsciiLatin,  sidLatin,   sidDefault,
    VIETNAMESE_CHARSET,  1258, FS_VIETNAMESE, sidAsciiLatin,  sidLatin, sidDefault,
    THAI_CHARSET,         874, FS_THAI ,    sidThai,        sidDefault, sidDefault,
    SHIFTJIS_CHARSET,     932, FS_JISJAPAN, sidKana,        sidDefault, sidDefault, //sidKana,        sidHan,     sidDefault,
    GB2312_CHARSET,       936, FS_CHINESESIMP,sidHan,       sidDefault, sidDefault, //sidKana,     sidHan,     sidBopomofo,
    HANGEUL_CHARSET,      949, FS_WANSUNG,  sidHangul,      sidDefault, sidDefault, //sidHangul,   sidKana,    sidHan,
    CHINESEBIG5_CHARSET,  950, FS_CHINESETRAD, sidBopomofo, sidDefault, sidDefault, //sidKana,     sidHan,     sidBopomofo,     
    JOHAB_CHARSET,       1361, FS_JOHAB,    sidHangul,     sidDefault, sidDefault,
    DEFAULT_CHARSET,        0, 0,           sidDefault,     sidDefault, sidDefault,
};

//
// Extended code page table
//
const struct {
    int         nCharSet;
    UINT        uCodePage;
    DWORD       dwCodePages;
} g_CharSetTransTableExt[] = 
{
    ANSI_CHARSET,        28591, FS_MLANG_28591,
    EASTEUROPE_CHARSET,  28592, FS_MLANG_28592,
    RUSSIAN_CHARSET,     28595, FS_MLANG_28595,
    GREEK_CHARSET,       28597, FS_MLANG_28597,
    TURKISH_CHARSET,     28593, FS_MLANG_28593,
    HEBREW_CHARSET,      28598, FS_MLANG_28598,
    HEBREW_CHARSET,      38598, FS_MLANG_38598,
    ARABIC_CHARSET,      28596, FS_MLANG_28596,
    BALTIC_CHARSET,      28594, FS_MLANG_28594,
    VIETNAMESE_CHARSET,  28599, FS_MLANG_28599,
    THAI_CHARSET,        28605, FS_MLANG_28605,
    ANSI_CHARSET,        20127, FS_MLANG_20127,
    ANSI_CHARSET,        50220, FS_MLANG_50220,
    ANSI_CHARSET,        51932, FS_MLANG_51932,
    ANSI_CHARSET,        51949, FS_MLANG_51949,
    ANSI_CHARSET,        50225, FS_MLANG_50225,
    ANSI_CHARSET,        52936, FS_MLANG_52936,
    ANSI_CHARSET,        65000, FS_MLANG_65000,
    ANSI_CHARSET,        65001, FS_MLANG_65001,
    ANSI_CHARSET,        1200,  FS_MLANG_1200,
    ANSI_CHARSET,        20866, FS_MLANG_20866,
    ANSI_CHARSET,        21866, FS_MLANG_21866,
    ANSI_CHARSET,        50221, FS_MLANG_50221,
    ANSI_CHARSET,        50222, FS_MLANG_50222,
    DEFAULT_CHARSET,     0,     0, 
};

// Primary chars for scripts
// Pre-sorted by Unicode characters to speed up CMAP search.
const struct {
    WCHAR       wch;    //Can be extended to a character list
    SCRIPT_ID   sid;
} g_wCharToScript[] =
{
        0x0531, sidArmenian,
        0x0710, sidSyriac,
        0x0780, sidThaana,
        0x0905, sidDevanagari,
        0x0985, sidBengali,
        0x0a05, sidGurmukhi,
        0x0a85, sidGujarati,
        0x0b05, sidOriya,
        0x0b85, sidTamil,
        0x0c05, sidTelugu,
        0x0c85, sidKannada,
        0x0d05, sidMalayalam,
        0x0d85, sidSinhala,
        0x0e81, sidLao,
        0x0f40, sidTibetan,
        0x10a0, sidGeorgian,
        0x10d0, sidGeorgian,
        0x1300, sidEthiopic,
        0x1401, sidCanSyllabic,
        0x13a0, sidCherokee,
        0xa000, sidYi,
        0x1680, sidOgham,
        0x16a0, sidRunic,
        0x1700, sidBurmese,
        0x1780, sidKhmer,
        0x2800, sidBraille,
//      0x0020, sidUserDefined
    };

// Script tables ported from Trident
static SCRIPT_ID s_asidUnicodeSubRangeScriptMapping[] =
{
    sidAsciiLatin, sidLatin,      sidLatin,      sidLatin,        // 128-131
    sidLatin,      sidLatin,      0,             sidGreek,        // 132-135
    sidGreek,      sidCyrillic,   sidArmenian,   sidHebrew,       // 136-139
    sidHebrew,     sidArabic,     sidArabic,     sidDevanagari,   // 140-143
    sidBengali,    sidGurmukhi,   sidGujarati,   sidOriya,        // 144-147
    sidTamil,      sidTelugu,     sidKannada,    sidMalayalam,    // 148-151
    sidThai,       sidLao,        sidGeorgian,   sidGeorgian,     // 152-155
    sidHangul,     sidLatin,      sidGreek,      0,               // 156-159
    0,             0,             0,             0,               // 160-163
    0,             0,             0,             0,               // 164-167
    0,             0,             0,             0,               // 168-171
    0,             0,             0,             0,               // 172-175
    sidHan,        sidKana,       sidKana,       sidBopomofo,     // 176-179
    sidHangul,     0,             0,             0,               // 180-183
    sidHangul,     sidHangul,     sidHangul,     sidHan,          // 184-187
    0,             sidHan,        0,             0,               // 188-191
    0,             0,             0,             0,               // 192-195
    0,             0,             sidHangul,     0,               // 196-199
};


// Script table (raw data from MichelSu)
// Rendered by script ID
const SCRIPT ScriptTable[] = 
{

    {sidDefault,    IDS_SIDDEFAULT,     0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 0
    {sidMerge,      IDS_SIDMERGE,       0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 1
    {sidAsciiSym,   IDS_SIDASCIISYM,    0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 2
    {sidAsciiLatin, IDS_SIDASCIILATIN,  1252, 0,      IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 3
    {sidLatin,      IDS_SIDLATIN,       1252, 0,      IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_HIDE},  // 4
    {sidGreek,      IDS_SIDGREEK,       1253, 0x03AC, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 5
    {sidCyrillic,   IDS_SIDCYRILLIC,    1251, 0x0401, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 6
    {sidArmenian,   IDS_SIDARMENIAN,    0,    0x0531, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 7
/**/{sidHebrew,     IDS_SIDHEBREW,      1255, 0x05D4, IDS_FONT_HEBREW_FIXED,  IDS_FONT_HEBREW_PROP, SCRIPTCONTF_SCRIPT_USER},    // 8
    {sidArabic,     IDS_SIDARABIC,      1256, 0x0627, IDS_FONT_ARABIC_FIXED,  IDS_FONT_ARABIC_PROP, SCRIPTCONTF_SCRIPT_USER},    // 9
    {sidDevanagari, IDS_SIDDEVANAGARI,  0,    0x0905, IDS_FONT_DEVANAGARI_FIXED,IDS_FONT_DEVANAGARI_PROP, SCRIPTCONTF_SCRIPT_USER}, // 10
    {sidBengali,    IDS_SIDBENGALI,     0,    0x0985, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 11
    {sidGurmukhi,   IDS_SIDGURMUKHI,    0,    0x0A05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 12
    {sidGujarati,   IDS_SIDGUJARATI,    0,    0x0A85, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 13
    {sidOriya,      IDS_SIDORIYA,       0,    0x0B05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 14
    {sidTamil,      IDS_SIDTAMIL,       0,    0x0B85, IDS_FONT_TAMIL_FIXED, IDS_FONT_TAMIL_PROP, SCRIPTCONTF_SCRIPT_USER},       // 15
    {sidTelugu,     IDS_SIDTELUGU,      0,    0x0C05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 16
    {sidKannada,    IDS_SIDKANNADA,     0,    0x0C85, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 17
    {sidMalayalam,  IDS_SIDMALAYALAM,   0,    0x0D05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 18
    {sidThai,       IDS_SIDTHAI,        874,  0x0E01, IDS_FONT_THAI_FIXED2, IDS_FONT_THAI_PROP2, SCRIPTCONTF_SCRIPT_USER},       // 19
    {sidLao,        IDS_SIDLAO,         0,    0x0E81, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 20
    {sidTibetan,    IDS_SIDTIBETAN,     0,    0x0F40, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 21
    {sidGeorgian,   IDS_SIDGEORGIAN,    0,    0x10D0, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 22
    {sidHangul,     IDS_SIDHANGUL,      949,  0,      IDS_FONT_KOREAN_FIXED,   IDS_FONT_KOREAN_PROP, SCRIPTCONTF_SCRIPT_USER},   // 23
    {sidKana,       IDS_SIDKANA,        932,  0,      IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, SCRIPTCONTF_SCRIPT_USER}, // 24
    {sidBopomofo,   IDS_SIDBOPOMOFO,    950,  0,      IDS_FONT_TAIWAN_FIXED,   IDS_FONT_TAIWAN_PROP, SCRIPTCONTF_SCRIPT_USER},   // 25
    {sidHan,        IDS_SIDHAN,         936,  0,      IDS_FONT_CHINESE_FIXED,  IDS_FONT_CHINESE_PROP, SCRIPTCONTF_SCRIPT_USER},  // 26
    {sidEthiopic,   IDS_SIDETHIOPIC,    0,    0x1300, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 27
    {sidCanSyllabic,IDS_SIDCANSYLLABIC, 0,    0x1401, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 28
    {sidCherokee,   IDS_SIDCHEROKEE,    0,    0x13A0, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 29
    {sidYi,         IDS_SIDYI,          0,    0xA000, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 30
    {sidBraille,    IDS_SIDBRAILLE,     0,    0x2800, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 31
    {sidRunic,      IDS_SIDRUNIC,       0,    0x16A0, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 32
    {sidOgham,      IDS_SIDOGHAM,       0,    0x1680, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 33
    {sidSinhala,    IDS_SIDSINHALA,     0,    0x0D85, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 34
    {sidSyriac,     IDS_SIDSYRIAC,      0,    0x0710, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 35
    {sidBurmese,    IDS_SIDBURMESE,     0,    0x1700, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 36
    {sidKhmer,      IDS_SIDKHMER,       0,    0x1780, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 37
    {sidThaana,     IDS_SIDTHAANA,      0,    0x0780, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 38
    {sidMongolian,  IDS_SIDMONGOLIAN,   0,    0,      0, 0, SCRIPTCONTF_SCRIPT_USER},      // 39
    {sidUserDefined,IDS_SIDUSERDEFINED, 0,    0x0020, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 40
};



UINT g_cScript = ARRAYSIZE(ScriptTable);

/////////////////////////////////////////////////////////////////////////////
// CMLFLink Free Global Objects

void CMLangFontLink_FreeGlobalObjects()
{
    if (g_pMLFLink)
        g_pMLFLink->Release();
    if (CMLFLink::m_pCodePagesCache)
        delete CMLFLink::m_pCodePagesCache;
    if (CMLFLink::m_pFontMappingCache)
        delete CMLFLink::m_pFontMappingCache;
    if (CMLFLink2::m_pFontMappingCache2)
        delete CMLFLink2::m_pFontMappingCache2;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink

CMLFLink::CMLFLink()
{
    DllAddRef();
    EnterCriticalSection(&g_cs);
    if (!m_pCodePagesCache)
        m_pCodePagesCache = new CCodePagesCache;
    if (!m_pFontMappingCache)
        m_pFontMappingCache = new CFontMappingCache;
    LeaveCriticalSection(&g_cs);
    m_pFlinkTable = NULL;
}

STDMETHODIMP CMLFLink::GetCharCodePages(WCHAR chSrc, DWORD* pdwCodePages)
{
    return ::GetCharCodePagesEx(chSrc, pdwCodePages, CPBITS_WINDOWS);
}


/////////////////////////////////////////////////////////////////////////////
// CMLFLink : IMLangCodePages

HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    HRESULT hr = S_OK;
    int nLen;
    int iCmd = 0;
    int nPickOffset;
    int nBitOffset = 0;
    int nBitCount = 32;
    DWORD dwDiff = 0xffffffff;
    DWORD dwOr = 0;
    DWORD dwCodePages;
    DWORD adwBitsMap[32];
    const CCodePagesHeader* pHeader;
    const WORD* pwTable;
    int nBlock;
    int nEndLen;
    const BYTE* pbBlock;
    BYTE *pBuffer = NULL;

    if (!CMLFLink::m_pCodePagesCache)
        CMLFLink::m_pCodePagesCache = new CMLFLink::CCodePagesCache;

    if (CMLFLink::m_pCodePagesCache)
        hr = CMLFLink::m_pCodePagesCache->Load();
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        pBuffer = CMLFLink::m_pCodePagesCache->GetCodePageBits(dwFlags & CPBITS_WINDOWS? FALSE:TRUE);
        pHeader = (CCodePagesHeader*) pBuffer;
        pwTable = (WORD*)(pBuffer + READWINTELDWORD(pHeader->m_dwTableOffset));
        nBlock = chSrc / READWINTELDWORD(pHeader->m_dwBlockSize);
        nEndLen = chSrc % READWINTELDWORD(pHeader->m_dwBlockSize);
        pbBlock = pBuffer + READWINTELWORD(pwTable[nBlock]);
    }

    for (int nDoneLen = 0; SUCCEEDED(hr) && nDoneLen < (int)READWINTELDWORD(pHeader->m_dwBlockSize); nDoneLen += nLen)
    {
        BYTE bCmd = pbBlock[--iCmd];
        if (bCmd < pHeader->m_abCmdCode[1])
        {
            // Flat
            nLen = bCmd + 1;
            nPickOffset = nBitOffset + nBitCount * (nEndLen - nDoneLen);
            nBitOffset += nBitCount * nLen;
        }
        else if (bCmd < pHeader->m_abCmdCode[2])
        {
            // Pack
            nLen = bCmd - pHeader->m_abCmdCode[1] + 2;
            nPickOffset = nBitOffset;
            nBitOffset += nBitCount;
        }
        else if (bCmd < pHeader->m_abCmdCode[4])
        {
            // Diff & Or
            nLen = 0;

            DWORD dw = pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];

            if (bCmd < pHeader->m_abCmdCode[3])
            {
                // Diff
                dwDiff = dw;
                DWORD dwShift = 1;
                nBitCount = 0;
                for (int nBit = 0; nBit < 32; nBit++)
                {
                    if (dwDiff & (1 << nBit))
                    {
                        adwBitsMap[nBit] = dwShift;
                        dwShift <<= 1;
                        nBitCount++;
                    }
                    else
                    {
                        adwBitsMap[nBit] = 0;
                    }
                }
            }
            else
            {
                // Or
                dwOr = dw;
            }
        }
        else
        {
            // Big Pack
            nLen = (bCmd - pHeader->m_abCmdCode[4]) * 0x100 + pbBlock[--iCmd] + pHeader->m_abCmdCode[2] - pHeader->m_abCmdCode[1] + 1 + 1;
            nPickOffset = nBitOffset;
            nBitOffset += nBitCount;
        }

        if (nEndLen < nDoneLen + nLen)
            break;
    }

    if (SUCCEEDED(hr) &&
        nDoneLen < (int)READWINTELDWORD(pHeader->m_dwBlockSize))
    {
        const BYTE* const pbBuf = &pbBlock[nPickOffset / 8];
        DWORD dwCompBits = pbBuf[0] | (DWORD(pbBuf[1]) << 8) | (DWORD(pbBuf[2]) << 16) | (DWORD(pbBuf[3]) << 24);
        dwCompBits >>= nPickOffset % 8;
        if (nBitOffset % 8)
            dwCompBits |= pbBuf[4] << (32 - nBitOffset % 8);

        if (nBitCount < 32)
        {
            dwCompBits &= (1 << nBitCount) - 1;

            dwCodePages = 0;
            for (int nBit = 0; nBit < 32; nBit++)
            {
                if (dwCompBits & adwBitsMap[nBit])
                    dwCodePages |= (1 << nBit);
            }
        }
        else
        {
            dwCodePages = dwCompBits;
        }

        dwCodePages |= dwOr;
    }
    else
    {
        hr = E_FAIL; // Probably Code Pages data is broken.
    }

    if (pdwCodePages)
    {
        if (SUCCEEDED(hr))
        {
            if (dwFlags & CPBITS_WINDOWS)
            {
                // 04/07/00 WEIWU
                // Need to match latest NLS file (Currently W2K RTM) if we're in strict mode for outbound encoding detection
                // For backward compatibilities reasons, we don't want to change our raw Windows CP data.
                // We patch up major differences between Win95/NT4 NLS files and current NLS files here
                // For non-Windows CP data, we'll modify them directly since it doesn't affect text rendering
                if (dwFlags & CPBITS_STRICT)
                {
                    // Add Euro support for 936,950, 949 if we're in strict mode
                    if (chSrc == 0x20AC)
                    {
                        dwCodePages |=  FS_WANSUNG|FS_CHINESESIMP|FS_CHINESETRAD;
                    }
                    else if (chSrc == 0x00AE)
                    {
                        dwCodePages |= FS_WANSUNG;
                    }
                    // Clear K1_HANJA bits if we're in strict mode
                    dwCodePages &= ~FS_MLANG_K1HANJA;
                }
                else
                {
                    // We introduce this new internal charset bit, FS_MLANG_K1HANJA, to support Korean K1 Hanja
                    // K1 Hanja is defined in KSC 5657-1991, it contains non-cp949 DBCS characters
                    // Currenly, Korean fonts shipped with NT5 and Win98 support K1 Hanja glyphs 
                    // and we don't want to switch font to other DBCS fonts in this case.
                    if (dwCodePages & FS_MLANG_K1HANJA)
                    {
                        // Assume Korean font supports K1_HANJA on Win98 and NT5 
                        if (g_bIsNT5 || (g_bIsWin98 && CP_KOR_5601 == g_uACP))
                            dwCodePages |= FS_WANSUNG;
                        dwCodePages &= ~FS_MLANG_K1HANJA;
                    }            

                }
            }
            *pdwCodePages = dwCodePages;
        }
        else
        {
            *pdwCodePages = 0;
        }
    }

    return hr;
}   



HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags)
{
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);
    ASSERT_WRITE_PTR_OR_NULL(pcchCodePages);

    HRESULT hr = S_OK;
    long cchCodePages = 0;
    DWORD dwStrCodePages = (DWORD)~0;
    BOOL fInit = FALSE;
    BOOL fNoPri = FALSE;

    if (!pszSrc || cchSrc <= 0) // We can't make dwStrCodePages when cchSrc is zero
        hr = E_INVALIDARG;

    while (SUCCEEDED(hr) && cchSrc > 0)
    {
        DWORD dwCharCodePages;

        if (SUCCEEDED(hr = GetCharCodePagesEx(*pszSrc, &dwCharCodePages, dwFlags)))
        {
            if (!fInit)
            {
                fInit = TRUE;
                fNoPri = !(dwPriorityCodePages & dwCharCodePages);
            }
            else if (fNoPri != !(dwPriorityCodePages & dwCharCodePages))
            {
                break;
            }
            if (!fNoPri)
                dwPriorityCodePages &= dwCharCodePages;

            if (dwCharCodePages & dwStrCodePages)
                dwStrCodePages &= dwCharCodePages;
            // Don't break if dwCharCodePages is zero and we're not in strict mode
            else if (dwCharCodePages || dwFlags & CPBITS_STRICT) 
                     break;

            pszSrc++;
            cchSrc--;
            cchCodePages++;
        }
    }

    // Codepage bits defines don't take full 32 bits. 
    // If no bits are flipped, we don't have any candidate code pages, we should clear the bits
    if (dwStrCodePages == (DWORD)~0)
        dwStrCodePages = 0;


    if (SUCCEEDED(hr))
    {
        if (pcchCodePages)
            *pcchCodePages = cchCodePages;
        if (pdwCodePages)
            *pdwCodePages = dwStrCodePages;
    }
    else
    {
        if (pcchCodePages)
            *pcchCodePages = 0;
        if (pdwCodePages)
            *pdwCodePages = 0;
    }

    return hr;
}

STDMETHODIMP CMLFLink::GetStrCodePages(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages)
{
    return ::GetStrCodePagesEx(pszSrc, cchSrc, dwPriorityCodePages, pdwCodePages, pcchCodePages, CPBITS_WINDOWS);
}

HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    int iCharSet;

    if (pdwCodePages)
        *pdwCodePages = 0;

    if (pdwCodePagesExt)
        *pdwCodePagesExt = 0;


    for (iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTable[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePages = g_CharSetTransTable[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    for (iCharSet = 0; g_CharSetTransTableExt[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTableExt[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePagesExt = g_CharSetTransTableExt[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    return E_FAIL; // Unknown code page
}

STDMETHODIMP CMLFLink::CodePageToCodePages(UINT uCodePage, DWORD* pdwCodePages)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTable[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePages = g_CharSetTransTable[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    if (pdwCodePages)
        *pdwCodePages = 0;

    return E_FAIL; // Unknown code page
}

STDMETHODIMP CMLFLink::CodePagesToCodePage(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage)
{
    return ::CodePagesToCodePageEx(dwCodePages, uDefaultCodePage, puCodePage, 0);
}

HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt)
{
    ASSERT_WRITE_PTR_OR_NULL(puCodePage);

    HRESULT hr = E_FAIL; // Unknown code pages
    DWORD dwDefaultCodePages;

    if (uDefaultCodePage &&
        SUCCEEDED(hr = CodePageToCodePagesEx(uDefaultCodePage, &dwDefaultCodePages, NULL)) &&
        (dwDefaultCodePages & dwCodePages))
    {
        hr = S_OK;
    }
    else
    {
        if (bCodePagesExt)
        {
            for (int iCharSet = 0; g_CharSetTransTableExt[iCharSet].dwCodePages; iCharSet++)
            {
                if (dwCodePages & g_CharSetTransTableExt[iCharSet].dwCodePages)
                {
                    uDefaultCodePage = g_CharSetTransTableExt[iCharSet].uCodePage;
                    hr = S_OK;
                    break;
                }
            }

        }
        else
        {

            for (int iCharSet = 0; g_CharSetTransTable[iCharSet].dwCodePages; iCharSet++)
            {
                if (dwCodePages & g_CharSetTransTable[iCharSet].dwCodePages)
                {
                    uDefaultCodePage = g_CharSetTransTable[iCharSet].uCodePage;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    if (puCodePage)
    {
        if (SUCCEEDED(hr))
            *puCodePage = uDefaultCodePage;
        else
            *puCodePage = 0;
    }

    return hr;
}


#define REGSTR_PATH_FONTLINK TSZMICROSOFTPATH TEXT("\\Windows NT\\CurrentVersion\\FontLink\\SystemLink")

void CMLFLink::FreeFlinkTable(void)
{
    if (m_pFlinkTable)
    {
        for (UINT i=0; i<m_uiFLinkFontNum; i++)
            if (m_pFlinkTable[i].pmszFaceName)
                LocalFree(m_pFlinkTable[i].pmszFaceName);
        LocalFree(m_pFlinkTable);
        m_pFlinkTable = NULL;
        m_uiFLinkFontNum = 0;
    }
}

#define MAX_FONTLINK_BUFFER_SIZE    1024

HRESULT CMLFLink::CreateNT5FontLinkTable(void)
{
    HKEY    hKey = NULL;
    HKEY    hKeyFont = NULL;
    ULONG   ulFonts = 0;
    ULONG   ulFLinkFonts = 0;
    DWORD   dwIndex = 0;
    WCHAR   szFaceName[LF_FACESIZE];
    LPWSTR  pNewFaceName = NULL;
    DWORD   dwOffset = 0;
    DWORD   dwOffset2 = 0;
    DWORD   dwValue;
    DWORD   dwData;
    WCHAR   szFontFile[LF_FACESIZE];
    DWORD   dwType;
    WCHAR   szFlinkFont[MAX_FONTLINK_BUFFER_SIZE];
    

    // Internal temperate data
    struct tagFontTable
    {
        WCHAR szFontFile[LF_FACESIZE];
        WCHAR szFaceName[LF_FACESIZE];
    }* tmpFontTable = NULL;

    HRESULT hr;

    // Open system font and fontlink key
    if ((ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_FONTLINK, 0, KEY_READ, &hKey)) ||
        (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEYNT, 0, KEY_READ, &hKeyFont)))
    {
        hr = E_FAIL;
        goto TABLE_DONE;
    }


    // Get number of items
    if ((ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, 0, NULL, 
         NULL, NULL, &ulFLinkFonts, NULL, NULL, NULL, NULL) || 0 == ulFLinkFonts) ||            
        (ERROR_SUCCESS != RegQueryInfoKey(hKeyFont, NULL, NULL, 0, NULL, 
            NULL, NULL, &ulFonts, NULL, NULL, NULL, NULL) || 0 == ulFonts))
    {
        hr = E_FAIL;
        goto TABLE_DONE;
    }

    tmpFontTable = (struct tagFontTable *)LocalAlloc(LPTR, sizeof(struct tagFontTable)*ulFonts);

    if (NULL == tmpFontTable)
    {
        hr = E_OUTOFMEMORY;
        goto TABLE_DONE;
    }

    dwValue = dwData = LF_FACESIZE;
    dwType = REG_SZ;
    dwIndex = 0;
    ulFonts = 0;    

    while (ERROR_NO_MORE_ITEMS != RegEnumValueW(
                      hKeyFont,
                      dwIndex++,
                      szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFontFile,
                      &dwData ))
    {
        //  TTF fonts only, TTC fonts already have face name under fontlink
        if (pNewFaceName = wcsstr(szFaceName, L" & "))
            break;
        pNewFaceName = wcsstr(szFaceName, L" (TrueType)");
        if(pNewFaceName)
        {
           *pNewFaceName = 0;
           MLStrCpyNW(tmpFontTable[ulFonts].szFaceName, szFaceName, ARRAYSIZE(tmpFontTable[ulFonts].szFaceName));
           MLStrCpyNW(tmpFontTable[ulFonts].szFontFile, szFontFile, ARRAYSIZE(tmpFontTable[ulFonts].szFontFile));
           ulFonts++;
        }

        dwValue = dwData = LF_FACESIZE;
        dwType = REG_SZ;
    }

    
    m_pFlinkTable = (PFLINKFONT) LocalAlloc(LPTR, sizeof(FLINKFONT)*ulFLinkFonts);
    if (NULL == m_pFlinkTable)
    {
        hr = E_OUTOFMEMORY;
        goto TABLE_DONE;
    }

    dwValue = LF_FACESIZE;
    dwData = MAX_FONTLINK_BUFFER_SIZE;
    dwType = REG_MULTI_SZ;

    dwIndex = 0;

    while (ERROR_NO_MORE_ITEMS != RegEnumValueW(
                      hKey,
                      dwIndex,
                      m_pFlinkTable[dwIndex].szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFlinkFont,
                      &dwData ))
    {
        m_pFlinkTable[dwIndex].pmszFaceName = (LPWSTR) LocalAlloc(LPTR, MAX_FONTLINK_BUFFER_SIZE); 
        if (!m_pFlinkTable[dwIndex].pmszFaceName)
        {
            hr = E_OUTOFMEMORY;
            goto TABLE_DONE;
        }
        while (TRUE)
        {
            pNewFaceName = wcsstr(&szFlinkFont[dwOffset], L",");
            
            if (pNewFaceName)   // TTC font, get face name from registry
            {
                MLStrCpyNW(&(m_pFlinkTable[dwIndex].pmszFaceName[dwOffset2]), ++pNewFaceName, LF_FACESIZE);
                dwOffset2 += lstrlenW(pNewFaceName)+1;
            }
            else                // TTF font, search font table for face name            
            {
                if (szFlinkFont[dwOffset])
                    for (UINT i=0; i<ulFonts; i++)
                    {
                        if (!MLStrCmpNIW(&szFlinkFont[dwOffset], tmpFontTable[i].szFontFile, LF_FACESIZE))
                        {
                            MLStrCpyNW(&(m_pFlinkTable[dwIndex].pmszFaceName[dwOffset2]), tmpFontTable[i].szFaceName, LF_FACESIZE);
                            dwOffset2 += lstrlenW(tmpFontTable[i].szFaceName)+1;
                            break;
                        }
                    }
                else            // End of multiple string, break out                    
                    break;
            }

            dwOffset += lstrlenW(&szFlinkFont[dwOffset])+1;

            // Prevent infinitive loop, shouldn't happen
            if (dwOffset >= MAX_FONTLINK_BUFFER_SIZE) 
            {
                break;
            }
        }

        dwValue = LF_FACESIZE;
        dwData = MAX_FONTLINK_BUFFER_SIZE;
        dwType = REG_MULTI_SZ;
        dwOffset = dwOffset2 = 0;
        dwIndex++;
    }

    m_uiFLinkFontNum = ulFLinkFonts;

    hr = S_OK;

TABLE_DONE:
    if (hKey)
        RegCloseKey(hKey);
    if (hKeyFont)
        RegCloseKey(hKeyFont);
    if (tmpFontTable)
        LocalFree(tmpFontTable);
    if ((hr != S_OK) && m_pFlinkTable)
        FreeFlinkTable();

    return hr;
}


HRESULT CMLFLink::GetNT5FLinkFontCodePages(HDC hDC, LOGFONTW* plfEnum, DWORD * lpdwCodePages)
{
    HRESULT hr = S_OK;
    UINT    i;

    if (!EnumFontFamiliesExW(hDC, plfEnum, GetFontCodePagesEnumFontProcW, (LPARAM)lpdwCodePages, 0))
        return E_FAIL;

    if (NULL == m_pFlinkTable)
        CreateNT5FontLinkTable();

    if (m_pFlinkTable)
    {
        for (i=0; i<m_uiFLinkFontNum;i++)
        {
            if (!MLStrCmpNIW(plfEnum->lfFaceName, m_pFlinkTable[i].szFaceName, LF_FACESIZE))
            {
                DWORD dwOffset=0;
                // Internal buffer, we're sure it'll end
                while(TRUE)
                {
                    MLStrCpyNW(plfEnum->lfFaceName, &m_pFlinkTable[i].pmszFaceName[dwOffset], LF_FACESIZE);
                    EnumFontFamiliesExW(hDC, plfEnum, GetFontCodePagesEnumFontProcW, (LPARAM)lpdwCodePages, 0);
                    dwOffset += lstrlenW(&m_pFlinkTable[i].pmszFaceName[dwOffset])+1;
                    // End of multiple string ?
                    if (m_pFlinkTable[i].pmszFaceName[dwOffset] == 0)
                        break;                        
                }
                break;
            }
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMLFLink : IMLangFontLink
// 1/29/99 - Change HR return
//        Now, we always return S_OK unless system error, caller will
//        check code pages bits in dwCodePages for font code page coverage
STDMETHODIMP CMLFLink::GetFontCodePages(HDC hDC, HFONT hFont, DWORD* pdwCodePages)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    HRESULT hr = S_OK;
    LOGFONT lfFont;
    DWORD dwCodePages = 0;


    if (!::GetObject(hFont, sizeof(lfFont), &lfFont))
        hr = E_FAIL; // Invalid hFont

    if (SUCCEEDED(hr))
    {
        LOGFONT lfEnum;

        // Enumerates all character sets of given font's facename
        // Then, combines them in dwCodePages

        ::memset(&lfEnum, 0, sizeof(lfEnum));
        lfEnum.lfCharSet = DEFAULT_CHARSET;
        //
        //Security, strsafe
        //
        _tcsncpy(lfEnum.lfFaceName, lfFont.lfFaceName, ARRAYSIZE(lfEnum.lfFaceName));


        if (g_bIsNT5)
        {
            LOGFONTW lfEnumW = {0};
            lfEnumW.lfCharSet = DEFAULT_CHARSET;

            if (MultiByteToWideChar(g_uACP, 0, lfFont.lfFaceName, LF_FACESIZE, lfEnumW.lfFaceName, LF_FACESIZE))
                hr = GetNT5FLinkFontCodePages(hDC, &lfEnumW, &dwCodePages);
            else
                if (!::EnumFontFamiliesEx(hDC, &lfEnum, GetFontCodePagesEnumFontProc, (LPARAM)&dwCodePages, 0))
                    hr = E_FAIL; // Invalid hDC

        }
        else
        {
            if (!::EnumFontFamiliesEx(hDC, &lfEnum, GetFontCodePagesEnumFontProc, (LPARAM)&dwCodePages, 0))
                hr = E_FAIL; // Invalid hDC
        }

    }

//############################
//######  MingLiU HACK  ######
//## Fix the bogus font !!! ##
//############################
    if (SUCCEEDED(hr) && ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfFont.lfFaceName, -1, _T("MingLiU"), -1) == 2)
    {
        dwCodePages &= ~FS_LATIN1; // Actually it doesn't have the characters of ANSI_CHARSET.
    }
//############################

// We should use following logic to replace above hack code 
// But, there is another DBCS<->Western font size mapping issue, we should disable this code until that issue is resolved,
#if 0

    // If font claims FE and 1252 and 1250, believe it can do 1252.
    // If font claims FE and 1252 and not 1250, don't believe it can do 1252.
    // This lets full Unicode fonts pass but blocks bad FE fonts.
    if (SUCCEEDED(hr) && (dwCodePages & (FS_JISJAPAN|FS_CHINESESIMP|FS_WANSUNG|FS_CHINESETRAD)) && (dwCodePages & FS_LATIN1) && !(dwCodePages & FS_LATIN2))
    {
        dwCodePages &= ~FS_LATIN1;
    }
#endif

#ifdef UNICODE
#define PRC_DEFAULT_GUI_FONT L"\x5b8b\x4f53"
#else
#define PRC_DEFAULT_GUI_FONT "\xcb\xce\xcc\xe5"
#endif

    // PRC Win95 DEFAULT_GUI_FONT HACK !!!
    if (SUCCEEDED(hr) && lfFont.lfCharSet == ANSI_CHARSET && ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfFont.lfFaceName, -1, PRC_DEFAULT_GUI_FONT, -1) == 2)
    {
        dwCodePages &= ~FS_CHINESESIMP; // Actually it doesn't have the characters of GB2321_CHARSET.
    }

    if (pdwCodePages)
    {
        if (SUCCEEDED(hr))
            *pdwCodePages = dwCodePages;
        else
            *pdwCodePages = 0;
    }

    return hr;
}

int CALLBACK CMLFLink::GetFontCodePagesEnumFontProc(const LOGFONT* plf, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{
    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].nCharSet != DEFAULT_CHARSET; iCharSet++)
    {
        if (plf->lfCharSet == g_CharSetTransTable[iCharSet].nCharSet)
        {
            if ((FontType == TRUETYPE_FONTTYPE) || 
                (g_CharSetTransTable[iCharSet].uCodePage == g_uACP))
            {
                *((DWORD*)lParam) |= g_CharSetTransTable[iCharSet].dwCodePages;
                break;
            }
        }
    }

    return TRUE;
}

int CALLBACK CMLFLink::GetFontCodePagesEnumFontProcW(const LOGFONTW* plf, const TEXTMETRICW*, DWORD FontType, LPARAM lParam)
{
    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].nCharSet != DEFAULT_CHARSET; iCharSet++)
    {
        if (plf->lfCharSet == g_CharSetTransTable[iCharSet].nCharSet)
        {
            if ((FontType == TRUETYPE_FONTTYPE) || 
                (g_CharSetTransTable[iCharSet].uCodePage == g_uACP))
            {
                *((DWORD*)lParam) |= g_CharSetTransTable[iCharSet].dwCodePages;
                break;
            }
        }
    }

    return TRUE;
}


STDMETHODIMP CMLFLink::MapFont(HDC hDC, DWORD dwCodePages, HFONT hSrcFont, HFONT* phDestFont)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(phDestFont);

    HRESULT hr = S_OK;

    CFontMappingInfo fm; // To accelerate internal subroutine calls

    fm.hDC = hDC;

    // Font mapping cache works only for Display
    BOOL fDisplay = (::GetDeviceCaps(hDC, TECHNOLOGY) == DT_RASDISPLAY);

    dwCodePages &= ~FS_SYMBOL; // We don't map symbol font.

    if (!::GetObject(hSrcFont, sizeof(fm.lfSrcFont), &fm.lfSrcFont))
        hr = E_FAIL; // Invalid hSrcFont

    // Do two things at same time
    // (1) Find given font in the font mapping cache
    // (2) Build m_auCodePage[] and m_adwCodePages[]
    if (SUCCEEDED(hr))
    {
        if (fDisplay)
        {
            BYTE nCharSet = fm.lfSrcFont.lfCharSet;
            fm.lfSrcFont.lfCharSet = DEFAULT_CHARSET;
            EnumFontFamiliesEx(hDC, &fm.lfSrcFont, (FONTENUMPROC)VerifyFontSizeEnumFontProc, (LPARAM)&fm.lfSrcFont, 0);
            fm.lfSrcFont.lfCharSet = nCharSet;
        }

        hr = S_FALSE; // hr == S_FALSE means that we didn't find the font in the cache
        for (int n = 0; n < 32 && dwCodePages; n++)
        {
            hr = CodePagesToCodePage(dwCodePages, 0, &fm.auCodePage[n]); // Pick one of CodePages

            if (SUCCEEDED(hr))
                hr = CodePageToCodePages(fm.auCodePage[n], &fm.adwCodePages[n]);

            if (SUCCEEDED(hr))
            {
                if (fDisplay && m_pFontMappingCache)
                    hr = m_pFontMappingCache->FindEntry(fm.auCodePage[n], fm.lfSrcFont, &fm.hDestFont);
                else
                    hr = S_FALSE;
            }

            if (hr != S_FALSE)
                break;

            dwCodePages &= ~fm.adwCodePages[n];
        }
        fm.auCodePage[n] = NULL; // End mark
        fm.adwCodePages[n] = 0;
    }

    if (hr == S_FALSE) // Not exist in cache
    {

        hr = MapFontCodePages(fm, GetFaceNameRegistry);

        if (hr == MLSTR_E_FACEMAPPINGFAILURE)
            hr = MapFontCodePages(fm, GetFaceNameGDI);

        // Handle font link failure case for NT5
        if (hr == MLSTR_E_FACEMAPPINGFAILURE && g_bIsNT5)
            hr = MapFontCodePages(fm, GetFaceNameMIME);

        if (SUCCEEDED(hr) && fDisplay && m_pFontMappingCache)
            hr = m_pFontMappingCache->AddEntry(fm.auCodePage[fm.iCP], fm.lfSrcFont, fm.hDestFont);
    }

    if (phDestFont)
    {
        if (SUCCEEDED(hr))
        {            
            *phDestFont = fm.hDestFont;
            fm.hDestFont = NULL; // Avoid being deleted it in destructor
        }
        else
        {
            *phDestFont = NULL;
        }
    }

    return hr;
}

STDMETHODIMP CMLFLink::ReleaseFont(HFONT hFont)
{
    ASSERT_THIS;

    HRESULT hr = S_OK;

    if (!m_pFontMappingCache || FAILED(hr = m_pFontMappingCache->UnlockEntry(hFont)))
    {
        // For non display DC
        if (::DeleteObject(hFont))
            hr = S_OK;
        else
            hr = E_FAIL; // Invalid hFont
    }
    return hr;
}

STDMETHODIMP CMLFLink::ResetFontMapping(void)
{
    ASSERT_THIS;
    HRESULT hr = S_OK;

    if (m_pFontMappingCache)
        hr =  m_pFontMappingCache->FlushEntries();

    return hr;
}

STDMETHODIMP CMLFLink2::ResetFontMapping(void)
{
    ASSERT_THIS;
    HRESULT hr = S_OK;

    if (m_pIMLFLnk)
        hr =  m_pIMLFLnk->ResetFontMapping();

    if (m_pFontMappingCache2)
        hr = (S_OK == m_pFontMappingCache2->EnsureFontTable(FALSE)? hr : E_FAIL);

    return hr;
}

HRESULT CMLFLink::MapFontCodePages(CFontMappingInfo& fm, PFNGETFACENAME pfnGetFaceName)
{
    HRESULT hr = MLSTR_E_FACEMAPPINGFAILURE;    

    for (fm.iCP = 0; fm.auCodePage[fm.iCP]; fm.iCP++)
    {
        fm.lfDestFont.lfCharSet = DEFAULT_CHARSET;

        hr = (this->*pfnGetFaceName)(fm);

        if (SUCCEEDED(hr))
        {
            LOGFONT lf = {0};

            // If face name is from registry or MIMEDB, we set charset to codepage charset.
            if (fm.lfDestFont.lfCharSet == DEFAULT_CHARSET)
            {
                for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
                {
                    if (fm.auCodePage[fm.iCP] == g_CharSetTransTable[iCharSet].uCodePage)
                    {
                        fm.lfDestFont.lfCharSet = (BYTE)g_CharSetTransTable[iCharSet].nCharSet;
                        break;
                    }
                }
            }

            lf.lfCharSet = DEFAULT_CHARSET;
            MLStrCpyN(lf.lfFaceName, fm.szFaceName, LF_FACESIZE);

            // Retrieve LOGFONT from gotten facename
            fm.lfDestFont.lfFaceName[0] = _T('\0');

            if (!::EnumFontFamiliesEx(fm.hDC, &lf, MapFontEnumFontProc, (LPARAM)&fm.lfDestFont, 0))
                hr = E_FAIL; // Invalid hDC
            else if (fm.lfDestFont.lfFaceName[0] == _T('\0'))
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (SUCCEEDED(hr))
        {
            fm.lfDestFont.lfHeight      = fm.lfSrcFont.lfHeight;
            fm.lfDestFont.lfWidth       = fm.lfSrcFont.lfWidth;
            fm.lfDestFont.lfEscapement  = fm.lfSrcFont.lfEscapement;
            fm.lfDestFont.lfOrientation = fm.lfSrcFont.lfOrientation;
            fm.lfDestFont.lfWeight      = fm.lfSrcFont.lfWeight;
            fm.lfDestFont.lfItalic      = fm.lfSrcFont.lfItalic;
            fm.lfDestFont.lfUnderline   = fm.lfSrcFont.lfUnderline;
            fm.lfDestFont.lfStrikeOut   = fm.lfSrcFont.lfStrikeOut;


            HRESULT hrTemp = VerifyFaceMap(fm);
            if (hrTemp == MLSTR_E_FACEMAPPINGFAILURE && fm.lfDestFont.lfWidth)
            {
                fm.lfDestFont.lfWidth = 0; // To recover non-scalable font
                hr = VerifyFaceMap(fm);
            }
            else
            {
                hr = hrTemp;
            }
        }

        if (hr != MLSTR_E_FACEMAPPINGFAILURE)
            break;
    }

    return hr;
}
    
int CALLBACK CMLFLink::MapFontEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD, LPARAM lParam)
{
    LOGFONT* plfDestFont = (LOGFONT*)lParam;
    
    if (!plfDestFont->lfFaceName[0] )
    {
        if (plfDestFont->lfCharSet != DEFAULT_CHARSET)
        {
            if (plfDestFont->lfCharSet == plfFont->lfCharSet)
                *plfDestFont = *plfFont;
        }
        else
              *plfDestFont = *plfFont;
    }

    return TRUE;
}

HRESULT CMLFLink::GetFaceNameRegistry(CFontMappingInfo& fm)
{
    static const TCHAR szRootKey[]       = _T("Software\\Microsoft\\Internet Explorer");
    static const TCHAR szIntlKey[]       = _T("International\\%d");
    static const TCHAR szPropFontName[]  = _T("IEPropFontName");
    static const TCHAR szFixedFontName[] = _T("IEFixedFontName");

    HRESULT hr = S_OK;
    HKEY hKeyRoot;

    if (::RegOpenKeyEx(HKEY_CURRENT_USER, szRootKey, 0, KEY_READ, &hKeyRoot) == ERROR_SUCCESS)
    {
        TCHAR szCodePageKey[ARRAYSIZE(szIntlKey) + 10];
        HKEY hKeySub;

        ::wsprintf(szCodePageKey, szIntlKey, fm.auCodePage[fm.iCP]);
        if (::RegOpenKeyEx(hKeyRoot, szCodePageKey, 0, KEY_READ, &hKeySub) == ERROR_SUCCESS)
        {
            const TCHAR* pszFontNameValue;
            DWORD dwType;
            DWORD dwSize = sizeof(fm.szFaceName);

            if ((fm.lfSrcFont.lfPitchAndFamily & 0x03) == FIXED_PITCH)
                pszFontNameValue = szFixedFontName;
            else
                pszFontNameValue = szPropFontName;

            if (::RegQueryValueEx(hKeySub, pszFontNameValue, 0, &dwType, (LPBYTE)fm.szFaceName, &dwSize) != ERROR_SUCCESS)
                hr = MLSTR_E_FACEMAPPINGFAILURE;

            if (::RegCloseKey(hKeySub) != ERROR_SUCCESS && SUCCEEDED(hr))
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }
        else
        {
            hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (::RegCloseKey(hKeyRoot) != ERROR_SUCCESS && SUCCEEDED(hr))
            hr = MLSTR_E_FACEMAPPINGFAILURE;
    }
    else
    {
        hr = MLSTR_E_FACEMAPPINGFAILURE;
    }
    return hr;
}

HRESULT CMLFLink::GetFaceNameGDI(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;

    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (fm.auCodePage[fm.iCP] == g_CharSetTransTable[iCharSet].uCodePage)
            break;
    }

    if (g_CharSetTransTable[iCharSet].uCodePage)
    {
        ::memset(&fm.lfDestFont, 0, sizeof(fm.lfDestFont));

        // Specify font weight as NORMAL to avoid NT GDI font mapping bugs
        fm.lfDestFont.lfWeight = FW_NORMAL;
        fm.lfDestFont.lfCharSet = (BYTE)g_CharSetTransTable[iCharSet].nCharSet;
        hr = GetFaceNameRealizeFont(fm);
    }
    else
    {
        hr = E_FAIL; // Unknown code page
    }

    if (SUCCEEDED(hr))
    {
        // Height, CharSet, Pitch and Family
        fm.lfDestFont.lfHeight = fm.lfSrcFont.lfHeight;
        fm.lfDestFont.lfPitchAndFamily = fm.lfSrcFont.lfPitchAndFamily;
        hr = GetFaceNameRealizeFont(fm);

        if (FAILED(hr))
        {
            // CharSet, Pitch and Family
            fm.lfDestFont.lfHeight = 0;
            hr = GetFaceNameRealizeFont(fm);
        }

        if (FAILED(hr))
        {
            // CharSet and Pitch
            fm.lfDestFont.lfPitchAndFamily &= 0x03; // Pitch Mask
            hr = GetFaceNameRealizeFont(fm);
        }

        if (FAILED(hr))
        {
            // CharSet only
            fm.lfDestFont.lfPitchAndFamily = 0;
            hr = GetFaceNameRealizeFont(fm);
        }
    }

    return hr;
}

HRESULT CMLFLink::GetFaceNameMIME(CFontMappingInfo& fm)
{
    HRESULT hr = E_FAIL;
    MIMECPINFO cpInfo;    

    if (fm.auCodePage[fm.iCP] == 936)
    {
        MLStrCpyN(fm.szFaceName, TEXT("SimSun"), LF_FACESIZE);
        return S_OK;
    }

    if (!g_pMimeDatabase)
        BuildGlobalObjects();


    if (NULL != g_pMimeDatabase)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(fm.auCodePage[fm.iCP], 0x409, &cpInfo)))
        {
            TCHAR szFontFaceName[LF_FACESIZE];
            szFontFaceName[0] = 0;

            if ((fm.lfSrcFont.lfPitchAndFamily & 0x03) == FIXED_PITCH && cpInfo.wszFixedWidthFont[0])
            {
#ifdef UNICODE
                MLStrCpyNW(szFontFaceName, cpInfo.wszFixedWidthFont, LF_FACESIZE);
#else
                WideCharToMultiByte(CP_ACP, 0, cpInfo.wszFixedWidthFont, -1, szFontFaceName, LF_FACESIZE, NULL, NULL);
#endif
            }
            else
                if (cpInfo.wszProportionalFont[0])
                {
#ifdef UNICODE
                    MLStrCpyNW(szFontFaceName, cpInfo.wszProportionalFont, LF_FACESIZE);
#else
                    WideCharToMultiByte(CP_ACP, 0, cpInfo.wszProportionalFont, -1, szFontFaceName, LF_FACESIZE, NULL, NULL);
#endif
                }

            if (szFontFaceName[0])
            {
                MLStrCpyN(fm.szFaceName, szFontFaceName, LF_FACESIZE);
                hr = S_OK;
            }
        }
        else
            hr = MLSTR_E_FACEMAPPINGFAILURE;
    }

    return hr;
}

HRESULT CMLFLink::GetFaceNameRealizeFont(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;
    HFONT hFont = NULL;
    HFONT hOldFont;
    DWORD dwFontCodePages;

    // First let's get a facename based on the given lfDestFont
    // Then verify if the font of the found facename has the code pages we want.

    hFont = ::CreateFontIndirect(&fm.lfDestFont);
    if (!hFont)
        hr = E_FAIL; // Out of memory or GDI resource

    if (SUCCEEDED(hr))
    {
        hOldFont = (HFONT)::SelectObject(fm.hDC, hFont);
        if (!hOldFont)
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (SUCCEEDED(hr))
    {
        if (!::GetTextFace(fm.hDC, ARRAYSIZE(fm.szFaceName), fm.szFaceName))
            hr = E_FAIL; // Out of memory or GDI resource

        if (!::SelectObject(fm.hDC, hOldFont) && SUCCEEDED(hr))
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (hFont)
        ::DeleteObject(hFont);

    if (SUCCEEDED(hr))
    {
        LOGFONT lfTemp;

        lfTemp = fm.lfDestFont;
        //
        // Security
        //
        _tcsncpy(lfTemp.lfFaceName, fm.szFaceName, ARRAYSIZE(lfTemp.lfFaceName));

        hFont = ::CreateFontIndirect(&lfTemp);
        if (!hFont)
            hr = E_FAIL; // Out of memory or GDI resource

        if (SUCCEEDED(hr = GetFontCodePages(fm.hDC, hFont, &dwFontCodePages)) && !(dwFontCodePages & fm.adwCodePages[fm.iCP]))
                hr = MLSTR_E_FACEMAPPINGFAILURE;

        if (hFont)
            ::DeleteObject(hFont);
    }

    return hr;
}

HRESULT CMLFLink::VerifyFaceMap(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;
    HFONT hOldFont;

    if (fm.hDestFont)
        ::DeleteObject(fm.hDestFont);

    fm.hDestFont = ::CreateFontIndirect(&fm.lfDestFont);
    if (!fm.hDestFont)
        hr = E_FAIL; // Out of memory or GDI resource

    if (SUCCEEDED(hr))
    {
        hOldFont = (HFONT)::SelectObject(fm.hDC, fm.hDestFont);
        if (!hOldFont)
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szFaceName[LF_FACESIZE];

        if (!::GetTextFace(fm.hDC, ARRAYSIZE(szFaceName), szFaceName))
            hr = E_FAIL; // Out of memory or GDI resource

        if (SUCCEEDED(hr))
        {
            int nRet = ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, fm.lfDestFont.lfFaceName, -1, szFaceName, -1);
            if (!nRet)
                hr = E_FAIL; // Unexpected error
            else if (nRet != 2) // Not Equal
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (!::SelectObject(fm.hDC, hOldFont) && SUCCEEDED(hr))
            hr = E_FAIL; // Out of memory or GDI resource
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink::CFontMappingCache

CMLFLink::CFontMappingCache::CFontMappingCache(void) :
    m_pEntries(NULL),
    m_pFree(NULL),
    m_cEntries(0)
{
    ::InitializeCriticalSection(&m_cs);
}

CMLFLink::CFontMappingCache::~CFontMappingCache(void)
{
    FlushEntries();
    DeleteCriticalSection(&m_cs);
}

HRESULT CMLFLink::CFontMappingCache::FindEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT* phDestFont)
{
    HRESULT hr = S_FALSE;

    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (uCodePage == pEntry->m_uSrcCodePage &&
                lfSrcFont.lfPitchAndFamily == pEntry->m_bSrcPitchAndFamily &&
                lfSrcFont.lfHeight == pEntry->m_lSrcHeight &&
                lfSrcFont.lfWidth == pEntry->m_lSrcWidth &&
                lfSrcFont.lfEscapement == pEntry->m_lSrcEscapement &&
                lfSrcFont.lfOrientation == pEntry->m_lSrcOrientation &&
                lfSrcFont.lfWeight == pEntry->m_lSrcWeight &&
                lfSrcFont.lfItalic == pEntry->m_bSrcItalic &&
                lfSrcFont.lfUnderline == pEntry->m_bSrcUnderline &&
                lfSrcFont.lfStrikeOut == pEntry->m_bSrcStrikeOut)
            {
                int nRet = ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfSrcFont.lfFaceName, -1, pEntry->m_szSrcFaceName, -1);
                if (!nRet)
                {
                    hr = E_FAIL; // Unexpected error
                    break;
                }
                else if (nRet == 2) // Equal
                {
                    if (phDestFont)
                        *phDestFont = pEntry->m_hDestFont;
                    pEntry->m_nLockCount++;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    ::LeaveCriticalSection(&m_cs);

    if (phDestFont && hr != S_OK)
        *phDestFont = NULL;

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::UnlockEntry(HFONT hDestFont)
{
    HRESULT hr = E_FAIL; // hDestFont is not found in the cache

    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (hDestFont == pEntry->m_hDestFont)
            {
                if (pEntry->m_nLockCount - 1 >= 0)
                {
                    pEntry->m_nLockCount--;
                    hr = S_OK;
                }
                break;
            }
        }
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::AddEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT hDestFont)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pEntries) // Need to allocate all the entries
    {
        CFontMappingCacheEntry* pEntries;

        pEntries = new CFontMappingCacheEntry[NUMFONTMAPENTRIES + 1]; // +1 for sentinel

        if (pEntries)
        {
            // Init sentinel
            pEntries[0].m_pPrev = &pEntries[0];
            pEntries[0].m_pNext = &pEntries[0];

            // Init free entries
            for (int n = 0; n < NUMFONTMAPENTRIES; n++)
            {
                const nEnt = n + 1; // + 1 for sentinel

                if (n < NUMFONTMAPENTRIES - 1)
                    pEntries[nEnt].m_pNext = &pEntries[nEnt + 1];
                else
                    pEntries[nEnt].m_pNext = NULL;
            }

            m_pEntries = &pEntries[0];
            m_pFree = &pEntries[1];
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && !m_pFree) // Need to delete oldest entry
    {
        CFontMappingCacheEntry* pOldestEntry = m_pEntries->m_pPrev;

        while (pOldestEntry->m_nLockCount > 0 && pOldestEntry != m_pEntries) // Entry is locked
            pOldestEntry = pOldestEntry->m_pPrev;

        if (pOldestEntry != m_pEntries)
        {
            if (pOldestEntry->m_hDestFont)
                ::DeleteObject(pOldestEntry->m_hDestFont);

            // Delete it from m_pEntries list
            pOldestEntry->m_pPrev->m_pNext = pOldestEntry->m_pNext;
            pOldestEntry->m_pNext->m_pPrev = pOldestEntry->m_pPrev;

            // Insert it into m_pFree list
            pOldestEntry->m_pNext = m_pFree;
            m_pFree = pOldestEntry;
        }
        else // No entry available
        {
            hr = E_FAIL; // Out of cache entries
        }
    }

    if (SUCCEEDED(hr)) // Create new entry and fill it
    {
        CFontMappingCacheEntry* pNewEntry;

        // Delete it from m_pFree list
        pNewEntry = m_pFree; // shouldn't be NULL
        m_pFree = pNewEntry->m_pNext;

        // Insert it into m_pEntries list
        pNewEntry->m_pNext = m_pEntries->m_pNext;
        pNewEntry->m_pPrev = m_pEntries;
        m_pEntries->m_pNext->m_pPrev = pNewEntry;
        m_pEntries->m_pNext = pNewEntry;

        // Fill it
        pNewEntry->m_nLockCount = 1;
        pNewEntry->m_uSrcCodePage = uCodePage;
        pNewEntry->m_lSrcHeight = lfSrcFont.lfHeight;
        pNewEntry->m_lSrcWidth = lfSrcFont.lfWidth;
        pNewEntry->m_lSrcEscapement = lfSrcFont.lfEscapement;
        pNewEntry->m_lSrcOrientation = lfSrcFont.lfOrientation;
        pNewEntry->m_lSrcWeight = lfSrcFont.lfWeight;
        pNewEntry->m_bSrcItalic = lfSrcFont.lfItalic;
        pNewEntry->m_bSrcUnderline = lfSrcFont.lfUnderline;
        pNewEntry->m_bSrcStrikeOut = lfSrcFont.lfStrikeOut;
        pNewEntry->m_bSrcPitchAndFamily = lfSrcFont.lfPitchAndFamily;

        //security
        _tcsncpy(pNewEntry->m_szSrcFaceName, lfSrcFont.lfFaceName, ARRAYSIZE(pNewEntry->m_szSrcFaceName));
        pNewEntry->m_hDestFont = hDestFont;
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::FlushEntries(void)
{
    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (pEntry->m_hDestFont)
                ::DeleteObject(pEntry->m_hDestFont);
        }

        delete[] m_pEntries;

        m_pEntries = NULL;
        m_cEntries = 0;
    }

    ::LeaveCriticalSection(&m_cs);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink::CCodePagesCache

CMLFLink::CCodePagesCache::CCodePagesCache(void) :
    m_pbBuf(NULL),m_pbBufExt(NULL)
{
    ::InitializeCriticalSection(&m_cs);
}

CMLFLink::CCodePagesCache::~CCodePagesCache(void)
{
    DeleteCriticalSection(&m_cs);
}

HRESULT CMLFLink::CCodePagesCache::RealLoad(void)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pbBuf && !m_pbBufExt)
    {
        HRSRC hrCodePages;
        HGLOBAL hgCodePages;
        HRSRC hrCodePagesExt;
        HGLOBAL hgCodePagesExt;


        if (SUCCEEDED(hr))
        {
            hrCodePages = ::FindResource(g_hInst, MAKEINTRESOURCE(IDR_CODEPAGES), _T("CODEPAGES"));
            hrCodePagesExt = ::FindResource(g_hInst, MAKEINTRESOURCE(IDR_CODEPAGESEXT), _T("CODEPAGESEXT"));
            if (!hrCodePages || !hrCodePagesExt)
                hr = E_FAIL; // Build error?
        }
        if (SUCCEEDED(hr))
        {
            hgCodePages = ::LoadResource(g_hInst, hrCodePages);
            hgCodePagesExt = ::LoadResource(g_hInst, hrCodePagesExt);
            if (!hgCodePages && !hgCodePagesExt)
                hr = E_FAIL; // Unexpected error
        }
        if (SUCCEEDED(hr))
        {
            m_pbBuf = (BYTE*)::LockResource(hgCodePages);
            m_pbBufExt = (BYTE*)::LockResource(hgCodePagesExt);
            if (!m_pbBuf || !m_pbBufExt)
                hr = E_FAIL; // Unexpected error
        }
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

extern "C" HRESULT GetGlobalFontLinkObject(IMLangFontLink **ppMLFontLink)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppMLFontLink)
    {
        if (NULL == g_pMLFLink)
        {
            EnterCriticalSection(&g_cs);
            if (NULL == g_pMLFLink)
                CComCreator< CComPolyObject< CMLFLink > >::CreateInstance(NULL, IID_IMLangFontLink, (void **)&g_pMLFLink);
            LeaveCriticalSection(&g_cs);
        }
        *ppMLFontLink = g_pMLFLink;
        if (g_pMLFLink)
        {
            g_pMLFLink->AddRef();
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMLFLink2::CFontMappingCache2::MapFontFromCMAP(HDC hDC, WCHAR wchar, HFONT hSrcFont, HFONT *phDestFont)
{
    BOOL    bFont = FALSE;
    HRESULT hr = E_FAIL;
    int     i,j,k;
    LOGFONT LogFont;

    if (!phDestFont)
        return E_INVALIDARG;

    if (!GetObject(hSrcFont, sizeof(LOGFONT), &LogFont))
        return hr;

    if (!g_pfont_table || !g_pfont_table[0].szFaceName[0])
    {        
        if (FAILED(LoadFontDataFile()))
        {
            return hr;
        }
    }

    i=0;
    j=ARRAYSIZE(g_urange_table);
    k = j/2;

    while (i<=j)
    {

        if (wchar >= g_urange_table[k].wcFrom && wchar <= g_urange_table[k].wcTo)
           break;
        else
           if (wchar < g_urange_table[k].wcFrom)
           {
               j = k -1;
           }
           else
           {
               i = k + 1;
           }
           k = (i+j)/2;
    }

    if (i<=j && g_urange_table[k].nFonts)
    {
        TCHAR szFaceName[LF_FACESIZE];
        GetTextFace(hDC, LF_FACESIZE, szFaceName);

        // Check if it supports the character
        for (i=0; i<g_urange_table[k].nFonts; i++)
        {
            if (!MLStrCmpI(szFaceName,g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName))
                break;
        }

        // Current font doesn't support this character
        if (i == g_urange_table[k].nFonts)
        {
            for (i=0; i<g_urange_table[k].nFonts; i++)
            {
                if (LogFont.lfCharSet == g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfCharSet)
                    break;
            }

            // No font available for current CharSet, then return the first one in the list            
            if (i >= g_urange_table[k].nFonts)
            {
                i = fetchCharSet((BYTE *) &(LogFont.lfCharSet), k);
            }

            MLStrCpyN(LogFont.lfFaceName, g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName, LF_FACESIZE);
        }

        if (i < g_urange_table[k].nFonts)
        {
            MLStrCpyN(LogFont.lfFaceName, g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName, LF_FACESIZE);
        }
        
        bFont = TRUE;
    } 

    if (bFont && (*phDestFont = CreateFontIndirect(&LogFont)))
    {
        hr = S_OK;       
    }
    else
    {
        *phDestFont = NULL;
    }


    return hr;
}


HRESULT CMLFLink2::CFontMappingCache2::UnicodeRanges(
    LPTSTR  szFont,
    UINT    *puiRanges, 
    UNICODERANGE* pURanges
    )

{
    HRESULT hr = E_FAIL;
    UINT    nURange = 0;
    DWORD   cmap    = 0;
    DWORD   name    = 0;
    HANDLE  hTTF;    
    TCHAR   szFontPath[MAX_PATH];
    static TCHAR s_szFontDir[MAX_PATH] = {0};


    HANDLE  hTTFMap;
    DWORD   dwFileSize;
    LPVOID  lpvFile = NULL;
    LPBYTE  lp, lp1, lp2, lpMax = NULL;
    DWORD   Num;
    WORD    i, j, Len;

    if (!szFont[0])
        return hr;

    if (!s_szFontDir[0])
    {
        MLGetWindowsDirectory(s_szFontDir, MAX_PATH);
        MLPathCombine(s_szFontDir, ARRAYSIZE(s_szFontDir), s_szFontDir, FONT_FOLDER);
    }

    MLPathCombine(szFontPath, ARRAYSIZE(szFontPath), s_szFontDir, szFont);

    hTTF = CreateFile(  szFontPath,             // pointer to name of the file
                        GENERIC_READ,           // access (read-write) mode
                        FILE_SHARE_READ,        // share mode
                        NULL,                   // pointer to security attributes
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // handle to file with attributes to copy;

    if (INVALID_HANDLE_VALUE == hTTF)
        return hr;

    dwFileSize = GetFileSize(hTTF, NULL);


    hTTFMap = CreateFileMapping(
                  hTTF,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hTTFMap == NULL)
    {
        goto CloseHandle;
    }

    lpvFile = MapViewOfFile(
                  hTTFMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if(lpvFile == NULL)
    {
        goto CloseHandle;
    }

    lp = (LPBYTE)lpvFile;
    // The maximum boundary we can go
    lpMax = (LPBYTE)lpvFile + dwFileSize;

    // Font table name uses ASCII
    if(strncmp(((TTC_HEAD*)lp)->TTCTag, "ttcf", 4) == 0)   // TTC format
    {
        lp += FOUR_BYTE_NUM(((TTC_HEAD*)lp)->OffsetTTF1);  // points to first TTF
    }

    Num = TWO_BYTE_NUM(((TTF_HEAD*)lp)->NumTables);        // Number of Tables
    lp += sizeof(TTF_HEAD);

    if (lp+Num*sizeof(TABLE_DIR) >= lpMax) // Not a valid TrueType file if table size >= TTF file size
        goto CloseHandle;

    for(i = 0; i < Num ; i++)   // go thru all tables to find cmap and name
    {
        if(strncmp( ((TABLE_DIR*)lp)->Tag, "cmap", 4) == 0)
        {
            cmap = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (name) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "name", 4) == 0)
        {
            name = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap) break;
        }
        lp += sizeof(TABLE_DIR);

     }

    if((!cmap) || (!name))    // Can't find cmap or name
    {
        goto CloseHandle;
    }

    // Read thru all name records
    // to see if font subfamily name is "Regular"

    lp  = (LPBYTE)lpvFile + name;                   // point to name table
    Num = TWO_BYTE_NUM(((NAME_TABLE*)lp)->NumRec);  // # of name record

    if (lp + sizeof(NAME_TABLE)*Num >= lpMax)
        goto CloseHandle;

    lp1 = lp  + sizeof(NAME_TABLE);                 // point to name record


    for(i = 0; i < Num; i++)
    {
        if(FONT_SUBFAMILY_NAME == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->NameID))
        {
            lp2 = lp +                              // point to string store
                  TWO_BYTE_NUM(((NAME_TABLE* )lp )->Offset) +
                  TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Offset);

            // Invalid TTF file
            if (lp2 >= lpMax)
                break;

            Len = TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Length);

            if(((MICROSOFT_PLATFORM == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Platform)) && 
                (UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding)))  ||
               ((APPLE_UNICODE_PLATFORM == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Platform)) && 
                (APPLE_UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding))))  
            {
                Len >>= 1;
                const char *pStr = szRegular;

                if (Len == sizeof(szNormal) -1)
                    pStr = szNormal;
                else 
                    if (Len != sizeof(szRegular)-1)
                    {
                        lp1 += sizeof(NAME_RECORD);
                        continue;
                    }

                while(--Len > 0)
                {
                    if(*(lp2+(Len<<1)+1) != pStr[Len])
                    break;
                }

                if (!Len)
                    break;
                else
                {
                    lp1 += sizeof(NAME_RECORD);
                    continue;
                }
            }
            else
            {
                if(strncmp((char*)lp2, szRegular, sizeof(szRegular)-1) != 0 && 
                   strncmp((char*)lp2, szNormal, sizeof(szNormal)-1) != 0)
                {
                    lp1 += sizeof(NAME_RECORD);
                    continue;
                }
                else
                    break;
            }
        }
        lp1 += sizeof(NAME_RECORD);
    }

    // If no regular font, exit
    if (i == Num)
        goto CloseHandle;

    // all non-regular fonts have already been eliminated
    lp1  = (LPBYTE)lpvFile + cmap;                     // point to cmap table

    if (lp1 + sizeof(CMAP_TABLE)*Num >= lpMax)
        goto CloseHandle;

    Num  = TWO_BYTE_NUM(((CMAP_HEAD*)lp1)->NumTables);

    lp1 += sizeof(CMAP_HEAD);


    while(Num >0)
    {

        if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM && 
           (TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING ||
           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_SYMBOL_INDEXING))
        {
            lp = (LPBYTE)lpvFile
                 + cmap
                 + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

            if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
            {
                break;
            }
        }
        Num--;
        lp1 += sizeof(CMAP_TABLE);
    }

    if(Num == 0)                            // can't find Platform:3/Encoding:1 (Unicode)
        goto CloseHandle;

    Num  = TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2);
    lp2  = lp  + sizeof(CMAP_FORMAT);       // lp2 -> first WCHAR of wcTo
    lp1  = lp2 + Num + 2;                   // lp1 -> first WCHAR of wcFrom

    if (lp1 + Num >= lpMax)
        goto CloseHandle;

    Num /= 2;

    

    if (pURanges == NULL)
    {
        *puiRanges = Num;
    }
    else
    {
        if (Num > *puiRanges)
            Num = *puiRanges;
        else
            *puiRanges = Num;

        for(i=0, j=0; i < Num; i++, j++, j++)
        {
            pURanges[i].wcFrom = TWO_BYTE_NUM((lp1+j));
            pURanges[i].wcTo   = TWO_BYTE_NUM((lp2+j));
        }
    }

    hr = S_OK;

CloseHandle:
    if (lpvFile)
    {
        UnmapViewOfFile(lpvFile);
    }

    if (hTTFMap)
    {
        CloseHandle(hTTFMap);
    }

    // Handle is checked after creation.
    CloseHandle(hTTF);

    return hr;
}

int CMLFLink2::CFontMappingCache2::fetchCharSet(BYTE *pCharset, int iURange)
{
    int i,j;

    //Check if current charset valid for the font
    for (i=0; i<g_urange_table[iURange].nFonts; i++)
    {
        for (j=0;(j<32) && g_CharSetTransTable[j].uCodePage;j++)
        {
            if (g_pfont_table[*(g_urange_table[iURange].pFontIndex+i)].dwCodePages[0] & g_CharSetTransTable[j].dwCodePages)
                if (*pCharset == g_CharSetTransTable[j].nCharSet)
                    return i;
        }
    }

    //If invalid, fetch first valid one.
    for (i=0;(i<32) && g_CharSetTransTable[i].uCodePage;i++)
    {
        if (g_pfont_table[*(g_urange_table[iURange].pFontIndex)].dwCodePages[0] & g_CharSetTransTable[i].dwCodePages)
        {
           *pCharset = (BYTE)g_CharSetTransTable[i].nCharSet;
           break;
        }
    }

    return 0;
}


BOOL CMLFLink2::CFontMappingCache2::GetNonCpFontUnicodeRanges(TCHAR *szFontName, int iFontIndex)
{
    LONG    nURange = 0;
    DWORD   cmap    = 0;
    DWORD   name    = 0;
    DWORD   os2     = 0;

    HANDLE  hTTFMap;
    DWORD   dwFileSize;
    LPVOID  lpvFile = NULL;
    LPBYTE  lp, lp1, lp2;
    DWORD   Num;
    int     i, j, k, m;
    WORD    Len;
    HANDLE  hTTF;
    BOOL    bRet = FALSE;


    hTTF = CreateFile(  szFontName,             // pointer to name of the file
                        GENERIC_READ,           // access (read-write) mode
                        FILE_SHARE_READ,        // share mode
                        NULL,                   // pointer to security attributes
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // handle to file with attributes to copy;

    if (hTTF == INVALID_HANDLE_VALUE)
        return FALSE;

    dwFileSize = GetFileSize(hTTF, NULL);

    hTTFMap = CreateFileMapping(
                  hTTF,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hTTFMap == NULL)
    {
        goto GET_NCP_EXIT;
    }

    lpvFile = MapViewOfFile(
                  hTTFMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if(lpvFile == NULL)
    {
        goto GET_NCP_EXIT;
    }

    lp = (LPBYTE)lpvFile;

    if(strncmp(((TTC_HEAD*)lp)->TTCTag, "ttcf", 4) == 0)   // TTC format
    {
        lp += FOUR_BYTE_NUM(((TTC_HEAD*)lp)->OffsetTTF1);  // points to first TTF
    }

    Num = TWO_BYTE_NUM(((TTF_HEAD*)lp)->NumTables);        // Number of Tables
    {
      // if SearchRange != (Maximum power of 2 <= Num)*16,
      // then this is not a TTF file
      DWORD  wTmp = 1;

      while(wTmp <= Num)
      {
        wTmp <<= 1;
      }
      wTmp <<= 3;          // (wTmp/2)*16

      if(wTmp != (DWORD)TWO_BYTE_NUM(((TTF_HEAD*)lp)->SearchRange))
      {
        goto GET_NCP_EXIT;
      }

      // if RangeShift != (Num*16) - SearchRange,
      // then this is not a TTF file
      wTmp = (Num<<4) - wTmp;
      if(wTmp != (DWORD)TWO_BYTE_NUM(((TTF_HEAD*)lp)->RangeShift))
      {
        goto GET_NCP_EXIT;
      }
    }

    lp += sizeof(TTF_HEAD);

    for(i = 0; i < (int)Num; i++)   // go thru all tables to find cmap and name
    {
        if(strncmp( ((TABLE_DIR*)lp)->Tag, "cmap", 4) == 0)
        {
            cmap = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (name && os2) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "name", 4) == 0)
        {
            name = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap && os2) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "OS/2", 4) == 0)
        {
            os2 = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap && name) break;
        }

        lp += sizeof(TABLE_DIR);
     }

    if((!cmap) || (!name) || (!os2))    // Can't find cmap or name
    {
        goto GET_NCP_EXIT;
    }

    // Read thru all name records
    // to see if font subfamily name is "Regular"

    lp  = (LPBYTE)lpvFile + name;                   // point to name table
    Num = TWO_BYTE_NUM(((NAME_TABLE*)lp)->NumRec);  // # of name record
    lp1 = lp  + sizeof(NAME_TABLE);                 // point to name record

    for(i = 0; i < (int)Num; i++)
    {
        if(FONT_SUBFAMILY_NAME == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->NameID))
        {
            lp2 = lp +                              // point to string store
                  TWO_BYTE_NUM(((NAME_TABLE* )lp )->Offset) +
                  TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Offset);

            Len = TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Length);

            if(UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding))
            {
                Len >>= 1;
                while(--Len > 0)
                {
                    if(*(lp2+(Len<<1)+1) != szRegular[Len])
                    goto GET_NCP_EXIT;
                }
                break;
            }
            else
            {
                if(strncmp((char*)lp2, szRegular, Len) != 0)
                    goto GET_NCP_EXIT;
                else
                    break;
            }
        } 

        lp1 += sizeof(NAME_RECORD);
    }

    // all non-regular fonts have already been eliminated

    lp1  = (LPBYTE)lpvFile + cmap;                     // point to cmap table
    Num  = TWO_BYTE_NUM(((CMAP_HEAD*)lp)->NumTables);
    lp1 += sizeof(CMAP_HEAD);

    while(Num >0)
    {
        if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM && 
           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING)
        {
            lp = (LPBYTE)lpvFile
                 + cmap
                 + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

            if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
            {
                break;
            }
        }
        Num--;
        lp1 += sizeof(CMAP_TABLE);
    }

    if(Num == 0)                   // can't find Platform:3/Encoding:1 (Unicode)
        goto GET_NCP_EXIT;


    Num  = TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2) ;

    m = ARRAYSIZE(g_urange_table);

    lp2  = lp  + sizeof(CMAP_FORMAT);     // lp2 -> first WCHAR of wcTo
    lp1  = lp2 + Num + 2;                 // lp1 -> first WCHAR of wcFrom


    // Fast parse !!!
    while (--m)
    {
        // URANGE binary search
        i=0;
        j= (int) Num - 2;
        k=j/2;
        while (i<=j)
        {
            if (k % 2) 
                k++;

            if (g_urange_table[m].wcFrom >= TWO_BYTE_NUM((lp1+k)) && g_urange_table[m].wcTo <= TWO_BYTE_NUM((lp2+k)))
            {
                EnterCriticalSection(&g_cs);
                if (!g_urange_table[m].pFontIndex)
                    g_urange_table[m].pFontIndex = (int *)LocalAlloc(LPTR, sizeof(int)* MAX_FONT_INDEX);
                if (!g_urange_table[m].pFontIndex)
                {
                    LeaveCriticalSection(&g_cs);
                    goto GET_NCP_EXIT;
                }

                if (g_urange_table[m].nFonts >= MAX_FONT_INDEX)
                {
                    LeaveCriticalSection(&g_cs);
                    break;
                }

                g_urange_table[m].pFontIndex[g_urange_table[m].nFonts] = iFontIndex;
                g_urange_table[m].nFonts++;

                // Fill in font code page signature
                g_pfont_table[iFontIndex].dwCodePages[0] = FOUR_BYTE_NUM(((BYTE *)lpvFile+os2+OFFSET_OS2CPRANGE));
                g_pfont_table[iFontIndex].dwCodePages[1] = FOUR_BYTE_NUM(((BYTE *)lpvFile+os2+OFFSET_OS2CPRANGE+1));                
                LeaveCriticalSection(&g_cs);
                break;
            }
            else
            {
                if (g_urange_table[m].wcFrom < TWO_BYTE_NUM((lp1+k)))
                {
                    j = k-2;
                }
                else
                {
                    i = k+2;
                }
                k = (i+j)/2;
            }
        }
    }
    
    bRet = TRUE;

GET_NCP_EXIT:
    if (lpvFile) 
    {
        UnmapViewOfFile(lpvFile);
    }

    if (hTTFMap)
    {
        CloseHandle(hTTFMap);        
    }

    CloseHandle(hTTF);

    return bRet;
}

HRESULT GetRegFontKey(HKEY *phKey, DWORD *pdwValues)
{
    HRESULT hr = E_FAIL;

    if (ERROR_SUCCESS == (g_bIsNT? 
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEYNT, 0, KEY_READ, phKey):
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEY95, 0, KEY_READ, phKey)))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(*phKey, NULL, NULL, 0, NULL, 
            NULL, NULL, pdwValues, NULL, NULL, NULL, NULL))
        {
            hr = S_OK;
        }
        else
        {
            RegCloseKey(*phKey);
        }
    }

    return hr;
}

BOOL CMLFLink2::CFontMappingCache2::GetFontURangeBits(TCHAR *szFontFile, DWORD * pdwURange)
{
    // We can make use of font Unicode range signature if needed.
    return TRUE;    
}

BOOL CMLFLink2::CFontMappingCache2::SetFontScripts(void)
{

    LOGFONT lf;
    int     i,j;
    HWND    hWnd = GetTopWindow(GetDesktopWindow());
    HDC     hDC = GetDC(hWnd);


    if (!g_pfont_table)
        return FALSE;

    // Process code page based scripts (g_CharSetTransTable.sid)
    for (i = 0; g_CharSetTransTable[i].nCharSet != DEFAULT_CHARSET; i++)
    {
        j = 0;
        ZeroMemory(&lf, sizeof(lf));
        lf.lfCharSet = (BYTE)g_CharSetTransTable[i].nCharSet;

        while (g_CharSetTransTable[i].sid[j] != sidDefault)
        {
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)SetFontScriptsEnumFontProc, (LPARAM)g_CharSetTransTable[i].sid[j], 0);
            j++;
        }
    }


    if (hDC)
        ReleaseDC(hWnd, hDC);

    // Process Unicode subrange based scripts (not implemented)
    // Skip this part since we need to access font CMAP anyway

    // Process char based scripts (g_wCharToScript)

    for (i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
    {
        UINT uiRanges = 0;
        UNICODERANGE* pURanges = NULL;
        SCRIPT_IDS  scripts;

        if (SUCCEEDED(m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, &uiRanges, pURanges)))
        {
            if (uiRanges)
            {
                int         l, m, n;                

                pURanges = (UNICODERANGE *)LocalAlloc(LPTR, sizeof(UNICODERANGE) * uiRanges);

                if (!pURanges)
                    return FALSE;

                m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, &uiRanges, pURanges);
                for (j=0; j< ARRAYSIZE(g_wCharToScript); j++)
                {

                    l = 0;
                    m = uiRanges;
                    n = m/2;
                    while (l <= m)
                    {
                        if ((g_wCharToScript[j].wch >= pURanges[n].wcFrom) && (g_wCharToScript[j].wch <= pURanges[n].wcTo))
                        {
                            scripts = 1;
                            scripts <<= g_wCharToScript[j].sid;
                            g_pfont_table[i].scripts |= scripts;
                            break;
                        }
                        else
                        {
                            if (g_wCharToScript[j].wch < pURanges[n].wcFrom)
                                m = n-1;
                            else
                                l = n+1;
                            n = (m+l)/2;
                        }
                    }
                }

                LocalFree(pURanges);
                pURanges = NULL;
            }
        }

        // sidUserDefined should contain all valid regular TrueType fonts
        if (!MLStrStr(g_pfont_table[i].szFaceName, TEXT("Bold")) && !MLStrStr(g_pfont_table[i].szFaceName, TEXT("Italic")))
        {
            scripts = 1;
            scripts <<= sidUserDefined;
            g_pfont_table[i].scripts |= scripts;
        }
    }

    //GetFontScriptFromCMAP(szFont, &(g_pfont_table[i].scripts));

    return TRUE;
}

BOOL CMLFLink2::CFontMappingCache2::IsFontUpdated(void)
{
    HKEY    hkey;
    DWORD   dwFonts = 0;
    BOOL    bRet = FALSE;


    if (g_pfont_table)
    {
        if (S_OK == GetRegFontKey(&hkey, &dwFonts))
        {
            if (g_pfont_table[0].dwCodePages[1] != dwFonts)
                bRet = TRUE;
            RegCloseKey(hkey);
        }
    }
    else
    {
        // font table not created yet, need to update
        bRet = TRUE;
    }

    return bRet;
}
    
// Make sure we have font data table available and it is updated
HRESULT CMLFLink2::CFontMappingCache2::EnsureFontTable(BOOL bUpdateURangeTable)    
{
    BOOL bRet;
    
    if (IsFontUpdated())
    {
        // Need to guard the whole font creation procedure by critical sections
        EnterCriticalSection(&g_cs);

        if (IsFontUpdated())
        {
            if (g_pfont_table)
            {
                if (g_pfont_table[0].szFaceName[0])
                {
                    bUpdateURangeTable = TRUE;
                }
                LocalFree(g_pfont_table);
                g_pfont_table = NULL;
            }

            bRet = SetFontTable();

            if (!bRet)
            {
                LeaveCriticalSection(&g_cs);        
                return E_OUTOFMEMORY;
            }

        }
        LeaveCriticalSection(&g_cs);        
    }

    if (bUpdateURangeTable)
    {
        EnterCriticalSection(&g_cs);
        for (int i = 0; i < ARRAYSIZE(g_urange_table); i++)
        {
            if (g_urange_table[i].nFonts)
            {
                LocalFree(g_urange_table[i].pFontIndex);
                g_urange_table[i].pFontIndex = NULL;
                g_urange_table[i].nFonts = 0;
            }            
        }
        LeaveCriticalSection(&g_cs);        

        if (S_OK != SetFontUnicodeRanges())
            return E_OUTOFMEMORY;

        SaveFontDataFile();
    }

    // All tables created successfully
    return S_OK;
}


#ifdef UNIX
typedef struct tagTable_info{
    int count;
    int table_size;
    } Table_info;

int UnixGetAllFontsProc(ENUMLOGFONTEX* plfFont, NEWTEXTMETRICEX* lpntm, int iFontType, LPARAM lParam)
{
    LOGFONT *lplf;
    int *pcount = &((Table_info*)lParam)->count;
    int *ptable_size = &((Table_info*)lParam)->table_size;

    lplf = &(plfFont->elfLogFont);
    // We don't use non TrueType fonts
    if (iFontType == DEVICE_FONTTYPE || iFontType == RASTER_FONTTYPE)
        return 1;   // keep going but don't use this font

    // We don't use the SYMBOL, Mac Charset fonts
    if(lplf->lfCharSet == SYMBOL_CHARSET || lplf->lfCharSet == MAC_CHARSET)
        return 1;

    // We don't handle vertical fonts
    if (TEXT('@') == lplf->lfFaceName[0])
        return 1;

    // Now update the font-table
    // Does UNIX use TTF? // if (FontType == TRUETYPE_FONTTYPE)
    {
        CopyMemory(&g_pfont_table[*pcount].lf, lplf, sizeof(LOGFONT));
        MLStrCpyN(g_pfont_table[*pcount].szFaceName, lplf->lfFaceName, LF_FACESIZE);
        (*pcount)++;
    }

    if (*pcount >= *ptable_size)
    {
        FONTINFO * pfont_table = NULL;

        *ptable_size += FONT_TABLE_INIT_SIZE;
        pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, 
                                        sizeof(FONTINFO) * *ptable_size,
                                        LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (NULL == pfont_table)
        {
            return 0; // Stop enum. 
        }
        else
        {
            g_pfont_table = pfont_table;
        }
    }
 
    return 1;       // Keep enum. 
}
#endif

BOOL CMLFLink2::CFontMappingCache2::SetFontTable(void)
{
    BOOL    bRet = TRUE;
    TCHAR   szFaceName[MAX_PATH];

    DWORD   dwValue;
    TCHAR   szFontFile[MAX_FONT_FILE_NAME];
    DWORD   dwData;
    DWORD   dwType = REG_SZ;
    DWORD   dwFonts;
    int     i, table_size = FONT_TABLE_INIT_SIZE;
    LPTSTR  pNewFaceName = NULL;
    HKEY    hkey = NULL;
    static int count;

    HDC     hDC = NULL;
    HWND    hWnd = NULL;
    
    FONTINFO * pFontTable;
    
    count = 1;
    
    if (!g_pfont_table)
    {
        g_pfont_table = (FONTINFO *)LocalAlloc(LPTR, sizeof(FONTINFO) * FONT_TABLE_INIT_SIZE);
        if (!g_pfont_table)
        {
            bRet = FALSE;
            goto SETFONT_DONE;
        }        
    }
    else
    {
        // weiwu: Need to clean up this code
        goto SETFONT_DONE;
    }
    
#ifndef UNIX
    if (S_OK != GetRegFontKey(&hkey, &dwFonts))
    {
        bRet = FALSE;
        goto SETFONT_DONE;
    }    

    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    for (i=0; ;i++)
    {
        dwValue = sizeof(szFaceName);
        dwData  = sizeof(szFontFile);

        if (ERROR_NO_MORE_ITEMS == RegEnumValue(
                      hkey,
                      i,
                      szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFontFile,
                      &dwData ))
        {
            break;
        }
        DWORD dwOffset = 0;
FIND_NEXT_FACENAME:        
        pNewFaceName = MLStrStr(&szFaceName[dwOffset], TEXT(" & "));
        if (pNewFaceName)
        {
           *pNewFaceName = 0;
           // Skip " & ", look for next font face name
           pNewFaceName+=3;
        }
        else
        {
            pNewFaceName = MLStrStr(&szFaceName[dwOffset], TEXT("(TrueType)"));
            if(pNewFaceName)
            {
                // Ignor the space between face name and "(TrueTye)" signature
                if ((pNewFaceName > szFaceName) && (*(pNewFaceName-1) == 0x20))
                    pNewFaceName--;
                *pNewFaceName = 0;
            }
        }

        if (pNewFaceName && !EnumFontFamilies(hDC, &szFaceName[dwOffset], MapFontExEnumFontProc, (LPARAM)&count))   //TrueType font
        {
            int nSize;
            LPTSTR pFontFile;

            if (count >= table_size)
            {
                FONTINFO * _pfont_table = NULL;

                table_size += FONT_TABLE_INIT_SIZE;
                _pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, sizeof(FONTINFO) * table_size,
                                    LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (NULL == _pfont_table)
                {
                    bRet = FALSE;
                    RegCloseKey(hkey);
                    goto SETFONT_DONE;
                }
                else
                {
                    g_pfont_table = _pfont_table;
                }
            }

            nSize = lstrlen(szFontFile);

            if (!MLStrCmpNI(&szFontFile[nSize-3], "fot", 3))
                _tcsncpy(&szFontFile[nSize-3], "ttf", 3);

            //
            // Trim off path 
            //
            // #335900, some third party apps write font file names to registry directly
            // and the names they used could have redundant font path 
            //
            pFontFile = szFontFile;

            while (nSize)
            {
                // Font file name contains only ASCII characters,
                // So, we can safely trim the path by backward searching '\'
                if (szFontFile[nSize] == TEXT('\\'))
                {
                    pFontFile = &szFontFile[nSize];
                    pFontFile++;
                    break;
                }
                nSize--;
            }

            GetFontURangeBits(szFontFile, &(g_pfont_table[count-1].dwUniSubRanges[0]));
            MLStrCpyN(g_pfont_table[count-1].szFaceName, &szFaceName[dwOffset], LF_FACESIZE);
            MLStrCpyN(g_pfont_table[count-1].szFileName, pFontFile, LF_FACESIZE);

        }
        if (pNewFaceName && (*pNewFaceName))
        {
            dwOffset = (DWORD)(pNewFaceName - &szFaceName[0]);
            goto FIND_NEXT_FACENAME;
        }
    }
#else
    // For UNIX, we don't have registry font information,
    // Let's create font table through EnumFontFamiliesEx.
    Table_info table_info;
    table_info.count = 1;
    table_info.table_size = table_size;

    int iRet;
    LOGFONT lf;
    lf.lfCharSet = DEFAULT_CHARSET; // give me all fonts
    lf.lfFaceName[0] = _T('\0');
    lf.lfPitchAndFamily = 0;
        
    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    iRet = EnumFontFamiliesEx(hDC, // Enum all fonts
                     &lf,
                     (FONTENUMPROC)UnixGetAllFontsProc,
                     (LPARAM)&table_info,
                     0);
    count = table_info.count;
    if (iRet == 0) // abort
    {
        bRet = FALSE;
        goto SETFONT_DONE;    
    }
#endif // UNIX

    // Release un-used memory
    pFontTable = (FONTINFO *)LocalReAlloc(g_pfont_table, (count)*sizeof(FONTINFO), LMEM_MOVEABLE);

    if (pFontTable)
    {
        g_pfont_table = pFontTable;
    }

    // Save TrueType font number
    g_pfont_table[0].dwCodePages[0] = count-1;

#ifndef UNIX
    // Unix doesn't have this number.
    // Save total font number for font change verification 
    g_pfont_table[0].dwCodePages[1] = dwFonts;

    RegCloseKey(hkey);
#endif

    if (count > 1)
        SetFontScripts();

SETFONT_DONE:    

    if (hDC)
        ReleaseDC(hWnd, hDC);

    if (count <= 1)
    {
        if (g_pfont_table)
        {
            LocalFree(g_pfont_table);
            g_pfont_table = NULL;
        }

        bRet = FALSE;
    }

    return bRet;

}


HRESULT CMLFLink2::CFontMappingCache2::SaveFontDataFile(void)
{
    FONTDATAHEADER fileHeader;
    HRESULT hr = E_FAIL;
    int     *pTmpBuf = NULL;
    HANDLE  hFile = NULL;
    int     i, j, Count = 0;
    DWORD   dwSize;
    FONTDATATABLE fontInfoTable, fontIndexTable;


    hFile = CreateFile( szFontDataFilePath,         
                        GENERIC_WRITE,          
                        0,                      
                        NULL,                   
                        CREATE_ALWAYS,          
                        FILE_ATTRIBUTE_HIDDEN,
                        NULL);                 

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto SAVE_FONT_DATA_DONE;
    }


    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        Count += (g_urange_table[i].nFonts+1);
    }


    // Create file header
    lstrcpynA(fileHeader.FileSig, FONT_DATA_SIGNATURE, sizeof(fileHeader.FileSig));
    fileHeader.dwVersion = 0x00010000;

    // Use file size as CheckSum
    fileHeader.dwCheckSum = sizeof(FONTINFO)*(g_pfont_table[0].dwCodePages[0]+1)+Count*sizeof(int)+
         + sizeof(FONTDATAHEADER) + sizeof(FONTDATATABLE)*FONTDATATABLENUM;
    fileHeader.nTable = FONTDATATABLENUM;


    pTmpBuf = (int *)LocalAlloc(LPTR, Count*sizeof(int));

    if (!pTmpBuf)
         goto SAVE_FONT_DATA_DONE;

    // Get font index data
    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        *pTmpBuf++ = g_urange_table[i].nFonts;

        if (g_urange_table[i].nFonts)
        {
            for (j = 0; j< g_urange_table[i].nFonts; j++)
            {
                *pTmpBuf++ = *(g_urange_table[i].pFontIndex+j);
            }
        }
    }

    pTmpBuf -= Count;

    // Create Dir tables
    lstrcpynA(fontInfoTable.szName, "fnt", sizeof(fontInfoTable.szName));
    fontInfoTable.dwOffset = sizeof(FONTDATAHEADER) + sizeof(FONTDATATABLE)*FONTDATATABLENUM;
    fontInfoTable.dwSize = sizeof(FONTINFO)*(g_pfont_table[0].dwCodePages[0]+1);

    lstrcpynA(fontIndexTable.szName, "idx", sizeof(fontIndexTable.szName));
    fontIndexTable.dwOffset = fontInfoTable.dwSize+fontInfoTable.dwOffset;
    fontIndexTable.dwSize = Count*sizeof(int);

    if (WriteFile(hFile, &fileHeader, sizeof(FONTDATAHEADER), &dwSize, NULL) &&
        WriteFile(hFile, &fontInfoTable, sizeof(FONTDATATABLE), &dwSize, NULL) &&
        WriteFile(hFile, &fontIndexTable, sizeof(FONTDATATABLE), &dwSize, NULL) &&
        WriteFile(hFile, g_pfont_table, fontInfoTable.dwSize, &dwSize, NULL) &&
        WriteFile(hFile, pTmpBuf, fontIndexTable.dwSize, &dwSize, NULL))
    {
        hr = S_OK;
    }

SAVE_FONT_DATA_DONE:
    if (hFile)
        CloseHandle(hFile);
    if (pTmpBuf)
        LocalFree(pTmpBuf);

    return hr;
}

HRESULT CMLFLink2::CFontMappingCache2::LoadFontDataFile(void)
{
    HANDLE  hFontData = NULL;
    HANDLE  hFileMap = NULL;
    LPVOID  lpvFile = NULL;
    int *   lp;
    HRESULT hr = E_FAIL;
    DWORD   dwFileSize;

    int     i, j;
    HKEY    hKey = NULL;
    DWORD   nFonts;
    FONTDATAHEADER *pHeader;
    FONTDATATABLE *pfTable;


    hFontData = CreateFile(szFontDataFilePath,  
                        GENERIC_READ,           
                        FILE_SHARE_READ,        
                        NULL,                   
                        OPEN_EXISTING,          
                        FILE_ATTRIBUTE_NORMAL,  
                        NULL);                  

    if (hFontData == INVALID_HANDLE_VALUE)
        return EnsureFontTable(TRUE);

    dwFileSize = GetFileSize(hFontData, NULL);

    hFileMap = CreateFileMapping(
                  hFontData,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hFileMap == NULL)
    {
        goto Load_File_Done;
    }

    lpvFile = MapViewOfFile(
                  hFileMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if (lpvFile == NULL)
    {        
        goto Load_File_Done;
    }

    pHeader = (FONTDATAHEADER *)lpvFile;

    // Check mlang font cache file by signature and checksum
    if (lstrcmpA(pHeader->FileSig, FONT_DATA_SIGNATURE) || pHeader->dwCheckSum != dwFileSize)
    {
        goto Load_File_Done;
    }


    if (S_OK != GetRegFontKey(&hKey, &nFonts))
    {
        goto Load_File_Done;
    }

    pfTable = (FONTDATATABLE *) ((LPBYTE)lpvFile + sizeof(FONTDATAHEADER));

    // Check if there is any font change (no guarantee, but works in most cases)
    if (nFonts != ((FONTINFO*)((LPBYTE)lpvFile + pfTable[0].dwOffset))->dwCodePages[1])
    {
        // If there is a change in system font number, we reload everything
        UnmapViewOfFile(lpvFile);
        CloseHandle(hFileMap);
        CloseHandle(hFontData);
        RegCloseKey(hKey);
        return EnsureFontTable(TRUE);
    }

    EnterCriticalSection(&g_cs);
    // Reset cache information
    if (g_pfont_table)
    {
        
        LocalFree(g_pfont_table);
        g_pfont_table = NULL;
        for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
        {
            if (g_urange_table[i].nFonts)
            {
                LocalFree(g_urange_table[i].pFontIndex);
                g_urange_table[i].pFontIndex = NULL;
                g_urange_table[i].nFonts = 0;
            }
        }        
    }


    if(!(g_pfont_table = (FONTINFO *) (LocalAlloc(LPTR, pfTable[0].dwSize))))
    {
        LeaveCriticalSection(&g_cs);        
        hr = E_OUTOFMEMORY;
        goto Load_File_Done;
    }

    CopyMemory(g_pfont_table, (LPBYTE)lpvFile + pfTable[0].dwOffset, pfTable[0].dwSize);

    lp = (int *)((LPBYTE)lpvFile + pfTable[1].dwOffset);

    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts = *lp++)
        {
            //g_urange_table[i].nFonts = *lp++;
            g_urange_table[i].pFontIndex = (int *)LocalAlloc(LPTR, sizeof(int)*g_urange_table[i].nFonts);
            for (j = 0; j<  g_urange_table[i].nFonts; j++)
            {
                g_urange_table[i].pFontIndex[j] = *lp++;
            }
        }
    }

    LeaveCriticalSection(&g_cs);

    hr = S_OK;

Load_File_Done:
    if (lpvFile)
        UnmapViewOfFile(lpvFile);
    if (hFileMap)
        CloseHandle(hFileMap);
    if (hFontData)
        CloseHandle(hFontData);
    if (hKey)
        RegCloseKey(hKey);

    return hr;

}


HRESULT CMLFLink2::CFontMappingCache2::SetFontUnicodeRanges(void)
{
    TCHAR   szFontPath[MAX_PATH];
    TCHAR   szFont[MAX_PATH];
    HRESULT hr = S_OK;
    int     i;
    int     *pInt;
    

    EnterCriticalSection(&g_cs);
    g_pfont_table[0].szFaceName[0] = 1;
    LeaveCriticalSection(&g_cs);
    
    MLGetWindowsDirectory(szFontPath, MAX_PATH);
    MLPathCombine(szFontPath, ARRAYSIZE(szFontPath), szFontPath, FONT_FOLDER);

    for (i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
    {
        MLPathCombine(szFont, ARRAYSIZE(szFont), szFontPath, g_pfont_table[i].szFileName);
        GetNonCpFontUnicodeRanges(szFont, i);
    }

    // Release un-used memory
    for (i=0; i< ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts)
        {
            pInt = (int *)LocalReAlloc(g_urange_table[i].pFontIndex, g_urange_table[i].nFonts*sizeof(int), LMEM_MOVEABLE);
            
            if (pInt)
            {
                g_urange_table[i].pFontIndex = pInt;
            }
        }
    }

    return hr;
}

STDMETHODIMP CMLFLink2::GetStrCodePages(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);
    ASSERT_WRITE_PTR_OR_NULL(pcchCodePages);

    HRESULT hr = S_OK;
    long cchCodePages = 0;
    DWORD dwStrCodePages = (DWORD)~0;
    BOOL fInit = FALSE;
    BOOL fNoPri = FALSE;

    if (!pszSrc || cchSrc <= 0) // We can't make dwStrCodePages when cchSrc is zero
        hr = E_INVALIDARG;

    if (!m_pIMLFLnk)
        return E_OUTOFMEMORY;

    while (SUCCEEDED(hr) && cchSrc > 0)
    {
        DWORD dwCharCodePages;

        if (SUCCEEDED(hr = m_pIMLFLnk->GetCharCodePages(*pszSrc, &dwCharCodePages)))
        {
            if (!fInit)
            {
                fInit = TRUE;
                fNoPri = !(dwPriorityCodePages & dwCharCodePages);
            }
            else if (fNoPri != !(dwPriorityCodePages & dwCharCodePages))
            {
                break;
            }
            if (!fNoPri)
                dwPriorityCodePages &= dwCharCodePages;

            if (dwCharCodePages && (dwCharCodePages & dwStrCodePages))
                dwStrCodePages &= dwCharCodePages;
            else
                break;

            pszSrc++;
            cchSrc--;
            cchCodePages++;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!cchCodePages)
        {
            dwStrCodePages = 0;
            cchCodePages++;
        }
        if (pcchCodePages)
            *pcchCodePages = cchCodePages;
        if (pdwCodePages)
            *pdwCodePages = dwStrCodePages;
    }
    else
    {
        if (pcchCodePages)
            *pcchCodePages = 0;
        if (pdwCodePages)
            *pdwCodePages = 0;
    }

    return hr;
}

STDMETHODIMP CMLFLink2::MapFont(HDC hDC, DWORD dwCodePages, WCHAR wchar, HFONT* phDestFont)
{
    HFONT hSrcFont = NULL;

    if (NULL == (hSrcFont = (HFONT) GetCurrentObject(hDC, OBJ_FONT)))
        return E_FAIL;

    if (dwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->MapFont(hDC, dwCodePages, hSrcFont, phDestFont);
        return E_OUTOFMEMORY;
    }
    else
    {
        if (!m_pFontMappingCache2)
            m_pFontMappingCache2 = new CFontMappingCache2;
        if (m_pFontMappingCache2)
            return m_pFontMappingCache2->MapFontFromCMAP(hDC, wchar, hSrcFont, phDestFont);
        else
            return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CMLFLink2::GetFontUnicodeRanges(HDC hDC, UINT *puiRanges, UNICODERANGE* pURanges)
{
    int     i;
    LOGFONT lf;
    HRESULT hr = E_FAIL;
    HFONT   hFont = NULL;

    if (!puiRanges)
        return E_INVALIDARG;

    if (!m_pFontMappingCache2)
        m_pFontMappingCache2 = new CFontMappingCache2;
    if (!m_pFontMappingCache2)
        return E_OUTOFMEMORY;

    if (!(hFont = (HFONT)GetCurrentObject(hDC, OBJ_FONT)))
        return hr;

    if (FAILED(m_pFontMappingCache2->EnsureFontTable(FALSE)))
        return hr;

    if (!GetObject(hFont, sizeof(LOGFONT), &lf))
        return hr;

    for (i=1; i<= (int) g_pfont_table[0].dwCodePages[0]; i++)
    {
        if (!lstrcmp(lf.lfFaceName, g_pfont_table[i].szFaceName))
            break;
    }

    if (i > (int) g_pfont_table[0].dwCodePages[0])
        return hr;

    return m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, puiRanges, pURanges);

}

STDMETHODIMP CMLFLink2::GetScriptFontInfo(SCRIPT_ID sid, DWORD dwFlags, UINT *puiFonts, SCRIPTFONTINFO* pScriptFont)
{
    HRESULT hr = E_FAIL;
    UINT    uiNum;
    BYTE    bPitch = dwFlags & SCRIPTCONTF_FIXED_FONT? FIXED_PITCH:VARIABLE_PITCH;


    if (!m_pFontMappingCache2)
        m_pFontMappingCache2 = new CFontMappingCache2;

    if (m_pFontMappingCache2)
        m_pFontMappingCache2->EnsureFontTable(FALSE);

    if (!g_pfont_table)
        return hr;


    if (!pScriptFont)
    {
        uiNum = g_pfont_table[0].dwCodePages[0];
    }
    else
    {
        uiNum = *puiFonts;    
    }

    *puiFonts = 0;

    // Binary search font table to match script id.
    for (UINT i=1; i<= g_pfont_table[0].dwCodePages[0]; i++)
    {
        // Check font pitch
        if (!(g_pfont_table[i].lf.lfPitchAndFamily & bPitch))
            continue;

        // Get sid bit mask
        SCRIPT_IDS sids = 1;
        sids <<= sid;

        if (sids & g_pfont_table[i].scripts)
        {
            // Bail out is required number reached
            if (*puiFonts >= uiNum)
            {
                break;
            }
            if (pScriptFont)
            {
                MultiByteToWideChar(CP_ACP, 0, g_pfont_table[i].szFaceName, -1, (pScriptFont + *puiFonts)->wszFont, MAX_MIMEFACE_NAME);
                (pScriptFont + *puiFonts)->scripts = g_pfont_table[i].scripts;
            }
            (*puiFonts)++;
        }
    }

    return S_OK;

}

// Map Windows code page to script id 
// if multiple script id exist, we'll return the default one
STDMETHODIMP CMLFLink2::CodePageToScriptID(UINT uiCodePage, SCRIPT_ID *pSid)
{
    MIMECPINFO  cpInfo;
    HRESULT     hr = E_FAIL;

    if (!pSid)
        return E_INVALIDARG;

    if (NULL != g_pMimeDatabase)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo)))
        {
            if (cpInfo.uiFamilyCodePage == CP_USER_DEFINED)
            {
                *pSid = sidUserDefined;
                hr = S_OK; 
            }
            else
                for (int i = 0; g_CharSetTransTable[i].uCodePage; i++)
                {
                    if (cpInfo.uiFamilyCodePage == g_CharSetTransTable[i].uCodePage)
                    {
                        *pSid = g_CharSetTransTable[i].sid[0];
                        hr = S_OK;
                        break;
                    }
                }            
        }
    }

    return hr;
}
        
CMLFLink2::CFontMappingCache2::CFontMappingCache2(void)
{
    if (GetSystemDirectory(szFontDataFilePath, MAX_PATH))
    {
        MLPathCombine(szFontDataFilePath, ARRAYSIZE(szFontDataFilePath), szFontDataFilePath, FONT_DATA_FILE_NAME);
    }
}

CMLFLink2::CFontMappingCache2::~CFontMappingCache2(void)
{
    EnterCriticalSection(&g_cs);

    if (g_pfont_table)
    {
        LocalFree(g_pfont_table); 
        g_pfont_table = NULL;
    }

    for (int i=0; i< ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts)
        {
            LocalFree(g_urange_table[i].pFontIndex);
            g_urange_table[i].nFonts = 0;
        }
    }

    LeaveCriticalSection(&g_cs);
}

int CALLBACK CMLFLink2::CFontMappingCache2::MapFontExEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{  
    if (FontType == TRUETYPE_FONTTYPE && plfFont->lfFaceName[0] != TEXT('@') )
    {
        CopyMemory(&g_pfont_table[*(int *)lParam].lf, plfFont, sizeof(LOGFONT));
        (*(int *)lParam)++;
        return 0;
    }
    return 1;
}

int CALLBACK CMLFLink2::CFontMappingCache2::SetFontScriptsEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{      
    if (FontType == TRUETYPE_FONTTYPE)
    {
        if (g_pfont_table)
        {
            for (int i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
                if (!MLStrCmpNI(plfFont->lfFaceName, g_pfont_table[i].szFaceName, LF_FACESIZE))
                {
                    SCRIPT_IDS scripts = 1;
                    scripts <<= lParam;
                    g_pfont_table[i].scripts |= scripts;
                    break;
                }

            if (i > (int)g_pfont_table[0].dwCodePages[0] && plfFont->lfFaceName[0] != TEXT('@'))        // GDI font not in current font table?
            {
                FONTINFO * pfont_table = NULL;

                pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, 
                                        sizeof(FONTINFO) * (g_pfont_table[0].dwCodePages[0]+2),
                                        LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (NULL != pfont_table)
                {
                    g_pfont_table = pfont_table;
                    g_pfont_table[0].dwCodePages[0]++;
                    MLStrCpyN(g_pfont_table[i].szFaceName, (char *)plfFont->lfFaceName, ARRAYSIZE(g_pfont_table[i].szFaceName));
                    CopyMemory(&g_pfont_table[i].lf, plfFont, sizeof(LOGFONT));

                    SCRIPT_IDS scripts = 1;
                    scripts <<= lParam;
                    g_pfont_table[i].scripts |= scripts;                    
                }
            }
        }
    }
    return 1;
}

int CALLBACK CMLFLink::VerifyFontSizeEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* ptm, DWORD FontType, LPARAM lParam)
{
    LOGFONT* plfSrcFont = (LOGFONT*)lParam;

    if (FontType != TRUETYPE_FONTTYPE)
    {
        LONG lHeight = ptm->tmInternalLeading - ptm->tmHeight;
        // Match source font's lfHeight to physical bitmap font's lfHeight
        if (lHeight < 0 && plfSrcFont->lfHeight < 0 && lHeight < plfSrcFont->lfHeight)
        {
            plfSrcFont->lfHeight = lHeight ;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlflink.h ===
// MLFLink.h : Declaration of the CMLFLink

#ifndef __MLFLINK_H_
#define __MLFLINK_H_

#include "mlatl.h"
#include "font.h"

#define NUMFONTMAPENTRIES 15

// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_FACEMAPPINGFAILURE      MAKE_HRESULT(1, FACILITY_MLSTR, 1001)


extern FONTINFO *g_pfont_table;


class CMultiLanguage;
class CMultiLanguage2;

// Code Page Table Cache
struct CCodePagesHeader
{
        DWORD m_dwID;
        DWORD m_dwVersion;
        DWORD m_dwFileSize;
        DWORD m_dwBlockSize;
        DWORD m_dwTableOffset;
        DWORD m_dwReserved;
        BYTE m_abCmdCode[8];
};

/////////////////////////////////////////////////////////////////////////////
// CMLFLink
class ATL_NO_VTABLE CMLFLink : 
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMLangFontLink
{
    friend void CMLangFontLink_FreeGlobalObjects(void);
    friend HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags);
    friend HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags);
    friend HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt);
    friend HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt);

public:
    CMLFLink(void);
    ~CMLFLink(void)
    {
        if (m_pFlinkTable)
            FreeFlinkTable();
        DllRelease();    
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLFLink)
        COM_INTERFACE_ENTRY(IMLangCodePages)
        COM_INTERFACE_ENTRY(IMLangFontLink)
    END_COM_MAP()

public:
// IMLangCodePages
    STDMETHOD(GetCharCodePages)(/*[in]*/ WCHAR chSrc, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(GetStrCodePages)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ DWORD dwPriorityCodePages, /*[out]*/ DWORD* pdwCodePages, /*[out]*/ long* pcchCodePages);
    STDMETHOD(CodePageToCodePages)(/*[in]*/ UINT uCodePage, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(CodePagesToCodePage)(/*[in]*/ DWORD dwCodePages, /*[in]*/ UINT uDefaultCodePage, /*[out]*/ UINT* puCodePage);
// IMLangFontLink
    STDMETHOD(GetFontCodePages)(/*[in]*/ HDC hDC, /*[in]*/ HFONT hFont, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(MapFont)(/*[in]*/ HDC hDC, /*[in]*/ DWORD dwCodePages, /*[in]*/ HFONT hSrcFont, /*[out]*/ HFONT* phDestFont);
    STDMETHOD(ReleaseFont)(/*[in]*/ HFONT hFont);
    STDMETHOD(ResetFontMapping)(void);

protected:
    static int CALLBACK GetFontCodePagesEnumFontProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD dwFontType, LPARAM lParam);

// MapFont() support functions
    class CFontMappingInfo
    {
    public:
        CFontMappingInfo(void) : hDestFont(NULL) {}
        ~CFontMappingInfo(void) {if (hDestFont) ::DeleteObject(hDestFont);}

        HDC hDC;
        int iCP;
        HFONT hDestFont;
        TCHAR szFaceName[LF_FACESIZE];
        LOGFONT lfSrcFont;
        LOGFONT lfDestFont;
        UINT auCodePage[32 + 1]; // +1 for end mark
        DWORD adwCodePages[32 + 1];
    };

    typedef HRESULT (CMLFLink::*PFNGETFACENAME)(CFontMappingInfo& fmi);

    HRESULT MapFontCodePages(CFontMappingInfo& fmi, PFNGETFACENAME pfnGetFaceName);
    static int CALLBACK MapFontEnumFontProc(const LOGFONT* lplf, const TEXTMETRIC*, DWORD, LPARAM lParam);
    HRESULT GetFaceNameRegistry(CFontMappingInfo& fmi);
    HRESULT GetFaceNameGDI(CFontMappingInfo& fmi);
    HRESULT GetFaceNameMIME(CFontMappingInfo& fmi);
    HRESULT GetFaceNameRealizeFont(CFontMappingInfo& fmi);
    HRESULT VerifyFaceMap(CFontMappingInfo& fmi);

// Font Mapping Cache
    class CFontMappingCache
    {
        class CFontMappingCacheEntry
        {
            friend class CFontMappingCache;

        protected:
            CFontMappingCacheEntry* m_pPrev;
            CFontMappingCacheEntry* m_pNext;

            int m_nLockCount;

            UINT m_uSrcCodePage;
            LONG m_lSrcHeight; 
            LONG m_lSrcWidth; 
            LONG m_lSrcEscapement; 
            LONG m_lSrcOrientation; 
            LONG m_lSrcWeight; 
            BYTE m_bSrcItalic; 
            BYTE m_bSrcUnderline; 
            BYTE m_bSrcStrikeOut; 
            BYTE m_bSrcPitchAndFamily; 
            TCHAR m_szSrcFaceName[LF_FACESIZE]; 

            HFONT m_hDestFont;
        };

    public:
        CFontMappingCache(void);
        ~CFontMappingCache(void);
        HRESULT FindEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT* phDestFont);
        HRESULT UnlockEntry(HFONT hDestFont);
        HRESULT AddEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT hDestFont);
        HRESULT FlushEntries(void);

    protected:
        CRITICAL_SECTION m_cs;
        CFontMappingCacheEntry* m_pEntries;
        CFontMappingCacheEntry* m_pFree;
        int m_cEntries;
    };

// Code Page Table Cache
    class CCodePagesCache
    {
    public:
        CCodePagesCache(void);
        ~CCodePagesCache(void);
        inline HRESULT Load(void);
        inline operator PBYTE(void) const;
        inline BYTE* GetCodePageBits(BOOL bCodePagesExt);

    protected:
        HRESULT RealLoad(void);

    protected:
        CRITICAL_SECTION m_cs;
        BYTE* m_pbBuf;
        BYTE* m_pbBufExt;
    };

    static CFontMappingCache* m_pFontMappingCache;
    static CCodePagesCache* m_pCodePagesCache;

    // For NT5 system font link
    typedef struct tagFLinkFont {    
        WCHAR   szFaceName[LF_FACESIZE];
        LPWSTR  pmszFaceName;
    } FLINKFONT, *PFLINKFONT;
    
    UINT m_uiFLinkFontNum;
    PFLINKFONT m_pFlinkTable;

    void FreeFlinkTable(void);
    HRESULT CreateNT5FontLinkTable(void);
    HRESULT GetNT5FLinkFontCodePages(HDC hDC, LOGFONTW* plfEnum, DWORD * lpdwCodePages);
    static int CALLBACK GetFontCodePagesEnumFontProcW(const LOGFONTW *lplf, const TEXTMETRICW *lptm, DWORD dwFontType, LPARAM lParam);
    static int CALLBACK VerifyFontSizeEnumFontProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD dwFontType, LPARAM lParam);
};

class CMultiLanguage2;

class ATL_NO_VTABLE CMLFLink2 :
#ifdef UNIX // Unix VTable isn't portable, we need to use CMultiLanguage 
    public CComTearOffObjectBase<CMultiLanguage>,
#else 
    public CComTearOffObjectBase<CMultiLanguage2>,
#endif
    public IMLangFontLink2
{
    IMLangFontLink * m_pIMLFLnk;

public:
    BEGIN_COM_MAP(CMLFLink2)
        COM_INTERFACE_ENTRY(IMLangFontLink2)
    END_COM_MAP()

    CMLFLink2(void)
    {
        DllAddRef();
        CComCreator< CComPolyObject< CMLFLink > >::CreateInstance( NULL, IID_IMLangFontLink, (void **)&m_pIMLFLnk );
    }

    ~CMLFLink2(void)
    {
        if (m_pIMLFLnk)
        {
            m_pIMLFLnk->Release();
            m_pIMLFLnk = NULL;
        }
        DllRelease();
    }

// IMLangCodePages
    STDMETHOD(GetCharCodePages)(/*[in]*/ WCHAR chSrc, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->GetCharCodePages(chSrc, pdwCodePages);
        else
            return E_FAIL;
    }
    STDMETHOD(CodePageToCodePages)(/*[in]*/ UINT uCodePage, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->CodePageToCodePages(uCodePage, pdwCodePages);
        else
            return E_FAIL;
    }
    STDMETHOD(CodePagesToCodePage)(/*[in]*/ DWORD dwCodePages, /*[in]*/ UINT uDefaultCodePage, /*[out]*/ UINT* puCodePage)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->CodePagesToCodePage(dwCodePages, uDefaultCodePage, puCodePage);
        else
            return E_FAIL;
    }
// IMLangFontLink
    STDMETHOD(GetFontCodePages)(/*[in]*/ HDC hDC, /*[in]*/ HFONT hFont, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->GetFontCodePages(hDC, hFont, pdwCodePages);
        else
            return E_FAIL;
    }

    STDMETHOD(ReleaseFont)(/*[in]*/ HFONT hFont)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->ReleaseFont(hFont);
        else
            return E_FAIL;
    }

// IMLangFontLink2
    STDMETHOD(ResetFontMapping)(void);
    STDMETHOD(GetStrCodePages)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ DWORD dwPriorityCodePages, /*[out]*/ DWORD* pdwCodePages, /*[out]*/ long* pcchCodePages);
    STDMETHOD(MapFont)(/*[in]*/ HDC hDC, /*[in]*/ DWORD dwCodePages, /*[in]*/ WCHAR chSrc, /*[out]*/ HFONT* pFont);
    STDMETHOD(GetFontUnicodeRanges)(/*[in]*/ HDC hDC, /*[in,out]*/ UINT *puiRanges, /*[out]*/ UNICODERANGE* pUranges);
    STDMETHOD(GetScriptFontInfo)(SCRIPT_ID sid, DWORD dwFlags, UINT *puiFonts, SCRIPTFONTINFO* pScriptFont);
    STDMETHOD(CodePageToScriptID)(UINT uiCodePage, SCRIPT_ID *pSid);

// Font Mapping Cache2 for MapFont
    class CFontMappingCache2
    {
    protected:
        TCHAR   szFontDataFilePath[MAX_PATH];
    public:
        CFontMappingCache2(void);
        ~CFontMappingCache2(void);
        int fetchCharSet(BYTE *pCharset, int iURange);
        BOOL GetNonCpFontUnicodeRanges(TCHAR *szFontName, int iFontIndex);
        BOOL SetFontScripts(void);
        BOOL SetFontTable(void);
        BOOL GetFontURangeBits(TCHAR *szFontName, DWORD *pdwURange);
        BOOL IsFontUpdated(void);
        HRESULT UnicodeRanges(LPTSTR pszFont, UINT *puiRanges, UNICODERANGE* pURanges);
        HRESULT SetFontUnicodeRanges(void);
        HRESULT MapFontFromCMAP(HDC hDC, WCHAR wchar, HFONT hSrcFont, HFONT *phDestFont);
        HRESULT LoadFontDataFile(void);
        HRESULT SaveFontDataFile(void);
        HRESULT EnsureFontTable(BOOL bUpdateURangeTable);
        static int CALLBACK MapFontExEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);
        static int CALLBACK SetFontScriptsEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);
    };

    static CFontMappingCache2* m_pFontMappingCache2;
};

/////////////////////////////////////////////////////////////////////////////
// CMLFLink inline functions

HRESULT CMLFLink::CCodePagesCache::Load(void)
{
    if (m_pbBuf && m_pbBufExt)
        return S_OK;
    else
        return RealLoad();
}

BYTE * CMLFLink::CCodePagesCache::GetCodePageBits(BOOL bCodePagesExt)
{
    if (bCodePagesExt)
        return m_pbBufExt;
    else
        return m_pbBuf;
}

CMLFLink::CCodePagesCache::operator PBYTE(void) const
{
    return m_pbBuf;
}

#endif //__MLFLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mllbcons.h ===
// MLLBCons.h : Declaration of the CMLLBCons

#ifndef __MLLBCONS_H_
#define __MLLBCONS_H_

#include "mlatl.h"

class CMultiLanguage;

/////////////////////////////////////////////////////////////////////////////
// CMLLBCons
class ATL_NO_VTABLE CMLLBCons :
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMLangLineBreakConsole
{
public:
    CMLLBCons(void) 
    {
        DllAddRef();
        m_pMLStrClass = NULL;
    }
    ~CMLLBCons(void) 
    {
        if (m_pMLStrClass) 
            m_pMLStrClass->Release();
        DllRelease();    
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLLBCons)
        COM_INTERFACE_ENTRY(IMLangLineBreakConsole)
    END_COM_MAP()

public:
// IMLangLineBreakConsole
    STDMETHOD(BreakLineML)(/*[in]*/ IMLangString* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long cMinColumns, /*[in]*/ long cMaxColumns, /*[out]*/ long* plLineLen, /*[out]*/ long* plSkipLen);
    STDMETHOD(BreakLineW)(/*[in]*/ LCID locale, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ long cMaxColumns, /*[out]*/ long* pcchLine, /*[out]*/ long* pcchSkip);
    STDMETHOD(BreakLineA)(/*[in]*/ LCID locale, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ long cMaxColumns, /*[out]*/ long* pcchLine, /*[out]*/ long* pcchSkip);

protected:
    template <DWORD INFOTYPE, int CACHESIZE>
    class CCharType
    {
    public:
#ifdef ASTRIMPL
        inline CCharType(void);
#else
        inline CCharType(LCID locale);
#endif
        inline ~CCharType(void);
        inline void Flush(void);
#ifdef ASTRIMPL
        WORD GetCharType(IMLangString* pMLStr, long lPos, long lLen, HRESULT* phr = NULL);
#else
        WORD GetCharType(LPCWSTR psz, int cch);
#endif

    protected:
        LPWORD m_pwBuf;
#ifdef ASTRIMPL
        IMLangStringAStr* m_pMLStrAStr;
        long m_lPos;
        long m_lLen;
#else
        LPSTR m_pszConv;
        LPCWSTR m_psz;
        int m_cch;
        LCID m_locale;
        UINT m_uCodePage;
#endif
        WORD m_wHalfWidth;
    };

    HRESULT PrepareMLStrClass(void)
    {
        if (m_pMLStrClass)
            return S_OK;
        else
            return ::_Module.GetClassObject(CLSID_CMLangString, IID_IClassFactory, (void**)&m_pMLStrClass);
    }

    IClassFactory* m_pMLStrClass;
};

template <DWORD INFOTYPE, int CACHESIZE>
#ifdef ASTRIMPL
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::CCharType(void)
#else
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::CCharType(LCID locale)
#endif
{
#ifndef ASTRIMPL
    TCHAR szCodePage[8];
#endif

    m_pwBuf = NULL;
#ifdef ASTRIMPL
    m_pMLStrAStr = NULL;

    // TODO: Set m_wHaldWidth here.
    m_wHalfWidth = 0;
#else
    m_pszConv = NULL;
    m_locale = locale;
    ::GetLocaleInfo(m_locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage));
    m_uCodePage = _ttoi(szCodePage);

    CPINFO cpi;
    ::GetCPInfo(m_uCodePage, &cpi);
    m_wHalfWidth = (cpi.LeadByte[0]) ? 0 : C3_HALFWIDTH;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::~CCharType(void)
{
    if (m_pwBuf)
        delete[] m_pwBuf;
#ifdef ASTRIMPL
    if (m_pMLStrAStr)
        m_pMLStrAStr->Release();
#else
    if (m_pszConv)
        delete[] m_pszConv;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
void CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::Flush(void)
{
#ifdef ASTRIMPL
    m_lPos = 0;
    m_lLen = 0;
#else
    m_psz = NULL;
    m_cch = 0;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
#ifdef ASTRIMPL
WORD CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::GetCharType(IMLangString* pMLStr, long lPos, long lLen, HRESULT* phr)
#else
WORD CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::GetCharType(LPCWSTR psz, int cch)
#endif
{
#ifdef ASTRIMPL
    if (lPos >= m_lPos + m_lLen || lPos + lLen <= m_lPos)
#else
    if (psz < m_psz || psz >= m_psz + m_cch)
#endif
    {
#ifdef ASTRIMPL
        HRESULT hr;
#endif
        LPWORD pwCharType;
#ifdef ASTRIMPL
        WORD wCharType;
        CHAR* psz;
        long cch;
        LCID locale;
        UINT uCodePage;

        if (m_pMLStrAStr)
        {
            m_pMLStrAStr->Release();
            m_pMLStrAStr = NULL;
        }

        if (SUCCEEDED(hr = pMLStr->QueryInterface(IID_IMLangStringAStr, (void**)&m_pMLStrAStr)))
        {
            if (!m_pwBuf)
                m_pwBuf = new WORD[CACHESIZE];

            if (m_pwBuf)
            {
                pwCharType = m_pwBuf;
                cch = CACHESIZE;
            }
            else
            {
                pwCharType = &wCharType;
                cch = 1;
            }

            lLen = min(lLen, cch);

            if (SUCCEEDED(hr = m_pMLStrAStr->GetLocale(lPos, lLen, &locale, NULL, &lLen)) &&
                SUCCEEDED(hr = ::LocaleToCodePage(locale, &uCodePage)) &&
                SUCCEEDED(hr = m_pMLStrAStr->LockAStr(lPos, lLen, MLSTR_READ, uCodePage, 0, NULL, &psz, &cch, NULL)))
            {
                if (!::GetStringTypeExA(locale, INFOTYPE, psz, cch, pwCharType))
                    hr = E_FAIL; // NLS failed

                ASSIGN_IF_FAILED(hr, m_pMLStrAStr->UnlockAStr(psz, 0, NULL, NULL));
            }
        }

        if (phr)
            *phr = hr;

        if (SUCCEEDED(hr))
        {
            m_lPos = lPos;
            m_lLen = lLen;
            return pwCharType[0] | m_wHalfWidth;
        }
        else
        {
            m_lPos = 0;
            m_lLen = 0;
            return 0 | m_wHalfWidth;
        }
#else
        LPSTR pszConv;
        WORD wCharType = 0;
        CHAR szTemp[2];

        if (!m_pwBuf)
            m_pwBuf = new WORD[CACHESIZE];

        if (m_pwBuf)
        {
            pwCharType = m_pwBuf;
            cch = min(cch, CACHESIZE);
        }
        else
        {
            pwCharType = &wCharType;
            cch = 1;
        }

        if (!m_pszConv)
            m_pszConv = new CHAR[CACHESIZE * 2];

        if (m_pszConv)
        {
            pszConv = m_pszConv;
        }
        else
        {
            pszConv = szTemp;
            cch = 1;
        }

        if (m_pwBuf && m_pszConv)
        {
            m_psz = psz;
            m_cch = cch;
        }

        int cchTemp = ::WideCharToMultiByte(m_uCodePage, 0, psz, cch, pszConv, CACHESIZE * 2, NULL, NULL);
        ::GetStringTypeExA(m_locale, INFOTYPE, pszConv, cchTemp, pwCharType);

        return pwCharType[0] | m_wHalfWidth;
#endif
    }
    else
    {
#ifdef ASTRIMPL
        return m_pwBuf[lPos - m_lPos] | m_wHalfWidth;
#else
        return m_pwBuf[psz - m_psz] | m_wHalfWidth;
#endif
    }
}

#endif //__MLLBCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlmain.h ===
// MLMain.h : Declaration of the CMultiLanguage

#ifndef __MLMAIN_H_
#define __MLMAIN_H_

#include "mlflink.h"
#include "mllbcons.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiLanguage


class ATL_NO_VTABLE CMultiLanguage : 
    public CComObjectRoot,
    public CComCoClass<CMultiLanguage, &CLSID_CMultiLanguage>,
    public IMultiLanguage
{
    MIMECONTF       dwMimeSource;
    CMimeDatabase   *m_pMimeDatabase;

public:
    CMultiLanguage(void) 
    {
        DllAddRef();
        m_pMimeDatabase = new CMimeDatabase;
        dwMimeSource = MIMECONTF_MIME_IE4;
        if (m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(MIMECONTF_MIME_IE4);
    }
    ~CMultiLanguage(void)
    {    
        if (m_pMimeDatabase)
            delete m_pMimeDatabase;
        DllRelease();
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMultiLanguage)
        COM_INTERFACE_ENTRY(IMultiLanguage)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangCodePages, CMLFLink)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangFontLink, CMLFLink)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangFontLink2, CMLFLink2)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMultiLanguage2, CMultiLanguage2)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangLineBreakConsole, CMLLBCons)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMultiLanguage3, CMultiLanguage2)
    END_COM_MAP()

public:
// IMultiLanguage
    virtual STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    virtual STDMETHODIMP GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo);
    virtual STDMETHODIMP GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage);
    virtual STDMETHODIMP EnumCodePages(DWORD grfFlags, IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    virtual STDMETHODIMP IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding);
    virtual STDMETHODIMP ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringReset(void);
    virtual STDMETHODIMP GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766);
    virtual STDMETHODIMP GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766);
    virtual STDMETHODIMP EnumRfc1766(IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP GetRfc1766Info(LCID Locale, PRFC1766INFO pRfc1766Info);
    virtual STDMETHODIMP CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset);

};

class ATL_NO_VTABLE CMultiLanguage2 : 
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMultiLanguage3
{        
    IMultiLanguage  * m_pIML;
    MIMECONTF       dwMimeSource;
    CMimeDatabase   * m_pMimeDatabase;


public:

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMultiLanguage2)
        COM_INTERFACE_ENTRY(IMultiLanguage2)
        COM_INTERFACE_ENTRY(IMultiLanguage3)
    END_COM_MAP()

    CMultiLanguage2(void);    
    ~CMultiLanguage2(void);

    virtual STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    virtual STDMETHODIMP GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo);
    virtual STDMETHODIMP GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage);
    virtual STDMETHODIMP EnumCodePages(DWORD grfFlags, LANGID LangId, IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    virtual STDMETHODIMP IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding)
    {
        if (m_pIML)
            return m_pIML->IsConvertible(dwSrcEncoding, dwDstEncoding);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertString(lpdwMode, dwSrcEncoding, dwDstEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertStringToUnicode(lpdwMode, dwEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertStringFromUnicode(lpdwMode, dwEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringReset(void)
    {
        if (m_pIML)
            return m_pIML->ConvertStringReset();
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766)
    {
        if (m_pIML)
            return m_pIML->GetRfc1766FromLcid(Locale, pbstrRfc1766);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766)
    {
        if (m_pIML)
            return m_pIML->GetLcidFromRfc1766(pLocale, bstrRfc1766);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP EnumRfc1766(LANGID LangId, IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP GetRfc1766Info(LCID Locale, LANGID LangId, PRFC1766INFO pRfc1766Info);
    virtual STDMETHODIMP CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset)
    {
        if (m_pIML)
            return m_pIML->CreateConvertCharset(uiSrcCodePage, uiDstCodePage, dwProperty, ppMLangConvertCharset);
        else
            return E_FAIL;
    }

    virtual STDMETHODIMP ConvertStringInIStream(LPDWORD lpdwMode, DWORD dwFlag, WCHAR *lpFallBack, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut);
    virtual STDMETHODIMP ConvertStringToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag=0, WCHAR *lpFallBack = NULL);
    virtual STDMETHODIMP ConvertStringFromUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag=0, WCHAR *lpFallBack = NULL);
    virtual STDMETHODIMP DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores);
    virtual STDMETHODIMP DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores);

    virtual STDMETHODIMP ValidateCodePage(UINT uiCodePage, HWND hwnd);
    virtual STDMETHODIMP GetCodePageDescription(UINT uiCodePage, LCID lcid, LPWSTR lpWideCharStr,  int cchWideChar);
    virtual STDMETHODIMP IsCodePageInstallable(UINT uiCodePage);
    virtual STDMETHODIMP SetMimeDBSource(MIMECONTF dwSource);
    virtual STDMETHODIMP GetNumberOfScripts(UINT *pnScripts);
    virtual STDMETHODIMP EnumScripts(DWORD dwFlags, LANGID LangId, IEnumScript **ppEnumScript);
    
    virtual STDMETHODIMP ValidateCodePageEx(UINT uiCodePage, HWND hwnd, DWORD dwfIODControl);
    virtual STDMETHODIMP DetectOutboundCodePage(DWORD dwFlags, LPCWSTR lpWideCharStr, UINT cchWideChar, UINT* puiPreferredCodePages, UINT nPreferredCodePages, UINT* puiDetectedCodePages, UINT* pnDetectedCodePages, WCHAR* lpSpecialChar);
    virtual STDMETHODIMP DetectOutboundCodePageInIStream(DWORD dwFlags, IStream* pStrIn, UINT* puiPreferredCodePages, UINT nPreferredCodePages, UINT* puiDetectedCodePages, UINT* pnDetectedCodePages, WCHAR* lpSpecialChar);
protected:
    HRESULT EnsureIEStatus(void);
    class CIEStatus
    {
    public:
        CIEStatus(void) { _IEFlags.fJITDisabled = FALSE;}
        HRESULT Init(void);
        BOOL IsJITEnabled(void) 
        { 
            return !_IEFlags.fJITDisabled;
        }
    protected:
        struct {
            BOOL fJITDisabled:1;
        } _IEFlags;
    };
    CIEStatus *m_pIEStat;
};

#endif //__MLMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstra.cpp ===
// MLStrA.cpp : Implementation of CMLStrA
#include "private.h"

#ifndef NEWMLSTR

#include "mlstr.h"
#ifdef ASTRIMPL
#include "mlswalk.h"
#include "mlsbwalk.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStrA

#ifdef ASTRIMPL
CMLStrA::CMLStrA(void) :
    m_pMLCPs(NULL)
{
    DllAddRef();
}

CMLStrA::~CMLStrA(void)
{
    if (m_pMLCPs)
        m_pMLCPs->Release();
    DllRelease();
}
#endif

STDMETHODIMP CMLStrA::Sync(BOOL fNoAccess)
{
    ASSERT_THIS;
    return GetOwner()->Sync(fNoAccess);
}

STDMETHODIMP CMLStrA::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrA::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrA::GetMLStr(long lSrcPos, long lSrcLen, IUnknown* pUnkOuter, DWORD dwClsContext, const IID* piid, IUnknown** ppDestMLStr, long* plDestPos, long* plDestLen)
{
    ASSERT_THIS;
    return GetOwner()->GetMLStr(lSrcPos, lSrcLen, pUnkOuter, dwClsContext, piid, ppDestMLStr, plDestPos, plDestLen);
}

STDMETHODIMP CMLStrA::SetAStr(long lDestPos, long lDestLen, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(TRUE, pOwner, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (pOwner->GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (uCodePage == CP_ACP)
            uCodePage = g_uACP;

        if (pMLStrBufA && uCodePage == pOwner->GetCodePage())
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufA->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenA(uCodePage, pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(CHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = pOwner->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                CMLStrWalkW StrWalk(pMLStrW, lDestPos, lDestLen, MLSTR_WRITE, (pcchActual || plActualLen));

                cchActual = 0;
                lActualLen = 0;
                while (StrWalk.Lock(hr))
                {
                    long cchWrittenA;
                    long lWrittenLen;

                    if (SUCCEEDED(hr = pOwner->ConvAStrToWStr(uCodePage, pszSrc, cchSrc, StrWalk.GetStr(), StrWalk.GetCCh(), &cchWrittenA, NULL, &lWrittenLen)))
                    {
                        pszSrc += cchWrittenA;
                        cchSrc -= cchWrittenA;
                        cchActual += cchWrittenA;
                        lActualLen += lWrittenLen;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                pMLStrW->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::SetStrBufA(long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufA* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->SetStrBufCommon(this, lDestPos, lDestLen, uCodePage, NULL, pSrcBuf, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrA::GetAStr(long lSrcPos, long lSrcLen, UINT uCodePageIn, UINT* puCodePageOut, CHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
#ifdef ASTRIMPL
    CMLStr::CLock Lock(FALSE, pOwner, hr);
#endif
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

#ifndef ASTRIMPL
    if (SUCCEEDED(hr = m_pOwner->CheckThread()) &&
        (m_pOwner->IsLocked() || puCodePageOut || uCodePageIn != m_pOwner->GetCodePage())) // !ASTRIMPL
    {
        hr = E_INVALIDARG;
    }
#endif

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
#ifdef ASTRIMPL
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (uCodePageIn == CP_ACP)
            uCodePageIn = g_uACP;

        if (pMLStrBufA && (puCodePageOut || uCodePageIn == pOwner->GetCodePage()))
        {
            uCodePageIn = pOwner->GetCodePage();

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenA(uCodePageIn, BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(CHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = pOwner->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                BOOL fDontHaveCodePageIn = (puCodePageOut != 0);
                CMLStrWalkW StrWalk(pMLStrW, lSrcPos, lSrcLen, (pcchActual || plActualLen));

                cchActual = 0;
                while (StrWalk.Lock(hr))
                {
                    LCID locale;
                    UINT uLocaleCodePage;
                    DWORD dwLocaleCodePages;
                    DWORD dwStrCodePages;
                    long cchWritten;
                    long lWrittenLen;

                    if (fDontHaveCodePageIn &&
                        SUCCEEDED(hr = pOwner->GetLocale(lSrcPos, lSrcLen, &locale, NULL, NULL)) &&
                        SUCCEEDED(hr = ::LocaleToCodePage(locale, &uLocaleCodePage)) &&
                        SUCCEEDED(hr = PrepareMLangCodePages()) &&
                        SUCCEEDED(hr = GetMLangCodePages()->CodePageToCodePages(uLocaleCodePage, &dwLocaleCodePages)) &&
                        SUCCEEDED(hr = GetMLangCodePages()->GetStrCodePages(StrWalk.GetStr(), StrWalk.GetCCh(), dwLocaleCodePages, &dwStrCodePages, NULL)))
                    {
                        fDontHaveCodePageIn = FALSE;
                        hr = GetMLangCodePages()->CodePagesToCodePage(dwStrCodePages, uLocaleCodePage, &uCodePageIn);
                    }

                    if (SUCCEEDED(hr) &&
                        SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePageIn, StrWalk.GetStr(), StrWalk.GetCCh(), pszDest, cchDest, &cchWritten, NULL, &lWrittenLen)))
                    {
                        pszDest += cchWritten;
                        cchDest -= cchWritten;
                        cchActual += cchWritten;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                lActualLen = StrWalk.GetDoneLen();

                pMLStrW->Release();
            }
        }
    }
#else
        if (pszDest)
        {
            hr = E_FAIL; // TODO: Not implemented in this version
        }
        else
        {
            cchActual = cchSrcLen;
        }
    }

    if (SUCCEEDED(hr) && plActualLen)
        hr = m_pOwner->CalcLenA(m_pOwner->GetCodePage(), 0, cchActual, &lActualLen);
#endif

    if (SUCCEEDED(hr))
    {
#ifdef ASTRIMPL
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
#endif
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (puCodePageOut)
            *puCodePageOut = 0;
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrA::GetStrBufA(long lSrcPos, long lSrcMaxLen, UINT* puDestCodePage, IMLangStringBufA** ppDestBuf, long* plDestLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puDestCodePage);
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    IMLangStringBufA* pMLStrBufA;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufA = pOwner->GetMLStrBufA();
        if (!pMLStrBufA)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (puDestCodePage)
            *puDestCodePage = pOwner->GetCodePage();
        if (ppDestBuf)
        {
            pMLStrBufA->AddRef();
            *ppDestBuf = pMLStrBufA;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (puDestCodePage)
            *puDestCodePage = 0;
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::LockAStr(long lSrcPos, long lSrcLen, long lFlags, UINT uCodePageIn, long cchRequest, UINT* puCodePageOut, CHAR** ppszDest, long* pcchDest, long* plDestLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(lFlags & MLSTR_WRITE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    CHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~pOwner->GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();
        fDirectLock = (pMLStrBufA && (puCodePageOut || uCodePageIn == pOwner->GetCodePage()));

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (puCodePageOut)
                hr = GetAStr(lSrcPos, lSrcLen, 0, &uCodePageIn, NULL, 0, NULL, NULL);

            if (SUCCEEDED(hr) &&
                cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufA->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                pOwner->SetBufCCh(pOwner->GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufA->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = pOwner->CalcLenA(uCodePageIn, pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = pOwner->CalcBufSizeA(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = pOwner->MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && ((lFlags & MLSTR_READ) || puCodePageOut))
                hr = GetAStr(lSrcPos, lSrcLen,  uCodePageIn, (puCodePageOut) ? &uCodePageIn : NULL, (lFlags & MLSTR_READ) ? pszBuf : NULL, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = pOwner->GetLockInfo()->Lock((fDirectLock) ? pOwner->UnlockAStrDirect : pOwner->UnlockAStrIndirect, lFlags, uCodePageIn, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                pOwner->GetMLStrBufA()->UnlockBuf(pszBuf, 0, 0);
            else
                pOwner->MemFree(pszBuf);
        }

        if (puCodePageOut)
            *puCodePageOut = 0;
        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::UnlockAStr(const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return GetOwner()->UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;
    return GetOwner()->SetLocale(lDestPos, lDestLen, locale);
}

STDMETHODIMP CMLStrA::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLocale(lSrcPos, lSrcMaxLen, plocale, plLocalePos, plLocaleLen);
}

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrA

CMLStrA::CMLStrA(void) :
    m_pAttrAStr(NULL),
    m_pAttrLocale(NULL),
    m_dwAttrAStrCookie(NULL),
    m_dwAttrLocaleCookie(NULL)
{
    DllAddRef();
    ::InitializeCriticalSection(&m_cs);
}

CMLStrA::~CMLStrA(void)
{
    if (m_dwAttrLocaleCookie)
        GetOwner()->UnregisterAttr(m_dwAttrLocaleCookie);
    if (m_dwAttrAStrCookie)
        GetOwner()->UnregisterAttr(m_dwAttrAStrCookie);
    if (m_pAttrLocale)
        m_pAttrLocale->Release();
    if (m_pAttrAStr)
        m_pAttrAStr->Release();

    ::DeleteCriticalSection(&m_cs);
    DllRelease();
}

HRESULT CMLStrA::GetAttrAStrReal(IMLStrAttrAStr** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrAStr)
    {
        IMLStrAttrAStr* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrAStr, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrAStrCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrAStr, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrAStr = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrAStr;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLStrA::GetAttrLocaleReal(IMLStrAttrLocale** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrLocale)
    {
        IMLStrAttrLocale* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrLocale, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrLocaleCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrLocale, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrLocale = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrLocale;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

STDMETHODIMP CMLStrA::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->LockMLStr(lPos, lLen, dwFlags, pdwCookie, plActualPos, plActualLen);
}

STDMETHODIMP CMLStrA::UnlockMLStr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnlockMLStr(dwCookie);
}

STDMETHODIMP CMLStrA::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrA::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrA::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    return GetOwner()->RegisterAttr(pUnk, pdwCookie);
}

STDMETHODIMP CMLStrA::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnregisterAttr(dwCookie);
}

STDMETHODIMP CMLStrA::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    return GetOwner()->EnumAttr(ppEnumUnk);
}

STDMETHODIMP CMLStrA::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    return GetOwner()->FindAttr(riid, lParam, ppUnk);
}

STDMETHODIMP CMLStrA::SetAStr(long lDestPos, long lDestLen, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetAStr(lDestPos, lDestLen, uCodePage, pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::SetStrBufA(long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufA* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetStrBufA(lDestPos, lDestLen, uCodePage, pSrcBuf, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::GetAStr(long lSrcPos, long lSrcLen, UINT uCodePageIn, UINT* puCodePageOut, CHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetAStr(lSrcPos, lSrcLen, uCodePageIn, puCodePageOut, pszDest, cchDest, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::GetStrBufA(long lSrcPos, long lSrcMaxLen, UINT* puDestCodePage, IMLangStringBufA** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetStrBufA(lSrcPos, lSrcMaxLen, puDestCodePage, ppDestBuf, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrA::LockAStr(long lSrcPos, long lSrcLen, long lFlags, UINT uCodePageIn, long cchRequest, UINT* puCodePageOut, CHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->LockAStr(lSrcPos, lSrcLen, lFlags, uCodePageIn, cchRequest, puCodePageOut, ppszDest, pcchDest, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrA::UnlockAStr(const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->UnlockAStr(pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetLong(lDestPos, lDestLen, (long)locale);

    return hr;
}

STDMETHODIMP CMLStrA::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetLong(lSrcPos, lSrcMaxLen, (long*)plocale, plLocalePos, plLocaleLen);

    return hr;
}

#endif NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstr.h ===
#ifndef NEWMLSTR

// MLStr.h : Declaration of the CMLStr

#ifndef __MLSTR_H_
#define __MLSTR_H_

#ifdef ASTRIMPL
#include "mlstrw.h"
#endif
#include "mlstra.h"
#ifdef ASTRIMPL
#include "mlstrbuf.h"
#endif

#define MAX_LOCK_COUNT                  4

// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_ACCESSDENIED            MAKE_HRESULT(1, FACILITY_MLSTR, 1002)
#define MLSTR_E_TOOMANYNESTOFLOCK       MAKE_HRESULT(1, FACILITY_MLSTR, 1003)
#define MLSTR_E_STRBUFNOTAVAILABLE      MAKE_HRESULT(1, FACILITY_MLSTR, 1004)

/////////////////////////////////////////////////////////////////////////////
// CMLStr
class ATL_NO_VTABLE CMLStr :
    public CComObjectRoot,
    public CComCoClass<CMLStr, &CLSID_CMLangString>,
#ifdef ASTRIMPL
    public IMLangString
#else
    public IMLangStringWStr
#endif
{
    typedef HRESULT (CMLStr::*PFNUNLOCKPROC)(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);

public:
    CMLStr(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStr)
        COM_INTERFACE_ENTRY(IMLangString)
#ifdef ASTRIMPL
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringWStr, CMLStrW)
#else
        COM_INTERFACE_ENTRY(IMLangStringWStr)
#endif
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringAStr, CMLStrA)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
#ifndef ASTRIMPL
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
#endif
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

#ifdef ASTRIMPL
protected:
    class CLockInfo
    {
    protected:
        class CLockInfoEntry
        {
        public:
            void* m_psz;
            PFNUNLOCKPROC m_pfnUnlockProc;
            long m_lFlags;
            UINT m_uCodePage;
            long m_lPos;
            long m_lLen;
            long m_cchPos;
            long m_cchLen;
        };

    public:
        CLockInfo(CMLStr* pMLStr) : m_pMLStr(pMLStr)
        {
            m_nLockCount = 0;
            m_pLockArray = NULL;
        }
        ~CLockInfo(void)
        {
            UnlockAll();
        }
        HRESULT UnlockAll(void);
        HRESULT StartLock(BOOL fWrite)
        {
            if (fWrite && !m_nLockCount)
                m_nLockCount = -1; // Negative means write lock
            else if (!fWrite && m_nLockCount >= 0)
                m_nLockCount++;
            else
                return MLSTR_E_ACCESSDENIED;
            return S_OK;
        }
        HRESULT EndLock(BOOL fWrite)
        {
            ASSERT(m_nLockCount);
            if (fWrite)
                m_nLockCount = 0;
            else
                m_nLockCount--;
            return S_OK;
        }
        HRESULT Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen);
        HRESULT Find(const void* psz, long cch, void** ppKey);
        HRESULT Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen);
        long GetFlags(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lFlags;}
        UINT GetCodePage(void* pKey) {return ((CLockInfoEntry*)pKey)->m_uCodePage;}
        long GetPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lPos;}
        long GetLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lLen;}
        long GetCChPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchPos;}
        long GetCChLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchLen;}

    protected:
        CMLStr* const m_pMLStr;
        int m_nLockCount;
        CLockInfoEntry* m_pLockArray;
    };

    class CMLStrBufStandardW : public CMLStrBufW
    {
    protected:
        LPVOID MemAlloc(ULONG cb) {return ::CoTaskMemAlloc(cb);}
        LPVOID MemRealloc(LPVOID pv, ULONG cb) {return ::CoTaskMemRealloc(pv, cb);}
        void MemFree(LPVOID pv) {::CoTaskMemFree(pv);}
        long RoundBufSize(long cchStr);
    };
#endif

public:
// Called from CMLStrW and CMLStrA
#ifdef ASTRIMPL
    class CLock
    {
    public:
        CLock(BOOL fWrite, CMLStr* pMLStr, HRESULT& hr) : m_fWrite(fWrite), m_pMLStr(pMLStr) {m_fLocked = (SUCCEEDED(hr) && SUCCEEDED(hr = m_pMLStr->GetLockInfo()->StartLock(m_fWrite)));}
        ~CLock(void) {if (m_fLocked) m_pMLStr->GetLockInfo()->EndLock(m_fWrite);}
        HRESULT FallThrough(void) {m_fLocked = FALSE; return S_OK;} // Don't call EndLock in destructor
    protected:
        const BOOL m_fWrite;
        CMLStr* const m_pMLStr;
        BOOL m_fLocked;
    };
#endif

    HRESULT PrepareMLStrBuf(void);
    HRESULT SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen);
#ifdef ASTRIMPL
    HRESULT UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
#endif
    HRESULT CheckThread(void) {return (m_dwThreadID == ::GetCurrentThreadId()) ? S_OK : E_FAIL;}
    HRESULT RegularizePosLen(long* plPos, long* plLen);
    HRESULT GetLen(long cchOffset, long cchLen, long* plLen);
    HRESULT GetCCh(long cchOffset, long lLen, long* pcchLen);
    static HRESULT CalcLenW(const WCHAR*, long cchLen, long* plLen) {if (plLen) *plLen = cchLen; return S_OK;}
    static HRESULT CalcLenA(UINT uCodePage, const CHAR*,  long cchLen, long* plLen);
    static HRESULT CalcCChW(const WCHAR*, long lLen, long* pcchLen) {if (pcchLen) *pcchLen = lLen; return S_OK;}
    static HRESULT CalcCChA(UINT uCodePage, const CHAR*,  long lLen, long* pcchLen);
    static HRESULT CalcBufSizeW(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen; return S_OK;}
    static HRESULT CalcBufSizeA(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen * 2; return S_OK;}
    static HRESULT ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    static HRESULT ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    IMLangStringBufW* GetMLStrBufW(void) const {return m_pMLStrBufW;}
    void SetMLStrBufW(IMLangStringBufW* pBuf) {m_pMLStrBufW = pBuf;}
    IMLangStringBufA* GetMLStrBufA(void) const {return m_pMLStrBufA;}
    void SetMLStrBufA(IMLangStringBufA* pBuf) {m_pMLStrBufA = pBuf;}
    UINT GetCodePage(void) const {return m_uCodePage;}
    void SetCodePage(UINT uCodePage) {m_uCodePage = uCodePage;}
    long GetBufFlags(void) const {return m_lBufFlags;}
    void SetBufFlags(long lBufFlags) {m_lBufFlags = lBufFlags;}
    long GetBufCCh(void) const {return m_cchBuf;}
    void SetBufCCh(long cchBuf) {m_cchBuf = cchBuf;}
    LCID GetLocale(void) const {return m_locale;}
    void SetLocale(LCID locale) {m_locale = locale;}
#ifdef ASTRIMPL
    CLockInfo* GetLockInfo(void) {return &m_LockInfo;}
#else
    BOOL IsLocked(void) const {return (m_lLockFlags != 0);}
    BOOL IsDirectLock(void) const {return m_fDirectLock;}
    void SetDirectLockFlag(BOOL fDirectLock) {m_fDirectLock = fDirectLock;}
    long GetLockFlags(void) const {return m_lLockFlags;}
    void SetLockFlags(long lFlags) {m_lLockFlags = lFlags;}
#endif
    HRESULT MemAlloc(ULONG cb, void** ppv) {void* pv = ::CoTaskMemAlloc(cb); if (ppv) *ppv = pv; return (pv) ? S_OK : E_OUTOFMEMORY;}
    HRESULT MemFree(void* pv) {::CoTaskMemFree(pv); return S_OK;}
#ifdef ASTRIMPL
    HRESULT UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
#endif

protected:
    ~CMLStr(void);
#ifndef ASTRIMPL
    static HRESULT ConvertMLStrBufAToWStr(UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchSrcPos, long cchSrcLen, WCHAR* pszBuf, long cchBuf, long* pcchActual);
    static HRESULT ConvertWStrToMLStrBufA(const WCHAR* pszSrc, long cchSrc, UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchDestPos, long cchDestLen);
#endif

    DWORD m_dwThreadID;

    IMLangStringBufW* m_pMLStrBufW;
    IMLangStringBufA* m_pMLStrBufA;
    UINT m_uCodePage;
    long m_lBufFlags;
    long m_cchBuf;

    LCID m_locale;

#ifdef ASTRIMPL
    CLockInfo m_LockInfo;
#else
    BOOL m_fDirectLock;
    long m_lLockFlags;

    WCHAR* m_pszLockBuf;
    long m_cchLockPos;
    long m_cchLockLen;
    long m_lLockPos;
    long m_lLockLen;
#endif
};

#endif //__MLSTR_H_

#else // NEWMLSTR

// MLStr.h : Declaration of the CMLStr

#ifndef __MLSTR_H_
#define __MLSTR_H_

#include "mlstrw.h" // IMLangStringWStrImpl
#include "mlstra.h" // IMLangStringAStrImpl
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStr
class ATL_NO_VTABLE CMLStr :
    public CComObjectRoot,
    public CComCoClass<CMLStr, &CLSID_CMLangString>,
    public IMLangString,
    public IMLStrAttrNotifySink,
    public IConnectionPointContainerImpl<CMLStr>,
    public IConnectionPointImpl<CMLStr, &IID_IMLangStringNotifySink>
{
public:
    CMLStr();

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStr)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringWStr, CMLStrW)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringAStr, CMLStrA)
        COM_INTERFACE_ENTRY(IMLStrAttrNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMLStr)
        CONNECTION_POINT_ENTRY(IID_IMLangStringNotifySink)
    END_CONNECTION_POINT_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/ DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLStrAttrNotifySink
    STDMETHOD(OnRequestEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnCanceledEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnChanged)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);

//---------------------------------------------------------------------------
protected:
    struct LOCKINFO
    {
        long lPos;
        long lLen;
        DWORD dwFlags;
        DWORD dwThrd;
    };
//---------------------------------------------------------------------------
protected:
    class CLockList : public CMLListFast
    {
    protected:
        struct CCell : public CMLListFast::CCell
        {
            LOCKINFO m_linfo;
        };

    public:
        inline CLockList(void) : CMLListFast(sizeof(CCell), sizeof(CCell) * 8) {}
        inline HRESULT SetLock(void* pv, long lPos, long lLen, DWORD dwFlags, DWORD dwThrd)
        {
            ((CCell*)pv)->m_linfo.lPos = lPos;
            ((CCell*)pv)->m_linfo.lLen = lLen;
            ((CCell*)pv)->m_linfo.dwFlags = dwFlags;
            ((CCell*)pv)->m_linfo.dwThrd = dwThrd;
            return S_OK;
        }
        inline HRESULT GetLockInfo(void* pv, LOCKINFO** pplinfo)
        {
            *pplinfo = &((CCell*)pv)->m_linfo;
            return S_OK;
        }
    };
//---------------------------------------------------------------------------
protected:
    class CAttrList : public CMLListLru
    {
    protected:
        struct CCell : public CMLListLru::CCell
        {
            IMLStrAttr* m_pAttr;
            DWORD m_dwCookie;
        };

    public:
        inline CAttrList(void) : CMLListLru(sizeof(CCell), sizeof(CCell) * 8) {}
        inline IMLStrAttr* GetAttr(void* pv) {return ((CCell*)pv)->m_pAttr;}
        inline void SetAttr(void* pv, IMLStrAttr* pAttr) {((CCell*)pv)->m_pAttr = pAttr;}
        inline DWORD GetCookie(void* pv) const {return ((CCell*)pv)->m_dwCookie;}
        inline void SetCookie(void* pv, DWORD dwCookie) {((CCell*)pv)->m_dwCookie = dwCookie;}
    };
//---------------------------------------------------------------------------
// IEnumUnknown object for IMLangString::EnumAttr()
protected:
    class ATL_NO_VTABLE CEnumAttr :
        public CComObjectRoot,
        public IEnumUnknown
    {
    public:
        CEnumAttr(void);
        ~CEnumAttr(void);
        void Init(CMLStr* pMLStr);

        BEGIN_COM_MAP(CEnumAttr)
            COM_INTERFACE_ENTRY(IEnumUnknown)
        END_COM_MAP()

        STDMETHOD(Next)(ULONG celt, IUnknown** rgelt, ULONG* pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumUnknown** ppEnum);

    protected:
        CMLStr* m_pMLStr;
        void* m_pv;
    };
    friend class CEnumAttr;
//---------------------------------------------------------------------------
// Fire notification to all of IMLangStringNotifySink advised.
protected:
    class CFire : public CFireConnection<IMLangStringNotifySink, &IID_IMLangStringNotifySink>
    {
    public:
        inline CFire(HRESULT& rhr, CMLStr* const pMLStr) :
            CFireConnection<IMLangStringNotifySink, &IID_IMLangStringNotifySink>(rhr)
        {
            if (SUCCEEDED(*m_phr) &&
                FAILED(*m_phr = pMLStr->EnumConnections(&m_pEnumConn)))
            {
                m_pEnumConn = NULL;
            }
        }
    };
//---------------------------------------------------------------------------

protected:
    ~CMLStr(void);
    HRESULT CheckAccessValidation(long lPos, long lLen, DWORD dwFlags, DWORD dwThrd, long* plActualPos, long* plActualLen);

    inline HRESULT StartEndConnectionAttr(IUnknown* const pUnk, DWORD* const pdwCookie, DWORD dwCookie)
    {
        return ::StartEndConnection(pUnk, &IID_IMLStrAttrNotifySink, (IMLStrAttrNotifySink*)this, pdwCookie, dwCookie);
    }

protected:
    long m_lLen;
    CLockList m_lock;
    CAttrList m_attr;
    HANDLE m_hUnlockEvent;
    int m_cWaitUnlock;
    HANDLE m_hZeroEvent;
};

#endif //__MLSTR_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstra.h ===
#ifndef NEWMLSTR

// MLStrA.h : Declaration of the CMLStrA

#ifndef __MLSTRA_H_
#define __MLSTRA_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrA
class ATL_NO_VTABLE CMLStrA :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringAStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
#ifdef ASTRIMPL
    CMLStrA(void);
#endif

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrA)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringAStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
// IMLangStringAStr
    STDMETHOD(SetAStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufA)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in]*/ IMLangStringBufA* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ UINT uCodePageIn, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(cchDest)]*/ CHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufA)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ UINT* puDestCodePage, /*[out]*/ IMLangStringBufA** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ UINT uCodePageIn, /*[in]*/ long cchRequest, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(,*pcchDest)]*/ CHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockAStr)(/*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
#ifdef ASTRIMPL
    ~CMLStrA(void);
#endif
    POWNER GetOwner(void) const {return m_pOwner;}
#ifdef ASTRIMPL
    HRESULT PrepareMLangCodePages(void)
    {
        HRESULT hr = S_OK;
        if (!m_pMLCPs)
            hr = ::CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMLangCodePages, (void**)&m_pMLCPs);
        return hr;
    }
    IMLangCodePages* GetMLangCodePages(void) const {return m_pMLCPs;}

    IMLangCodePages* m_pMLCPs;
#endif
};

#endif //__MLSTRA_H_

#else // NEWMLSTR

// MLStrA.h : Declaration of the CMLStrA

#ifndef __MLSTRA_H_
#define __MLSTRA_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrA
class ATL_NO_VTABLE CMLStrA :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringAStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    CMLStrA(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrA)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringAStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/ DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLangStringAStr
    STDMETHOD(SetAStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufA)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in]*/ IMLangStringBufA* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ UINT uCodePageIn, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(cchDest)]*/ CHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufA)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ UINT* puDestCodePage, /*[out]*/ IMLangStringBufA** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ UINT uCodePageIn, /*[in]*/ long cchRequest, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(,*pcchDest)]*/ CHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockAStr)(/*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    ~CMLStrA(void);
    POWNER GetOwner(void) const {return m_pOwner;}
    inline HRESULT GetAttrAStr(IMLStrAttrAStr** ppAttr);
    inline HRESULT GetAttrLocale(IMLStrAttrLocale** ppAttr);
    HRESULT GetAttrAStrReal(IMLStrAttrAStr** ppAttr);
    HRESULT GetAttrLocaleReal(IMLStrAttrLocale** ppAttr);

    CRITICAL_SECTION m_cs;
    IMLStrAttrAStr* m_pAttrAStr;
    IMLStrAttrLocale* m_pAttrLocale;
    DWORD m_dwAttrAStrCookie; // Returned by RegisterAttr
    DWORD m_dwAttrLocaleCookie; // Returned by RegisterAttr
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrA inline-line functions
HRESULT CMLStrA::GetAttrAStr(IMLStrAttrAStr** ppAttr)
{
    if (m_pAttrAStr)
    {
        if (ppAttr)
            *ppAttr = m_pAttrAStr;

        return S_OK;
    }
    else
    {
        return GetAttrAStrReal(ppAttr);
    }
}

HRESULT CMLStrA::GetAttrLocale(IMLStrAttrLocale** ppAttr)
{
    if (m_pAttrLocale)
    {
        if (ppAttr)
            *ppAttr = m_pAttrLocale;

        return S_OK;
    }
    else
    {
        return GetAttrLocaleReal(ppAttr);
    }
}

#endif //__MLSTRA_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlsbwalk.h ===
// MLSBWalk.h : Declaration of the CMLStrBufWalk

#ifndef __MLSBWALK_H_
#define __MLSBWALK_H_

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufWalk
template <class IMLSTRBUF, class CHTYPE>
class CMLStrBufWalk
{
public:
    inline CMLStrBufWalk(IMLSTRBUF* pMLStrBuf, long cchOffset, long cchLen, BOOL fCanStopAtMiddle = FALSE);
    BOOL Lock(HRESULT& rhr);
    void Unlock(HRESULT& rhr, long cchActual = 0);
    inline CHTYPE* GetStr(void);
    inline long GetCCh(void) const;
    inline long GetDoneCCh(void) const;
    inline long GetRestCCh(void) const;

protected:
    IMLSTRBUF* m_pMLStrBuf;
    BOOL m_fCanStopAtMiddle;
    long m_cchOffset;
    long m_cchLen;
    long m_cchDone;
    CHTYPE* m_pszBuf;
    long m_cchBuf;
};

template <class IMLSTRBUF, class CHTYPE>
CMLStrBufWalk<IMLSTRBUF, CHTYPE>::CMLStrBufWalk(IMLSTRBUF* pMLStrBuf, long cchOffset, long cchLen, BOOL fCanStopAtMiddle) :
    m_pMLStrBuf(pMLStrBuf),
    m_fCanStopAtMiddle(fCanStopAtMiddle)
{
    m_cchOffset = cchOffset;
    m_cchLen = cchLen;
    m_cchDone = 0;

    m_pszBuf = NULL; // Mark as it's not locked
}

template <class IMLSTRBUF, class CHTYPE>
BOOL CMLStrBufWalk<IMLSTRBUF, CHTYPE>::Lock(HRESULT& rhr)
{
    if (m_pszBuf)
        rhr = E_FAIL; // Already locked

    if (SUCCEEDED(rhr) &&
        m_cchLen > 0 &&
        FAILED(rhr = m_pMLStrBuf->LockBuf(m_cchOffset, m_cchLen, &m_pszBuf, &m_cchBuf)))
    {
        m_pszBuf = NULL; // Mark as it's not locked
    }

    if (m_fCanStopAtMiddle && FAILED(rhr) && m_cchDone > 0)
    {
        rhr = S_OK;
        return FALSE; // Stop it, but not fail
    }
    else
    {
        return (SUCCEEDED(rhr) && m_cchLen > 0);
    }
}

template <class IMLSTRBUF, class CHTYPE>
void CMLStrBufWalk<IMLSTRBUF, CHTYPE>::Unlock(HRESULT& rhr, long cchActual)
{
    HRESULT hr = S_OK;

    if (!m_pszBuf)
        hr = E_FAIL; // Not locked yet

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = m_pMLStrBuf->UnlockBuf(m_pszBuf, 0, 0))) // Unlock even if rhr is already failed
    {
        if (!cchActual)
            cchActual = m_cchBuf;
        else
            ASSERT(cchActual > 0 && cchActual <= m_cchBuf);

        m_cchOffset += cchActual;
        m_cchLen -= cchActual;
        m_cchDone += cchActual;
    }

    m_pszBuf = NULL; // Unlock anyway

    if (SUCCEEDED(rhr))
        rhr = hr; // if rhr is failed before UnlockBuf, use it
}

template <class IMLSTRBUF, class CHTYPE>
CHTYPE* CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetStr(void)
{
    ASSERT(m_pszBuf); // Not locked
    return m_pszBuf;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetCCh(void) const
{
    ASSERT(m_pszBuf); // Not locked
    if (m_pszBuf)
        return m_cchBuf;
    else
        return 0;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetDoneCCh(void) const
{
    return m_cchDone;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetRestCCh(void) const
{
    return m_cchLen - m_cchDone;
}

typedef CMLStrBufWalk<IMLangStringBufW, WCHAR> CMLStrBufWalkW;
typedef CMLStrBufWalk<IMLangStringBufA, CHAR>  CMLStrBufWalkA;

#endif //__MLSBWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstrw.cpp ===
// MLStrW.cpp : Implementation of CMLStrW
#include "private.h"

#ifndef NEWMLSTR

#ifdef ASTRIMPL
#include "mlstr.h"
#include "mlsbwalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrW

STDMETHODIMP CMLStrW::Sync(BOOL fNoAccess)
{
    ASSERT_THIS;
    return GetOwner()->Sync(fNoAccess);
}

STDMETHODIMP CMLStrW::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrW::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrW::GetMLStr(long lSrcPos, long lSrcLen, IUnknown* pUnkOuter, DWORD dwClsContext, const IID* piid, IUnknown** ppDestMLStr, long* plDestPos, long* plDestLen)
{
    ASSERT_THIS;
    return GetOwner()->GetMLStr(lSrcPos, lSrcLen, pUnkOuter, dwClsContext, piid, ppDestMLStr, plDestPos, plDestLen);
}

STDMETHODIMP CMLStrW::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(TRUE, pOwner, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (pOwner->GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();

        if (pMLStrBufW)
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufW->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufW->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkW BufWalk(pMLStrBufW, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenW(pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(WCHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA(); // Should succeed because PrepareMLStrBuf() above was succeeded
            const UINT uCodePage = pOwner->GetCodePage();
            long cchSrcA;

            if (SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, NULL, 0, &cchSrcA, NULL, NULL)))
            {
                if (cchSrcA > cchDestLen)
                {
                    hr = pMLStrBufA->Insert(cchDestPos, cchSrcA - cchDestLen, (pcchActual || plActualLen) ? &cchSrcA : NULL);
                    cchSrcA += cchDestLen;
                }
                else if  (cchSrcA < cchDestLen)
                {
                    hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrcA);
                }
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrcA, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, BufWalk.GetStr(), BufWalk.GetCCh(), &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    pszSrc += cchWrittenW;
                    cchSrc -= cchWrittenW;
                    cchActual += cchWrittenW;
                    lActualLen += lWrittenLen;
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrW::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->SetStrBufCommon(this, lDestPos, lDestLen, 0, pSrcBuf, NULL, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrW::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (pMLStrBufW)
        {
            CMLStrBufWalkW BufWalk(pMLStrBufW, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenW(BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(WCHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else if (pMLStrBufA)
        {
            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while ((!pszDest || cchDest > 0) && BufWalk.Lock(hr))
            {
                CHAR* const pszBuf = BufWalk.GetStr();
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = pOwner->ConvAStrToWStr(pOwner->GetCodePage(), pszBuf, BufWalk.GetCCh(), pszDest, cchDest, &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    lActualLen += lWrittenLen;
                    cchActual += cchWrittenW;

                    if (pszDest)
                    {
                        pszDest += cchWrittenW;
                        cchDest -= cchWrittenW;
                    }
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
        else
        {
            ASSERT(cchActual == 0); // MLStrBuf is not available
            lActualLen = 0;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrW::GetStrBufW(long lSrcPos, long lSrcMaxLen, IMLangStringBufW** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    IMLangStringBufW* pMLStrBufW;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufW = pOwner->GetMLStrBufW();
        if (!pMLStrBufW)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (ppDestBuf)
        {
            pMLStrBufW->AddRef();
            *ppDestBuf = pMLStrBufW;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrW::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(lFlags & MLSTR_WRITE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    WCHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~pOwner->GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();
        fDirectLock = (pMLStrBufW != 0);

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufW->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                pOwner->SetBufCCh(pOwner->GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufW->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = pOwner->CalcLenW(pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = pOwner->CalcBufSizeW(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = pOwner->MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && (lFlags & MLSTR_READ))
                hr = GetWStr(lSrcPos, lSrcLen,  pszBuf, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = pOwner->GetLockInfo()->Lock((fDirectLock) ? pOwner->UnlockWStrDirect : pOwner->UnlockWStrIndirect, lFlags, 0, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                pOwner->GetMLStrBufW()->UnlockBuf(pszBuf, 0, 0);
            else
                pOwner->MemFree(pszBuf);
        }

        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrW::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return GetOwner()->UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrW::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;
    return GetOwner()->SetLocale(lDestPos, lDestLen, locale);
}

STDMETHODIMP CMLStrW::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLocale(lSrcPos, lSrcMaxLen, plocale, plLocalePos, plLocaleLen);
}
#endif

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrW

CMLStrW::CMLStrW(void) :
    m_pAttrWStr(NULL),
    m_pAttrLocale(NULL),
    m_dwAttrWStrCookie(NULL),
    m_dwAttrLocaleCookie(NULL)
{
    DllAddRef();
    ::InitializeCriticalSection(&m_cs);
}

CMLStrW::~CMLStrW(void)
{
    if (m_dwAttrLocaleCookie)
        GetOwner()->UnregisterAttr(m_dwAttrLocaleCookie);
    if (m_dwAttrWStrCookie)
        GetOwner()->UnregisterAttr(m_dwAttrWStrCookie);
    if (m_pAttrLocale)
        m_pAttrLocale->Release();
    if (m_pAttrWStr)
        m_pAttrWStr->Release();

    ::DeleteCriticalSection(&m_cs);
    DllRelease();
}

HRESULT CMLStrW::GetAttrWStrReal(IMLStrAttrWStr** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrWStr)
    {
        IMLStrAttrWStr* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrWStr, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrWStrCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrWStr, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrWStr = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrWStr;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLStrW::GetAttrLocaleReal(IMLStrAttrLocale** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrLocale)
    {
        IMLStrAttrLocale* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrLocale, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrLocaleCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrLocale, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrLocale = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrLocale;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

STDMETHODIMP CMLStrW::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->LockMLStr(lPos, lLen, dwFlags, pdwCookie, plActualPos, plActualLen);
}

STDMETHODIMP CMLStrW::UnlockMLStr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnlockMLStr(dwCookie);
}

STDMETHODIMP CMLStrW::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrW::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrW::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    return GetOwner()->RegisterAttr(pUnk, pdwCookie);
}

STDMETHODIMP CMLStrW::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnregisterAttr(dwCookie);
}

STDMETHODIMP CMLStrW::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    return GetOwner()->EnumAttr(ppEnumUnk);
}

STDMETHODIMP CMLStrW::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    return GetOwner()->FindAttr(riid, lParam, ppUnk);
}

STDMETHODIMP CMLStrW::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetWStr(lDestPos, lDestLen, pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetStrBufW(lDestPos, lDestLen, pSrcBuf, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetWStr(lSrcPos, lSrcLen, pszDest, cchDest, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::GetStrBufW(long lSrcPos, long lSrcMaxLen, IMLangStringBufW** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetStrBufW(lSrcPos, lSrcMaxLen, ppDestBuf, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrW::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->LockWStr(lSrcPos, lSrcLen, lFlags, cchRequest, ppszDest, pcchDest, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrW::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->UnlockWStr(pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetLong(lDestPos, lDestLen, (long)locale);

    return hr;
}

STDMETHODIMP CMLStrW::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetLong(lSrcPos, lSrcMaxLen, (long*)plocale, plLocalePos, plLocaleLen);

    return hr;
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstr.cpp ===
// MLStr.cpp : Implementation of CMLStr
#include "private.h"

#ifndef NEWMLSTR

#include "mlstr.h"
#ifdef ASTRIMPL
#include "mlsbwalk.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStr Helper functions

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen)
{
    ASSERT_WRITE_PTR(plPos);
    ASSERT_WRITE_PTR(plLen);

    long lPos = *plPos;
    long lLen = *plLen;

    if (lPos < 0)
        lPos = lStrLen;
    else
        lPos = min(lPos, lStrLen);

    if (lLen < 0)
        lLen = lStrLen - lPos;
    else
        lLen = min(lLen, lStrLen - lPos);

    *plPos = lPos;
    *plLen = lLen;

    return S_OK;
}

#ifdef ASTRIMPL
HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage)
{
    HRESULT hr = S_OK;

    if (puCodePage)
    {
        TCHAR szCodePage[8];

        if (::GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage)) > 0)
            *puCodePage = _ttoi(szCodePage);
        else
            hr = E_FAIL; // NLS failed
    }

    return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStr

CMLStr::CMLStr(void) :
    m_pMLStrBufW(NULL),
    m_pMLStrBufA(NULL),
    m_lBufFlags(0),
    m_cchBuf(0),
    m_locale(0),
#ifdef ASTRIMPL
    m_LockInfo(this)
#else
    m_lLockFlags(0)
#endif
{
    DllAddRef();
    m_dwThreadID = ::GetCurrentThreadId();
}

CMLStr::~CMLStr(void)
{
    if (m_pMLStrBufW)
        m_pMLStrBufW->Release();
    if (m_pMLStrBufA)
        m_pMLStrBufA->Release();
    DllRelease();
}

STDMETHODIMP CMLStr::Sync(BOOL)
{
    ASSERT_THIS;
    return S_OK; // No multithread supported; Always synchronized
}

STDMETHODIMP CMLStr::GetLength(long* plLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(FALSE, this, hr);
#endif
    long lLen;

    if (SUCCEEDED(hr))
        hr = GetLen(0, GetBufCCh(), &lLen);

    if (plLen)
    {
        if (SUCCEEDED(hr))
            *plLen = lLen;
        else
            *plLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStr::SetMLStr(long, long, IUnknown*, long, long)
{
    return E_NOTIMPL; // IMLangString::SetMLStr()
}

STDMETHODIMP CMLStr::GetMLStr(long, long, IUnknown*, DWORD, const IID*, IUnknown**, long*, long*)
{
    return E_NOTIMPL; // IMLangString::GetMLStr()
}

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    return E_NOTIMPL; // !ASTRIMPL
}

STDMETHODIMP CMLStr::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    return SetStrBufCommon(NULL, lDestPos, lDestLen, 0, pSrcBuf, NULL, pcchActual, plActualLen);
}
#endif

HRESULT CMLStr::SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_PTR_OR_NULL(pSrcBufW);
    ASSERT_READ_PTR_OR_NULL(pSrcBufA);
    ASSERT(!pSrcBufW || !pSrcBufA); // Either one or both should be NULL
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(TRUE, this, hr);
#endif
    long lBufFlags = 0; // '= 0' for in case of both of pSrcBufW and pSrcBufA are NULL
    long cchBuf = 0;
    long cchDestPos;
    long cchDestLen;
    long lActualLen = 0;

#ifndef ASTRIMPL
    if (SUCCEEDED(hr) && IsLocked())
        hr = E_INVALIDARG; // This MLStr is locked
#endif

    if (SUCCEEDED(hr) &&
        (!pSrcBufW || SUCCEEDED(hr = pSrcBufW->GetStatus(&lBufFlags, &cchBuf))) &&
        (!pSrcBufA || SUCCEEDED(hr = pSrcBufA->GetStatus(&lBufFlags, &cchBuf))) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        if (!cchDestPos && cchDestLen == GetBufCCh()) // Replacing entire string
        {
            IMLangStringBufW* const pOldBufW = GetMLStrBufW();
            IMLangStringBufA* const pOldBufA = GetMLStrBufA();

            if (pOldBufW)
                pOldBufW->Release();
            else if (pOldBufA)
                pOldBufA->Release();

            if (pSrcBufW)
                pSrcBufW->AddRef();
            else if (pSrcBufA)
                pSrcBufA->AddRef();

            SetMLStrBufW(pSrcBufW);
            SetMLStrBufA(pSrcBufA);
            SetCodePage(uCodePage);
            SetBufFlags(lBufFlags);
            SetBufCCh(cchBuf);

            if (plActualLen)
                hr = GetLen(0, GetBufCCh(), &lActualLen);
        }
        else
        {
#ifdef ASTRIMPL
            if (pSrcBufW)
            {
                CMLStrBufWalkW BufWalk(pSrcBufW, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringWStr*)pMLStrX)->SetWStr(lDestPos, lDestLen, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufW->Release();
            }
            else if (pSrcBufA && pMLStrX)
            {
                CMLStrBufWalkA BufWalk(pSrcBufA, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringAStr*)pMLStrX)->SetAStr(lDestPos, lDestLen, uCodePage, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufA->Release();
            }
            else
            {
                hr = SetMLStr(lDestPos, lDestLen, NULL, 0, 0);
            }
#else
            hr = E_INVALIDARG; // !ASTRIMPL
#endif
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchBuf;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && IsLocked())
        hr = E_INVALIDARG; // This MLStr is locked

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        if (pszDest)
        {
            long cchActualTemp = min(cchSrcLen, cchDest);
            cchActual = cchActualTemp;

            while (SUCCEEDED(hr) && cchActualTemp > 0)
            {
                WCHAR* pszBuf;
                long cchBuf;

                if (m_pMLStrBufW)
                {
                    if (SUCCEEDED(hr = m_pMLStrBufW->LockBuf(cchSrcPos, cchActualTemp, &pszBuf, &cchBuf)))
                    {
                        ::memcpy(pszDest, pszBuf, sizeof(WCHAR) * cchBuf);
                        hr = m_pMLStrBufW->UnlockBuf(pszBuf, 0, 0);

                        cchSrcPos += cchBuf;
                        cchActualTemp -= cchBuf;
                        pszDest += cchBuf;
                    }
                }
                else // m_pMLStrBufW
                {
                    hr = E_FAIL;  // !ASTRIMPL
                }
            }

            if (FAILED(hr) && cchActualTemp < cchActual && (pcchActual || plActualLen))
            {
                cchActual -= cchActualTemp;
                hr = S_OK;
            }
        }
        else
        {
            cchActual = cchSrcLen;
        }
    }

    if (SUCCEEDED(hr) && plActualLen)
        hr = CalcLenW(0, cchActual, &lActualLen);

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStr::GetStrBufW(long, long, IMLangStringBufW**, long*)
{
    return E_NOTIMPL; // !ASTRIMPL
}

STDMETHODIMP CMLStr::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    long cchSrcPos;
    long cchSrcLen;
    WCHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;

    if (SUCCEEDED(hr) && (IsLocked() || !lFlags || (lFlags & ~GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // This MLStr is locked, no flags specified or not writable

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
        SetDirectLockFlag(pMLStrBufW != 0);

        if (IsDirectLock())
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufW->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                SetBufCCh(GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufW->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

        }
        else if (m_pMLStrBufA)
        {
            long cchSize;

            if (SUCCEEDED(hr = CalcBufSizeW(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && (lFlags & MLSTR_READ))
                hr = ConvertMLStrBufAToWStr(m_uCodePage, m_pMLStrBufA, cchSrcPos, cchSrcLen, pszBuf, cchBuf, (pcchDest) ? &cchBuf : NULL);
        }
        else
        {
            hr = E_FAIL; // !ASTRIMPL
        }
    }

    if (plDestLen && SUCCEEDED(hr))
        hr = CalcLenW(pszBuf, cchBuf, &lLockLen);

    if (SUCCEEDED(hr))
    {
        SetLockFlags(lFlags);
        m_pszLockBuf = pszBuf;
        m_cchLockPos = cchSrcPos;
        m_cchLockLen = cchBuf;
        m_lLockPos = lSrcPos;
        m_lLockLen = lSrcLen;

        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (IsDirectLock())
                GetMLStrBufW()->UnlockBuf(pszBuf, 0, 0);
            else
                MemFree(pszBuf);
        }

        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}
#endif

#ifdef ASTRIMPL
HRESULT CMLStr::UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufW->UnlockBuf((WCHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufW->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenW((WCHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStr::UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLangStringWStr, &IID_IMLangStringWStr> pMLStrW(this);
        ASSERT(pMLStrW);
        hr = pMLStrW->SetWStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), (WCHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}

HRESULT CMLStr::UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufA->UnlockBuf((CHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufA->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenA(GetCodePage(), (CHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStr::UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLangStringAStr, &IID_IMLangStringAStr> pMLStrA(this);
        ASSERT(pMLStrA);
        hr = pMLStrA->SetAStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), GetLockInfo()->GetCodePage(pKey), (CHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}
#endif

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    long lSrcLen = 0;
    const long lLockFlags = GetLockFlags();

    if (SUCCEEDED(hr) && (!IsLocked() || pszSrc != m_pszLockBuf))
        hr = E_INVALIDARG; // This MLStr is not locked

    if (!(lLockFlags & MLSTR_WRITE))
    {
        cchSrc = 0;
        lSrcLen = 0;
    }

    if (SUCCEEDED(hr))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();

        if (IsDirectLock())
        {
            if (SUCCEEDED(hr = pMLStrBufW->UnlockBuf(pszSrc, 0, cchSrc)) &&
                (lLockFlags & MLSTR_WRITE))
            {
                if (cchSrc < m_cchLockLen)
                {
                    if (SUCCEEDED(hr = pMLStrBufW->Delete(m_cchLockPos + cchSrc, m_cchLockLen - cchSrc)))
                        SetBufCCh(GetBufCCh() - (m_cchLockLen - cchSrc));
                }

                if (SUCCEEDED(hr) && plActualLen)
                    hr = CalcLenW(pszSrc, cchSrc, &lSrcLen);
            }
        }
        else
        {
            if (lLockFlags & MLSTR_WRITE)
                hr = SetWStr(m_lLockPos, m_lLockLen, pszSrc, cchSrc, (pcchActual) ? &cchSrc : NULL, (plActualLen) ? &lSrcLen : NULL);

            HRESULT hrTemp = MemFree((void*)pszSrc);
            if (FAILED(hrTemp) && SUCCEEDED(hr))
                hr = hrTemp;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchSrc;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    SetLockFlags(0); // Unlock it anyway

    return hr;
}
#endif

#ifdef ASTRIMPL
HRESULT CMLStr::UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = CheckThread();
    void* pLockKey;
    long lSrcLen;

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Find(pszSrc, cchSrc, &pLockKey);

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Unlock(pLockKey, pszSrc, cchSrc, (pcchActual) ? &cchSrc : NULL, (plActualLen) ? &lSrcLen : NULL);

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchSrc;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}
#endif

STDMETHODIMP CMLStr::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(TRUE, this, hr);
#endif
    long cchDestPos;
    long cchDestLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        //if (!cchDestPos && cchDestLen == GetBufCCh())
            SetLocale(locale);
        //else
        //    hr = E_NOTIMPL; // Cannot set the locale to a part of string in this version.
    }

    return hr;
}

STDMETHODIMP CMLStr::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plocale);
    ASSERT_WRITE_PTR_OR_NULL(plLocalePos);
    ASSERT_WRITE_PTR_OR_NULL(plLocaleLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(FALSE, this, hr);
#endif
    long lStrLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = GetLen(0, GetBufCCh(), &lStrLen)) &&
        SUCCEEDED(hr = ::RegularizePosLen(lStrLen, &lSrcPos, &lSrcMaxLen)))
    {
        if (plocale)
            *plocale = GetLocale();
        if (plLocalePos)
            *plLocalePos = 0;
        if (plLocaleLen)
        {
            if (plLocalePos)
                *plLocaleLen = lStrLen;
            else
                *plLocaleLen = lSrcMaxLen;
        }
    }
    else
    {
        if (plocale)
            *plocale = 0;
        if (plLocalePos)
            *plLocalePos = 0;
        if (plLocaleLen)
            *plLocaleLen = 0;
    }

    return hr;
}

HRESULT CMLStr::PrepareMLStrBuf(void)
{
    if (GetMLStrBufW() || GetMLStrBufA())
        return S_OK;
#ifdef ASTRIMPL

    IMLangStringBufW* pBuf = new CMLStr::CMLStrBufStandardW;
    if (pBuf)
    {
        SetMLStrBufW(pBuf);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
#else
    else
        return E_NOTIMPL; //!ASTRIMPL
#endif
}

HRESULT CMLStr::RegularizePosLen(long* plPos, long* plLen)
{
    HRESULT hr;
    long lStrLen;

    if (SUCCEEDED(hr = GetLen(0, GetBufCCh(), &lStrLen)))
        hr = ::RegularizePosLen(lStrLen, plPos, plLen);

    return hr;
}

HRESULT CMLStr::GetCCh(long cchOffset, long lLen, long* pcchLen)
{
    if (GetMLStrBufW())
    {
        if (pcchLen)
            *pcchLen = lLen; // The number of characters is equal to the length
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
#ifdef ASTRIMPL
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, GetBufCCh() - cchOffset);

        while (lLen > 0 && BufWalk.Lock(hr))
        {
            for (LPCSTR pszTemp = BufWalk.GetStr(); lLen > 0 && *pszTemp; lLen--)
                pszTemp = ::CharNextExA((WORD)GetCodePage(), pszTemp, 0);

            if (!*pszTemp)
                lLen = 0; // String terminated

            BufWalk.Unlock(hr);
        }
#else
        long cchDone = 0;
        long cchRest = GetBufCCh() - cchOffset;

        while (SUCCEEDED(hr) && lLen > 0)
        {
            CHAR* pszBuf;
            long cchBuf;

            if (SUCCEEDED(hr = m_pMLStrBufA->LockBuf(cchOffset, cchRest, &pszBuf, &cchBuf)))
            {
                for (LPCSTR pszTemp = pszBuf; lLen > 0 && *pszTemp; lLen--)
                    pszTemp = ::CharNextExA((WORD)m_uCodePage, pszTemp, 0);

                if (!*pszBuf)
                    lLen = 0; // String terminated

                hr = m_pMLStrBufA->UnlockBuf(pszBuf, 0, 0);

                cchOffset += cchBuf;
                cchRest -= cchBuf;
                cchDone += (int)(pszTemp - pszBuf);
            }
        }
#endif

        if (pcchLen)
        {
            if (SUCCEEDED(hr))
#ifdef ASTRIMPL
                *pcchLen = BufWalk.GetDoneCCh();
#else
                *pcchLen = cchDone;
#endif
            else
                *pcchLen = 0;
        }

        return hr;
    }
    else
    {
        if (pcchLen)
            *pcchLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStr::GetLen(long cchOffset, long cchLen, long* plLen)
{
    if (GetMLStrBufW())
    {
        if (plLen)
            *plLen = cchLen; // The length is equal to the number of characters
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
        long lDoneLen = 0;
#ifdef ASTRIMPL
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, cchLen);

        while (BufWalk.Lock(hr))
        {
            long lTempLen;

            hr = CalcLenA(GetCodePage(), BufWalk.GetStr(), BufWalk.GetCCh(), &lTempLen);
            if (hr == S_FALSE)
                cchLen = 0; // String terminated
            lDoneLen += lTempLen;

            BufWalk.Unlock(hr);
        }
#else

        while (SUCCEEDED(hr) && cchLen > 0)
        {
            CHAR* pszBuf;
            long cchBuf;

            if (SUCCEEDED(hr = m_pMLStrBufA->LockBuf(cchOffset, cchLen, &pszBuf, &cchBuf)))
            {
                long lTempLen;

                hr = CalcLenA(GetCodePage(), pszBuf, cchBuf, &lTempLen);
                if (hr == S_FALSE)
                    cchLen = 0; // String terminated
                lDoneLen += lTempLen;

                hr = m_pMLStrBufA->UnlockBuf(pszBuf, 0, 0);

                cchOffset += cchBuf;
                cchLen -= cchBuf;
            }
        }
#endif

        if (plLen)
        {
            if (SUCCEEDED(hr))
                *plLen = lDoneLen;
            else
                *plLen = 0;
        }

        return hr;
    }
    else
    {
        if (plLen)
            *plLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStr::CalcLenA(UINT uCodePage, const CHAR* psz, long cchLen, long* plLen)
{
    long lLen = 0;
    const CHAR* const pszEnd = psz + cchLen;

    for (; psz < pszEnd && *psz; lLen++)
    {
        const CHAR* const pszNew = ::CharNextExA((WORD)uCodePage, psz, 0);

        if (pszNew > pszEnd) // Overrun out of buffer
            break;

        psz = pszNew;
    }

    if (plLen)
        *plLen = lLen;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

#ifdef ASTRIMPL
HRESULT CMLStr::CalcCChA(UINT uCodePage, const CHAR* psz, long lLen, long* pcchLen)
{
    const CHAR* const pszStart = psz;

    for (; lLen > 0 && *psz; lLen--)
        psz = ::CharNextExA((WORD)uCodePage, psz, 0);

    if (pcchLen)
        *pcchLen = psz - pszStart;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMLStr::ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenA;

    long cchWrittenW = ::MultiByteToWideChar(uCodePage, 0, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0);
    if (!cchWrittenW)
        hr = E_FAIL; // NLS failed

    if ((pcchActualA || plActualLen) && SUCCEEDED(hr))
        hr = CalcLenW(pszDest, cchWrittenW, &lWrittenLen); // BOGUS: pszDest may be NULL

    if (pcchActualA && SUCCEEDED(hr))
        hr = CalcCChA(uCodePage, pszSrc, lWrittenLen, &cchWrittenA);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

HRESULT CMLStr::ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenW;

    long cchWrittenA = ::WideCharToMultiByte(uCodePage, (fCanStopAtMiddle) ? 0 : WC_DEFAULTCHAR, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0, NULL, NULL);
    if (!cchWrittenA)
        hr = E_FAIL; // NLS failed

    if ((pcchActualW || plActualLen) && SUCCEEDED(hr))
    {
        if (pszDest)
            hr = CalcLenA(uCodePage, pszDest, cchWrittenA, &lWrittenLen);
        else
            hr = E_NOTIMPL; // Can't retrieve pcchActualW and plActualLen
    }

    if (pcchActualW && SUCCEEDED(hr))
        hr = CalcCChW(pszSrc, lWrittenLen, &cchWrittenW);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}
#endif

#ifndef ASTRIMPL
HRESULT CMLStr::ConvertMLStrBufAToWStr(UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchSrcPos, long cchSrcLen, WCHAR* pszBuf, long cchBuf, long* pcchActual)
{
    HRESULT hr = S_OK;
    long cchDone = 0;

    while (SUCCEEDED(hr) && cchSrcLen > 0)
    {
        CHAR* pszBufA;
        long cchBufA;

        if (SUCCEEDED(hr = pMLStrBufA->LockBuf(cchSrcPos, cchSrcLen, &pszBufA, &cchBufA)))
        {
            long cchWritten = ::MultiByteToWideChar(uCodePage, 0, pszBufA, cchBufA, pszBuf, cchBuf);
            if (!cchWritten)
                hr = E_FAIL; // NLS failed

            HRESULT hrTemp = pMLStrBufA->UnlockBuf(pszBufA, 0, 0);
            if (FAILED(hrTemp) && SUCCEEDED(hr))
                hr = hrTemp;

            cchSrcPos += cchBufA;
            cchSrcLen -= cchBufA;
            pszBuf += cchWritten;
            cchBuf -= cchWritten;
            cchDone += cchWritten;
            ASSERT(cchBuf >= 0);
        }
    }

    if (pcchActual)
    {
        *pcchActual = cchDone;

        if (FAILED(hr) && cchDone > 0)
            hr = S_OK;
    }

    return hr;
}

HRESULT CMLStr::ConvertWStrToMLStrBufA(const WCHAR*, long, UINT, IMLangStringBufA*, long, long)
{
    return E_NOTIMPL; // !ASTRIMPL
}
#endif

#ifdef ASTRIMPL
/////////////////////////////////////////////////////////////////////////////
// CMLStr::CLockInfo

HRESULT CMLStr::CLockInfo::UnlockAll(void)
{
    if (m_pLockArray)
    {
        for (int n = 0; n < MAX_LOCK_COUNT; n++)
        {
            if (m_pLockArray[n].m_psz)
                Unlock(&m_pLockArray[n], m_pLockArray[n].m_psz, m_pLockArray[n].m_cchLen, NULL, NULL);
        }
    }

    return S_OK;
}

HRESULT CMLStr::CLockInfo::Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (!m_pLockArray)
    {
        m_pLockArray = new CLockInfoEntry[MAX_LOCK_COUNT];

        if (m_pLockArray)
        {
            for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
                m_pLockArray[nIndex].m_psz = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (!m_pLockArray[nIndex].m_psz)
                break;
        }
        if (nIndex >= MAX_LOCK_COUNT)
            hr = MLSTR_E_TOOMANYNESTOFLOCK;
    }

    if (SUCCEEDED(hr))
    {
        m_pLockArray[nIndex].m_psz = psz;
        m_pLockArray[nIndex].m_pfnUnlockProc = pfnUnlockProc;
        m_pLockArray[nIndex].m_lFlags = lFlags;
        m_pLockArray[nIndex].m_uCodePage = uCodePage;
        m_pLockArray[nIndex].m_lPos = lPos;
        m_pLockArray[nIndex].m_lLen = lLen;
        m_pLockArray[nIndex].m_cchPos = cchPos;
        m_pLockArray[nIndex].m_cchLen = cchLen;
    }

    return hr;
}

HRESULT CMLStr::CLockInfo::Find(const void* psz, long, void** ppKey)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (m_pLockArray)
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (psz == m_pLockArray[nIndex].m_psz)
                break;
        }
    }
    if (!m_pLockArray || nIndex >= MAX_LOCK_COUNT)
        hr = E_INVALIDARG;

    if (ppKey)
    {
        if (SUCCEEDED(hr))
            *ppKey = &m_pLockArray[nIndex];
        else
            *ppKey = NULL;
    }

    return hr;
}

HRESULT CMLStr::CLockInfo::Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen)
{
    CLockInfoEntry* const pEntry = (CLockInfoEntry*)pKey;
    HRESULT hr;

    if (!(pEntry->m_lFlags & MLSTR_WRITE))
    {
        cch = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    hr = (m_pMLStr->*(pEntry->m_pfnUnlockProc))(pKey, psz, cch, pcchActual, plActualLen);

    if (SUCCEEDED(hr))
        hr = EndLock(pEntry->m_lFlags & MLSTR_WRITE);

    pEntry->m_psz = NULL; // Remove from lock array anyway

    if (FAILED(hr))
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStr::CMLStrBufStandardW

long CMLStr::CMLStrBufStandardW::RoundBufSize(long cchStr)
{
    for (int n = 8; n < 12; n++)
    {
        if (cchStr < (1L << n))
            break;
    }
    const long cchTick = (1L << (n - 4));
    return (cchStr + cchTick - 1) / cchTick * cchTick;
}

#endif

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStr

CMLStr::CMLStr(void) :
    m_lLen(0),
    m_hUnlockEvent(NULL),
    m_hZeroEvent(NULL)
{
    DllAddRef();
}

CMLStr::~CMLStr(void)
{
    void* pv;

    if (m_hZeroEvent)
        ::CloseHandle(m_hZeroEvent);
    if (m_hUnlockEvent)
        ::CloseHandle(m_hUnlockEvent);

    // m_lock should be empty
    ASSERT(SUCCEEDED(m_lock.Top(&pv)));
    ASSERT(!pv);

    // Release all attributes in m_attr
    VERIFY(SUCCEEDED(m_attr.Top(&pv)));
    while (pv)
    {
        IMLStrAttr* const pAttr = m_attr.GetAttr(pv);
        ASSERT(pAttr);
        VERIFY(SUCCEEDED(pAttr->SetClient(NULL))); // Reset
        VERIFY(SUCCEEDED(StartEndConnectionAttr(pAttr, NULL, m_attr.GetCookie(pv)))); // Disconnect
        pAttr->Release();
        VERIFY(SUCCEEDED(m_attr.Next(pv, &pv)));
    }
    DllRelease();
}

STDMETHODIMP CMLStr::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCookie);
    ASSERT_WRITE_PTR_OR_NULL(plActualPos);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr;
    void* pv;

    Lock();

    if (SUCCEEDED(hr = ::RegularizePosLen(m_lLen, &lPos, &lLen)))
    {
        const DWORD dwThrd = ::GetCurrentThreadId();

        if (SUCCEEDED(hr = CheckAccessValidation(lPos, lLen, dwFlags, dwThrd, plActualPos, plActualLen)) &&
            SUCCEEDED(hr = m_lock.Add(&pv)))
        {
            if (plActualPos && !plActualLen)
                lLen -= *plActualPos - lPos;
            else if (plActualLen)
                lLen = *plActualLen;
            if (plActualPos)
                lPos = *plActualPos;

            hr = m_lock.SetLock(pv, lPos, lLen, dwFlags, dwThrd);

            if (FAILED(hr))
                VERIFY(SUCCEEDED(m_lock.Remove(pv)));
        }
    }
    else
    {
        if (plActualPos)
            *plActualPos = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    Unlock();

    if (pdwCookie)
    {
        if (SUCCEEDED(hr))
            *pdwCookie = (DWORD)pv;
        else
            *pdwCookie = 0;
    }

    return hr;
}

HRESULT CMLStr::CheckAccessValidation(long lPos, long lLen, DWORD dwFlags, DWORD dwThrd, long* plActualPos, long* plActualLen)
{
    HRESULT hr;
    DWORD dwStartTime = 0;
    long lActualPos;
    long lActualLen;

    for (;;) // Waiting unlock loop
    {
        void* pv;
        HRESULT hrValidation = S_OK;

        lActualPos = lPos;
        lActualLen = lLen;

        hr = m_lock.Top(&pv);
        while (SUCCEEDED(hr) && pv) // Enumerate all locks
        {
            LOCKINFO* plinfo;

            if (SUCCEEDED(hr = m_lock.GetLockInfo(pv, &plinfo))) // Retrieve info of a lock
            {
                if ((dwFlags & MLSTR_MOVE) && // Moving this lock
                    lPos < plinfo->lPos + plinfo->lLen && // Overwrap or left of this lock
                    (dwThrd != plinfo->dwThrd || // Another thread
                     (plinfo->dwFlags & (MLSTR_READ | MLSTR_WRITE)))) // Same thread and has read or write access
                {
                    if (dwThrd == plinfo->dwThrd)
                        hr = MLSTR_E_ACCESSDENIED;
                    else
                        hr = MLSTR_E_BUSY;
                }

                if (SUCCEEDED(hr) &&
                    lActualPos < plinfo->lPos + plinfo->lLen &&
                    lActualPos + lActualLen >= plinfo->lPos) // Overwraping with this lock
                {
                    DWORD dwShareMask = 0;
                    if (dwThrd == plinfo->dwThrd) // Same thread
                        dwShareMask = ~(MLSTR_SHARE_DENYREAD | MLSTR_SHARE_DENYWRITE); // Ignore share flags

                    if (((dwFlags & MLSTR_WRITE) && (plinfo->dwFlags & (MLSTR_READ | MLSTR_WRITE | MLSTR_SHARE_DENYWRITE) & dwShareMask)) || // Write on read/write
                        ((dwFlags & MLSTR_READ)  && (plinfo->dwFlags & (             MLSTR_WRITE | MLSTR_SHARE_DENYREAD ) & dwShareMask)) || // Read on write
                        ((dwFlags & MLSTR_SHARE_DENYWRITE & dwShareMask) && (plinfo->dwFlags & MLSTR_WRITE)) || // Share deny on write
                        ((dwFlags & MLSTR_SHARE_DENYREAD  & dwShareMask) && (plinfo->dwFlags & MLSTR_READ)))    // Share deny on read
                    {
                        // Conflicting access
                        if ((plinfo->lPos <= lActualPos && plinfo->lPos + plinfo->lLen >= lActualPos + lActualLen) || // No valid range left
                            (!plActualPos && !plActualLen)) // Needs to lock entire range
                        {
                            lActualPos = 0;
                            lActualLen = 0;
                            if (dwThrd == plinfo->dwThrd)
                                hr = MLSTR_E_ACCESSDENIED;
                            else
                                hr = MLSTR_E_BUSY;
                        }
                        else if ((!plActualPos && plinfo->lPos <= lActualPos) || // Forward processing, Starting from invalid range
                                 (!plActualLen && plinfo->lPos + plinfo->lLen < lActualPos + lActualLen) || // Backward processing, Trancate valid range
                                 (plActualPos && plActualLen && plinfo->lPos - lActualPos >= (lActualPos + lActualLen) - (plinfo->lPos + plinfo->lLen))) // Maximum valid range, Right valid range is bigger
                        {
                            lActualLen += lActualPos;
                            lActualPos = plinfo->lPos + plinfo->lLen;
                            lActualLen -= lActualPos;
                            if (!plActualPos) // Forward processing
                            {
                                if (dwThrd == plinfo->dwThrd)
                                    hrValidation = MLSTR_E_ACCESSDENIED;
                                else
                                    hrValidation = MLSTR_E_BUSY;
                            }
                        }
                        else
                        {
                            lActualLen = plinfo->lPos - lActualPos;
                            if (!plActualLen) // Backward processing
                            {
                                if (dwThrd == plinfo->dwThrd)
                                    hrValidation = MLSTR_E_ACCESSDENIED;
                                else
                                    hrValidation = MLSTR_E_BUSY;
                            }
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
                hr = m_lock.Next(pv, &pv);
        }

        if (SUCCEEDED(hr) && FAILED(hrValidation))
        {
            hr = hrValidation;
            if (plActualLen && lPos < lActualPos) // Forward processing
            {
                lActualLen = lActualPos - lPos;
                lActualPos = lPos;
            }
            else if (plActualPos && lPos + lLen != lActualPos + lActualLen) // Backward processing
            {
                lActualPos += lActualLen;
                lActualLen = lPos + lLen - lActualPos;
            }
        }

        if (hr != MLSTR_E_BUSY || (dwFlags | MLSTR_NOWAIT)) // No busy state, or don't want to wait even if busy
            break;

        // Now, let's wait another thread run UnlockMLStr. Then, try validation again.

        if (!dwStartTime) // Not initialized yet
            dwStartTime = ::GetTickCount(); // Remember starting time

        const DWORD dwElapsedTime = ::GetTickCount() - dwStartTime;
        if (dwElapsedTime >= MLSTR_LOCK_TIMELIMIT) // Already elapsed long time
            break;

        if (!m_hUnlockEvent) // We don't have event object yet
        {
            m_hUnlockEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL); // Manual reset, initial reset
            if (!m_hUnlockEvent)
                break;

            m_cWaitUnlock = -1; // Initialize
        }
        else // After second time
        {
            ASSERT(m_cWaitUnlock == 0 || m_cWaitUnlock == -1 || m_cWaitUnlock >= 1);
            if (m_cWaitUnlock == 0) // Don't reset if m_cWaitUnlock is not zero
            {
                ::ResetEvent(m_hUnlockEvent);
                m_cWaitUnlock = -1;
            }
            else
            {
                if (!m_hZeroEvent)
                {
                    m_hZeroEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL); // Auto-reset, initial reset
                    if (!m_hZeroEvent)
                        break;
                }
                if (m_cWaitUnlock == -1)
                    m_cWaitUnlock = 2;
                else
                    m_cWaitUnlock++;
            }
        }
        ASSERT(m_cWaitUnlock == -1 || m_cWaitUnlock >= 2);

        // CAUTION: Don't leave here until we make sure m_cWaitUnlock gets zero.

        Unlock();

        // === The story of m_cWaitUnlock ===
        // If we don't have m_cWaitUnlock, the following scenario can be considered.
        // (1) Thread A: ResetEvent(m_hUnlockEvent)
        // (2) Thread A: Unlock()
        // (3) Thread B: SetEvent(m_hUnlockEvent) // UnlockMLStr!!!
        // (4) Thread C: Lock()
        // (5) Thread C: ResetEvent(m_hUnlockEvent) // Problem!!!
        // (6) Thread C: Unlock()
        // (7) Thread A: WaitForSingleObject(m_hUnlockEvent)
        // In this scenario, thread A is missing a event of (3). This situation should not happen.
        // m_cWaitUnlock solves the problem.

        const DWORD dwWaitResult = ::WaitForSingleObject(m_hUnlockEvent, MLSTR_LOCK_TIMELIMIT - dwElapsedTime); // Now wait unlock

        Lock();

        ASSERT(m_cWaitUnlock == -1 || m_cWaitUnlock >= 1);
        if (m_cWaitUnlock == -1)
        {
            m_cWaitUnlock = 0;
        }
        else // m_cWaitUnlock >= 1
        {
            m_cWaitUnlock--;

            // Here, let's wait until m_cWaitUnlock gets zero.
            // Unless this, it may not good for performance.
            // In worst case, it makes thousands of loops in this function because it never reset m_hUnlockEvent.
            // m_hUnlockEvent will be signaled even though UnlockMLStr is called yet.
            if (m_cWaitUnlock > 0)
            {
                Unlock();
                ::WaitForSingleObject(m_hZeroEvent, INFINITE); // Wait until m_cWaitUnlock gets zero, auto-reset
                Lock();
            }
            else // Now it's zero! Yeah!
            {
                ::SetEvent(m_hZeroEvent); // Release other threads
            }
        }
        // ASSERT(m_cWaitUnlock == 0); This is not true. Maybe non-zero for next time.
        // Now we may leave here.

        if (dwWaitResult != WAIT_OBJECT_0) // Time expired or an error occurred
            break;
    }

    if (plActualPos)
        *plActualPos = lActualPos;
    if (plActualLen)
        *plActualLen = lActualLen;

    return hr;
}

STDMETHODIMP CMLStr::UnlockMLStr(DWORD dwCookie)
{
    Lock();

    void* const pv = (void*)dwCookie;

    const HRESULT hr = m_lock.Remove(pv);

    if (m_hUnlockEvent)
        ::SetEvent(m_hUnlockEvent);

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::GetLength(long* plLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plLen);

    if (plLen)
        *plLen = m_lLen;

    return S_OK;
}

STDMETHODIMP CMLStr::SetMLStr(long, long, IUnknown*, long, long)
{
    return E_NOTIMPL; // IMLangString::SetMLStr()
}

STDMETHODIMP CMLStr::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pUnk);
    ASSERT_WRITE_PTR_OR_NULL(pdwCookie);

    HRESULT hr;
    void* pv;
    IMLStrAttr* pAttr = NULL;
    BOOL fConnStarted = FALSE;
    DWORD dwConnCookie;

    Lock();

    if (SUCCEEDED(hr = m_attr.Add(&pv)) &&
        SUCCEEDED(hr = pUnk->QueryInterface(IID_IMLStrAttr, (void**)&pAttr)))
    {
        ASSERT_READ_PTR(pAttr);
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = StartEndConnectionAttr(pAttr, &dwConnCookie, 0))) // Connect
    {
        fConnStarted = TRUE;
        if (SUCCEEDED(hr = pAttr->SetClient((IMLangString*)this)))
        {
            CFire fire(hr, this);
            while (fire.Next())
                hr = fire.Sink()->OnRegisterAttr(pAttr);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pAttr->SetMLStr(0, -1, (IMLangString*)this, 0, m_lLen)))
    {
        m_attr.SetAttr(pv, pAttr);
        m_attr.SetCookie(pv, dwConnCookie);

        if (pdwCookie)
            *pdwCookie = (DWORD)pv;
    }
    else
    {
        if (pAttr)
        {
            pAttr->SetClient(NULL);
            if (fConnStarted)
                VERIFY(SUCCEEDED(StartEndConnectionAttr(pAttr, NULL, dwConnCookie))); // Disconnect
            pAttr->Release();
        }

        if (pv)
            m_attr.Remove(pv);

        if (pdwCookie)
            *pdwCookie = NULL;
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;

    void* const pv = (void*)dwCookie;

    Lock();

    IMLStrAttr* const pAttr = m_attr.GetAttr(pv);
    ASSERT(pAttr);

    // Fire OnUnregisterAttr
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnUnregisterAttr(pAttr);

    // Release attribute
    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pAttr->SetClient(NULL))) // Reset
    {
        VERIFY(SUCCEEDED(hr = StartEndConnectionAttr(pAttr, NULL, m_attr.GetCookie(pv)))); // Disconnect
        pAttr->Release();

        // Remove entry from attr table
        m_attr.Remove(pv);
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppEnumUnk);

    if (!ppEnumUnk)
        return S_OK;

    CEnumAttr* const pEnum = new CComObject<CEnumAttr>;

    *ppEnumUnk = pEnum;

    if (pEnum)
    {
        pEnum->Init(this);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CMLStr::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppUnk);

    HRESULT hr;
    void* pv;
    IUnknown* pMaxUnk = NULL;
    long lMaxConf = 0;

    Lock();

    for (hr = m_attr.Top(&pv); SUCCEEDED(hr) && pv; hr = m_attr.Next(pv, &pv))
    {
        IMLStrAttr* const pIMLStrAttr = m_attr.GetAttr(pv);
        IUnknown* pUnk;
        long lConf;

        hr = pIMLStrAttr->QueryAttr(riid, lParam, &pUnk, &lConf);
        if (SUCCEEDED(hr))
        {
            if (lConf > lMaxConf)
            {
                lMaxConf = lConf;
                if (pMaxUnk)
                    pMaxUnk->Release();
                pMaxUnk = pUnk;
            }
            else
            {
                if (pUnk)
                    pUnk->Release();
            }

            if (lMaxConf == MLSTR_CONF_MAX)
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (ppUnk)
            *ppUnk = pMaxUnk;
        else if (pMaxUnk)
            pMaxUnk->Release();
    }
    else
    {
        if (pMaxUnk)
            pMaxUnk->Release();
        if (ppUnk)
            *ppUnk = NULL;
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::OnRequestEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnRequestEdit(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

STDMETHODIMP CMLStr::OnCanceledEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnCanceledEdit(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

STDMETHODIMP CMLStr::OnChanged(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnChanged(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStr::CEnumAttr

CMLStr::CEnumAttr::CEnumAttr(void) :
    m_pMLStr(NULL),
    m_pv(NULL)
{
}

CMLStr::CEnumAttr::~CEnumAttr(void)
{
    if (m_pMLStr)
        m_pMLStr->Unlock();
}

void CMLStr::CEnumAttr::Init(CMLStr* pMLStr)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pMLStr);

    if (m_pMLStr)
        m_pMLStr->Unlock();

    m_pMLStr = pMLStr;
    m_pMLStr->Lock();

    VERIFY(SUCCEEDED(Reset()));
}

HRESULT CMLStr::CEnumAttr::Next(ULONG celt, IUnknown** rgelt, ULONG* pceltFetched)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(rgelt, celt);
    ASSERT_WRITE_PTR_OR_NULL(pceltFetched);

    ULONG c = 0;

    if (rgelt && m_pMLStr)
    {
        for (; m_pv && c < celt; c++)
        {
            *rgelt = m_pMLStr->m_attr.GetAttr(m_pv);
            ASSERT(*rgelt);
            (*rgelt)->AddRef();

            VERIFY(SUCCEEDED(m_pMLStr->m_attr.Next(m_pv, &m_pv)));
            rgelt++;
        }
    }

    if (pceltFetched)
        *pceltFetched = c;

    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Skip(ULONG celt)
{
    ASSERT_THIS;

    for (ULONG c = 0; m_pv && c < celt; c++)
        VERIFY(SUCCEEDED(m_pMLStr->m_attr.Next(m_pv, &m_pv)));

    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Reset(void)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(m_pMLStr);

    VERIFY(SUCCEEDED(m_pMLStr->m_attr.Top(&m_pv)));
    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Clone(IEnumUnknown** ppEnum)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppEnum);
    ASSERT_READ_PTR(m_pMLStr);

    return m_pMLStr->EnumAttr(ppEnum);
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstrbuf.h ===
// MLStrBuf.h : Declaration and implementation of the IMLangStringBufW/A classes

#ifndef __MLSTRBUF_H_
#define __MLSTRBUF_H_

#include <mlang.h>

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufTempl

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
class CMLStrBufTempl : public IMLSB, public MEM, public ACCESS
{
public:
    CMLStrBufTempl(CHTYPE* psz = NULL, long cch = 0, void* pv = NULL, long cb = 0) : ACCESS(psz, cch, pv, cb)
#ifdef DEBUG
        {m_nLockCount = 0;}
#else
        {}
#endif
    ~CMLStrBufTempl(void) {ASSERT(!m_nLockCount);}

// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return AddRefI();}
    STDMETHOD_(ULONG, Release)(void) {return ReleaseI();}
// IMLangStringBufW/A
    STDMETHOD(GetStatus)(long* plFlags, long* pcchBuf);
    STDMETHOD(LockBuf)(long cchOffset, long cchMaxLock, CHTYPE** ppszBuf, long* pcchBuf);
    STDMETHOD(UnlockBuf)(const CHTYPE* pszBuf, long cchOffset, long cchWrite);
    STDMETHOD(Insert)(long cchOffset, long cchMaxInsert, long* pcchActual) {ASSERT(!m_nLockCount); return InsertI(cchOffset, cchMaxInsert, pcchActual);}
    STDMETHOD(Delete)(long cchOffset, long cchDelete) {ASSERT(!m_nLockCount); return DeleteI(cchOffset, cchDelete);}

protected:
#ifdef DEBUG
    int m_nLockCount;
#endif
};

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        (sizeof(CHTYPE) == sizeof(CHAR)  && IsEqualIID(riid, IID_IMLangStringBufA)) ||
        (sizeof(CHTYPE) == sizeof(WCHAR) && IsEqualIID(riid, IID_IMLangStringBufW)))
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::GetStatus(long* plFlags, long* pcchBuf)
{
    if (plFlags)
        *plFlags = GetFlags();

    if (pcchBuf)
        *pcchBuf = m_cchStr;

    return S_OK;
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::LockBuf(long cchOffset, long cchMaxLock, CHTYPE** ppszBuf, long* pcchBuf)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchMaxLock >= 1 && cchMaxLock <= m_cchStr - cchOffset);
#ifdef DEBUG
    m_nLockCount++;
#endif

    if (ppszBuf)
        *ppszBuf = m_pszBuf + cchOffset;

    if (pcchBuf)
        *pcchBuf = cchMaxLock;

    return S_OK;
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::UnlockBuf(const CHTYPE* pszBuf, long cchOffset, long cchWrite)
{
    ASSERT(m_nLockCount > 0);
    ASSERT(cchOffset >= 0  && pszBuf + cchOffset >= m_pszBuf && pszBuf + cchOffset < m_pszBuf + m_cchStr);
    ASSERT(cchWrite == 0);
#ifdef DEBUG
    m_nLockCount--;
#endif

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufConst

template <class CHTYPE>
class CMLStrBufConst
{
protected:
    CMLStrBufConst(CHTYPE* psz, long cch, void*, long) : m_pszBuf(psz), m_cchStr(cch) {}
    long GetFlags(void) const {return MLSTR_READ;}
    HRESULT InsertI(long cchOffset, long cchMaxInsert, long* pcchActual) {ASSERT(FALSE); if (pcchActual) *pcchActual = 0; return E_FAIL;}
    HRESULT DeleteI(long cchOffset, long cchDelete) {ASSERT(FALSE); return E_FAIL;}

    CHTYPE* const m_pszBuf;
    const long m_cchStr;
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufVariable

template <class CHTYPE>
class CMLStrBufVariable
{
protected:
    CMLStrBufVariable(CHTYPE* psz, long cch, void* pv, long cb) {m_pszBuf = (CHTYPE*)pv; m_cchBuf = cb / sizeof(CHTYPE); m_cchOffset = psz - m_pszBuf; m_cchStr = cch;}
    ~CMLStrBufVariable(void) {if (m_pszBuf) MemFree(m_pszBuf);}
    long GetFlags(void) const {return MLSTR_READ | MLSTR_WRITE;}
    HRESULT InsertI(long cchOffset, long cchMaxInsert, long* pcchActual);
    HRESULT DeleteI(long cchOffset, long cchDelete);

    virtual LPVOID MemAlloc(ULONG) {return NULL;}
    virtual LPVOID MemRealloc(LPVOID, ULONG) {return NULL;}
    virtual void MemFree(LPVOID) {}
    virtual long RoundBufSize(long cchStr) {return (cchStr + 15) / 16;}

    CHTYPE* m_pszBuf;
    long m_cchBuf;
    long m_cchOffset;
    long m_cchStr;
};

template <class CHTYPE>
HRESULT CMLStrBufVariable<CHTYPE>::InsertI(long cchOffset, long cchMaxInsert, long* pcchActual)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchMaxInsert >= 0);

    long lShiftLeft = 0;
    long lShiftRight = 0;

    if (cchOffset < m_cchStr - cchOffset &&
        cchMaxInsert <= m_cchOffset)
    {
        lShiftLeft = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchBuf - m_cchOffset - m_cchStr)
    {
        lShiftRight = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchOffset)
    {
        lShiftLeft = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchBuf - m_cchStr)
    {
        lShiftLeft = m_cchOffset;
        lShiftRight = cchMaxInsert - m_cchOffset;
    }
    else
    {
        void* pBuf;
        const long cchNew = RoundBufSize(m_cchOffset + m_cchStr + cchMaxInsert);

        if (!m_pszBuf)
            pBuf = MemAlloc(sizeof(*m_pszBuf) * cchNew);
        else
            pBuf = MemRealloc(m_pszBuf, sizeof(*m_pszBuf) * cchNew);

        if (pBuf)
        {
            m_pszBuf = (WCHAR*)pBuf;
            m_cchBuf = cchNew;
            lShiftRight = cchMaxInsert;
        }
        else
        {
            lShiftRight = m_cchBuf - m_cchOffset - m_cchStr;
            lShiftLeft = cchMaxInsert - lShiftRight;

            if (!pcchActual)
                return E_OUTOFMEMORY;
        }
    }

    if (lShiftLeft > 0)
    {
        if (cchOffset)
            ::memmove(m_pszBuf + m_cchOffset - lShiftLeft, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        m_cchOffset -= lShiftLeft;
        m_cchStr += lShiftLeft;
    }

    if (lShiftRight > 0)
    {
        if (m_cchStr - cchOffset)
            ::memmove(m_pszBuf + m_cchOffset + lShiftRight, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * (m_cchStr - cchOffset));
        m_cchStr += lShiftRight;
    }

    if (pcchActual)
        *pcchActual = lShiftLeft + lShiftRight;

    return S_OK;
}

template <class CHTYPE>
HRESULT CMLStrBufVariable<CHTYPE>::DeleteI(long cchOffset, long cchDelete)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchDelete >= 0 && cchDelete < m_cchStr - cchOffset);

    long cchShrink = m_cchBuf - RoundBufSize(RoundBufSize(m_cchStr - cchDelete) + 1);
    cchShrink = max(cchShrink, 0);

    const long cchRight = m_cchStr - cchOffset - cchDelete;
    if (cchOffset < cchRight && m_cchBuf - m_cchOffset - m_cchStr >= cchShrink)
    {
        if (cchOffset)
            ::memmove(m_pszBuf + m_cchOffset + cchDelete, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        m_cchOffset += cchDelete;
        m_cchStr -= cchDelete;
    }
    else if (m_cchBuf - m_cchOffset - m_cchStr + cchDelete >= cchShrink)
    {
        if (cchRight)
            ::memmove(m_pszBuf + m_cchOffset + cchOffset, m_pszBuf + m_cchOffset + cchDelete, sizeof(*m_pszBuf) * cchRight);
        m_cchStr -= cchDelete;
    }
    else
    {
        if (cchOffset)
            ::memmove(m_pszBuf, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        if (cchRight)
            ::memmove(m_pszBuf + cchOffset, m_pszBuf + m_cchOffset + cchDelete, sizeof(*m_pszBuf) * cchRight);

        m_cchOffset = 0;
        m_cchStr -= cchDelete;
    }

    if (cchShrink)
    {
        void* pBuf = MemRealloc(m_pszBuf, sizeof(*m_pszBuf) * (m_cchBuf - cchShrink));

        if (pBuf)
        {
            m_pszBuf = (WCHAR*)pBuf;
            m_cchBuf -= cchShrink;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufStack

class CMLStrBufStack
{
protected:
#ifdef DEBUG
    inline CMLStrBufStack(void) {m_cRef = 0;}
#else
    inline CMLStrBufStack(void) {}
#endif
    inline ~CMLStrBufStack(void) {ASSERT(!m_cRef);}

    ULONG AddRefI(void)
    {
#ifdef DEBUG
        m_cRef++;
        return m_cRef;
#else
        ASSERT(FALSE);
        return 0;
#endif
    }

    ULONG ReleaseI(void)
    {
#ifdef DEBUG
        m_cRef--;
        ASSERT(m_cRef >= 0);
        return m_cRef;
#else
        ASSERT(FALSE);
        return 0;
#endif
    }

#ifdef DEBUG
    int m_cRef;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufHeap

class CMLStrBufHeap
{
protected:
    inline CMLStrBufHeap(void) {m_cRef = 0;}
    inline ~CMLStrBufHeap(void) {ASSERT(!m_cRef);}
    ULONG AddRefI(void) {m_cRef++; return m_cRef;}
    ULONG ReleaseI(void) {m_cRef--; const int cRef = m_cRef; if (!cRef) delete this; return cRef;}

    int m_cRef;
};

typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufStack, CMLStrBufConst<WCHAR> > CMLStrBufConstStackW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufStack, CMLStrBufConst<CHAR>  > CMLStrBufConstStackA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufStack, CMLStrBufVariable<WCHAR> > CMLStrBufStackW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufStack, CMLStrBufVariable<CHAR>  > CMLStrBufStackA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufHeap,  CMLStrBufConst<WCHAR> > CMLStrBufConstW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufHeap,  CMLStrBufConst<CHAR>  > CMLStrBufConstA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufHeap,  CMLStrBufVariable<WCHAR> > CMLStrBufW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufHeap,  CMLStrBufVariable<CHAR>  > CMLStrBufA;

#ifdef UNICODE
typedef CMLStrBufConstStackW CMLStrBufConstStackT;
typedef CMLStrBufStackW CMLStrBufStackT;
typedef CMLStrBufConstW CMLStrBufConstT;
typedef CMLStrBufW CMLStrBufT;
#else
typedef CMLStrBufConstStackA CMLStrBufConstStackT;
typedef CMLStrBufStackA CMLStrBufStackT;
typedef CMLStrBufConstA CMLStrBufConstT;
typedef CMLStrBufA CMLStrBufT;
#endif

#endif //__MLSTRBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlswalk.cpp ===
// MLSWalk.cpp : Implementation of CMLStrWalkW
#include "private.h"
#include "mlswalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW

BOOL CMLStrWalkW::Lock(HRESULT& rhr)
{
    if (m_pszBuf)
        rhr = E_FAIL; // Already locked

    if (SUCCEEDED(rhr) &&
        m_lLen > 0 &&
        FAILED(rhr = m_pMLStr->LockWStr(m_lPos, m_lLen, m_lFlags, 0, &m_pszBuf, &m_cchBuf, &m_lLockLen)))
    {
        m_pszBuf = NULL; // Mark as it's not locked
    }

    if (m_fCanStopAtMiddle && FAILED(rhr) && m_lDoneLen > 0)
    {
        rhr = S_OK;
        return FALSE; // Stop it, but not fail
    }
    else
    {
        return (SUCCEEDED(rhr) && m_lLen > 0);
    }
}

void CMLStrWalkW::Unlock(HRESULT& rhr, long lActualLen)
{
    HRESULT hr = S_OK;

    if (!m_pszBuf)
        hr = E_FAIL; // Not locked yet

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = m_pMLStr->UnlockWStr(m_pszBuf, 0, NULL, NULL))) // Unlock even if rhr is already failed
    {
        if (!lActualLen)
            lActualLen = m_lLockLen;
        else
            ASSERT(lActualLen > 0 && lActualLen <= m_lLockLen);

        m_lPos += lActualLen;
        m_lLen -= lActualLen;
        m_lDoneLen += lActualLen;
    }

    m_pszBuf = NULL; // Unlock anyway

    if (SUCCEEDED(rhr))
        rhr = hr; // if rhr is failed before UnlockBuf, use it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlswalk.h ===
// MLSWalk.h : Declaration of the CMLStrWalkW and CMLStrWalkA

#ifndef __MLSWALK_H_
#define __MLSWALK_H_

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW

class CMLStrWalkW
{
public:
    inline CMLStrWalkW(IMLangStringWStr* pMLStrW, long lPos, long lLen, long lFlags = MLSTR_READ, BOOL fCanStopAtMiddle = FALSE);
    BOOL Lock(HRESULT& rhr);
    void Unlock(HRESULT& rhr, long lActualLen = 0);
    inline WCHAR* GetStr(void);
    inline long GetCCh(void) const;
    long GetPos(void) const {return m_lPos + m_lDoneLen;}
    long GetLen(void) const {return m_lLen - m_lDoneLen;}
    long GetDoneLen(void) const {return m_lDoneLen;}

protected:
    IMLangStringWStr* m_pMLStr;
    BOOL m_fCanStopAtMiddle;
    long m_lPos;
    long m_lLen;
    long m_lFlags;
    long m_lDoneLen;
    WCHAR* m_pszBuf;
    long m_cchBuf;
    long m_lLockLen;
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW inline functions

CMLStrWalkW::CMLStrWalkW(IMLangStringWStr* pMLStr, long lPos, long lLen, long lFlags, BOOL fCanStopAtMiddle) :
    m_pMLStr(pMLStr),
    m_fCanStopAtMiddle(fCanStopAtMiddle)
{
    m_lPos = lPos;
    m_lLen = lLen;
    m_lFlags = lFlags;
    m_lDoneLen = 0;

    m_pszBuf = NULL; // Mark as it's not locked
}

WCHAR* CMLStrWalkW::GetStr(void)
{
    ASSERT(m_pszBuf); // Not locked
    return m_pszBuf;
}

long CMLStrWalkW::GetCCh(void) const
{
    ASSERT(m_pszBuf); // Not locked
    if (m_pszBuf)
        return m_cchBuf;
    else
        return 0;
}

#endif //__MLSWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\msencode.h ===
/*----------------------------------------------------------------------------
    %%File: msencode.h
    %%Unit: fechmap
    %%Contact: jpick

    External header file for MsEncode character conversion module.
----------------------------------------------------------------------------*/

#ifndef MSENCODE_H
#define MSENCODE_H
    
    
// ----------------------------------------------------------------------------
//
// Error Returns
// 
// ----------------------------------------------------------------------------

//
// Return Type for API Functions
//
typedef int CCE;
    
//
// Error:       cceSuccess
// Explanation: Function succeeded (no error).
//
#define cceSuccess                       0

//
// Error:       cceRequestedStop
// Explanation: Function succeeded (no error).  Caller 
//              requested function to be run in iterator mode 
//              (stop on each character or stop on ASCII) and 
//              function is making requested stop.  (Stream 
//              conversion functions only).
//
#define cceRequestedStop                (-1)

//
// Error:       cceInsufficientBuffer
// Explanation: Buffer provided to function is too small.
//
#define cceInsufficientBuffer           (-2)

//
// Error:       cceInvalidFlags
// Explanation: An invalid flag or combination of flags was 
//              given to function.
//
#define cceInvalidFlags                 (-3)

//
// Error:       cceInvalidParameter
// Explanation: Invalid parameter passed to function (null 
//              pointer, invalid encoding specified, etc.).
//
#define cceInvalidParameter             (-4)

//
// Error:       cceRead
// Explanation: User read-callback function failed.
//
#define cceRead                         (-5)

//
// Error:       cceWrite
// Explanation: User write-callback function failed.
//
#define cceWrite                        (-6)

//
// Error:       cceUnget
// Explanation: User unget-callback function failed.
//
#define cceUnget                        (-7)

//
// Error:       cceNoCodePage
// Explanation: Requested encoding requires an installed
//              code page (NLS file) for conversion.  That
//              file is not installed.
//
#define cceNoCodePage                   (-8)

//
// Error:       cceEndOfInput
// Explanation: Unexpected end-of-input occurred within a 
//              multi-byte character in conversion function.
//              (Returned only if user requested errors for
//              invalid characters).
//
#define cceEndOfInput                   (-9)

//
// Error:       cceNoTranslation
// Explanation: Character in input stream or string has no 
//              equivalent Unicode (multi-byte to Unicode) or
//              multi-byte (Unicode to multi-byte) character.
//              (Returned only if user requested errors for
//              invalid characters).
//
#define cceNoTranslation                (-10)

//
// Error:       cceInvalidChar
// Explanation: Converter found a single or multi-byte character
//              that is outside the legal range for the given
//              encoding.  (Returned only if user requested 
//              errors for invalid characters).
//
#define cceInvalidChar                  (-11)

//
// Error:       cceAmbiguousInput
// Explanation: CceDetectInputCode(), only.  Data matches more
//              than one of the supported encodings types.
//              (Returned only if function told to not resolve
//              ambiguity).
//
#define cceAmbiguousInput               (-12)

//
// Error:       cceUnknownInput
// Explanation: CceDetectInputCode(), only.  Data matches none
//              of the supported encoding types.
//
#define cceUnknownInput                 (-13)

//
// Error:       cceMayBeAscii
// Explanation: CceDetectInputCode(), only.  Technically, data
//              matches at least one of the supported encoding
//              types, but may not be a true match.  (For example,
//              an ASCII file with only a few scattered extended
//              characters).  (Returned only if function told to
//              resolve ambiguity).
//
//              This is not an error, only a flag to the calling
//              application.  CceDetectInputCode() will still set
//              the encoding type if it returns this value.
//
#define cceMayBeAscii                   (-14)

//
// Error:       cceInternal
// Explanation: Unrecoverable internal error.
//
#define cceInternal                     (-15)

//
// Error:       cceConvert
// Explanation: Unexpected DBCS function conversion error.
//
#define cceConvert                      (-16)

//
// Error:       cceEncodingNotImplemented
// Explanation: Temporary integration error.  Requested encoding
//              is not implemented.
//
#define cceEncodingNotImplemented       (-100)

//
// Error:       cceFunctionNotImplemented
// Explanation: Temporary integration error.  Function
//              is not implemented.
//
#define cceFunctionNotImplemented       (-101)



// ----------------------------------------------------------------------------
//
// General Definitions for Modules Using these Routines
// 
// ----------------------------------------------------------------------------

#define MSENAPI                 PASCAL
#define MSENCBACK               PASCAL
#define EXPIMPL(type)           type MSENAPI
#define EXPDECL(type)           extern type MSENAPI

// In case these are not already defined
//
#ifndef FAR
#ifdef _WIN32
#define FAR     __far
#else
#define FAR
#endif
#endif

typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef UCHAR FAR *LPUSTR;
typedef const UCHAR FAR *LPCUSTR;

#ifndef UNIX // IEUNIX uses 4 bytes WCHAR, these are already defined in winnt.h
typedef unsigned short WCHAR;
typedef WCHAR *PWCHAR;
typedef WCHAR FAR *LPWSTR;
typedef const WCHAR FAR *LPCWSTR;
#endif

//
// Character encoding types supported by this module.
//
typedef enum _cenc
    {
    ceNil = -1,
    ceEucCn = 0,
    ceEucJp,
    ceEucKr,
    ceIso2022Jp,
    ceIso2022Kr,
    ceBig5,
    ceGbk,
    ceHz,
    ceShiftJis,
    ceWansung,
    ceUtf7,
    ceUtf8,
    ceCount,
    };

typedef short CEnc;
    
//
// Encoding "families" (for CceDetectInputCode() preferences).
//
typedef enum _efam
    {
    efNone = 0,
    efDbcs,
    efEuc,
    efIso2022,
    efUtf8,
    } EFam;

//
// API private/reserved structure.  For most API functions,
// this structure must be zero-filled by calling application.
// See converter function documentation, below, for more
// information.
//
#define cdwReserved     4
typedef struct _ars
    {
    DWORD rgdw[cdwReserved];
    } ARS;

// For GetProcAddress()
typedef void (MSENAPI *PFNMSENCODEVER)(WORD FAR *, WORD FAR *);

// ----------------------------------------------------------------------------
//
// Input Code Auto-Detection Routine
// 
// ----------------------------------------------------------------------------

//
// Configuration Flags for Auto Detection Routine
// 
//   grfDetectResolveAmbiguity
//       The default is to return cceAmbiguousInput if the auto
//       detection code cannot definitely determine the encoding
//       of the input stream.  If this flag is set, the function
//       will use optional user preferences and the system code 
//       page to pick an encoding (note that in this case, the
//       "lpfGuess" flag will be set to fTrue upon return).
// 
//   grfDetectUseCharMapping
//       The default action of the auto-detection code is to 
//       parse the input against the known encoding types.  Legal 
//       character sequences are not analyzed for anything 
//       beyond syntactic correctness.  If this flag is set, 
//       auto-detect will map recognized sequences to flush out
//       invalid characters.
//
//       This option will cause auto-detection to run more 
//       slowly, but also yield more accurate results.
// 
//   grfDetectIgnoreEof
//       Because auto-detect parses byte sequences against the
//       the known encoding types, end-of-input in the middle of a 
//       sequence is obviously an error.  If the calling application
//       will artificially limit the sample size, set this flag
//       to ignore such end-of-input errors.
//
#define grfDetectResolveAmbiguity       0x1
#define grfDetectUseCharMapping         0x2
#define grfDetectIgnoreEof              0x4

//
// Entry Point -- Attempt to Detect the Encoding
//
//    Return cceAmbiguousInput if input is ambiguous or cceUnknownInput
//    if encoding type matches none of the known types.
//
//    Detected encoding is returned in lpCe.  lpfGuess used to return
//    a flag indicating whether or not the function "guessed" at an
//    encoding (chose default from ambiguous state).
//
//    User preferences for encoding family (efPref) and code page
//    (nPrefCp) are optional, even if caller chooses to have
//    this function attempt to resolve ambiguity.  If either has
//    the value 0, they will be ignored.
//
EXPDECL(CCE)
CceDetectInputCode(
    IStream   *pstmIn,           // input stream
    DWORD     dwFlags,          // configuration flags
    EFam      efPref,           // optional: preferred encoding family
    int       nPrefCp,          // optional: preferred code page
    UINT      *lpCe,                // set to detected encoding
    BOOL      *lpfGuess         // set to fTrue if function "guessed"
);

#endif          // #ifndef MSENCODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\private.h ===
#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right for oleaut32.h, we are defing these

#ifdef STRICT
#undef STRICT
#endif

#define STRICT
#pragma warning(disable:4514) // unreferenced inline function has been removed

#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <port32.h>
#include <debug.h>
#include <inetreg.h>
#include <mlang.h>
#include <urlmon.h> // for JIT stuff

#include "mimedb.h"
#include "enumcp.h"
#include "resource.h"
#include "shfusion.h"

#include "detect.h"     // LCDETECT
#include "font.h"

//
//  Function prototypes
//
#if defined(__cplusplus)
extern "C" HRESULT WINAPI ConvertINetReset(void);
#else
HRESULT WINAPI ConvertINetReset(void);
#endif
HRESULT WINAPI ConvertINetStringInIStream(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI ConvertINetUnicodeToMultiByteEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI ConvertINetMultiByteToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI _DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScoores);
HRESULT WINAPI _DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScoores);

void CMLangFontLink_FreeGlobalObjects(void);
int _LoadStringExW(HMODULE, UINT, LPWSTR, int, WORD);
int _LoadStringExA(HMODULE, UINT, LPSTR, int, WORD);

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen);
HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage);
HRESULT StartEndConnection(IUnknown* const pUnkCPC, const IID* const piid, IUnknown* const pUnkSink, DWORD* const pdwCookie, DWORD dwCookie);

HRESULT RegisterServerInfo(void);
HRESULT UnregisterServerInfo(void);

// Legacy registry MIME DB code, keep it for backward compatiblility
BOOL MimeDatabaseInfo(void);

void DllAddRef(void);
void DllRelease(void);

// JIT langpack stuff
HRESULT InstallIEFeature(HWND hWnd, CLSID *clsid, DWORD dwfIODControl);
HRESULT _GetJITClsIDForCodePage(UINT uiCodePage, CLSID *clsid );
HRESULT _AddFontForCP(UINT uiCP);
HRESULT _ValidateCPInfo(UINT uiCP);
HRESULT _InstallNT5Langpack(HWND hwnd, UINT uiCP);
LANGID GetNT5UILanguage(void);
BOOL    _IsValidCodePage(UINT uiCodePage);
BOOL    _IsKOI8RU(unsigned char *pStr, int nSize);
HRESULT  IsNTLangpackAvailable(UINT uiCodePage);
HRESULT _IsCodePageInstallable(UINT uiCodePage);

// String functions
WCHAR *MLStrCpyNW(WCHAR *strDest, const WCHAR *strSource, int nCount);
WCHAR *MLStrCpyW(WCHAR *strDest, const WCHAR *strSource);
int MLStrCmpIW( const wchar_t *string1, const wchar_t *string2 );
int MLStrCmpI(LPCTSTR pwsz1, LPCTSTR pwsz2);
LPTSTR MLPathCombine(LPTSTR szPath, int nSize, LPTSTR szPath1, LPTSTR szPath2);
LPTSTR MLStrCpyN(LPTSTR pstrDest, const LPTSTR pstrSource, UINT nCount);
LPTSTR MLStrStr(const LPTSTR Str, const LPTSTR subStr);
DWORD HexToNum(LPTSTR lpsz);
LPTSTR MLStrChr( const TCHAR *string, int c );
BOOL AnsiFromUnicode(LPSTR * ppszAnsi, LPCWSTR pwszWide, LPSTR pszBuf, int cchBuf);
int WINAPI MLStrToIntW(LPCWSTR lpSrc);
int WINAPI MLStrToIntA(LPCSTR lpSrc);
int MLStrCmpNI(LPCTSTR pstr1, LPCTSTR pstr2, int nChar);
int MLStrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
int MLStrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
UINT MLGetWindowsDirectory(LPTSTR lpBuffer, UINT uSize);
int LowAsciiStrCmpNIA(LPCSTR  lpstr1, LPCSTR lpstr2, int count);

int CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelf, NEWTEXTMETRICEX *lpntm, int iFontType, LPARAM lParam);
INT_PTR CALLBACK LangpackDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD OutBoundDetectPreScan(LPWSTR lpWideCharStr, UINT cchWideChar, WCHAR *pwszCopy, WCHAR *lpBestFit);
void BuildGlobalObjects(void);
HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags);
HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags);
HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt);
HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt);
BOOL NeedToLoadMLangForOutlook(void);
BOOL MLIsOS(DWORD dwOS);


#ifdef UNICODE
#define MLStrToInt MLStrToIntW
#else
#define MLStrToInt MLStrToIntA
#endif

//
//  Globals
//
extern HINSTANCE    g_hInst;
extern HINSTANCE    g_hUrlMon;
extern UINT         g_cRfc1766;
extern PRFC1766INFOA g_pRfc1766Reg;

extern CRITICAL_SECTION g_cs;

extern BOOL g_bIsNT5;
extern BOOL g_bIsNT;
extern BOOL g_bIsWin98;
extern UINT g_uACP;
extern BOOL g_bUseSysUTF8;

#ifdef  __cplusplus

extern LCDetect * g_pLCDetect; // LCDETECT

#endif  // __cplusplus

//
//  Macros
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define VERIFY(f) AssertE(f)


#define ASSIGN_IF_FAILED(hr, exp) {HRESULT hrTemp = (exp); if (FAILED(hrTemp) && SUCCEEDED(hr)) (hr) = hrTemp;}

#define ASSERT_READ_PTR(p) ASSERT(!::IsBadReadPtr((p), sizeof(*p)))
#define ASSERT_READ_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadReadPtr((p), sizeof(*p)))
#define ASSERT_WRITE_PTR(p) ASSERT(!::IsBadWritePtr((p), sizeof(*p)))
#define ASSERT_WRITE_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadWritePtr((p), sizeof(*p)))
#define ASSERT_READ_BLOCK(p,s) ASSERT(!::IsBadReadPtr((p), sizeof(*p) * (s)))
#define ASSERT_READ_BLOCK_OR_NULL(p,s) ASSERT(!(p) || !::IsBadReadPtr((p), sizeof(*p) * (s)))
#define ASSERT_WRITE_BLOCK(p,s) ASSERT(!::IsBadWritePtr((p), sizeof(*p) * (s)))
#define ASSERT_WRITE_BLOCK_OR_NULL(p,s) ASSERT(!(p) || !::IsBadWritePtr((p), sizeof(*p) * (s)))
#define ASSERT_TSTR_PTR(p) ASSERT(!::IsBadStringPtr((p), (UINT)-1))
#define ASSERT_TSTR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtr((p), (UINT)-1))
#define ASSERT_WSTR_PTR(p) ASSERT(!::IsBadStringPtrW((p), (UINT)-1))
#define ASSERT_WSTR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtrW((p), (UINT)-1))
#define ASSERT_STR_PTR(p) ASSERT(!::IsBadStringPtrA((p), (UINT)-1))
#define ASSERT_STR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtrA((p), (UINT)-1))
#define ASSERT_CODE_PTR(p) ASSERT(!::IsBadCodePtr((FARPROC)(p)))
#define ASSERT_CODE_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadCodePtr((FARPROC)(p)))
#define ASSERT_THIS ASSERT_WRITE_PTR(this)

#ifdef NEWMLSTR
// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_ACCESSDENIED            MAKE_HRESULT(1, FACILITY_MLSTR, 2001)
#define MLSTR_E_BUSY                    MAKE_HRESULT(1, FACILITY_MLSTR, 2002)
#define MLSTR_E_TOOMANYNESTOFLOCK       MAKE_HRESULT(1, FACILITY_MLSTR, 1003)
#define MLSTR_E_STRBUFNOTAVAILABLE      MAKE_HRESULT(1, FACILITY_MLSTR, 1004)

#define MLSTR_LOCK_TIMELIMIT            100
#define MLSTR_CONF_MAX                  0x40000000
#define MAX_LOCK_COUNT                  4
#endif

#define BIT_HEADER_CHARSET              0x1
#define BIT_BODY_CHARSET                0x2
#define BIT_WEB_CHARSET                 0x4
#define BIT_WEB_FIXED_WIDTH_FONT        0x8 
#define BIT_PROPORTIONAL_FONT           0x10
#define BIT_DESCRIPTION                 0x20
#define BIT_FAMILY                      0x40
#define BIT_LEVEL                       0x80
#define BIT_ENCODING                    0x100

#define BIT_DEL_HEADER_CHARSET          0x10000
#define BIT_DEL_BODY_CHARSET            0x20000
#define BIT_DEL_WEB_CHARSET             0x40000
#define BIT_DEL_WEB_FIXED_WIDTH_FONT    0x80000 
#define BIT_DEL_PROPORTIONAL_FONT       0x100000
#define BIT_DEL_DESCRIPTION             0x200000
#define BIT_DEL_FAMILY                  0x400000
#define BIT_DEL_LEVEL                   0x800000
#define BIT_DEL_ENCODING                0x1000000

#define BIT_CODEPAGE                    0x1
#define BIT_INTERNET_ENCODING           0x2
#define BIT_ALIAS_FOR_CHARSET           0x4

#define CPBITS_WINDOWS                     0x1
#define CPBITS_EXTENDED                    0x2
#define CPBITS_STRICT                      0x4

#define DETECTION_MAX_LEN               20*1024     // Limit max auto-detect length to 20k
#define IS_DIGITA(ch)    InRange(ch, '0', '9')
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')
#define IS_CHARA(ch)     (InRange(ch, 'a', 'z') && InRange(ch, 'A', 'Z'))
#define IS_NLS_DLL_CP(x) ((x) == CP_UTF_8  || InRange(x, 57002, 57011) || (x) == CP_18030 || (x) == CP_UTF_7)
#define IS_HINDI_CHAR(x) (InRange(x, 0x0900, 0x0DFF) || InRange(x, 0x0F00, 0x10FF))
#define IS_PUA_CHAR(x)   (InRange(x, 0xE000, 0xF8FF))
#define IS_CJK_CHAR(x)   (InRange(x, 0x3000, 0x9FFF) || InRange(x, 0xAC00, 0xD7A3) || InRange(x, 0xF900, 0xFAFF) || InRange(x, 0xFF00, 0xFFEF))
#define IS_CHS_LEADBYTE(x) (InRange(x, 0x81, 0xFE))
#define IS_KOR_LEADBYTE(x) (InRange(x, 0x81, 0xFE))


// Internal define for K1 Hanja support
// In future version of MLang, we might need to update this bit define if there is a conflict with system define
#define FS_MLANG_K1HANJA 0x10000000L

//
// We support following code pages for outbound encoding detection
//      Windows  : 1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 932, 949, 950, 936
//      Unicode  : 65001, 65000, 1200
//      ISO      : 28591, 28592, 20866, 28595, 28597, 28593, 28594, 28596, 28598, 28605, 28599
//      Others   : 20127, 50220, 51932, 51949, 50225, 52936
//
// Default priorities
//       20127 > Windows > ISO > Others > Unicode
//

// Internal define of extented code pages
#define FS_MLANG_28591               0x00000001L
#define FS_MLANG_28592               0x00000002L
#define FS_MLANG_28595               0x00000004L
#define FS_MLANG_28597               0x00000008L
#define FS_MLANG_28593               0x00000010L
#define FS_MLANG_28598               0x00000020L
#define FS_MLANG_28596               0x00000040L
#define FS_MLANG_28594               0x00000080L
#define FS_MLANG_28599               0x00000200L
#define FS_MLANG_28605               0x00000400L
#define FS_MLANG_20127               0x00000800L
#define FS_MLANG_50220               0x00001000L
#define FS_MLANG_51932               0x00002000L
#define FS_MLANG_51949               0x00004000L
#define FS_MLANG_50225               0x00008000L
#define FS_MLANG_52936               0x00010000L
#define FS_MLANG_65000               0x00020000L
#define FS_MLANG_65001               0x00040000L
#define FS_MLANG_1200                0x00080000L
#define FS_MLANG_20866               0x00100000L
#define FS_MLANG_21866               0x00200000L
#define FS_MLANG_38598               0x00400000L
#define FS_MLANG_50221               0x00800000L
#define FS_MLANG_50222               0x01000000L

#define FS_CJK                       0x00000001L
#define FS_HINDI                     0x00000002L
#define FS_PUA                       0x00000004L

// Returns TRUE/FALSE depending on question
#define OS_WINDOWS                  0           // windows vs. NT
#define OS_NT                       1           // windows vs. NT
#define OS_WIN95ORGREATER           2           // Win95 or greater
#define OS_NT4ORGREATER             3           // NT4 or greater
// don't use (used to be OS_NT5)    4           // this flag is redundant w/ OS_WIN2000ORGREATER, use that instead  ;internal
#define OS_WIN98ORGREATER           5           // Win98 or greater
#define OS_WIN98_GOLD               6           // Win98 Gold (Version 4.10 build 1998)
#define OS_WIN2000ORGREATER         7           // Some derivative of Win2000

// NOTE: these flags are bogus, they check explicitly for (dwMajorVersion == 5) so they will fail when majorversion is bumped to 6
// !!! DO NOT USE THESE FLAGS !!!
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server in "Application Server" mode (now simply called "Terminal Server")
// END bogus flags

#define OS_EMBEDDED                 13          // Embedded Windows Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (eg user is comming in via tsclient)
#define OS_TERMINALREMOTEADMIN      15          // Terminal Server in "Remote Administration" mode
#define OS_WIN95_GOLD               16          // Windows 95 Gold (Version 4.0 Build 1995)
#define OS_MILLENNIUMORGREATER      17          // Windows Millennium (Version 5.0)

#define OS_WHISTLERORGREATER        18          // Whistler or greater
#define OS_PERSONAL                 19          // Personal (eg NOT Professional, Server, Advanced Server, or Datacenter)


#ifdef UNIX // Add some type that's not defined in UNIX SDK
typedef WORD UWORD;
#endif

#define REG_KEY_NT5LPK                    TEXT("W2KLpk")
#define REGSTR_PATH_NT5LPK_INSTALL        TEXT("System\\CurrentControlSet\\Control\\NLS\\Language Groups")

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950))   

#define IS_COMPLEXSCRIPT_CODEPAGE(j) \
    (((j) == 874)   || \
    ((j) == 1255)   || \
    ((j) == 1256)   || \
    ((j) == 1258))   

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mlstrw.h ===
#ifndef NEWMLSTR

// MLStrW.h : Declaration of the CMLStrW

#ifndef __MLSTRW_H_
#define __MLSTRW_H_

#include "mlatl.h"
#include "mlstrbuf.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrW
class ATL_NO_VTABLE CMLStrW :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringWStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrW)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringWStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    POWNER GetOwner(void) const {return m_pOwner;}
};

#endif //__MLSTRW_H_

#else // NEWMLSTR

// MLStrW.h : Declaration of the CMLStrW

#ifndef __MLSTRW_H_
#define __MLSTRW_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrW
class ATL_NO_VTABLE CMLStrW :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringWStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    CMLStrW(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrW)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringWStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/  DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    ~CMLStrW(void);
    POWNER GetOwner(void) const {return m_pOwner;}
    inline HRESULT GetAttrWStr(IMLStrAttrWStr** ppAttr);
    inline HRESULT GetAttrLocale(IMLStrAttrLocale** ppAttr);
    HRESULT GetAttrWStrReal(IMLStrAttrWStr** ppAttr);
    HRESULT GetAttrLocaleReal(IMLStrAttrLocale** ppAttr);

    CRITICAL_SECTION m_cs;
    IMLStrAttrWStr* m_pAttrWStr;
    IMLStrAttrLocale* m_pAttrLocale;
    DWORD m_dwAttrWStrCookie; // Returned by RegisterAttr
    DWORD m_dwAttrLocaleCookie; // Returned by RegisterAttr
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrW inline-line functions
HRESULT CMLStrW::GetAttrWStr(IMLStrAttrWStr** ppAttr)
{
    if (m_pAttrWStr)
    {
        if (ppAttr)
            *ppAttr = m_pAttrWStr;

        return S_OK;
    }
    else
    {
        return GetAttrWStrReal(ppAttr);
    }
}

HRESULT CMLStrW::GetAttrLocale(IMLStrAttrLocale** ppAttr)
{
    if (m_pAttrLocale)
    {
        if (ppAttr)
            *ppAttr = m_pAttrLocale;

        return S_OK;
    }
    else
    {
        return GetAttrLocaleReal(ppAttr);
    }
}

#endif //__MLSTRW_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\resource.h ===
#include "windows.h"
// For NT5 langpack dialog
#define IDD_DIALOG_LPK                  101
#define IDC_CHECK_LPK                   1000
#define IDC_STATIC_LANG                 201
#define IDC_STATIC                      -1

//
//  IDs for Mime Language Name (0x1000 - 0x10FF)
//
#define IDS_MIME_LANG_DEFAULT           0x1000
#define IDS_LANGPACK_INSTALL            0x1001
#define IDS_NO_ADMIN                    0x1002
#define IDS_NT5_LANGPACK                0x1003
//
//  IDs for Mime RFC1766 Name (0x1100 - 0x11FF)
//
#define IDS_RFC1766_LCID0436            0x1100            
#define IDS_RFC1766_LCID041C            0x1101
#define IDS_RFC1766_LCID0001            0x1102
#define IDS_RFC1766_LCID0401            0x1103
#define IDS_RFC1766_LCID0801            0x1104
#define IDS_RFC1766_LCID0C01            0x1105
#define IDS_RFC1766_LCID1001            0x1106
#define IDS_RFC1766_LCID1401            0x1107
#define IDS_RFC1766_LCID1801            0x1108
#define IDS_RFC1766_LCID1C01            0x1109
#define IDS_RFC1766_LCID2001            0x110A
#define IDS_RFC1766_LCID2401            0x110B
#define IDS_RFC1766_LCID2801            0x110C
#define IDS_RFC1766_LCID2C01            0x110D
#define IDS_RFC1766_LCID3001            0x110E
#define IDS_RFC1766_LCID3401            0x110F
#define IDS_RFC1766_LCID3801            0x1110
#define IDS_RFC1766_LCID3C01            0x1111
#define IDS_RFC1766_LCID4001            0x1112
#define IDS_RFC1766_LCID042D            0x1113
#define IDS_RFC1766_LCID0402            0x1114
#define IDS_RFC1766_LCID0423            0x1115
#define IDS_RFC1766_LCID0403            0x1116
#define IDS_RFC1766_LCID0004            0x1117
#define IDS_RFC1766_LCID0404            0x1118
#define IDS_RFC1766_LCID0804            0x1119
#define IDS_RFC1766_LCID0C04            0x111A
#define IDS_RFC1766_LCID1004            0x111B
#define IDS_RFC1766_LCID041A            0x111C
#define IDS_RFC1766_LCID0405            0x111D
#define IDS_RFC1766_LCID0406            0x111E
#define IDS_RFC1766_LCID0413            0x111F
#define IDS_RFC1766_LCID0813            0x1120
#define IDS_RFC1766_LCID0009            0x1121
#define IDS_RFC1766_LCID0409            0x1122
#define IDS_RFC1766_LCID0809            0x1123
#define IDS_RFC1766_LCID0C09            0x1124
#define IDS_RFC1766_LCID1009            0x1125
#define IDS_RFC1766_LCID1409            0x1126
#define IDS_RFC1766_LCID1809            0x1127
#define IDS_RFC1766_LCID1C09            0x1128
#define IDS_RFC1766_LCID2009            0x1129
#define IDS_RFC1766_LCID2809            0x112A
#define IDS_RFC1766_LCID2C09            0x112B
#define IDS_RFC1766_LCID0425            0x112C
#define IDS_RFC1766_LCID0438            0x112D
#define IDS_RFC1766_LCID0429            0x112E
#define IDS_RFC1766_LCID040B            0x112F
#define IDS_RFC1766_LCID040C            0x1130
#define IDS_RFC1766_LCID080C            0x1131
#define IDS_RFC1766_LCID0C0C            0x1132
#define IDS_RFC1766_LCID100C            0x1133
#define IDS_RFC1766_LCID140C            0x1134
#define IDS_RFC1766_LCID043C            0x1135
#define IDS_RFC1766_LCID0407            0x1136
#define IDS_RFC1766_LCID0807            0x1137
#define IDS_RFC1766_LCID0C07            0x1138
#define IDS_RFC1766_LCID1007            0x1139
#define IDS_RFC1766_LCID1407            0x113A
#define IDS_RFC1766_LCID0408            0x113B
#define IDS_RFC1766_LCID040D            0x113C
#define IDS_RFC1766_LCID0439            0x113D
#define IDS_RFC1766_LCID040E            0x113E
#define IDS_RFC1766_LCID040F            0x113F
#define IDS_RFC1766_LCID0421            0x1140
#define IDS_RFC1766_LCID0410            0x1141
#define IDS_RFC1766_LCID0810            0x1142
#define IDS_RFC1766_LCID0411            0x1143
#define IDS_RFC1766_LCID0412            0x1144
#define IDS_RFC1766_LCID0426            0x1145
#define IDS_RFC1766_LCID0427            0x1146
#define IDS_RFC1766_LCID042F            0x1147
#define IDS_RFC1766_LCID043E            0x1148
#define IDS_RFC1766_LCID043A            0x1149
#define IDS_RFC1766_LCID0414            0x114A
#define IDS_RFC1766_LCID0814            0x114B
#define IDS_RFC1766_LCID0415            0x114C
#define IDS_RFC1766_LCID0416            0x114D
#define IDS_RFC1766_LCID0816            0x114E
#define IDS_RFC1766_LCID0417            0x114F
#define IDS_RFC1766_LCID0418            0x1150
#define IDS_RFC1766_LCID0818            0x1151
#define IDS_RFC1766_LCID0419            0x1152
#define IDS_RFC1766_LCID0819            0x1153
#define IDS_RFC1766_LCID0C1A            0x1154
#define IDS_RFC1766_LCID081A            0x1155
#define IDS_RFC1766_LCID041B            0x1156
#define IDS_RFC1766_LCID0424            0x1157
#define IDS_RFC1766_LCID042E            0x1158
#define IDS_RFC1766_LCID040A            0x1159
#define IDS_RFC1766_LCID080A            0x115A
#define IDS_RFC1766_LCID0C0A            0x115B
#define IDS_RFC1766_LCID100A            0x115C
#define IDS_RFC1766_LCID140A            0x115D
#define IDS_RFC1766_LCID180A            0x115E
#define IDS_RFC1766_LCID1C0A            0x115F
#define IDS_RFC1766_LCID200A            0x1160
#define IDS_RFC1766_LCID240A            0x1161
#define IDS_RFC1766_LCID280A            0x1162
#define IDS_RFC1766_LCID2C0A            0x1163
#define IDS_RFC1766_LCID300A            0x1164
#define IDS_RFC1766_LCID340A            0x1165
#define IDS_RFC1766_LCID380A            0x1166
#define IDS_RFC1766_LCID3C0A            0x1167
#define IDS_RFC1766_LCID400A            0x1168
#define IDS_RFC1766_LCID440A            0x1169
#define IDS_RFC1766_LCID480A            0x116A
#define IDS_RFC1766_LCID4C0A            0x116B
#define IDS_RFC1766_LCID500A            0x116C
#define IDS_RFC1766_LCID0430            0x116D
#define IDS_RFC1766_LCID041D            0x116E
#define IDS_RFC1766_LCID081D            0x116F
#define IDS_RFC1766_LCID041E            0x1170
#define IDS_RFC1766_LCID0431            0x1171
#define IDS_RFC1766_LCID0432            0x1172
#define IDS_RFC1766_LCID041F            0x1173
#define IDS_RFC1766_LCID0422            0x1174
#define IDS_RFC1766_LCID0420            0x1175
#define IDS_RFC1766_LCID042A            0x1176
#define IDS_RFC1766_LCID0434            0x1177
#define IDS_RFC1766_LCID043D            0x1178
#define IDS_RFC1766_LCID0435            0x1179
#define IDS_RFC1766_LCID1404            0x117A
#define IDS_RFC1766_LCID2409            0x117B
#define IDS_RFC1766_LCID3009            0x117C
#define IDS_RFC1766_LCID3409            0x117D
#define IDS_RFC1766_LCID180C            0x117E
#define IDS_RFC1766_LCID042C            0x117F
#define IDS_RFC1766_LCID0843            0x1180
#define IDS_RFC1766_LCID0443            0x1181
#define IDS_RFC1766_LCID042B            0x1182
#define IDS_RFC1766_LCID0437            0x1183
#define IDS_RFC1766_LCID043F            0x1184
#define IDS_RFC1766_LCID0441            0x1185
#define IDS_RFC1766_LCID0444            0x1186
#define IDS_RFC1766_LCID0445            0x1187
#define IDS_RFC1766_LCID0446            0x1188
#define IDS_RFC1766_LCID0447            0x1189
#define IDS_RFC1766_LCID0448            0x118A
#define IDS_RFC1766_LCID0449            0x118B
#define IDS_RFC1766_LCID044A            0x118C
#define IDS_RFC1766_LCID044B            0x118D
#define IDS_RFC1766_LCID044C            0x118E
#define IDS_RFC1766_LCID044D            0x118F
#define IDS_RFC1766_LCID044E            0x1191
#define IDS_RFC1766_LCID083E            0x1192
#define IDS_RFC1766_LCID0861            0x1193
#define IDS_RFC1766_LCID044F            0x1194
// #define IDS_RFC1766_LCID0827            0x1195
#define IDS_RFC1766_LCID0457            0x1196
#define IDS_RFC1766_LCID082C            0x1197
#define IDS_RFC1766_LCID0440            0x1198
#define IDS_RFC1766_LCID0450            0x1199
#define IDS_RFC1766_LCID0456            0x119A
#define IDS_RFC1766_LCID045A            0x119B
#define IDS_RFC1766_LCID0465            0x119C
#define IDS_RFC1766_LCID540A            0x119D


//
//  IDs for Mime Codepage Name (0x1200 - 0x12FF)
//
#define IDS_DESC_1200                   0x1200
#define IDS_DESC_1201                   0x1201
#define IDS_DESC_1250                   0x1202
#define IDS_DESC_1251                   0x1203
#define IDS_DESC_1252                   0x1204
#define IDS_DESC_1253                   0x1205
#define IDS_DESC_1254                   0x1206
#define IDS_DESC_1255                   0x1207
#define IDS_DESC_1256                   0x1208
#define IDS_DESC_1257                   0x1209
#define IDS_DESC_1258                   0x120A
#define IDS_DESC_20105                  0x120B
#define IDS_DESC_20106                  0x120C
#define IDS_DESC_20107                  0x120D
#define IDS_DESC_20108                  0x120E
#define IDS_DESC_20866                  0x120F
#define IDS_DESC_21866                  0x1210
#define IDS_DESC_28592                  0x1211
#define IDS_DESC_28593                  0x1212
#define IDS_DESC_28594                  0x1213
#define IDS_DESC_28595                  0x1214
#define IDS_DESC_28596                  0x1215
#define IDS_DESC_28597                  0x1216
#define IDS_DESC_28598                  0x1217
#define IDS_DESC_50000                  0x1218
#define IDS_DESC_50220                  0x1219
#define IDS_DESC_50221                  0x121A
#define IDS_DESC_50222                  0x121B
#define IDS_DESC_50225                  0x121C
#define IDS_DESC_50932                  0x121D
#define IDS_DESC_50949                  0x121E
#define IDS_DESC_51932                  0x121F
#define IDS_DESC_51949                  0x1220
#define IDS_DESC_52936                  0x1221
#define IDS_DESC_65000                  0x1222
#define IDS_DESC_65001                  0x1223
#define IDS_DESC_852                    0x1224
#define IDS_DESC_866                    0x1225
#define IDS_DESC_874                    0x1226
#define IDS_DESC_932                    0x1227
#define IDS_DESC_936                    0x1228
#define IDS_DESC_949                    0x1229
#define IDS_DESC_950                    0x122A
#define IDS_DESC_38598                  0x122B
#define IDS_DESC_50001                  0x122C
#define IDS_DESC_708                    0x122D
#define IDS_DESC_720                    0x122E
#define IDS_DESC_862                    0x122F
#define IDS_DESC_28591                  0x1230
#define IDS_DESC_50936                  0x1231
#define IDS_DESC_50950                  0x1232   
#define IDS_DESC_51251                  0x1233
#define IDS_DESC_51253                  0x1234    
#define IDS_DESC_51256                  0x1235    
#define IDS_DESC_28599                  0x1236    
#define IDS_DESC_28605                  0x1237    
#define IDS_DESC_20127                  0x1238
#define IDS_DESC_51936                  0x1239
#define IDS_DESC_1361                   0x123A
#define IDS_DESC_437                    0x123B
#define IDS_DESC_1252_IE4               0x123C
#define IDS_DESC_29001                  0x123D
#define IDS_DESC_20000                  0x123E
#define IDS_DESC_20002                  0x123F
#define IDS_DESC_28603                  0x1240
#define IDS_DESC_850                    0x1241
#define IDS_DESC_737                    0x1242
#define IDS_DESC_869                    0x1243
#define IDS_DESC_775                    0x1244
#define IDS_DESC_857                    0x1245
#define IDS_DESC_861                    0x1246
#define IDS_DESC_10000                  0x1247
#define IDS_DESC_10001                  0x1248
#define IDS_DESC_10002                  0x1249
#define IDS_DESC_10003                  0x124A
#define IDS_DESC_10004                  0x124B
#define IDS_DESC_10005                  0x125C
#define IDS_DESC_10006                  0x125D
#define IDS_DESC_10007                  0x125E
#define IDS_DESC_10008                  0x125F
#define IDS_DESC_10029                  0x1260
#define IDS_DESC_10079                  0x1261
#define IDS_DESC_10081                  0x1262
#define IDS_DESC_37                     0x1263
#define IDS_DESC_500                    0x1264
#define IDS_DESC_870                    0x1265
#define IDS_DESC_875                    0x1266
#define IDS_DESC_1026                   0x1267
#define IDS_DESC_20273                  0x1268
#define IDS_DESC_20277                  0x1269
#define IDS_DESC_20278                  0x126A
#define IDS_DESC_20280                  0x126B
#define IDS_DESC_20284                  0x126C
#define IDS_DESC_20285                  0x126D
#define IDS_DESC_20290                  0x126E
#define IDS_DESC_20297                  0x126F
#define IDS_DESC_20420                  0x1270
#define IDS_DESC_20423                  0x1271
#define IDS_DESC_20424                  0x1272
#define IDS_DESC_20833                  0x1273
#define IDS_DESC_20838                  0x1274
#define IDS_DESC_20871                  0x1275
#define IDS_DESC_20880                  0x1276
#define IDS_DESC_20905                  0x1277
#define IDS_DESC_21025                  0x1278
#define IDS_DESC_50930                  0x1279
#define IDS_DESC_50931                  0x127A
#define IDS_DESC_50939                  0x127B
#define IDS_DESC_50933                  0x127C
#define IDS_DESC_50935                  0x127D
#define IDS_DESC_50937                  0x127E

#define IDS_DESC_1140                   0x127F
#define IDS_DESC_1141                   0x1280
#define IDS_DESC_1142                   0x1281
#define IDS_DESC_1143                   0x1282
#define IDS_DESC_1144                   0x1283
#define IDS_DESC_1145                   0x1284
#define IDS_DESC_1146                   0x1285
#define IDS_DESC_1147                   0x1286
#define IDS_DESC_1148                   0x1287
#define IDS_DESC_1149                   0x1288
#define IDS_DESC_57006                  0x1289
#define IDS_DESC_57003                  0x128A
#define IDS_DESC_57002                  0x128B
#define IDS_DESC_57010                  0x128C
#define IDS_DESC_57008                  0x128D
#define IDS_DESC_57009                  0x128E
#define IDS_DESC_57007                  0x128F
#define IDS_DESC_57011                  0x1290
#define IDS_DESC_57005                  0x1291
#define IDS_DESC_57004                  0x1292
#define IDS_DESC_10021                  0x1293
#define IDS_DESC_10010                  0x1294
#define IDS_DESC_10017                  0x1295
#define IDS_DESC_10082                  0x1296    
#define IDS_DESC_860                    0x1297    
#define IDS_DESC_863                    0x1298    
#define IDS_DESC_864                    0x1299    
#define IDS_DESC_865                    0x129A
#define IDS_DESC_54936                  0x129B
#define IDS_DESC_855                    0x129C
#define IDS_DESC_858                    0x129D
#define IDS_DESC_20924                  0x129E
#define IDS_DESC_1047                   0x129F
#define IDS_DESC_20001                  0x12a0
#define IDS_DESC_20003                  0x12a1
#define IDS_DESC_20004                  0x12a2
#define IDS_DESC_20005                  0x12a3
#define IDS_DESC_20261                  0x12a4
#define IDS_DESC_20269                  0x12a5
#define IDS_DESC_20936                  0x12a6
#define IDS_DESC_20949                  0x12a7
#define IDS_DESC_21027                  0x12a8
#define IDS_DESC_50227                  0x12a9
#define IDS_DESC_50229                  0x12aA
#define IDS_DESC_20932                  0x12AB

//
//  IDs for Mime Fontface Name (0x1300 - 0x13FF)
//
#define IDS_FONT_JAPANESE_FIXED         0x1300
#define IDS_FONT_JAPANESE_PROP          0x1301
#define IDS_FONT_CHINESE_FIXED          0x1302
#define IDS_FONT_CHINESE_PROP           0x1303
// a-ehuang: mail-Hyo Kyoung Kim-Kevin Gjerstad-9/14/98
#define IDS_FONT_KOREAN_FIXED           0x1304
#define IDS_FONT_KOREAN_PROP            0x1305
#define IDS_FONT_KOREAN_FIXED4          0x1306
#define IDS_FONT_KOREAN_PROP4           0x1307
// end-of-change
#define IDS_FONT_TAIWAN_FIXED           0x1308
#define IDS_FONT_TAIWAN_PROP            0x1309
#define IDS_FONT_WESTERN_FIXED          0x130A
#define IDS_FONT_WESTERN_PROP           0x130B
#define IDS_FONT_UNICODE_PROP           0x130C
#define IDS_FONT_HEBREW_FIXED           0x130D
#define IDS_FONT_HEBREW_PROP            0x130E
#define IDS_FONT_THAI_FIXED             0x130F
#define IDS_FONT_THAI_PROP              0x1310

#define IDS_FONT_ARABIC_FIXED           0x1311
#define IDS_FONT_ARABIC_PROP            0x1312
#define IDS_FONT_DEVANAGARI_FIXED       0x1313
#define IDS_FONT_DEVANAGARI_PROP        0x1314
#define IDS_FONT_TAMIL_FIXED            0x1315
#define IDS_FONT_TAMIL_PROP             0x1316
#define IDS_FONT_WESTERN_PROP2          0x1317
#define IDS_FONT_THAI_FIXED2            0x1318
#define IDS_FONT_THAI_PROP2             0x1319


//
// IDs for script descriptions (0x1400 - -x14FF)
//
#define IDS_SIDASCIILATIN               0x1400
#define IDS_SIDLATIN                    0x1401
#define IDS_SIDGREEK                    0x1402
#define IDS_SIDCYRILLIC                 0x1403
#define IDS_SIDARMENIAN                 0x1404
#define IDS_SIDHEBREW                   0x1405
#define IDS_SIDARABIC                   0x1406
#define IDS_SIDDEVANAGARI               0x1407
#define IDS_SIDBENGALI                  0x1408
#define IDS_SIDGURMUKHI                 0x1409
#define IDS_SIDGUJARATI                 0x140A
#define IDS_SIDORIYA                    0x140B
#define IDS_SIDTAMIL                    0x140C
#define IDS_SIDTELUGU                   0x140D
#define IDS_SIDKANNADA                  0x140E
#define IDS_SIDMALAYALAM                0x140F
#define IDS_SIDTHAI                     0x1410
#define IDS_SIDLAO                      0x1411
#define IDS_SIDTIBETAN                  0x1412
#define IDS_SIDGEORGIAN                 0x1413
#define IDS_SIDHANGUL                   0x1414
#define IDS_SIDKANA                     0x1415
#define IDS_SIDBOPOMOFO                 0x1416
#define IDS_SIDHAN                      0x1417
#define IDS_SIDETHIOPIC                 0x1418
#define IDS_SIDCANSYLLABIC              0x1419
#define IDS_SIDCHEROKEE                 0x141A
#define IDS_SIDYI                       0x141B
#define IDS_SIDBRAILLE                  0x141C
#define IDS_SIDRUNIC                    0x141D
#define IDS_SIDOGHAM                    0x141E
#define IDS_SIDSINHALA                  0x141F
#define IDS_SIDSYRIAC                   0x1420
#define IDS_SIDBURMESE                  0x1421
#define IDS_SIDKHMER                    0x1422
#define IDS_SIDTHAANA                   0x1423
#define IDS_SIDMONGOLIAN                0x1424
#define IDS_SIDDEFAULT                  0x1426
#define IDS_SIDMERGE                    0x1427
#define IDS_SIDASCIISYM                 0x1428
#define IDS_SIDUSERDEFINED              0x1429

//                                      
//  Other Resource IDs                  
//                                      
#define IDR_CODEPAGES                   0x2000
#define IDR_CODEPAGESEXT                0x2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\reg.cpp ===
#include "private.h"
#include <strsafe.h>

//
//  CLSID for MLANG objects
//
typedef struct tagCLSIDOBJ
{
    LPCTSTR szCLSID;
    LPCTSTR szDesc;
}   CLSIDOBJ, *LPCLSIDOBJ;

const CLSIDOBJ clsidObj[] =
{
    { TEXT("CLSID\\{275C23E2-3747-11D0-9FEA-00AA003F8646}"), TEXT("Multi Language Support") },          // CLSID_MLANG
    { TEXT("CLSID\\{C04D65CF-B70D-11D0-B188-00AA0038C969}"), TEXT("Multi Language String") },           // CLSID_MLANG
    { TEXT("CLSID\\{D66D6F99-CDAA-11D0-B822-00C04FC9B31F}"), TEXT("Multi Language ConvertCharset") },   // CLSID_MLANG
    { NULL, NULL }
};

LPCTSTR szInProcServer = TEXT("InProcServer32");
LPCTSTR szThreadingModel = TEXT("ThreadingModel");
LPCTSTR szThreadingModelValue = TEXT("Both");


HRESULT RegisterServerInfo(void)
{
    HKEY hKey = NULL, hKeySub = NULL;
    DWORD dwAction = 0;
    int i = 0;
    TCHAR szModule[MAX_PATH];
    HRESULT hr = S_OK;

    if (!GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule)))
        hr = E_FAIL;

    while (SUCCEEDED(hr) && clsidObj[i].szCLSID)
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS != RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)clsidObj[i].szDesc, (lstrlen(clsidObj[i].szDesc) + 1) * sizeof(TCHAR)))
                hr = E_FAIL;

            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, szInProcServer, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                if (ERROR_SUCCESS != RegSetValueEx(hKeySub, NULL, 0, REG_SZ, (LPBYTE)szModule, (lstrlen(szModule) + 1) * sizeof(TCHAR)))
                    hr = E_FAIL;
                if (ERROR_SUCCESS != RegSetValueEx(hKeySub, szThreadingModel, 0, REG_SZ, (LPBYTE)szThreadingModelValue, (lstrlen(szThreadingModelValue) + 1) * sizeof(TCHAR)))
                    hr = E_FAIL;

                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                hr = E_FAIL;

            RegCloseKey(hKey);
            hKey = NULL;
        }
        else
            hr = E_FAIL;
        i++;
    }
    return hr;
}

HRESULT UnregisterServerInfo(void)
{
    HKEY hKey = NULL;
    int i = 0;
    HRESULT hr = S_OK;

    while (clsidObj[i].szCLSID)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID, 0, KEY_ALL_ACCESS, &hKey))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS != RegDeleteKey(hKey, szInProcServer))
                hr = E_FAIL;

            RegCloseKey(hKey);
            hKey = NULL;

            if (ERROR_SUCCESS != RegDeleteKey(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID))
                hr = E_FAIL;
        }
        else
            hr = S_FALSE;
        i++;
    }
    return hr;
}



// Legacy code for Outlook Express and other clients who depend on MLang created MIME DB in registry
// Those client should switch to MLang interface for MIME data

long PrivRegSetValueEx(HKEY hKey, LPCTSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData, BOOL bOverWrite)
{
    long lRet = ERROR_SUCCESS;

    if (bOverWrite || ERROR_SUCCESS != RegQueryValueEx(hKey, lpValueName, 0, NULL, NULL, NULL))
        lRet = RegSetValueEx(hKey, lpValueName, 0, dwType, lpData, cbData);
    return lRet;
}

//
//  MIME database Key or Value name
//
LPCTSTR szMIMEDatabase = TEXT("MIME\\Database");
LPCTSTR szCharset = TEXT("Charset");
LPCTSTR szRfc1766 = TEXT("Rfc1766");
LPCTSTR szCodepage = TEXT("Codepage");
LPCTSTR szInternetEncoding = TEXT("InternetEncoding");
LPCTSTR szAliasForCharset = TEXT("AliasForCharset");
LPCTSTR szHeaderCharset = TEXT("HeaderCharset");
LPCTSTR szBodyCharset = TEXT("BodyCharset");
LPCTSTR szWebCharset = TEXT("WebCharset");
LPCTSTR szFixedWidthFont = TEXT("FixedWidthFont");
LPCTSTR szProportionalFont = TEXT("ProportionalFont");
LPCTSTR szDescription = TEXT("Description");
LPCTSTR szFamily = TEXT("Family");
LPCTSTR szLevel = TEXT("Level");
LPCTSTR szEncoding = TEXT("Encoding");

//
//  RFC1766 registry data at MIME\Database
//
typedef struct tagREGRFC1766
{
    LPCTSTR szLCID;
    LPCTSTR szAcceptLang;
    UINT    uidLCID;
}   REGRFC1766, *LPREGRFC1766;

const REGRFC1766 regRfc1766[] =
{
    { TEXT("0436"), TEXT("af"),    IDS_RFC1766_LCID0436 },
    { TEXT("041C"), TEXT("sq"),    IDS_RFC1766_LCID041C },
    { TEXT("0001"), TEXT("ar"),    IDS_RFC1766_LCID0001 },
    { TEXT("0401"), TEXT("ar-sa"), IDS_RFC1766_LCID0401 },
    { TEXT("0801"), TEXT("ar-iq"), IDS_RFC1766_LCID0801 },
    { TEXT("0C01"), TEXT("ar-eg"), IDS_RFC1766_LCID0C01 },
    { TEXT("1001"), TEXT("ar-ly"), IDS_RFC1766_LCID1001 },
    { TEXT("1401"), TEXT("ar-dz"), IDS_RFC1766_LCID1401 },
    { TEXT("1801"), TEXT("ar-ma"), IDS_RFC1766_LCID1801 },
    { TEXT("1C01"), TEXT("ar-tn"), IDS_RFC1766_LCID1C01 },
    { TEXT("2001"), TEXT("ar-om"), IDS_RFC1766_LCID2001 },
    { TEXT("2401"), TEXT("ar-ye"), IDS_RFC1766_LCID2401 },
    { TEXT("2801"), TEXT("ar-sy"), IDS_RFC1766_LCID2801 },
    { TEXT("2C01"), TEXT("ar-jo"), IDS_RFC1766_LCID2C01 },
    { TEXT("3001"), TEXT("ar-lb"), IDS_RFC1766_LCID3001 },
    { TEXT("3401"), TEXT("ar-kw"), IDS_RFC1766_LCID3401 },
    { TEXT("3801"), TEXT("ar-ae"), IDS_RFC1766_LCID3801 },
    { TEXT("3C01"), TEXT("ar-bh"), IDS_RFC1766_LCID3C01 },
    { TEXT("4001"), TEXT("ar-qa"), IDS_RFC1766_LCID4001 },
    { TEXT("042D"), TEXT("eu"),    IDS_RFC1766_LCID042D },
    { TEXT("0402"), TEXT("bg"),    IDS_RFC1766_LCID0402 },
    { TEXT("0423"), TEXT("be"),    IDS_RFC1766_LCID0423 },
    { TEXT("0403"), TEXT("ca"),    IDS_RFC1766_LCID0403 },
    { TEXT("0004"), TEXT("zh"),    IDS_RFC1766_LCID0004 },
    { TEXT("0404"), TEXT("zh-tw"), IDS_RFC1766_LCID0404 },
    { TEXT("0804"), TEXT("zh-cn"), IDS_RFC1766_LCID0804 },
    { TEXT("0C04"), TEXT("zh-hk"), IDS_RFC1766_LCID0C04 },
    { TEXT("1004"), TEXT("zh-sg"), IDS_RFC1766_LCID1004 },
    { TEXT("041A"), TEXT("hr"),    IDS_RFC1766_LCID041A },
    { TEXT("0405"), TEXT("cs"),    IDS_RFC1766_LCID0405 },
    { TEXT("0406"), TEXT("da"),    IDS_RFC1766_LCID0406 },
    { TEXT("0413"), TEXT("nl"),    IDS_RFC1766_LCID0413 },
    { TEXT("0813"), TEXT("nl-be"), IDS_RFC1766_LCID0813 },
    { TEXT("0009"), TEXT("en"),    IDS_RFC1766_LCID0009 },
    { TEXT("0409"), TEXT("en-us"), IDS_RFC1766_LCID0409 },
    { TEXT("0809"), TEXT("en-gb"), IDS_RFC1766_LCID0809 },
    { TEXT("0C09"), TEXT("en-au"), IDS_RFC1766_LCID0C09 },
    { TEXT("1009"), TEXT("en-ca"), IDS_RFC1766_LCID1009 },
    { TEXT("1409"), TEXT("en-nz"), IDS_RFC1766_LCID1409 },
    { TEXT("1809"), TEXT("en-ie"), IDS_RFC1766_LCID1809 },
    { TEXT("1C09"), TEXT("en-za"), IDS_RFC1766_LCID1C09 },
    { TEXT("2009"), TEXT("en-jm"), IDS_RFC1766_LCID2009 },
    { TEXT("2809"), TEXT("en-bz"), IDS_RFC1766_LCID2809 },
    { TEXT("2C09"), TEXT("en-tt"), IDS_RFC1766_LCID2C09 },
    { TEXT("0425"), TEXT("et"),    IDS_RFC1766_LCID0425 },
    { TEXT("0438"), TEXT("fo"),    IDS_RFC1766_LCID0438 },
    { TEXT("0429"), TEXT("fa"),    IDS_RFC1766_LCID0429 },
    { TEXT("040B"), TEXT("fi"),    IDS_RFC1766_LCID040B },
    { TEXT("040C"), TEXT("fr"),    IDS_RFC1766_LCID040C },
    { TEXT("080C"), TEXT("fr-be"), IDS_RFC1766_LCID080C },
    { TEXT("0C0C"), TEXT("fr-ca"), IDS_RFC1766_LCID0C0C },
    { TEXT("100C"), TEXT("fr-ch"), IDS_RFC1766_LCID100C },
    { TEXT("140C"), TEXT("fr-lu"), IDS_RFC1766_LCID140C },
    { TEXT("043C"), TEXT("gd"),    IDS_RFC1766_LCID043C },
    { TEXT("0407"), TEXT("de"),    IDS_RFC1766_LCID0407 },
    { TEXT("0807"), TEXT("de-ch"), IDS_RFC1766_LCID0807 },
    { TEXT("0C07"), TEXT("de-at"), IDS_RFC1766_LCID0C07 },
    { TEXT("1007"), TEXT("de-lu"), IDS_RFC1766_LCID1007 },
    { TEXT("1407"), TEXT("de-li"), IDS_RFC1766_LCID1407 },
    { TEXT("0408"), TEXT("el"),    IDS_RFC1766_LCID0408 },
    { TEXT("040D"), TEXT("he"),    IDS_RFC1766_LCID040D },
    { TEXT("0439"), TEXT("hi"),    IDS_RFC1766_LCID0439 },
    { TEXT("040E"), TEXT("hu"),    IDS_RFC1766_LCID040E },
    { TEXT("040F"), TEXT("is"),    IDS_RFC1766_LCID040F },
    { TEXT("0421"), TEXT("in"),    IDS_RFC1766_LCID0421 },
    { TEXT("0410"), TEXT("it"),    IDS_RFC1766_LCID0410 },
    { TEXT("0810"), TEXT("it-ch"), IDS_RFC1766_LCID0810 },
    { TEXT("0411"), TEXT("ja"),    IDS_RFC1766_LCID0411 },
    { TEXT("0412"), TEXT("ko"),    IDS_RFC1766_LCID0412 },
    { TEXT("0426"), TEXT("lv"),    IDS_RFC1766_LCID0426 },
    { TEXT("0427"), TEXT("lt"),    IDS_RFC1766_LCID0427 },
    { TEXT("042F"), TEXT("mk"),    IDS_RFC1766_LCID042F },
    { TEXT("043E"), TEXT("ms"),    IDS_RFC1766_LCID043E },
    { TEXT("043A"), TEXT("mt"),    IDS_RFC1766_LCID043A },
    { TEXT("0414"), TEXT("no"),    IDS_RFC1766_LCID0414 },
    { TEXT("0814"), TEXT("no"),    IDS_RFC1766_LCID0814 },
    { TEXT("0415"), TEXT("pl"),    IDS_RFC1766_LCID0415 },
    { TEXT("0416"), TEXT("pt-br"), IDS_RFC1766_LCID0416 },
    { TEXT("0816"), TEXT("pt"),    IDS_RFC1766_LCID0816 },
    { TEXT("0417"), TEXT("rm"),    IDS_RFC1766_LCID0417 },
    { TEXT("0418"), TEXT("ro"),    IDS_RFC1766_LCID0418 },
    { TEXT("0818"), TEXT("ro-mo"), IDS_RFC1766_LCID0818 },
    { TEXT("0419"), TEXT("ru"),    IDS_RFC1766_LCID0419 },
    { TEXT("0819"), TEXT("ru-mo"), IDS_RFC1766_LCID0819 },
    { TEXT("0C1A"), TEXT("sr"),    IDS_RFC1766_LCID0C1A },
    { TEXT("081A"), TEXT("sr"),    IDS_RFC1766_LCID081A },
    { TEXT("041B"), TEXT("sk"),    IDS_RFC1766_LCID041B },
    { TEXT("0424"), TEXT("sl"),    IDS_RFC1766_LCID0424 },
    { TEXT("042E"), TEXT("sb"),    IDS_RFC1766_LCID042E },
    { TEXT("040A"), TEXT("es"),    IDS_RFC1766_LCID040A },
    { TEXT("080A"), TEXT("es-mx"), IDS_RFC1766_LCID080A },
    { TEXT("0C0A"), TEXT("es"),    IDS_RFC1766_LCID0C0A },
    { TEXT("100A"), TEXT("es-gt"), IDS_RFC1766_LCID100A },
    { TEXT("140A"), TEXT("es-cr"), IDS_RFC1766_LCID140A },
    { TEXT("180A"), TEXT("es-pa"), IDS_RFC1766_LCID180A },
    { TEXT("1C0A"), TEXT("es-do"), IDS_RFC1766_LCID1C0A },
    { TEXT("200A"), TEXT("es-ve"), IDS_RFC1766_LCID200A },
    { TEXT("240A"), TEXT("es-co"), IDS_RFC1766_LCID240A },
    { TEXT("280A"), TEXT("es-pe"), IDS_RFC1766_LCID280A },
    { TEXT("2C0A"), TEXT("es-ar"), IDS_RFC1766_LCID2C0A },
    { TEXT("300A"), TEXT("es-ec"), IDS_RFC1766_LCID300A },
    { TEXT("340A"), TEXT("es-cl"), IDS_RFC1766_LCID340A },
    { TEXT("380A"), TEXT("es-uy"), IDS_RFC1766_LCID380A },
    { TEXT("3C0A"), TEXT("es-py"), IDS_RFC1766_LCID3C0A },
    { TEXT("400A"), TEXT("es-bo"), IDS_RFC1766_LCID400A },
    { TEXT("440A"), TEXT("es-sv"), IDS_RFC1766_LCID440A },
    { TEXT("480A"), TEXT("es-hn"), IDS_RFC1766_LCID480A },
    { TEXT("4C0A"), TEXT("es-ni"), IDS_RFC1766_LCID4C0A },
    { TEXT("500A"), TEXT("es-pr"), IDS_RFC1766_LCID500A },
    { TEXT("0430"), TEXT("sx"),    IDS_RFC1766_LCID0430 },
    { TEXT("041D"), TEXT("sv"),    IDS_RFC1766_LCID041D },
    { TEXT("081D"), TEXT("sv-fi"), IDS_RFC1766_LCID081D },
    { TEXT("041E"), TEXT("th"),    IDS_RFC1766_LCID041E },
    { TEXT("0431"), TEXT("ts"),    IDS_RFC1766_LCID0431 },
    { TEXT("0432"), TEXT("tn"),    IDS_RFC1766_LCID0432 },
    { TEXT("041F"), TEXT("tr"),    IDS_RFC1766_LCID041F },
    { TEXT("0422"), TEXT("uk"),    IDS_RFC1766_LCID0422 },
    { TEXT("0420"), TEXT("ur"),    IDS_RFC1766_LCID0420 },
    { TEXT("042A"), TEXT("vi"),    IDS_RFC1766_LCID042A },
    { TEXT("0434"), TEXT("xh"),    IDS_RFC1766_LCID0434 },
    { TEXT("043D"), TEXT("ji"),    IDS_RFC1766_LCID043D },
    { TEXT("0435"), TEXT("zu"),    IDS_RFC1766_LCID0435 },
    { NULL,         NULL,          0                    }
};

//
//  Charset registry data at MIME\Database
//
typedef struct tagREGCHARSET
{
    LPCTSTR szCharset;
    DWORD dwCodePage;
    DWORD dwInternetEncoding;
    LPCTSTR szAliasForCharset;
    DWORD dwCharsetMask;
}   REGCHARSET, *LPREGCHARSET;

const REGCHARSET regCharset[] =
{
    { TEXT("_autodetect_all"), 50001, 50001, NULL, 0x0 },
    { TEXT("_autodetect"), 50932, 50932, NULL, 0x0 },
    { TEXT("_autodetect_kr"), 50949, 50949, NULL, 0x0 },
    { TEXT("_iso-2022-jp$ESC"), 932, 50221, NULL, 0x0 },
    { TEXT("_iso-2022-jp$SIO"), 932, 50222, NULL, 0x3 },
    { TEXT("Big5"), 950, 950, NULL, 0x0 },
    { TEXT("ks_c_5601-1987"), 949, 949, NULL, 0x3 },
    { TEXT("euc-kr"), 949, 949, NULL, 0x3 },
    { TEXT("GB2312"), 936, 936, NULL, 0x0 },
    { TEXT("hz-gb-2312"), 936, 52936, NULL, 0x0 },
    { TEXT("ibm852"), 852, 852, NULL, 0x3 },
    { TEXT("ibm866"), 866, 866, NULL, 0x3 },
    { TEXT("iso-2022-jp"), 932, 50220, NULL,0x3 },
    { TEXT("iso-2022-kr"), 949, 50225, NULL, 0x3 },
    { TEXT("iso-8859-1"), 1252, 1252, NULL, 0x0 },
    { TEXT("iso-8859-2"), 1250, 28592, NULL, 0x0 },
    { TEXT("iso-8859-3"), 1254, 28593, NULL, 0x0 },
    { TEXT("iso-8859-4"), 1257, 28594, NULL, 0x0 },
    { TEXT("iso-8859-5"), 1251, 28595, NULL, 0x0 },
    { TEXT("iso-8859-6"), 1256, 28596, NULL, 0x0 },
    { TEXT("iso-8859-7"), 1253, 28597, NULL, 0x0 },
    { TEXT("iso-8859-8"), 1255, 28598, NULL, 0x2 },
    { TEXT("iso-8859-8-i"), 1255, 38598, NULL, 0x0 },
    { TEXT("iso-8859-9"), 1254, 1254, NULL, 0x0 },
    { TEXT("iso-8859-11"), 0, 0, TEXT("windows-874"), 0x0 },
    { TEXT("koi8-r"), 1251, 20866, NULL, 0x0 },
    { TEXT("koi8-ru"), 1251, 21866, NULL, 0x2 },
    { TEXT("shift_jis"), 932, 932, NULL, 0x0 },
    { TEXT("unicode-1-1-utf-7"), 0, 0, TEXT("utf-7"), 0x4 },
    { TEXT("unicode-1-1-utf-8"), 0, 0, TEXT("utf-8"), 0x0 },
    { TEXT("x-unicode-2-0-utf-7"), 0, 0, TEXT("utf-7"), 0x4 },
    { TEXT("x-unicode-2-0-utf-8"), 0, 0, TEXT("utf-8"), 0x4 },
    { TEXT("utf-7"), 1200, 65000, NULL, 0x1 },
    { TEXT("utf-8"), 1200, 65001, NULL, 0x1 },
    { TEXT("unicode"), 1200, 1200, NULL, 0x0 },
    { TEXT("unicodeFFFE"), 1200, 1201, NULL, 0x0 },
    { TEXT("windows-1250"), 1250, 1250, NULL, 0x0 },
    { TEXT("windows-1251"), 1251, 1251, NULL, 0x0 },
    { TEXT("windows-1252"), 1252, 1252, NULL, 0x0 },
    { TEXT("windows-1253"), 1253, 1253, NULL, 0x0 },
    { TEXT("windows-1255"), 1255, 1255, NULL, 0x0 },
    { TEXT("windows-1256"), 1256, 1256, NULL, 0x0 },
    { TEXT("windows-1257"), 1257, 1257, NULL, 0x0 },
    { TEXT("windows-1258"), 1258, 1258, NULL, 0x0 },
    { TEXT("windows-874"), 874, 874, NULL, 0x0 },
    { TEXT("x-user-defined"), 50000, 50000, NULL, 0x0 },
    { TEXT("x-ansi"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("euc-jp"), 932, 51932, NULL, 0x0 },
    { TEXT("x-euc-jp"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("x-euc"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("x-ms-cp932"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("x-sjis"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("ANSI_X3.4-1968"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("ANSI_X3.4-1986"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("ascii"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("chinese"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("CN-GB"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("cp866"), 0, 0, TEXT("ibm866"), 0x0 },
    { TEXT("cp852"), 0, 0, TEXT("ibm852"), 0x0 },
    { TEXT("cp367"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("cp819"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("csASCII"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("csbig5"), 0, 0, TEXT("big5"), 0x0 },
    { TEXT("csEUCPkdFmtJapanese"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("csGB2312"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("csISO2022KR"), 0, 0, TEXT("iso-2022-kr"), 0x0 },
    { TEXT("csISO58GB231280"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("csISOLatin2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("csISOLatin4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("csISOLatin5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("csISOLatinCyrillic"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("csISOLatinGreek"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("csISOLatinHebrew"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("csKSC56011987"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("csShiftJIS"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("csUnicode11UTF7"), 0, 0, TEXT("utf-7"), 0x0 },
    { TEXT("csWindows31J"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("cyrillic"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ECMA-118"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ELOT_928"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("greek"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("greek8"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("hebrew"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("IBM367"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("ibm819"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("ISO_646.irv:1991"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-1:1987"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("iso_8859-2:1987"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("ISO_8859-4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("ISO_8859-5"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ISO_8859-7"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ISO_8859-8"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-9"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("ISO646-US"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso8859-1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso-ir-100"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso-ir-101"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("iso-ir-110"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("iso-ir-126"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("iso-ir-138"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("iso-ir-144"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("iso-ir-148"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("iso-ir-58"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("iso-ir-6"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("korean"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("ks_c_5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("l2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("l4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("l5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("latin1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("latin2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("latin4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("latin5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("ms_Kanji"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("shift-jis"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("unicode-2-0-utf-8"), 0, 0, TEXT("utf-8"), 0x0 },
    { TEXT("us-ascii"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("us"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("x-cp1250"), 0, 0, TEXT("Windows-1250"), 0x0 },
    { TEXT("x-cp1251"), 0, 0, TEXT("Windows-1251"), 0x0 },
    { TEXT("x-x-big5"), 0, 0, TEXT("big5"), 0x0 },
    { TEXT("csISO2022JP"), 0, 0, TEXT("_iso-2022-jp$ESC"), 0x4 },
    { TEXT("csKOI8R"), 0, 0, TEXT("koi8-r"), 0x0 },
    { TEXT("Extended_UNIX_Code_Packed_Format_for_Japanese"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("GB_2312-80"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("GBK"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("ISO_8859-4:1988"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("ISO_8859-5:1988"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ISO_8859-7:1987"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ISO_8859-8:1988"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-9:1989"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("iso8859-2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("koi"), 0, 0, TEXT("koi8-r"), 0x0 },
    { TEXT("Windows-1254"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("DOS-720"), 1256, 720, NULL, 0x0 },
    { TEXT("DOS-862"), 1255, 862, NULL, 0x0 },
    { TEXT("DOS-874"), 874, 874, NULL, 0x0 },
    { TEXT("ASMO-708"), 1256, 708, NULL, 0x0 },
    { TEXT("csEUCKR"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("csISOLatin1"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("iso-ir-111"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("iso-ir-149"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("KSC_5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("KSC5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("ks_c_5601-1989"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("l1"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("cp1256"), 0, 0, TEXT("windows-1256"), 0x0 },
    { TEXT("logical"), 0, 0, TEXT("windows-1255"), 0x0 },
    { TEXT("csISOLatinArabic"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("ECMA-114"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("visual"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO-8859-8 Visual"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-6"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("iso-ir-127"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("ISO_8859-6:1987"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("arabic"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { NULL, 0, 0, NULL, 0 }    
};

//
//  Codepage registry data at MIME\Database
//
typedef struct tagREGCODEPAGE
{
    LPCTSTR szCodePage;
    LPCTSTR szHeaderCharset;
    LPCTSTR szBodyCharset;
    LPCTSTR szWebCharset;
    UINT uidFixedWidthFont;
    UINT uidProportionalFont;
    UINT uidDescription;
    DWORD dwFamily;
    DWORD dwLevel;
    DWORD dwEncoding;
    DWORD dwCodePageMask;
}   REGCODEPAGE, *LPREGCODEPAGE;

const REGCODEPAGE regCodePage[] =
{
    { TEXT("1200"), NULL, TEXT("unicode"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1200, 0, 0x00000204, 0x00000101, 0xA0 },
    { TEXT("1201"), NULL, TEXT("unicodeFFFE"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1201, 1200, 0x00000000, 0x00000101,0xE0 },
    { TEXT("1250"), NULL, TEXT("iso-8859-2"), TEXT("windows-1250"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303, 0x00000202, 0xA0 },
    { TEXT("1251"), NULL, TEXT("koi8-r"), TEXT("windows-1251"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303, 0x00000202, 0xA0 },
    { TEXT("1252"), NULL, TEXT("iso-8859-1"), TEXT("iso-8859-1"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252, 0, 0x00000707, 0x00000000, 0xA4 },
    { TEXT("1253"), NULL, TEXT("iso-8859-7"), TEXT("windows-1253"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303, 0x00000101, 0x100A6 },
    { TEXT("1254"), NULL, TEXT("iso-8859-9"), TEXT("iso-8859-9"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707, 0x00000202, 0xA0 },
    { TEXT("1255"), NULL, TEXT("iso-8859-8-i"), TEXT("windows-1255"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1255, 0, 0x00000303, 0x00000101, 0xA2 },
    { TEXT("1256"), NULL, TEXT("iso-8859-6"), TEXT("windows-1256"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1256, 0, 0x00000303, 0x00000101, 0xA0 },
    { TEXT("1257"), NULL, TEXT("iso-8859-4"), TEXT("windows-1257"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707, 0x00000202, 0xA0 },
    { TEXT("1258"), NULL, TEXT("windows-1258"), TEXT("windows-1258"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1258, 0, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("20866"), NULL, TEXT("koi8-r"), NULL, 0, 0, IDS_DESC_20866, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("21866"), NULL, TEXT("koi8-ru"), NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28592"), NULL, TEXT("iso-8859-2"), NULL, 0, 0, IDS_DESC_28592, 1250, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("28593"), NULL, TEXT("iso-8859-3"), NULL, 0, 0, IDS_DESC_28593, 1254, 0x00000701, 0x00000000, 0xA0 },
    { TEXT("28594"), NULL, TEXT("iso-8859-4"), NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000301, 0x00000000, 0xA0 },
    { TEXT("28595"), NULL, TEXT("iso-8859-5"), NULL, 0, 0, IDS_DESC_28595, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28596"), NULL, TEXT("iso-8859-6"), NULL, 0, 0, IDS_DESC_28596, 1256, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("28597"), NULL, TEXT("iso-8859-7"), NULL, 0, 0, IDS_DESC_28597, 1253, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("50000"), NULL, TEXT("x-user-defined"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_UNICODE_PROP, IDS_DESC_50000, 0, 0x00000303, 0x00000000, 0xA0 },
    { TEXT("50220"), NULL, TEXT("iso-2022-jp"), NULL, 0, 0, IDS_DESC_50220, 932, 0x00000101, 0x00000000, 0xE2 },
    { TEXT("50221"), NULL, TEXT("_iso-2022-jp$ESC"), TEXT("csISO2022JP"), 0, 0, IDS_DESC_50221, 932, 0x00000301, 0x00000000, 0xE6 },
    { TEXT("50222"), NULL, TEXT("_iso-2022-jp$SIO"), TEXT("iso-2022-jp"), 0, 0, IDS_DESC_50222, 932, 0x00000101, 0x00000000, 0xE6 },
    { TEXT("50225"), NULL, TEXT("iso-2022-kr"), TEXT("iso-2022-kr"), 0, 0, IDS_DESC_50225, 949, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("50001"), NULL, TEXT("_autodetect_all"), NULL, 0, 0, IDS_DESC_50001, 0, 0x00000007, 0x00000101, 0xA2 },
    { TEXT("50932"), NULL, TEXT("_autodetect"), NULL, 0, 0, IDS_DESC_50932, 932, 0x00000007, 0x00000101, 0xA2 },
    { TEXT("50949"), NULL, TEXT("_autodetect_kr"), NULL, 0, 0, IDS_DESC_50949, 949, 0x00000001, 0x00000101, 0xA0 },
    { TEXT("51932"), NULL, TEXT("euc-jp"), NULL, 0, 0, IDS_DESC_51932, 932, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("51949"), NULL, TEXT("euc-kr"), NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000, 0x00000101, 0xE2 },
    { TEXT("52936"), NULL, TEXT("hz-gb-2312"), NULL, 0, 0, IDS_DESC_52936, 936, 0x00000303, 0x00000000, 0xA2 },
    { TEXT("65000"), NULL, TEXT("utf-7"), NULL, 0, 0, IDS_DESC_65000, 1200, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("65001"), NULL, TEXT("utf-8"), NULL, 0, 0, IDS_DESC_65001, 1200, 0x00000303, 0x00000000, 0xA0 },
    { TEXT("852"), NULL, TEXT("ibm852"), NULL, 0, 0, IDS_DESC_852, 1250, 0x00000202, 0x00000000, 0xE0 },
    { TEXT("866"), NULL, TEXT("cp866"), NULL, 0, 0, IDS_DESC_866, 1251, 0x00000202, 0x00000000, 0xA0 },
    { TEXT("874"), NULL, TEXT("windows-874"), TEXT("windows-874"), IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_874, 0, 0x00000707, 0x00000101, 0x1B8 },
    { TEXT("932"), NULL, TEXT("iso-2022-jp"), TEXT("shift_jis"), IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, IDS_DESC_932, 0, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("936"), NULL, TEXT("gb2312"), NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_936, 0, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("949"), TEXT("euc-kr"), TEXT("euc-kr"), TEXT("ks_c_5601-1987"), IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_949, 0, 0x00000707, 0x00000101, 0xA7 },
    { TEXT("950"), NULL, TEXT("big5"), NULL, IDS_FONT_TAIWAN_FIXED, IDS_FONT_TAIWAN_PROP, IDS_DESC_950, 0, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28598"), NULL, TEXT("iso-8859-8"), NULL, 0, 0, IDS_DESC_28598, 1255, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("38598"), NULL, TEXT("iso-8859-8-i"), NULL, IDS_FONT_HEBREW_FIXED, IDS_FONT_HEBREW_PROP, IDS_DESC_38598, 1255, 0x00000707, 0x00000101, 0xB8 },
    { TEXT("708"), NULL, TEXT("ASMO-708"), NULL, 0, 0, IDS_DESC_708, 1256, 0x00000707, 0, 0xA0 },
    { TEXT("720"), NULL, TEXT("DOS-720"), NULL, 0, 0, IDS_DESC_720, 1256, 0x00000707, 0, 0xA0 },
    { TEXT("862"), NULL, TEXT("DOS-862"), NULL, 0, 0, IDS_DESC_862, 1255, 0x00000707, 0, 0xA0 },
    { NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0x00000000, 0x00000000, 0x0  }        
};


BOOL MimeDatabaseInfo(void)
{
    HKEY hKey = NULL, hKeySub = NULL;
    TCHAR szKey[32], szValue[256];
    int i;
    BOOL bNewKey, bOverWrite;
    DWORD dwAction;
    BOOL bRet = TRUE;
    HRESULT hr = E_FAIL;

    // MIME\Database\CodePage
    //*STRSAFE*     wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szCodepage);
    hr = StringCchPrintf(szKey , ARRAYSIZE(szKey),  TEXT("%s\\%s"), szMIMEDatabase, szCodepage);
    if (!SUCCEEDED(hr))
    {
       return FALSE;
    }
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        bNewKey = (dwAction == REG_CREATED_NEW_KEY);
        while (regCodePage[i].szCodePage)
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, regCodePage[i].szCodePage, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                bOverWrite = (bNewKey || dwAction == REG_CREATED_NEW_KEY);
                if (regCodePage[i].szHeaderCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szHeaderCharset, REG_SZ, (LPBYTE)regCodePage[i].szHeaderCharset, (lstrlen(regCodePage[i].szHeaderCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_HEADER_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_HEADER_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szHeaderCharset);
                    }
                }
                if (regCodePage[i].szBodyCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szBodyCharset, REG_SZ, (LPBYTE)regCodePage[i].szBodyCharset, (lstrlen(regCodePage[i].szBodyCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_BODY_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_BODY_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szBodyCharset);
                    }
                }
                if (regCodePage[i].szWebCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szWebCharset, REG_SZ, (LPBYTE)regCodePage[i].szWebCharset, (lstrlen(regCodePage[i].szWebCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_WEB_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_WEB_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szWebCharset);
                    }
                }
                if (regCodePage[i].uidFixedWidthFont)
                {
                    LoadString(g_hInst, regCodePage[i].uidFixedWidthFont, szValue, sizeof(szValue));
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szFixedWidthFont, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_WEB_FIXED_WIDTH_FONT)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_WEB_FIXED_WIDTH_FONT)
                    {
                        RegDeleteValue(hKeySub, szFixedWidthFont);
                    }
                }
                if (regCodePage[i].uidProportionalFont)
                {
                    LoadString(g_hInst, regCodePage[i].uidProportionalFont, szValue, sizeof(szValue));
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szProportionalFont, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_PROPORTIONAL_FONT)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_PROPORTIONAL_FONT)
                    {
                        RegDeleteValue(hKeySub, szProportionalFont);
                    }
                }
                if (regCodePage[i].uidDescription)
                {
                    LANGID lid = GetSystemDefaultLangID();

                    // Unsupported language resource?
                    if (!_LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), lid))
                    {
                        // First try, primary language
                        lid = MAKELANGID(PRIMARYLANGID(lid), SUBLANG_NEUTRAL);                         
                        if (!_LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), lid))
                        {
                            // Last try, switch to English, US
                            _LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
                        }
                    }

                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szDescription, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_DESCRIPTION)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_DESCRIPTION)
                    {
                        RegDeleteValue(hKeySub, szDescription);
                    }
                }
                if (regCodePage[i].dwFamily)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szFamily, REG_DWORD, (LPBYTE)&regCodePage[i].dwFamily, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_FAMILY)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_FAMILY)
                    {
                        RegDeleteValue(hKeySub, szFamily);
                    }
                }
                if (regCodePage[i].dwLevel)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szLevel, REG_BINARY, (LPBYTE)&regCodePage[i].dwLevel, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_LEVEL)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_LEVEL)
                    {
                        RegDeleteValue(hKeySub, szLevel);
                    }
                }
                if (regCodePage[i].dwEncoding)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szEncoding, REG_BINARY, (LPBYTE)&regCodePage[i].dwEncoding, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_ENCODING)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_ENCODING)
                    {
                        RegDeleteValue(hKeySub, szEncoding);
                    }
                }
                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    // MIME\Database\Charset
    //*STRSAFE*     wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szCharset);
    hr = StringCchPrintf(szKey , ARRAYSIZE(szKey),  TEXT("%s\\%s"), szMIMEDatabase, szCharset);
    if (!SUCCEEDED(hr))
    {
       return FALSE;
    }
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        bNewKey = (dwAction == REG_CREATED_NEW_KEY);
        while (regCharset[i].szCharset)
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, regCharset[i].szCharset, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                bOverWrite = (bNewKey || dwAction == REG_CREATED_NEW_KEY);
                if (regCharset[i].szAliasForCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szAliasForCharset, REG_SZ, (LPBYTE)regCharset[i].szAliasForCharset, (lstrlen(regCharset[i].szAliasForCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCharset[i].dwCharsetMask & BIT_ALIAS_FOR_CHARSET)))
                        bRet = FALSE;
                }
                else
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szCodepage, REG_DWORD, (LPBYTE)&regCharset[i].dwCodePage, sizeof(DWORD), bOverWrite || (regCharset[i].dwCharsetMask & BIT_CODEPAGE)))
                        bRet = FALSE;
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szInternetEncoding, REG_DWORD, (LPBYTE)&regCharset[i].dwInternetEncoding, sizeof(DWORD), bOverWrite || (regCharset[i].dwCharsetMask & BIT_INTERNET_ENCODING)))
                        bRet = FALSE;
                }
                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    // MIME\Database\Rfc1766
    //*STRSAFE*     wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szRfc1766);
    hr = StringCchPrintf(szKey , ARRAYSIZE(szKey),  TEXT("%s\\%s"), szMIMEDatabase, szRfc1766);
    if (!SUCCEEDED(hr))
    {
       return FALSE;
    }
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        while (regRfc1766[i].szLCID)
        {
            TCHAR szBuf[256];
            LANGID lid = GetSystemDefaultLangID();

            if (!_LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), lid))
            {
                // First try, primary language
                lid = MAKELANGID(PRIMARYLANGID(lid), SUBLANG_NEUTRAL);
                if (!_LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), lid))
                {
                    // Last try, switch to English, US
                    _LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
                }
            }

            //*STRSAFE*             wsprintf(szValue, TEXT("%s;%s"), regRfc1766[i].szAcceptLang, szBuf);
            hr = StringCchPrintf(szValue , ARRAYSIZE(szValue),  TEXT("%s;%s"), regRfc1766[i].szAcceptLang, szBuf);
            if (!SUCCEEDED(hr))
            {
                RegCloseKey(hKey);
                return FALSE;
            }
            if (ERROR_SUCCESS != PrivRegSetValueEx(hKey, regRfc1766[i].szLCID, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite))
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\rfc1766.cpp ===
#include "private.h"

//
//  Globals
//


#if 0
STDAPI EnumRfc1766Info(DWORD dwIndex, PRFC1766INFOA pRfc1766Info)
{
    EnsureRfc1766Table();

    if (NULL != pRfc1766Info)
    {
        if (dwIndex < g_cRfc1766)
        {
            *pRfc1766Info = g_pRfc1766[dwIndex];
            return S_OK;    
        }
        else
            return S_FALSE;
    }
    return E_INVALIDARG;
}    
#endif

STDAPI LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    if (0 < iMaxLength)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            if (WideCharToMultiByte(1252, 0, MimeRfc1766[i].szRfc1766, -1, pszRfc1766, iMaxLength, NULL, NULL))
                hr = S_OK;
        }
        else
        {
            CHAR sz[MAX_RFC1766_NAME];

            int nISO639 = GetLocaleInfoA(Locale, LOCALE_SISO639LANGNAME, sz, ARRAYSIZE(sz));

            if (nISO639)
            {
                // Two letter language name
                if (nISO639 == 3)
                {
                    sz[2] = '-';
                    if (3 != GetLocaleInfoA(Locale, LOCALE_SISO3166CTRYNAME, &sz[3], ARRAYSIZE(sz)-3))
                    {
                        sz[2] = 0;
                    }
                }
                // Three letter language name
                else if (nISO639 == 4)
                {
                    sz[3] = 0;
                }

                if (nISO639 <= 4)
                {
                    CharLowerA(sz);

                    if (lstrcpynA(pszRfc1766, sz, iMaxLength))
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}    



STDAPI LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    if (0 < nChar)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            MLStrCpyNW(pwszRfc1766, MimeRfc1766[i].szRfc1766, nChar);
            hr = S_OK;
        }
        else
        {
            CHAR sz[MAX_RFC1766_NAME];
            int nISO639 = GetLocaleInfoA(Locale, LOCALE_SISO639LANGNAME, sz, ARRAYSIZE(sz));

            if (nISO639)
            {
                // Two letter language name
                if (nISO639 == 3)
                {
                    sz[2] = '-';
                    if (3 != GetLocaleInfoA(Locale, LOCALE_SISO3166CTRYNAME, &sz[3], ARRAYSIZE(sz)))
                    {
                        sz[2] = 0;
                    }
                }
                // Three letter language name
                else if (nISO639 == 4)
                {
                    sz[3] = 0;
                }

                if (nISO639 <= 4)
                {
                    CharLowerA(sz);

                    if (MultiByteToWideChar(1252, 0, sz, lstrlen(sz)+1, pwszRfc1766, nChar))
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}    

STDAPI Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;
    
    if (NULL != pLocale && NULL != pwszRfc1766)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (!MLStrCmpIW(MimeRfc1766[i].szRfc1766, pwszRfc1766))
                break;
        }
        if (i < g_cRfc1766)
        {
            *pLocale = MimeRfc1766[i].LcId;
            hr = S_OK;
        }
        else
        {
            if (InRange(lstrlenW(pwszRfc1766), 2, MAX_RFC1766_NAME-1))
            {
                WCHAR sz[MAX_RFC1766_NAME];
                LPWSTR pDash;

                MLStrCpyNW(sz, pwszRfc1766, MAX_RFC1766_NAME);

                pDash = wcschr(sz, L'-');

                if (pDash && (pDash - sz >= 2))
                {
                    *pDash = 0;
                }

                for (i = 0; i < g_cRfc1766; i++)
                {
                    if (!MLStrCmpIW(MimeRfc1766[i].szRfc1766, sz))
                        break;                
                }
                if (i < g_cRfc1766)
                {
                    *pLocale = MimeRfc1766[i].LcId;
                    hr = S_FALSE;
                }
                else
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}

STDAPI Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pLocale && NULL != pszRfc1766)
    {
        int i;
        WCHAR sz[MAX_RFC1766_NAME];


        for (i = 0; i < MAX_RFC1766_NAME - 1; i++)
        {
            sz[i] = (WCHAR)pszRfc1766[i];
            if (0 == sz[i])
                break;
        }
        if (i == MAX_RFC1766_NAME -1)
            sz[i] = 0;

        hr = Rfc1766ToLcidW(pLocale, (LPCWSTR)sz);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\utf8obj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from UTF-8
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "utf8obj.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF8In::CInccUTF8In(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF8In::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nByteFollow = 0 ;
    m_tcUnicode = 0 ;
    m_tcSurrogateUnicode = 0 ;
    m_nBytesUsed = 0 ;
    m_fSurrogatesPairs = FALSE;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccUTF8In::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF8In::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccUTF8In::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    if( ( 0x80 & tc ) == 0 )                    // BIT7 == 0 ASCII
    {
        Output(tc);
        fDone = Output(0);
        m_nBytesUsed = 0 ; 
    }
    else if( (0x40 & tc) == 0 )                 // BIT6 == 0 a trail byte
    {
        if( m_nByteFollow )                
        {
            if (m_fSurrogatesPairs)
            {
                m_nByteFollow--;
                m_tcSurrogateUnicode <<= 6;             // Make room for trail byte
                m_tcSurrogateUnicode |= ( 0x3F & tc );  // LOWER_6BIT add trail byte value

                if( m_nByteFollow == 0)                 // End of sequence, advance output ptr
                {
                    m_tcUnicode = (WCHAR)(((m_tcSurrogateUnicode - 0x10000) >> 10) + HIGHT_SURROGATE_START);
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_tcUnicode = (WCHAR)((m_tcSurrogateUnicode - 0x10000)%0x400 + LOW_SURROGATE_START);
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_fSurrogatesPairs = 0;
                    m_nBytesUsed = 0 ; 
                }   
                else
                    m_nBytesUsed++ ; 
            }
            else
            {
                m_nByteFollow--;
                m_tcUnicode <<= 6;                  // make room for trail byte
                m_tcUnicode |= ( 0x3F & tc );       // LOWER_6BIT add trail byte value

                if( m_nByteFollow == 0)             // end of sequence, advance output ptr
                {
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_nBytesUsed = 0 ; 
                }   
                else
                    m_nBytesUsed++ ; 
            }
        }
        else                                    // error - ignor and rest
        {
            m_nBytesUsed = 0 ; 
            m_nByteFollow = 0 ;
        }
    }
    else                                        // a lead byte
    {
        if( m_nByteFollow > 0 )                 // error, previous sequence not finished
        {
            m_nByteFollow = 0;
            Output(' ');
            fDone = Output(0);
            m_nBytesUsed = 0 ; 
        }
        else                                    // calculate # bytes to follow
        {
            while( (0x80 & tc) != 0)            // BIT7 until first 0 encountered from left to right
            {
                tc <<= 1;
                m_nByteFollow++;
            }

            if (m_nByteFollow == 4)
            {
                m_fSurrogatesPairs = TRUE;
                m_tcSurrogateUnicode = tc >> m_nByteFollow;

            }
            else
            {
                m_tcUnicode = ( tc >> m_nByteFollow ) ;
                m_nBytesUsed = 1 ;               // # bytes used
            }
            m_nByteFollow--;                     // # bytes to follow
        }
    }

    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccUTF8In::CleanUpMain()
{
    return TRUE;
}

int CInccUTF8In::GetUnconvertBytes()
{
    return  m_nBytesUsed < 4 ? m_nBytesUsed : 3 ; 
}

DWORD CInccUTF8In::GetConvertMode()
{
    // UTF8 does not use mode esc sequence
    return 0 ;
}

void CInccUTF8In::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    // UTF8 does not use mode esc sequence
    return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to UTF-8
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF8Out::CInccUTF8Out(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF8Out::Reset()
{
    m_fDoubleByte = FALSE;
    m_wchSurrogateHigh = 0;
    return ;
}

HRESULT CInccUTF8Out::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    WORD uc ;
    UCHAR UTF8[4] ;

    if (m_fDoubleByte )
    {
        uc = (  (WORD) tc << 8 | m_tcLeadByte  ) ;

        if (uc >= HIGHT_SURROGATE_START && uc <= HIGHT_SURROGATE_END && cchSrc >= sizeof(WCHAR))
        {
            if (m_wchSurrogateHigh)
            {
                UTF8[0] = 0xe0 | ( m_wchSurrogateHigh >> 12 );              // 4 bits in first byte
                UTF8[1] = 0x80 | ( ( m_wchSurrogateHigh >> 6 ) & 0x3f );    // 6 bits in second
                UTF8[2] = 0x80 | ( 0x3f & m_wchSurrogateHigh);              // 6 bits in third
                Output(UTF8[0]);
                Output(UTF8[1]);
                fDone = Output(UTF8[2]);
            }
            m_wchSurrogateHigh = uc;
            m_fDoubleByte = FALSE ;
            goto CONVERT_DONE;
        }

        if (m_wchSurrogateHigh)
        {
            if (uc >= LOW_SURROGATE_START && uc <= LOW_SURROGATE_END)       // We find a surrogate pairs
            {

                DWORD dwSurrogateChar = ((m_wchSurrogateHigh-0xD800) << 10) + uc - 0xDC00 + 0x10000;
                UTF8[0] = 0xF0 | (unsigned char)( dwSurrogateChar >> 18 );                 // 3 bits in first byte
                UTF8[1] = 0x80 | (unsigned char)( ( dwSurrogateChar >> 12 ) & 0x3f );      // 6 bits in second
                UTF8[2] = 0x80 | (unsigned char)( ( dwSurrogateChar >> 6 ) & 0x3f );       // 6 bits in third
                UTF8[3] = 0x80 | (unsigned char)( 0x3f & dwSurrogateChar);                 // 6 bits in forth
                Output(UTF8[0]);
                Output(UTF8[1]);
                Output(UTF8[2]);
                fDone = Output(UTF8[3]);                
                m_fDoubleByte = FALSE ;
                m_wchSurrogateHigh = 0;
                goto CONVERT_DONE;
            }
            else                                                            // Not a surrogate pairs, error
            {
                UTF8[0] = 0xe0 | ( m_wchSurrogateHigh >> 12 );              // 4 bits in first byte
                UTF8[1] = 0x80 | ( ( m_wchSurrogateHigh >> 6 ) & 0x3f );    // 6 bits in second
                UTF8[2] = 0x80 | ( 0x3f & m_wchSurrogateHigh);              // 6 bits in third
                Output(UTF8[0]);
                Output(UTF8[1]);
                fDone = Output(UTF8[2]);
                m_wchSurrogateHigh = 0;
            }
        }


        if( ( uc & 0xff80 ) == 0 ) // ASCII
        {
            UTF8[0] = (UCHAR) uc;
            fDone = Output(UTF8[0]);
        }
        else if( ( uc & 0xf800 ) == 0 )             // UTF8_2_MAX 2-byte sequence if < 07ff (11 bits)
        {
            UTF8[0] = 0xC0 | (uc >> 6);             // 5 bits in first byte
            UTF8[1] = 0x80 | ( 0x3f & uc);       // 6 bits in second
            Output(UTF8[0]);
            fDone = Output(UTF8[1]);
        }
        else                                             // 3-byte sequence
        {
            UTF8[0] = 0xe0 | ( uc >> 12 );                // 4 bits in first byte
            UTF8[1] = 0x80 | ( ( uc >> 6 ) & 0x3f );      // 6 bits in second
            UTF8[2] = 0x80 | ( 0x3f & uc);                // 6 bits in third
            Output(UTF8[0]);
            Output(UTF8[1]);
            fDone = Output(UTF8[2]);
        }
        m_fDoubleByte = FALSE ;
    }
    else
    {
        m_tcLeadByte = tc ;
        m_fDoubleByte = TRUE ;
    }

CONVERT_DONE:
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF8Out::CleanUp()
{
    BOOL fDone = TRUE;

    return fDone;
}

int CInccUTF8Out::GetUnconvertBytes()
{
    return  m_fDoubleByte ? 1 : 0 ;
}

DWORD CInccUTF8Out::GetConvertMode()
{
    // UTF8 does not use mode esc sequence
    return 0 ;
}

void CInccUTF8Out::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    // UTF8 does not use mode esc sequence
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\utf8obj.h ===
#include "convbase.h"

#define HIGHT_SURROGATE_START   0xD800
#define HIGHT_SURROGATE_END     0xDBFF
#define LOW_SURROGATE_START     0xDC00
#define LOW_SURROGATE_END       0xDFFF

class CInccUTF8In : public CINetCodeConverter
{
private:
    BOOL (CInccUTF8In::*m_pfnConv)(UCHAR tc);
    BOOL (CInccUTF8In::*m_pfnCleanUp)();

    WORD    m_tcUnicode ;
    DWORD   m_tcSurrogateUnicode ;
    int     m_nByteFollow;
    int     m_nBytesUsed;
    BOOL    m_fSurrogatesPairs;
public:
    CInccUTF8In(UINT uCodePage, int nCodeSet);
    ~CInccUTF8In() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset(); 
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();

};

class CInccUTF8Out : public CINetCodeConverter
{
private:
    BOOL    m_fDoubleByte;
    BYTE    m_tcLeadByte;
    WCHAR   m_wchSurrogateHigh;

public:
    CInccUTF8Out(UINT uCodePage, int nCodeSet);
    ~CInccUTF8Out() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\sources.inc ===
CCSHELL_DIR         = $(PROJECT_ROOT)

TARGET_BOTH         = 1
NOT_UNICODE         = 1
PRECOMPILED_CXX     = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED        = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETTYPE          = DYNLINK
TARGETNAME          = mlang
TARGETPATH          = obj

UMTYPE              = windows

DLLENTRY            = _DllMainCRTStartup
DLLDEF              = ..\mlang.def

PRECOMPILED_INCLUDE = ..\private.h

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS          = $(SDK_LIB_PATH)\kernel32.lib      \
                      $(SDK_LIB_PATH)\user32.lib        \
                      $(SDK_LIB_PATH)\gdi32.lib         \
                      $(SDK_LIB_PATH)\advapi32.lib      \
                      $(SDK_LIB_PATH)\uuid.lib          \
                      $(SDK_LIB_PATH)\ole32.lib         \
                      $(SDK_LIB_PATH)\shlwapi.lib       \
                      $(SDK_LIB_PATH)\version.lib       \
                      $(CCSHELL_DIR)\lib\$O\stock4.lib  \
                      $(CCSHELL_DIR)\lib\$(O)\shfusion.lib 


USE_MSVCRT          = 1

INCLUDES            = $(INCLUDES); \
                      $(BASEDIR)\public\sdk\inc\atl21

# Multi Language part
SOURCES_ML          = ..\mlang.rc      \
                      ..\init.cpp      \
                      ..\mimedb.cpp    \
                      ..\mimereg.cpp   \
                      ..\rfc1766.cpp   \
                      ..\enumcp.cpp    \
                      ..\mlang.cpp     \
                      ..\dllload.cpp   \
                      ..\reg.cpp       \
                      ..\debug.c

# IMLConvertCharset part
SOURCES_CC          = ..\utf8obj.cpp   \
                      ..\utf7obj.cpp   \
                      ..\ichrcnv.cpp   \
                      ..\convbase.cpp  \
                      ..\convinet.cpp  \
                      ..\detcbase.cpp  \
                      ..\kscobj.cpp    \
                      ..\eucjobj.cpp   \
                      ..\hzgbobj.cpp   \
                      ..\jisobj.cpp    \
                      ..\convobj.cpp

# IMLangX part
SOURCES_MLX         = ..\mlflink.cpp   \
                      ..\mlstr.cpp     \
                      ..\mlstrw.cpp    \
                      ..\mlstra.cpp    \
                      ..\mlswalk.cpp   \
                      ..\mllbcons.cpp  \
                      ..\attrstr.cpp   \
                      ..\attrstrw.cpp  \
                      ..\attrstra.cpp  \
                      ..\attrloc.cpp   \
                      ..\util.cpp

# Multi Language detection
SOURCES_AUTO        = ..\fechauto.cpp   \
                      ..\fechmap.cpp    \
                      ..\jislex.cpp     \
                      ..\lcinit.cpp     \
                      ..\detcjpn.cpp    \
                      ..\detckrn.cpp    \
                      ..\cpdetect.cpp   \
                      ..\lcdetect.cpp   \
                      ..\validate.cpp   

SOURCES             = $(SOURCES_ML) $(SOURCES_CC) $(SOURCES_MLX) $(SOURCES_AUTO)


# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=123 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\utf7obj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from UTF-7
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "utf7obj.h"

//+-----------------------------------------------------------------------
//
//  Function:   IsBase64
//
//  Synopsis:   We use the following table to quickly determine if we have
//              a valid base64 character.
//
//------------------------------------------------------------------------

static UCHAR g_aBase64[256] =
{
  /*            0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   A,   B,   C,   D,   E,   F, */

  /* 00-0f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 10-1f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 20-2f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63,
  /* 30-3f */  52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255, 255, 255, 255, 255,
  /* 40-4f */ 255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
  /* 50-5f */  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
  /* 60-6f */ 255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  /* 70-7f */  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255,
  /* 80-8f */  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 90-9f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* a0-af */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* b0-bf */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* c0-cf */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* d0-df */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* e0-ef */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* f0-ff */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
};


// Direct encoded ASCII table
static UCHAR g_aDirectChar[128] =
{
  /*            0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   A,   B,   C,   D,   E,   F, */

  /* 00-0f */ 255, 255, 255, 255, 255, 255, 255, 255, 255,  72,  73, 255, 255,  74, 255, 255,
  /* 10-1f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 20-2f */  71, 255, 255, 255, 255, 255, 255,  62,  63,  64, 255, 255,  65,  66,  67,  68,
  /* 30-3f */  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  69, 255, 255, 255, 255,  70,
  /* 40-4f */ 255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
  /* 50-5f */  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
  /* 60-6f */ 255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  /* 70-7f */  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255,
};

// Base64 byte value table
static UCHAR g_aInvBase64[] = { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };

static inline BOOL
IsBase64(UCHAR t )
{
    return g_aBase64[t] < 64;
}

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF7In::CInccUTF7In(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF7In::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_fUTF7Mode = FALSE ;
    m_nBitCount = 0 ;
    m_tcUnicode = 0 ;
    m_nOutCount = 0 ;
    return ;
}


/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccUTF7In::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF7In::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccUTF7In::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    // are we in UTF-7 mode ?
    if (m_fUTF7Mode )
    {
        if ( IsBase64(tc) )
        {
            UCHAR t64, outc ;
            LONG tcUnicode ;

            // save the Base64 value and update bit count
            t64 = g_aBase64[tc] ;
            m_tcUnicode = m_tcUnicode << 6 | t64 ;
            m_nBitCount += 6 ;

            // see if we accumulate enough bits
            if ( m_nBitCount >= 16 )
            {
                // get higher 16 bits data from buffer
                tcUnicode = m_tcUnicode >> ( m_nBitCount - 16 ) ;
                // output one Unicode char
                outc = (UCHAR) tcUnicode ;
                Output( outc );
                outc = (UCHAR) ( tcUnicode >> 8 ) ;
                fDone = Output( outc );

                // update output char count
                m_nOutCount ++ ;
                m_nBitCount -= 16 ;
            }
        }
        // not a Base64 char, reset UTF-7 mode
        else
        {
            // special case +- decodes to +
            if ( tc == '-' && m_nOutCount == 0 && m_nBitCount == 0 )
            {
                Output('+');
                fDone=Output(0);
            }
            // absorb shiht-out char '-', otherwise output char
            else if ( tc != '-')
            {
                Output(tc);
                fDone=Output(0);
            }
            // reset variables and UTF7Mode
            m_fUTF7Mode = FALSE ;
            m_nBitCount = 0 ;
            m_tcUnicode = 0 ;
            m_nOutCount = 0 ;
        }
    }
    // is it a UTF-7 shift-in char ?
    else if ( tc == '+' )
    {
        m_fUTF7Mode = TRUE ;
        m_nBitCount = 0 ;
        m_tcUnicode = 0 ;
        m_nOutCount = 0 ;
    }
    else
    // convert ASCII directly to Unicode if it is not in UFT-7 mode
    {
        Output(tc);
        fDone = Output(0);
    }

    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccUTF7In::CleanUpMain()
{
    return TRUE;
}

int CInccUTF7In::GetUnconvertBytes()
{
    return  0 ;
}

DWORD CInccUTF7In::GetConvertMode()
{
    DWORD dwMode ;

    if ( m_fUTF7Mode )
    {
        dwMode = ( m_tcUnicode & 0xffff ) | ( m_nBitCount << 16 ) ;
        if ( dwMode == 0 )
            dwMode = 1L ; // it is ok, since bitcount is 0
    }
    else
        dwMode = 0 ;

    return dwMode;
}

void CInccUTF7In::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    if (mode)
    {
        m_fUTF7Mode = TRUE ;
        m_tcUnicode = ( mode & 0x7fff );
        m_nBitCount = ( mode >> 16 ) & 0xffff ;
    }
    else
        m_fUTF7Mode = FALSE ;
}

// ============================================================================
// Internet Character Set Conversion: Output to UTF-7
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF7Out::CInccUTF7Out(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)

{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF7Out::Reset()
{
    m_fDoubleByte = FALSE;
    m_fUTF7Mode = FALSE ;
    m_nBitCount = 0 ;
    m_tcUnicode = 0 ;
    return;
}

HRESULT CInccUTF7Out::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    WORD uc ;

    // 2nd byte of Unicode
    if (m_fDoubleByte )
    {
        BOOL bNeedShift ;

        // compose the 16 bits char
        uc = ( (WORD) tc << 8 | m_tcFirstByte  ) ;

        // check whether the char can be direct encoded ?
        bNeedShift = uc > 0x7f ? TRUE : g_aDirectChar[(UCHAR)uc] == 255 ;

        if ( bNeedShift && m_fUTF7Mode == FALSE)
        {
            // output Shift-in char to change to UTF-7 Mode
            fDone = Output('+');

            // handle special case '+-'
            if ( uc == '+' ) // single byte "+"
            {
                fDone=Output('-');
            }
            else
                m_fUTF7Mode = TRUE ;
        }

        if (m_fUTF7Mode)
        {
            LONG tcUnicode ;
            UCHAR t64 ;
            int pad_bits ;

            // either write the char to the bit buffer 
            // or pad bit buffer out to a full base64 char
            if (bNeedShift)
            {
                m_tcUnicode = m_tcUnicode << 16 | uc ;
                m_nBitCount += 16 ;
            }
            // pad bit buffer out to a full base64 char
            else if (m_nBitCount % 6 )  
            {
                pad_bits = 6 - (m_nBitCount % 6 ) ;
                // get to next 6 multiple, pad these bits with 0
                m_tcUnicode = m_tcUnicode << pad_bits ;
                m_nBitCount += pad_bits ;
            }

            // flush out as many full base64 char as possible
            while ( m_nBitCount >= 6 && fDone )
            {
                tcUnicode = ( m_tcUnicode >> ( m_nBitCount - 6 ) );
                t64 = (UCHAR) ( tcUnicode & 0x3f ) ;
                fDone = Output(g_aInvBase64[t64]);
                m_nBitCount -= 6 ;
            }

            if (!bNeedShift)
            {
                // output Shift-out char
                fDone = Output('-');

                m_fUTF7Mode = FALSE ;
                m_nBitCount = 0 ;
                m_tcUnicode = 0 ;
            }
        }

        // the character can be directly encoded as ASCII
        if (!bNeedShift)
        {
            fDone = Output(m_tcFirstByte);
        }

        m_fDoubleByte = FALSE ;
    }
    // 1st byte of Unicode
    else
    {
        m_tcFirstByte = tc ;
        m_fDoubleByte = TRUE ;
    }
    
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF7Out::CleanUp()
{
    BOOL fDone = TRUE;

    if (m_fUTF7Mode)
    {
        UCHAR t64 ;
        LONG tcUnicode ;
        int pad_bits ;

        // pad bit buffer out to a full base64 char
        if (m_nBitCount % 6 )  
        {
            pad_bits = 6 - (m_nBitCount % 6 ) ;
            // get to next 6 multiple, pad these bits with 0
            m_tcUnicode = m_tcUnicode << pad_bits ;
            m_nBitCount += pad_bits ;
        }

        // flush out as many full base64 char as possible
        while ( m_nBitCount >= 6 && fDone )
        {
            tcUnicode = ( m_tcUnicode >> ( m_nBitCount - 6 ) );
            t64 = (UCHAR) ( tcUnicode & 0x3f ) ;
            fDone = Output(g_aInvBase64[t64]);
            m_nBitCount -= 6 ;
        }

        {
            // output Shift-out char
            fDone = Output('-');

            m_fUTF7Mode = FALSE ;
            m_nBitCount = 0 ;
            m_tcUnicode = 0 ;
        }
    }
    return fDone;
}

int CInccUTF7Out::GetUnconvertBytes()
{
    return  m_fDoubleByte ? 1 : 0 ;
}

DWORD CInccUTF7Out::GetConvertMode()
{
    return 0 ;
}

void CInccUTF7Out::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\util.cpp ===
// Util.cpp : Helper functions and classes
#include "private.h"
#include "mlmain.h"
#include <setupapi.h>
#include <tchar.h>
#include <strsafe.h>

const CLSID CLSID_Japanese =  {0x76C19B30,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Korean   =  {0x76C19B31,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_PanEuro  =  {0x76C19B32,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_TradChinese = {0x76C19B33,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_SimpChinese = {0x76C19B34,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Thai        = {0x76C19B35,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Hebrew      = {0x76C19B36,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Vietnamese  = {0x76C19B37,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Arabic      = {0x76C19B38,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Auto        = {0x76C19B50,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};

TCHAR szFonts[]=TEXT("fonts");

static TCHAR s_szJaFont[] = TEXT("msgothic.ttf,msgothic.ttc");
// a-ehuang: mail-Hyo Kyoung Kim-Kevin Gjerstad-9/14/98
// OLD: static TCHAR s_szKorFont[] = TEXT("gulimche.ttf, gulim.ttf,gulim.ttc");
static TCHAR s_szKorFont[] = TEXT("gulim.ttf,gulim.ttc,gulimche.ttf");
// end-of-change
static TCHAR s_szZhtFont[] = TEXT("mingliu.ttf,mingliu.ttc");
static TCHAR s_szZhcFont[] = TEXT("mssong.ttf,simsun.ttc,mshei.ttf");
static TCHAR s_szThaiFont[] = TEXT("angsa.ttf,angsa.ttf,angsab.ttf,angsai.ttf,angsaz.ttf,upcil.ttf,upcib.ttf,upcibi.ttf, cordia.ttf, cordiab.ttf, cordiai.ttf, coradiaz.ttf");
static TCHAR s_szPeFont[] = TEXT("larial.ttf,larialbd.ttf,larialbi.ttf,lariali.ttf,lcour.ttf,lcourbd.ttf,lcourbi.ttf,lcouri.ttf,ltimes.ttf,ltimesbd.ttf,ltimesbi.ttf,ltimesi.ttf,symbol.ttf");
static TCHAR s_szArFont[] = TEXT("andlso.ttf, artrbdo.ttf, artro.ttf, simpbdo.ttf, simpfxo.ttf, tradbdo.ttf, trado.ttf");
static TCHAR s_szViFont[] = TEXT("VARIAL.TTF, VARIALBD.TTF, VARIALBI.TTF, VARIALI.TTF, VCOUR.TTF, VCOURBD.TTF, VCOURBI.TTF, VCOURI.TTF, VTIMES.TTF, VTIMESBD.TTF, VTIMESBI.TTF, VTIMESI.TTF");
static TCHAR s_szIwFont[] = TEXT("DAVID.TTF, DAVIDBD.TTF, DAVIDTR.TTF, MRIAM.TTF, MRIAMC.TTF, MRIAMFX.TTF, MRIAMTR.TTF, ROD.TTF");

#ifdef NEWMLSTR


#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen)
{
    ASSERT_WRITE_PTR(plPos);
    ASSERT_WRITE_PTR(plLen);

    long lPos = *plPos;
    long lLen = *plLen;

    if (lPos < 0)
        lPos = lStrLen;
    else
        lPos = min(lPos, lStrLen);

    if (lLen < 0)
        lLen = lStrLen - lPos;
    else
        lLen = min(lLen, lStrLen - lPos);

    *plPos = lPos;
    *plLen = lLen;

    return S_OK;
}

HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage)
{
    HRESULT hr = S_OK;

    if (puCodePage)
    {
        TCHAR szCodePage[8];

        if (::GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage)) > 0)
            *puCodePage = _ttoi(szCodePage);
        else
            hr = E_FAIL; // NLS failed
    }

    return hr;
}

HRESULT StartEndConnection(IUnknown* const pUnkCPC, const IID* const piid, IUnknown* const pUnkSink, DWORD* const pdwCookie, DWORD dwCookie)
{
    ASSERT_READ_PTR(pUnkCPC);
    ASSERT_READ_PTR(piid);
    if (pdwCookie)
        ASSERT_WRITE_PTR(pUnkSink);
    ASSERT_READ_PTR_OR_NULL(pdwCookie);

    HRESULT hr;
    IConnectionPointContainer* pcpc;

    if (SUCCEEDED(hr = pUnkCPC->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc)))
    {
        ASSERT_READ_PTR(pcpc);

        IConnectionPoint* pcp;

        if (SUCCEEDED(hr = pcpc->FindConnectionPoint(*piid, &pcp)))
        {
            ASSERT_READ_PTR(pcp);

            if (pdwCookie)
                hr = pcp->Advise(pUnkSink, pdwCookie);
            else
                hr = pcp->Unadvise(dwCookie);

            pcp->Release();
        }

        pcpc->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLAlloc

CMLAlloc::CMLAlloc(void)
{
    if (FAILED(::CoGetMalloc(1, &m_pIMalloc)))
        m_pIMalloc = NULL;
}

CMLAlloc::~CMLAlloc(void)
{
    if (m_pIMalloc)
        m_pIMalloc->Release();
}

void* CMLAlloc::Alloc(ULONG cb)
{
    if (m_pIMalloc)
        return m_pIMalloc->Alloc(cb);
    else
        return ::malloc(cb);
}

void* CMLAlloc::Realloc(void* pv, ULONG cb)
{
    if (m_pIMalloc)
        return m_pIMalloc->Realloc(pv, cb);
    else
        return ::realloc(pv, cb);
}

void CMLAlloc::Free(void* pv)
{
    if (m_pIMalloc)
        m_pIMalloc->Free(pv);
    else
        ::free(pv);
}

/////////////////////////////////////////////////////////////////////////////
// CMLList

HRESULT CMLList::Add(void** ppv)
{
    if (!m_pFree) // No free cell
    {
        // Determine new size of the buffer
        const int cNewCell = (m_cbCell * m_cCell + m_cbIncrement + m_cbCell - 1) / m_cbCell;
        ASSERT(cNewCell > m_cCell);
        const long lNewSize = cNewCell * m_cbCell;

        // Allocate the buffer
        void *pNewBuf;
        if (!m_pBuf)
        {
            pNewBuf = MemAlloc(lNewSize);
        }
        else
        {
            pNewBuf = MemRealloc((void*)m_pBuf, lNewSize);
            ASSERT(m_pBuf == pNewBuf);
        }
        ASSERT_WRITE_BLOCK_OR_NULL((BYTE*)pNewBuf, lNewSize);

        if (pNewBuf)
        {
            // Add new cells to free link
            m_pFree = m_pBuf[m_cCell].m_pNext;
            for (int iCell = m_cCell; iCell + 1 < cNewCell; iCell++)
                m_pBuf[iCell].m_pNext = &m_pBuf[iCell + 1];
            m_pBuf[iCell].m_pNext = NULL;

            m_pBuf = (CCell*)pNewBuf;
            m_cCell = cNewCell;
        }
    }

    if (m_pFree)
    {
        // Get a new element from free link
        CCell* const pNewCell = m_pFree;
        m_pFree = pNewCell->m_pNext;
        *ppv = pNewCell;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }
}

HRESULT CMLList::Remove(void* pv)
{
    AssertPV(pv);
#ifdef DEBUG
    for (CCell* pWalk = m_pFree; pWalk && pWalk != pv; pWalk = pWalk->m_pNext)
        ;
    ASSERT(!pWalk); // pv is already in free link
#endif

    CCell* const pCell = (CCell* const)pv;
    pCell->m_pNext = m_pFree;
    m_pFree = pCell;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLListLru

HRESULT CMLListLru::Add(void** ppv)
{
    HRESULT hr;
    CCell* pCell;
    
    if (SUCCEEDED(hr = CMLList::Add((void**)&pCell)))
    {
        // Add the cell at the bottom of LRU link
        for (CCell** ppCell = &m_pTop; *ppCell; ppCell = &(*ppCell)->m_pNext)
            ;
        *ppCell = pCell;
        pCell->m_pNext = NULL;
    }

    *ppv = (void*)pCell;
    return hr;
}

HRESULT CMLListLru::Remove(void* pv)
{
    AssertPV(pv);

    // Look for previous cell of given
    for (CCell** ppWalk = &m_pTop; *ppWalk != pv && *ppWalk; ppWalk = &(*ppWalk)->m_pNext)
        ;
    ASSERT(!*ppWalk); // Not found in LRU link

    if (*ppWalk)
    {
        // Remove from LRU link
        CCell* const pCell = *ppWalk;
        *ppWalk = pCell->m_pNext;
    }

    // Add to free link
    return CMLList::Remove(pv);
}

/////////////////////////////////////////////////////////////////////////////
// CMLListFast

HRESULT CMLListFast::Add(void** ppv)
{
    HRESULT hr;
    CCell* pCell;
    
    if (SUCCEEDED(hr = CMLList::Add((void**)&pCell)))
    {
        // Add to top of double link
        pCell->m_pNext = m_pTop;
        CCell* const pPrev = m_pTop->m_pPrev;
        pCell->m_pPrev = pPrev;
        m_pTop = pCell;
        pPrev->m_pNext = pCell;
    }

    *ppv = (void*)pCell;
    return hr;
}

HRESULT CMLListFast::Remove(void* pv)
{
    AssertPV(pv);

    // Remove from double link
    CCell* const pCell = (CCell*)pv;
    CCell* const pPrev = pCell->m_pPrev;
    CCell* const pNext = (CCell*)pCell->m_pNext;
    pPrev->m_pNext = pNext;
    pNext->m_pPrev = pPrev;

    // Add to free link
    return CMLList::Remove(pv);
}

#endif // NEWMLSTR

HRESULT 
_FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    typedef HRESULT (WINAPI *PFNJIT)(
        HWND hwnd, 
        uCLSSPEC *pclsspec, 
        QUERYCONTEXT *pQ, 
        DWORD dwFlags);
    static PFNJIT  pfnJIT = NULL;

    if (!pfnJIT && !g_hUrlMon)
    {
        g_hUrlMon = LoadLibrary(TEXT("urlmon.DLL"));
        if (g_hUrlMon)
            pfnJIT = (PFNJIT)GetProcAddress(g_hUrlMon, "FaultInIEFeature");
    }
    
    if (pfnJIT)
       hr = pfnJIT(hwnd, pclsspec, pQ, dwFlags);
       
    return hr;
}


HRESULT InstallIEFeature(HWND hWnd, CLSID *clsid, DWORD dwfIODControl)
{
   
    HRESULT     hr  = REGDB_E_CLASSNOTREG;
    uCLSSPEC    classpec;
    DWORD       dwfIEF = 0;
    
    classpec.tyspec=TYSPEC_CLSID;
    classpec.tagged_union.clsid=*clsid;

    if (dwfIODControl & CPIOD_PEEK)
        dwfIEF |= FIEF_FLAG_PEEK;

    if (dwfIODControl & CPIOD_FORCE_PROMPT)
        dwfIEF |= FIEF_FLAG_FORCE_JITUI;

    hr = _FaultInIEFeature(hWnd, &classpec, NULL, dwfIEF);

    if (hr != S_OK) {
        hr = REGDB_E_CLASSNOTREG;
    }
    return hr;
}

HRESULT _GetJITClsIDForCodePage(UINT uiCP, CLSID *clsid)
{
    switch(uiCP)
    {
        case 932: // JA
            *clsid = CLSID_Japanese;
            break;
        case 949: // KOR
            *clsid = CLSID_Korean;
            break;
        case 950: // ZHT
            *clsid = CLSID_TradChinese;
            break;
        case 936: // ZHC
            *clsid = CLSID_SimpChinese;
            break;
        case 874:
            *clsid = CLSID_Thai;
            break;
        case 1255:
            *clsid = CLSID_Hebrew;
            break;
        case 1256:
            *clsid = CLSID_Arabic;
            break;
        case 1258:
            *clsid = CLSID_Vietnamese;
            break;            
        case 1250:    // PANEURO
        case 1251: 
        case 1253:
        case 1254:
        case 1257:
            *clsid = CLSID_PanEuro;
            break;
        case 50001:
            *clsid = CLSID_Auto;
            break;
        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
}

// Only good for family code pages.
HRESULT _ValidateCPInfo(UINT uiCP)
{
    HRESULT hr = E_FAIL;
    if (g_pMimeDatabase) // just a paranoid
    {
        switch(uiCP)
        {
            case 932: // JA
            case 949: // KOR
            case 874: // Thai
            case 950: // ZHT
            case 936: // ZHC
            case 1255: // Hebrew
            case 1256: // Arabic
            case 1258: // Vietnamese
            case 50001: // CP_AUTO
                // just validate what's given
                hr = g_pMimeDatabase->ValidateCP(uiCP);
                break;
            case 1250:    // PANEURO
            case 1251:
            case 1253:
            case 1254:
            case 1257:
                // have to validate
                // all of these
                hr = g_pMimeDatabase->ValidateCP(1250);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1251);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1253);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1254);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1257);
                break;
            default:
                return E_INVALIDARG;
        }
    }
    return hr;
}

// assumes the corresponding fontfile name for now
HRESULT _AddFontForCP(UINT uiCP)
{
   TCHAR szFontsPath[MAX_PATH];
   LPTSTR szFontFile;
   HRESULT hr = S_OK;
   BOOL bAtLeastOneFontAdded = FALSE;
   
   switch(uiCP)
   {
        case 932: // JA
            szFontFile = s_szJaFont;
            break;
        case 949: // KOR
            szFontFile = s_szKorFont;
            break;
        case 950: // ZHT
            szFontFile = s_szZhtFont;
            break;
        case 936: // ZHC
            szFontFile = s_szZhcFont;
            break;
        case 874:
            szFontFile = s_szThaiFont;
            break; 
        case 1255:
            szFontFile = s_szIwFont;
            break; 
        case 1256:
            szFontFile = s_szArFont;
            break; 
        case 1258:
            szFontFile = s_szViFont;
            break; 
        case 1251:    // PANEURO
        case 1253:
        case 1254:
        case 1257:
            szFontFile = s_szPeFont;
            break;
        default:
            hr = E_INVALIDARG;
    } 
   
   // addfontresource, then broadcast WM_FONTCHANGE
   if (SUCCEEDED(hr))
   {      
       if (MLGetWindowsDirectory(szFontsPath, ARRAYSIZE(szFontsPath)))
       {
           TCHAR  szFontFilePath[MAX_PATH];
           LPTSTR psz, pszT;

           MLPathCombine(szFontsPath, ARRAYSIZE(szFontsPath), szFontsPath, szFonts);

           for (psz = szFontFile; *psz; psz = pszT + 1)
           {
               pszT = MLStrChr(psz, TEXT(','));
               if (pszT)
               {
                   *pszT=TEXT('\0');
               }

               MLPathCombine(szFontFilePath, ARRAYSIZE(szFontFilePath), szFontsPath, psz);
               if (AddFontResource(szFontFilePath))
               {
                   bAtLeastOneFontAdded = TRUE;
               }

               if (!pszT)
                  break;
           }
           if (!bAtLeastOneFontAdded)
               hr = E_FAIL;
       }
       else
           hr = E_FAIL;
   }

   // Clients will take care of WM_FONTCHANGE notification
   return hr;
}

int _LoadStringExA(
    HMODULE    hModule,
    UINT      wID,
    LPSTR     lpBuffer,            
    int       cchBufferMax,        
    WORD      wLangId)
{
    int iRet = 0;

    LPWSTR lpwStr = (LPWSTR) LocalAlloc(LPTR, cchBufferMax*sizeof(WCHAR));

    if (lpwStr)
    {
        iRet = _LoadStringExW(hModule, wID, lpwStr, cchBufferMax, wLangId);

        if (iRet)
            iRet = WideCharToMultiByte(CP_ACP, 0, lpwStr, iRet, lpBuffer, cchBufferMax, NULL, NULL);

        if(iRet >= cchBufferMax)
            iRet = cchBufferMax-1;

        lpBuffer[iRet] = 0;

        LocalFree(lpwStr);
    }

    return iRet;
}

// Extend LoadString() to to _LoadStringExW() to take LangId parameter
int _LoadStringExW(
    HMODULE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return 0;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hModule, (LPCWSTR)RT_STRING,
                                   (LPWSTR)IntToPtr(((USHORT)wID >> 4) + 1), wLangId)) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hModule, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            wID &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
                            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax-1;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

        }
    }

    return cch;
}


typedef struct tagCPLGID
{
    UINT    uiCodepage;
    TCHAR   szLgId[3];
    TCHAR   szLgIdHex[3]; // Darn it! NT should be persistent on presenting language group numbers
                          // It uses decimal string in INF and hex string in registry. 
                          // We have to add this field to save conversion, this is fine for a small array of data.  
} CPLGID;

const CPLGID CpLgId[] =
{
    {1252,  TEXT("1"),  TEXT("1")},  // WESTERN EUROPE
    {1250,  TEXT("2"),  TEXT("2")},  // CENTRAL EUROPE
    {1257,  TEXT("3"),  TEXT("3")},  // BALTIC
    {1253,  TEXT("4"),  TEXT("4")},  // GREEK
    {1251,  TEXT("5"),  TEXT("5")},  // CYRILLIC
    {1254,  TEXT("6"),  TEXT("6")},  // TURKISH
    {932,   TEXT("7"),  TEXT("7")},  // JAPANESE
    {949,   TEXT("8"),  TEXT("8")},  // KOREAN
    {950,   TEXT("9"),  TEXT("9")},  // TRADITIONAL CHINESE
    {936,  TEXT("10"),  TEXT("a")},  // SIMPLIFIED CHINESE
    {874,  TEXT("11"),  TEXT("b")},  // THAI
    {1255, TEXT("12"),  TEXT("c")},  // HEBREW
    {1256, TEXT("13"),  TEXT("d")},  // ARABIC
    {1258, TEXT("14"),  TEXT("e")},  // VIETNAMESE
    // ISCII encodings don't really have code pages or family code page
    // Code pages number are made up in W2K for conveniences, 
    // So, we have to list them all to install the same Indian language group
    {57002,TEXT("15"),  TEXT("f")},  // INDIAN 
    {57003,TEXT("15"),  TEXT("f")},  // INDIAN
    {57004,TEXT("15"),  TEXT("f")},  // INDIAN
    {57005,TEXT("15"),  TEXT("f")},  // INDIAN
    {57006,TEXT("15"),  TEXT("f")},  // INDIAN
    {57007,TEXT("15"),  TEXT("f")},  // INDIAN
    {57008,TEXT("15"),  TEXT("f")},  // INDIAN
    {57009,TEXT("15"),  TEXT("f")},  // INDIAN
    {57010,TEXT("15"),  TEXT("f")},  // INDIAN
    {57011,TEXT("15"),  TEXT("f")},  // INDIAN
};

typedef BOOL (WINAPI *PFNISNTADMIN) ( DWORD dwReserved, DWORD *lpdwReserved );

typedef INT (WINAPI *PFNSETUPPROMPTREBOOT) (
        HSPFILEQ FileQueue,  // optional, handle to a file queue
        HWND Owner,          // parent window of this dialog box
        BOOL ScanOnly        // optional, do not prompt user
        );

typedef PSP_FILE_CALLBACK PFNSETUPDEFAULTQUEUECALLBACK;

typedef VOID (WINAPI *PFNSETUPCLOSEINFFILE) (
    HINF InfHandle
    );

typedef BOOL (WINAPI *PFNSETUPINSTALLFROMINFSECTION) (
    HWND                Owner,
    HINF                InfHandle,
    LPCTSTR             SectionName,
    UINT                Flags,
    HKEY                RelativeKeyRoot,   OPTIONAL
    LPCTSTR             SourceRootPath,    OPTIONAL
    UINT                CopyFlags,
    PSP_FILE_CALLBACK   MsgHandler,
    PVOID               Context,
    HDEVINFO            DeviceInfoSet,     OPTIONAL
    PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

typedef HINF (WINAPI *PFNSETUPOPENINFFILE) (
    LPCTSTR FileName,
    LPCTSTR InfClass,    OPTIONAL
    DWORD   InfStyle,
    PUINT   ErrorLine    OPTIONAL
    );

typedef PVOID (WINAPI *PFNSETUPINITDEFAULTQUEUECALLBACK) (
    IN HWND OwnerWindow
    );

typedef BOOL (WINAPI *PFNSETUPOPENAPPENDINFFILE) (
  PCTSTR FileName, // optional, name of the file to append
  HINF InfHandle,  // handle of the file to append to
  PUINT ErrorLine  // optional, receives error information
);
 


HRESULT IsNTLangpackAvailable(UINT uiCP)
{
    HRESULT hr = S_FALSE;

    // check if there is a valid W2K language group
    for (int i=0; i < ARRAYSIZE(CpLgId); i++)
    {
        if (uiCP == CpLgId[i].uiCodepage)
        {
            hr = S_OK;
            break;
        }
    }

    // check if it is already installed, if so, we don't install it again
    if (S_OK == hr)
    {
        HKEY hkey;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         REGSTR_PATH_NT5LPK_INSTALL,
                         0, KEY_READ, &hkey)) 
        {
            DWORD dwType = REG_SZ;
            TCHAR szLpkInstall[16] = {0};
            DWORD dwSize = sizeof(szLpkInstall);

            if (ERROR_SUCCESS == RegQueryValueEx(hkey, CpLgId[i].szLgIdHex, 0, 
                                                 &dwType, (LPBYTE)&szLpkInstall, &dwSize))
            {
                if (!lstrcmp(szLpkInstall, TEXT("1")))
                    hr = S_FALSE;
            }
            RegCloseKey(hkey);
        }
    }

    return hr;
}

HRESULT _InstallNT5Langpack(HWND hwnd, UINT uiCP)
{
    HRESULT             hr = E_FAIL;
    HINF                hIntlInf = NULL;
    TCHAR               szIntlInf[MAX_PATH];
    TCHAR               szIntlInfSection[MAX_PATH];
    PVOID               QueueContext = NULL;   

    HINSTANCE           hDllAdvPack = NULL;
    HINSTANCE           hDllSetupApi = NULL;

    PFNSETUPINSTALLFROMINFSECTION       lpfnSetupInstallFromInfSection = NULL;
    PFNSETUPCLOSEINFFILE                lpfnSetupCloseInfFile = NULL;
    PFNSETUPDEFAULTQUEUECALLBACK        lpfnSetupDefaultQueueCallback = NULL;
    PFNSETUPOPENINFFILE                 lpfnSetupOpenInfFile = NULL;
    PFNISNTADMIN                        lpfnIsNTAdmin = NULL;
    PFNSETUPINITDEFAULTQUEUECALLBACK    lpfnSetupInitDefaultQueueCallback = NULL;
    PFNSETUPOPENAPPENDINFFILE           lpfnSetupOpenAppendInfFile = NULL;

    for (int i=0; i < ARRAYSIZE(CpLgId); i++)
    {
        if (uiCP == CpLgId[i].uiCodepage)
        {
            //*STRSAFE*             _tcscpy(szIntlInfSection, TEXT("LG_INSTALL_"));
            hr = StringCchCopy(szIntlInfSection , ARRAYSIZE(szIntlInfSection),  TEXT("LG_INSTALL_"));
            if (!SUCCEEDED(hr))
            {
               goto LANGPACK_EXIT;
            }
            //*STRSAFE*             _tcscat(szIntlInfSection, CpLgId[i].szLgId);
            hr = StringCchCat(szIntlInfSection , ARRAYSIZE(szIntlInfSection),  CpLgId[i].szLgId);
            if (!SUCCEEDED(hr))
            {
               goto LANGPACK_EXIT;
            }
            break;
        }
    }

    if (i >= ARRAYSIZE(CpLgId))
    {
        goto LANGPACK_EXIT;
    }

    hDllAdvPack = LoadLibrary(TEXT("advpack.dll"));
    hDllSetupApi = LoadLibrary(TEXT("setupapi.dll"));

    if (!hDllAdvPack || !hDllSetupApi)
    {
        goto LANGPACK_EXIT;
    }

    lpfnIsNTAdmin = (PFNISNTADMIN) GetProcAddress( hDllAdvPack, "IsNTAdmin");
    lpfnSetupCloseInfFile = (PFNSETUPCLOSEINFFILE) GetProcAddress( hDllSetupApi, "SetupCloseInfFile");
    lpfnSetupInitDefaultQueueCallback = (PFNSETUPINITDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupInitDefaultQueueCallback");
#ifdef UNICODE
    lpfnSetupOpenInfFile = (PFNSETUPOPENINFFILE) GetProcAddress( hDllSetupApi, "SetupOpenInfFileW"));
    lpfnSetupInstallFromInfSection = (PFNSETUPINSTALLFROMINFSECTION) GetProcAddress( hDllSetupApi, "SetupInstallFromInfSectionW");
    lpfnSetupDefaultQueueCallback = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupDefaultQueueCallbackW");
    lpfnSetupOpenAppendInfFile = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupOpenAppendInfFileW");
#else
    lpfnSetupOpenInfFile = (PFNSETUPOPENINFFILE) GetProcAddress( hDllSetupApi, "SetupOpenInfFileA");
    lpfnSetupInstallFromInfSection = (PFNSETUPINSTALLFROMINFSECTION) GetProcAddress( hDllSetupApi, "SetupInstallFromInfSectionA");
    lpfnSetupDefaultQueueCallback = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupDefaultQueueCallbackA");
    lpfnSetupOpenAppendInfFile = (PFNSETUPOPENAPPENDINFFILE) GetProcAddress(hDllSetupApi, "SetupOpenAppendInfFileA");
#endif

    if (!lpfnIsNTAdmin || !lpfnSetupOpenInfFile || !lpfnSetupCloseInfFile || !lpfnSetupDefaultQueueCallback 
        || !lpfnSetupInstallFromInfSection || !lpfnSetupInitDefaultQueueCallback || !lpfnSetupOpenAppendInfFile)
    {
        goto LANGPACK_EXIT;
    }

    if (!lpfnIsNTAdmin(0, NULL))
    {
        WCHAR wszLangInstall[MAX_PATH];
        WCHAR wszNoAdmin[1024];
        LANGID LangId = GetNT5UILanguage();

        // Fall back to English (US) if we don't have a specific language resource
        if (!_LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId) ||
            !_LoadStringExW(g_hInst, IDS_NO_ADMIN, wszNoAdmin, ARRAYSIZE(wszNoAdmin), LangId))
        {
            LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            _LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId);
            _LoadStringExW(g_hInst, IDS_NO_ADMIN, wszNoAdmin, ARRAYSIZE(wszNoAdmin), LangId);
        }
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        MessageBoxW(hwnd, wszNoAdmin, wszLangInstall, MB_OK);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        goto LANGPACK_EXIT;
    }

    QueueContext = lpfnSetupInitDefaultQueueCallback(hwnd);

    MLGetWindowsDirectory(szIntlInf, MAX_PATH);
    MLPathCombine(szIntlInf, ARRAYSIZE(szIntlInf), szIntlInf, TEXT("inf\\intl.inf"));

    hIntlInf = lpfnSetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);

    if (!lpfnSetupOpenAppendInfFile(NULL, hIntlInf, NULL))
    {
        lpfnSetupCloseInfFile(hIntlInf);
        goto LANGPACK_EXIT;
    }

    if (INVALID_HANDLE_VALUE != hIntlInf)
    {
        if (lpfnSetupInstallFromInfSection( hwnd,
                                    hIntlInf,
                                    szIntlInfSection,
                                    SPINST_FILES,
                                    NULL,
                                    NULL,
                                    SP_COPY_NEWER,
                                    lpfnSetupDefaultQueueCallback,
                                    QueueContext,
                                    NULL,
                                    NULL ))
        {
            if (lpfnSetupInstallFromInfSection( hwnd,
                                    hIntlInf,
                                    szIntlInfSection,
                                    SPINST_ALL & ~SPINST_FILES,
                                    NULL,
                                    NULL,
                                    0,
                                    lpfnSetupDefaultQueueCallback,
                                    QueueContext,
                                    NULL,
                                    NULL ))
            {
                hr = S_OK;
            }
        }
    
        lpfnSetupCloseInfFile(hIntlInf);
    }

LANGPACK_EXIT:

    if(hDllSetupApi)
        FreeLibrary(hDllSetupApi);
    if(hDllAdvPack)
        FreeLibrary(hDllAdvPack);
    
    //
    // Bug #289905, On Whistler, language pack will be installed with a groups of languages,
    // So, MLang need to validate codepage and fonts for all languages in the same group
    // After intl.cpl is modified for font validation, we'll remove this hardcoded language group.
    //
    if (hr == S_OK)
    {
        // This has to match Whistler language group
        UINT uiDBCSCps[] = {932, 936, 949, 950, 0};
        UINT uiCompCps[] = {874, 1255, 1256, 1258, 0};
        UINT uiOtherCps[] = {uiCP, 0};
            
        UINT *pCps = uiOtherCps;
        
        if (MLIsOS(OS_WHISTLERORGREATER))
        {
            if (IS_DBCSCODEPAGE(uiCP))
                pCps = uiDBCSCps;
            else if (IS_COMPLEXSCRIPT_CODEPAGE(uiCP))
                pCps = uiCompCps;
        }               
            
        while (*pCps)
        {
            hr = _ValidateCPInfo(*pCps);
            if (SUCCEEDED(hr))
            {                
                _AddFontForCP(*pCps);
            }
            pCps++;
        }
    }    

    return hr;
}

BOOL _IsValidCodePage(UINT uiCodePage)
{
    BOOL bRet;

    if (50001 == uiCodePage)
    {
        HANDLE hFile = NULL;
        CHAR szFileName[MAX_PATH];
        LPSTR psz;
        HRESULT hr = E_FAIL;
        
        if (GetModuleFileNameA(g_hInst, szFileName, ARRAYSIZE(szFileName)) == 0)
            return GetLastError();
        
        if ( (psz = strrchr (szFileName, '\\')) != NULL ||
            (psz = strrchr (szFileName, ':')) != NULL )
        {
            *++psz = 0;
        }
        else
            *szFileName = 0;
        
        //*STRSAFE*         strcat (szFileName, DETECTION_DATA_FILENAME);        
        hr = StringCchCatA(szFileName , ARRAYSIZE(szFileName),  DETECTION_DATA_FILENAME);
        if (!SUCCEEDED(hr))
        {
           return FALSE;
        }

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
        {
            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;
            CloseHandle(hFile);
        }
    }
    else
    {
        bRet = IsValidCodePage(uiCodePage);
    }
    return bRet;
}

//
// Security!!!Buffer overrun, should use strsafe API
//
//_tcsncat, strncat, _mbsnbcat, wcsncat
//_tcsncpy, strncpy, _mbsnbcpy, wcsncpy  
//_fcvt


WCHAR *MLStrCpyNW(WCHAR *strDest, const WCHAR *strSource, int nCount)
{  
    StringCchCopyW(strDest, nCount, strSource);
    return strDest;
}

LPTSTR MLStrChr( const TCHAR *string, int c )
{
    return _tcschr(string, c);
}

LPTSTR MLStrCpyN(LPTSTR strDest, const LPTSTR strSource, UINT nCount)
{
    StringCchCopyA(strDest, nCount, strSource);
    return strDest;
}

LPTSTR MLStrStr(const LPTSTR Str, const LPTSTR subStr)
{
    return _tcsstr(Str, subStr);
}

LPTSTR MLPathCombine(LPTSTR szPath, INT nSize, LPTSTR szPath1, LPTSTR szPath2)
{
    int len;
    HRESULT hr = E_FAIL;

    if (!szPath) 
        return NULL;

    if (szPath != szPath1)
    {
        //*STRSAFE*         _tcscpy(szPath, szPath1);
        hr = StringCchCopy(szPath , nSize,  szPath1);
        if (!SUCCEEDED(hr))
        {
           return NULL;
        }
    }

    len = _tcslen(szPath1);

    if (szPath[len-1] != TEXT('\\'))
    {
        szPath[len++] = TEXT('\\');
        szPath[len] = 0;
    }

    //*STRSAFE*     return _tcscat(szPath, szPath2);
    hr = StringCchCat(szPath , nSize,  szPath2);
    if (!SUCCEEDED(hr))
    {
       return NULL;
    }
    else
    {
        return szPath;
    }
}

DWORD HexToNum(LPTSTR lpsz)
{
    DWORD   dw = 0L;
    TCHAR   c;

    if (lpsz) {
        while(*lpsz)
        {
            c = *lpsz++;

            if (c >= TEXT('A') && c <= TEXT('F'))
            {
                c -= TEXT('A') - 0xa;
            }
            else if (c >= TEXT('0') && c <= TEXT('9'))
            {
                c -= TEXT('0');
            }
            else if (c >= TEXT('a') && c <= TEXT('f'))
            {
                c -= TEXT('a') - 0xa;
            }
            else
            {
                break;
            }
            dw *= 0x10;
            dw += c;
        }
    }
    return(dw);
}


// Following code is borrowed from shlwapi
BOOL AnsiFromUnicode(
     LPSTR * ppszAnsi,
     LPCWSTR pwszWide,        // NULL to clean up
     LPSTR pszBuf,
     int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
    {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
        }
        else
        {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
        }

        if (psz)
        {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppszAnsi = psz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}

int MLStrCmpI(IN LPCTSTR pwsz1, IN LPCTSTR pwsz2)
{
#ifdef UNICODE
    return MLStrCmpIW(pwsz1, pwsz2);
#else
    return lstrcmpiA(pwsz1, pwsz2);
#endif
}

int MLStrCmpNI(IN LPCTSTR pstr1, IN LPCTSTR pstr2, IN int count)
{
#ifdef UNICODE
    return MLStrCmpNIW(pstr1, pstr2, count);
#else
    return MLStrCmpNIA(pstr1, pstr2, count);
#endif
}

int MLStrCmpIW(
    IN LPCWSTR pwsz1,
    IN LPCWSTR pwsz2)
{
    int iRet;
    
    ASSERT(IS_VALID_STRING_PTRW(pwsz1, -1));
    ASSERT(IS_VALID_STRING_PTRW(pwsz2, -1));
    
    if (g_bIsNT)
    {        
        iRet = CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, pwsz1, -1, pwsz2, -1) - CSTR_EQUAL;
    }
    else
    {
        CHAR sz1[512];
        CHAR sz2[512];
        LPSTR psz1;
        LPSTR psz2;

        iRet = -1;      // arbitrary on failure

        if (pwsz1 && pwsz2)
        {
            if (AnsiFromUnicode(&psz1, pwsz1, sz1, SIZECHARS(sz1)))
            {
                if (AnsiFromUnicode(&psz2, pwsz2, sz2, SIZECHARS(sz2)))
                {
                    iRet = CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, psz1, -1, psz2, -1) - CSTR_EQUAL;
                    AnsiFromUnicode(&psz2, NULL, sz2, 0);       // Free
                }
                AnsiFromUnicode(&psz1, NULL, sz1, 0);       // Free
            }
        }
    }

    return iRet;
}

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

int WINAPI MLStrToIntA(
    LPCSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (lpSrc) {
        if (*lpSrc == '-') {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITA(*lpSrc)) {
            n *= 10;
            n += *lpSrc - '0';
            lpSrc++;
        }
    }
    return bNeg ? -n : n;
}


int WINAPI MLStrToIntW(
    LPCWSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (lpSrc) {

        if (*lpSrc == L'-') {
            bNeg = TRUE;
            lpSrc++;
        }

        while (IS_DIGITW(*lpSrc)) {
            n *= 10;
            n += *lpSrc - L'0';
            lpSrc++;
        }
    }
    return bNeg ? -n : n;
}

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

#if defined(MWBIG_ENDIAN)
    sz2[0] = LOBYTE(wMatch);
    sz2[1] = HIBYTE(wMatch);
#else
    *(WORD *)sz2 = wMatch;
#endif
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return lstrcmpiW(sz1, sz2);
}


/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int MLStrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? READNATIVEWORD(lpStr1) : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? (UINT)READNATIVEWORD(lpStr2) : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}

int MLStrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpIW(*lpStr1, *lpStr2);
        if (i) {
            return i;
        }
    }
    return 0;
}


HRESULT _IsCodePageInstallable(UINT uiCodePage)
{
    MIMECPINFO cpInfo;
    UINT       uiFamCp;
    HRESULT    hr;

    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    uiFamCp = cpInfo.uiFamilyCodePage;
    if (g_bIsNT5)
    {
        hr = IsNTLangpackAvailable(uiFamCp);
    }
    else
    {
        CLSID      clsid;
        // clsid is just used for place holder
        hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
    }
    return hr;
}

//
// CML2 specific utilities
//

//
// CMultiLanguage2::EnsureIEStatus()
//
// ensures CML2::m_pIEStat
//
HRESULT CMultiLanguage2::EnsureIEStatus(void)
{
    HRESULT hr = S_OK;
    // initialize IE status cache
    if (!m_pIEStat)
    {
        m_pIEStat = new CIEStatus();

        if (m_pIEStat)
        {
            hr = m_pIEStat->Init();
        }
    }

    return hr;
}

//
// CIEStatus::Init()
//
// initializes the IE status;
//
HRESULT CMultiLanguage2::CIEStatus::Init(void)
{
    HRESULT hr = S_OK;
    HKEY hkey;
    // Get JIT satus
    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                      REGSTR_PATH_MAIN,
                     0, KEY_READ, &hkey) == ERROR_SUCCESS) 
    {
        DWORD dwVal, dwType;
        DWORD dwSize = sizeof(dwVal);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("nojitsetup"), 0, &dwType, (LPBYTE)&dwVal, &dwSize))
        {
            if (dwType == REG_DWORD && dwSize == sizeof(dwVal))
            {
                if (dwVal > 0 ) 
                    _IEFlags.fJITDisabled = TRUE;
                else
                    _IEFlags.fJITDisabled = FALSE;
            }
        }
        RegCloseKey(hkey);
    }
    else
        hr = E_FAIL;
    // any other status to get initialized
    // ...
    
    return hr;
}

#define NT5LPK_DLG_STRING "MLang.NT5LpkDlg"

//
// LangpackDlgProc()
//
// Message handler for the NT5 langpack dialog.
//
INT_PTR CALLBACK LangpackDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    ASSERT(g_bIsNT5);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            HWND hwndCheckBox;            
            RECT rc1, rc2;
            MIMECPINFO cpInfo;

            SetProp(hDlg, NT5LPK_DLG_STRING, (HANDLE)lParam);
    
            if ((NULL != g_pMimeDatabase) &&
                SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(HIWORD(lParam), GetNT5UILanguage(), &cpInfo)))
            {
                for (int i=0; i<MAX_MIMECP_NAME && cpInfo.wszDescription[i]; i++)
                {
                    if (cpInfo.wszDescription[i] == L'(')
                    {
                        cpInfo.wszDescription[i] = 0;
                        break;
                    }
                }
                // Use W version regardlessly since we're only running this on NT5             
                SetDlgItemTextW(hDlg, IDC_STATIC_LANG, cpInfo.wszDescription);
            }
            
            // Center the dialog in the area of parent window
            if (GetWindowRect(GetParent(hDlg), &rc1) && GetWindowRect(hDlg, &rc2))
            {
                MoveWindow(hDlg, (rc1.right+rc2.left+rc1.left-rc2.right)/2, (rc1.bottom+rc2.top+rc1.top-rc2.bottom)/2, rc2.right-rc2.left, rc2.bottom-rc2.top, FALSE);
            }            

            hwndCheckBox = GetDlgItem(hDlg, IDC_CHECK_LPK);

            // Set CheckBox state according to current registry setting
            PostMessage(hwndCheckBox, BM_SETCHECK, LOWORD(lParam)? BST_UNCHECKED:BST_CHECKED, 0);
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) != IDC_CHECK_LPK)
            {
                HKEY hkey;
                DWORD dwInstallOut = (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_CHECK_LPK), BM_GETCHECK, 0, 0)? 0:1);
                DWORD dwInstallIn = LOWORD(GetProp(hDlg, NT5LPK_DLG_STRING));
                
                if ((dwInstallOut != dwInstallIn) &&
                    ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_INTERNATIONAL,
                         NULL, KEY_READ|KEY_SET_VALUE, &hkey)) 
                {
                    DWORD dwType = REG_DWORD;
                    DWORD dwSize = sizeof(DWORD);
                    RegSetValueEx(hkey, REG_KEY_NT5LPK, 0, REG_DWORD, (LPBYTE)&dwInstallOut, sizeof(dwInstallOut));
                    RegCloseKey(hkey);
                }                
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            }
            break;

        case WM_HELP:
            // Do we need help file for this simply dialog?
            // If needed, we can always add it at later time.
            break;


        default:
            return FALSE;
    }
    return TRUE;
}

// To get real Windows directory on Terminal Server, 
// Instead of using internal Kernel32 API GetSystemWindowsDirectory with LoadLibrary/GetProcAddress,
// We cast GetSystemDirectory return to Windows directory
UINT MLGetWindowsDirectory(
    LPTSTR lpBuffer,    // address of buffer for Windows directory
    UINT uSize          // size of directory buffer
    )
{
    UINT uLen;

    if (g_bIsNT)
    {        
        if (uLen = GetSystemDirectory(lpBuffer, uSize))
        {        
            if (lpBuffer[uLen-1] == TEXT('\\'))
                uLen--;

            while (uLen-- > 0)
            {
                if (lpBuffer[uLen] == TEXT('\\'))
                {
                    lpBuffer[uLen] = NULL;                
                    break;
                }
            }
        }
    }
    else    
        uLen = GetWindowsDirectory(lpBuffer, uSize);

    return uLen;
}

// To speed up basic ANSI string compare,
// We avoid using lstrcmpi in LOW-ASCII case
int LowAsciiStrCmpNIA(LPCSTR  lpstr1, LPCSTR lpstr2, int count)
{
    int delta;

    while (count-- > 0)
    {        
        delta = *lpstr1 - *lpstr2;
        if (delta && 
            !(IS_CHARA(*lpstr1) && IS_CHARA(*lpstr2) && (delta == 0x20 || delta == -0x20)))
            return delta;
        lpstr1++;
        lpstr2++;
    }

    return 0;
}

//
//  GetNT5UILanguage(void)
//
LANGID GetNT5UILanguage(void)
{
    if (g_bIsNT5)
    {
        static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

        if (pfnGetUserDefaultUILanguage == NULL)
        {
            HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

            if (hmod)
                pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
        }
        if (pfnGetUserDefaultUILanguage)
            return pfnGetUserDefaultUILanguage();
    }

    return 0;
}

// Special characters that we should filter out
WCHAR wszBestFit[] = {0x00A6, 0x00A9, 0x00AB, 0x00AD, 0x00AE, 0x00B7, 0x00BB, 0x02C6, 0x02DC, 0x2013, 
                      0x2014, 0x2018, 0x2019, 0x201A, 0x201C,0x201D, 0x201E, 0x2022, 0x2026, 0x2039, 0x203A,0x2122, 0x0000};

DWORD OutBoundDetectPreScan(LPWSTR lpWideCharStr, UINT cchWideChar, WCHAR *pwszCopy, WCHAR *lpBestFitChar)
{
    DWORD dwRet = 0;
    WCHAR *lpStart;

    if (!lpBestFitChar)
        lpBestFitChar = wszBestFit;

    lpStart = lpBestFitChar;

    if (pwszCopy)
    {
        CopyMemory(pwszCopy, lpWideCharStr, sizeof(WCHAR)*cchWideChar);
        lpWideCharStr = pwszCopy;
    }     

    if (lpWideCharStr)
    {
        for (UINT ui=0; ui<cchWideChar; ui++)
        {
            if (IS_CJK_CHAR(*lpWideCharStr))
                dwRet |= FS_CJK;
            else if (IS_HINDI_CHAR(*lpWideCharStr))
                dwRet |= FS_HINDI;     
            else if (IS_PUA_CHAR(*lpWideCharStr))
                dwRet |= FS_PUA;
            else if (pwszCopy)
            {
                while (*lpBestFitChar)
                {
                    if (*lpWideCharStr == *lpBestFitChar)
                        *lpWideCharStr = 0x20;
                    lpBestFitChar++;
                }
                lpBestFitChar = lpStart;
            }
            lpWideCharStr++;
        }
    }
    
    return dwRet;
}

//
// Whistler bug #90433 WEIWU 07/06/00
//
// Outlook has a bug its RTFHTML, this component doesn't CoInitialize/
// CoUninitialize COM, but, it uses MLang COM services, it depends on 
// other threads (components) to deal with COM, when COM is unloaded by those threads. 
// Invoking the interface pointer causes AV. RTFHTML should CoInit/CoUnInit by 
// itself.
//
// The reason for this to be working before is - MLang was depending on ATL 
// for objects management, ATL create heap for MLang object allocations, MLang 
// notifies ATL to destroy the heap at DLL detach time and RTFHTML's IsBadReadPtr
// () caught the invalid pointer. Now in Whistler, MLang includes crtfree.h 
// which overwrites ATL memory management functions (same as other shell 
// components), so, nothing is allocated from the process heap, this is fine for 
// MLang since it assumes that clients use COM correctly. 
//
// Now, we add this function to check Outlook version, if it is the buggy Outlook,
// We'll load mlang.dll itself DllGetClassObject() to increase the Dll ref count
//
BOOL NeedToLoadMLangForOutlook(void)
{
    TCHAR szModulePath[MAX_PATH];
    CHAR chBuffer[4096];
    DWORD dwHandle;
    VS_FIXEDFILEINFO * pszVersion;
    static BOOL bMLangLoaded = FALSE;

    if (!bMLangLoaded)
    {
        if (GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath)))
        {
            if (MLStrStr(szModulePath, TEXT("OUTLOOK.EXE")))
            {
                UINT cb = GetFileVersionInfoSize(szModulePath, &dwHandle);

                if (cb <= sizeof(chBuffer) &&
                    GetFileVersionInfo(szModulePath, dwHandle, sizeof(chBuffer), (void *)chBuffer) &&
                    VerQueryValue((void *)chBuffer, TEXT("\\"), (void **) &pszVersion, &cb) &&
                    (HIWORD(pszVersion->dwProductVersionMS) <= 0x09))
                {
                    bMLangLoaded = TRUE;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//
// staticIsOS() doesn't support newer Whistler OS flags.
// Borrow code from shlwapi - IsOS()
//
BOOL MLIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED (but downlevel shell32 uses them, so don't RIP there)
    case OS_WIN2000PRO:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;


    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;


    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;


    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;


    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\utf7obj.h ===
#include "convbase.h"

class CInccUTF7In : public CINetCodeConverter
{
private:
    BOOL (CInccUTF7In::*m_pfnConv)(UCHAR tc);
    BOOL (CInccUTF7In::*m_pfnCleanUp)();

    LONG m_tcUnicode ;
    BOOL m_fUTF7Mode;
    int  m_nBitCount;
    int  m_nOutCount;

public:
    CInccUTF7In(UINT uCodePage, int nCodeSet);
    ~CInccUTF7In() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();    // initialization
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
};

class CInccUTF7Out : public CINetCodeConverter
{
private:
    BOOL m_fUTF7Mode;
    BOOL m_fDoubleByte;
    BYTE m_tcFirstByte;
    int  m_nBitCount;
    LONG m_tcUnicode ;

public:
    CInccUTF7Out(UINT uCodePage, int nCodeSet);
    ~CInccUTF7Out() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();    // initialization
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\util.h ===
// Util.h : Helper functions and classes

#ifndef __UTIL_H_
#define __UTIL_H_

#include "mlatl.h"

extern class CMLAlloc* g_pMalloc;

/////////////////////////////////////////////////////////////////////////////
// CMLAlloc
class CMLAlloc
{
public:
    CMLAlloc(void);
    ~CMLAlloc(void);
    void* Alloc(ULONG cb);
    void* Realloc(void* pv, ULONG cb);
    void Free(void* pv);

private:
    IMalloc* m_pIMalloc;
};

/////////////////////////////////////////////////////////////////////////////
// CMLList
class CMLList
{
public:
    inline CMLList(int cbCell, int cbIncrement);
    inline ~CMLList(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);

    struct CCell
    {
        CCell* m_pNext;
    };

protected:
    inline void AssertPV(void*pv) const;

    inline void* MemAlloc(ULONG cb) {return ::g_pMalloc->Alloc(cb);}
    inline void* MemRealloc(void* pv, ULONG cb) {return ::g_pMalloc->Realloc(pv, cb);}
    inline void MemFree(void* pv) {::g_pMalloc->Free(pv);}

private:
    const int m_cbCell; // The size, in bytes, of a cell
    const int m_cbIncrement; // The size, in bytes, to increase the buffer at a time
    CCell* m_pBuf; // Pointer to the buffer
    int m_cCell; // The number of cells allocated
    CCell* m_pFree; // Pointer to a cell the top of free link
};

CMLList::CMLList(int cbCell, int cbIncrement) :
    m_cbCell(cbCell),
    m_cbIncrement(cbIncrement),
    m_pBuf(NULL),
    m_cCell(0),
    m_pFree(NULL)
{
    ASSERT(cbCell >= sizeof(CCell));
    ASSERT(cbIncrement >= cbCell);
}

CMLList::~CMLList(void)
{
    if (m_pBuf)
    {
#ifdef DEBUG
        int cCell = 0;
        for (CCell* pCell = m_pFree; pCell; pCell = pCell->m_pNext)
        {
            if (++cCell > m_cCell)
            {
                ASSERT(FALSE); // Free link is broken
                break;
            }
        }
        ASSERT(cCell < m_cCell); // Memory leak!?
#endif
        MemFree(m_pBuf);
    }
}

void CMLList::AssertPV(void*pv) const
{
    ASSERT(pv >= m_pBuf);
    ASSERT(pv < m_pBuf + m_cbCell * m_cCell);
    ASSERT(((CCell*)pv - m_pBuf) % m_cbCell == 0);
}

/////////////////////////////////////////////////////////////////////////////
// CMLListLru
class CMLListLru : public CMLList
{
public:
    inline CMLListLru(int cbCell, int cbIncrement);
    inline ~CMLListLru(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);
    inline HRESULT Top(void** ppv) const;
    inline HRESULT Next(void* pv, void** ppv) const;

    typedef CMLList::CCell CCell;

private:
    CCell* m_pTop;
};

CMLListLru::CMLListLru(int cbCell, int cbIncrement) :
    CMLList(cbCell, cbIncrement),
    m_pTop(NULL)
{
}

CMLListLru::~CMLListLru(void)
{
#ifdef DEBUG
    ASSERT(!m_pTop); // Memory Leak?
    while (m_pTop)
        Remove(m_pTop);
#endif
}

HRESULT CMLListLru::Top(void** ppv) const
{
    *ppv = (void*)m_pTop;
    return S_OK;
}

HRESULT CMLListLru::Next(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pNext)
        AssertPV(pCell->m_pNext);

    *ppv = (void*)pCell->m_pNext;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLListFast - double linked list
class CMLListFast : public CMLList
{
public:
    inline CMLListFast(int cbCell, int cbIncrement);
    inline ~CMLListFast(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);
    inline HRESULT Top(void** ppv) const;
    inline HRESULT Bottom(void** ppv) const;
    inline HRESULT Next(void* pv, void** ppv) const;
    inline HRESULT Prev(void* pv, void** ppv) const;

    struct CCell : public CMLList::CCell
    {
        CCell* m_pPrev;
    };

private:
    CCell* m_pTop;
};

CMLListFast::CMLListFast(int cbCell, int cbIncrement) :
    CMLList(cbCell, cbIncrement),
    m_pTop(NULL)
{
    ASSERT(cbCell >= sizeof(CCell));
}

CMLListFast::~CMLListFast(void)
{
#ifdef DEBUG
    ASSERT(!m_pTop); // Memory Leak?
    while (m_pTop)
        Remove(m_pTop);
#endif
}

HRESULT CMLListFast::Top(void** ppv) const
{
    *ppv = (void*)m_pTop;
    return S_OK;
}

HRESULT CMLListFast::Bottom(void** ppv) const
{
    if (m_pTop)
    {
        return Prev(m_pTop, ppv);
    }
    else
    {
        *ppv = NULL;
        return S_OK;
    }
}

HRESULT CMLListFast::Next(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pNext)
        AssertPV(pCell->m_pNext);

    *ppv = (void*)pCell->m_pNext;
    return S_OK;
}

HRESULT CMLListFast::Prev(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pPrev)
        AssertPV(pCell->m_pPrev);

    *ppv = (void*)pCell->m_pPrev;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFireConnection
template <class T, const IID* piid>
class CFireConnection
{
public:
    inline CFireConnection(HRESULT& rhr);
    inline CFireConnection(HRESULT& rhr, IUnknown* const pUnk);
    inline ~CFireConnection(void);
    inline BOOL Next(void);
    inline T* Sink(void);

protected:
    HRESULT* const m_phr;
    IEnumConnections* m_pEnumConn;
    CONNECTDATA m_cd;
    T* m_pSink;
};

template <class T, const IID* piid>
CFireConnection<T, piid>::CFireConnection(HRESULT& rhr) :
    m_phr(&rhr),
    m_pEnumConn(NULL),
    m_pSink(NULL)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(piid);
    ASSERT_WRITE_PTR(m_phr);

    *m_phr = S_OK;
}

template <class T, const IID* piid>
CFireConnection<T, piid>::CFireConnection(HRESULT& rhr, IUnknown* const pUnk) :
    m_phr(&rhr),
    m_pEnumConn(NULL),
    m_pSink(NULL)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(piid);
    ASSERT_WRITE_PTR(m_phr);
    ASSERT_READ_PTR(pUnk);

    IConnectionPointContainer* pcpc;

    if (SUCCEEDED(*m_phr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc)))
    {
        ASSERT_READ_PTR(pcpc);

        IConnectionPoint* pcp;

        if (SUCCEEDED(*m_phr = pcpc->FindConnectionPoint(*piid, &pcp)))
        {
            ASSERT_READ_PTR(pcp);

            if (SUCCEEDED(*m_phr = pcp->EnumConnections(&m_pEnumConn)))
            {
                ASSERT_READ_PTR(m_pEnumConn);
            }
            else
            {
                m_pEnumConn = NULL;
            }

            pcp->Release();
        }

        pcpc->Release();
    }
}

template <class T, const IID* piid>
CFireConnection<T, piid>::~CFireConnection(void)
{
    if (m_pSink)
        m_pSink->Release();
    if (m_pEnumConn)
        m_pEnumConn->Release();
}

template <class T, const IID* piid>
BOOL CFireConnection<T, piid>::Next(void)
{
    if (SUCCEEDED(*m_phr))
        ASSERT_READ_PTR(m_pEnumConn);

    if (SUCCEEDED(*m_phr) &&
        (*m_phr = m_pEnumConn->Next(1, &m_cd, NULL)) == S_OK)
    {
        if (m_pSink)
        {
            m_pSink->Release();
            m_pSink = NULL;
        }

        if (SUCCEEDED(*m_phr = m_cd.pUnk->QueryInterface(*piid, (void**)&m_pSink)))
            ASSERT_READ_PTR(m_pSink);
    }

    return SUCCEEDED(*m_phr);
}

template <class T, const IID* piid>
T* CFireConnection<T, piid>::Sink(void)
{
    return m_pSink;
}

#endif //__UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\validate.cpp ===
/*----------------------------------------------------------------------------
    %%File: validate.c
    %%Unit: fechmap
    %%Contact: jpick

    "Rolling" state machines that allow interactive verification of
    DBCS and EUC files.  Currently, separate tables are stored for
    each encoding so that the state machines can be run in parallel
    (i.e., multiple parse streams).

    These routines are used by auto-detection and if caller wants
    conversion routines to return errors on invalid characters.

    Following is a description of the structure of the DBCS and EUC 
    encodings handled by this module.  This information is taken from
    CJK.INF (maintained by Ken Lunde, author of _Understanding Japanese
    Information Processing_).  This information governs the structure
    of the class and validation state tables used in this module.

    Big5
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0xA1-0xFE
          second byte ranges                   0x40-0x7E, 0xA1-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E
    
    GBK
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0x81-0xFE
          second byte ranges                   0x40-0x7E and 0x80-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E

    HZ (information from HZ spec Fung F. Lee (lee@umunhum.stanford.edu))
      One-byte characters                   Encoding Ranges                        
        first GB byte range                     0x21-0x77
        second GB byte range                    0x21-0x7E
        ASCII                                   0x21-0x7E
      Mode switching                        Encoding sequence
        escape sequence from GB to ASCII        0x7E followed by 0x7B ("~{")
        escape sequence from ASCII to GB        0x7E followed by 0x7D ("~}")
        line continuation marker                0x7E followed by 0x0A 
        (Note: ASCII mode is the default mode) 
    
    Shift-Jis
      Two-byte Standard Characters         Encoding Ranges
          first byte ranges                    0x81-0x9F, 0xE0-0xEF
          second byte ranges                   0x40-0x7E, 0x80-0xFC
      Two-byte User-defined Dharacters     Encoding Ranges
          first byte range                     0xF0-0xFC
          second byte ranges                   0x40-0x7E, 0x80-0xFC
      One-byte Characters                  Encoding Range
          Half-width katakana                  0xA1-0xDF
          ASCII/JIS-Roman                      0x21-0x7E
    
    Wansung
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0x81-0xFE
          second byte ranges                   0x40-0x7E and 0x80-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E

    EUC-Cn
      Code set 0 (ASCII or GB 1988-89):        0x21-0x7E
      Code set 1 (GB 2312-80):                 0xA1A1-0xFEFE
      Code set 2:                              unused
      Code set 3:                              unused

    EUC-Jp
      Code set 0 (ASCII or JIS X 0201-1976 Roman):  0x21-0x7E
      Code set 1 (JIS X 0208):                 0xA1A1-0xFEFE
      Code set 2 (half-width katakana):        0x8EA1-0x8EDF
      Code set 3 (JIS X 0212-1990):            0x8FA1A1-0x8FFEFE

    EUC-Kr
      Code set 0 (ASCII or KS C 5636-1993):    0x21-0x7E
      Code set 1 (KS C 5601-1992):             0xA1A1-0xFEFE
      Code set 2:                              unused
      Code set 3:                              unused

    EUC-Tw
      Code set 0 (ASCII):                      0x21-0x7E
      Code set 1 (CNS 11643-1992 Plane 1):     0xA1A1-0xFEFE
      Code set 2 (CNS 11643-1992 Planes 1-16): 0x8EA1A1A1-0x8EB0FEFE
      Code set 3:                              unused

    UTF-7 (information from the RFC2152 by D.Goldsmith)
      One-byte characters                   Encoding Ranges                        
        Direct and Optionally direct            0x21-0x2A, 0x2C-0x5B, 
                                                0x5D-0x60, 0x7B-0x7D
                                                0x09, 0x0A, 0x0D, 0x20
        Modified Base64                         0x2B, 0x2F-39, 0x41-0x5A, 0x61-0x7A
      Mode switching
        escape sequence from D/O to M. Base64   0x2B
        escape sequence from M. Base64 to D/O   0x2D (or any control character)
        
 ----------------------------------------------------------------------------*/
 
#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"


/*----------------------------------------------------------------------------
    Common Defs for all Sequence Validation
----------------------------------------------------------------------------*/

// Characters are broken down into ranges -- the smallest ranges that
// are treated as important by either EUC or DBCS (all flavors).  In
// some cases, the smallest range is a single character.  It saves
// some space to avoid having two class tables (even though more states
// are added to the state machines), so both encodings share these
// tokens.

// Common Tokens
//
#define ollow       0       // "other" legal low ascii character
#define x000a       1       // 0x0a ("\n")
#define x212a       2       // characters in range 0x21-0x2a
#define x002b       3       // 0x2b ("+")
#define x002c       4       // 0x2c (",")
#define x002d       5       // 0x2d ("-")
#define x002e       6       // 0x2e ("\")
#define x2f39       7       // characters in range 0x2f-0x39
#define x3a3f       8       // characters in range 0x3a-0x3f
#define x0040       9       // 0x40
#define x415a       10      // characters in range 0x41-0x5a
#define x005b       11      // 0x5b ("[")   
#define x005c       12      // 0x5c ("\")
#define x5d60       13      // characters in range 0x5d-0x60
#define x6177       14      // characters in range 0x61-0x77
#define x787a       15      // characters in range 0x78-0x7a
#define x007b       16      // 0x7b ("{")
#define x007c       17      // 0x7c ("|")
#define x007d       18      // 0x7d ("}")
#define x007e       19      // 0x7e ("~")
#define x007f       20      // 0x7f (DEL)
#define x0080       21      // 0x80     
#define x818d       22      // characters in range 0x81-0x8d
#define x008e       23      // 0x8e
#define x008f       24      // 0x8f
#define x909f       25      // characters in range 0x90-0x9f
#define x00a0       26      // 0xa0
#define xa1b0       27      // characters in range 0xa1-0xb0
#define xb1df       28      // characters in range 0xb1-0xdf
#define xe0ef       29      // characters in range 0xe0-0xef
#define xf0fc       30      // characters in range 0xf0-0xfc
#define xfdfe       31      // characters in range 0xfd-0xfe

#define ateof       32      // end-of-file
#define other       33      // character not covered by above tokens

#define nTokens     34      //

// Class table
//
static char _rgchCharClass[256] =
//         0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f
    {
//  0      nul    soh    stx    etx    eot    enq    ack    bel    bs     tab    lf     vt     np     cr     so     si      0   
           other, other, other, other, other, other, other, other, other, ollow, x000a, other, other, ollow, other, other,

//  1      dle    dc1    dc2    dc3    dc4    nak    syn    etb    can    em     eof    esc    fs     gs     rs     us      1   
           other, other, other, other, other, other, other, other, other, other, ollow, other, other, other, other, other, 

//  2      sp     !      "      #      $      %      &      '      (      )      *      +      ,      -      .      /       2  
           ollow, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x002b, x002c, x002d, x002e, x2f39, 

//  3      0      1      2      3      4      5      6      7      8      9      :      ;      <      =      >      ?       3  
           x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x3a3f, x3a3f, x3a3f, x3a3f, x3a3f, x3a3f, 

//  4      @      A      B      C      D      E      F      G      H      I      J      K      L      M      N      O       4  
           x0040, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, 

//  5      P      Q      R      S      T      U      V      W      X      Y      Z      [      \      ]      ^      _       5  
           x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x005b, x005c, x5d60, x5d60, x5d60, 

//  6      `      a      b      c      d      e      f      g      h      i      j      k      l      m      n      o       6  
           x5d60, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, 

//  7      p      q      r      s      t      u      v      w      x      y      z      {      |      }      ~      del     7  
           x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x787a, x787a, x787a, x007b, x007c, x007d, x007e, x007f, 

//  8                                                                                                                       8  
           x0080, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x008e, x008f, 

//  9                                                                                                                       9  
           x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, 

//  a                                                                                                                       a  
           x00a0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, 

//  b                                                                                                                       b  
           xa1b0, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//  c                                                                                                                       c  
           xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//  d                                                                                                                       d  
           xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//  e                                                                                                                       e  
           xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, 

//  f                                                                                                                       f  
           xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xfdfe, xfdfe, other, 

//         0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f
};


// Common States -- All SM's use these
//
#define ACC         0x4e
#define ERR         0x7f

// Other States -- All SM's use some of these, not all use all
//
#define ST0         0x00
#define ST0c        0x40
#define ST1         0x01
#define ST1c        0x41
#define ST2         0x02
#define ST2c        0x42
#define ST3         0x03
#define ST3c        0x43
#define ST4         0x04
#define ST4c        0x44

// Each state can have a corresponding counting stata i.e. stata with
// with the same transitions but during which we look for special sequences.
//
#define FTstCounting(tst)                   (((tst) & 0x40) != 0)   // If the state is counting (including ACC)
#define TstNotCountingFromTst(tst)          ((tst) & 0x3f)          // Obtain the real state from the counting

/*----------------------------------------------------------------------------
    DBCS character sequence validation
----------------------------------------------------------------------------*/

#define nSJisStates     2
static signed char _rgchSJisNextState[nSJisStates][nTokens] =
{
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     e     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
                                                                                                                                        

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ERR,  ACC,  ACC,  ST1,  ST1,  ERR,  ACC,  ERR,
     
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,
     
};

#define nBig5States     2
static signed char _rgchBig5NextState[nBig5States][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
     
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
};

#define nGbkWanStates       2
static signed char _rgchGbkWanNextState[nGbkWanStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
     
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
     
};
        

/*----------------------------------------------------------------------------
    EUC character sequence validation
----------------------------------------------------------------------------*/

#define nEucJpStates        4
static signed char _rgchEucJpNextState[nEucJpStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ST2,  ST3,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
     
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
// EUC State 2 -- saw 8e, need a1df
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,
     
// EUC State 3 -- saw 8f, need 2 a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ERR,  ERR,
     
};

#define nEucKrCnStates      2
static signed char _rgchEucKrCnNextState[nEucKrCnStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
     
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
};

#define nEucTwStates        4
static signed char _rgchEucTwNextState[nEucTwStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
     
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
// EUC State 2 -- saw 8e, need a1b0
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST3,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
    
// EUC State 3 -- saw 8e, a1b0; need 2 a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ERR,  ERR,
     
};

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    HZ character sequence validation
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// Currently some of the rules for HZ encoding outlined above are a bit loosened up.
// (e.g. the range for the first GB byte is expanded) The rules were adjusted based on real data. 

#define nHzStates       5
static signed char _rgchHzNextState[nHzStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// HZ State 0 -- ASCII
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ST1c, ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
     
// HZ State 1 -- saw "~," looking for "{" to make transition to GB mode
    ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST2c, ERR,  ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
     
// HZ State 2 -- just saw "{," expecting GB byte
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ERR,  ERR,  ERR,  ST4c, ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
    
// HZ State 3 -- expecting GB byte
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST4c, ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,

// HZ State 4 -- saw "~," looking for "}" to make transition to ASCII mode
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ACC,  ST3,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,

};

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    UTF-7 character sequence validation
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#define nUtf7States     3
static signed char _rgchUtf7NextState[nUtf7States][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// UTF7 State 0 -- Direct/optionally direct ACSII mode, state transition can happen on "+"
    ACC,  ACC,  ACC,  ST1c, ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
     
// UTF7 State 1 -- Expecting first character from Modified Base64 alphabet
    ERR,  ERR,  ERR,  ST2,  ERR,  ACC,  ERR,  ST2,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST2,  ST2,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
     
// UTF7 State 2 -- Modified Base64 alphabet mode, can be exited with "-" or any control character.
    ACC,  ACC,  ERR,  ST2,  ERR,  ACC,  ERR,  ST2,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST2,  ST2,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
};

/*----------------------------------------------------------------------------
    UTF-8 character sequence validation
----------------------------------------------------------------------------*/

static int _nUtf8Tb = 0;

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

/* N  U T F  8 */
/*----------------------------------------------------------------------------
    %%Function: _NUtf8
    %%Contact: jpick

    UTF-8 doesn't require a state table for validation, just a count
    of the number of expected trail bytes.  See utf8lex.c for an 
    explanation of this code.
----------------------------------------------------------------------------*/
static int __inline NUtf8(UCHAR uch, BOOL fEoi)
{
    // BIT7(uch) == 0 implies single ASCII byte.
    // BIT6(uch) == 0 implies one of n trail bytes.
    // Otherwise, lead byte, with number of bits set
    //   up to first 0 equal to the total number bytes
    //   in the sequence.
    //
    // REVIEW: _nUtf8Tb *is* really the state of this
    //   validator -- use nState in structure?
    //
    if (fEoi && (_nUtf8Tb != 0))
        {
        return 0;               // unexpected end-of-input
        }
    else if (BIT7(uch) == 0)
        {
        if (_nUtf8Tb != 0)      // unexpected single byte
            return 0;
        return 1;
        }
    else if (BIT6(uch) == 0)
        {
        if (_nUtf8Tb == 0)      // unexpected trail byte
            return 0;
        if ((--_nUtf8Tb) == 0)
            return 1;
        }
    else
        {
        if (_nUtf8Tb != 0)      // unexpected lead byte
            return 0;
        while (BIT7(uch) != 0)
            {
            uch <<= 1;
            _nUtf8Tb++;
            }
        _nUtf8Tb--;             // don't count lead byte
        }
    return -1;
}


/*----------------------------------------------------------------------------
    Character Mapping Defs
----------------------------------------------------------------------------*/

// If caller wants us to check characters as part of validation
//
typedef BOOL (*PFNCHECKCHAR)(ICET icetIn);

#define cchMaxBuff      5
typedef struct _cc
{
    int nCp;                        // code page
    int cchBuff;                    // fill count of character buffer
    PFNCHECKCHAR pfnCheckChar;      // character check routine
    char rgchBuff[cchMaxBuff];      // character buffer
} CC;
    
// Character validation prototypes
//
static BOOL _FDbcsCheckChar(ICET icetIn);

    
// DBCS character checker structures
//

// Big5
static CC _ccBig5 =
{
    nCpTaiwan,
    0,
    _FDbcsCheckChar,
};

// Gbk
static CC _ccGbk =
{
    nCpChina,
    0,
    _FDbcsCheckChar,
};

// ShiftJis
static CC _ccSJis =
{
    nCpJapan,
    0,
    _FDbcsCheckChar,
};

// Wansung
static CC _ccWan =
{
    nCpKorea,
    0,
    _FDbcsCheckChar,
};


// Character checker structures just used as buffers.
//

// Euc-Jp
static CC _ccEucJp =
{
    0,
    0,
    0,
};

// Hz
static CC _ccHz =
{
    0,
    0,
    0,
};

// Utf7
static CC _ccUtf7 =
{
    0,
    0,
    0,
};

/*----------------------------------------------------------------------------
    Character Occurrence Counters
----------------------------------------------------------------------------*/

// If calling app wants us to track occurrences of common character
// sequences during validation (used only by auto-detection, so far).
//

typedef struct _coce
{
    int   cHits;
    short cwch;
    WCHAR rgwch[2];
} COCE;

typedef struct _coc
{
    BOOL  fMatching;
    short nCoceCurr;
    short nCoceIndex;
    int   ccoce;
    COCE *rgcoce;
} COC;
    
// Big5
//
static COCE _rgcoceBig5[] =
{
    {0, 2, {(WCHAR)0xa7da, (WCHAR)0xadcc},},            // "wo men"
    {0, 2, {(WCHAR)0xa8e4, (WCHAR)0xb9ea},},            // "qi shi"
    {0, 2, {(WCHAR)0xa65d, (WCHAR)0xacb0},},            // "yin wei"
    {0, 2, {(WCHAR)0xb8ea, (WCHAR)0xb054},},            // "zi xun"
    {0, 2, {(WCHAR)0xb971, (WCHAR)0xb8a3},},            // "diam nao"
    {0, 2, {(WCHAR)0xbaf4, (WCHAR)0xb8f4},},            // "wang lu"
    {0, 2, {(WCHAR)0xbd75, (WCHAR)0xa457},},            // "xian shang"
    {0, 2, {(WCHAR)0xc577, (WCHAR)0xaaef},},            // "huan ying"
    {0, 2, {(WCHAR)0xa477, (WCHAR)0xb867},},            // "yi jing"
};
        
static COC _cocBig5 =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceBig5) / sizeof(_rgcoceBig5[0]),       // ccoce
    _rgcoceBig5,                                        // rgcoce
};

// Euc-Cn
//
static COCE _rgcoceEucCn[] =
{
    {0, 2, {(WCHAR)0xcbfb, (WCHAR)0xc3c7},},            // "ta men"
    {0, 2, {(WCHAR)0xced2, (WCHAR)0xc3c7},},            // "wo men"
    {0, 2, {(WCHAR)0xd2f2, (WCHAR)0xb4cb},},            // "yin ci"
    {0, 2, {(WCHAR)0xcab2, (WCHAR)0xc3b4},},            // "shen mo"
    {0, 2, {(WCHAR)0xc8e7, (WCHAR)0xb9fb},},            // "ru guo"
    {0, 2, {(WCHAR)0xd2f2, (WCHAR)0xceaa},},            // "yin wei"
    {0, 2, {(WCHAR)0xcbf9, (WCHAR)0xd2d4},},            // "suo yi"
    {0, 2, {(WCHAR)0xbbb6, (WCHAR)0xd3ad},},            // "huan ying"
    {0, 2, {(WCHAR)0xcdf8, (WCHAR)0xc2e7},},            // "wang luo"
    {0, 2, {(WCHAR)0xd0c5, (WCHAR)0xcfa2},},            // "xin xi"
    {0, 2, {(WCHAR)0xbcc6, (WCHAR)0xcbe3},},            // "ji guan"
};
        
static COC _cocEucCn =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceEucCn) / sizeof(_rgcoceEucCn[0]),     // ccoce
    _rgcoceEucCn,                                       // rgcoce
};
    
// Euc-Kr
//
static COCE _rgcoceEucKr[] =
{
    {0, 2, {(WCHAR)0xb0a1, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb0a1, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xb4c2, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb4c2, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xb4d9, (WCHAR)0x002e},},
    {0, 2, {(WCHAR)0xb4d9, (WCHAR)0xa3ae},},
    {0, 2, {(WCHAR)0xb8a6, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb8a6, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0ba, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0ba, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0bb, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0bb, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0cc, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0cc, (WCHAR)0xa1a1},},
};
        
static COC _cocEucKr =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceEucKr) / sizeof(_rgcoceEucKr[0]),     // ccoce
    _rgcoceEucKr,                                       // rgcoce
};
    
// EUC-Jp
//
static COCE _rgcoceEucJp[] =
{
    {0, 2, {(WCHAR)0xa4c7, (WCHAR)0xa4b9},},            // "de su"
    {0, 2, {(WCHAR)0xa4c0, (WCHAR)0xa1a3},},            // "da ."
    {0, 2, {(WCHAR)0xa4a4, (WCHAR)0xa4eb},},            // "i ru"
    {0, 2, {(WCHAR)0xa4de, (WCHAR)0xa4b9},},            // "ma su"
    {0, 2, {(WCHAR)0xa4b7, (WCHAR)0xa4bf},},            // "shi ta"
    {0, 2, {(WCHAR)0xa4b9, (WCHAR)0xa4eb},},            // "su ru"
    {0, 2, {(WCHAR)0xa4bf, (WCHAR)0xa1a3},},            // "ta ."
    {0, 2, {(WCHAR)0xa4eb, (WCHAR)0xa1a3},},            // "ru ."
};
        
static COC _cocEucJp =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceEucJp) / sizeof(_rgcoceEucJp[0]),     // ccoce
    _rgcoceEucJp,                                       // rgcoce
};

// GBK
//
static COCE _rgcoceGbk[] =
{
    {0, 2, {(WCHAR)0xcbfb, (WCHAR)0xc3c7},},            // "ta men"
    {0, 2, {(WCHAR)0xced2, (WCHAR)0xc3c7},},            // "wo men"
    {0, 2, {(WCHAR)0xd2f2, (WCHAR)0xb4cb},},            // "yin ci"
    {0, 2, {(WCHAR)0xcab2, (WCHAR)0xc3b4},},            // "shen mo"
    {0, 2, {(WCHAR)0xc8e7, (WCHAR)0xb9fb},},            // "ru guo"
    {0, 2, {(WCHAR)0xd2f2, (WCHAR)0xceaa},},            // "yin wei"
    {0, 2, {(WCHAR)0xcbf9, (WCHAR)0xd2d4},},            // "suo yi"
    {0, 2, {(WCHAR)0xbbb6, (WCHAR)0xd3ad},},            // "huan ying"
    {0, 2, {(WCHAR)0xcdf8, (WCHAR)0xc2e7},},            // "wang luo"
    {0, 2, {(WCHAR)0xd0c5, (WCHAR)0xcfa2},},            // "xin xi"
    {0, 2, {(WCHAR)0xbcc6, (WCHAR)0xcbe3},},            // "ji guan"
};
        
static COC _cocGbk =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceGbk) / sizeof(_rgcoceGbk[0]),         // ccoce
    _rgcoceGbk,                                         // rgcoce
};
    
// Shift-JIS
//
static COCE _rgcoceSJis[] =
{
    {0, 2, {(WCHAR)0x82c5, (WCHAR)0x82b7},},            // "de su"
    {0, 2, {(WCHAR)0x82be, (WCHAR)0x8142},},            // "da ."
    {0, 2, {(WCHAR)0x82a2, (WCHAR)0x82e9},},            // "i ru"
    {0, 2, {(WCHAR)0x82dc, (WCHAR)0x82b7},},            // "ma su"
    {0, 2, {(WCHAR)0x82b5, (WCHAR)0x82bd},},            // "shi ta"
    {0, 2, {(WCHAR)0x82b7, (WCHAR)0x82e9},},            // "su ru"
    {0, 2, {(WCHAR)0x82bd, (WCHAR)0x8142},},            // "ta ."
    {0, 2, {(WCHAR)0x82e9, (WCHAR)0x8142},},            // "ru ."
};

static COC _cocSJis =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceSJis) / sizeof(_rgcoceSJis[0]),       // ccoce
    _rgcoceSJis,                                        // rgcoce
};
    
// Wansung
//
// REVIEW: bug (1/2 this table is being ignored)
//
static COCE _rgcoceWan[] =
{
    {0, 2, {(WCHAR)0xb0a1, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb0a1, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xb4c2, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb4c2, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xb4d9, (WCHAR)0x002e},},
    {0, 2, {(WCHAR)0xb4d9, (WCHAR)0xa3ae},},
    {0, 2, {(WCHAR)0xb8a6, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xb8a6, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0ba, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0ba, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0bb, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0bb, (WCHAR)0xa1a1},},
    {0, 2, {(WCHAR)0xc0cc, (WCHAR)0x0020},},
    {0, 2, {(WCHAR)0xc0cc, (WCHAR)0xa1a1},},
};

static COC _cocWan =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceWan) / sizeof(_rgcoceWan[0]),         // ccoce
    _rgcoceWan,                                         // rgcoce
};

// Hz
//
static COCE _rgcoceHz[] =
{
    {0, 2, {(WCHAR)0x007e, (WCHAR)0x007b},},            // ~{
    {0, 2, {(WCHAR)0x007e, (WCHAR)0x007d},},            //  ~}
};

static COC _cocHz =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceHz) / sizeof(_rgcoceHz[0]),           // ccoce
    _rgcoceHz,                                          // rgcoce
};

// Utf7
//
static COCE _rgcoceUtf7[] =
{
    {0, 2, {(WCHAR)0x002b, (WCHAR)0x002d},},            // +-
};

static COC _cocUtf7 =
{
    fFalse,                                             // fMatching
    0,                                                  // nCoceCurr
    0,                                                  // nCoceIndex
    sizeof(_rgcoceUtf7) / sizeof(_rgcoceUtf7[0]),       // ccoce
    _rgcoceUtf7,                                        // rgcoce
};
    
// Character counter prototype.
//
static void _CountChars(ICET icetIn);


/*----------------------------------------------------------------------------
    Main Definitions
----------------------------------------------------------------------------*/

// Structure to keep state, state machine and other associated
// information for a given character set "parse stream."
//
typedef struct _vr
{
    BOOL  fInUse;
    DWORD dwFlags;
    int   nState;
    CC   *ccCheck;
    signed char (*rgchNextState)[nTokens];
} VR;

// Array of validation records.  We allow multiple, active parse
// streams for auto-detect -- this way, it can concurrently keep
// a parse stream for each encoding type, without needing to read
// its input multiple times.
//
static VR _mpicetvr[icetCount] =
{
    {fTrue,  0, ST0, 0,         _rgchEucKrCnNextState,},        // icetEucCn
    {fTrue,  0, ST0, &_ccEucJp, _rgchEucJpNextState,},          // icetEucJp
    {fTrue,  0, ST0, 0,         _rgchEucKrCnNextState,},        // icetEucKr
    {fTrue,  0, ST0, 0,         _rgchEucTwNextState,},          // icetEucTw
    {fFalse, 0, ST0, 0,         0,},                            // icetIso2022Cn
    {fFalse, 0, ST0, 0,         0,},                            // icetIso2022Jp
    {fFalse, 0, ST0, 0,         0,},                            // icetIso2022Kr
    {fFalse, 0, ST0, 0,         0,},                            // icetIso2022Tw
    {fTrue,  0, ST0, &_ccBig5,  _rgchBig5NextState,},           // icetBig5
    {fTrue,  0, ST0, &_ccGbk,   _rgchGbkWanNextState,},         // icetGbk
    {fTrue,  0, ST0, &_ccHz,    _rgchHzNextState,},             // icetHz
    {fTrue,  0, ST0, &_ccSJis,  _rgchSJisNextState,},           // icetShiftJis
    {fTrue,  0, ST0, &_ccWan,   _rgchGbkWanNextState,},         // icetWansung
    {fTrue,  0, ST0, &_ccUtf7,  _rgchUtf7NextState,},           // icetUtf7
    {fTrue,  0, ST0, 0,        0,},                             // icetUtf8
};

// Array of character sequence counters, one per encoding type.
//
static COC *_mpicetlpcoc[icetCount] =
{
    &_cocEucCn,         // icetEucCn
    &_cocEucJp,         // icetEucJp
    &_cocEucKr,         // icetEucKr
    0,                  // icetEucTw
    0,                  // icetIso2022Cn
    0,                  // icetIso2022Jp
    0,                  // icetIso2022Kr
    0,                  // icetIso2022Tw
    &_cocBig5,          // icetBig5
    &_cocGbk,           // icetGbk
    &_cocHz,            // icetHz
    &_cocSJis,          // icetShiftJis
    &_cocWan,           // icetWansung
    &_cocUtf7,          // icetUtf7
    0,                  // icetUtf8
};


/* V A L I D A T E  I N I T */
/*----------------------------------------------------------------------------
    %%Function: ValidateInit
    %%Contact: jpick

    Initialize the state machine for the given character set (set its
    state to ST0 (the start state) and store its parsing options).
----------------------------------------------------------------------------*/
void ValidateInit(ICET icetIn, DWORD dwFlags)
{
    // Initialize the character occurrence counter, if caller wants
    // us to count common character sequences (auto-detect, only,
    // for now).  Turn off the count-common-chars flag if we're not
    // set up to count sequences (meaning we don't have a set of
    // common characters for this encoding type or have no place
    // to buffer them).
    //  
    if (dwFlags & grfCountCommonChars)
        {
        if ((_mpicetlpcoc[icetIn]) && (_mpicetvr[icetIn].ccCheck))
            {
            int i;
            for (i = 0; i < _mpicetlpcoc[icetIn]->ccoce; i++)
                _mpicetlpcoc[icetIn]->rgcoce[i].cHits = 0;
            _mpicetlpcoc[icetIn]->fMatching = fFalse;
            }
        else
            {
            dwFlags &= ~grfCountCommonChars;
            }
        }
        
    // If validation not supported for the encoding type, there's
    // nothing else for us to do here.
    //
    if (!_mpicetvr[icetIn].fInUse)
        return;
        
    _mpicetvr[icetIn].nState = ST0;
    
    // Can't do character mapping validation without character 
    // checker information.  (If we do have the character checker,
    // initialize its buffer length to 0).
    //
    if (_mpicetvr[icetIn].ccCheck)
        _mpicetvr[icetIn].ccCheck->cchBuff = 0;
    else
        dwFlags &= ~grfValidateCharMapping;
        
    // It's also impossible without a valid code page.
    //
    if ((dwFlags & grfValidateCharMapping) && !IsValidCodePage(_mpicetvr[icetIn].ccCheck->nCp))
        dwFlags &= ~grfValidateCharMapping;
    
    _mpicetvr[icetIn].dwFlags = dwFlags;
    
    if (icetIn == icetUtf8)
        _nUtf8Tb = 0;
}


/* V A L I D A T E  R E S E T  A L L*/
/*----------------------------------------------------------------------------
    %%Function: ValidateInitAll
    %%Contact: jpick

    Initialize the state machines for all character sets (set their
    states to ST0 (the start state) and store their parsing options).
----------------------------------------------------------------------------*/
void ValidateInitAll(DWORD dwFlags)
{
    int i;
    for (i = 0 ; i < icetCount; i++)
        {
        if (!_mpicetvr[i].fInUse)
            continue;
        ValidateInit((ICET)i, dwFlags); 
        }
}


/* V A L I D A T E  R E S E T */
/*----------------------------------------------------------------------------
    %%Function: ValidateReset
    %%Contact: jpick

    Reset the state machine for the given character set (set its state
    to ST0 (the start state)).
----------------------------------------------------------------------------*/
void ValidateReset(ICET icetIn)
{
    // Initialize the character occurrence counter, if caller wants
    // us to count common character sequences (auto-detect, only,
    // for now).  We're guaranteed to have the structures if the
    // flag is set by ValidateInit(), above.
    //  
    if (_mpicetvr[icetIn].dwFlags & grfCountCommonChars)
        {
        int i;
        for (i = 0; i < _mpicetlpcoc[icetIn]->ccoce; i++)
            _mpicetlpcoc[icetIn]->rgcoce[i].cHits = 0;
        _mpicetlpcoc[icetIn]->fMatching = fFalse;
        }
        
    // If validation not supported for the encoding type, there's
    // nothing else for us to do here.
    //
    if (!_mpicetvr[icetIn].fInUse)
        return;
        
    _mpicetvr[icetIn].nState = ST0;
    
    if (_mpicetvr[icetIn].ccCheck)
        _mpicetvr[icetIn].ccCheck->cchBuff = 0;
        
    if (icetIn == icetUtf8)
        _nUtf8Tb = 0;
}


/* V A L I D A T E  R E S E T  A L L */
/*----------------------------------------------------------------------------
    %%Function: ValidateResetAll
    %%Contact: jpick

    Reset the state machines for all character sets (set their states to
    ST0 (the start state)).
----------------------------------------------------------------------------*/
void ValidateResetAll(void)
{
    int i;
    
    for (i=0 ; i < icetCount; i++)
        {
        if (!_mpicetvr[i].fInUse)
            continue;
        ValidateReset((ICET)i);
        }
}


/* N  V A L I D A T E  U C H */
/*----------------------------------------------------------------------------
    %%Function: NValidateUch
    %%Contact: jpick

    Single step parser, takes one transition through the state table
    for the given character set.  Current state is kept for each
    character set's parse stream.
    
    Routine returns -1 if it does not reach a final state on this
    transition; 0 if transitioned to ERR(or) and 1 if transtioned
    to ACC(ept).
    
    If final state is ACC(ept), machine reset to ST0 (start state).
    (i.e., there's no need to manually reset on ACC(ept)).
    
    Routine is also a convenient collection point for certain
    statistics (currently only the counting of occurrences of common
    character sequences (defined for character sets, above)).
----------------------------------------------------------------------------*/
int NValidateUch(ICET icetIn, UCHAR uch, BOOL fEoi)
{
    int nToken;
    int nPrevState;
    int rc = -1;
    
    // If not validating this icet, nothing to do (so say 
    // we accept the character).
    //
    if (!_mpicetvr[icetIn].fInUse)
        return 1;
    if (_mpicetvr[icetIn].nState == ERR)
        return 0;

    // Ignore all zeros in the detection file.
    if (!uch && !fEoi)
        {
            goto _LRet;
        }

    // Hack -- want to validate UTF-8, but don't need a state
    // table to do so.  Treat as special case here and return.
    //
    if (icetIn == icetUtf8)
        {
        if ((rc = NUtf8(uch, fEoi)) == 0)
            _mpicetvr[icetIn].nState = ERR;
        return rc;
        }
        
    // Classify the character...
    //
    nPrevState = _mpicetvr[icetIn].nState;
    nToken = fEoi ? ateof : _rgchCharClass[uch];
    
    // First obtain a real number for a state based on the counting state...
    // Then do the transition...
    //
    _mpicetvr[icetIn].nState = (_mpicetvr[icetIn].rgchNextState)[TstNotCountingFromTst(_mpicetvr[icetIn].nState)][nToken];

#if 0
    if (_mpicetvr[icetIn].nState == ERR) 
        printf("Character 0x%.2x; Going from state %.2x to state %.2x\n", uch, nPrevState, _mpicetvr[icetIn].nState);
#endif

    // If we're in an error state or have seen end-of-input, return.
    //
    if ((_mpicetvr[icetIn].nState == ERR) || (nToken == ateof))
        goto _LRet;
    
    // Are we to do character mapping validation?  (If this flag
    // is set, we're guaranteed to have a character checker 
    // structure).  How about character occurrence counting?
    // (This also guarantees us a character checker structure).
    //
    if (!(_mpicetvr[icetIn].dwFlags & grfValidateCharMapping) &&
            !(_mpicetvr[icetIn].dwFlags & grfCountCommonChars))
        {
        goto _LRet;
        }
            
    // Buffer the current character (trusting that we'll never get
    // more than the max amount -- present tables enforce this)
    // (if it's Utf7 or Hz, buffer only if we are in the counting state
    //
    if (FTstCounting(_mpicetvr[icetIn].nState) || (icetIn != icetHz && icetIn != icetUtf7)) 
        _mpicetvr[icetIn].ccCheck->rgchBuff[_mpicetvr[icetIn].ccCheck->cchBuff++] = uch;

    // Return if we are not in the counting state
    //
    if (!(FTstCounting(_mpicetvr[icetIn].nState)))
        goto _LRet;
        
    // Call the character checker, if we have one.
    //
    if (_mpicetvr[icetIn].dwFlags & grfValidateCharMapping)
        {
        if (_mpicetvr[icetIn].ccCheck->pfnCheckChar && !(_mpicetvr[icetIn].ccCheck->pfnCheckChar)(icetIn))
            {
            _mpicetvr[icetIn].nState = ERR;
            goto _LRet;
            }
        }
        
    // If we're counting common characters, do so now.
    //
    if (_mpicetvr[icetIn].dwFlags & grfCountCommonChars)
        _CountChars(icetIn);
    
    // Reset the character checker/counter buffer.
    //
    _mpicetvr[icetIn].ccCheck->cchBuff = 0;
    
_LRet:

    // Return the appropriate code.
    //
    switch (_mpicetvr[icetIn].nState)
        {
        case ERR:
            return 0;
        case ACC:
            _mpicetvr[icetIn].nState = ST0;         // Reset
            return 1;
        default:
            return -1;                              // need more data
        }
}


/* F  V A L I D A T E  C H A R  C O U N T */
/*----------------------------------------------------------------------------
    %%Function: FValidateCharCount
    %%Contact: jpick

    Return the number of matched special character sequences for the
    given character set.  If we're not keeping track of these sequences
    for the character set, either because we don't have the necessary
    static data or because the flag wasn't set by the calling routine,
    return fFalse.  Otherwise, return the count in *lpcMatch and return
    fTrue;
    
    (We track the counts separately for each sequence, just in case
    we want to weight them differently in the future.  Return the
    total, here).
----------------------------------------------------------------------------*/
BOOL FValidateCharCount(ICET icetIn, int *lpcMatch)
{
    int i;
    COC *lpcoc = _mpicetlpcoc[icetIn];
    VR *lpvr = &_mpicetvr[icetIn];
        
    if (!lpcoc || !lpvr->fInUse || !(lpvr->dwFlags & grfCountCommonChars))
        return fFalse;
        
    for (i = 0, *lpcMatch = 0; i < lpcoc->ccoce; i++)
        *lpcMatch += lpcoc->rgcoce[i].cHits;
        
    return fTrue;
}


/* _  C O U N T  C H A R S */
/*----------------------------------------------------------------------------
    %%Function: _CountChars
    %%Contact: jpick

    We've just completed a legal character for the given character
    set.  Match it against the set of special character sequences for
    the character set, if we have them.  Update match counts and
    current match indices (since sequences can span multiple legal
    characters) as needed.
----------------------------------------------------------------------------*/
static void _CountChars(ICET icetIn)
{
    WCHAR wch;
    int i;
    BOOL fFound;
    
    // Anything to do?
    //
    if (!_mpicetlpcoc[icetIn] || !_mpicetvr[icetIn].ccCheck)
        return;
        
    // Build the WCHAR.
    //
    switch (_mpicetvr[icetIn].ccCheck->cchBuff)
        {
        case 1:
            wch = WchFromUchUch(0, _mpicetvr[icetIn].ccCheck->rgchBuff[0]);
            break;
        case 2:
            wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[0],
                                _mpicetvr[icetIn].ccCheck->rgchBuff[1]);
            break;
        case 3:
            wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[1],
                                _mpicetvr[icetIn].ccCheck->rgchBuff[2]);
            break;
        case 4:
            wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[2],
                                _mpicetvr[icetIn].ccCheck->rgchBuff[3]);
            break;
        default:
            return;
        }
        
    // Are we currently working on matching a sequence?
    //
    if ((_mpicetlpcoc[icetIn]->fMatching) && 
        (wch == _mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].rgwch[_mpicetlpcoc[icetIn]->nCoceIndex]))
        {
        // Did we just match the entire sequence?  If so, increment the
        // hit count and reset.
        //
        if (++_mpicetlpcoc[icetIn]->nCoceIndex >= _mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].cwch)
            {
            ++_mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].cHits;
            _mpicetlpcoc[icetIn]->fMatching = fFalse;
            }
            
        // All done.
        //
        return;
        }
        
    // If we need to start matching again (either because we're not
    // currently in a sequence or because a 2nd or later character
    // didn't match), try the current character as a lead character.
    //
    // REVIEW: wrong for sequences longer than 2 wchars.
    //
    for (i = 0, fFound = fFalse; (!fFound && (i < _mpicetlpcoc[icetIn]->ccoce)); i++)
        {
        if (wch == _mpicetlpcoc[icetIn]->rgcoce[i].rgwch[0])
            fFound = fTrue;
        }
        
    // Any luck?
    //
    if (!fFound)
        {
        _mpicetlpcoc[icetIn]->fMatching = fFalse;
        return;
        }
        
    // Store the matching state.
    //
    _mpicetlpcoc[icetIn]->fMatching = fTrue;
    _mpicetlpcoc[icetIn]->nCoceCurr = i - 1;
    _mpicetlpcoc[icetIn]->nCoceIndex = 1;           // where to look next
}


/* _  D B C S  C H E C K  C H A R */
/*----------------------------------------------------------------------------
    %%Function: _DbcsCheckChar
    %%Contact: jpick

    Character validator for DBCS formats.  Attempts to round-trip a
    legal multi-byte sequence to ensure that its valid for the given
    character set.
    
    REVIEW:  Slow, slow, slow -- do we really gain anything from the
    round-trip check, or is conversion *to* Unicode a sufficient test?
----------------------------------------------------------------------------*/
static WCHAR _rgwBuff[10];
static UCHAR _rgchBuff[30];

static BOOL _FDbcsCheckChar(ICET icetIn)
{
    int cCvt;
    
    // skip 1 byte characters, mostly uninteresting (Shift-Jis ??).
    //
    if (_mpicetvr[icetIn].ccCheck->cchBuff == 1)
        return fTrue;
    
    if (!(cCvt = MultiByteToWideChar(_mpicetvr[icetIn].ccCheck->nCp,
                                     MB_ERR_INVALID_CHARS,
                                     _mpicetvr[icetIn].ccCheck->rgchBuff,
                                     _mpicetvr[icetIn].ccCheck->cchBuff,
                                     _rgwBuff, 10)))
        {
        if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
            return fFalse;
        }
        
    return fTrue;  // probably not always right
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\factory.cpp ===
#include "private.h"
#include "factory.h"

CClassFactory::CClassFactory(const CFactoryData *pFactoryData) :
    m_pFactoryData(pFactoryData)
{
    m_cRef = 1;

    DllAddRef();
}

CClassFactory::~CClassFactory()
{
    DllRelease();
}

// IUnknown members
STDMETHODIMP CClassFactory::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if( IID_IUnknown == riid || IID_IClassFactory == riid )
        *ppv=this;

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

// IClassFactory members
STDMETHODIMP CClassFactory::CreateInstance(
    LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if ((NULL == ppv) ||
        (punkOuter && (IID_IUnknown != riid)))
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if ((NULL != punkOuter) && 
        !(m_pFactoryData->m_dwFlags & FD_ALLOWAGGREGATION))
    {
        return CLASS_E_NOAGGREGATION;
    }

    IUnknown *punk;
    hr = m_pFactoryData->m_pCreateProc(punkOuter, &punk);

    if (SUCCEEDED(hr))
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    }

    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllLock();
    }
    else
    {
        DllUnlock();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\identmgr.cpp ===
//
// ident.cpp - implementation of CIdentity class
//
#include "private.h"
#include "multiusr.h"
#include "multiui.h"
#include "strconst.h"
#include "resource.h"
#include "mluisup.h"

extern HINSTANCE g_hInst;
BOOL        g_fReleasedMutex = true;


//
// Constructor / destructor
//
CUserIdentityManager::CUserIdentityManager()
{
    m_cRef = 1;
    m_fWndRegistered = FALSE;
    m_hwnd = NULL;
    m_pAdviseRegistry = NULL;
    InitializeCriticalSection(&m_rCritSect);
    DllAddRef();
}

CUserIdentityManager::~CUserIdentityManager()
{
    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();
    DeleteCriticalSection(&m_rCritSect);
    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CUserIdentityManager::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if (IID_IUnknown == riid)
    {
        *ppv = (IUserIdentityManager *)this;
    }
    else if (IID_IUserIdentityManager == riid)
    {
        *ppv = (IUserIdentityManager *)this;
    }
    else if (IID_IConnectionPoint == riid)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else if (IID_IPrivateIdentityManager == riid)
    {
        *ppv = (IPrivateIdentityManager *)this;
    }
    else if (IID_IPrivateIdentityManager2 == riid)
    {
        *ppv = (IPrivateIdentityManager2 *)this;
    }

    // Addref through the interface
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUserIdentityManager::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CUserIdentityManager::Release()
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


STDMETHODIMP CUserIdentityManager::CreateIdentity(WCHAR *pszName, IUserIdentity **ppIdentity)
{
    return CreateIdentity2(pszName, NULL, ppIdentity);
}

STDMETHODIMP CUserIdentityManager::CreateIdentity2(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT  hr;
    TCHAR   szName[CCH_IDENTITY_NAME_MAX_LENGTH+1];

    *ppIdentity = NULL;

    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szName, CCH_IDENTITY_NAME_MAX_LENGTH, NULL, NULL) == 0)
        return GetLastError();

    if (MU_UsernameExists(szName))
        return E_IDENTITY_EXISTS;

    pIdentity = new CUserIdentity;
    
    Assert(pIdentity);

    if (!pIdentity)
        return E_OUTOFMEMORY;

    hr = pIdentity->SetName(pszName);
    
    if (SUCCEEDED(hr))
    {
        if (pszPassword)
        {
            hr = pIdentity->SetPassword(pszPassword);
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppIdentity = pIdentity;
    }
    else
    {
        pIdentity->Release();
    }

    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_ADDED);

    return hr;
}

STDMETHODIMP CUserIdentityManager::ConfirmPassword(GUID *uidCookie, WCHAR *pszPassword)
{
    TCHAR           szPwd[CCH_USERPASSWORD_MAX_LENGTH+1];
    HRESULT         hr = E_FAIL;
    USERINFO        userInfo;

    if (WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, szPwd, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
        return E_FAIL;

    if (MU_GetUserInfo(uidCookie, &userInfo))
    {
        if (userInfo.fPasswordValid)
        {
            if (!userInfo.fUsePassword)
                userInfo.szPassword[0] = 0;

            if (lstrcmp(szPwd, userInfo.szPassword) == 0)
                hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CUserIdentityManager::DestroyIdentity(GUID *uidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;
    
    return MU_DeleteUser(uidCookie);
}

STDMETHODIMP CUserIdentityManager::EnumIdentities(IEnumUserIdentity **ppEnumIdentity)
{
    CEnumUserIdentity   *pEnumIdentity;

    *ppEnumIdentity = NULL;

    pEnumIdentity = new CEnumUserIdentity;

    if (!pEnumIdentity)
        return E_OUTOFMEMORY;

    *ppEnumIdentity = pEnumIdentity;

    return S_OK;
}

STDMETHODIMP CUserIdentityManager::SetDefaultIdentity(GUID *puidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    return MU_MakeDefaultUser(puidCookie);
}

STDMETHODIMP CUserIdentityManager::GetDefaultIdentity(GUID *puidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    return MU_GetDefaultUserID(puidCookie) ? S_OK : S_FALSE;
}

STDMETHODIMP CUserIdentityManager::ManageIdentities(HWND hwndParent, DWORD dwFlags)
{
    TCHAR    szUsername[CCH_USERNAME_MAX_LENGTH+1];

    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;
    
    *szUsername = 0;

    MU_ManageUsers(hwndParent, szUsername, dwFlags);
    
    // if the user created a new user and said they want to switch to them now,
    // we should do so.
    if (*szUsername)
    {
        BOOL        fGotUser;
        USERINFO    rUser;
        GUID        uidUserID;
        HRESULT     hr;

        fGotUser = MU_GetUserInfo(NULL, &rUser);
        if (!fGotUser)
        {
            *rUser.szUsername = 0;
            ZeroMemory(&rUser.uidUserID, sizeof(GUID));
        }
        MU_UsernameToUserId(szUsername, &uidUserID);

        if (FAILED(hr = _SwitchToUser(&rUser.uidUserID, &uidUserID)))
        {
            SetForegroundWindow(hwndParent);
            
            if (hr != E_USER_CANCELLED)
                MU_ShowErrorMessage(hwndParent, idsSwitchCancelled, idsSwitchCancelCaption);
        }
    }
    return S_OK;
}

STDMETHODIMP CUserIdentityManager::_PersistChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szOutgoingID, 0, REG_BINARY, (LPBYTE)&g_uidOldUserId, sizeof(GUID)))
    {
        goto exit;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szIncomingID, 0, REG_BINARY, (LPBYTE)&g_uidNewUserId, sizeof(GUID)))
    {
        goto exit;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szChanging, 0, REG_BINARY, (LPBYTE)&g_fNotifyComplete, sizeof(g_fNotifyComplete)))
    {
        goto exit;
    }
    

    hr = S_OK;
exit:
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;
}

STDMETHODIMP CUserIdentityManager::_LoadChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;
    DWORD dwType, dwSize;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    dwType = REG_BINARY;
    dwSize = sizeof(GUID);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szOutgoingID, 0, &dwType, (LPBYTE)&g_uidOldUserId, &dwSize))
    {
        goto exit;
    }
    
    dwSize = sizeof(GUID);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szIncomingID, 0, &dwType, (LPBYTE)&g_uidNewUserId, &dwSize))
    {
        goto exit;
    }

    dwSize = sizeof(g_fNotifyComplete);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szChanging, 0, &dwType, (LPBYTE)&g_fNotifyComplete, &dwSize))
    {
        goto exit;
    }


    hr = S_OK;
exit:
    if (FAILED(hr))
    {
        g_uidOldUserId = GUID_NULL;
        g_uidNewUserId = GUID_NULL;
        g_fNotifyComplete = TRUE;
    }
    
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;
}

STDMETHODIMP CUserIdentityManager::ClearChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    RegDeleteValue(hKeyIdentities, c_szChanging);
    RegDeleteValue(hKeyIdentities, c_szIncomingID);
    RegDeleteValue(hKeyIdentities, c_szOutgoingID);    

    hr = S_OK;
    
exit:
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;

}

STDMETHODIMP CUserIdentityManager::Logon(HWND hwndParent, DWORD dwFlags, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT     hr = E_FAIL;
    USERINFO    rUser;
    GUID        uidUserID, uidNewUserID;
    BOOL        fGotUser;
    TCHAR       szOldUsername[CCH_USERNAME_MAX_LENGTH+1], szLogoffName[CCH_USERNAME_MAX_LENGTH+1];
    TCHAR       szRes[MAX_PATH];

    // if identities are disabled, always return the default identity.
    // if they are forcing the UI, return an error, otherwise succeed and 
    // send the message back that identities are disabled.
    if (MU_IdentitiesDisabled())
    {
        if (!!(dwFlags & UIL_FORCE_UI))
            return E_IDENTITIES_DISABLED;

        hr = GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, ppIdentity);
        
        return (SUCCEEDED(hr) ? S_IDENTITIES_DISABLED : hr);
    }

    if (!g_hMutex)
        return E_UNEXPECTED;

    _LoadChangingIdentities();

    if (g_uidOldUserId != GUID_NULL || g_uidNewUserId != GUID_NULL)
    {
        // we are in the middle of a switch
        if (!g_fNotifyComplete)
        {
            // and we are not done checking to see if a switch is ok.
            if (!!(dwFlags & UIL_FORCE_UI))    //if its a force ui, then just fail.
                return E_IDENTITY_CHANGING;    

            //otherwise, we need to do something here, but since they could be
            //calling Login from the notifier proc, this could create a deadlock,
            //but returning either the old or the new could be wrong.  Return the
            //same error here unless we can come up with a better solution.
            return E_IDENTITY_CHANGING;
        }
    }

    DWORD dwWaitResult;
    dwWaitResult = WaitForSingleObject(g_hMutex, 5000); 
    g_fReleasedMutex = false;
    if (dwWaitResult == WAIT_TIMEOUT)
    {
        char    szMsg[255], szTitle[63];

        // someone else seems to have a login dialog up.  Notify the user
        // about this problem and bail.
        if (!!(dwFlags & UIL_FORCE_UI))
        {
            MLLoadStringA(idsSwitchInProgressSwitch, szMsg, ARRAYSIZE(szMsg));
            MLLoadStringA(idsSwitchIdentities, szTitle, ARRAYSIZE(szTitle));
        }
        else
        {
            MLLoadStringA(idsSwitchInProgressLaunch, szMsg, ARRAYSIZE(szMsg));
            MLLoadStringA(idsIdentityLogin, szTitle, ARRAYSIZE(szTitle));
        }

        MessageBox(hwndParent, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

        return E_UNEXPECTED;
    }

    *ppIdentity = NULL;
    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
    {
        *rUser.szUsername = 0;
        ZeroMemory(&rUser.uidUserID, sizeof(GUID));
    }
    lstrcpy(szOldUsername, rUser.szUsername);

    // if we don't have to do the UI and there is a current 
    // user, then just return that identity
    if (!(dwFlags & UIL_FORCE_UI) && fGotUser)
    {
        pIdentity = new CUserIdentity;
        
        if (!pIdentity)
            hr = E_OUTOFMEMORY;

        if (pIdentity && SUCCEEDED(hr = pIdentity->InitFromUsername(rUser.szUsername)))
            *ppIdentity = pIdentity;
    }
    else
    {
        if (0 == *rUser.szUsername)
        {
            GUID    uidStart;

            MU_GetLoginOption(&uidStart);
            if (GUID_NULL != uidStart)
            {
                MU_GetUserInfo(&uidStart, &rUser);
                rUser.uidUserID = GUID_NULL;
        
            }
        }

        if (MU_Login(hwndParent, dwFlags, rUser.szUsername))
        {
            MLLoadStringA(idsLogoff, szLogoffName, sizeof(szLogoffName));
            if (lstrcmp(szLogoffName, rUser.szUsername) == 0)
            {
                MLLoadStringA(idsConfirmLogoff, szRes, sizeof(szRes));

                if (MessageBox(hwndParent, szRes, szLogoffName, MB_YESNO) == IDYES)
                {
                    ReleaseMutex(g_hMutex);
                    g_fReleasedMutex = true;
                    Logoff(hwndParent);
                }
            }
            else
            {
                pIdentity = new CUserIdentity;
                if (pIdentity)
                {
                    hr = pIdentity->InitFromUsername(rUser.szUsername);

                    if (SUCCEEDED(hr))
                    {
                        pIdentity->GetCookie(&uidNewUserID);

                        hr = _SwitchToUser(&rUser.uidUserID, &uidNewUserID);
                        *ppIdentity = pIdentity;
                    }

                    if (FAILED(hr))
                    {
                        UINT    iMsgId = idsSwitchCancelled;

                        pIdentity->Release();
                        *ppIdentity = NULL;

                        SetForegroundWindow(hwndParent);
                    
                        // could switch on some error codes to set iMsgId to 
                        // other error messages.  For now, skip showing the
                        // message if a user did the cancelling
                        if (hr != E_USER_CANCELLED)
                            MU_ShowErrorMessage(hwndParent, iMsgId, idsSwitchCancelCaption);
                    }
                }
            }
        }
        else
            hr = E_USER_CANCELLED;
    }

    if (!g_fReleasedMutex)
        ReleaseMutex(g_hMutex);

    return hr;
}


STDMETHODIMP CUserIdentityManager::Logoff(HWND hwndParent)
{
    GUID        uidToID = GUID_NULL;
    HRESULT     hr;
    USERINFO    rUser;
    BOOL        fGotUser;

    if (!g_hMutex)
        return E_UNEXPECTED;

    DWORD dwWaitResult;
    dwWaitResult = WaitForSingleObject(g_hMutex, INFINITE);  
    
    if (dwWaitResult != WAIT_OBJECT_0)
        return E_UNEXPECTED;

    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
        rUser.uidUserID = GUID_NULL;

    // switch to the null user
    hr = _SwitchToUser(&rUser.uidUserID, &uidToID);

    if (FAILED(hr))
    {
        UINT    iMsgId = idsLogoutCancelled;

        SetForegroundWindow(hwndParent);
        
        // could switch on some error codes to set iMsgId to 
        // other error messages.  For now, skip showing the
        // message if a user did the cancelling
        if (hr != E_USER_CANCELLED)
            MU_ShowErrorMessage(hwndParent, iMsgId, idsSwitchCancelCaption);
    }

    ReleaseMutex(g_hMutex);

    return hr;
}

STDMETHODIMP CUserIdentityManager::_SwitchToUser(GUID *puidFromUser, GUID *puidToUser)
{
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1] = "";
    HRESULT hr;

    // switching to the same user is automatically OK.
    if (*puidFromUser == *puidToUser)
        return S_OK;

    // Set up the from and to users
    g_uidOldUserId = *puidFromUser;
    g_uidNewUserId = *puidToUser;
    g_fNotifyComplete = FALSE;
    _PersistChangingIdentities();
    if (*puidToUser != GUID_NULL)
        MU_UserIdToUsername(puidToUser, szUsername, CCH_USERNAME_MAX_LENGTH);
        
    // Notify window's that a switch is coming
    if (SUCCEEDED(hr = _QueryProcessesCanSwitch()))
    {
        if (SUCCEEDED(hr = MU_SwitchToUser(szUsername)))
        {
            if (!g_fReleasedMutex)
            {
                g_fReleasedMutex = true;
                g_fNotifyComplete = true;
                ReleaseMutex(g_hMutex);
            }
            _NotifyIdentitiesSwitched();
        }
    }
    g_fNotifyComplete = TRUE;

    // clear these back out again
    g_uidOldUserId = GUID_NULL;
    g_uidNewUserId = GUID_NULL;
    ClearChangingIdentities();

    return hr;
}

STDMETHODIMP CUserIdentityManager::GetIdentityByCookie(GUID *uidCookie, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT hr = E_IDENTITY_NOT_FOUND;
    GUID        uidUserCookie = *uidCookie;

    *ppIdentity = NULL;

    if (MU_IdentitiesDisabled())
    {
        // if disabled, they can only get the default identity. 
        // if asking for the current, they will get the defalt.
        // if asking for default by the constant or the default's guid, then succeed.
        // otherwise return an error.
        if (!MU_GetDefaultUserID(&uidUserCookie))
            return E_IDENTITY_NOT_FOUND;
        
        if (UID_GIBC_CURRENT_USER == uidUserCookie)
            uidUserCookie = UID_GIBC_DEFAULT_USER;

        if (!(uidUserCookie == uidUserCookie || UID_GIBC_DEFAULT_USER == uidUserCookie))
            return E_IDENTITIES_DISABLED;
    }


    if (uidUserCookie  == UID_GIBC_DEFAULT_USER)
    {
        if (!MU_GetDefaultUserID(&uidUserCookie))
            return E_IDENTITY_NOT_FOUND;
    }
    else if (uidUserCookie  == UID_GIBC_CURRENT_USER)
    {
        if (!MU_GetCurrentUserID(&uidUserCookie))
            return E_NO_CURRENT_IDENTITY;
    }
    else if (uidUserCookie  == UID_GIBC_OUTGOING_USER)
    {
        _LoadChangingIdentities();
        if (g_uidOldUserId == GUID_NULL)
            return E_IDENTITY_NOT_FOUND;
        else
            uidUserCookie = g_uidOldUserId;
    }
    else if (uidUserCookie  == UID_GIBC_INCOMING_USER)
    {
        _LoadChangingIdentities();
        if (g_uidNewUserId == GUID_NULL)
            return E_IDENTITY_NOT_FOUND;
        else
            uidUserCookie = g_uidNewUserId;
    }

    pIdentity = new CUserIdentity;
    if (pIdentity)
    {
        hr = pIdentity->InitFromCookie(&uidUserCookie);

        if (SUCCEEDED(hr))
            *ppIdentity = pIdentity;
        else
        {
            // Cleanup
            delete pIdentity;
        }
    }

    return hr;
}

STDMETHODIMP CUserIdentityManager::GetConnectionInterface(IID *pIID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    HRESULT hr;
    EnterCriticalSection(&m_rCritSect);

    AddRef();

    if (!m_pAdviseRegistry)
        m_pAdviseRegistry = new CNotifierList;
    Assert(m_pAdviseRegistry);

    if (m_pAdviseRegistry)
    {
        if (!m_fWndRegistered)
            _CreateWindowClass();

        hr = m_pAdviseRegistry->Add(pUnkSink, pdwCookie);
    }
    else
        hr = E_OUTOFMEMORY;

    LeaveCriticalSection(&m_rCritSect);    
    return hr;
}

STDMETHODIMP CUserIdentityManager::Unadvise(DWORD dwCookie)
{
    HRESULT hr;

    EnterCriticalSection(&m_rCritSect);
    if (m_pAdviseRegistry)
    {
        hr = m_pAdviseRegistry->RemoveCookie(dwCookie);
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_rCritSect);    

    Release();
    
    return hr;
}
        
STDMETHODIMP CUserIdentityManager::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::QuerySwitchIdentities()
{
    HRESULT    hr = S_OK;
    DWORD    dwLength, dwIndex;

    if (!m_pAdviseRegistry)
        return S_OK;

    TraceCall("Identity - CUserIdentityManager::QuerySwitchIdentities");

    dwLength = m_pAdviseRegistry->GetLength();

    for (dwIndex = 0; dwIndex < dwLength; dwIndex++)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;
        if (SUCCEEDED(m_pAdviseRegistry->GetAtIndex(dwIndex, &punk)) && punk)
        {
            if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
            {
                if (FAILED(hr = pICNotify->QuerySwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
                pICNotify->Release();
            }
            punk->Release();
        }
    }
exit:
    return hr;
}

STDMETHODIMP CUserIdentityManager::NotifySwitchIdentities()
{
    HRESULT    hr = S_OK;
    DWORD    dwLength, dwIndex;

    if (!m_pAdviseRegistry)
        return S_OK;

    TraceCall("Identity - CUserIdentityManager::NotifySwitchIdentities");

    dwLength = m_pAdviseRegistry->GetLength();

    for (dwIndex = 0; dwIndex < dwLength; dwIndex++)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;
        if (SUCCEEDED(m_pAdviseRegistry->GetAtIndex(dwIndex, &punk)) && punk)
        {
            if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
            {
                if (FAILED(hr = pICNotify->SwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
                pICNotify->Release();
            }
            punk->Release();
        }
    }
exit:
    return hr;
}

STDMETHODIMP CUserIdentityManager::_QueryProcessesCanSwitch()
{
    HWND    hWnd, hNextWnd = NULL;
    LRESULT lResult;
    HWND   *prghwnd = NULL;
    DWORD   chwnd = 0, cAllocHwnd = 0, dw;
    HRESULT hr;

    TraceCall("Identity - CUserIdentityManager::_QueryProcessesCanSwitch");

    cAllocHwnd = 10;
    if (!MemAlloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
        return E_OUTOFMEMORY;

    hWnd = GetTopWindow(NULL);
    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        if (!IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName(hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, c_szNotifyWindowClass) == 0)
            {
                if (chwnd == cAllocHwnd)
                {
                    cAllocHwnd += 10;
                    if (!MemRealloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                }
                prghwnd[chwnd++] = hWnd;
            }
        }

        hWnd = hNextWnd;
    }
    
    hr = S_OK;
    for (dw = 0; dw < chwnd; dw++)
    {
        if (IsWindow(prghwnd[dw]))
        {
            lResult = SendMessage(prghwnd[dw], WM_QUERY_IDENTITY_CHANGE, 0, 0);
            if (FAILED((HRESULT)lResult))
            {
                hr = (HRESULT)lResult;
                goto exit;
            }
        }
    }
exit:
    MemFree(prghwnd);
    prghwnd = NULL;
    return hr;
}

STDMETHODIMP CUserIdentityManager::_NotifyIdentitiesSwitched()
{
    HWND    hWnd, hNextWnd = NULL;
    LRESULT lResult;
    HWND   *prghwnd = NULL;
    DWORD   chwnd = 0, cAllocHwnd = 0, dw;

    TraceCall("Identity - CUserIdentityManager::_NotifyIdentitiesSwitched");

    cAllocHwnd = 10;
    if (!MemAlloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
        return E_OUTOFMEMORY;

    hWnd = GetTopWindow(NULL);
    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        if (!IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName(hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, c_szNotifyWindowClass) == 0)
            {
                if (chwnd == cAllocHwnd)
                {
                    cAllocHwnd += 10;
                    if (!MemRealloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
                        goto exit;
                }
                prghwnd[chwnd++] = hWnd;
            }
        }

        hWnd = hNextWnd;
    }
    
    for (dw = 0; dw < chwnd; dw++)
    {
        DWORD_PTR dwResult;
        if (IsWindow(prghwnd[dw]))
//            lResult = PostMessage(prghwnd[dw], WM_IDENTITY_CHANGED, 0, 0);    //Raid 48054
            SendMessageTimeout(prghwnd[dw], WM_IDENTITY_CHANGED, 0, 0, SMTO_ABORTIFHUNG | SMTO_NORMAL, 1500, &dwResult);
    }
exit:
    MemFree(prghwnd);
    prghwnd = NULL;
    return S_OK;
}

STDMETHODIMP CUserIdentityManager::_CreateWindowClass()
{
    WNDCLASS wc;    
        
    if (!m_fWndRegistered)            /*set up window class and register it */
    {
        wc.lpszClassName    = c_szNotifyWindowClass;
        wc.hInstance        = g_hInst;
        wc.lpfnWndProc      = CUserIdentityManager::WndProc;
        wc.hCursor          = NULL;
        wc.hIcon            = NULL;
        wc.lpszMenuName     = NULL;
        wc.hbrBackground    = NULL;
        wc.style            = CS_DBLCLKS;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;

        if (!RegisterClassA(&wc))
            return E_FAIL;

        m_fWndRegistered = TRUE;
    }

    return S_OK;
}


LRESULT CALLBACK CUserIdentityManager::WndProc(HWND hWnd, UINT messg, WPARAM wParam, LPARAM lParam)
{
    CNotifierList *pList = NULL;
    HRESULT  hr;

    if (messg == WM_QUERY_IDENTITY_CHANGE ||
        messg == WM_IDENTITY_CHANGED ||
        messg == WM_IDENTITY_INFO_CHANGED)
    {
#if defined(DEBUG)
        DebugStrf("Identity - CUserIdentityManager::WndProc() called for notification.\r\n");
#endif
        pList = (CNotifierList *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        if (pList)
        {
            hr = pList->SendNotification(messg, (DWORD)lParam);
            return hr;
        }
    }
    else
    {
        switch(messg)
        {
            case WM_CREATE:
                LPCREATESTRUCT  pcs;

                pcs = (LPCREATESTRUCT)lParam;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LRESULT)pcs->lpCreateParams);
                return(DefWindowProc(hWnd, messg, wParam, lParam));
                break;
/*
            case WM_QUERY_IDENTITY_CHANGE:
            case WM_IDENTITY_CHANGED:
            case WM_IDENTITY_INFO_CHANGED:
                DebugStrf("Identity - CUserIdentityManager::WndProc() called for notification.\r\n");
                pList = (CNotifierList *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
                if (pList)
                {
                    hr = pList->SendNotification(messg, (DWORD)lParam);
                    return hr;
                }
                break;
*/
            case WM_CLOSE:
                SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
                return(DefWindowProc(hWnd, messg, wParam, lParam));
                break;

            default:
                return(DefWindowProc(hWnd, messg, wParam, lParam));
 
        }
    }
    return 0;
}

//----------------------------------------------------------------------------
//  Logon the specified user.
//  - Checks password
//----------------------------------------------------------------------------
STDMETHODIMP CUserIdentityManager::LogonAs(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT     hr = E_FAIL;
    USERINFO    rUser;
    GUID        uidNewUserID;
    BOOL        fGotUser;
    TCHAR       szName[CCH_USERNAME_MAX_LENGTH+1];

    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szName, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
    {
        return E_FAIL;
    }

    // if identities are disabled, always return the default identity.
    if (MU_IdentitiesDisabled())
    {
        hr = GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, ppIdentity);
        
        return (SUCCEEDED(hr) ? S_IDENTITIES_DISABLED : hr);
    }

    if (!g_hMutex)
        return E_UNEXPECTED;

    if (g_uidOldUserId != GUID_NULL || g_uidOldUserId != GUID_NULL)
    {
        // we are in the middle of a switch
        if (!g_fNotifyComplete)
        {
            return E_IDENTITY_CHANGING;
        }
    }

    *ppIdentity = NULL;

    //
    // Grab info on the current user
    //
    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
    {
        *rUser.szUsername = 0;
        ZeroMemory(&rUser.uidUserID, sizeof(GUID));
    }

    if (0 == *rUser.szUsername)
    {
        GUID uidStart;

        MU_GetLoginOption(&uidStart);
        if (GUID_NULL != uidStart)
        {
            MU_GetUserInfo(&uidStart, &rUser);
            rUser.uidUserID = GUID_NULL;
    
        }
    }

    pIdentity = new CUserIdentity;
    if (pIdentity)
    {
        hr = pIdentity->InitFromUsername(szName);
        if (SUCCEEDED(hr))
        {
            pIdentity->GetCookie(&uidNewUserID);
            hr= ConfirmPassword(&uidNewUserID, pszPassword);
            if (SUCCEEDED(hr))
            {
                hr = _SwitchToUser(&rUser.uidUserID, &uidNewUserID);

                if (SUCCEEDED(hr))
                {
                    *ppIdentity = pIdentity;
                }
                else
                {
                    UINT iMsgId = idsSwitchCancelled;

                    pIdentity->Release();
                    *ppIdentity = NULL;

                    // could switch on some error codes to set iMsgId to 
                    // other error messages.  For now, skip showing the
                    // message if a user did the cancelling
                    if (hr != E_USER_CANCELLED)
                        MU_ShowErrorMessage(NULL, iMsgId, idsSwitchCancelCaption);
                }
            } // ConfirmPassword()
        } // InitFromUsername()
    }

    if (!g_fReleasedMutex)
        ReleaseMutex(g_hMutex);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\factory.h ===
#ifndef _factory_h
#define _factory_h

typedef HRESULT (* CREATEPROC)(IUnknown *, IUnknown **);

#define FD_ALLOWAGGREGATION     0x00000001

struct CFactoryData
{
    CLSID const *m_pClsid;
    CREATEPROC  m_pCreateProc;
    DWORD       m_dwFlags;
};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(const CFactoryData *pFactoryData);
    ~CClassFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP         LockServer(BOOL fLock);

private:
    ULONG               m_cRef;
    const CFactoryData  *m_pFactoryData;
};

#endif // _factory_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\idenum.cpp ===
//
// ident.cpp - implementation of CIdentity class
//
#include "private.h"
#include "strconst.h"
#include "multiusr.h"
//
// Constructor / destructor
//
CEnumUserIdentity::CEnumUserIdentity()
{
    m_cRef = 1;
    m_dwCurrentUser = 0;
    m_cCountUsers = 0;
    m_rguidUsers = NULL;
    m_fInited = FALSE;

    DllAddRef();
}


CEnumUserIdentity::~CEnumUserIdentity()
{   
    _Cleanup();

    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CEnumUserIdentity::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if(IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if(IID_IEnumUserIdentity == riid)
    {
        *ppv = (IEnumUserIdentity *)this;
    }

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumUserIdentity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumUserIdentity::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


// 
// IEnumUserIdentity members
//
STDMETHODIMP CEnumUserIdentity::Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched)
{
	ULONG celtFetched = 0;
	HRESULT hr = ResultFromScode(S_OK);
    CUserIdentity   *pIdentity;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    while (celt) 
    {
        if (m_dwCurrentUser == m_cCountUsers) {
            hr = ResultFromScode(S_FALSE);
            break;
        }

        pIdentity = new CUserIdentity;
        if (pIdentity)
        {
            if (SUCCEEDED(pIdentity->InitFromCookie(&m_rguidUsers[m_dwCurrentUser])))
            {
                rgelt[celtFetched++] = pIdentity;
                m_dwCurrentUser++;
            }
            else
            {
                pIdentity->Release();
                hr = ResultFromScode(E_OUTOFMEMORY);
                break;
            }
        }
        else
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            break;
        }
        celt--;
    }

    if (FAILED(hr))
    {
        for (ULONG i = 0; i < celtFetched; i++)
            rgelt[i]->Release();
        celtFetched = 0;
    }

	if (pceltFetched != NULL)
		*pceltFetched = celtFetched;

	return hr;
}

STDMETHODIMP CEnumUserIdentity::Skip(ULONG celt)
{
    SCODE sc;
    HRESULT hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

	if (m_dwCurrentUser + celt > m_cCountUsers) {
		m_dwCurrentUser = m_cCountUsers;
		sc = S_FALSE;
	}
	else {
		m_dwCurrentUser += celt;
		sc = S_OK;
	}

	return ResultFromScode(sc);
}

STDMETHODIMP CEnumUserIdentity::Reset(void)
{
    m_dwCurrentUser = 0;
    _Cleanup();
    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::Clone(IEnumUserIdentity **ppenum)
{
    CEnumUserIdentity   *pEnum;
    HRESULT             hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    pEnum = new CEnumUserIdentity;

    if (pEnum)
    {
        hr = pEnum->_Init(m_dwCurrentUser, m_cCountUsers, m_rguidUsers);

        if (SUCCEEDED(hr))
            *ppenum = pEnum;
        else
            delete pEnum;
    }

    return hr;
}

STDMETHODIMP CEnumUserIdentity::GetCount(ULONG *pnCount)
{
    HRESULT hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    *pnCount = m_cCountUsers;

    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::_Cleanup()
{
    MemFree(m_rguidUsers);
    m_rguidUsers = NULL;
    m_cCountUsers = 0;
    m_fInited = FALSE;

    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::_Init()
{
    HRESULT hr=S_OK;
    HKEY    hReg = NULL;
    DWORD   cUsers = 0;
    DWORD   cbMaxSubKeyLen;
    DWORD   cb;
    DWORD   dwEnumIndex = 0;
    BOOL    fDisabled = MU_IdentitiesDisabled();

    m_cCountUsers = 0;

    // Open or Create root server key
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Enumerate keys
    if (RegQueryInfoKey(hReg, NULL, NULL, 0, &cUsers, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL,
                        NULL, NULL) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }


    // No users ?
    if (cUsers == 0)
        goto done;

    if (fDisabled)
        cUsers = 1;

    // Allocate the users array
    MemAlloc((LPVOID *)&m_rguidUsers, sizeof(GUID) * cUsers);
    
    if (!m_rguidUsers)
    {
        cUsers = 0;
        goto done;
    }

    // Zero init
    ZeroMemory(m_rguidUsers, sizeof(GUID) * cUsers);

    if (fDisabled)
    {
        MU_GetDefaultUserID(&m_rguidUsers[0]);
        goto done;
    }

    while (TRUE) 
    {
        HKEY    hkUserKey;
        DWORD   dwStatus, dwSize, dwType;
        TCHAR   szKeyNameBuffer[MAX_PATH];
        TCHAR   szUid[255];

        if (RegEnumKey(hReg, dwEnumIndex++, szKeyNameBuffer,MAX_PATH)
            !=  ERROR_SUCCESS)
            break;
        
        if (RegOpenKey(hReg, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szUid);
            dwStatus = RegQueryValueEx(hkUserKey, c_szUserID, NULL, &dwType, (LPBYTE)szUid, &dwSize);
            Assert(ERROR_SUCCESS == dwStatus);

            if (ERROR_SUCCESS == dwStatus)
                GUIDFromAString(szUid, &m_rguidUsers[dwEnumIndex - 1]);

            RegCloseKey(hkUserKey); 
        }
        else
            AssertSz(FALSE, "Couldn't open user's key");
    }

done:
    m_cCountUsers = cUsers;
    m_fInited = TRUE;

exit:
    if (hReg)
        RegCloseKey(hReg);

    return hr;
}


STDMETHODIMP CEnumUserIdentity::_Init(DWORD dwCurrentUser, DWORD dwCountUsers, GUID *prgUserCookies)
{
    m_dwCurrentUser = dwCurrentUser;
    m_cCountUsers = dwCountUsers;

    // Allocate the users array
    MemAlloc((LPVOID *)&m_rguidUsers, sizeof(GUID) * dwCountUsers);
    
    if (!m_rguidUsers)
        return E_OUTOFMEMORY;

    CopyMemory(m_rguidUsers, prgUserCookies, sizeof(GUID) * dwCountUsers);

    m_fInited = TRUE;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? TRUE : NULL!=(_hinst = LoadLibrary(TEXT(#_dll))))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        ASSERT_MSGA(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- PSTOREC.DLL ---------------
HINSTANCE g_hinstPSTOREC = NULL;

DELAY_LOAD_ERR(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore ** ppProvider, PST_PROVIDERID *pProviderID, void *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL);

void UnloadPStore()
{
    if (g_hinstPSTOREC)
        FreeLibrary(g_hinstPSTOREC);
    g_hinstPSTOREC = NULL;
}

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\ident.cpp ===
//
// ident.cpp - implementation of CUserIdentity class
//
#include "private.h"
#include "shlwapi.h"
#include "multiusr.h"
#include "strconst.h"
#include "multiutl.h"
#include <shfolder.h>

//
// Constructor / destructor
//
CUserIdentity::CUserIdentity()
    : m_cRef(1),
      m_fSaved(FALSE),
      m_fUsePassword(0)
{
    m_szUsername[0] = 0;
    m_szPassword[0] = 0;
    ZeroMemory(&m_uidCookie, sizeof(GUID));

    DllAddRef();
}


CUserIdentity::~CUserIdentity()
{
    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CUserIdentity::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if(IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if ((IID_IUserIdentity == riid)
             || (IID_IUserIdentity2 == riid))
    {
        *ppv = (IUserIdentity2 *)this;
    }

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUserIdentity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CUserIdentity::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


// 
// IUserIdentity members
//
STDMETHODIMP CUserIdentity::GetCookie(GUID *puidCookie)
{
    if (!m_fSaved)
        return E_INVALIDARG;

    *puidCookie = m_uidCookie;
    return S_OK;

}

STDMETHODIMP CUserIdentity::OpenIdentityRegKey(DWORD dwDesiredAccess, HKEY *phKey)
{
    TCHAR    szRootPath[MAX_PATH];
    HRESULT  hr = S_OK;

    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    MU_GetRegRootForUserID(&m_uidCookie, szRootPath);

    hr = RegCreateKey(HKEY_CURRENT_USER, szRootPath, phKey);
    RegCloseKey(*phKey);

    hr = RegOpenKeyEx(HKEY_CURRENT_USER, szRootPath, 0, dwDesiredAccess, phKey);
    return (hr == ERROR_SUCCESS ? S_OK : E_FAIL);
}


STDMETHODIMP CUserIdentity::GetIdentityFolder(DWORD dwFlags, WCHAR *pszPath, ULONG ulBuffSize)
{
    WCHAR    szwRootPath[MAX_PATH];
    HRESULT hr;

    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    hr = MU_GetUserDirectoryRoot(&m_uidCookie, dwFlags, szwRootPath, MAX_PATH);
    
    if (SUCCEEDED(hr))
    {
        StrCpyW(pszPath, szwRootPath);
    }

    return hr;
}



STDMETHODIMP CUserIdentity::GetName(WCHAR *pszName, ULONG ulBuffSize)
{
    if (!m_fSaved || ulBuffSize == 0)
        return E_IDENTITY_NOT_FOUND;

    if (MultiByteToWideChar(CP_ACP, 0, m_szUsername, -1, pszName, ulBuffSize) == 0)
        return GetLastError();
    
    return S_OK;
}

STDMETHODIMP CUserIdentity::SetName(WCHAR *pszName)
{
    TCHAR       szRegPath[MAX_PATH];
    HRESULT     hr = S_OK;
    HKEY        hKey;
    USERINFO    uiCurrent;
    LPARAM      lpNotify = IIC_CURRENT_IDENTITY_CHANGED;
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    
    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szUsername, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
    {
        return GetLastError();
    }

    //
    // Only perform change if the username doesn't already exist.
    //
    if (!MU_UsernameExists(szUsername) && strcmp(szUsername, m_szUsername) != 0)
    {
        strcpy( m_szUsername, szUsername );

        hr = _SaveUser();
    
        // if its not the current identity, then just broadcast that an identity changed
        if (MU_GetUserInfo(NULL, &uiCurrent) && (m_uidCookie != uiCurrent.uidUserID))
        {
            lpNotify = IIC_IDENTITY_CHANGED;
        }

        // tell apps that the user's name changed
        if (SUCCEEDED(hr))
        {
            PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, lpNotify);
        }
    }
    else
    {
        hr = E_IDENTITY_EXISTS;
    }

    return hr;
}

STDMETHODIMP CUserIdentity::SetPassword(WCHAR *pszPassword)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR       szRegPath[MAX_PATH];
    HRESULT     hr = S_OK;
    HKEY        hKey;
    
    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    if (WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, m_szPassword, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
        return GetLastError();
    
    m_fUsePassword = (*m_szPassword != 0);

    hr = _SaveUser();

    return hr;
#else
    return E_NOTIMPL;
#endif
}


STDMETHODIMP CUserIdentity::_SaveUser()
{
    DWORD   dwType, dwSize, dwValue, dwStatus;
    HKEY    hkCurrUser;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szUid[255];
    HRESULT hr;

    if (*m_szUsername == 0)
        return E_INVALIDARG;

    if (!m_fUsePassword)
        m_szPassword[0] = 0;

    if (!m_fSaved)
        hr = _ClaimNextUserId(&m_uidCookie);

    Assert(m_uidCookie != GUID_NULL);
    Assert(SUCCEEDED(hr));

    //
    // Save our settings
    //
    USERINFO UserInfo;

    UserInfo.uidUserID= m_uidCookie;
    lstrcpy( UserInfo.szUsername, m_szUsername);
    UserInfo.fUsePassword= m_fUsePassword;
    UserInfo.fPasswordValid= m_fUsePassword;
    lstrcpy( UserInfo.szPassword, m_szPassword );
    
    BOOL bSuccess= MU_SetUserInfo(&UserInfo);

    if (bSuccess)
    {
        m_fSaved = TRUE;
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


STDMETHODIMP CUserIdentity::InitFromUsername(TCHAR *pszUsername)
{
    GUID   uidCookie;
    HRESULT hr;

    if(FAILED(hr = MU_UsernameToUserId(pszUsername, &uidCookie)))
        return hr;

    return InitFromCookie(&uidCookie);
}


STDMETHODIMP CUserIdentity::InitFromCookie(GUID *puidCookie)
{
    BOOL bSuccess;
    USERINFO UserInfo;
    HRESULT hrRet = E_FAIL;

    bSuccess = MU_GetUserInfo( puidCookie, &UserInfo );

    if (bSuccess)
    {
        m_fUsePassword = UserInfo.fUsePassword;
        lstrcpy( m_szUsername, UserInfo.szUsername );
        lstrcpy( m_szPassword, UserInfo.szPassword );
        m_uidCookie = UserInfo.uidUserID;
        m_fSaved = TRUE;
        hrRet = S_OK;
    }

    return hrRet;
}


STDMETHODIMP CUserIdentity::GetOrdinal(DWORD* pdwOrdinal)
{
    if (!pdwOrdinal)
    {
        return E_INVALIDARG;
    }

    HKEY    hSourceSubKey, hkUserKey;
    DWORD   dwSize, dwType;
    DWORD   dwIdentityOrdinal = 1, dwOrdinal = 0;
    TCHAR   szUid[MAX_PATH];
    HRESULT hr = E_FAIL;
    
    AStringFromGUID(&m_uidCookie,  szUid, MAX_PATH);
        
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        if (RegOpenKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                    hr = S_OK;
                }
                else
                {
                    AssertSz(FALSE, "Couldn't set the identity ordinal");
                }
            }
            else
            {
                hr = S_OK;
            }
            
            RegCloseKey(hkUserKey); 
        }
        else
        {
            AssertSz(FALSE, "Couldn't open user's Key");
        }
        
        RegCloseKey(hSourceSubKey);
    }
    else
    {
        AssertSz(FALSE, "Couldn't open user profiles root Key");
    }

    *pdwOrdinal = dwOrdinal;
    return hr;
}

//----------------------------------------------------------------------------
//  Changes password to newPass if oldPass matches the current password
//----------------------------------------------------------------------------
STDMETHODIMP CUserIdentity::ChangePassword(WCHAR *szOldPass, WCHAR *szNewPass)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szOldPwd[CCH_USERPASSWORD_MAX_LENGTH+1];
    
    if (!m_fSaved)
    {
        return E_IDENTITY_NOT_FOUND;
    }

    if (WideCharToMultiByte(CP_ACP, 0, szOldPass, -1, szOldPwd, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
    {
        return E_FAIL;
    }

    if (!m_fUsePassword || lstrcmp(szOldPwd, m_szPassword) == 0)
    {
        hr = SetPassword(szNewPass);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\mluisup.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString        MLLoadStringW
#define MLBuildResURLWrap   MLBuildResURLWrapW
#else
#define MLLoadString        MLLoadStringA
#define MLBuildResURLWrap   MLBuildResURLWrapA
#endif

#undef ML_ID_DIALOGCALLS
BOOL        _PathRemoveFileSpec(LPTSTR pFile);

void        MLLoadResources(HINSTANCE hinstParent, LPTSTR pszLocResDll);
void        MLFreeResources(HINSTANCE hinstParent);
int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);
HINSTANCE   MLGetHinst();
INT_PTR     MLDialogBoxWrap(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc);
INT_PTR     MLDialogBoxParamWrap(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND        MLCreateDialogParamWrap(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
BOOL        MLEndDialogWrap(HWND hDlg, INT_PTR nResult);
HWND        MLHtmlHelpWrap(HWND hwndCaller, LPCTSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage);
BOOL        MLWinHelpWrap(HWND hwndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD dwData);
HRESULT     MLBuildResURLWrapA(LPSTR    pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPSTR    pszResName,
                               LPSTR    pszResURL,
                               int      nBufSize,
                               LPSTR    pszParentDll);
HRESULT     MLBuildResURLWrapW(LPWSTR   pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPWSTR   pszResName,
                               LPWSTR   pszResURL,
                               int      nBufSize,
                               LPWSTR   pszParentDll);

HWND        SHHtmlHelpOnDemandWrap(HWND hwndCaller, LPCTSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
BOOL        SHWinHelpOnDemandWrap(HWND hwndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
// MLLoadLibrary is used for loading the various localized resource libraries
// Note: MLLoadLibrary is exported without a name, only an ordinal #
#ifndef UNICODE
#define szMLLoadLibrary 377  //TEXT("MLLoadLibraryA"); 
#else
#define szMLLoadLibrary 378  //TEXT("MLLoadLibraryW"); // for Unicode
#endif

#ifdef MLUI_INIT

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const char c_szShlwapiDll[] = "shlwapi.dll";


struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    ULONG       ulRefs;
    BOOL        fMLEnabled;
} g_mluiInfo = { NULL, 0 , FALSE };

static HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DWORD dwVerInfoSize, dwVerHnd;
    int iEnd;
    LPSTR lpInfo;
    HINSTANCE hInst = NULL;
    UINT uLen;
    VS_FIXEDFILEINFO *pinfo;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        if (GetModuleFileName(hinstShlwapi, szPath, ARRAYSIZE(szPath)))
        {
            if (dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd))
            {
                if (MemAlloc((void **)&lpInfo, dwVerInfoSize))
                {
                    if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, lpInfo))
                    {
                        if (VerQueryValue(lpInfo, "\\", (LPVOID *)&pinfo, &uLen) && 
                            uLen == sizeof(VS_FIXEDFILEINFO))
                        {
                            if (pinfo->dwProductVersionMS >= 0x00050000)
                            {
                                pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                                if (pfn != NULL)
                                    hInst = pfn(szDllName, hInstCaller, 0);
                            }
                        }
                    }
                
                    MemFree(lpInfo);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        _PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        lstrcpyn(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}

void
MLLoadResources(HINSTANCE hinstParent, LPTSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
        // find out whether ML is enabled or not
#ifdef MLUI_SUPPORT
        g_mluiInfo.fMLEnabled = TRUE;
#else
        g_mluiInfo.fMLEnabled = FALSE;
#endif

        if (g_mluiInfo.fMLEnabled)
        {
            g_mluiInfo.ulRefs++;
//            g_mluiInfo.hinstLocRes = lpfnMLLoadLibrary(pszLocResDll, hinstParent, ML_CROSSCODEPAGE);
            g_mluiInfo.hinstLocRes = LoadLangDll(hinstParent, pszLocResDll);
        }
        else
        {
            g_mluiInfo.hinstLocRes = hinstParent;
        }
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    g_mluiInfo.ulRefs--;

    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent &&
        g_mluiInfo.ulRefs == 0 )
    {
        FreeLibrary(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    return LoadStringW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
//    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

HINSTANCE
MLGetHinst()
{
    return g_mluiInfo.hinstLocRes;
}


INT_PTR
MLDialogBoxParamWrap(HINSTANCE hInstance,
                     LPCWSTR lpTemplateName,
                     HWND hwndParent,
                     DLGPROC lpDialogFunc,
                     LPARAM dwInitParam)
{
    INT_PTR nRet;

#ifdef ML_ID_DIALOGCALLS
    {
        nRet = MLDialogBoxParam(hInstance,
                               (LPWSTR)lpTemplateName,
                               hwndParent,
                               lpDialogFunc,
                               dwInitParam);
    }
#else
    {
        nRet = DialogBoxParamWrapW(hInstance,
                              lpTemplateName,
                              hwndParent,
                              lpDialogFunc,
                              dwInitParam);
    }
#endif
    return nRet;
}


BOOL
MLEndDialogWrap(HWND hDlg, INT_PTR nResult)
{
    BOOL    fRet;

#ifdef ML_ID_DIALOGCALLS
    {
        fRet = MLEndDialog(hDlg, nResult);
    }
#else
    {
        fRet = EndDialog(hDlg, nResult);
    }
#endif
    return fRet;
}

#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\msident.cpp ===
#include "private.h"
#include "multiusr.h"

UINT WM_IDENTITY_CHANGED;
UINT WM_QUERY_IDENTITY_CHANGE;
UINT WM_IDENTITY_INFO_CHANGED;

extern "C" int _fltused = 0;    // define this so that floats and doubles don't bring in the CRT

// Count number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

// DLL Instance handle
HINSTANCE   g_hInst=0;

// mutex for preventing logon re-entrancy
HANDLE      g_hMutex = NULL;

#define IDENTITY_LOGIN_VALUE    0x00098053
#define DEFINE_STRING_CONSTANTS
#include "StrConst.h"

#define MLUI_SUPPORT
#define MLUI_INIT
#include "mluisup.h"

BOOL    g_fNotifyComplete = TRUE;
GUID    g_uidOldUserId = {0x0};
GUID    g_uidNewUserId = {0x0};

TCHAR   szHKCUPolicyPath[] = "Software\\Microsoft\\Outlook Express\\Identities";

void FixMissingIdentityNames();
void UnloadPStore();
PSECURITY_DESCRIPTOR CreateSd(void);

// This is needed so we can link to libcmt.dll, because floating-point
// initialization code is required.
void __cdecl main()
{
}

#ifdef DISABIDENT
void DisableOnFirstRun(void)
{
    // disable identities in Whistler
  
    HKEY    hKey = NULL;
    DWORD   dwVal = 0;
    DWORD  dwType = 0;
    ULONG  cbData = sizeof(DWORD);
    OSVERSIONINFO OSInfo = {0};
    TCHAR   szPolicyPath[] = "Identities";
    TCHAR   szPolicyKey[] = "Locked Down";
    TCHAR   szFirstRun[] = "FirstRun";
    TCHAR   szRegisteredVersion[] = "RegisteredVersion";

    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSInfo);
    if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
    {
        if(!(((OSInfo.dwMajorVersion == 5) && (OSInfo.dwMinorVersion > 0)) || (OSInfo.dwMajorVersion > 5)))
            return;
    }
    else
        return; // No disabling on Win 9x and NT4

    // Check: first time run?
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szHKCUPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey, szRegisteredVersion, NULL, &dwType, (LPBYTE) &dwVal, &cbData);
        RegCloseKey(hKey);

        if(dwVal != OSInfo.dwBuildNumber)
            return; // already checked.
    }
    else
        return;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, szPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey, szFirstRun, NULL, &dwType, (LPBYTE) &dwVal, &cbData);
        if(dwVal != 1)

        {
            dwVal = 1;
            RegSetValueEx(hKey, szFirstRun, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        }
        else
        {
            RegCloseKey(hKey);
            return; // already checked.
        }
    }
    else 
        return;

    if(MU_CountUsers() < 2)
        RegSetValueEx(hKey, szPolicyKey, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);       

    RegCloseKey(hKey);
}
#endif // DISABIDENT

//////////////////////////////////////////////////////////////////////////
//
// DLL entry point
//
//////////////////////////////////////////////////////////////////////////
EXTERN_C BOOL WINAPI LibMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    WM_IDENTITY_CHANGED= RegisterWindowMessage("WM_IDENTITY_CHANGED");
    WM_QUERY_IDENTITY_CHANGE= RegisterWindowMessage("WM_QUERY_IDENTITY_CHANGE");
    WM_IDENTITY_INFO_CHANGED= RegisterWindowMessage("WM_IDENTITY_INFO_CHANGED");

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            // MessageBox(NULL, "Debug", "Debug", MB_OK);
            SHFusionInitializeFromModule(hInstance);
            MLLoadResources(hInstance, TEXT("msidntld.dll"));
            if (MLGetHinst() == NULL)
                return FALSE;

            if (g_hMutex == NULL)
            {
                SECURITY_ATTRIBUTES  sa;
                PSECURITY_DESCRIPTOR psd;

                psd = CreateSd();
                if (psd)
                {
                    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                    sa.lpSecurityDescriptor = psd;
                    sa.bInheritHandle = TRUE;

                    g_hMutex = CreateMutex(&sa, FALSE, "MSIdent Logon");

                    LocalFree(psd);
                }
                else
                    // in the worst case drop down to unshared object
                    g_hMutex = CreateMutex(NULL, FALSE, "MSIdent Logon");

                if (g_hMutex == NULL)  // Try to open mutex, if we cannot create mutex IE6 32769 
                    g_hMutex = OpenMutex(MUTEX_MODIFY_STATE, FALSE, "MSIdent Logon");


                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    GUID        uidStart;
                    USERINFO    uiLogin;

#ifdef DISABIDENT
                    DisableOnFirstRun();
#endif // DISABIDENT
                    // in case something got stuck in a switch, wipe it out here.
                    CUserIdentityManager::ClearChangingIdentities();                         

                    FixMissingIdentityNames();
                    // we are the first instance to come up.
                    // may need to reset the last user.....
                    if (GetProp(GetDesktopWindow(),"IDENTITY_LOGIN") != (HANDLE)IDENTITY_LOGIN_VALUE)
                    {
                        _MigratePasswords();
                        MU_GetLoginOption(&uidStart);

                        // if there is a password on this identity, we can't auto start as them
                        if (uidStart != GUID_NULL && MU_GetUserInfo(&uidStart, &uiLogin) && (uiLogin.fUsePassword || !uiLogin.fPasswordValid))
                        {
                            uidStart = GUID_NULL;
                        }

                        if (uidStart == GUID_NULL)
                        {
                            MU_SwitchToUser("");
                            SetProp(GetDesktopWindow(),"IDENTITY_LOGIN", (HANDLE)IDENTITY_LOGIN_VALUE);
                        }
                        else
                        {
                            if(MU_GetUserInfo(&uidStart, &uiLogin))
                                MU_SwitchToUser(uiLogin.szUsername);
                            else
                                MU_SwitchToUser("");
                        }
                        SetProp(GetDesktopWindow(),"IDENTITY_LOGIN", (HANDLE)IDENTITY_LOGIN_VALUE);
                    }
                }
            }
            DisableThreadLibraryCalls(hInstance);
            g_hInst = hInstance;

            break;

        case DLL_PROCESS_DETACH:
            MLFreeResources(hInstance);
            UnloadPStore();
            CloseHandle(g_hMutex);
            g_hMutex = NULL;
            SHFusionUninitialize();
            break;
    }

    return TRUE;
} 

//////////////////////////////////////////////////////////////////////////
//
// Standard OLE entry points
//
//////////////////////////////////////////////////////////////////////////

//  Class factory -
//  For classes with no special needs these macros should take care of it.
//  If your class needs some special stuff just to get the ball rolling,
//  implement your own CreateInstance method.  (ala, CConnectionAgent)

#define DEFINE_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    *ppunk = (iface *)new cls; \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

#define DEFINE_AGGREGATED_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    *ppunk = (iface *)new cls(punkOuter); \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

DEFINE_CREATEINSTANCE(CUserIdentityManager, IUserIdentityManager)

const CFactoryData g_FactoryData[] = 
{
 {   &CLSID_UserIdentityManager,        CUserIdentityManager_CreateInstance,    0 }
};

HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;

    *ppv = NULL;

    MU_Init();

    // Validate request
    for (int i = 0; i < ARRAYSIZE(g_FactoryData); i++)
    {
        if (rclsid == *g_FactoryData[i].m_pClsid)
        {
            punk = new CClassFactory(&g_FactoryData[i]);
            break;
        }
    }

    if (ARRAYSIZE(g_FactoryData) <= i)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }
    else if (NULL == punk)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    } 


    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    // check objects and locks
    return (0L == DllGetRef() && 0L == DllGetLock()) ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    char        szDll[MAX_PATH];
    int         cch;
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            // Get our location
            GetModuleFileName(g_hInst, szDll, sizeof(szDll));

            // Setup special registration stuff
            // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
            stReg.cEntries = 0;
            seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
            seReg[stReg.cEntries].pszValue = szDll;
            stReg.cEntries++;    
            stReg.pse = seReg;

            hr = pfnri(g_hInst, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

    STDAPI DllRegisterServer(void)
{
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    HKEY    hKey = NULL;
    DWORD   dwVal = 1;
    ULONG  cbData = sizeof(DWORD);
    OSVERSIONINFO OSInfo = {0};
    TCHAR   szPolicyPath[] = "Identities";
    TCHAR   szRegisteredVersion[] = "RegisteredVersion";
    TCHAR   szPolPath[] = "Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Identities";
    TCHAR   szPolicyKey[] = "Locked Down";

    CallRegInstall("Reg");
    if (hinstAdvPack)
    {
        FreeLibrary(hinstAdvPack);
    }
#ifdef DISABIDENT
    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSInfo);

    if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
    {
        if(!(((OSInfo.dwMajorVersion == 5) && (OSInfo.dwMinorVersion > 0)) || (OSInfo.dwMajorVersion > 5)))
            return NOERROR;
    }
    else
        return NOERROR; // No disable for Win9x

    // Set registration value
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szHKCUPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        dwVal = OSInfo.dwBuildNumber;
        RegSetValueEx(hKey, szRegisteredVersion, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
#endif // DISABIDENT

    // DISABLING identities in Win64
#ifdef _WIN64
    // Set registration value
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPolPath, 0, NULL, 0, 
                    KEY_WOW64_32KEY | KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegSetValueEx(hKey, szPolicyKey, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
    }
#endif // _WIN64
    return NOERROR;
}

STDAPI
DllUnregisterServer(void)
{
    return NOERROR;
}

PSECURITY_DESCRIPTOR CreateSd(void)
{
    PSID                     AuthenticatedUsers = NULL;
    PSID                     BuiltInAdministrators = NULL;
    PSID                     PowerUsers = NULL;
    PSECURITY_DESCRIPTOR     RetVal = NULL;
    PSECURITY_DESCRIPTOR     Sd = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG                    AclSize;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  &BuiltInAdministrators))
        goto ErrorExit;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_POWER_USERS,
                                  0,0,0,0,0,0,
                                  &PowerUsers))
        goto ErrorExit;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,            // 1 sub-authority
                                  SECURITY_AUTHENTICATED_USER_RID,
                                  0,0,0,0,0,0,0,
                                  &AuthenticatedUsers))
        goto ErrorExit;

    // 
    // Calculate the size of and allocate a buffer for the DACL, we need
    // this value independently of the total alloc size for ACL init.
    //
    // "- sizeof (ULONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.
    //

    AclSize = sizeof (ACL) +
        (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators) +
        GetLengthSid(PowerUsers);

    Sd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

    if (Sd)
    {
        ACL *Acl;

        Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (!InitializeAcl(Acl,
                           AclSize,
                           ACL_REVISION)) {

            // Error

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        SYNCHRONIZE | MUTEX_MODIFY_STATE,
                                        AuthenticatedUsers)) {

            // Failed to build the ACE granting "Authenticated users"
            // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        SYNCHRONIZE | MUTEX_MODIFY_STATE,
                                        PowerUsers)) {

            // Failed to build the ACE granting "Power users"
            // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        MUTEX_ALL_ACCESS,
                                        BuiltInAdministrators)) {

            // Failed to build the ACE granting "Built-in Administrators"
            // GENERIC_ALL access.

        } else if (!InitializeSecurityDescriptor(Sd,
                                                 SECURITY_DESCRIPTOR_REVISION)) {

            // error

        } else if (!SetSecurityDescriptorDacl(Sd,
                                              TRUE,
                                              Acl,
                                              FALSE)) {

            // error

        } else {

            // success
            RetVal = Sd;
        }

        // only free Sd if we encountered a failure
        if (!RetVal)
            LocalFree(Sd);
    }

ErrorExit:

    if (AuthenticatedUsers)
        FreeSid(AuthenticatedUsers);

    if (BuiltInAdministrators)
        FreeSid(BuiltInAdministrators);

    if (PowerUsers)
        FreeSid(PowerUsers);

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiui.cpp ===
/*******************************************************
    MultiUI.cpp

    Code for handling multiple user interface in IE
    and friends

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/

#include "private.h"
#include "resource.h"
#include "multiui.h"
#include "multiutl.h"
#include "multiusr.h"
#include "mluisup.h"
#include "strconst.h"
#include "commctrl.h"
extern HINSTANCE g_hInst;

static const GUID GUID_NULL = { /* 00000000-0000-0000-0000-000000000000 */ 
    0x0,
    0x0,
    0x0,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
  };

static const HELPMAP g_rgCtxMapMultiUserGeneral[] = {
    {IDC_NO_HELP_1, NO_HELP},
    {IDC_NO_HELP_2, NO_HELP},
    {IDC_NO_HELP_3, NO_HELP},
    {IDC_NO_HELP_4, NO_HELP},
    {idcWarningIcon, NO_HELP},
    {idcConfirmMsg, NO_HELP},
    {idcErrorMsg, NO_HELP},
    {idcLoginInstr, NO_HELP},
    {idcWelcomeMsg, NO_HELP},
    {idcAdd, IDH_IDENTITY_ADD},
    {idcNewPwd, IDH_IDENTITY_PWORD_NEW},
    {idcPwdCaption,IDH_IDENTITY_ENTER_PWORD}, 
    {idcPwd, IDH_IDENTITY_ENTER_PWORD},
    {idcProperties, IDH_IDENTITY_PROPERTIES},
    {idcConfPwd, IDH_IDENTITY_CONFIRM_PWORD},
    {idcUserName, IDH_IDENTITY_NAME},
    {idcDefault, IDH_IDENTITY_DEFAULT},
    {idcOldPwd, IDH_IDENTITY_PWORD_OLD},
    {idcStartupCombo, IDH_IDENTITY_STARTAS},
    {idcDelete, IDH_IDENTITY_DELETE},
    {idcStaticName, IDH_IDENTITY_LIST},
    {idcUserNameList, IDH_IDENTITY_LIST},
    {idcTellMeMore, /*IDH_IDENTITY_TELLMEMORE_CONTENT */IDH_IDENTITY_TELLMEMORE},
    {idcStaticNames, IDH_IDENTITY_LIST},
    {idcStaticStartUp, IDH_IDENTITY_STARTAS},
    {idcUsePwd, IDH_IDENTITY_PROMPT_PWORD},
    {idcChgPwd, IDH_IDENTITY_CHANGE_PWORD},
    {idcConfirmPwd, IDH_MULTI_DELETE_PWORD},
    {idcManage, IDH_IDENTITY_MANAGE},
    {idcLogoff, IDH_MULTI_LOG_OFF},
    {idcCheckDefault, IDH_MULTI_MNG_IDENT_DEFAULT},
    {idcDefaultCombo, IDH_MULTI_MNG_DEFAULT_LIST},
    {0,0}};


/*
    MU_ShowErrorMessage

    Simple wrapper around resource string table based call to MessageBox
*/
void MU_ShowErrorMessage(HWND hwnd, UINT iMsgID, UINT iTitleID)
{
    TCHAR    szMsg[255], szTitle[63];

    MLLoadStringA(iMsgID, szMsg, ARRAYSIZE(szMsg));
    MLLoadStringA(iTitleID, szTitle, ARRAYSIZE(szTitle));
    MessageBox(hwnd, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/*
    _StripDefault

    Remove the (Default) string from the user's name, if it
    appears.  Should be called after getting a username from
    the listbox since the default user has the string (Default) 
    appended to it
*/
void _StripDefault(LPSTR psz)
{
    TCHAR   szResString[CCH_USERNAME_MAX_LENGTH], *pszStr;
    MLLoadStringA(idsDefault, szResString, CCH_USERNAME_MAX_LENGTH);
    
    pszStr = strstr(psz, szResString);
    if(pszStr)
    {
        *pszStr = 0;
    }
}

#ifdef IDENTITY_PASSWORDS

// ****************************************************************************************************
//  C   H   A   N   G   E       U   S   E   R       P   A   S   S   W   O   R   D
/*
    _ValidateChangePasswordValues

    Validate the data entered by the user.  Return true only if everything is
    legitimate, 
*/

static BOOL _ValidateChangePasswordValues(HWND   hDlg, 
                                         TCHAR*  lpszOldNewPassword)
{
    TCHAR    szOldPW[255], szPW1[255], szPW2[255];

    GetDlgItemText(hDlg,idcOldPwd,  szOldPW, ARRAYSIZE(szOldPW));
    GetDlgItemText(hDlg,idcNewPwd,  szPW1,   ARRAYSIZE(szPW1));
    GetDlgItemText(hDlg,idcConfPwd, szPW2,   ARRAYSIZE(szPW2));

    if (strcmp(lpszOldNewPassword, szOldPW) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcOldPwd));
        SendDlgItemMessage(hDlg,idcOldPwd,EM_SETSEL,0,-1);
        return false;
    }

    if (strcmp(szPW1, szPW2) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdChgNotMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcNewPwd));
        SendDlgItemMessage(hDlg,idcNewPwd,EM_SETSEL,0,-1);
        return false;
    }

    strcpy(lpszOldNewPassword, szPW1);

    return true;
}


/*
    _ChangeUserPwdDlgProc

    Description: Dialog proc for handling the change user password dialog.
*/

INT_PTR CALLBACK _ChangeUserPwdDlgProc(HWND     hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR *sOldNewPassword;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        SendMessage(GetDlgItem(hDlg, idcNewPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg, idcOldPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg,idcConfPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sOldNewPassword = (TCHAR *)lParam;
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateChangePasswordValues(hDlg, sOldNewPassword))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    ChangeUserPassword

    Wrapper routine for changing the user password.  Pass in the current
    password in lpszOldNewPassword which is used to confirm the current 
    password with what the user entered.  If the user enters the old 
    password correctly and enters the new password twice correctly, 
    and clicks OK, then the new password is returned in lpszOldNewPassword
    and this function returns TRUE.  Otherwise, the value in lpszOldNewPassword
    is unchanged and it returns false.

    lpszOldNewPassword must point to a TCHAR buffer large enough to hold a password 
    (CCH_USERPASSWORD_MAX_LENGTH characters)
*/

BOOL        ChangeUserPassword(HWND hwnd, TCHAR *lpszOldNewPassword) 
{
    INT_PTR bResult;
    
    Assert(hwnd);
    Assert(lpszOldNewPassword);
    
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddChgPwd), hwnd, _ChangeUserPwdDlgProc, (LPARAM)lpszOldNewPassword);

    //Don't actually change it here, the caller will do the right thing
    //since this may be (and is) called from another dialog with a cancel 
    //button on it

    return (bResult == IDOK);   
}


// ****************************************************************************************************
//  C   O   N   F   I   R   M       U   S   E   R       P   A   S   S   W   O   R   D

/*
    _ConfirmUserPwdDlgProc

    Description: Dialog proc for handling the confirming user password dialog.
*/  
INT_PTR CALLBACK _ConfirmUserPwdDlgProc(HWND    hDlg,
                                    UINT    iMsg, 
                                    WPARAM  wParam, 
                                    LPARAM  lParam)
{
    static LPCONFIRMPWDDIALOGINFO sConfirmPwdInfo;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);

        SendMessage(GetDlgItem(hDlg, idcConfirmPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sConfirmPwdInfo = (LPCONFIRMPWDDIALOGINFO)lParam;
        SetDlgItemText(hDlg, idcConfirmMsg, sConfirmPwdInfo->szMsg);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            TCHAR    szPW[255];
            
            //if the password matches the provided password, then
            //everything is OK and the dialog can complete, otherwise,
            //barf an error message and keep waiting for a good password
            //or Cancel.
            GetDlgItemText(hDlg,idcConfirmPwd,  szPW, ARRAYSIZE(szPW));
            if (strcmp(szPW, sConfirmPwdInfo->szPassword) == 0)
                MLEndDialogWrap(hDlg, IDOK);
            else
            {
                MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
                SetFocus(GetDlgItem(hDlg,idcConfirmPwd));
                SendDlgItemMessage(hDlg,idcConfirmPwd,EM_SETSEL,0,-1);
            }
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    MU_ConfirmUserPassword

    Confirm that the user knows the password before it is disabled 
    in the registry.  If they enter the correct password, simply return
    true since the calling dialog box will do the right thing if the 
    user clicks cancel there.
*/

BOOL        MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword) 
{
    INT_PTR bResult;
    CONFIRMPWDDIALOGINFO    vConfirmInfo;

    Assert(hwnd);
    Assert(lpszPassword);
    Assert(lpszMsg);
    Assert(lstrlen(lpszMsg) < ARRAYSIZE(vConfirmInfo.szMsg));
    Assert(lstrlen(lpszPassword) < ARRAYSIZE(vConfirmInfo.szPassword));

    strcpy(vConfirmInfo.szMsg, lpszMsg);
    strcpy(vConfirmInfo.szPassword, lpszPassword);

    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddPasswordOff), hwnd, _ConfirmUserPwdDlgProc, (LPARAM)&vConfirmInfo);

    return (bResult == IDOK);   
}

// ****************************************************************************************************
//  E   N   T   E   R       U   S   E   R       P   A   S   S   W   O   R   D

/*
    _ValidateNewPasswordValues

    Description: Make sure that the entered values in the new password
    dialog are legit and consistant.
*/  
static BOOL _ValidateNewPasswordValues(HWND  hDlg, 
                                         TCHAR*  lpszNewPassword)
{
    TCHAR    szPW1[255], szPW2[255];

    GetDlgItemText(hDlg,idcNewPwd,  szPW1,   ARRAYSIZE(szPW1));
    GetDlgItemText(hDlg,idcConfPwd, szPW2,   ARRAYSIZE(szPW2));

    if (strcmp(szPW1, szPW2) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdChgNotMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcNewPwd));
        SendDlgItemMessage(hDlg,idcNewPwd,EM_SETSEL,0,-1);
        return false;
    }

    strcpy(lpszNewPassword, szPW1);

    return true;
}


/*
    _EnterUserPwdDlgProc

    Description: Dialog proc for handling the enter user password dialog.
*/
INT_PTR CALLBACK _EnterUserPwdDlgProc(HWND      hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR *sNewPassword;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        SendMessage(GetDlgItem(hDlg, idcNewPwd),     EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg, idcConfPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sNewPassword = (TCHAR *)lParam;
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateNewPasswordValues(hDlg, sNewPassword))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    EnterUserPassword

    Wrapper routine for getting a new user password.  If the user enters the 
    password and confirms it correctly, and clicks OK, then the new password is 
    returned in lpszNewPassword and this function returns TRUE.  
    Otherwise, the value in lpszNewPassword is unchanged and it returns false.

    lpszNewPassword must point to a TCHAR buffer large enough to hold a password 
    (CCH_USERPASSWORD_MAX_LENGTH characters)
*/
BOOL        EnterUserPassword(HWND hwnd, TCHAR *lpszNewPassword) 
{
    INT_PTR bResult;
    
    Assert(hwnd);
    Assert(lpszNewPassword);
    
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddNewPwd), hwnd, _EnterUserPwdDlgProc, (LPARAM)lpszNewPassword);

    return (bResult == IDOK);   
}

#endif //IDENTITY_PASSWORDS

// ****************************************************************************************************
//  C   O   N   F   I   R   M       D   E   L   E   T   E       U   S   E   R       D   I   A   L   O   G


/*
    ConfirmDeleteUserDlgProc

    Description: Dialog proc for handling the confirm delete user dialog.

*/

INT_PTR CALLBACK _ConfirmDeleteUserDlgProc(HWND hDlg,
                                    UINT    iMsg, 
                                    WPARAM  wParam, 
                                    LPARAM  lParam)
{

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);

        SendDlgItemMessage(hDlg, idcWarningIcon, STM_SETICON, (WPARAM)::LoadIcon(NULL, IDI_EXCLAMATION), 0);
        SetDlgItemText(hDlg, idcErrorMsg, (TCHAR *)lParam);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            MLEndDialogWrap(hDlg, LOWORD(wParam));
            return true;
        }
        break;

    }
    return false;
}

BOOL        MU_ConfirmDeleteUser(HWND hwnd, TCHAR *lpszUsername)
{
    TCHAR   szBuffer[255];    // really ought to be big enough
    TCHAR   szDisplay[255+CCH_USERNAME_MAX_LENGTH];
    TCHAR   szPassword[CCH_USERPASSWORD_MAX_LENGTH];

    // format the message with the username scattered throughout.
    MLLoadStringA(idsConfirmDeleteMsg, szBuffer, ARRAYSIZE(szBuffer));

    if (szBuffer[0])
    {
        INT_PTR bResult;

        wsprintf(szDisplay, szBuffer, lpszUsername);
        
        // Show the Confirm Delete dialog box to make sure they really want to delete the user
        bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddConfirmUserDelete), hwnd, _ConfirmDeleteUserDlgProc, (LPARAM)szDisplay);
        
#ifdef IDENTITY_PASSWORDS

        if (IDOK == bResult)
        {
            BOOL    fUsePassword;
            // check to see if this user has a password, if so, then make sure that
            // they know the password before blowing it all away.
            if (MU_GetPasswordForUsername(lpszUsername, szPassword, &fUsePassword))
            {
                if (fUsePassword)
                {
                    MLLoadStringA(idsConfirmDelPwd, szBuffer, ARRAYSIZE(szBuffer));

                    wsprintf(szDisplay, szBuffer, lpszUsername);
                    
                    if (!MU_ConfirmUserPassword(hwnd, szDisplay, szPassword))
                        bResult = IDCANCEL;
                }
            }
            else    //couldn't load the password, can't delete them either
            {
                MU_ShowErrorMessage(hwnd, idsPwdNotFound, idsPwdError);
                bResult = IDCANCEL;
            }
            
            return (IDOK == bResult);
        }
#else
        return (IDOK == bResult);
#endif //IDENTITY_PASSWORDS
    }
    
    return false;
}

// ****************************************************************************************************
//  C   H   A   N   G   E       U   S   E   R       S   E   T   T   I   N   G   S   
/*
    _ValidateChangeUserValues

    Validate the data entered by the user.  Return true only if everything is
    legit, 
*/
static BOOL _ValidateChangeUserValues(HWND          hDlg, 
                                     LPUSERINFO     lpUserInfo)
{
    TCHAR   szResString[CCH_USERNAME_MAX_LENGTH], *pszStr;
    TCHAR   szUsername[255];
    ULONG   cb;
    
    GetDlgItemText(hDlg,idcUserName, szUsername, ARRAYSIZE(szUsername));
    
    cb = lstrlen(szUsername);
    UlStripWhitespace(szUsername, false, true, &cb);    //remove trailing whitespace

    // Make sure the username wasn't all spaces
    if (!cb)
    {
        MU_ShowErrorMessage(hDlg, idsUserNameTooShort, idsNameTooShort);
        SetFocus(GetDlgItem(hDlg,idcUserName));
        SendDlgItemMessage(hDlg,idcUserName,EM_SETSEL,0,-1);
        return false;
    }

    // if the username exists, and its not the same as the account currently, then
    // it is not allowed.
    if (MU_UsernameExists(szUsername) && strcmp(szUsername, lpUserInfo->szUsername) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsUserNameExists, idsUserNameInUse);
        SetFocus(GetDlgItem(hDlg,idcUserName));
        SendDlgItemMessage(hDlg,idcUserName,EM_SETSEL,0,-1);
        return false;
    }
    
    lstrcpy(lpUserInfo->szUsername, szUsername);
    lpUserInfo->fUsePassword = IsDlgButtonChecked(hDlg, idcUsePwd);
    if (!lpUserInfo->fUsePassword)
        lpUserInfo->szPassword[0] = 0;

    return true;
}


/*
    ChangeUserSettingsDlgProc

    Description: Dialog proc for handling the Change user settings dialog.
*/
INT_PTR CALLBACK _ChangeUserSettingsDlgProc(HWND        hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static LPUSERINFO sUserInfo;
    TCHAR    szMsg[255];
    TCHAR    szPassword[CCH_USERPASSWORD_MAX_LENGTH];

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        
        sUserInfo = (LPUSERINFO)lParam;
        
        MLLoadStringA((*sUserInfo->szUsername) ? idsIdentityProperties : idsNewIdentity, szMsg, ARRAYSIZE(szMsg));
        SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM)szMsg);

        SetDlgItemText(hDlg, idcUserName, sUserInfo->szUsername);
        SendMessage(GetDlgItem(hDlg, idcUserName), EM_LIMITTEXT, CCH_IDENTITY_NAME_MAX_LENGTH/2, 0);
        CheckDlgButton(hDlg, idcUsePwd, sUserInfo->fUsePassword ? BST_CHECKED : BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, idcChgPwd), sUserInfo->fUsePassword);

        // Don't allow zero length names by disabling OK
        if (!lstrlen(sUserInfo->szUsername))
            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateChangeUserValues(hDlg, sUserInfo))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        case idcUserName:
            if (EN_CHANGE == HIWORD(wParam))
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), SendMessage((HWND)lParam, WM_GETTEXTLENGTH, 0, 0) != 0);
                return TRUE;
            }
            break;
        
#ifdef IDENTITY_PASSWORDS
        case idcTellMeMore:
//            WinHelp ((HWND)GetDlgItem(hDlg, idcTellMeMore),
//                        c_szCtxHelpFile,
//                        HELP_WM_HELP,
//                        (DWORD_PTR)(LPVOID)g_rgCtxMapMultiUserGeneral);
            WinHelp(hDlg, c_szCtxHelpFile, HELP_CONTEXT, IDH_IDENTITY_TELLMEMORE_CONTENT);
            return true;

        case idcUsePwd:
            // if they are turning off the password, they need to confirm it first.
            if (!IsDlgButtonChecked(hDlg, idcUsePwd))
            {               
                strcpy(szPassword, sUserInfo->szPassword);
                MLLoadStringA(idsConfirmDisablePwd, szMsg, ARRAYSIZE(szMsg));
                if (!MU_ConfirmUserPassword(hDlg,szMsg, szPassword))
                    CheckDlgButton(hDlg, idcUsePwd, BST_CHECKED);
            }
            else
            {
                // if they are turning it on, they should set the password.
                if (EnterUserPassword(hDlg, szPassword))
                {
                    sUserInfo->fUsePassword = true;
                    strcpy(sUserInfo->szPassword, szPassword);
                }
                else
                {
                    CheckDlgButton(hDlg, idcUsePwd, BST_UNCHECKED);
                }
            }
            EnableWindow(GetDlgItem(hDlg, idcChgPwd), IsDlgButtonChecked(hDlg, idcUsePwd));
            return true;
        
        case idcChgPwd:
            if(sUserInfo->fUsePassword || (0 != *sUserInfo->szPassword))
            {
                strcpy(szPassword, sUserInfo->szPassword);
                
                if (ChangeUserPassword(hDlg, szPassword))
                    strcpy(sUserInfo->szPassword, szPassword);
            }
            return true;
#endif //IDENTITY_PASSWORDS
        }
        break;

    }
    return false;
}

/*
    MU_UserProperties

    Allow the user the change their username or password.
*/
BOOL        MU_UserProperties(HWND hwnd, LPUSERINFO lpUserInfo) 
{
    INT_PTR                 fResult;
    USERINFO                nuInfo;
    TCHAR                   szOldUsername[CCH_IDENTITY_NAME_MAX_LENGTH+1];
    USERINFO                uiCurrent;
    LPARAM                  lpNotify = IIC_CURRENT_IDENTITY_CHANGED;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpUserInfo);
    
    // get the current info so we know who to change later.
    MU_GetUserInfo(NULL, &nuInfo);    

    lstrcpy(szOldUsername, lpUserInfo->szUsername);

    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    fResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddUserProperties), hwnd, _ChangeUserSettingsDlgProc, (LPARAM)lpUserInfo);

    if (IDOK == fResult)
    {
        if (GUID_NULL == lpUserInfo->uidUserID)
            _ClaimNextUserId(&lpUserInfo->uidUserID);

        MU_SetUserInfo(lpUserInfo);

        // if its not the current identity, then just broadcast that an identity changed
        if (MU_GetUserInfo(NULL, &uiCurrent) && (lpUserInfo->uidUserID != uiCurrent.uidUserID))
            lpNotify = IIC_IDENTITY_CHANGED;

        // if the name changd, tell other apps 
        // Unless we're doing an add (szOldUsername == "")
        // which already has its own notification
        if (*szOldUsername != 0 && lstrcmp(szOldUsername, lpUserInfo->szUsername) != 0)
            PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, lpNotify);

    }
    
    return (IDOK == fResult);   
}



// ****************************************************************************************************
//  L   O   G   I   N       S   C   R   E   E   N
/*
    _ValidateLoginValues

    Validate the data entered by the user.  Return true only if everything is
    legit, 
*/
static BOOL _ValidateLoginValues(HWND  hDlg, 
                                    TCHAR*   lpszOldNewPassword)
{
    TCHAR    szUsername[255];
    TCHAR    szPW[255], szRealPW[CCH_USERPASSWORD_MAX_LENGTH];
    LRESULT dSelItem;
    BOOL    rResult = false;

    dSelItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
    if (LB_ERR != dSelItem)
    {
        if (SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXTLEN, dSelItem, 0) < ARRAYSIZE(szUsername))
        {
            SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dSelItem, (LPARAM)szUsername);

#ifdef IDENTITY_PASSWORDS
            BOOL fUsePassword;
            if (MU_GetPasswordForUsername(szUsername, szRealPW, &fUsePassword))
            {
                if (fUsePassword)
                {
                    GetDlgItemText(hDlg,idcPwd,szPW, ARRAYSIZE(szPW));

                    if (strcmp(szPW, szRealPW) == 0)
                    {
                        strcpy(lpszOldNewPassword, szUsername);
                        rResult = true;
                    }
                    else
                    {
                        MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
                        SetFocus(GetDlgItem(hDlg,idcPwd));
                        SendDlgItemMessage(hDlg,idcPwd,EM_SETSEL,0,-1);
                        return false;
                    }
                }
                else    // if there is no password, then it does match up.
                {
                    strcpy(lpszOldNewPassword, szUsername);
                    rResult = true;
                }
            }
            else    //can't load identity password, do not allow access
            {
                MU_ShowErrorMessage(hDlg, idsPwdNotFound, idsPwdError);
                return false;
            }
#else  //IDENTITY_PASSWORDS
            strcpy(lpszOldNewPassword, szUsername);
            rResult = true;
#endif //IDENTITY_PASSWORDS
        }
    }
    return rResult;
}

static void _LoginEnableDisablePwdField(HWND hDlg)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR    szUsername[255], szRealPW[255];
    BOOL    bEnabled = false;
#endif //IDENTITY_PASSWORDS
    LRESULT dSelItem;

    dSelItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
#ifdef IDENTITY_PASSWORDS
    if (LB_ERR != dSelItem)
    {
        if (SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXTLEN, dSelItem, 0) < ARRAYSIZE(szUsername))
        {
            SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dSelItem, (LPARAM)szUsername);

            BOOL fUsePassword;
            if (MU_GetPasswordForUsername(szUsername, szRealPW, &fUsePassword) && fUsePassword)
            {
                bEnabled = true;
            }
        } 
    }
    EnableWindow(GetDlgItem(hDlg,idcPwd),bEnabled);
    EnableWindow(GetDlgItem(hDlg,idcPwdCaption),bEnabled);
#endif //IDENTITY_PASSWORDS

    EnableWindow(GetDlgItem(hDlg,IDOK),(dSelItem != -1));
}

typedef struct 
{
    TCHAR   *pszUsername;
    DWORD    dwFlags;
} LOGIN_PARAMS;

/*
    _LoginDlgProc

    Description: Dialog proc for handling the OE Login dialog.
*/
INT_PTR CALLBACK _LoginDlgProc(HWND       hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR        *sResultUsername;
    static LOGIN_PARAMS *plpParams;
    TCHAR                szMsg[1024], szRes[1024];
    USERINFO            nuInfo;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        
        plpParams = (LOGIN_PARAMS *)lParam;
        sResultUsername = plpParams->pszUsername;

        MLLoadStringA(!!(plpParams->dwFlags & UIL_FORCE_UI) ? idsSwitchIdentities : idsIdentityLogin, szMsg, ARRAYSIZE(szMsg));
        SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM)szMsg);
        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
        
        if (MU_GetUserInfo(NULL, &nuInfo))
        {
            MLLoadStringA(idsLoginWithCurrent, szRes, ARRAYSIZE(szRes));
            wsprintf(szMsg, szRes, nuInfo.szUsername);
            SetDlgItemText(hDlg, idcWelcomeMsg, szMsg);

            MLLoadStringA(idsCurrIdentityInstr, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcLoginInstr, szMsg);
        }
        else
        {
            MLLoadStringA(idsLoginNoCurrent, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcWelcomeMsg, szMsg);
            MLLoadStringA(idsNoIdentityInstr, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcLoginInstr, szMsg);
        }


        if (sResultUsername[0] == 0)
            strcpy(sResultUsername, nuInfo.szUsername);

        if (sResultUsername[0])
        {
            LRESULT dFoundItem;
            
            dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
            if (LB_ERR != dFoundItem)
            {
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
            }
        }
        else
            SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, 0, 0);

        
        _LoginEnableDisablePwdField(hDlg);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
            case LBN_DBLCLK:
                wParam = IDOK;
                break;
            case LBN_SELCHANGE:
                _LoginEnableDisablePwdField(hDlg);
                break;
        }

        switch(LOWORD(wParam))
        {
            case IDOK:
                if (_ValidateLoginValues(hDlg, sResultUsername))
                    MLEndDialogWrap(hDlg, IDOK);
                return true;

            case IDCANCEL:
                MLEndDialogWrap(hDlg, IDCANCEL);
                return true;

            case idcLogoff:
                MLLoadStringA(idsLogoff, sResultUsername, CCH_USERNAME_MAX_LENGTH);
                MLEndDialogWrap(hDlg, IDOK);
                return true;
                
            case idcManage:
                {
                    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1] = "";

                    MU_ManageUsers(hDlg, szUsername, 0);
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, 0, 0);
                    _LoginEnableDisablePwdField(hDlg);

                    if (*szUsername)
                    {
                        lstrcpy(sResultUsername, szUsername);
                        MLEndDialogWrap(hDlg, IDOK);
                    }
                }
                return true;
        
        }
        break;

    }
    return false;
}


/*
    MU_Login

    Wrapper routine for logging in to OE.  Asks the user to choose a username
    and, if necessary, enter the password for that user.  The user can also
    create an account at this point.  

    lpszUsername should contain the name of the person who should be the default
    selection in the list.  If the name is empty ("") then it will look up the
    default from the registry.

    Returns the username that was selected in lpszUsername.  Returns true
    if that username is valid.
*/
BOOL        MU_Login(HWND hwnd, DWORD dwFlags, TCHAR *lpszUsername) 
{
    INT_PTR bResult;
    CStringList *csList;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpszUsername);
    
    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    csList = MU_GetUsernameList();

    // if there is only one username and they do not have a password, just return it.
    if (csList && csList->GetLength() == 1 && !(dwFlags & UIL_FORCE_UI))
    {
        TCHAR   *pszUsername;
        TCHAR   szPassword[255];
        BOOL    fUsePassword;
        pszUsername = csList->GetString(0);

        if(MU_GetPasswordForUsername(pszUsername, szPassword, &fUsePassword) && !fUsePassword)
        {
            lstrcpy(lpszUsername, pszUsername);
            delete csList;
            return TRUE;
        }
    }

    LOGIN_PARAMS lpParams;

    lpParams.dwFlags = dwFlags;
    lpParams.pszUsername = lpszUsername;
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddLogin), hwnd, _LoginDlgProc, (LPARAM)&lpParams);

    if (csList)
        delete csList;

    return (IDOK == bResult);   
}

void _ManagerUpdateButtons(HWND hDlg)
{
    LRESULT     dFoundItem;
    USERINFO    rUserInfo;
    GUID        uidDefaultId;

    // make sure that the delete button is only available if the
    // current user is not selected.
    dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
    if (dFoundItem != -1)
    {
        SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
    
        MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
        MU_GetCurrentUserID(&uidDefaultId);

        // if there is no current user, don't allow deletion of the default user.
        if (GUID_NULL == uidDefaultId)
            MU_GetDefaultUserID(&uidDefaultId);
    }

    EnableWindow(GetDlgItem(hDlg, idcDelete), dFoundItem != -1 && uidDefaultId != rUserInfo.uidUserID);
}

typedef struct 
{
    TCHAR   *pszUsername;
    DWORD    dwFlags;
} MANAGE_PARAMS;

/*
    _ManagerDlgProc

    Description: Dialog proc for handling the identity manager dialog.
*/
INT_PTR CALLBACK _ManagerDlgProc(HWND       hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    USERINFO        rUserInfo;
    static MANAGE_PARAMS  *pmpParams;
    static TCHAR    sResultUsername[MAX_PATH] = "";
    static DWORD    sdwFlags = 0;
    LRESULT         dFoundItem;
    ULONG           uidUserId;
    HRESULT         hr;
    TCHAR           szRes[256];
    USERINFO        nuInfo;
    DWORD           dwIndex;
    GUID            uidDefault;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        _ResetRememberedLoginOption();
        
        pmpParams = (MANAGE_PARAMS*)lParam;
        sdwFlags = pmpParams->dwFlags;

        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));

        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));

        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

        dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));

        CheckDlgButton(hDlg, idcCheckDefault, dwIndex != ASK_BEFORE_LOGIN);
        EnableWindow(GetDlgItem(hDlg, idcStartupCombo), dwIndex != ASK_BEFORE_LOGIN);
        if (dwIndex != ASK_BEFORE_LOGIN)
            SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, dwIndex, 0);
        else
            SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, 0, 0);
        
        MU_GetUserInfo(NULL, &nuInfo);
        strcpy(szRes, nuInfo.szUsername);

        if (szRes[0])
        {
            dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)szRes);
            if (LB_ERR != dFoundItem)
            {
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
            }
        }

        SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);
        
        _ManagerUpdateButtons(hDlg);
        if (!!(sdwFlags & UIMI_CREATE_NEW_IDENTITY))
        {
            ShowWindow(hDlg, SW_SHOW);
            PostMessage(hDlg, WM_COMMAND, idcAdd, 0);
        }
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
            case LBN_DBLCLK:
                wParam = idcProperties;
                break;
            case LBN_SELCHANGE:
                _ManagerUpdateButtons(hDlg);
                break;
        }

        switch(LOWORD(wParam))
        {
            case IDCANCEL:
            case idcClose:
            case IDOK:
                dFoundItem = SendDlgItemMessage(hDlg, idcStartupCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                if (IsDlgButtonChecked(hDlg, idcCheckDefault))
                    MU_SetLoginOption(GetDlgItem(hDlg,idcStartupCombo), dFoundItem);
                else
                    MU_SetLoginOption(GetDlgItem(hDlg,idcStartupCombo), ASK_BEFORE_LOGIN);

                dFoundItem = SendDlgItemMessage(hDlg, idcDefaultCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                MLEndDialogWrap(hDlg, IDOK);
                return true;

            case idcAdd:
                ZeroMemory(&rUserInfo, sizeof(USERINFO));

                if (MU_UserProperties(hDlg,&rUserInfo))
                {
                    TCHAR   szMsg[ARRAYSIZE(szRes) + CCH_IDENTITY_NAME_MAX_LENGTH];
                    
                    // rebuild the username list and select the newly added one
                    _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                    strcpy(sResultUsername, rUserInfo.szUsername);
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                    dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                    SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                    SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);

                    dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
                    if (LB_ERR != dFoundItem)
                    {
                        SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                    }
                    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_ADDED);

                    if (pmpParams->pszUsername)
                    {
                        MLLoadStringA(idsLoginAsUser, szRes, ARRAYSIZE(szRes));
                        wsprintf(szMsg, szRes, rUserInfo.szUsername);

                        MLLoadStringA(idsUserAdded, szRes, ARRAYSIZE(szRes));
                        if (IDYES == MessageBox(hDlg, szMsg, szRes, MB_YESNO))
                        {
                            lstrcpy(pmpParams->pszUsername, rUserInfo.szUsername);
                            PostMessage(hDlg, WM_COMMAND, idcClose, 0);
                        }
                    }
                }
                _ManagerUpdateButtons(hDlg);
                return true;

            case idcDefaultCombo:
                dFoundItem = SendDlgItemMessage(hDlg, idcDefaultCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                _ManagerUpdateButtons(hDlg);
                break;

            case idcCheckDefault:
                EnableWindow(GetDlgItem(hDlg, idcStartupCombo), IsDlgButtonChecked(hDlg, idcCheckDefault));
                return true;

            case idcDelete:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                if (MU_ConfirmDeleteUser(hDlg, rUserInfo.szUsername))
                {
                    MU_DeleteUser(&rUserInfo.uidUserID);
                    _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                    dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                    SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                    SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);
                    _ManagerUpdateButtons(hDlg);
                }
                return true;

            case idcProperties:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

#ifdef IDENTITY_PASSWORDS
                if (SUCCEEDED(hr) && MU_GetUserInfo(&rUserInfo.uidUserID, &rUserInfo) && MU_CanEditIdentity(hDlg, &rUserInfo.uidUserID))
#else
                if (SUCCEEDED(hr) && MU_GetUserInfo(&rUserInfo.uidUserID, &rUserInfo))
#endif //IDENTITY_PASSWORDS

                {
                    if (MU_UserProperties(hDlg,&rUserInfo))
                    {
                        // rebuild the username list and select the newly added one
                        _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                        strcpy(sResultUsername, rUserInfo.szUsername);
                        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                        dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                        SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                        SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);

                        dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
                        if (LB_ERR != dFoundItem)
                        {
                            SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                        }
                    }
                }
                _ManagerUpdateButtons(hDlg);
                break;
/*          
            case idcDefault:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
//                _StripDefault(rUserInfo.szUsername);

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));

                SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo)), 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                _ManagerUpdateButtons(hDlg);
                break;
*/
        }
        break;

    }
    return false;
}

/*
    MU_ManageUsers
*/
BOOL        MU_ManageUsers(HWND hwnd, TCHAR *lpszSwitchtoUsername, DWORD dwFlags) 
{
    INT_PTR         bResult;
    MANAGE_PARAMS   rParams;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpszUsername);
    
    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    rParams.dwFlags = dwFlags;
    rParams.pszUsername = lpszSwitchtoUsername;

    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddManager), hwnd, _ManagerDlgProc, (LPARAM)&rParams);

    return (IDOK == bResult);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiusr.cpp ===
/*******************************************************
    MultiUsr.cpp

    Code for handling multiple user functionality in IE
    and friends

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/

#define DONT_WANT_SHELLDEBUG
#include "private.h"
#include "resource.h"
#include "multiusr.h"
#include <assert.h>
#include "multiutl.h"
#include "strconst.h"
#include "Shlwapi.h"
#include "multiui.h"
#include <shlobj.h>
#include "mluisup.h"
#include <lmwksta.h>

TCHAR g_szRegRoot[MAX_PATH] = "";
extern HINSTANCE g_hInst;
static void _CreateIdentitiesFolder();


// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path 

// this is here to avoid a dependancy on shlwapi.dll
#define CH_WHACK TEXT('\\')

STDAPI_(LPTSTR)
_PathAddBackslash(
    LPTSTR lpszPath)
{
    LPTSTR lpszEnd;

    // perf: avoid lstrlen call for guys who pass in ptr to end
    // of buffer (or rather, EOB - 1).
    // note that such callers need to check for overflow themselves.
    int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

    // try to keep us from tromping over MAX_PATH in size.
    // if we find these cases, return NULL.  Note: We need to
    // check those places that call us to handle their GP fault
    // if they try to use the NULL!
    if (ichPath >= (MAX_PATH - 1))
    {
        Assert(FALSE);      // Let the caller know!        
        return(NULL);
    }

    lpszEnd = lpszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*lpszPath)
        return lpszEnd;

    /* Get the end of the source directory
    */
    switch(*CharPrev(lpszPath, lpszEnd)) {
    case CH_WHACK:
        break;

    default:
        *lpszEnd++ = CH_WHACK;
        *lpszEnd = TEXT('\0');
    }
    return lpszEnd;
}


STDAPI_(DWORD)
_SHGetValueA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey,          OPTIONAL
    IN  LPCSTR  pszValue,           OPTIONAL
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegQueryValueEx(hkeyNew, pszValue, NULL, pdwType, (LPBYTE)pvData, pcbData);
        RegCloseKey(hkeyNew);
    }
    else if (pcbData)
        *pcbData = 0;

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
_DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                _DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}

// ****************************************************************************************************
//  C   S   T   R   I   N   G   L   I   S   T       C   L   A   S   S
//
//  A really basic string list class.  Actually, its a string array class, but you don't need to know
//  that.  It could do so much more, but for now, it only maintains an array of C strings.
//


CStringList::CStringList()
{
    m_count = 0;
    m_ptrCount = 0;
    m_strings = NULL;
}

/*
    CStringList::~CStringList

    Clean up any memory that was allocated in the CStringList object
*/
CStringList::~CStringList()
{
    if (m_strings)
    {
        for (int i = 0; i < m_count; i++)
        {
            if (m_strings[i])
            {
                MemFree(m_strings[i]);
                m_strings[i] = NULL;
            }
        }
        MemFree(m_strings);
        m_strings = NULL;
        m_count = 0;
    }
}


/*
    CStringList::AddString

    Add a string to the end of the string list.
*/
void    CStringList::AddString(TCHAR* lpszInString)
{
    // make more room for pointers, if necessary
    if (m_ptrCount == m_count)
    {
        m_ptrCount += 5;
        if (!MemRealloc((void **)&m_strings, sizeof(TCHAR *) * m_ptrCount))
        {
            m_ptrCount -= 5;
            Assert(false);
            return;
        }

        // initialize the new strings to nil
        for (int i = m_count; i < m_ptrCount; i++)
            m_strings[i] = NULL;

    }
    
    //now put the string in the next location
    int iNewIndex = m_count++;

    if(MemAlloc((void **)&m_strings[iNewIndex], sizeof(TCHAR) * lstrlen(lpszInString)+1))
    {
        lstrcpy(m_strings[iNewIndex], lpszInString);
    }
    else
    {
        // couldn't allocate space for the string.  Don't count that spot as filled
        m_count--;
    }
}

/*
    CStringList::RemoveString
    
    Remove a string at zero based index iIndex 
*/

void    CStringList::RemoveString(int   iIndex)
{
    int     iCopySize;

    iCopySize = ((m_count - iIndex) - 1) * 4;

    // free the memory for the string
    if (m_strings[iIndex])
    {
        MemFree(m_strings[iIndex]);
        m_strings[iIndex] = NULL;
    }

    // move the other strings down
    if (iCopySize)
    {
        memmove(&(m_strings[iIndex]), &(m_strings[iIndex+1]), iCopySize);
    }

    // null out the last item in the list and decrement the counter.
    m_strings[--m_count] = NULL;
}

/*
    CStringList::GetString
    
    Return the pointer to the string at zero based index iIndex.

    Return the string at the given index.  Note that the TCHAR pointer
    is still owned by the string list and should not be deleted.
*/

TCHAR    *CStringList::GetString(int iIndex)
{
    if (iIndex < m_count && iIndex >= 0)
        return m_strings[iIndex];
    else
        return NULL;
}


int __cdecl _CSL_Compare(const void *p1, const void *p2)
{
    TCHAR *psz1, *psz2;

    psz1 = *((TCHAR **)p1);
    psz2 = *((TCHAR **)p2);

    return lstrcmpi(psz1, psz2);
}


/*
    CStringList::Sort
    
    Sort the strings in the list
*/

void    CStringList::Sort()
{
    qsort(m_strings, m_count, sizeof(TCHAR *), _CSL_Compare);
}


/*
    MU_Init

    Initialize the memory allocator and make sure that there is
    at least one user in the registry.
*/
static BOOL g_inited = FALSE;
EXTERN_C void    MU_Init()
{
    CStringList* pList;

    if (!g_inited)
    {
        pList = MU_GetUsernameList();

        if (!pList || pList->GetLength() == 0)
        {
            _MakeDefaultFirstUser();
        }
        if (pList)
            delete pList;
        g_inited = TRUE;
    }
}


/*
    MU_GetUsernameList
    
    Build a CStringList with all of the names of the users 
    stored in HKLM
*/
#define MAXKEYNAME          256

CStringList*    MU_GetUsernameList(void)
{
    CStringList*    vList = NULL;
    HKEY    hSourceSubKey;
    DWORD   dwEnumIndex = 0, dwStatus, dwSize, dwType;
    int     cb;
    TCHAR    szKeyNameBuffer[MAXKEYNAME];
    DWORD dwIdentityOrdinal = 1;

    vList = new CStringList;
    Assert(vList);
    
    if (!vList)
        goto exit;
        
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) != ERROR_SUCCESS)
    {
        AssertSz(FALSE, "Couldn't open user profiles root Key");
        goto exit;
    }

    dwSize = sizeof(dwIdentityOrdinal);
    RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

    while (TRUE) 
    {
        DWORD   dwOrdinal;
        HKEY    hkUserKey;
        if (RegEnumKey(hSourceSubKey, dwEnumIndex++, szKeyNameBuffer,MAXKEYNAME)!=  ERROR_SUCCESS)
            break;

        cb = lstrlen(szKeyNameBuffer);
            
        if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szKeyNameBuffer);
            dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)&szKeyNameBuffer, &dwSize);
                
            Assert(ERROR_SUCCESS == dwStatus);
            Assert(*szKeyNameBuffer != 0);
            //filter names that begin with _ to hide things like "_Outlook News"
            if (ERROR_SUCCESS == dwStatus && *szKeyNameBuffer != '_')
                vList->AddString(szKeyNameBuffer);

            dwSize = sizeof(dwOrdinal);
            dwStatus = RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize);
            if (dwStatus==ERROR_SUCCESS)
            {
                if (dwOrdinal>=dwIdentityOrdinal)
                {
                    dwIdentityOrdinal = dwOrdinal+1;
                    AssertSz(FALSE, "MaxOrdinal is smaller than this identity. Why?");
                }
            }
            else
            {
                dwStatus = RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                dwIdentityOrdinal++;
            }
            Assert(ERROR_SUCCESS == dwStatus);
            
            RegCloseKey(hkUserKey); 
        }
        else
            AssertSz(FALSE, "Couldn't open user's Key");
    }

    dwSize = sizeof(dwIdentityOrdinal);
    if (RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)!=ERROR_SUCCESS)
    {
        AssertSz(FALSE, "Couldn't set the identity ordinal");
    }

    RegCloseKey(hSourceSubKey);

exit:
    return vList;
}


/*
    MU_UsernameToUserId

    Given a username, find its user id and return it.  Returns E_FAIL if it can't 
    find the given username.
*/

HRESULT   MU_UsernameToUserId(TCHAR *lpszUsername, GUID *puidID)
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType;
    TCHAR    szKeyNameBuffer[MAXKEYNAME];
    BOOL    fFound = FALSE;
    TCHAR    szUid[255];

    ZeroMemory(puidID, sizeof(GUID));

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(szKeyNameBuffer);
                dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)&szKeyNameBuffer, &dwSize);
                
                if (ERROR_SUCCESS == dwStatus && lstrcmpi(lpszUsername, szKeyNameBuffer) == 0)
                {
                    dwSize = sizeof(szUid);
                    dwStatus = RegQueryValueEx(hkUserKey, c_szUserID, NULL, &dwType, (LPBYTE)&szUid, &dwSize);
                    fFound = (dwStatus == ERROR_SUCCESS);

                    if (fFound)
                        fFound = SUCCEEDED(GUIDFromAString(szUid, puidID));
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
    

    return (fFound ? S_OK : E_FAIL);
}

/*
    MU_GetPasswordForUsername

    Get the password for the provided user and return it in szOutPassword.  Return in 
    pfUsePassword if password is enabled and false if it is disabled.

    Function returns true if the password data could be found, false otherwise
*/

BOOL  MU_GetPasswordForUsername(TCHAR *lpszInUsername, TCHAR *szOutPassword, BOOL *pfUsePassword)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR           szPath[MAX_PATH];
    TCHAR           szPassword[255] = "";
    HKEY            hDestinationSubKey;
    DWORD           dwSize, dwStatus, dwType;
    DWORD           dwPWEnabled = 0;
    GUID            uidUserID;
    HRESULT         hr;
    PASSWORD_STORE  pwStore;

    hr = MU_UsernameToUserId(lpszInUsername, &uidUserID);
    Assert(SUCCEEDED(hr));
    
    if (uidUserID == GUID_NULL)
    {
        *pfUsePassword = FALSE;
        return TRUE;
    }
    
    if (SUCCEEDED(hr = ReadIdentityPassword(&uidUserID, &pwStore)))
    {
        lstrcpy(szOutPassword, pwStore.szPassword);
        *pfUsePassword = pwStore.fUsePassword;
        return TRUE;
    }
    else
    {
        BOOL fFoundPassword = FALSE;
        
        //build the user level key. 
        MU_GetRegRootForUserID(&uidUserID, szPath);
    
        if (RegCreateKey(HKEY_CURRENT_USER, szPath, &hDestinationSubKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwPWEnabled);
            dwStatus = RegQueryValueEx(hDestinationSubKey, c_szUsePassword, NULL, &dwType, (LPBYTE)&dwPWEnabled, &dwSize);
        
            if (ERROR_SUCCESS == dwStatus && 0 != dwPWEnabled)
            {
                dwSize = sizeof(szPassword);
                dwStatus = RegQueryValueEx(hDestinationSubKey, c_szPassword, NULL, &dwType, (LPBYTE)&szPassword, &dwSize);
        
                if (ERROR_SUCCESS == dwStatus)
                {
                    ULONG   cbSize;

                    fFoundPassword = TRUE;
                    cbSize = dwSize;
                    if (cbSize > 1)
                    {
                        DecodeUserPassword(szPassword, &cbSize);
                        strcpy(szOutPassword, szPassword);  
                    }
                    else
                    {
                        *szOutPassword = 0;
                    }
                }
            }
        
            RegCloseKey(hDestinationSubKey);
        }

        // Herein lies the pull.  We can't count on being able to access any
        // given pstore from any given profile on Win9x.  If you log on with
        // a blank password, or hit escape (not much difference to a user)
        // you will have a different pstore.  If we store our passwords in the
        // registry, they can be whacked pretty simply.  If we can't find the 
        // password, we will disable it for now and say there is none.  It 
        // seems that most people don't put passwords on identities now 
        // anyway, though this will change. 
        if (!fFoundPassword)
        {
            fFoundPassword = TRUE;
            dwPWEnabled = 0;
        }
        // Here ends the pull
        
        *pfUsePassword = (dwPWEnabled != 0);
        return fFoundPassword;
    }
#else
    *pfUsePassword = FALSE;
    return TRUE;
#endif //IDENTITY_PASSWORDS

}

/*
    _FillListBoxWithUsernames

    Fill a listbox with the names of the users,  Adds (Default) 
    to the default user.
*/
BOOL _FillListBoxWithUsernames(HWND hListbox)
{
    CStringList *lpCStringList;
    GUID        uidDefault;
    GUID        uidUser;

    lpCStringList = MU_GetUsernameList();

    if (lpCStringList)
    {    
        MU_GetDefaultUserID(&uidDefault);

        SendMessage(hListbox, LB_RESETCONTENT, 0, 0);
        lpCStringList->Sort();

        if (lpCStringList)
        {
            for(int i = 0; i < lpCStringList->GetLength(); i++)
            {
                if (lpCStringList->GetString(i))
                {
                    SendMessage(hListbox, LB_ADDSTRING, 0, (LPARAM)lpCStringList->GetString(i));
                }
            }
            delete lpCStringList;
            return true;
        }
    }
    return false;
}

BOOL _FillComboBoxWithUsernames(HWND hCombobox, HWND hListbox)
{
    TCHAR szRes[128];
    DWORD_PTR cIndex, dwCount = SendMessage(hListbox, LB_GETCOUNT, 0, 0);

    SendMessage(hCombobox, CB_RESETCONTENT, 0, 0);

    for (cIndex = 0; cIndex < dwCount; cIndex++)
    {
        SendMessage(hListbox, LB_GETTEXT, cIndex, (LPARAM)szRes);
        SendMessage(hCombobox, CB_ADDSTRING, 0, (LPARAM)szRes);
    }
    return true;
}

/*
    MU_UsernameExists
    
    Does the given name already exist as a username?
*/

BOOL        MU_UsernameExists(TCHAR*    lpszUsername)
{
    GUID uidID;
    
    return SUCCEEDED(MU_UsernameToUserId(lpszUsername, &uidID));

}

/*
    MU_GetUserInfo
    
    Fill in the user info structure with current values
*/

BOOL    MU_GetUserInfo(GUID *puidUserID, LPUSERINFO lpUserInfo)
{
    TCHAR           szPWBuffer[255];
    TCHAR           szRegPath[MAX_PATH];
    HKEY            hKey;
    BOOL            bResult = false;
    LONG            lValue;
    DWORD           dwStatus, dwType, dwSize;
    GUID            uidUser;
    TCHAR           szUid[255];
    HRESULT         hr;
    PASSWORD_STORE  pwStore;

    lpUserInfo->fPasswordValid = FALSE;
    
    if( puidUserID == NULL)
    {
        MU_GetCurrentUserID(&uidUser);
        if (uidUser == GUID_NULL)
            return FALSE;
    }
    else
        uidUser = *puidUserID;

    MU_GetRegRootForUserID(&uidUser, szRegPath);
    
    if (RegOpenKey(HKEY_CURRENT_USER, szRegPath, &hKey) == ERROR_SUCCESS)
    {
        *lpUserInfo->szPassword = 0;
        lpUserInfo->fUsePassword = false;
        ZeroMemory(&lpUserInfo->uidUserID, sizeof(GUID));

        dwSize = sizeof(lpUserInfo->szUsername);
        if ((dwStatus = RegQueryValueEx(hKey, c_szUsername, NULL, &dwType, (LPBYTE)lpUserInfo->szUsername, &dwSize)) == ERROR_SUCCESS &&
                (0 != *lpUserInfo->szUsername))
        {
            //we have the username, that is the only required part.  The others are optional.
            bResult = true;
            
#ifdef IDENTITY_PASSWORDS
            lpUserInfo->fPasswordValid = FALSE;
            if (SUCCEEDED(hr = ReadIdentityPassword(&uidUser, &pwStore)))
            {
                lstrcpy(lpUserInfo->szPassword, pwStore.szPassword);
                lpUserInfo->fUsePassword = pwStore.fUsePassword;
                lpUserInfo->fPasswordValid = TRUE;
            }
            else
            {
                dwSize = sizeof(lValue);
                if ((dwStatus = RegQueryValueEx(hKey, c_szUsePassword, NULL, &dwType, (LPBYTE)&lValue, &dwSize)) == ERROR_SUCCESS)
                {
                    lpUserInfo->fUsePassword = (lValue != 0);
                }

                dwSize = sizeof(szPWBuffer);
                dwStatus = RegQueryValueEx(hKey, c_szPassword, NULL, &dwType, (LPBYTE)szPWBuffer, &dwSize);

                ULONG   cbSize;

                lpUserInfo->fPasswordValid = (ERROR_SUCCESS == dwStatus);

                // Herein lies the pull (Volume 2).  We can't count on being able to access any
                // given pstore from any given profile on Win9x.  If you log on with
                // a blank password, or hit escape (not much difference to a user)
                // you will have a different pstore.  If we store our passwords in the
                // registry, they can be whacked pretty simply.  If we can't find the 
                // password, we will disable it for now and say there is none.  It 
                // seems that most people don't put passwords on identities now 
                // anyway, though this will change.  
                if (!lpUserInfo->fPasswordValid)
                {
                    lpUserInfo->fPasswordValid = TRUE;
                    lpUserInfo->fUsePassword = FALSE;
                }
                // Here ends the pull

                cbSize = dwSize;
                if (ERROR_SUCCESS == dwStatus && cbSize > 1)
                {
                    DecodeUserPassword(szPWBuffer, &cbSize);
                    strcpy(lpUserInfo->szPassword, szPWBuffer);
                }
                else
                    *lpUserInfo->szPassword = 0;
            }
#endif 
            dwSize = sizeof(szUid);
            if ((dwStatus = RegQueryValueEx(hKey, c_szUserID, NULL, &dwType, (LPBYTE)&szUid, &dwSize)) == ERROR_SUCCESS)
            {
                hr = GUIDFromAString(szUid, &lpUserInfo->uidUserID);
                Assert(hr);
            }

        }
        RegCloseKey(hKey);
    }
        
    return bResult;
}


/*
    MU_SetUserInfo
    
    Save the user info structure with the user values
*/
BOOL        MU_SetUserInfo(LPUSERINFO lpUserInfo)
{
    DWORD           dwType, dwSize, dwValue, dwStatus;
    HKEY            hkCurrUser;
    TCHAR           szPath[MAX_PATH];
    WCHAR           szwPath[MAX_PATH];
    TCHAR           szUid[255];
    BOOL            fNewIdentity = FALSE;
    PASSWORD_STORE  pwStore;
    HRESULT         hr;

    MU_GetRegRootForUserID(&lpUserInfo->uidUserID, szPath);
    
    Assert(pszRegPath && *pszRegPath);
    Assert(lpUserInfo->uidUserID != GUID_NULL);
    
    if ((dwStatus = RegCreateKey(HKEY_CURRENT_USER, szPath, &hkCurrUser)) == ERROR_SUCCESS)
    {
        ULONG   cbSize;
        TCHAR   szBuffer[255];

        // write out the correct values
        dwType = REG_SZ;
        dwSize = lstrlen(lpUserInfo->szUsername) + 1;
        RegSetValueEx(hkCurrUser, c_szUsername, 0, dwType, (LPBYTE)lpUserInfo->szUsername, dwSize);

        dwSize = sizeof(DWORD);
        if ((dwStatus = RegQueryValueEx(hkCurrUser, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize)) != ERROR_SUCCESS)
        {
            dwValue = MU_GenerateDirectoryNameForIdentity(&lpUserInfo->uidUserID);
        
            dwType = REG_DWORD;
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkCurrUser, c_szDirName, 0, dwType, (LPBYTE)&dwValue, dwSize);
            fNewIdentity = TRUE;
        }

#ifdef IDENTITY_PASSWORDS
        lstrcpy(pwStore.szPassword, lpUserInfo->szPassword);
        pwStore.fUsePassword = lpUserInfo->fUsePassword;

        if (FAILED(hr = WriteIdentityPassword(&lpUserInfo->uidUserID, &pwStore)))
        {
            dwType = REG_BINARY ;
            cbSize = strlen(lpUserInfo->szPassword) + 1;
            lstrcpy(szBuffer, lpUserInfo->szPassword);
            EncodeUserPassword(szBuffer, &cbSize);
            dwSize = cbSize;
            RegSetValueEx(hkCurrUser, c_szPassword, 0, dwType, (LPBYTE)szBuffer, dwSize);
        
            dwType = REG_DWORD;
            dwValue = (lpUserInfo->fUsePassword ? 1 : 0);
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkCurrUser, c_szUsePassword, 0, dwType, (LPBYTE)&dwValue, dwSize);
        }
        else
        {
            //don't keep the registry values if we could save it to the pstore.
            RegDeleteValue(hkCurrUser, c_szPassword);
            RegDeleteValue(hkCurrUser, c_szUsePassword);
        }
#endif //IDENTITY_PASSWORDS

        Assert(lpUserInfo->uidUserID != GUID_NULL);
        AStringFromGUID(&lpUserInfo->uidUserID,  szUid, ARRAYSIZE(szUid));

        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkCurrUser, c_szUserID, 0, dwType, (LPBYTE)&szUid, dwSize);

        RegCloseKey(hkCurrUser);

        if (fNewIdentity)
        {
            if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_ROAMING_FOLDER, szwPath, MAX_PATH)))
            {
                if (!CreateDirectoryWrapW(szwPath,NULL))
                {
                    _CreateIdentitiesFolder();
                    CreateDirectoryWrapW(szwPath,NULL);
                }
            }
            
            if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_NON_ROAMING_FOLDER, szwPath, MAX_PATH)))
            {
                if (!CreateDirectoryWrapW(szwPath,NULL))
                {
                    _CreateIdentitiesFolder();
                    CreateDirectoryWrapW(szwPath,NULL);
                }
            }
        }
        return TRUE;
    }
    return FALSE;
}

/*
    MU_SwitchToUser

    Currently, this just saves the last user's info.
*/
HRESULT  MU_SwitchToUser(TCHAR *lpszUsername)
{
    GUID    uidUserID;
    TCHAR    szUid[255];
    HRESULT hr;

    Assert(lpszUsername);
    
    if (*lpszUsername == 0) //  null string means null guid
    {
        uidUserID = GUID_NULL;
    }
    else
    {
        hr = MU_UsernameToUserId(lpszUsername, &uidUserID);
        if (FAILED(hr))
            return hr;
    }


    AStringFromGUID(&uidUserID,  szUid, ARRAYSIZE(szUid));
    Assert(uidUserID != GUID_NULL || (*lpszUsername == 0));

    wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);
    
    // remember who we last switched to
    HKEY    hkey;
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType, dwSize;

        dwType = REG_SZ;
        dwSize = lstrlen(lpszUsername) + 1;
        RegSetValueEx(hkey, c_szLastUserName, 0, dwType, (LPBYTE)lpszUsername, dwSize);

        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkey, c_szLastUserID, 0, dwType, (LPBYTE)szUid, dwSize);

        RegCloseKey(hkey);
    }

    return S_OK;
}

/*
    MU_SwitchToLastUser

    Makes the last user current, if there is no
    last user, it switches to the first user it can
    find. If there are no users, it creates a 
    user called "Main User"
*/
void MU_SwitchToLastUser()
{
    HKEY    hkey;
    TCHAR   szUserUid[255];
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH + 1];
    BOOL    fSwitched = FALSE;
    GUID    uidUserId;

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType, dwStatus, dwSize;
        dwSize = sizeof(szUserUid);
        dwStatus = RegQueryValueEx(hkey, c_szLastUserID, NULL, &dwType, (LPBYTE)szUserUid, &dwSize);
        
        RegCloseKey(hkey);

        if (ERROR_SUCCESS == dwStatus && SUCCEEDED(GUIDFromAString(szUserUid, &uidUserId)) && 
                    SUCCEEDED(MU_UserIdToUsername(&uidUserId, szUsername, CCH_USERNAME_MAX_LENGTH)))
        {
            MU_SwitchToUser(szUsername);
            fSwitched = true;
        }
    }

    if (!fSwitched)
    {
        LPSTR   pszName;

        CStringList*    pList = MU_GetUsernameList();
        
        if (pList)
        {
            DWORD   dwIndex, dwLen = pList->GetLength();

            // find the first non hidden user and switch to them
            for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
            {
                pszName = pList->GetString(dwIndex);
                
                if (pszName && *pszName  && *pszName != '_')
                {
                    MU_SwitchToUser(pszName);
                    fSwitched = TRUE;
                    break;
                }
            }
            delete pList;
        }
    }

    if (!fSwitched)
    {
        _MakeDefaultFirstUser();
        CStringList*    pList = MU_GetUsernameList();
        
        if (pList && pList->GetLength() > 0)
            MU_SwitchToUser(pList->GetString(0));
        
        if (pList)
            delete pList; 
    }
}

/*
    _CreateIdentitiesFolder

    Create the parent folder of all of the identities folders.
*/

static void _CreateIdentitiesFolder()
{
    HRESULT     hr;
    TCHAR       szAppDir[MAX_PATH], szSubDir[MAX_PATH], *psz;
    DWORD       dw, type;

    hr = E_FAIL;

    dw = MAX_PATH;


    if (ERROR_SUCCESS == _SHGetValueA(HKEY_CURRENT_USER, c_szRegFolders, c_szValueAppData, &type, (LPBYTE)szAppDir, &dw))
    {
        lstrcpy(szSubDir, c_szIdentitiesFolderName);
        psz = _PathAddBackslash(szSubDir);
        if (psz)
        {
            psz = _PathAddBackslash(szAppDir);
            if (psz)
            {
                lstrcpy(psz, szSubDir);

                psz = _PathAddBackslash(szAppDir);
        
                CreateDirectory(szAppDir, NULL);
            }
        }
    }
}


/*
    MU_GetCurrentUserDirectoryRoot

    Return the path to the top of the current user's root directory.
    This is the directory where the mail store should be located.
    It is in a subfolder the App Data folder.

    lpszUserRoot is a pointer to a character buffer that is cch chars
    in size.
*/
HRESULT MU_GetUserDirectoryRoot(GUID *uidUserID, DWORD dwFlags, WCHAR   *lpszwUserRoot, int cch)
{
    HRESULT         hr;
    WCHAR           szwSubDir[MAX_PATH], *pszw, szwUid[255]; 
    int             cb;
    DWORD           type, dwDirId;
    LPITEMIDLIST    pidl = NULL;
    IShellFolder   *psf = NULL;
    STRRET          str;
    IMalloc         *pMalloc = NULL;
    BOOL            fNeedHelp = FALSE;

    Assert(lpszUserRoot != NULL);
    Assert(uidUserID);
    Assert(cch >= MAX_PATH);
    Assert((dwFlags & (GIF_NON_ROAMING_FOLDER | GIF_ROAMING_FOLDER)));

    hr = MU_GetDirectoryIdForIdentity(uidUserID, &dwDirId);
    StringFromGUID2(*uidUserID, szwUid, ARRAYSIZE(szwUid));

    if (FAILED(hr))
        return hr;

    hr = SHGetMalloc(&pMalloc);
    Assert(pMalloc);
    if (!pMalloc)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    if (!!(dwFlags & GIF_NON_ROAMING_FOLDER))
    {
        hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_LOCAL_APPDATA, &pidl);
        
        if (FAILED(hr) || pidl == 0)
            hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl);

        if (FAILED(hr))
            fNeedHelp = TRUE;

    }
    else if (!!(dwFlags & GIF_ROAMING_FOLDER))
    {
        hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl);

        if (FAILED(hr))
            fNeedHelp = TRUE;
    }
    else
        hr = E_INVALIDARG;

    *lpszwUserRoot = 0;
    if (SUCCEEDED(hr) && pidl)
    {
        if (FAILED(hr = SHGetDesktopFolder(&psf)))
            goto exit;

        if (FAILED(hr = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
            goto exit;

        switch(str.uType)
        {
            case STRRET_WSTR:
                lstrcpyW(lpszwUserRoot, str.pOleStr);
                pMalloc->Free(str.pOleStr);
                break;

            case STRRET_OFFSET:
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)pidl+str.uOffset, -1, lpszwUserRoot, cch-11);
                break;

            case STRRET_CSTR:
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)str.cStr, -1, lpszwUserRoot, cch-11);
                break;

            default:
                Assert(FALSE);
                goto exit;
        }

        pszw = PathAddBackslashW(lpszwUserRoot);

        if (lstrlenW(lpszwUserRoot) < cch - 10)
        {
            StrCatW(pszw, L"Identities\\");
            StrCatW(pszw, szwUid);
            StrCatW(pszw, L"\\");
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *lpszwUserRoot = 0;
        }
    }
    else if (fNeedHelp)
    {
        // $$$Review: NEIL QFE
        // SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl) fails on non-SI OSR2.
        HKEY hkeySrc;
        DWORD cb;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                                          0, KEY_QUERY_VALUE, &hkeySrc))
        {
            // -1 for the backslash we may add
            cb = cch - 1;
            if (ERROR_SUCCESS == RegQueryValueExWrapW(hkeySrc, L"AppData", 0, NULL, (LPBYTE)lpszwUserRoot, &cb))
            {
                pszw = PathAddBackslashW(lpszwUserRoot);

                if (lstrlenW(lpszwUserRoot) < cch - 10)
                {
                    StrCatW(pszw, L"Identities\\");
                    StrCatW(pszw, szwUid);
                    StrCatW(pszw, L"\\");
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    *lpszwUserRoot = 0;
                }
            }

            RegCloseKey(hkeySrc);
        }
    } 
exit:
    Assert(lstrlenW(lpszwUserRoot) > 0);
    SafeRelease(psf);
    pMalloc->Free(pidl);
    SafeRelease(pMalloc);

    return hr;
}


/*
    _ClaimNextUserId

    Get the next available user id.  Currently this means starting 
    with the CURRENT_USER GUID and changing the first DWORD of it
    until it is unique.  
*/
HRESULT   _ClaimNextUserId(GUID *puidId)
{
    ULONG   ulValue = 1;
    DWORD   dwType, dwSize, dwStatus;
    HKEY    hkeyProfiles;
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];
    GUID    uid;
    FILETIME    ft;

    if (FAILED(CoCreateGuid(&uid)))
    {
        uid = UID_GIBC_CURRENT_USER;
        GetSystemTimeAsFileTime(&ft);
        uid.Data1 = ft.dwLowDateTime;

        //make sure it hasn't been used
        while (MU_UserIdToUsername(&uid, szUsername, CCH_USERNAME_MAX_LENGTH))
            uid.Data1 ++;
    }
    
    *puidId = uid;

    return S_OK;
}



BOOL MU_GetCurrentUserID(GUID *puidUserID)
{
    BOOL    fFound = FALSE;
    HKEY    hkey;
    GUID    uidUserId;
    TCHAR   szUid[255];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwSize;

        dwSize = 255;
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szLastUserID, 0, NULL, (LPBYTE)szUid, &dwSize));

        if (fFound)
            fFound = SUCCEEDED(GUIDFromAString(szUid, puidUserID));

        if (fFound && *puidUserID == GUID_NULL)
            fFound = false;

        RegCloseKey(hkey);
    }

#ifdef DEBUG
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];

    Assert(MU_UserIdToUsername(puidUserID, szUsername, CCH_USERNAME_MAX_LENGTH));
#endif

    return fFound;
}

/*
    MU_UserIdToUsername

    Return the user name for the user whose user id is passed in.  Returns
    whether or not the user was found.
*/
BOOL MU_UserIdToUsername(GUID *puidUserID, TCHAR *lpszUsername, ULONG cch)
{
    HKEY    hkey;
    TCHAR   szPath[MAX_PATH];
    BOOL    fFound = FALSE;

    Assert(lpszUsername);
    lpszUsername[0] = 0;

    MU_GetRegRootForUserID(puidUserID, szPath);    
    Assert(*szPath);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szPath, 0, KEY_QUERY_VALUE, &hkey))
    {
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szUsername, 0, NULL, (LPBYTE)lpszUsername, &cch));
        RegCloseKey(hkey);
    }

    return fFound;
}

/*
    MU_CountUsers

    Returns the number of users currently configured.
*/
ULONG  MU_CountUsers(void)
{
    CStringList *psList;
    ULONG       ulCount = 0;

    psList = MU_GetUsernameList();

    if (psList)
    {
        ulCount = psList->GetLength();
        delete psList;
    }

    return ulCount;
}

/*
    MU_GetRegRootForUserid

    Get the reg root path for a given user id.
*/
HRESULT     MU_GetRegRootForUserID(GUID *puidUserID, LPSTR pszPath)
{
    TCHAR szUid[255];

    Assert(pszPath);
    Assert(puidUserID);

    AStringFromGUID(puidUserID,  szUid, ARRAYSIZE(szUid));
    wsprintf(pszPath, "%.100s\\%.40s", c_szRegRoot, szUid);

    return S_OK;
}

/*
    MU_GetDefaultUserID

    Get the user id for the user who is currently marked as the default user.
    Returns true if the proper user was found, false if not.
*/
BOOL MU_GetDefaultUserID(GUID *puidUserID)
{
    BOOL    fFound = FALSE;
    HKEY    hkey;
    TCHAR    szUid[255];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwSize;

        dwSize = sizeof(szUid);
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDefaultUserID, 0, NULL, (LPBYTE)szUid, &dwSize));

        if (fFound)
            fFound = SUCCEEDED(GUIDFromAString(szUid, puidUserID));

        RegCloseKey(hkey);
    }

#ifdef DEBUG
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];

    Assert(MU_UserIdToUsername(ulUserID, szUsername, CCH_USERNAME_MAX_LENGTH));
#endif

    return fFound;
}

/*
    MU_MakeDefaultUser

    Set the user referenced by id ulUserID to be the default user.
    The default user is referenced by certain applications which
    can only deal with one user. MS Phone is a good example.

*/
HRESULT MU_MakeDefaultUser(GUID *puidUserID)
{
    HRESULT hr = E_FAIL;
    TCHAR   szUid[255];
    // make sure the user exists and get their name to put in the 
    // Default Username reg key
    
    if (*puidUserID==GUID_NULL)
    {
        // We don't have a current user. So we'll have to figure out a new default user.
        LPSTR   pszName;
        CStringList*    pList = MU_GetUsernameList();
        
        if (pList)
        {
            DWORD   dwIndex, dwLen = pList->GetLength();

            // find the first non hidden user and switch to them
            for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
            {
                pszName = pList->GetString(dwIndex);
                
                if (pszName && *pszName  && *pszName != '_')
                {
                    break;
                }
            }
            if (dwIndex==dwLen)
            {
                // Or, just create one
                delete pList;
                _MakeDefaultFirstUser();
                return S_OK;
            }
            MU_SwitchToUser(pszName);
            GUID    guid;    
            hr = MU_UsernameToUserId(pszName, &guid);
            if (SUCCEEDED(hr))
            {
                AStringFromGUID(&guid,  szUid, ARRAYSIZE(szUid));
            }
            delete pList;
        }
    }
    else
    {
        TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];
        AStringFromGUID(puidUserID,  szUid, ARRAYSIZE(szUid));
        if (MU_UserIdToUsername(puidUserID, szUsername, CCH_USERNAME_MAX_LENGTH))
            hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {        
        HKEY    hkey;
        if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
        {
            DWORD   dwType, dwSize;
            LONG    lError;

            dwType = REG_SZ;
            dwSize = lstrlen(szUid) + 1;
            lError = RegSetValueEx(hkey, c_szDefaultUserID, 0, dwType, (LPBYTE)szUid, dwSize);

            if (lError)
            {
                hr = E_FAIL;
                goto error;
            }

            hr = S_OK;

error:
            RegCloseKey(hkey);
            
        }
    }

    return hr;
}

/*
    MU_DeleteUser

    Remove a user from the registry.  This does not delete
    anything in the user's folder, but it does blow away
    their reg settings.
*/
HRESULT MU_DeleteUser(GUID *puidUserID)
{
    GUID   uidDefault, uidCurrent;
    TCHAR   szPath[MAX_PATH];

    MU_GetCurrentUserID(&uidCurrent);
    MU_GetDefaultUserID(&uidDefault);

    // Can't delete the current user
    if (*puidUserID == uidCurrent)
        return E_FAIL;
    
    // Delete the registry settings
    MU_GetRegRootForUserID(puidUserID, szPath);
    _DeleteKeyRecursively(HKEY_CURRENT_USER, szPath);

    // If we had a default user, we'll have to find a new one now
    if (*puidUserID == uidDefault)
        MU_MakeDefaultUser(&uidCurrent);

    // don't delete the directory since the user may need 
    // data out of it.
    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_DELETED);

    return S_OK;
}


/*
    MU_CreateUser

    Create a user with the user info passed in.  This includes 
    creating their spot in the registry and their directory in the
    identities folder.
*/

HRESULT MU_CreateUser(LPUSERINFO   lpUserInfo)
{
    TCHAR           szPath[MAX_PATH], szBuffer[MAX_PATH], szUid[255];
    WCHAR           szwPath[MAX_PATH];
    HKEY            hkey;
    HRESULT         hr = S_OK;
    DWORD           dwType, dwSize, cbSize, dwValue;
    PASSWORD_STORE  pwStore;

    MU_GetRegRootForUserID(&lpUserInfo->uidUserID, szPath);
    
    Assert(*szPath && *szAcctPath);
 
    AStringFromGUID(&lpUserInfo->uidUserID,  szUid, ARRAYSIZE(szUid));
    Assert(lpUserInfo->uidUserID != GUID_NULL);

    if (RegCreateKey(HKEY_CURRENT_USER, szPath, &hkey) == ERROR_SUCCESS)
    {
        // write out the correct values
        dwType = REG_SZ;
        dwSize = lstrlen(lpUserInfo->szUsername) + 1;
        RegSetValueEx(hkey, c_szUsername, 0, dwType, (LPBYTE)lpUserInfo->szUsername, dwSize);

#ifdef IDENTITY_PASSWORDS
        lstrcpy(pwStore.szPassword, lpUserInfo->szPassword);
        pwStore.fUsePassword = lpUserInfo->fUsePassword;
        if (FAILED(hr = WriteIdentityPassword(&lpUserInfo->uidUserID, &pwStore)))
        {
            dwType = REG_BINARY ;
            cbSize = strlen(lpUserInfo->szPassword) + 1;
            lstrcpy(szBuffer, lpUserInfo->szPassword);
            EncodeUserPassword(szBuffer, &cbSize);
            dwSize = cbSize;
            RegSetValueEx(hkey, c_szPassword, 0, dwType, (LPBYTE)szBuffer, dwSize);
        
            dwType = REG_DWORD;
            dwValue = (lpUserInfo->fUsePassword ? 1 : 0);
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkey, c_szUsePassword, 0, dwType, (LPBYTE)&dwValue, dwSize);
        }
#endif //IDENTITY_PASSWORDS
        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkey, c_szUserID, 0, dwType, (LPBYTE)&szUid, dwSize);
    
        RegCloseKey(hkey);

        if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_ROAMING_FOLDER, szwPath, MAX_PATH)))
            if (!CreateDirectoryWrapW(szwPath,NULL))
            {
                _CreateIdentitiesFolder();
                CreateDirectoryWrapW(szwPath,NULL);
            }

        if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_NON_ROAMING_FOLDER, szwPath, MAX_PATH)))
            if (!CreateDirectoryWrapW(szwPath,NULL))
            {
                _CreateIdentitiesFolder();
                CreateDirectoryWrapW(szwPath,NULL);
            }
    }
    else
        hr = E_FAIL;

    return hr;
}

/*
    MU_GetRegRoot

    Returns a pointer to a string containing the location 
    in HKEY_CURRENT_USER for the current user.
*/
LPCTSTR     MU_GetRegRoot()
{
    if (*g_szRegRoot)
        return g_szRegRoot;
    else
    {
        TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH + 1];

        if (MU_Login(NULL, 0, szUsername))
        {
            GUID uidUserId;
            TCHAR szUid[255];
            
            MU_UsernameToUserId(szUsername, &uidUserId);

            AStringFromGUID(&uidUserId,  szUid, ARRAYSIZE(szUid));
            wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);

            return g_szRegRoot;
        }
        else
        {
            Assert(FALSE);
        }
    }
    return NULL;
}


void _MakeDefaultFirstUser()
{
    USERINFO    nuInfo;
    TCHAR        szUid[255];

    MLLoadStringA(idsMainUser, nuInfo.szUsername, CCH_USERNAME_MAX_LENGTH);
    if (nuInfo.szUsername[0] == 0)
    {
        lstrcpy(nuInfo.szUsername, TEXT("Main Identity"));
    }
    *nuInfo.szPassword = 0;
    nuInfo.fUsePassword = false;
    nuInfo.fPasswordValid = true;
    _ClaimNextUserId(&nuInfo.uidUserID);

    MU_CreateUser(&nuInfo);
    MU_MakeDefaultUser(&nuInfo.uidUserID);
    MU_SwitchToUser(nuInfo.szUsername);

    AStringFromGUID(&nuInfo.uidUserID,  szUid, ARRAYSIZE(szUid));
    wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);
}

void FixMissingIdentityNames()
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType, dwValue;
    BOOL    fFound = FALSE;
    TCHAR   szKeyNameBuffer[MAX_PATH];
	TCHAR	szUsername[CCH_USERNAME_MAX_LENGTH];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(szUsername);
                dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)szUsername, &dwSize);
                
                if (ERROR_SUCCESS != dwStatus || 0 == szUsername[0])
                {
					lstrcpy(szUsername, "Main Identity");
					dwStatus = RegSetValueEx(hkUserKey, c_szUsername, 0, REG_SZ, (LPBYTE)szUsername, lstrlen(szUsername)+1);
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
}

typedef DWORD (STDAPICALLTYPE *PNetWkstaUserGetInfo)
    (LPWSTR reserved, DWORD level, LPBYTE *bufptr);


#if 0
/*
    _DomainControllerPresent

    Identities are disabled when the machine they are running on is part of a domain, unless 
    there is a policy to explicitly allow them.  This function checks to see if the machine
    is joined to a domain.
*/
BOOL _DomainControllerPresent()
{
    static BOOL fInDomain = FALSE;
    static BOOL fValid = FALSE;
    HINSTANCE  hInst;
    PNetWkstaUserGetInfo pNetWkstaUserGetInfo;
    _WKSTA_USER_INFO_1  *pwui1;

    if (!fValid)
    {
        fValid = TRUE;
        hInst = LoadLibrary(TEXT("NETAPI32.DLL"));

        if (hInst)
        {
            pNetWkstaUserGetInfo = (PNetWkstaUserGetInfo)GetProcAddress(hInst, TEXT("NetWkstaUserGetInfo"));

            if (pNetWkstaUserGetInfo && (pNetWkstaUserGetInfo(NULL, 1, (LPBYTE*)&pwui1) == NOERROR))
            {
                if (pwui1->wkui1_logon_domain && pwui1->wkui1_logon_server && lstrcmpW(pwui1->wkui1_logon_server, pwui1->wkui1_logon_domain) != 0)
                {
                    fInDomain = TRUE;
                }
            }
            FreeLibrary(hInst);
        }
    }
    return fInDomain;
}
#endif

/*
    MU_IdentitiesDisabled

    Returns if identities is disabled due to a policy 
    or whatever.
*/
BOOL MU_IdentitiesDisabled()
{
#ifndef _WIN64
    TCHAR   szPolicyPath[] = "Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Identities";
    HKEY    hkey;
    DWORD   dwValue, dwSize;
    BOOL    fLockedDown = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szPolicyPath, &hkey) == ERROR_SUCCESS)
    { 
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }

    if (!fLockedDown && RegOpenKey(HKEY_CURRENT_USER, szPolicyPath, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }

#ifdef DISABIDENT
    if (!fLockedDown && RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }
#endif //DISABIDENT
#if 0
    // turned off for now, pending determination of whether we even want to
    // have this policy
    if (!fLockedDown && _DomainControllerPresent())
    {
        fLockedDown = TRUE;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, szPolicyPath, &hkey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szEnableDCPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
                fLockedDown = FALSE;

            RegCloseKey(hkey);
        }

        if (fLockedDown && RegOpenKey(HKEY_CURRENT_USER, szPolicyPath, &hkey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szEnableDCPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
                fLockedDown = FALSE;

            RegCloseKey(hkey);
        }
    }
#endif

    return fLockedDown;
#else // _WIN64
	return(TRUE);
#endif // _WIN64
}

static GUID    g_uidLoginOption;
static BOOLEAN g_uidLoginOptionSet;

void  _ResetRememberedLoginOption(void)
{
    g_uidLoginOption = GUID_NULL;
    g_uidLoginOptionSet = FALSE;
}

void  _RememberLoginOption(HWND hwndCombo)
{
    LRESULT dFoundItem;
    TCHAR   szUsername[CCH_IDENTITY_NAME_MAX_LENGTH * 2];
    GUID    uidUser;

    *szUsername = 0;

    g_uidLoginOptionSet = TRUE;

    dFoundItem = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);

    SendMessage(hwndCombo, CB_GETLBTEXT, dFoundItem, (LPARAM)szUsername);
    
    if (FAILED(MU_UsernameToUserId(szUsername, &uidUser)))
        g_uidLoginOption = GUID_NULL;
    else
        g_uidLoginOption = uidUser;
}

DWORD MU_GetDefaultOptionIndex(HWND hwndCombo)
{
    GUID        uidStart, uidDefault;
    USERINFO    uiDefault;
    DWORD       dwResult = 0;

    if (MU_GetDefaultUserID(&uidDefault))
    {
        MU_GetUserInfo(&uidDefault, &uiDefault);

        if (uiDefault.szUsername[0])
        {
            dwResult = (DWORD)SendMessage(hwndCombo, CB_FINDSTRING, 0, (LPARAM)uiDefault.szUsername);
        }
    }
    return dwResult;
}

DWORD MU_GetLoginOptionIndex(HWND hwndCombo)
{
    GUID        uidStart, uidDefault;
    USERINFO    uiLogin;
    DWORD       dwResult = ASK_BEFORE_LOGIN;

    if (GUID_NULL == g_uidLoginOption)
    {
        if (g_uidLoginOptionSet)
            goto exit;

        MU_GetLoginOption(&uidStart);
    }
    else
        uidStart = g_uidLoginOption;
    
    if (uidStart == GUID_NULL)
        goto exit;

    if(!MU_GetUserInfo(&uidStart, &uiLogin))
        goto exit;

    dwResult = (DWORD)SendMessage(hwndCombo, CB_FINDSTRING, 0, (LPARAM)uiLogin.szUsername);
exit:
    return dwResult;
}
/*
    MU_GetLoginOption

    return the user's choice for what should happen when there is no current 
    user
*/

void MU_GetLoginOption(GUID *puidStartAs)
{
    HKEY    hkey;
    DWORD   dwSize;
    TCHAR   szUid[255];
    GUID    uidUser;

    ZeroMemory(puidStartAs, sizeof(GUID));
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szUid);
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szLoginAs, 0, NULL, (LPBYTE)szUid, &dwSize))
            MU_GetDefaultUserID(puidStartAs);
        else
            GUIDFromAString(szUid, puidStartAs);

        RegCloseKey(hkey);
    }
}

/*
    MU_SetLoginOption

    return the user's choice for what should happen when there is no current 
    user
*/

BOOL MU_SetLoginOption(HWND hwndCombo,  LRESULT dOption)
{
    HKEY    hkey;
    BOOL    fResult = FALSE;
    TCHAR   szUsername[CCH_IDENTITY_NAME_MAX_LENGTH * 2];
    TCHAR   szUid[255];
    GUID    uidUser;


    SendMessage(hwndCombo, CB_GETLBTEXT, dOption, (LPARAM)szUsername);
    
    if (dOption == (LRESULT)ASK_BEFORE_LOGIN || FAILED(MU_UsernameToUserId(szUsername, &uidUser)))
    {
        ZeroMemory(&uidUser, sizeof(uidUser));
    }
    AStringFromGUID(&uidUser,  szUid, sizeof(szUid));
    
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        fResult = (ERROR_SUCCESS == RegSetValueEx(hkey, c_szLoginAs, 0, REG_SZ, (LPBYTE)szUid, lstrlen(szUid)+1));

        RegCloseKey(hkey);
    }

    return TRUE;
}


/*
    MU_CanEditIdentity

    Is the current identity allowed to edit the indicated identity's settings?
*/
BOOL MU_CanEditIdentity(HWND hwndParent, GUID *puidIdentityId)
{
#ifndef IDENTITY_PASSWORDS
    return TRUE;
#else
    USERINFO        uiCurrent, uiQuery;
    TCHAR           szBuffer[255];    // really ought to be big enough
    TCHAR           szString[255+CCH_USERNAME_MAX_LENGTH];
    BOOL            fResult = FALSE;
    PASSWORD_STORE  pwStore;

    ZeroMemory(&uiQuery, sizeof(USERINFO));

    if (MU_GetUserInfo(puidIdentityId, &uiQuery))
    {
        if (!uiQuery.fPasswordValid)
        {
            MU_ShowErrorMessage(hwndParent, idsPwdNotFound, idsPwdError);
            return FALSE;
        }

        if (uiQuery.szPassword[0] == 0)
        {
            return TRUE;    
        }
        
        if (MU_GetUserInfo(NULL, &uiCurrent))
        {
            if (uiCurrent.uidUserID == uiQuery.uidUserID)
                return TRUE;
        }
    }
    else
        return FALSE;

    MLLoadStringA(idsConfirmEdit, szBuffer, sizeof(szBuffer));

    wsprintf(szString, szBuffer, uiQuery.szUsername);

    fResult = MU_ConfirmUserPassword(hwndParent, szString, uiQuery.szPassword);

    return fResult;
#endif //IDENTITY_PASSWORDS
}

static BOOL _DirectoryIdInUse(DWORD dwId)
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType, dwValue;
    BOOL    fFound = FALSE;
    TCHAR   szKeyNameBuffer[MAX_PATH];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwValue);
                dwStatus = RegQueryValueEx(hkUserKey, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);
                
                if (ERROR_SUCCESS == dwStatus && dwValue == dwId)
                {
                    fFound = TRUE;
                    RegCloseKey(hkUserKey); 
                    break;
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
    

    return fFound;
}


DWORD   MU_GenerateDirectoryNameForIdentity(GUID *puidIdentityId)
{   
    DWORD dwId, dwRegValue;

    dwId = puidIdentityId->Data1;

    while (_DirectoryIdInUse(dwId))
        dwId++;

    return dwId;
}

HRESULT MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId)
{
    TCHAR   szRegPath[MAX_PATH];
    HKEY    hkey;
    HRESULT hr = E_FAIL;
    DWORD   dwSize, dwStatus, dwValue, dwType;

    MU_GetRegRootForUserID(puidIdentityId, szRegPath);

    if (RegOpenKey(HKEY_CURRENT_USER, szRegPath, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        dwStatus = RegQueryValueEx(hkey, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);
    
        if (ERROR_SUCCESS == dwStatus)
        {
            *pdwDirId = dwValue;
            hr = S_OK;
        }
        else
        {
            // try to generate one
            dwValue = MU_GenerateDirectoryNameForIdentity(puidIdentityId);
        
            dwType = REG_DWORD;
            dwSize = sizeof(dwValue);
            dwStatus = RegSetValueEx(hkey, c_szDirName, 0, dwType, (LPBYTE)&dwValue, dwSize);

            if (ERROR_SUCCESS == dwStatus)
            {
                *pdwDirId = dwValue;
                hr = S_OK;
            }
        }
        RegCloseKey(hkey);
    }

    return hr;
}


void _MigratePasswords()
{
    CStringList *psList;
    int   i, iCount = 0;
	USERINFO uiUser;
	DWORD dwStatus, dwValue, dwType, dwSize;

	dwType = REG_DWORD;
	dwSize = sizeof(DWORD);
	dwStatus = SHGetValue(HKEY_CURRENT_USER, c_szRegRoot, c_szMigrated5, &dwType, &dwValue, &dwSize);	

	if (dwStatus == ERROR_SUCCESS && dwValue == 1)
		return;
		
    psList = MU_GetUsernameList();

    if (psList)
    {
        iCount = psList->GetLength();

		for (i = 0; i < iCount; i++)
		{
			GUID	uidUser;
			if (SUCCEEDED(MU_UsernameToUserId(psList->GetString(i), &uidUser)) 
				&& MU_GetUserInfo(&uidUser, &uiUser))
			{
				if (!uiUser.fPasswordValid)
				{
					uiUser.fUsePassword = false;
					*uiUser.szPassword = 0;
					MU_SetUserInfo(&uiUser);
				}
			}
		}
        delete psList;
    }

	dwValue = 1;
	SHSetValue(HKEY_CURRENT_USER, c_szRegRoot, c_szMigrated5, REG_DWORD, &dwValue, sizeof(DWORD));	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiusr.h ===
/************************************************
    MultiUsr.h

    Header for multiple user functionality.

    Initially by Christopher Evans (cevans) 7/16/98
*************************************************/
#ifndef _MULTIUSR_H
#define _MULTIUSR_H


#define CCH_USERPASSWORD_MAX_LENGTH 16
#define CCH_USERNAME_MAX_LENGTH     CCH_IDENTITY_NAME_MAX_LENGTH
typedef struct 
{
    BOOL        fUsePassword;
    BOOL        fPasswordValid;
    GUID        uidUserID;
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    TCHAR       szPassword[CCH_USERPASSWORD_MAX_LENGTH];
}USERINFO, *LPUSERINFO;


typedef struct 
{
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    BOOL        fDeleteMessages;
}DELETEUSERDIALOGINFO, *LPDELETEUSERDIALOGINFO;


typedef struct 
{
    TCHAR        szPassword[CCH_USERPASSWORD_MAX_LENGTH];
    TCHAR        szMsg[255];
}CONFIRMPWDDIALOGINFO, *LPCONFIRMPWDDIALOGINFO;

typedef struct  
{
    BOOL        fUsePassword;
    TCHAR       szPassword[CCH_USERPASSWORD_MAX_LENGTH];
}PASSWORD_STORE;


#define  ID_LOGIN_AS_LAST                       0
#define  ID_LOGIN_ASK_ME                        1

#define ASK_BEFORE_LOGIN    (0xffffffff)

class CStringList
{
public:
                            CStringList();
    virtual                 ~CStringList();

    inline  int             GetLength       (void)      {return m_count;}
            void            AddString       (TCHAR*  lpszInString);
            void            RemoveString    (int    iIndex);
            TCHAR*          GetString       (int    iIndex);   
            void            Sort            ();
private:
    int         m_count;
    int         m_ptrCount;
    TCHAR**      m_strings;      
};

EXTERN_C void   MU_Init();
CStringList*    MU_GetUsernameList(void);
HRESULT         MU_UsernameToUserId(TCHAR *lpszUsername, GUID *puidUserId);
BOOL            MU_GetPasswordForUsername(TCHAR *lpszInUsername, TCHAR *szOutPassword, BOOL *pfUsePassword);
BOOL            MU_UsernameExists(TCHAR*    lpszUsername);
BOOL            MU_GetUserInfo(GUID *puidUserId, LPUSERINFO lpUserInfo);
BOOL            MU_SetUserInfo(LPUSERINFO lpUserInfo);
HRESULT         MU_SwitchToUser(TCHAR *lpszUsername);
void            MU_SwitchToLastUser();
HRESULT         MU_GetUserDirectoryRoot(GUID *uidUserID, DWORD dwFlags, WCHAR   *lpszUserRoot, int cch);
ULONG           MU_CountUsers(void);
HRESULT         MU_GetRegRootForUserID(GUID *puidUserId, LPSTR pszPath);
HRESULT         MU_CreateUser(LPUSERINFO   lpUserInfo);
HRESULT         MU_DeleteUser(GUID *puidUserId);
LPCTSTR         MU_GetRegRoot();
HRESULT         MU_MakeDefaultUser(GUID *puidUserId);
BOOL            MU_GetCurrentUserID(GUID *puidUserId);
BOOL            MU_GetDefaultUserID(GUID *puidUserId);
BOOL            MU_UserIdToUsername(GUID *puidUserId, TCHAR *lpszUsername, ULONG cch);
BOOL            MU_IdentitiesDisabled();
DWORD           MU_GetDefaultOptionIndex(HWND hwndCombo);
DWORD           MU_GetLoginOptionIndex(HWND hwndCombo);
void            MU_GetLoginOption(GUID *puidStartAs);
BOOL            MU_SetLoginOption(HWND hwndCombo,  LRESULT dOption);
BOOL            MU_CanEditIdentity(HWND hwndParent, GUID *puidIdentityId);
DWORD           MU_GenerateDirectoryNameForIdentity(GUID *puidIdentityId);
HRESULT         MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId);
HRESULT         MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId);
HRESULT         _ClaimNextUserId(GUID *puidUserId);
void            _MakeDefaultFirstUser();
BOOL            _FillListBoxWithUsernames(HWND hListbox);
BOOL            _FillComboBoxWithUsernames(HWND hCombobox, HWND hListbox);
void            _ResetRememberedLoginOption(void);
void            _RememberLoginOption(HWND hwndCombo);
void            _MigratePasswords();

#endif _MULTIUSR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\private.h ===
#include <windows.h>
#include <ole2.h>
#include <docobj.h>
#include <advpub.h>
#include <initguid.h>
#include "msident.h"
#include "factory.h"
#include "multiutl.h"
#include <ocidl.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

#ifndef ASSERT
#ifdef DEBUG
#define ASSERT	Assert
#else
#define ASSERT(x)
#endif
#endif

#define IDENTITY_PASSWORDS
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

extern ULONG    g_cLock, g_cObj;
extern HANDLE   g_hMutex;
extern GUID     g_uidOldUserId;
extern GUID     g_uidNewUserId;
extern BOOL     g_fNotifyComplete;

inline ULONG DllLock()     { return ++g_cLock; }
inline ULONG DllUnlock()   { return --g_cLock; }
inline ULONG DllGetLock()  { return g_cLock; }

inline ULONG DllAddRef()   { return ++g_cObj; }
inline ULONG DllRelease()  { return --g_cObj; }
inline ULONG DllGetRef()   { return g_cObj; }

extern UINT WM_IDENTITY_CHANGED;
extern UINT WM_QUERY_IDENTITY_CHANGE;
extern UINT WM_IDENTITY_INFO_CHANGED;

#define CCH_USERPASSWORD_MAX_LENGTH         16
#define CCH_USERNAME_MAX_LENGTH             CCH_IDENTITY_NAME_MAX_LENGTH

//
// CUserIdentity object
//
class CUserIdentity : public IUserIdentity2
{
protected:
    ULONG           m_cRef;
    GUID            m_uidCookie;
    BOOL            m_fSaved;
    BOOL            m_fUsePassword;
    TCHAR           m_szUsername[CCH_USERNAME_MAX_LENGTH];
    TCHAR           m_szPassword[CCH_USERPASSWORD_MAX_LENGTH];


public:
    CUserIdentity();
    ~CUserIdentity();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IUserIdentity members
    STDMETHODIMP         GetCookie(GUID *puidCookie);
    STDMETHODIMP         OpenIdentityRegKey(DWORD dwDesiredAccess, HKEY *phKey);
    STDMETHODIMP         GetIdentityFolder(DWORD dwFlags, WCHAR *pszPath, ULONG ulBuffSize);
    STDMETHODIMP         GetName(WCHAR *pszName, ULONG ulBuffSize);

    // IUserIdentity2 members
    STDMETHODIMP         GetOrdinal(DWORD* pdwOrdinal);
    STDMETHODIMP         SetName(WCHAR *pszName);
    STDMETHODIMP         ChangePassword(WCHAR *szOldPass, WCHAR *szNewPass);

    // Other members
    STDMETHODIMP         SetPassword(WCHAR *pszPassword);
    STDMETHODIMP         InitFromUsername(TCHAR *pszUsername);
    STDMETHODIMP         InitFromCookie(GUID *uidCookie);
private:
    STDMETHODIMP         _SaveUser();
};

//
// CEnumUserIdentity object
//
class CEnumUserIdentity : public IEnumUserIdentity
{
protected:
    ULONG           m_cRef;
    DWORD           m_dwCurrentUser;     // Maintain current index into the reg list
    DWORD           m_cCountUsers;      // number of accounts in the registry
    GUID           *m_rguidUsers;
    BOOL            m_fInited;

public:
    CEnumUserIdentity();
    ~CEnumUserIdentity();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumUserIdentity members
    STDMETHODIMP         Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP         Skip(ULONG celt);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumUserIdentity **ppenum);
    STDMETHODIMP         GetCount(ULONG *pnCount);

private:
    // Other methods
    STDMETHODIMP         _Init();
    STDMETHODIMP         _Init(DWORD dwCurrentUser, DWORD dwCountUsers, GUID *prguidUserCookies);
    STDMETHODIMP         _Cleanup();
};


//
// CUserIdentityManager object
//
class CUserIdentityManager :
    public IUserIdentityManager,
    public IConnectionPoint,
    public IPrivateIdentityManager,
    public IPrivateIdentityManager2
{
protected:
    ULONG               m_cRef;
    CRITICAL_SECTION    m_rCritSect;
    CNotifierList       *m_pAdviseRegistry;
	BOOL				m_fWndRegistered;
	HWND				m_hwnd;

public:
    CUserIdentityManager();
    ~CUserIdentityManager();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IUserIdentityManager members
    STDMETHODIMP        EnumIdentities(IEnumUserIdentity **ppEnumUserIdentity);
    STDMETHODIMP        ManageIdentities(HWND hwndParent, DWORD dwFlags);
    STDMETHODIMP        Logon(HWND hwndParent, DWORD dwFlags, IUserIdentity **ppUserIdentity);
    STDMETHODIMP        Logoff(HWND hwndParent);
    STDMETHODIMP        GetIdentityByCookie(GUID *uidCookie, IUserIdentity **ppUserIdentity);

    // IConnectionPoint functions
    STDMETHODIMP        GetConnectionInterface(IID *pIID);        
    STDMETHODIMP        GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    STDMETHODIMP        Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        
    STDMETHODIMP        Unadvise(DWORD dwCookie);        
    STDMETHODIMP        EnumConnections(IEnumConnections **ppEnum);

    // IPrivateIdentityManager functions
    STDMETHODIMP        CreateIdentity(WCHAR *pszName, IUserIdentity **ppIdentity);
    STDMETHODIMP        ConfirmPassword(GUID *uidCookie, WCHAR *pszPassword);

    // IPrivateIdentityManager2 functions
    STDMETHODIMP        CreateIdentity2(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity);
    STDMETHODIMP        DestroyIdentity(GUID *uidCookie);
    STDMETHODIMP        LogonAs(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity);
    STDMETHODIMP        SetDefaultIdentity(GUID *uidCookie);
    STDMETHODIMP        GetDefaultIdentity(GUID *uidCookie);

    // Other methods
    STDMETHODIMP        QuerySwitchIdentities();
    STDMETHODIMP        NotifySwitchIdentities();

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static STDMETHODIMP     ClearChangingIdentities();

private:
    STDMETHODIMP        _NotifyIdentitiesSwitched();
    STDMETHODIMP        _QueryProcessesCanSwitch();
    STDMETHODIMP        _CreateWindowClass();
    STDMETHODIMP        _SwitchToUser(GUID *puidFromUser, GUID *puidToUser);
    STDMETHODIMP        _PersistChangingIdentities();
    STDMETHODIMP        _LoadChangingIdentities();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiui.h ===
/************************************************
    MultiUI.h

    Header for multiple user functionality.

    Initially by Christopher Evans (cevans) 7/16/98
*************************************************/
#ifndef _MULTIUI_H
#define _MULTIUI_H
#include "multiusr.h"


#define     IDH_IDENTITY_NAME                   50100
#define     IDH_IDENTITY_MANAGE                 50140
#define     IDH_IDENTITY_LIST                   50155
#define     IDH_IDENTITY_DELETE                 50165
#define     IDH_IDENTITY_ADD                    50175
#define     IDH_IDENTITY_PROPERTIES             50180
#define     IDH_IDENTITY_DEFAULT                50185
#define     IDH_IDENTITY_STARTAS                50190
#define     IDH_IDENTITY_PROMPT_PWORD           50105 //Add new identity; ask for password
#define     IDH_IDENTITY_ENTER_PWORD            50110 //Add new identity; password
#define     IDH_IDENTITY_CONFIRM_PWORD          50115 //Add new identity; confirm password
#define     IDH_IDENTITY_ASK_PWORD              50125 //Change user; ask for pword
#define     IDH_IDENTITY_CHANGE_PWORD           50130 //Change user; change pword button
#define     IDH_IDENTITY_PWORD_OLD              50145 //Change user; old pword
#define     IDH_IDENTITY_PWORD_NEW              50150 //Change user; new pword
#define     IDH_IDENTITY_DELETE_PWORD           50170
#define     IDH_IDENTITY_TELLMEMORE             50195  
#define     IDH_IDENTITY_TELLMEMORE_CONTENT     50200
#define     IDH_MULTI_LOG_OFF                   50120 
#define     IDH_MULTI_MNG_IDENT_DEFAULT	        50185
#define     IDH_MULTI_MNG_DEFAULT_LIST          50160
#define     IDH_MULTI_DELETE_PWORD	            50170

#define  ID_LOGIN_AS_LAST                       0
#define  ID_LOGIN_ASK_ME                        1

void            MU_ShowErrorMessage(HWND hwnd, UINT iMsgID, UINT iTitleID);

BOOL            MU_CreateNewUser(HWND  hwnd, LPUSERINFO  lpUserInfo);
BOOL CALLBACK   AddUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK   ChangeUserPwdDlgProc(HWND   hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_ChangeUserPassword(HWND hwnd, TCHAR *lpszOldNewPassword);
BOOL CALLBACK   EnterUserPwdDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_EnterUserPassword(HWND hwnd, TCHAR *lpszNewPassword);
BOOL CALLBACK   ConfirmUserPwdDlgProc(HWND hDlg, UINT iMsg, WPARAM  wParam, LPARAM  lParam);
BOOL            MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword);
BOOL CALLBACK   DeleteUserDlgProc(HWND  hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_GetUserToDelete(HWND hwnd, LPDELETEUSERDIALOGINFO lpszOutUserInfo);
BOOL CALLBACK   ConfirmDeleteUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_ConfirmDeleteUser(HWND hwnd, TCHAR *lpszUsername);
BOOL            MU_Login(HWND hwnd, DWORD dwFlags, TCHAR *lpszUsername); 
BOOL            MU_ChangeUserSettings(HWND hwnd, LPUSERINFO lpUserInfo);
BOOL            MU_ManageUsers(HWND hwnd, TCHAR *lpszUsername, DWORD dwFlags); 
BOOL            MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword);
void            _StripDefault(LPSTR psz);


#endif //_MULTIUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiutl.h ===
#ifndef __MULTIUTL_H
#define __MULTIUTL_H

#include <assert.h>
#include "objidl.h"
#include <pstore.h>
#include "multiusr.h"

#ifndef Assert
#ifdef DEBUG
#define Assert(a)		assert(a)
#define SideAssert(a)	Assert(a)
#define AssertSz(a, sz) Assert(a)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#else	// DEBUG
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define Assert(a)
#define SideAssert(a)	(a)
#define AssertSz(a, sz) 
#endif	// DEBUG, else

#endif

#ifdef UNICODE
#define FIsSpace            FIsSpaceW
#else
#define FIsSpace            FIsSpaceA
#endif


// Context-sensitive Help utility.
typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);


ULONG UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
void    EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
void    DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
STDAPI WriteIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore);
STDAPI  ReadIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore);
STDAPI  CreatePStore(IPStore **ppIPStore);
STDAPI  ReleasePStore(IPStore *pIPStore);



// --------------------------------------------------------------------------------
// SafeRelease - Releases an object and sets the object to NULL
// --------------------------------------------------------------------------------
#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

void       MemFree(void* pv);
BOOL       MemAlloc(void** ppv, ULONG cb);
BOOL       MemRealloc(void** ppv, ULONG cbNew);

// --------------------------------------------------------------------------------
// TraceCall(_pszFunc)
// -------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C void DebugStrf(LPTSTR lpszFormat, ...);
#endif

#if defined(FULL_DEBUG)
#define TraceCall(_pszFunc) DebugStrf("%s\r\n", _pszFunc)
#else
#define TraceCall(_pszFunc)
#endif

// --------------------------------------------------------------------------------
// GUID <-> Ascii string functions
// --------------------------------------------------------------------------------
HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid);
int     AStringFromGUID(GUID *rguid,  TCHAR *lpsz, int cch);

typedef enum 
{
    NS_NONE = 0,
    NS_PRE_NOTIFY,
    NS_NOTIFIED
} NOTIFICATION_STATE;

typedef struct tagUNKLIST_ENTRY
{
    HWND        hwnd;
    DWORD       dwThreadId;
    DWORD       dwCookie;
    BYTE        bState;
    IUnknown   *punk;
} UNKLIST_ENTRY;

class CNotifierList
{
public:
                            CNotifierList();
    virtual                 ~CNotifierList();

    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    inline  DWORD           GetLength(void)      {return m_count;}
            HRESULT         Add(IUnknown *punk, DWORD *pdwCookie);
            HRESULT         RemoveCookie(DWORD dwCookie);
            HRESULT         Remove(int iIndex);
            HRESULT         GetAtIndex(int iIndex, IUnknown **ppunk);  
            HRESULT         CreateNotifyWindow();
            HRESULT         ReleaseWindow();
            HRESULT         SendNotification(UINT msg, DWORD dwType);
            HRESULT         PreNotify();
            int             GetNextNotify();
private:
    ULONG               m_cRef;
    int                 m_count;
    int                 m_ptrCount;
    DWORD               m_nextCookie;
    UNKLIST_ENTRY      *m_entries;      
    CRITICAL_SECTION    m_rCritSect;
};



#endif  //__MULTIUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\multiutl.cpp ===
#include "private.h"
#include "multiutl.h"
#include <wtypes.h>
#include "strconst.h"
#include <platform.h>

extern      HINSTANCE   g_hInst;

// Pstore related variables.
static PST_KEY s_Key = PST_KEY_CURRENT_USER;

// {89C39569-6841-11d2-9F59-0000F8085266}
static const GUID GUID_PStoreType = { 0x89c39569, 0x6841, 0x11d2, { 0x9f, 0x59, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66 } };
static WCHAR c_szIdentityMgr[] = L"IdentityMgr";
static WCHAR c_szIdentities[] = L"Identities";
static WCHAR c_szIdentityPass[] = L"IdentitiesPass";

//Need these private implementations
//OE has dependency on the particular allocator used

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return CoTaskMemAlloc(nSize);
}

void  __cdecl operator delete(void *pv)
{
    //If changed to GlobalFree or HeapFree - must check for NULL here
    CoTaskMemFree(pv);
}

extern "C" int __cdecl _purecall(void) 
{
    DebugBreak();
    return 0;
}


// --------------------------------------------------------------------------
// FIsSpaceA
// --------------------------------------------------------------------------
BOOL FIsSpaceA(LPSTR psz)
{
#ifdef MAC
    return (isspace(*psz));
#else	// !MAC
    WORD wType;

    if (IsDBCSLeadByte(*psz))
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType);
    else
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
#endif	// MAC
}

// --------------------------------------------------------------------------
// FIsSpaceW
// --------------------------------------------------------------------------
BOOL FIsSpaceW(LPWSTR psz)
{
#ifdef MAC
    // Maybe we should convert to ANSI before checking??
    return (isspace(*( ( (TCHAR *) psz ) + 1 ) ));
#else	// !MAC
    WORD wType;
    GetStringTypeExW(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
#endif	// !MAC
}


ULONG UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb)
{
    // Locals
    ULONG           cb;
    LPTSTR          psz;
    
    Assert(lpsz != NULL);
    Assert(fLeading || fTrailing);
    
    // Did the user pass in the length
    if (pcb)
        cb = *pcb;
    else
        cb = lstrlen (lpsz);
    
    if (cb == 0)
        return cb;
    
    if (fLeading)
    {
        psz = lpsz;
        
        while (FIsSpace(psz))
        {
            psz++;
            cb--;
        }
        
        if (psz != lpsz)
            // get the NULL at the end too
            MoveMemory(lpsz, psz, (cb + 1) * sizeof(TCHAR));
    }
    
    if (fTrailing)
    {
        psz = lpsz + cb;
        
        while (cb > 0)
        {
            if (!FIsSpace(psz-1))
                break;
            psz--;
            cb--;
        }    
        
        // NULL Term
        *psz = '\0';
    }
    
    // Set String Size
    if (pcb)
        *pcb = cb;
    
    // Done
    return cb;
}

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            WinHelp ((HWND)lphi->hItemHandle,
                        c_szCtxHelpFile,
                        HELP_WM_HELP,
                        (DWORD_PTR)(void*)rgCtxMap);
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU)
    {
        WinHelp ((HWND) wParam,
                    c_szCtxHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(void*)rgCtxMap);
        return (TRUE);
    }

    Assert(0);

    return FALSE;
}



#define OBFUSCATOR              0x14151875;

#define PROT_SIZEOF_HEADER      0x02    // 2 bytes in the header
#define PROT_SIZEOF_XORHEADER   (PROT_SIZEOF_HEADER+sizeof(DWORD))

#define PROT_VERSION_1          0x01

#define PROT_PASS_XOR           0x01
#define PROT_PASS_PST           0x02

static BOOL FDataIsValidV1(BYTE *pb)
{ return pb && pb[0] == PROT_VERSION_1 && (pb[1] == PROT_PASS_XOR || pb[1] == PROT_PASS_PST); }

static BOOL FDataIsPST(BYTE *pb)
{ return pb && pb[1] == PROT_PASS_PST; }

///////////////////////////////////////////////////////////////////////////
// 
// NOTE - The functions for encoding the user passwords really should not 
//        be here.  Unfortunately, they are not anywhere else so for now,
//        this is where they will stay.  They are defined as static since
//        other code should not rely on them staying here, particularly the 
//        XOR stuff.
//
///////////////////////////////////////////////////////////////////////////
// 
// XOR functions
//
///////////////////////////////////////////////////////////////////////////

static HRESULT _XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded)
{
    DWORD       dwSize;
    DWORD       last, last2;
    DWORD       UNALIGNED *pdwCypher;
    DWORD       dex;

    pEncoded->cbSize = pClear->cbSize+PROT_SIZEOF_XORHEADER;
    if (!MemAlloc((void* *)&pEncoded->pBlobData, pEncoded->cbSize + 6))
        return E_OUTOFMEMORY;
    
    // set up header data
    Assert(2 == PROT_SIZEOF_HEADER);
    pEncoded->pBlobData[0] = PROT_VERSION_1;
    pEncoded->pBlobData[1] = PROT_PASS_XOR;
    *((DWORD UNALIGNED *)&(pEncoded->pBlobData[2])) = pClear->cbSize;

    // nevermind that the pointer is offset by the header size, this is
    // where we start to write out the modified password
    pdwCypher = (DWORD UNALIGNED *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;                              // 0' = 0 ^ ob
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            {
            last2 = ((DWORD UNALIGNED *)pClear->pBlobData)[dex];  // 1 
            pdwCypher[dex] = last2 ^ last;              // 1' = 1 ^ 0
            last = last2;                   // save 1 for the 2 round
            }
        }

    // if we have bits left over
    // note that dwSize is computed now in bits
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        pdwCypher[dex] &= ((DWORD)-1) << dwSize;
        pdwCypher[dex] |=
            ((((DWORD UNALIGNED *)pClear->pBlobData)[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

static HRESULT _XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear)
{
    DWORD       dwSize;
    DWORD       last;
    DWORD       UNALIGNED *pdwCypher;
    DWORD       dex;

    // we use CoTaskMemAlloc to be in line with the PST implementation
    pClear->cbSize = *(DWORD UNALIGNED *)(&pEncoded->pBlobData[2]);
    MemAlloc((void **)&pClear->pBlobData, pClear->cbSize);
    if (!pClear->pBlobData)
        return E_OUTOFMEMORY;
    
    // should have been tested by now
    Assert(FDataIsValidV1(pEncoded->pBlobData));
    Assert(!FDataIsPST(pEncoded->pBlobData));

    // nevermind that the pointer is offset by the header size, this is
    // where the password starts
    pdwCypher = (DWORD UNALIGNED *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            last = ((DWORD UNALIGNED *)pClear->pBlobData)[dex] = pdwCypher[dex] ^ last;
        }

    // if we have bits left over
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        ((DWORD UNALIGNED *)pClear->pBlobData)[dex] &= ((DWORD)-1) << dwSize;
        ((DWORD UNALIGNED *)pClear->pBlobData)[dex] |=
                ((pdwCypher[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

/*
    EncodeUserPassword

    Encrypt the passed in password.  This encryption seems to
    add an extra 6 bytes on to the beginning of the data
    that it passes back, so we need to make sure that the 
    lpszPwd is large enough to hold a few extra characters.
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, a c string containing the password.
    on exit, it is the encrypted data, plus some header info.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would enter with *cb == 4.
*/
void EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XOREncodeProp(&blobClient, &blobProp);
    
    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}

/*
    DecodeUserPassword

    Decrypt the passed in data and return a password.  This 
    encryption seems to add an extra 6 bytes on to the beginning 
    so decrupting will result in a using less of lpszPwd.
    .
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, the encrypted password plus some 
    header info. 
    on exit, a c string containing the password.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would leave with *cb == 4.
*/
void DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XORDecodeProp(&blobClient, &blobProp);

    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        lpszPwd[blobProp.cbSize] = 0;
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}


// --------------------------------------------------------------------------------
// MemInit
// --------------------------------------------------------------------------------
void MemInit()
{
}

// --------------------------------------------------------------------------------
// MemUnInit
// --------------------------------------------------------------------------------
void MemUnInit()
{
}


// --------------------------------------------------------------------------------
// MemFree
// --------------------------------------------------------------------------------
void MemFree(void* pv) 
{
    CoTaskMemFree(pv);
}

// --------------------------------------------------------------------------------
// MemAlloc
// --------------------------------------------------------------------------------
BOOL MemAlloc(void** ppv, ULONG cb) 
{
    assert(ppv && cb);
    *ppv = CoTaskMemAlloc(cb);
    if (NULL == *ppv)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// MemRealloc
// --------------------------------------------------------------------------------
BOOL MemRealloc(void* *ppv, ULONG cbNew) 
{
    assert(ppv && cbNew);
    void* pv = CoTaskMemRealloc(*ppv, cbNew);
    if (NULL == pv)
        return FALSE;
    *ppv = pv;
    return TRUE;
}

// --------------------------------------------------------------------------------
//  Functions to convert GUIDs to ascii strings
// --------------------------------------------------------------------------------

int AStringFromGUID(GUID *puid,  TCHAR *lpsz, int cch)
{
    WCHAR   wsz[255];
    int     i;

    i = StringFromGUID2(*puid, wsz, 255);

    if (WideCharToMultiByte(CP_ACP, 0, wsz, -1, lpsz, cch, NULL, NULL) == 0)
        return 0;
    
    return (lstrlen(lpsz) + 1);
}


HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid)
{
    WCHAR   wsz[255];
    HRESULT hr;

    if (MultiByteToWideChar(CP_ACP, 0, lpsz, -1, wsz, 255) == 0)
        return GetLastError();

    hr = CLSIDFromString(wsz, puid);
    
    return hr;
}



// ****************************************************************************************************
//  CNotifierList Class
//
//  A really basic IUnknown list class.  Actually, its a IUnknown array class, but you don't need to know
//  that.
//


CNotifierList::CNotifierList()
{
    m_count = 0;
    m_ptrCount = 0;
    m_entries = NULL;
    m_nextCookie = 1;
    m_cRef = 1;
    InitializeCriticalSection(&m_rCritSect);
}

/*
    CNotifierList::~CNotifierList

    Clean up any memory that was allocated in the CNotifierList object
*/
CNotifierList::~CNotifierList()
{
    if (m_entries)
    {
        for (int i = 0; i < m_count; i++)
        {
            if (m_entries[i].punk)
            {
                m_entries[i].punk->Release();
                m_entries[i].punk = NULL;
                m_entries[i].dwCookie = 0;
            }
        }
        MemFree(m_entries);
        m_entries = NULL;
        m_count = 0;
    }
    DeleteCriticalSection(&m_rCritSect);
}


STDMETHODIMP_(ULONG) CNotifierList::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CNotifierList::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

/*
    CNotifierList::Add

    Add a IUnknown to the end of the IUnknown list.
*/
HRESULT    CNotifierList::Add(IUnknown *punk, DWORD *pdwCookie)
{
    TraceCall("Identity - CNotifierList::Add");

    EnterCriticalSection(&m_rCritSect);
    // make more room for pointers, if necessary
    if (m_ptrCount == m_count)
    {
        m_ptrCount += 5;
        if (!MemRealloc((void **)&m_entries, sizeof(UNKLIST_ENTRY) * m_ptrCount))
        {
            m_ptrCount -= 5;
            Assert(false);
            LeaveCriticalSection(&m_rCritSect);    
            return E_OUTOFMEMORY;
        }

        // initialize the new IUnknowns to nil
        for (int i = m_count; i < m_ptrCount; i++)
        {
            ZeroMemory(&m_entries[i], sizeof(UNKLIST_ENTRY));
        }
    }
    
    //now put the IUnknown in the next location
    int iNewIndex = m_count++;
    
    punk->AddRef();
    m_entries[iNewIndex].punk = punk;
    m_entries[iNewIndex].bState = NS_NONE;
    m_entries[iNewIndex].dwCookie = ++m_nextCookie;
    m_entries[iNewIndex].dwThreadId = GetCurrentThreadId();
    *pdwCookie = m_entries[iNewIndex].dwCookie;
    LeaveCriticalSection(&m_rCritSect);  
    CreateNotifyWindow();
    return S_OK;
}

/*
    CNotifierList::Remove
    
    Remove a IUnknown at zero based index iIndex 
*/

HRESULT CNotifierList::Remove(int   iIndex)
{
    int     iCopySize;

    TraceCall("Identity - CNotifierList::Remove");

    EnterCriticalSection(&m_rCritSect);
    iCopySize = ((m_count - iIndex) - 1) * sizeof(UNKLIST_ENTRY);

    // free the memory for the IUnknown
    if (m_entries[iIndex].punk)
    {
        ReleaseWindow();
        m_entries[iIndex].punk->Release();
        ZeroMemory(&m_entries[iIndex], sizeof(UNKLIST_ENTRY));
    }

    // move the other IUnknowns down
    if (iCopySize)
    {
        memmove(&(m_entries[iIndex]), &(m_entries[iIndex+1]), iCopySize);
    }

    // null out the last item in the list and decrement the counter.
    m_entries[--m_count].punk = NULL;
    LeaveCriticalSection(&m_rCritSect); 
    return S_OK;
}

/*
    CNotifierList::RemoveCookie
    
    Remove an IUnknown by its cookie
*/

HRESULT    CNotifierList::RemoveCookie(DWORD dwCookie)
{
    int     iIndex;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwCookie == dwCookie)
        {
            return Remove(iIndex);
        }
    }
    return E_FAIL;
}

/*
    CNotifierList::GetAtIndex
    
    Return the pointer to the IUnknown at zero based index iIndex.

    Return the IUnknown at the given index.  Note that the object pointer
    is still owned by the IUnknown list and should not be deleted.
*/

HRESULT     CNotifierList::GetAtIndex(int iIndex, IUnknown **ppunk)
{
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&m_rCritSect);
    if (iIndex < m_count && iIndex >= 0 && m_entries[iIndex].punk)
    {
        *ppunk = m_entries[iIndex].punk;
        (*ppunk)->AddRef();
        hr = S_OK;
    }
    else
        *ppunk = NULL;

    LeaveCriticalSection(&m_rCritSect);    
    return hr;
}


HRESULT     CNotifierList::CreateNotifyWindow()
{
    DWORD   dwThreadCount = 0;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    int     iFound = -1;
    HWND    hwnd = NULL;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId)
        {
            iFound  = iIndex;
            if (!hwnd)
                hwnd = m_entries[iIndex].hwnd;
            else
            {
                Assert(NULL == m_entries[iIndex].hwnd || hwnd == m_entries[iIndex].hwnd);
                m_entries[iIndex].hwnd = hwnd;
            }
            dwThreadCount++;
        }
    }
    
    if (dwThreadCount == 1 && iFound >= 0)
    {
        hwnd = m_entries[iFound].hwnd = CreateWindowA(c_szNotifyWindowClass, c_szNotifyWindowClass, WS_POPUP, 
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, 
                    NULL, g_hInst, this);
        
        if (m_entries[iFound].hwnd)
            SetWindowLongPtr(m_entries[iFound].hwnd, GWLP_USERDATA, (LRESULT)this);
    }
    return (hwnd ? S_OK : E_FAIL);
}


HRESULT     CNotifierList::ReleaseWindow()
{
    DWORD   dwThreadCount = 0;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    HWND    hwnd = NULL;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId)
        {
            if (dwThreadCount == 0)
                hwnd = m_entries[iIndex].hwnd;
            dwThreadCount++;
        }
    }
    
    if (dwThreadCount == 1 && hwnd)
    {
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return S_OK;
}

HRESULT     CNotifierList::PreNotify()
{
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;

    for (iIndex = m_count -1; iIndex >= 0; iIndex--)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId && NULL != m_entries[iIndex].punk)
            m_entries[iIndex].bState = NS_PRE_NOTIFY;
//        else          //BUG 47472, this could cause problems during re-entrant calls to SendNotification
//            m_entries[iIndex].bState = NS_NONE;
    }
    return S_OK;
}

int     CNotifierList::GetNextNotify()
{
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    for (iIndex = m_count -1; iIndex >= 0; iIndex--)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId && NULL != m_entries[iIndex].punk && NS_PRE_NOTIFY == m_entries[iIndex].bState)
            return iIndex;
    }
    return -1;
}

HRESULT     CNotifierList::SendNotification(UINT msg, DWORD dwType)
{
    DWORD   dwThreadCount = 0, dwOldCount;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    HWND    hwnd = NULL;
    HRESULT hr = S_OK;

#if defined(DEBUG)
    DebugStrf("Identity - CNotifierList::SendNotification %ld\r\n", msg);
#endif

    AddRef();

    PreNotify();

    while ((iIndex = GetNextNotify()) != -1)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;

        punk = m_entries[iIndex].punk;
        m_entries[iIndex].bState = NS_NOTIFIED;

        punk->AddRef();
        if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
        {
            if( msg == WM_QUERY_IDENTITY_CHANGE )
            {
                if (FAILED(hr = pICNotify->QuerySwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
            }
            else if( msg == WM_IDENTITY_CHANGED )
            {
                pICNotify->SwitchIdentities();
            }
            else if( msg == WM_IDENTITY_INFO_CHANGED )
            {
                    pICNotify->IdentityInformationChanged(dwType);
            }

            pICNotify->Release();
        }
        punk->Release();
    }

exit:
    Release();
    return hr;
}

#ifdef DEBUG

// --------------------------------------------------------------------------------
// DebugStrf
// --------------------------------------------------------------------------------
void DebugStrf(LPTSTR lpszFormat, ...)
{
    static TCHAR szDebugBuff[500];
    va_list arglist;

    va_start(arglist, lpszFormat);
    wvsprintf(szDebugBuff, lpszFormat, arglist);
    va_end(arglist);

    OutputDebugString(szDebugBuff);
}
#endif



// ---------------------------------------------------------------------------------
// Pstore code for storing passwords
// ---------------------------------------------------------------------------------
// Functions related to saving and restoring user passwords from the pstore.


// We have wrappers around Create and Release to allow for future caching of the pstore
// instance within webcheck. 

STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;

    hr = PStoreCreateInstance ( ppIPStore,
                                NULL,
                                NULL,
                                0);
    return hr;
}


STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}


STDAPI  ReadIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore)
{
    GUID             itemType = GUID_NULL;
    GUID             itemSubtype = GUID_NULL;
    PST_PROMPTINFO   promptInfo = {0};
    IPStore*         pStore = NULL;
    HRESULT          hr ;
     
    if (pPwdStore == NULL)
        return E_POINTER;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = NULL;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    
    hr = CreatePStore(&pStore);    

    if (SUCCEEDED(hr))
    {
        Assert(pStore != NULL);

        itemType = GUID_PStoreType;
        itemSubtype = *puidIdentity;

        if (SUCCEEDED(hr))
        {
            DWORD           cbData;
            BYTE           *pbData = NULL;
            

            hr = pStore->ReadItem(
                            s_Key,
                            &itemType,
                            &itemSubtype,
                            c_szIdentityPass,
                            &cbData,
                            &pbData,
                            &promptInfo,
                            0);

            if (SUCCEEDED(hr))
            {
                CopyMemory(pPwdStore, pbData, (cbData <= sizeof(PASSWORD_STORE) ? cbData : sizeof(PASSWORD_STORE)));
                MemFree(pbData);

                hr = S_OK;
            }
        }

        ReleasePStore(pStore);
    }

    return hr;
}

STDAPI WriteIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore)
{
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    IPStore *       pStore;

    typeInfo.cbSize = sizeof(typeInfo);

    typeInfo.szDisplayName = c_szIdentityMgr;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    promptInfo.szPrompt = NULL;

    hr = CreatePStore(&pStore);

    if (SUCCEEDED(hr))
    {
        GUID itemType = GUID_NULL;
        GUID itemSubtype = GUID_NULL;

        Assert(pStore != NULL);

        itemType = GUID_PStoreType;
        itemSubtype = *puidIdentity;
        
        if (SUCCEEDED(hr))
        {
            hr = pStore->CreateType(s_Key, &itemType, &typeInfo, 0);

            // PST_E_TYPE_EXISTS implies type already exists which is just fine
            // by us.
            if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
            {
                typeInfo.szDisplayName = c_szIdentities;

                hr = pStore->CreateSubtype(
                                        s_Key,
                                        &itemType,
                                        &itemSubtype,
                                        &typeInfo,
                                        NULL,
                                        0);

                if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
                {
                    if (pPwdStore != NULL)
                    {
                        hr = pStore->WriteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            c_szIdentityPass,
                                            (sizeof(PASSWORD_STORE)),
                                            (BYTE *)pPwdStore,
                                            &promptInfo,
                                            PST_CF_NONE,
                                            0);
                    }
                    else
                    {
                        hr = pStore->DeleteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            c_szIdentityPass,
                                            &promptInfo,
                                            0);
                    }
                }
            }
        }
        
        ReleasePStore(pStore);
    }
    
    return hr;
}              

#define CH_WHACK TEXT(FILENAME_SEPARATOR)
                                                         
// rips the last part of the path off including the backslash
//      C:\foo      -> C:\      ;
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> ?? (test this)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//
//      Stolen from shlwapi\path.c

STDAPI_(BOOL) _PathRemoveFileSpec(LPTSTR pFile)
{
    LPTSTR pT;
    LPTSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == CH_WHACK)
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't
            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == CH_WHACK)) {
        // Is it just a '\'?
        if (*(pT+1) != TEXT('\0')) {
            // Nope.
            *(pT+1) = TEXT('\0');
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msident.rc
//
#define idiUser                         50
#define idiPasswordKeys2                51
#define idiLogin                        52
#define iddUserProperties               101
#define idiYellow                       103
#define idiKeys                         106
#define iddManager                      107
#define iddPasswordOff                  183
#define iddChgPwd                       184
#define iddDeleteUser                   185
#define iddConfirmUserDelete            186
#define iddConfirmPwd                   187
#define iddLogin                        188
#define iddChgUser                      189
#define iddNewPwd                       190
#define iddNewUser                      191
#define idcAdd                          1001
#define idcNewPwd                       1002
#define idcChkUsePwd                    1003
#define idcPwd                          1004
#define idcProperties                   1005
#define idcConfPwd                      1006
#define idcClose                        1007
#define idcUserName                     1008
#define idcDefault                      1009
#define idcOldPwd                       1010
#define idcStartupCombo                 1011
#define idcDelete                       1012
#define idcStaticName                   1013
#define idcDefaultCombo                 1013
#define idcUserNameList                 1014
#define idcDeleteMsgs                   1015
#define idcStaticNames                  1016
#define idcErrorMsg                     1017
#define idcWarningIcon                  1018
#define idcConfirmMsg                   1019
#define idcStaticUserName               1020
#define idcWelcomeMsg                   1021
#define idcAddUser                      1022
#define idcPwdCaption                   1023
#define idcUsePwd                       1024
#define idcChgPwd                       1025
#define idcAddUsername                  1026
#define idcConfirmPwd                   1027
#define idcManage                       1028
#define idcTellMeMore                   1029
#define idcStaticStartUp                1030
#define idcNoteMsg                      1031
#define idcCheckDefault                 1032
#define idcLogoff                       1033
#define idcLoginInstr                   1034
#define STR_FIRST                       20000
#define idsPwdNotMatch                  20005
#define idsPwdError                     20007
#define idsPwdDoesntMatch               20010
#define idsPwdChgNotMatch               20011
#define idsConfirmDeleteMsg             20012
#define idsConfirmDelPwd                20013
#define idsConfirmDisablePwd            20014
#define idsUserNameExists               20015
#define idsUserNameInUse                20016
#define idsCantDeleteCurrUser           20017
#define idsCantDeleteUser               20018
#define idsLoginAsUser                  20019
#define idsUserAdded                    20020
#define idsSwitchUser                   20021
#define idsMaintainConnection           20022
#define idsUserNameTooShort             20023
#define idsNameTooShort                 20024
#define idsMainUser                     20025
#define idsRootDirName                  20026
#define idsDefault                      20027
#define idsLoginDefault                 20028
#define idsLoginLast                    20029
#define idsLoginAsk                     20030
#define idsSwitchCancelled              20031
#define idsSwitchCancelCaption          20032
#define idsLogoutCancelled              20033
#define idsConfirmEdit                  20034
#define idsIdentityLogin                20035
#define idsSwitchIdentities             20036
#define idsIdentityProperties           20037
#define idsNewIdentity                  20038
#define idsLoginWithCurrent             20039
#define idsLoginNoCurrent               20040
#define idsLogoff                       20041
#define idsConfirmLogoff                20042
#define idsNameCantBeDefault            20043
#define idsNameProblem                  20044
#define idsSwitchInProgressSwitch       20045
#define idsSwitchInProgressLaunch       20046
#define idsNoIdentityInstr              20047
#define idsCurrIdentityInstr            20048
#define idsPwdNotFound                  20049
#define IDC_STATIC                      -1
#define IDC_UNUSED                      -1
#define IDC_NO_HELP_1                   650
#define IDC_NO_HELP_2                   651
#define IDC_NO_HELP_3                   652
#define IDC_NO_HELP_4                   653
#define IDC_NO_HELP_5                   654
#define NO_HELP                         -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msident\strconst.h ===
/*----------------------------------------------------------------------------
    strconst.h
        Non-localizable String constant definitions

 ----------------------------------------------------------------------------*/
#ifndef _STRCONST_H
#define _STRCONST_H


#ifndef WIN16
#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif
#else // !WIN16
#ifdef DEFINE_STRING_CONSTANTS
#ifdef __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y
#else  // __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#endif // __WATCOMC__
#else
#ifdef __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#else  // __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif // __WATCOMC__
#endif

#endif // !WIN16

#define STR_REG_PATH_ROOT           "Identities"

// --------------------------------------------------------------------------
// MultiUser
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegRoot,             STR_REG_PATH_ROOT);
STR_GLOBAL(c_szUserDirPath,         "Application Data\\Identities\\");
STR_GLOBAL(c_szUsername,            "Username");
STR_GLOBAL(c_szUserID,              "User ID");
STR_GLOBAL(c_szDirName,             "Directory Name");
STR_GLOBAL(c_szUsePassword,         "Use Password");
STR_GLOBAL(c_szPassword,            "Password");
STR_GLOBAL(c_szLastUserID,          "Last User ID");
STR_GLOBAL(c_szLastUserName,        "Last Username");
STR_GLOBAL(c_szDefaultUserID,       "Default User ID");
STR_GLOBAL(c_szDefaultUserName,     "Default Username");
STR_GLOBAL(c_szPolicyKey,           "Locked Down");
STR_GLOBAL(c_szLoginAs,             "Start As");
STR_GLOBAL(c_szRegFolders,          "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
STR_GLOBAL(c_szValueAppData,        "AppData");
STR_GLOBAL(c_szNotifyWindowClass,   "Identity Mgr Notify");
STR_GLOBAL(c_szCtxHelpFile,         "ident.hlp");
STR_GLOBAL(c_szIdentitiesFolderName,"Identities");
STR_GLOBAL(c_szEnableDCPolicyKey,   "DCPresent Enable");
STR_GLOBAL(c_szMigrated5,           "Migrated5");
STR_GLOBAL(c_szIdentityOrdinal,     "Identity Ordinal");
STR_GLOBAL(c_szOutgoingID,          "OutgoingID");
STR_GLOBAL(c_szIncomingID,          "IncomingID");
STR_GLOBAL(c_szChanging,            "Changing");

#endif  //_STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\sage\sage.inc ===
WM_USER equ 0400h

WM_SAGE_MSG equ WM_USER+5

VSageID equ Undefined_Device_ID

ERROR_NoT_SUPPORTED equ 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\msidle.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.h
//
//  Contents:   Types and prototypes for idle detection callback dll
//
//  Classes:
//
//  Functions:
//
//  History:    05-26-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

//
// Idle callback type
//
typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD, DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msidle.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        169
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1085
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\msidle.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.cpp
//
//  Contents:   user idle detection
//
//  Classes:
//
//  Functions:
//
//  History:    05-14-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "msidle.h"
#include "resource.h"

// useful things...
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

//
// Global unshared variables
//
DWORD   g_dwIdleMin = 0;                // inactivity minutes before idle
UINT_PTR g_uIdleTimer = 0;              // idle timer for this process
BOOL    g_fIdleNotify = FALSE;          // notify when idle
BOOL    g_fBusyNotify = FALSE;          // notify when busy
BOOL    g_fIsWinNT = FALSE;             // which platform?
BOOL    g_fIsWinNT5 = FALSE;            // are we running on NT5?
BOOL    g_fIsWhistler = FALSE;          // are we running on Whistler?
HANDLE  g_hSageVxd = INVALID_HANDLE_VALUE;
                                        // handle to sage.vxd
DWORD   g_dwIdleBeginTicks = 0;         // ticks when we became idle
HINSTANCE g_hInst = NULL;               // dll instance
_IDLECALLBACK g_pfnCallback = NULL;     // function to call back in client

#ifdef MSIDLE_DOWNLEVEL
//
// Global shared variables
//
#pragma data_seg(".shrdata")

HHOOK   sg_hKbdHook = NULL, sg_hMouseHook = NULL;
DWORD   sg_dwLastTickCount = 0;
POINT   sg_pt = {0,0};

#pragma data_seg()

//
// Prototypes
//
LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK KbdProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif // MSIDLE_DOWNLEVEL

VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

//
// From winuser.h, but NT5 only
//
#if (_WIN32_WINNT < 0x0500)
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;
#endif

//
// NT5 api we dynaload from user32
//
typedef WINUSERAPI BOOL (WINAPI* PFNGETLASTINPUTINFO)(PLASTINPUTINFO plii);

PFNGETLASTINPUTINFO pfnGetLastInputInfo = NULL;

///////////////////////////////////////////////////////////////////////////
//
//                     Internal functions
//
///////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

inline BOOL IsRegMultiSZType(DWORD dwType)
{
    return (REG_MULTI_SZ == dwType);
}

inline BOOL IsRegStringType(DWORD dwType)
{
    return (REG_SZ == dwType) ||
           (REG_EXPAND_SZ == dwType) ||
           IsRegMultiSZType(dwType);
}
 
LONG SafeRegQueryValueEx(
    IN HKEY hKey,
    IN PCTSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    DWORD dwType;
    DWORD cbData = lpcbData ? *lpcbData : 0;
 
    //  We always care about the type even if the caller doesn't
    if (!lpType)
    {
        lpType = &dwType;
    }
    
    LONG lResult = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
    //  need to make sure we NULL terminate strings.
    if ((ERROR_SUCCESS == lResult) && lpData && IsRegStringType(*lpType))
    {
        if (cbData >= sizeof(TCHAR))
        {
            TCHAR *psz = (TCHAR *)lpData;
            DWORD cch = cbData / sizeof(TCHAR);
 
            psz[cch - 1] = 0;
 
            //  and make sure that REG_MULTI_SZ strings are double NULL terminated
            if (IsRegMultiSZType(*lpType))
            {
                if (cbData >= (sizeof(TCHAR) * 2))
                {
                    psz[cch - 2] = 0;
                }
            }
        }
    }
 
    return lResult;
}

BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue, 
                   void *pData, DWORD dwBytes)
{
    long    lResult;
    HKEY    hkey;
    DWORD   dwType;

    lResult = RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_READ, &hkey);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }
    lResult = SafeRegQueryValueEx(hkey, pszValue, NULL, &dwType, (BYTE *)pData, &dwBytes);
    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS) 
        return FALSE;
    
    return TRUE;
}

TCHAR *g_pszLoggingFile;
BOOL  g_fCheckedForLog = FALSE;

DWORD LogEvent(LPTSTR pszFormat, ...)
{

    // check registry if necessary
    if(FALSE == g_fCheckedForLog) {

        TCHAR   pszFilePath[MAX_PATH];

        if(ReadRegValue(HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\msidle"),
                TEXT("LoggingFile"), pszFilePath, sizeof(pszFilePath))) {

            g_pszLoggingFile = (TCHAR *)LocalAlloc(LPTR, lstrlen(pszFilePath) + 1);
            if(g_pszLoggingFile) {
                lstrcpyn(g_pszLoggingFile, pszFilePath, ARRAYSIZE(g_pszLoggingFile));
            }
        }

        g_fCheckedForLog = TRUE;
    }

    if(g_pszLoggingFile) {

        TCHAR       pszString[1025];
        SYSTEMTIME  st;
        HANDLE      hLog;
        DWORD       dwWritten;
        va_list     va;

        hLog = CreateFile(g_pszLoggingFile, GENERIC_WRITE, 0, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if(INVALID_HANDLE_VALUE == hLog)
            return GetLastError();

        // seek to end of file
        SetFilePointer(hLog, 0, 0, FILE_END);

        // dump time
        GetLocalTime(&st);

        //  Safe to call wsprintf since the buffer is 1025 (wsprintf has a built in 1024 limit)
        wsprintf(pszString, "%02d:%02d:%02d [%x] - ", st.wHour, st.wMinute, st.wSecond, GetCurrentThreadId());
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);
        OutputDebugString(pszString);

        // dump passed in string
        va_start(va, pszFormat);

        //  Safe to call wvsprintf since the buffer is 1025 (wsprintf has a built in 1024 limit)
        wvsprintf(pszString, pszFormat, va);
        va_end(va);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);
        OutputDebugString(pszString);

        // cr
        WriteFile(hLog, "\r\n", 2, &dwWritten, NULL);
        OutputDebugString("\r\n");

        // clean up
        CloseHandle(hLog);
    }

    return 0;
}

#endif // DEBUG

//
// SetIdleTimer - decide how often to poll and set the timer appropriately
//
void SetIdleTimer(void)
{
    UINT uInterval = 1000 * 60;

    //
    // If we're looking for loss of idle, check every 4 seconds
    //
    if(TRUE == g_fBusyNotify) {
        uInterval = 1000 * 4;
    }

    //
    // kill off the old timer
    //
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
    }

    //
    // Set the timer
    //
    g_uIdleTimer = SetTimer(NULL, 0, uInterval, OnIdleTimer);
}
       
DWORD GetLastActivityTicks(void)
{
    DWORD dwLastActivityTicks = 0;

    if (g_fIsWhistler) {

        dwLastActivityTicks = USER_SHARED_DATA->LastSystemRITEventTickCount;

    } else if(g_fIsWinNT5 && pfnGetLastInputInfo) {
        // NT5: Use get last input time API
        LASTINPUTINFO lii;

        memset(&lii, 0, sizeof(lii));
        lii.cbSize = sizeof(lii);
        (*pfnGetLastInputInfo)(&lii);
        dwLastActivityTicks = lii.dwTime;
    } else {
        // NT4 or Win95: Use sage if it's loaded
        if(INVALID_HANDLE_VALUE != g_hSageVxd) {
            // query sage.vxd for tick count
            DeviceIoControl(g_hSageVxd, 2, &dwLastActivityTicks, sizeof(DWORD),
                NULL, 0, NULL, NULL);
        }
#ifdef MSIDLE_DOWNLEVEL
    else {
            // use hooks
            dwLastActivityTicks = sg_dwLastTickCount;
        }
#endif // MSIDLE_DOWNLEVEL
    }

    return dwLastActivityTicks;
}

//
// OnIdleTimer - idle timer has gone off
//
VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    DWORD   dwDiff, dwLastActivityTicks;
    BOOL    fTempBusyNotify = g_fBusyNotify;
    BOOL    fTempIdleNotify = g_fIdleNotify;

    //
    // get last activity ticks from sage or shared segment
    //
    dwLastActivityTicks = GetLastActivityTicks();

#ifdef DEBUG
    LogEvent("OnIdleTimer: dwLastActivity=%d, CurrentTicks=%d, dwIdleBegin=%d", dwLastActivityTicks, GetTickCount(), g_dwIdleBeginTicks);
#endif

    //
    // check to see if we've changed state
    //
    if(fTempBusyNotify) {
        //
        // Want to know if we become busy
        //
        if(dwLastActivityTicks != g_dwIdleBeginTicks) {
            // activity since we became idle - stop being idle!
            g_fBusyNotify = FALSE;
            g_fIdleNotify = TRUE;

            // set the timer
            SetIdleTimer();

            // call back client
#ifdef DEBUG
            LogEvent("OnIdleTimer: Idle Ends");
#endif
            if(g_pfnCallback)
                (g_pfnCallback)(STATE_USER_IDLE_END);
        }

    }

    if(fTempIdleNotify) {
        //
        // Want to know if we become idle
        //
        dwDiff = GetTickCount() - dwLastActivityTicks;

        if(dwDiff > 1000 * 60 * g_dwIdleMin) {
            // Nothing's happened for our threshold time.  We're now idle.
            g_fIdleNotify = FALSE;
            g_fBusyNotify = TRUE;

            // save time we became idle
            g_dwIdleBeginTicks = dwLastActivityTicks;

            // set the timer
            SetIdleTimer();

            // call back client
#ifdef DEBUG
            LogEvent("OnIdleTimer: Idle Begins");
#endif
            if(g_pfnCallback)
                (g_pfnCallback)(STATE_USER_IDLE_BEGIN);
        }
    }
}

BOOL LoadSageVxd(void)
{
    int inpVXD[3];

    if(INVALID_HANDLE_VALUE != g_hSageVxd)
        return TRUE;

    g_hSageVxd = CreateFile("\\\\.\\sage.vxd", 0, 0, NULL, 0,
            FILE_FLAG_DELETE_ON_CLOSE, NULL);

    // can't open it?  can't use it
    if(INVALID_HANDLE_VALUE == g_hSageVxd)
        return FALSE;

    // start it monitoring
    inpVXD[0] = -1;                         // no window - will query
    inpVXD[1] = 0;                          // unused
    inpVXD[2] = 0;                          // how long to wait between checks

    DeviceIoControl(g_hSageVxd, 1, &inpVXD, sizeof(inpVXD), NULL, 0, NULL, NULL);

    return TRUE;
}

BOOL UnloadSageVxd(void)
{
    if(INVALID_HANDLE_VALUE != g_hSageVxd) {
        CloseHandle(g_hSageVxd);
        g_hSageVxd = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//
//                   Externally callable functions
//
///////////////////////////////////////////////////////////////////////////

//
// LibMain - dll entry point
//
EXTERN_C BOOL WINAPI LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvRes)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        {
        OSVERSIONINFO vi;

        DisableThreadLibraryCalls(hInst);
        g_hInst = hInst;

        vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&vi);
        if(vi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            g_fIsWinNT = TRUE;
            if(vi.dwMajorVersion >= 5) {
                if (vi.dwMajorVersion > 5 || vi.dwMinorVersion > 0 || LOWORD(vi.dwBuildNumber) > 2410) {
                    g_fIsWhistler = TRUE;
                } else {
                    g_fIsWinNT5 = TRUE;
                }
            }

        }
        }
        break;
    }

    return TRUE;
}

//
// BeginIdleDetection
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved)
{
    DWORD dwValue = 0;

    // make sure reserved is 0
    if(dwReserved)
        return ERROR_INVALID_DATA;

#ifdef DEBUG
    LogEvent("BeginIdleDetection: IdleMin=%d", dwIdleMin);
#endif

    // save callback
    g_pfnCallback = pfnCallback;

    // save minutes
    g_dwIdleMin = dwIdleMin;

    // call back on idle
    g_fIdleNotify = TRUE;

    if(FALSE == g_fIsWinNT) {
        // try to load sage.vxd
        LoadSageVxd();
    }

    if(g_fIsWinNT5) {
        // we need to find our NT5 api in user
        HINSTANCE hUser = GetModuleHandle("user32.dll");
        if(hUser) {
            pfnGetLastInputInfo =
                (PFNGETLASTINPUTINFO)GetProcAddress(hUser, "GetLastInputInfo");
        }

        if(NULL == pfnGetLastInputInfo) {
            // not on NT5 - bizarre
            g_fIsWinNT5 = FALSE;
        }
    }

#ifdef MSIDLE_DOWNLEVEL
    if(INVALID_HANDLE_VALUE == g_hSageVxd && FALSE == g_fIsWinNT5 && FALSE == g_fIsWhistler) {

        // sage vxd not available - do it the hard way

        // hook kbd
        sg_hKbdHook = SetWindowsHookEx(WH_KEYBOARD, KbdProc, g_hInst, 0);
        if(NULL == sg_hKbdHook)
            return GetLastError();
        
        // hook mouse
        sg_hMouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, g_hInst, 0);
        if(NULL == sg_hMouseHook) {
            DWORD dwError = GetLastError();
            EndIdleDetection(0);
            return dwError;
        }
    }
#endif // MSIDLE_DOWNLEVEL

    // Fire up the timer
    SetIdleTimer();

    return 0;
}

//
// IdleEnd - stop idle monitoring
//
BOOL EndIdleDetection(DWORD dwReserved)
{
    // ensure reserved is 0
    if(dwReserved)
        return FALSE;

    // free up sage if we're using it
    UnloadSageVxd();

    // kill timer
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
        g_uIdleTimer = 0;
    }

    // callback is no longer valid
    g_pfnCallback = NULL;

#ifdef MSIDLE_DOWNLEVEL
    // free up hooks
    if(sg_hKbdHook) {
        UnhookWindowsHookEx(sg_hKbdHook);
        sg_hKbdHook = NULL;
    }

    if(sg_hMouseHook) {
        UnhookWindowsHookEx(sg_hMouseHook);
        sg_hMouseHook = NULL;
    }
#endif // MSIDLE_DOWNLEVEL

    return TRUE;
}

//
// SetIdleMinutes - set the timout value and reset idle flag to false
//
// dwMinutes   - if non-0, set idle timeout to that many minutes
// fIdleNotify - call back when idle for at least idle minutes
// fBusyNotify - call back on activity since Idle begin
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved)
{
    if(dwReserved)
        return FALSE;

#ifdef DEBUG
    LogEvent("SetIdleTimeout: dwIdleMin=%d", dwMinutes);
#endif

    if(dwMinutes)
        g_dwIdleMin = dwMinutes;

    return TRUE;
}

//
// SetIdleNotify - set flag to turn on or off idle notifications
//
// fNotify - flag
// dwReserved - must be 0
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved)
{
#ifdef DEBUG
    LogEvent("SetIdleNotify: fNotify=%d", fNotify);
#endif

    g_fIdleNotify = fNotify;
}

//
// SetIdleNotify - set flag to turn on or off idle notifications
//
// fNotify - flag
// dwReserved - must be 0
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved)
{
#ifdef DEBUG
    LogEvent("SetBusyNotify: fNotify=%d", fNotify);
#endif

    g_fBusyNotify = fNotify;

    if(g_fBusyNotify)
        g_dwIdleBeginTicks = GetLastActivityTicks();

    // set the timer
    SetIdleTimer();
}

//
// GetIdleMinutes - return how many minutes since last user activity
//
DWORD GetIdleMinutes(DWORD dwReserved)
{
    if(dwReserved)
        return 0;

    return (GetTickCount() - GetLastActivityTicks()) / 60000;
}

#ifdef MSIDLE_DOWNLEVEL
///////////////////////////////////////////////////////////////////////////
//
//                           Hook functions
//
///////////////////////////////////////////////////////////////////////////

//
// Note: These functions can be called back in any process!
//
LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    MOUSEHOOKSTRUCT * pmsh = (MOUSEHOOKSTRUCT *)lParam;

    if(nCode >= 0) {
        // ignore mouse move messages to the same point as all window
        // creations cause these - it doesn't mean the user moved the mouse
        if(WM_MOUSEMOVE != wParam || pmsh->pt.x != sg_pt.x || pmsh->pt.y != sg_pt.y) {
            sg_dwLastTickCount = GetTickCount();
            sg_pt = pmsh->pt;
        }
    }

    return(CallNextHookEx(sg_hMouseHook, nCode, wParam, lParam));
}

LRESULT CALLBACK KbdProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    if(nCode >= 0) {
        sg_dwLastTickCount = GetTickCount();
    }

    return(CallNextHookEx(sg_hKbdHook, nCode, wParam, lParam));
}
#endif // MSIDLE_DOWNLEVEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\makefile.inc ===
..\resource.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\debug.cpp ===
#include "precomp.hxx"
#include "stdio.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MYDOCS"
#define SZ_MODULE           "MYDOCS"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\copyhook.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include "util.h"
#include "dll.h"
#include "resource.h"

class CMyDocsCopyHook : public ICopyHook
{
public:
    CMyDocsCopyHook();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICopyHook
    STDMETHOD_(UINT,CopyCallback)(HWND hwnd, UINT wFunc, UINT wFlags,
                                  LPCTSTR pszSrcFile, DWORD dwSrcAttribs,
                                  LPCTSTR pszDestFile, DWORD dwDestAttribs);
private:
    ~CMyDocsCopyHook();
    LONG _cRef;
};

STDMETHODIMP CMyDocsCopyHook::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsCopyHook, ICopyHook),    // IID_ICopyHook
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsCopyHook::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsCopyHook::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CMyDocsCopyHook::CMyDocsCopyHook() : _cRef(1)
{
    DllAddRef();
}

CMyDocsCopyHook::~CMyDocsCopyHook()
{
    DllRelease();
}

// ICopyHook methods
UINT CMyDocsCopyHook::CopyCallback(HWND hwnd, UINT wFunc, UINT wFlags,
                                   LPCTSTR pszSrcFile,  DWORD dwSrcAttribs,
                                   LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    UINT uRes = IDYES;

    if ((wFunc == FO_COPY) || (wFunc == FO_MOVE))
    {
        TCHAR szPersonal[MAX_PATH];

        if (S_OK == SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPersonal) &&
            lstrcmpi(pszSrcFile, szPersonal) == 0)
        {
            // the source is the personal directory, now check if the
            // destination is on the desktop...
            DWORD dwRes = IsPathGoodMyDocsPath(hwnd, pszDestFile);

            if (dwRes == PATH_IS_NONEXISTENT)
            {
                StrCpyN(szPersonal, pszDestFile, ARRAYSIZE(szPersonal));
                if (PathRemoveFileSpec(szPersonal))
                {
                    dwRes = IsPathGoodMyDocsPath(hwnd, szPersonal);
                }
            }

            if (dwRes == PATH_IS_DESKTOP)
            {
                // keep the user from moving the personal folder to the desktop
                TCHAR szVerb[ 32 ];
                LoadString(g_hInstance, (wFunc == FO_COPY) ? IDS_COPY : IDS_MOVE, szVerb, ARRAYSIZE(szVerb));

                uRes = IDNO;

                GetFolderDisplayName(CSIDL_PERSONAL, szPersonal, ARRAYSIZE(szPersonal));

                ShellMessageBox(g_hInstance, hwnd,
                                (LPTSTR)IDS_NODRAG_DESKTOP_NOT_HIDDEN, szPersonal,
                                MB_OK | MB_ICONSTOP, szPersonal, szVerb);
            }
        }
    }
    return uRes;
}

HRESULT CMyDocsCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsCopyHook * pMDCH = new CMyDocsCopyHook();
    if (pMDCH)
    {
        *ppunk = SAFECAST(pMDCH, ICopyHook*);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\msidle\sage\sage.asm ===
PAGE 58,132
;******************************************************************************
TITLE SAGE - SAGE VxD
;******************************************************************************
;
;   Title:      SAGE.ASM - SAGE VxD
;
;   Version:    0.060
;
;   Date:       04/18/95
;
;   Author:     Bob Eichenlaub    
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV                 DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;     04/18/95      Initial version - be
;     07/06/95      serial IRQ detection - be; credit to rjc for the basic approach
;     05/23/97      [darrenmi] major clean-up and support multiple clients
;                   for IE4
;
;==============================================================================

        .386p

;******************************************************************************
;                             I N C L U D E S
;******************************************************************************

        .XLIST
        INCLUDE VMM.Inc
        INCLUDE VWIN32.Inc
        INCLUDE VPICD.Inc
 WIN41SERVICES equ 1		; need _SHELL_Update_User_Activity_Ex service
        INCLUDE SHELL.Inc
        INCLUDE VXDLDR.Inc
        INCLUDE regdef.Inc
        INCLUDE Debug.Inc
        INCLUDE Sage.Inc
        .LIST

;public SAGE_Update_User_Activity

;******************************************************************************
;              V I R T U A L   D E V I C E   D E C L A R A T I O N
;------------------------------------------------------------------------------
; The VxD declaration statement defines the VxD name, version number,
; control proc entry point, VxD ID, initialization order, and VM API 
; entry points.
;
; - Defined VxD ID: See VXDID.TXT for more information
; - Init order: If serial port detection is enabled then this Vxd MUST loaded
;               before VCOMM.VxD and after VPICD.VxD,
;               See VMM.INC for the complete
;               definition of the init order of the standard devices.
;               
;******************************************************************************

Declare_Virtual_Device sage, 1, 0, SAGE_Control, VSageID, UNDEFINED_INIT_ORDER

;******************************************************************************
;                                D A T A
;******************************************************************************

;
; Locked data
;
VxD_LOCKED_DATA_SEG

Window_List             dd  0, 0, 0, 0, 0, 0, 0, 0
cClients                dd  0       ; number of valid windows in window list
Time_Out_Idle           dd  10000   ; the interval between message posts
Time_Out_Handle         dd  0       ; Handle to the global time out we create
PtrSHELL_SUUAE_INFO	dd  0	    ; pointer to the SHELL_SUUAE_INFO structure
PrevActiveDisplay	dd  0       ; last screen or user input activity
PrevActiveSystem        dd  0       ; last system activity
Hooked_Proc             dd  0       ; shell's user_activity entry that we hooked

; Fake user activity info structure in case on Win95.
FakeSUUAE_INFO	_SHELL_SUUAE_INFO <0,0,0,0,0>

VxD_LOCKED_DATA_ENDS

;******************************************************************************
;                               C O D E
;------------------------------------------------------------------------------
; The 'body' of the VxD is in the standard code segment.
;******************************************************************************

VxD_CODE_SEG

BeginProc SAGE_Start_Idle_Timer

        push    esi

        ; check to see if we've already got a timer
        mov     esi, [Time_Out_Handle]
        test    esi, esi
        jnz     start1

        ; get a timer
        mov     eax, [Time_Out_Idle]
        mov     esi, OFFSET32 SAGE_User_Idle_Check
        VMMCall Set_Global_Time_Out
        mov     [Time_Out_Handle], esi

start1:
        pop     esi
        ret

EndProc SAGE_Start_Idle_Timer

BeginProc SAGE_Stop_Idle_Timer

        push    esi

        ; check to see if we have a timer
        mov     esi, [Time_Out_Handle]
        test    esi, esi
        jz      stop1

        ; kill it
        VMMCall Cancel_Time_Out
        xor     esi, esi
        mov     [Time_Out_Handle], esi

stop1:
        pop     esi
        ret

EndProc SAGE_Stop_Idle_Timer


;******************************************************************************
;
;   SAGE_Device_IO
;
;   DESCRIPTION:
;       This is the routine that is called when the CreateFile or
;       DeviceIoControl is made
;
;   ENTRY:
;       ESI = Pointer to args (see VWIN32.INC for struct definition)
;
;   EXIT:
;       EAX = return value
;
;   USES:
;       flags
;
;==============================================================================

BeginProc SAGE_Device_IO

        mov     ecx, [esi.dwIOControlCode]
        test    ecx, ecx
        jnz     next1

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; DIOC_GETVERSION
        ;

        ; obtain a pointer to the shell vxd's activity timer info
        cmp	[PtrSHELL_SUUAE_INFO], 0
        jne	short getver1
        VxDCall	SHELL_Get_Version
        cmp	eax, 040Ah
        jae	short haveSUUAEX

	; Running on Win95 so we don't have SHELL_Update_User_Activty_Ex service,
	; hook the shell vxd's activity service to watch activity.
        mov     esi, offset32 SAGE_Update_User_Activity
        GetVxDServiceOrdinal eax, SHELL_Update_User_Activity
        VMMCall Hook_Device_Service
	mov	eax, offset32 FakeSUUAE_INFO
	jmp	short setSUUAE_INFO

haveSUUAEX:
	VxDCall _SHELL_Update_User_Activity_Ex, <SUUAE_CONTINUOUS OR SUUAE_CONTINUOUS_CHECK>
setSUUAE_INFO:
	mov     [PtrSHELL_SUUAE_INFO], eax	; (eax) = ptr to SHELL_SUAAE_INFO structure
        
getver1:
        xor     eax, eax                    ; success
        ret

next1:
        cmp     ecx,-1
        jne     next2

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; DIOC_CLOSE
        ;

        ; see if we have clients to close
        cmp     [cClients], 0
        jz      close1

        ; we do... see if it's the last one...
        dec     [cClients]
        cmp     [cClients], 0
        jnz     close1

        ; last client going away - clean up
        call    SAGE_Stop_Idle_Timer

        cmp     [PtrSHELL_SUUAE_INFO], offset32 FakeSUUAE_INFO
        jne     short close1

        ; unhook activity service
        GetVxDServiceOrdinal    eax,SHELL_Update_User_Activity
        mov     esi, offset32 SAGE_Update_User_Activity
        VMMCall Unhook_Device_Service
        xor	eax, eax
	mov     [PtrSHELL_SUUAE_INFO], eax	; clear pointer

close1:
        xor     eax,eax     ; success
        ret

next2:
        cmp     ecx,1
        jne     next3

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; Set handle and timeout
        ;
        mov     ebx, [esi.lpvInBuffer]

        ; Try to find window handle
        mov     eax, [ebx]
        mov     ecx, [cClients]
        test    ecx, ecx
        jz      addtolist

ioloop:
        cmp     eax, [Window_List + 4 * ecx - 4]
        je      timeout

        dec     ecx
        jnz     ioloop

        ; Can't find it - add it to window list
        mov     ecx, [cClients]
        cmp     ecx, 8
        jnl     timeout

addtolist:
        inc     [cClients]
        mov     [Window_List + 4 * ecx], eax

timeout:
        ; update timeout if specified
        mov     eax, [ebx+8]
        test    eax, eax
        jz      config1

        mov     [Time_Out_Idle], eax

config1:
        call    SAGE_Start_Idle_Timer

        xor     eax, eax    ; success
        ret
next3:
        cmp     ecx, 2
        jne     next4

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; Query last activity
        ;
        mov     ebx, [esi.lpvInBuffer]
        mov	edx, [PtrSHELL_SUUAE_INFO]
	.errnz ssiHoldSystem-ssiHoldDisplay-1
	cmp     word ptr [edx].ssiHoldDisplay, 0
	jne     short lact1		; system or display in "hold" state
	mov	eax, [edx].ssiTimeLastActiveDisplay
	cmp	eax, [edx].ssiTimeLastActiveSystem
	jae	short lact2
	mov	eax, [edx].ssiTimeLastActiveSystem
	jmp	short lact2

lact1:	VMMCall	Get_Last_Updated_System_Time
lact2:  mov     [ebx], eax
        xor     eax, eax
        ret

next4:

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; some unsupported value...
        ;
        mov     eax, ERROR_NOT_SUPPORTED
        ret

EndProc SAGE_Device_IO


VxD_CODE_ENDS



;******************************************************************************
;                      P A G E   L O C K E D   C O D E
;------------------------------------------------------------------------------
;       Memory is a scarce resource. Use this only where necessary.
;******************************************************************************
VxD_LOCKED_CODE_SEG

;******************************************************************************
;
;   SAGE_Control
;
;   DESCRIPTION:
;
;       This is a call-back routine to handle the messages that are sent
;       to VxD's to control system operation. Every VxD needs this function
;       regardless if messages are processed or not. The control proc must
;       be in the LOCKED code segment.
;
;       The Control_Dispatch macro used in this procedure simplifies
;       the handling of messages. To handle a particular message, add
;       a Control_Dispatch statement with the message name, followed
;       by the procedure that should handle the message. 
;
;   ENTRY:
;       EAX = Message number
;       EBX = VM Handle
;
;==============================================================================

BeginProc SAGE_Control

        Control_Dispatch W32_DEVICEIOCONTROL, SAGE_Device_IO
        clc
        ret

EndProc SAGE_Control


BeginDoc
;******************************************************************************
;
; SAGE_Update_User_Activity
;
; DESCRIPTION:
;
;   This service is called by VMD, VKD to tell us that user input occured
; ENTRY:    None
; EXIT:     None
; USES:     NONE
;==============================================================================
EndDoc
BeginProc SAGE_Update_User_Activity, HOOK_PROC, Hooked_Proc

    push    eax

    ; save off the time
    VMMCall Get_Last_Updated_System_Time
    mov     [FakeSUUAE_INFO.ssiTimeLastActiveDisplay], eax

    pop     eax
    jmp     Hooked_Proc

EndProc SAGE_Update_User_Activity


VxD_LOCKED_CODE_ENDS

VxD_PAGEABLE_CODE_SEG

;******************************************************************************
;
; SAGE_User_Idle_Check
;
; DESCRIPTION:
;
;   This checks if key/mouse or serial port (comm) event has occurred.
;
; Entry:
;   None
; Exit:
;   None
; Uses:
;   ALL
;******************************************************************************

BeginProc SAGE_User_Idle_Check,High_Freq,PUBLIC                                 
                                                                                
    ;                                                                           
    ; clear handle                                                              
    ;                                                                           
    xor     ecx, ecx                                                            
    mov     [Time_Out_Handle], ecx                                              
                                                                                
    ;                                                                           
    ; check for idleness                                                        
    ;                                                                           
    mov     eax, [PtrSHELL_SUUAE_INFO]	; (eax) = ptr to SHELL_SUAAE_INFO structure
    .errnz ssiHoldSystem-ssiHoldDisplay-1
    cmp     word ptr [eax].ssiHoldDisplay, 0
    jne     short holdActive		; system or display in "hold" state
    mov	    ecx, [eax].ssiTimeLastActiveDisplay
    mov	    edx, [eax].ssiTimeLastActiveSystem
    cmp	    ecx, [PrevActiveDisplay]
    jne	    notIdle			; display activity changed
    cmp     edx, [PrevActiveSystem]
    je      ResetTimer			; no display or system activity since last time

    ;                                                                           
    ; Not idle so post a message to all clients who want to know
    ;                     
notIdle:
    mov     [PrevActiveDisplay], ecx	; update idle times for next time
    mov     [PrevActiveSystem], edx
holdActive:
    
    xor     eax, eax                                                            
    mov     ecx, [cClients]
    test    ecx, ecx                                                            
    jz      ResetTimer                                                          

loop0:

    ; get next window
    mov     ebx, [4 * ecx + Window_List - 4]

    ; skip if it's -1
    cmp     ebx, -1
    je      loop1
                                                                                
    ; post message
    push    ecx
    VxDCall _SHELL_PostMessage, <ebx, WM_SAGE_MSG, eax, eax, eax, eax>          
    pop     ecx

loop1:
    dec     ecx
    jnz     loop0

    ;                                                                           
    ; reset the timer so we check again later                                   
    ;                                                                           
ResetTimer:                                                                     
    call    SAGE_Start_Idle_Timer
    ret                                                                         
                                                                                
EndProc SAGE_User_Idle_Check                                                    

VxD_PAGEABLE_CODE_ENDS


;******************************************************************************
;                       R E A L   M O D E   C O D E
;******************************************************************************

;******************************************************************************
;
;       Real mode initialization code
;
;   DESCRIPTION:
;       This code is called when the system is still in real mode, and
;       the VxDs are being loaded.
;
;       This routine as coded shows how a VxD (with a defined VxD ID)
;       could check to see if it was being loaded twice, and abort the 
;       second without an error message. Note that this would require
;       that the VxD have an ID other than Undefined_Device_ID. See
;       the file VXDID.TXT more details.
;
;   ENTRY:
;       AX = VMM Version
;       BX = Flags
;               Bit 0: duplicate device ID already loaded 
;               Bit 1: duplicate ID was from the INT 2F device list
;               Bit 2: this device is from the INT 2F device list
;       EDX = Reference data from INT 2F response, or 0
;       SI = Environment segment, passed from MS-DOS
;
;   EXIT:
;       BX = ptr to list of pages to exclude (0, if none)
;       SI = ptr to list of instance data items (0, if none)
;       EDX = DWORD of reference data to be passed to protect mode init
;
;==============================================================================

VxD_REAL_INIT_SEG

BeginProc SAGE_Real_Init_Proc

        test    bx, Duplicate_Device_ID ; check for already loaded
        jnz     short duplicate         ; jump if so

        xor     bx, bx                  ; no exclusion table
        xor     si, si                  ; no instance data table
        xor     edx, edx                ; no reference data

        mov     ax, Device_Load_Ok
        ret

duplicate:
        mov     ax, Abort_Device_Load + No_Fail_Message
        ret

EndProc SAGE_Real_Init_Proc


VxD_REAL_INIT_ENDS


        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\dll.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>
#include <advpub.h>     // RegInstall stuff

#include "util.h"
#include "resource.h"
#include "version.h"

// {ECF03A32-103D-11d2-854D-006008059367}   CLSID_MyDocsDropTarget
const CLSID CLSID_MyDocsDropTarget = { 0xecf03a32, 0x103d, 0x11d2, { 0x85, 0x4d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67 } };
// {ECF03A33-103D-11d2-854D-006008059367}   CLSID_MyDocsCopyHook
const CLSID CLSID_MyDocsCopyHook = { 0xecf03a33, 0x103d, 0x11d2, { 0x85, 0x4d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67 } };
// {4a7ded0a-ad25-11d0-98a8-0800361b1103}   CLSID_MyDocsProp
const CLSID CLSID_MyDocsProp = {0x4a7ded0a, 0xad25, 0x11d0, 0x98, 0xa8, 0x08, 0x00, 0x36, 0x1b, 0x11, 0x03};

HINSTANCE g_hInstance = 0;
LONG g_cRefThisDll = 0;          // DLL global reference count

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll ? S_FALSE : S_OK;
}

HRESULT CMyDocsCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
HRESULT CMyDocsSendTo_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
HRESULT CMyDocsProp_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);


CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_MyDocsCopyHook,      CMyDocsCopyHook_CreateInstance,   COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_MyDocsDropTarget,    CMyDocsSendTo_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_MyDocsProp,          CMyDocsProp_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter) // && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

// export that ie4unit.exe calls at per user install time
// this lets us execute code instead of depending on the "DefaultUser" template
// that is used to init new accounts. this deals with upgrade cases too, very important

STDAPI_(void) PerUserInit(void)
{
    TCHAR szPath[MAX_PATH];

    SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);

    // Don't install these guys on server builds
    if (!IsOS(OS_ANYSERVER))
    {
        SHGetFolderPath(NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
        SHGetFolderPath(NULL, CSIDL_MYMUSIC | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
    }

    UpdateSendToFile();
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hInstance, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hInstance, "UnregDll");
    return S_OK;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    if (pszCmdLine && *pszCmdLine)
    {
        if (0 == StrCmpIW(pszCmdLine, L"UseReadOnly"))
        {
            // Add key for system to use read only bit on shell folders...
            HKEY hkey;
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                                                0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
            {
                if (bInstall)
                {
                    DWORD dwValue = 1;
                    RegSetValueEx(hkey, TEXT("UseReadOnlyForSystemFolders"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
                }
                else
                {
                    RegDeleteValue(hkey, TEXT("UseReadOnlyForSystemFolders"));
                }
                RegCloseKey(hkey);
            }
        }
        else if (0 == StrCmpIW(pszCmdLine, L"U"))
        {
            // not currently used, but for testing (and consistency with shell32.dll)
            // REGSVR32.EXE /n /i:U mydocs.dll
            PerUserInit();  
        }
    }
    return S_OK;
}

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, void *pReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
        break;

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\dll.h ===
#ifndef __dll_h
#define __dll_h

#define T_HKEY   0x0001
#define T_VALUE  0x0002
#define T_DWORD  0x0003
#define T_END    0xFFFF

extern HINSTANCE g_hInstance;

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#ifdef DEBUG
void DllSetTraceMask(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\dllload.cpp ===
#include "precomp.hxx"
#include "util.h"

#include "..\..\inc\dllload.c"

/**********************************************************************/
/**********************************************************************/

// ---------- CSCDLL.DLL ------------

HINSTANCE g_hinstCSCDLL = NULL;

DELAY_LOAD_BOOL(g_hinstCSCDLL, CSCDLL, CSCQueryFileStatus,
            (LPCTSTR lpszFileName, LPDWORD lpdwStatus, LPDWORD lpdwPinCount, LPDWORD lpdwHintFlags),
            (lpszFileName, lpdwStatus, lpdwPinCount, lpdwHintFlags));


// ---------- CSCUI.DLL ------------

HINSTANCE g_hinstCSCUI = NULL;

DELAY_LOAD_HRESULT(g_hinstCSCUI, CSCUI, CSCUIRemoveFolderFromCache,
            (LPCWSTR pszFolder, DWORD dwReserved, PFN_CSCUIRemoveFolderCallback pfnCB, LPARAM lParam),
            (pszFolder, dwReserved, pfnCB, lParam));


// ---------- MPR.DLL --------------

HINSTANCE g_hinstMPR = NULL;

DELAY_LOAD_ERR(g_hinstMPR, MPR, DWORD, WNetGetUniversalName,
            (LPCTSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize),
            (lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize),
            ERROR_NOT_CONNECTED);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\prop.h ===
#ifndef __props_h
#define __props_h


INT_PTR CALLBACK TargetDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

#define MAX_NAME_LEN 20
#define FILENAME_LEN_WITH_SLASH_AND_NULL 14
#define MAX_DIR_PATH (MAX_PATH-FILENAME_LEN_WITH_SLASH_AND_NULL)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MYDOCS                      100
#define IDI_MYPICS                      101

#define IDR_CONTEXT                     201
#define IDM_OPEN                        300
#define IDM_EXPLORE                     301
#define IDM_SHORTCUT                    302
#define IDM_DELETE                      303
#define IDM_RENAME                      304
#define IDM_PROPERTIES                  305
#define DLG_TARGET                      400
#define IDD_ITEMICON                    401
#define IDD_NAME                        402
#define IDD_TARGET_TXT                  406
#define IDD_TARGET                      407
#define IDD_BROWSE                      408
#define IDD_FIND                        409
#define IDD_INSTRUCTIONS                413
#define IDD_RESET                       414
#define IDS_CREATE_FOLDER_TITLE         630
#define IDS_CREATE_FOLDER               631
#define IDS_INVALID_TITLE               632
#define IDS_NONEXISTENT_FOLDER          633
#define IDS_NOT_DIRECTORY               634

#define IDS_NODESKTOP                   642
#define IDS_NODESKTOP_FOLDERS           643
#define IDS_NOSHELLEXT_FOLDERS          644

#define IDS_NODRAG_DESKTOP_NOT_HIDDEN   649
#define IDS_COPY                        651
#define IDS_MOVE                        652
#define IDS_PROP_ERROR_TITLE            653
#define IDS_NOWINDIR_FOLDER             656
#define IDS_NOPROFILEDIR_FOLDER         657
#define IDS_PROP_INSTRUCTIONS           661
#define IDS_GENERAL_BADDIR              664
#define IDS_BROWSE_TITLE                665
#define IDS_NOTALLOWED_FOLDERS          668
#define IDS_MOVE_DOCUMENTS_TITLE        676
#define IDS_MOVE_DOCUMENTS              677
#define IDS_MOVE_ERROR_TITLE            678
#define IDS_MOVE_ERROR                  679
#define IDS_BROWSE_CAPTION              680
#define IDS_CANT_MOVE_TO_SUBDIR         682
#define IDS_UNPIN_OLD_TITLE             685
#define IDS_UNPIN_OLDTARGET             686
#define IDS_SHARENAME                   689

#define IDS_DELETE_MESSAGE              900

#define IDC_TARGET_GBOX                 -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\prop.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include "util.h"
#include "dll.h"
#include "resource.h"
#include "prop.h"

#include <shellids.h>   // IDH_ values
#include "shlguidp.h"
#include "inetreg.h"
#include "strsafe.h"

typedef struct {
    HWND hDlg;
    BOOL bDirty;
    BOOL bInitDone;
    BOOL bSetToDefault;
    TCHAR szFolder[MAX_PATH];
    UINT csidl;
} CUSTINFO;

const static DWORD rgdwHelpTarget[] = {
    IDD_TARGET_TXT,                   IDH_MYDOCS_TARGET,
    IDD_TARGET,                       IDH_MYDOCS_TARGET,
    IDD_FIND,                         IDH_MYDOCS_FIND_TARGET,
    IDD_BROWSE,                       IDH_MYDOCS_BROWSE,
    IDD_RESET,                        IDH_MYDOCS_RESET,
    0, 0
};

// Scans a desktop.ini file for sections to see if all of them are empty...

BOOL IsDesktopIniEmpty(LPCTSTR pIniFile)
{
    TCHAR szSections[1024];  // for section names
    if (GetPrivateProfileSectionNames(szSections, ARRAYSIZE(szSections), pIniFile))
    {
        for (LPTSTR pTmp = szSections; *pTmp; pTmp += lstrlen(pTmp) + 1)
        {
            TCHAR szSection[1024];   // for section key names and values
            GetPrivateProfileSection(pTmp, szSection, ARRAYSIZE(szSection), pIniFile);
            if (szSection[0])
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

void CleanupSystemFolder(LPCTSTR pszPath)
{
    TCHAR szIniFile[MAX_PATH];
    PathCombine(szIniFile, pszPath, TEXT("desktop.ini"));

    DWORD dwAttrb;
    if (PathFileExistsAndAttributes(szIniFile, &dwAttrb))
    {
        // Remove CLSID2, InfoTip, Icon
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("InfoTip"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconFile"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconIndex"), NULL, szIniFile);

        // get rid of delete on copy entries to see if we can generate an empty .ini file
        WritePrivateProfileSection(TEXT("DeleteOnCopy"), NULL, szIniFile);

        if (IsDesktopIniEmpty(szIniFile))
        {
            dwAttrb &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN);
            SetFileAttributes(szIniFile, dwAttrb);
            DeleteFile(szIniFile);
        }

        // see if we can cleanout an old thumbs.db file too
        // so we have a better chance of deleting an empty folder
        PathCombine(szIniFile, pszPath, TEXT("thumbs.db"));
        DeleteFile(szIniFile);

        PathUnmakeSystemFolder(pszPath);
    }

    // in case it is empty try to delete it 
    // this will fail if there are contents in the folder
    if (RemoveDirectory(pszPath))
    {
        // it is gone, let people know
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszPath, NULL);
    }
    else
    {
        // attribute bits changed for this folder, refresh views of it
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pszPath, NULL);
    }
}

HRESULT ChangeFolderPath(UINT csidl, LPCTSTR pszNew, LPCTSTR pszOld)
{
    HRESULT hr = SHSetFolderPath(csidl, NULL, 0, pszNew);
    if (SUCCEEDED(hr))
    {
        // now we can cleanup the old folder... now that we have the new folder
        // established

        if (*pszOld)
        {
            CleanupSystemFolder(pszOld);
        }
        // force the per user init stuff on the new folder
        TCHAR szPath[MAX_PATH];
        hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
        if (SUCCEEDED(hr))
        {
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szPath, NULL);
        }
    }
    return hr;
}

// test to see if pszToTest is a sub folder of pszFolder
BOOL PathIsDirectChildOf(LPCTSTR pszFolder, LPCTSTR pszMaybeChild)
{
    return PATH_IS_CHILD == ComparePaths(pszMaybeChild, pszFolder);
}

LPTSTR GetMessageTitle(CUSTINFO *pci, LPTSTR psz, UINT cch)
{
    TCHAR szFormat[64], szName[MAX_PATH];

    LoadString(g_hInstance, IDS_PROP_ERROR_TITLE, szFormat, ARRAYSIZE(szFormat));
    GetFolderDisplayName(pci->csidl, szName, ARRAYSIZE(szName));
    StringCchPrintf(psz, cch, szFormat, szName);

    return psz;
}

void GetTargetExpandedPath(HWND hDlg, LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;

    TCHAR szUnExPath[MAX_PATH];

    if (GetDlgItemText(hDlg, IDD_TARGET, szUnExPath, ARRAYSIZE(szUnExPath)))
    {
        // Turn "c:" into "c:\", but don't change other paths:
        PathAddBackslash(szUnExPath);                                // safe to ignore return
        PathRemoveBackslash(szUnExPath);
        SHExpandEnvironmentStrings(szUnExPath, pszPath, cch);
    }
}

// Check known key in the registry to see if policy has disabled changing
// of My Docs location.

BOOL PolicyAllowsFolderPathChange(CUSTINFO *pci)
{
    BOOL bChange = TRUE;

    if (pci->csidl == CSIDL_PERSONAL)
    {
        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), 0, KEY_READ, &hkey))
        {
            bChange = (ERROR_SUCCESS != RegQueryValueEx(hkey, TEXT("DisablePersonalDirChange"), NULL, NULL, NULL, NULL));
            RegCloseKey(hkey);
        }
    }
    return bChange;
}

BOOL InitTargetPage(HWND hDlg, LPARAM lParam)
{
    CUSTINFO *pci = (CUSTINFO *)LocalAlloc(LPTR, sizeof(*pci));
    if (pci)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szFormat[MAX_PATH];
        TCHAR szText[ARRAYSIZE(szFormat) + MAX_NAME_LEN];
        TCHAR szName[MAX_PATH];

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pci);
        pci->hDlg = hDlg;
        pci->csidl = CSIDL_PERSONAL;

        // Fill in title/instructions...
        GetFolderDisplayName(pci->csidl, szName, ARRAYSIZE(szName));
        if (lstrlen(szName) > MAX_NAME_LEN)
        {
            StringCchCopy(&szName[MAX_NAME_LEN], ARRAYSIZE(szName) - MAX_NAME_LEN, TEXT("..."));            // already bounds checked above
        }

        LoadString(g_hInstance, IDS_PROP_INSTRUCTIONS, szFormat, ARRAYSIZE(szFormat));

        StringCchPrintf(szText, ARRAYSIZE(szText), szFormat, szName);
        SetDlgItemText(hDlg, IDD_INSTRUCTIONS, szText);

        // Limit edit field to MAX_PATH-13 characters.  Why -13?
        // Well, 13 is the number of characters in a DOS style 8.3
        // filename with a '\', and CreateDirectory will fail if you try to create
        // a directory that can't at least contain 8.3 file names.
        SendDlgItemMessage(hDlg, IDD_TARGET, EM_SETLIMITTEXT, MAX_DIR_PATH, 0);

        // Check whether path can be changed
        if (PolicyAllowsFolderPathChange(pci))
        {
            SHAutoComplete(GetDlgItem(hDlg, IDD_TARGET), SHACF_FILESYS_DIRS);
        }
        else
        {
            // Make edit field read only
            SendDlgItemMessage(hDlg, IDD_TARGET, EM_SETREADONLY, (WPARAM)TRUE, 0);
            ShowWindow(GetDlgItem(hDlg, IDD_RESET), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_FIND), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_BROWSE), SW_HIDE);
        }

        SHGetFolderPath(NULL, pci->csidl | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);

        if (szPath[0])
        {
            PathRemoveBackslash(szPath);                                // keep path without trailing backslash
            StringCchCopy(pci->szFolder, ARRAYSIZE(pci->szFolder), szPath);
            SetDlgItemText(hDlg, IDD_TARGET, szPath);
        }

        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetFolderLocation(NULL, pci->csidl | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, &pidl)))
        {
            SHFILEINFO sfi;
            SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_PIDL);
            if (sfi.hIcon)
            {
                if (sfi.hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0))
                {
                    DestroyIcon(sfi.hIcon);
                }                    
            }
            ILFree(pidl);
        }

        pci->bInitDone = TRUE;
    }
    return pci ? TRUE : FALSE;
}

const UINT c_rgRedirectCanidates[] = 
{
    CSIDL_MYPICTURES,
    CSIDL_MYMUSIC,
    CSIDL_MYVIDEO,
    CSIDL_MYDOCUMENTS,
};

int MoveFilesForRedirect(HWND hdlg, LPCTSTR pszNewPath, LPCTSTR pszOldPath)
{
    int iRet = 0;  // success

    // since we use FOF_RENAMEONCOLLISION when moving files from the old location
    // to the new we want to special case target folders if they are the shell special
    // folders that may live under the folder being redirected

    // this code implements a merge of those folders doing "rename on collision" at the
    // level below the folder. this keeps us from generating "copy of xxx" for each of
    // the special folders
    
    for (UINT i = 0; (iRet == 0) && (i < ARRAYSIZE(c_rgRedirectCanidates)); i++)
    {
        TCHAR szOld[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, c_rgRedirectCanidates[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szOld)) &&
            PathIsDirectChildOf(pszOldPath, szOld))
        {
            TCHAR szDestPath[MAX_PATH] = {0};   // zero init for SHFileOperation()
            PathCombine(szDestPath, pszNewPath, PathFindFileName(szOld));

            DWORD dwAtt;
            if (PathFileExistsAndAttributes(szDestPath, &dwAtt) &&
                (FILE_ATTRIBUTE_DIRECTORY & dwAtt))
            {
                // reset the folder with the system before the move
                ChangeFolderPath(c_rgRedirectCanidates[i], szDestPath, szOld);

                // the above may have emptied and deleted the old location
                // but if not we need to move the contents
                if (PathFileExistsAndAttributes(szOld, &dwAtt))
                {
                    // Move items in current MyPics to new location
                    TCHAR szSrcPath[MAX_PATH + 1] = {0};    // +1 for double null
                    PathCombine(szSrcPath, szOld, TEXT("*.*"));

                    SHFILEOPSTRUCT  fo = {0};
                    fo.hwnd = hdlg;
                    fo.wFunc = FO_MOVE;
                    fo.fFlags = FOF_RENAMEONCOLLISION;
                    fo.pFrom = szSrcPath;
                    fo.pTo = szDestPath;        

                    iRet = SHFileOperation(&fo);
                    if ((0 == iRet) && !fo.fAnyOperationsAborted)
                    {
                        // since the above was a full move no files should
                        // be left behind so this should work
                        if (RemoveDirectory(szOld))
                            SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szOld, NULL);
                    }
                }
            }
        }
    }

    // above failed or canceled?
    if (0 == iRet)
    {
        // move the rest of the stuff
        TCHAR szSrcPath[MAX_PATH + 1] = {0};    // +1 for double null
        PathCombine(szSrcPath, pszOldPath, TEXT("*.*"));

        TCHAR szDestPath[MAX_PATH] = {0};   // zero init for dbl null term
        StringCchCopy(szDestPath, ARRAYSIZE(szDestPath), pszNewPath);

        SHFILEOPSTRUCT  fo = {0};
        fo.hwnd = hdlg;
        fo.wFunc = FO_MOVE;
        fo.fFlags = FOF_RENAMEONCOLLISION;  // don't want any "replace file" prompts

        fo.pFrom = szSrcPath;
        fo.pTo = szDestPath;

        iRet = SHFileOperation(&fo);
        if (0 == iRet)
        {
            // if the above worked we try to clean up the old path
            // now that it it empty
            if (RemoveDirectory(pszOldPath))
                SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszOldPath, NULL);
        }
    }
    return iRet;
}

// Ask the user if they want to create the directory of a given path.
// Returns TRUE if the user decided to create it, FALSE if not.
// If TRUE, the dir attributes are returned in pdwAttr.
BOOL QueryCreateTheDirectory(CUSTINFO *pci, LPCTSTR pPath, DWORD *pdwAttr)
{
    *pdwAttr = 0;

    UINT id = IDYES;

    if (pci->bSetToDefault)
        id = IDYES;
    else
        id = ShellMessageBox(g_hInstance, pci->hDlg, MAKEINTRESOURCE(IDS_CREATE_FOLDER), MAKEINTRESOURCE(IDS_CREATE_FOLDER_TITLE),
                              MB_YESNO | MB_ICONQUESTION, pPath);
    if (IDYES == id)
    {
        // user asked us to create the folder
        if (ERROR_SUCCESS == SHCreateDirectoryEx(pci->hDlg, pPath, NULL))
            *pdwAttr = GetFileAttributes(pPath);
    }
    return IDYES == id;
}

void _MaybeUnpinOldFolder(LPCTSTR pszPath, HWND hwnd, BOOL fPromptUnPin)
{
    //
    // Convert the path to canonical UNC form (the CSC and CSCUI
    // functions require the path to be in this form)
    //
    // WNetGetUniversalName fails if you give it a path that's already
    // in canonical UNC form, so in the failure case just try using
    // pszPath.  CSCQueryFileStatus will validate it.
    //
    LPCTSTR pszUNC;

    struct {
       UNIVERSAL_NAME_INFO uni;
       TCHAR szBuf[MAX_PATH];
    } s;
    DWORD cbBuf = sizeof(s);

    if (ERROR_SUCCESS == WNetGetUniversalName(pszPath, UNIVERSAL_NAME_INFO_LEVEL,
                                &s, &cbBuf))
    {
        pszUNC = s.uni.lpUniversalName;
    }
    else
    {
        pszUNC = pszPath;
    }

    //
    // Ask CSC if the folder is pinned for this user
    //
    DWORD dwHintFlags = 0;
    if (CSCQueryFileStatus(pszUNC, NULL, NULL, &dwHintFlags))
    {
        if (dwHintFlags & FLAG_CSC_HINT_PIN_USER)
        {
            //
            // Yes; figure out if we should unpin it
            //
            BOOL fUnpin;

            if (fPromptUnPin)
            {
                //
                // Give the unconverted path name in the message box, since
                // that's the name the user knows
                //
                UINT id = ShellMessageBox(g_hInstance, hwnd,
                                  MAKEINTRESOURCE(IDS_UNPIN_OLDTARGET), MAKEINTRESOURCE(IDS_UNPIN_OLD_TITLE),
                                  MB_YESNO | MB_ICONQUESTION | MB_TOPMOST | MB_DEFBUTTON2,
                                  pszPath);

                fUnpin = (id == IDNO);
            }
            else
            {
                fUnpin = TRUE;
            }

            if (fUnpin)
            {
                CSCUIRemoveFolderFromCache(pszUNC, 0, NULL, 0);
            }
        }
    }
}

void ComputChildrenOf(LPCTSTR pszOld, UINT rgChildren[], UINT sizeArray)
{
    UINT iCanidate = 0;

    ZeroMemory(rgChildren, sizeof(rgChildren[0]) * sizeArray);

    for (UINT i = 0; i < ARRAYSIZE(c_rgRedirectCanidates); i++)
    {
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, c_rgRedirectCanidates[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)))
        {
            if (PathIsDirectChildOf(pszOld, szPath))
            {
                if (iCanidate < sizeArray)
                {
                    rgChildren[iCanidate++] = c_rgRedirectCanidates[i];
                }
            }
        }
    }
}

// if csidl DEFAULT VALUE ends up under the new folder we reset that folder
// to that value

HRESULT ResetSubFolderDefault(LPCTSTR pszNew, UINT csidl, LPCTSTR pszOldPath)
{
    HRESULT hr = S_OK;
    // note: getting the default value for this path, not the current value!
    TCHAR szDefault[MAX_PATH];
    if (S_OK == SHGetFolderPath(NULL, csidl, NULL, SHGFP_TYPE_DEFAULT, szDefault))
    {
        if (PathIsDirectChildOf(pszNew, szDefault))
        {
            hr = SHSetFolderPath(csidl, NULL, 0, szDefault);
            if (SUCCEEDED(hr))
            {
                // we've written the registry, that is enough to cleanup the old folder
                if (*pszOldPath)
                    CleanupSystemFolder(pszOldPath);

                hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szDefault);
            }
        }
    }
    return hr;
}

void ResetNonMovedFolders(LPCTSTR pszNew, UINT rgChildren[], UINT sizeArray)
{
    for (UINT i = 0; i < sizeArray; i++)
    {
        // for all of these folders that were sub folders of the old location
        // and are now not sub folders we try to restore them to the default

        TCHAR szPath[MAX_PATH];
        if (rgChildren[i] && 
            SUCCEEDED(SHGetFolderPath(NULL, rgChildren[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)) &&
            !PathIsDirectChildOf(pszNew, szPath))
        {
            ResetSubFolderDefault(pszNew, rgChildren[i], szPath);
        }
    }
}
              
void _DoApply(CUSTINFO *pci)
{
    LONG lres = PSNRET_NOERROR;
    TCHAR szNewFolder[MAX_PATH];
    DWORD dwAttr;

    GetTargetExpandedPath(pci->hDlg, szNewFolder, ARRAYSIZE(szNewFolder));

    if (pci->bDirty && (lstrcmpi(szNewFolder, pci->szFolder) != 0))
    {
        TCHAR szPropTitle[MAX_PATH + 32];
        DWORD dwRes = IsPathGoodMyDocsPath(pci->hDlg, szNewFolder);

        // all of the special cases

        switch (dwRes)
        {
        case PATH_IS_DESKTOP:   // desktop is not good
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NODESKTOP_FOLDERS), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_SYSTEM:
        case PATH_IS_WINDOWS:   // these would be bad
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOWINDIR_FOLDER), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_PROFILE:   // profile is bad
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOPROFILEDIR_FOLDER), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_NONEXISTENT:
        case PATH_IS_NONDIR:
        case PATH_IS_GOOD:

            dwAttr = GetFileAttributes(szNewFolder);

            if (dwAttr == 0xFFFFFFFF)
            {
                // Ask user if we should create the directory...
                if (!QueryCreateTheDirectory(pci, szNewFolder, &dwAttr))
                {
                    // They don't want to create the directory.. break here
                    lres = PSNRET_INVALID_NOCHANGEPAGE;
                    break;
                }
            }

            if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (lstrcmpi(szNewFolder, pci->szFolder))
                {
                    UINT rgChildren[10];
                    ComputChildrenOf(pci->szFolder, rgChildren, ARRAYSIZE(rgChildren));

                    if (SUCCEEDED(ChangeFolderPath(pci->csidl, szNewFolder, pci->szFolder)))
                    {
                        BOOL fNewSubdirOfOld = PathIsEqualOrSubFolder(pci->szFolder, szNewFolder);

                        BOOL fPromptUnPin = TRUE;

                        if (fNewSubdirOfOld)
                        {
                            // can't move old content to a subdir
                            ShellMessageBox(g_hInstance, pci->hDlg,
                                    MAKEINTRESOURCE(IDS_CANT_MOVE_TO_SUBDIR), MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS_TITLE),
                                    MB_OK | MB_ICONINFORMATION | MB_TOPMOST,
                                    pci->szFolder);
                        }
                        else if (IDYES == ShellMessageBox(g_hInstance, pci->hDlg,
                                        MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS),
                                        MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS_TITLE),
                                        MB_YESNO | MB_ICONQUESTION | MB_TOPMOST,
                                        pci->szFolder, szNewFolder))
                        {
                            // move old mydocs content -- returns 0 on success
                            if (0 == MoveFilesForRedirect(pci->hDlg, szNewFolder, pci->szFolder)) 
                            {
                                // Move succeeded, the old target dir is now empty, so
                                // no need to prompt about unpinning it (just go ahead
                                // and do it).

                                fPromptUnPin = FALSE;
                            }
                            else
                            {
                                // move failure
                                ShellMessageBox(g_hInstance, pci->hDlg,
                                    MAKEINTRESOURCE(IDS_MOVE_ERROR), MAKEINTRESOURCE(IDS_MOVE_ERROR_TITLE),
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST,
                                    szNewFolder, pci->szFolder);
                            }
                        }

                        ResetNonMovedFolders(szNewFolder, rgChildren, ARRAYSIZE(rgChildren));

                        if (!fNewSubdirOfOld && pci->szFolder[0])
                        {
                            // If the old folder was pinned, offer to unpin it.
                            //
                            // Do this only if new target is not a subdir of the 
                            // old target, since otherwise we'd end up unpinning
                            // the new target as well

                            _MaybeUnpinOldFolder(pci->szFolder, pci->hDlg, fPromptUnPin);
                        }
                    }
                    else
                    {
                        ShellMessageBox(g_hInstance, pci->hDlg,
                                         MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                        lres = PSNRET_INVALID_NOCHANGEPAGE;
                    }
                }
            }
            else if (dwAttr)
            {
                DWORD id = IDS_NONEXISTENT_FOLDER;

                // The user entered a path that doesn't exist or isn't a
                // directory...

                if (dwAttr != 0xFFFFFFFF)
                {
                    id = IDS_NOT_DIRECTORY;
                }

                ShellMessageBox(g_hInstance, pci->hDlg,
                                 IntToPtr_(LPTSTR, id), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                 MB_OK | MB_ICONERROR | MB_TOPMOST);
                lres = PSNRET_INVALID_NOCHANGEPAGE;
            }
            else
            {
                ShellMessageBox(g_hInstance, pci->hDlg,
                                 MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
                lres = PSNRET_INVALID_NOCHANGEPAGE;
            }
            break;

        default:
            // the path to something isn't allowed
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOTALLOWED_FOLDERS), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;
        }
    }

    if (lres == PSNRET_NOERROR)
    {
        pci->bDirty = FALSE;
        StringCchCopy(pci->szFolder, ARRAYSIZE(pci->szFolder), szNewFolder);
    }

    SetWindowLongPtr(pci->hDlg, DWLP_MSGRESULT, lres);
}

int _BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        // Set the caption. ('Select a destination')
        TCHAR szTitle[100];
        LoadString(g_hInstance, IDS_BROWSE_CAPTION, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
        break;

    case BFFM_SELCHANGED:
        if (lParam)
        {
            TCHAR szPath[MAX_PATH];

            szPath[0] = 0;
            SHGetPathFromIDList((LPITEMIDLIST)lParam, szPath);

            DWORD dwRes = IsPathGoodMyDocsPath(hwnd, szPath);

            if (dwRes == PATH_IS_GOOD || dwRes == PATH_IS_MYDOCS)
            {
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)TRUE);
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, 0);
            }
            else
            {
                TCHAR szStatus[128];

                SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);

                szStatus[0] = 0;
                LoadString(g_hInstance, IDS_NOSHELLEXT_FOLDERS, szStatus, ARRAYSIZE(szStatus));
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)szStatus);
            }
        }
        break;
    }

    return 0;
}

void _MakeDirty(CUSTINFO *pci)
{
    pci->bDirty = TRUE;
    pci->bSetToDefault = FALSE;
    PropSheet_Changed(GetParent(pci->hDlg), pci->hDlg);
}

void _DoFind(CUSTINFO *pci)
{
    TCHAR szPath[MAX_PATH];
    GetTargetExpandedPath(pci->hDlg, szPath, ARRAYSIZE(szPath));

    LPITEMIDLIST pidl = ILCreateFromPath(szPath);
    if (pidl)
    {
        SHOpenFolderAndSelectItems(pidl, 0, NULL, 0);
        ILFree(pidl);
    }
    else
    {
        ShellMessageBox(g_hInstance, pci->hDlg,
                     MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
    }
}

void _DoBrowse(CUSTINFO *pci)
{
    BROWSEINFO bi = {0};
    TCHAR szTitle[128];

    LoadString(g_hInstance, IDS_BROWSE_TITLE, szTitle, ARRAYSIZE(szTitle));

    bi.hwndOwner = pci->hDlg;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT | BIF_NEWDIALOGSTYLE | BIF_UAHINT;
    bi.lpfn = _BrowseCallbackProc;

    // the default root for this folder is MyDocs so we don't need to set that up.

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl)
    {
        TCHAR szName[MAX_PATH];
        if (SHGetPathFromIDList(pidl, szName))
        {
            SetDlgItemText(pci->hDlg, IDD_TARGET, szName);
            _MakeDirty(pci);
        }
        ILFree(pidl);
    }
}

void DoReset(CUSTINFO *pci)
{
    TCHAR szPath[MAX_PATH];

    if (S_OK == SHGetFolderPath(NULL, pci->csidl, NULL, SHGFP_TYPE_DEFAULT, szPath))
    {
        SetDlgItemText(pci->hDlg, IDD_TARGET, szPath);
        _MakeDirty(pci);
        pci->bSetToDefault = TRUE;  // to avoid prompt to create
    }
}

INT_PTR CALLBACK TargetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUSTINFO *pci = (CUSTINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitTargetPage(hDlg, lParam);
        return 1;

    case WM_DESTROY:
        LocalFree(pci);
        SetWindowLongPtr(hDlg, DWLP_USER, 0);
        return 1;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_RESET:
            DoReset(pci);
            return 1;

        case IDD_TARGET:
	    if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE) && pci && (pci->bInitDone) && (!pci->bDirty))
            {
                _MakeDirty(pci);
            }
            return 1;

        case IDD_FIND:
            _DoFind(pci);
            return 1;

        case IDD_BROWSE:
            _DoBrowse(pci);
            return 1;
        }
        break;

    case WM_HELP:               /* F1 or title-bar help button */
        if ((((LPHELPINFO)lParam)->iCtrlId != IDD_ITEMICON)     &&
            (((LPHELPINFO)lParam)->iCtrlId != IDD_INSTRUCTIONS) &&
            (((LPHELPINFO)lParam)->iCtrlId != IDC_TARGET_GBOX))
        {
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle,
                     NULL, HELP_WM_HELP, (DWORD_PTR) rgdwHelpTarget);
        }
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        {
            POINT p;
            HWND hwndChild;
            INT ctrlid;

            //
            // Get the point where the user clicked...
            //

            p.x = GET_X_LPARAM(lParam);
            p.y = GET_Y_LPARAM(lParam);

            //
            // Now, map that to a child control if possible...
            //

            ScreenToClient(hDlg, &p);
            hwndChild = ChildWindowFromPoint((HWND)wParam, p);
            ctrlid = GetDlgCtrlID(hwndChild);

            //
            // Don't put up the help context menu for the items
            // that don't have help...
            //
            if ((ctrlid != IDD_ITEMICON)     &&
                (ctrlid != IDD_INSTRUCTIONS))
            {
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR)rgdwHelpTarget);
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            _DoApply(pci);
            return 1;
        }
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\sources.inc ===
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

SELFREGNAME= $(O)\selfreg_mydocs.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

TARGETNAME= mydocs
TARGETTYPE= DYNLINK
TARGETPATH= obj

DLLDEF=     ..\mydocs.def
DLLENTRY=   DllMain
DLLBASE=    0x77000000

# Include ATL just to get conversion macros
USE_ATL=    1

USE_MSVCRT= 1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\user32.lib      \
            $(SDK_LIB_PATH)\gdi32.lib       \
            $(SHELL_LIB_PATH)\shell32p.lib  \
            $(CCSHELL_DIR)\lib\$(O)\shguid.lib \
            $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
            $(SHELL_LIB_PATH)\shlwapip.lib  \
            $(SHELL_LIB_PATH)\shdocvw.lib   \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(SHELL_LIB_PATH)\shfusion.lib  \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(CCSHELL_DIR)\lib\$(O)\stock.lib

INCLUDES=   ..\;$(BASE_INC_PATH);$(DS_INC_PATH);$(O)

SOURCES=    ..\copyhook.cpp    \
            ..\debug.cpp       \
            ..\dll.cpp         \
            ..\dllload.cpp     \
            ..\mydocsexts.cpp  \
            ..\prop.cpp        \
            ..\resource.rc     \
            ..\util.cpp

NTTARGETFILES=

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
 
# Fusionized
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\mydocsexts.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shellp.h>     // SHCoCreateInstance
#include <shlguidp.h>   // IID_IResolveShellLink
#include "util.h"
#include "dll.h"
#include "resource.h"
#include "prop.h"


HRESULT _GetUIObjectForMyDocs(REFIID riid, void **ppv)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
        ILFree(pidl);
    }
    return hr;
}


// send to "My Documents" handler

class CMyDocsSendTo : public IDropTarget, IPersistFile
{
public:
    CMyDocsSendTo();
    HRESULT _InitTarget();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFile
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName);

private:
    ~CMyDocsSendTo();

    LONG _cRef;
    IDropTarget *_pdtgt;
};

CMyDocsSendTo::CMyDocsSendTo() : _cRef(1)
{
    DllAddRef();
}

CMyDocsSendTo::~CMyDocsSendTo()
{
    if (_pdtgt)
        _pdtgt->Release();
    DllRelease();
}

STDMETHODIMP CMyDocsSendTo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsSendTo, IDropTarget),
        QITABENT(CMyDocsSendTo, IPersistFile), 
        QITABENTMULTI(CMyDocsSendTo, IPersist, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMyDocsSendTo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMyDocsSendTo::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CMyDocsSendTo::_InitTarget()
{
    if (_pdtgt)
        return S_OK;
    return _GetUIObjectForMyDocs(IID_PPV_ARG(IDropTarget, &_pdtgt));
}

STDMETHODIMP CMyDocsSendTo::DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragOver(grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::DragLeave()
{
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragLeave();
    return hr;
}

STDMETHODIMP CMyDocsSendTo::Drop(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->Drop(pDataObject, grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MyDocsDropTarget;
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::IsDirty(void)
{
    return S_OK;        // no
}


STDMETHODIMP CMyDocsSendTo::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (_pdtgt)
        return S_OK;
    UpdateSendToFile();    // refresh the send to target (in case the desktop icon was renamed)
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::GetCurFile(LPOLESTR *ppszFileName)
{
    *ppszFileName = NULL;
    return E_NOTIMPL;
}

HRESULT CMyDocsSendTo_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsSendTo* pdt = new CMyDocsSendTo();
    if (pdt)
    {
        *ppunk = SAFECAST(pdt, IDropTarget *);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}


// properyt page and context menu shell extension

class CMyDocsProp : public IShellPropSheetExt, public IShellExtInit
{
public:
    CMyDocsProp();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

private:
    ~CMyDocsProp();
    void _AddExtraPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

    LONG _cRef;
};

CMyDocsProp::CMyDocsProp() : _cRef(1)
{
    DllAddRef();
}

CMyDocsProp::~CMyDocsProp()
{
    DllRelease();
}

STDMETHODIMP CMyDocsProp::QueryInterface( REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsProp, IShellPropSheetExt), 
        QITABENT(CMyDocsProp, IShellExtInit), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsProp::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsProp::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMyDocsProp::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkey)
{
    return S_OK;
}

// {f81e9010-6ea4-11ce-a7ff-00aa003ca9f6}
const CLSID CLSID_CShare = {0xf81e9010, 0x6ea4, 0x11ce, 0xa7, 0xff, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6 };

// {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_RShellExt = {0x1F2E5C40, 0x9550, 0x11CE, 0x99, 0xD2, 0x00, 0xAA, 0x00, 0x6E, 0x08, 0x6C };

const CLSID *c_rgFilePages[] = {
    &CLSID_ShellFileDefExt,
    &CLSID_CShare,
    &CLSID_RShellExt,
};

const CLSID *c_rgDrivePages[] = {
    &CLSID_ShellDrvDefExt,
    &CLSID_CShare,
    &CLSID_RShellExt,
};

// add optional pages to Explore/Options.

void CMyDocsProp::_AddExtraPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    IDataObject *pdtobj;

    if (SUCCEEDED(_GetUIObjectForMyDocs(IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        TCHAR szPath[MAX_PATH];
        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);
        BOOL fDriveRoot = PathIsRoot(szPath) && !PathIsUNC(szPath);
        const CLSID** pCLSIDs = fDriveRoot ? c_rgDrivePages : c_rgFilePages;
        int nCLSIDs = (int)(fDriveRoot ? ARRAYSIZE(c_rgDrivePages) : ARRAYSIZE(c_rgFilePages));
        for (int i = 0; i < nCLSIDs; i++)
        {
            IUnknown *punk;

            // We need to CoCreate for IUnknown instead of IShellPropSheetExt because the
            // class factory for the Win9x sharing property sheet (msshrui.dll) is buggy
            // and return E_NOINTERFACE ISPSE...
            HRESULT hr = SHCoCreateInstance(NULL, pCLSIDs[i], NULL, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hr))
            {
                IShellPropSheetExt *pspse;
                hr = punk->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));
                punk->Release();
                if (SUCCEEDED(hr))
                {
                    IShellExtInit *psei;
                    if (SUCCEEDED(pspse->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
                    {
                        hr = psei->Initialize(NULL, pdtobj, NULL);
                        psei->Release();
                    }

                    if (SUCCEEDED(hr))
                        pspse->AddPages(pfnAddPage, lParam);
                    pspse->Release();
                }
            }
        }
    }
}

STDMETHODIMP CMyDocsProp::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr = S_OK;

    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_TARGET);
    psp.pfnDlgProc = TargetDlgProc;

    HPROPSHEETPAGE hPage = CreatePropertySheetPage( &psp );
    if (hPage)
    {
        pfnAddPage( hPage, lParam );
        _AddExtraPages(pfnAddPage, lParam);
    }
    return hr;
}

STDMETHODIMP CMyDocsProp::ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}

HRESULT CMyDocsProp_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsProp* pmp = new CMyDocsProp();
    if (pmp)
    {
        *ppunk = SAFECAST(pmp, IShellExtInit *);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "My Documents Folder UI"
#define VER_INTERNALNAME_STR            "mydocs"
#define VER_LEGALCOPYRIGHT_YEARS        "1997"
#define VER_ORIGINALFILENAME_STR        "mydocs.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\util.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shlobjp.h>    // SHFlushSFCache()
#include "util.h"
#include "dll.h"
#include "resource.h"
#include "sddl.h"
#include "strsafe.h"

HRESULT GetFolderDisplayName(UINT csidl, LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, &pidl)))
    {
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, pszPath, cch, NULL);
        ILFree(pidl);
    }
    return *pszPath ? S_OK : E_FAIL;
}

#define MYDOCS_CLSID  TEXT("{450d8fba-ad25-11d0-98a8-0800361b1103}") // CLSID_MyDocuments

// Create/Updates file in SendTo directory to have current display name

void UpdateSendToFile()
{
    TCHAR szSendToDir[MAX_PATH];
    
    if (S_OK == SHGetFolderPath(NULL, CSIDL_SENDTO, NULL, SHGFP_TYPE_CURRENT, szSendToDir))
    {
        // Create c:\winnt\profile\chrisg\sendto\<display name>.mydocs
        BOOL bDeleteOnly = FALSE;
        TCHAR szNewFile[MAX_PATH];
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(GetFolderDisplayName(CSIDL_PERSONAL, szName, ARRAYSIZE(szName))))
        {
            PathCleanupSpec(NULL, szName);  // map any illegal chars to file sys chars
            PathRemoveBlanks(szName);

            PathCombine(szNewFile, szSendToDir, szName);
            StringCchCat(szNewFile, ARRAYSIZE(szNewFile), TEXT(".mydocs"));
        }
        else
        {
            // we can't create a new file, because we don't have a name
            bDeleteOnly = TRUE;
        }
        
        TCHAR szFile[MAX_PATH];
        WIN32_FIND_DATA fd;

        // delete c:\winnt\profile\chrisg\sendto\*.mydocs

        PathCombine(szFile, szSendToDir, TEXT("*.mydocs"));

        HANDLE hFind = FindFirstFile(szFile, &fd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                PathCombine(szFile, szSendToDir, fd.cFileName);
                if (0 == lstrcmp(szFile, szNewFile))
                {
                    // The file that we needed to create already exists,
                    // just leave it in place instead of deleting it and
                    // then creating it again below (this fixes
                    // app compat problems - see NT bug 246932)
                    bDeleteOnly = TRUE;
                    // file now has the exact display name, MUI adjusts the return from GetFolderDisplayName and
                    // since we run this every time we dont have to worry about localizing the sendto target.
                }
                else
                {
                    DeleteFile(szFile);
                }
            } while (FindNextFile(hFind, &fd));
            FindClose(hFind);
        }

        if (!bDeleteOnly)
        {
            hFind = CreateFile(szNewFile, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFind);
                // file now has the exact display name, MUI adjusts the return from GetFolderDisplayName and
                // since we run this every time we dont have to worry about localizing the sendto target.
            }
            else
            {
                // might be illegal chars in the file name, fall back to the default MyDocs name here
            }
        }
    }
}

// test pszChild against pszParent to see if
// pszChild is equal (PATH_IS_EQUAL) or 
// a DIRECT child (PATH_IS_CHILD)

DWORD ComparePaths(LPCTSTR pszChild, LPCTSTR pszParent)
{
    DWORD dwRet = PATH_IS_DIFFERENT;

    TCHAR szParent[MAX_PATH];
    StringCchCopy(szParent, ARRAYSIZE(szParent), pszParent);

    if (PathIsRoot(szParent) && (-1 != PathGetDriveNumber(szParent)))
    {
        szParent[2] = 0;    // trip D:\ -> D: to make code below work
    }

    INT cchParent = lstrlen(szParent);
    INT cchChild = lstrlen(pszChild);

    if (cchParent <= cchChild)
    {
        TCHAR szChild[MAX_PATH];
        StringCchCopy(szChild, ARRAYSIZE(szChild), pszChild);

        LPTSTR pszChildSlice = szChild + cchParent;
        if (TEXT('\\') == *pszChildSlice)
        {
            *pszChildSlice = 0;
        }

        if (lstrcmpi(szChild, szParent) == 0)
        {
            if (cchParent < cchChild)
            {
                LPTSTR pTmp = pszChildSlice + 1;

                while (*pTmp && *pTmp != TEXT('\\'))
                {
                    pTmp++; // find second level path segments
                }

                if (!(*pTmp))
                {
                    dwRet = PATH_IS_CHILD;  // direct child
                }
            }
            else
            {
                dwRet = PATH_IS_EQUAL;
            }
        }
    }

    return dwRet;
}

// Checks the path to see if it is marked as system or read only and
// then check desktop.ini for CLSID or CLSID2 entry...

BOOL IsPathAlreadyShellFolder(LPCTSTR pszPath, DWORD dwAttrib)
{
    BOOL bIsShellFolder = FALSE;

    if (PathIsSystemFolder(pszPath, dwAttrib))
    {
        TCHAR szDesktopIni[MAX_PATH];
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // Check for CLSID entry...
        TCHAR szBuffer[MAX_PATH];
        GetPrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), TEXT("foo"), szBuffer, ARRAYSIZE(szBuffer), szDesktopIni);

        if ((lstrcmpi(szBuffer, TEXT("foo")) !=0) &&
             (lstrcmpi(szBuffer, MYDOCS_CLSID) !=0))
        {
            bIsShellFolder = TRUE;
        }

        // Check for CLSID2 entry...
        GetPrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), TEXT("foo"), szBuffer, ARRAYSIZE(szBuffer), szDesktopIni);

        if ((lstrcmpi(szBuffer, TEXT("foo")) != 0) &&
             (lstrcmpi(szBuffer, MYDOCS_CLSID) != 0))
        {
            bIsShellFolder = TRUE;
        }
    }
    return bIsShellFolder;
}

const struct
{
    DWORD dwDir;
    DWORD dwFlags;
    DWORD dwRet;
}
_adirs[] =
{
    { CSIDL_DESKTOP,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_DESKTOP   },
    { CSIDL_PERSONAL,           PATH_IS_EQUAL                , PATH_IS_MYDOCS    },
    { CSIDL_SENDTO,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_SENDTO    },
    { CSIDL_RECENT,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_RECENT    },
    { CSIDL_HISTORY,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_HISTORY   },
    { CSIDL_COOKIES,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_COOKIES   },
    { CSIDL_PRINTHOOD,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_PRINTHOOD },
    { CSIDL_NETHOOD,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_NETHOOD   },
    { CSIDL_STARTMENU,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_STARTMENU },
    { CSIDL_TEMPLATES,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_TEMPLATES },
    { CSIDL_FAVORITES,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_FAVORITES },
    { CSIDL_FONTS,              PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_FONTS     },
    { CSIDL_APPDATA,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_APPDATA   },
    { CSIDL_INTERNET_CACHE,     PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_TEMP_INET },
    { CSIDL_COMMON_STARTMENU,   PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_STARTMENU },
    { CSIDL_COMMON_DESKTOPDIRECTORY, PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_DESKTOP },
    { CSIDL_WINDOWS,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_WINDOWS },
    { CSIDL_SYSTEM,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_SYSTEM },
    { CSIDL_PROFILE,            PATH_IS_EQUAL                , PATH_IS_PROFILE },
};

BOOL PathEndsInDot(LPCTSTR pszPath)
{
    // CreateDirectory("c:\foo.") or CreateDirectory("c:\foo.....")
    // will succeed but create a directory named "c:\foo", which isn't
    // what the user asked for.  So we use this function to guard
    // against those cases.
    //
    // Note that this simple test also picks off "c:\foo\." -- ok for
    // our purposes.

    UINT cLen = lstrlen(pszPath);
    return (cLen >= 1) && (pszPath[cLen - 1] == TEXT('.'));
}

//
// Checks the path to see if it is okay as a MyDocs path
//
DWORD IsPathGoodMyDocsPath(HWND hwnd, LPCTSTR pszPath)
{
    if (NULL == pszPath)
    {
        return PATH_IS_ERROR;
    }
    
    TCHAR szRootPath[MAX_PATH];
    StringCchCopy(szRootPath, ARRAYSIZE(szRootPath), pszPath);
    if (!PathStripToRoot(szRootPath))
    {
        return PATH_IS_ERROR;
    }

    if (PathEndsInDot(pszPath))
    {
        return PATH_IS_ERROR;
    }
    
    DWORD dwRes, dwAttr = GetFileAttributes(pszPath);
    if (dwAttr == 0xFFFFFFFF)
    {
        if (0xFFFFFFFF == GetFileAttributes(szRootPath))
        {
            // If the root path doesn't exist, then we're not going
            // to be able to create a path:
            return PATH_IS_ERROR;
        }
        else
        {
            return PATH_IS_NONEXISTENT;
        }
    }

    if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
    {
        return PATH_IS_NONDIR;
    }

    for (int i = 0; i < ARRAYSIZE(_adirs); i++)
    {
        TCHAR szPathToCheck[MAX_PATH];
        //
        // Check for various special shell folders
        //
        if (S_OK == SHGetFolderPath(hwnd, _adirs[i].dwDir | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPathToCheck))
        {
            dwRes = ComparePaths(pszPath, szPathToCheck);

            if (dwRes & _adirs[i].dwFlags)
            {
                //
                // The inevitable exceptions
                //
                switch (_adirs[i].dwDir) 
                {
                case CSIDL_DESKTOP:
                    if (PATH_IS_CHILD == dwRes) 
                    {
                        continue;   // allowing subfolder of CSIDL_DESKTOP
                    }
                    break;

                default:
                    break;
                } // switch

                return _adirs[i].dwRet;
            }
        }
    }
    
    //
    // Make sure path isn't set as a system or some other kind of
    // folder that already has a CLSID or CLSID2 entry...
    //
    if (IsPathAlreadyShellFolder(pszPath, dwAttr))
    {
        return PATH_IS_SHELLFOLDER;
    }

    return PATH_IS_GOOD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mydocs2\util.h ===
#include <debug.h>
#include <shconv.h>    // for UNICODE/ANSI conversion macros

DWORD IsPathGoodMyDocsPath(HWND hwnd, LPCTSTR pPath);
void RestoreMyDocsFolder(void);
void UpdateSendToFile();
HRESULT GetFolderDisplayName(UINT csidl, LPTSTR pPath, UINT cch);

#define PATH_IS_GOOD            0x00000000
#define PATH_IS_DESKTOP         0x00000001
#define PATH_IS_PROFILE         0x00000002
#define PATH_IS_SYSTEM          0x00000003
#define PATH_IS_WINDOWS         0x00000004
#define PATH_IS_SHELLFOLDER     0x00000005
#define PATH_IS_MYDOCS          0x00000006
#define PATH_IS_NONDIR          0x00000007
#define PATH_IS_SENDTO          0x00000008
#define PATH_IS_RECENT          0x00000009
#define PATH_IS_HISTORY         0x0000000A
#define PATH_IS_COOKIES         0x0000000B
#define PATH_IS_PRINTHOOD       0x0000000C
#define PATH_IS_NETHOOD         0x0000000D
#define PATH_IS_STARTMENU       0x0000000E
#define PATH_IS_TEMPLATES       0x0000000F
#define PATH_IS_FAVORITES       0x00000010
#define PATH_IS_TEMP_INET       0x00000011
#define PATH_IS_FONTS           0x00000012
#define PATH_IS_APPDATA         0x00000013
#define PATH_IS_DRIVEROOT       0x00000014
#define PATH_IS_SYSDRIVEROOT    0x00000015
#define PATH_IS_ERROR           0x00000016
#define PATH_IS_NONEXISTENT     0x00000017
#define PATH_IS_READONLY        0x00000018

// This is a bit mask
#define PATH_IS_DIFFERENT   0x00000001
#define PATH_IS_EQUAL       0x00000002
#define PATH_IS_CHILD       0x00000004

// PATH_IS_ values returned
DWORD ComparePaths(LPCTSTR pszChild, LPCTSTR pszParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\dialog.h ===
#ifndef DIALOG_H_INCLUDED
#define DIALOG_H_INCLUDED

class CDialogBase
{
protected:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;

public:
    virtual ~CDialogBase() {}
};

class CPropertyPage: public CDialogBase
{
public:
    void SetPropSheetPageMembers(PROPSHEETPAGE* ppsp)
    {
        ppsp->lParam = (LPARAM) this;
        ppsp->pfnDlgProc = CPropertyPage::StaticProc;
    }

private:
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

class CDialog: public CDialogBase
{
public:
    INT_PTR DoModal(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent)
    {return DialogBoxParam(hInstance, lpTemplate, hWndParent, CDialog::StaticProc, (LPARAM) this);}

private:
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif //!DIALOG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\dialog.cpp ===
#include "stdafx.h"
#pragma hdrstop

INT_PTR CPropertyPage::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPropertyPage* pthis = (CPropertyPage*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    PROPSHEETPAGE* ppage;
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        ppage = (PROPSHEETPAGE*) lParam;
        pthis = (CPropertyPage*) ppage->lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;
}

INT_PTR CDialog::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialog* pthis = (CDialog*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        pthis = (CDialog*) lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\data.h ===
#ifndef DATA_H
#define DATA_H


// group info object, this holds the information about a group - name, comment etc

class CGroupInfo
{
public:
    CGroupInfo()
    {
        m_szGroup[0] = m_szComment[0] = TEXT('\0');
    }

    TCHAR m_szGroup[MAX_GROUP + 1];
    TCHAR m_szComment[MAXCOMMENTSZ];
};


// object for managing a list of groups

class CGroupInfoList: public CDPA<CGroupInfo>
{
public:
    CGroupInfoList();
    ~CGroupInfoList();

    HRESULT Initialize();

private:
    static int CALLBACK DestroyGroupInfoCallback(CGroupInfo* pGroupInfo, LPVOID pData);
    HRESULT AddGroupToList(LPCTSTR szGroup, LPCTSTR szComment);
};


// user data manager

class CUserManagerData
{
public:
    // Functions
    CUserManagerData(LPCTSTR pszCurrentDomainUser);
    ~CUserManagerData();

    HRESULT Initialize(HWND hwndUserListPage);

    BOOL IsComputerInDomain()           
        {return m_fInDomain;}
    CUserListLoader* GetUserListLoader()
        {return &m_UserListLoader;}   
    CGroupInfoList* GetGroupList()
        {return &m_GroupList;}
    CUserInfo* GetLoggedOnUserInfo()
        {return &m_LoggedOnUser;}
    TCHAR* GetComputerName()        
        {return m_szComputername;}
    
    BOOL IsAutologonEnabled();
    TCHAR* GetHelpfilePath();

    void UserInfoChanged(LPCTSTR pszUser, LPCTSTR pszDomain);
    BOOL LogoffRequired();

private:
    // Functions
    void SetComputerDomainFlag();

private:
    // Data
    // List of users read from the local security DB
    CUserInfo m_LoggedOnUser;
    CUserListLoader m_UserListLoader;
    CGroupInfoList m_GroupList;
    BOOL m_fInDomain;
    TCHAR m_szComputername[MAX_COMPUTERNAME + 1];
    TCHAR m_szHelpfilePath[MAX_PATH + 1];

    LPTSTR m_pszCurrentDomainUser;
    BOOL m_fLogoffRequired;
};

#endif //! DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\disconndlg.cpp ===
#include "stdafx.h"

// Disconnect drive dialog
// History:
//  dsheldon    11/09/2000  created

class CDisconnectDrives : public CDialog
{
private:
    void _InitializeDriveListview(HWND hwnd);
    BOOL _DriveAlreadyInList(HWND hwndList, NETRESOURCE* pnr);
    UINT _FillDriveList(HWND hwnd, DWORD dwScope);
    void _DoDisconnect(HWND hwnd);
    void _EnableButtons(HWND hwnd);
    INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Data
};

INT_PTR CDisconnectDrives::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fReturn = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szCaption[256];
            LoadString(g_hinst, IDS_DISCONNECT_CAPTION, szCaption, ARRAYSIZE(szCaption));
            SetWindowText(hwndDlg, szCaption);
            
            HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_PSW));
            SendMessage(hwndDlg, WM_SETICON, (WPARAM) ICON_BIG, (LPARAM) hIcon);
            SendMessage(hwndDlg, WM_SETICON, (WPARAM) ICON_SMALL, (LPARAM) hIcon);
            _InitializeDriveListview(hwndDlg);
            if (_FillDriveList(hwndDlg, RESOURCE_CONNECTED) + _FillDriveList(hwndDlg, RESOURCE_REMEMBERED) == 0)
            {
                DisplayFormatMessage(hwndDlg, IDS_DISCONNECTDRIVETITLE, IDS_NONETDRIVES, MB_ICONINFORMATION | MB_OK);
                EndDialog(hwndDlg, IDCANCEL);
            }
            _EnableButtons(hwndDlg);

            fReturn = TRUE;
        }
        break;
    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDOK:
                _DoDisconnect(hwndDlg);
                // Fall through
            case IDCANCEL:
                EndDialog(hwndDlg, LOWORD(wParam));
                fReturn = TRUE;
                break;
            }
        }
        break;
    case WM_NOTIFY:
        switch ((int) wParam)
        {
        case IDC_DRIVELIST:
            if (((LPNMHDR) lParam)->code == LVN_ITEMCHANGED)
            {
                _EnableButtons(hwndDlg);
            }
            break;
        }
        break;
    }

    return fReturn;
}

#define COL_LOCALNAME  0
#define COL_REMOTENAME 1
#define COL_COMMENT    2

const UINT c_auTileColumns[] = {COL_LOCALNAME, COL_REMOTENAME, COL_COMMENT};
const UINT c_auTileSubItems[] = {COL_REMOTENAME, COL_COMMENT};

void CDisconnectDrives::_InitializeDriveListview(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);
    ListView_SetView(hwndList, LV_VIEW_TILE);

    for (int i=0; i<ARRAYSIZE(c_auTileColumns); i++)
    {
        LV_COLUMN col;
        col.mask = LVCF_SUBITEM;
        col.iSubItem = c_auTileColumns[i];
        ListView_InsertColumn(hwndList, i, &col);
    }

    RECT rc;
    GetClientRect(hwndList, &rc);

    LVTILEVIEWINFO lvtvi;
    lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
    lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
    lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
    // Bug 298835 - Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
    lvtvi.sizeTile.cx = ((rc.right-rc.left) - GetSystemMetrics(SM_CXVSCROLL))/2;
    lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
    ListView_SetTileViewInfo(hwndList, &lvtvi);

    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
}

BOOL CDisconnectDrives::_DriveAlreadyInList(HWND hwndList, NETRESOURCE* pnr)
{
    BOOL fAlreadyInList = FALSE;
    if (pnr->lpLocalName)
    {
        int cItems = ListView_GetItemCount(hwndList);
        if (-1 != cItems)
        {
            int i = 0;
            while ((i < cItems) && !fAlreadyInList)
            {
                WCHAR szItem[MAX_PATH]; *szItem = 0;
                ListView_GetItemText(hwndList, i, 0, szItem, ARRAYSIZE(szItem));
                if (0 == StrCmpI(szItem, pnr->lpLocalName))
                {
                    fAlreadyInList = TRUE;
                }

                i++;
            }
        }
    }

    return fAlreadyInList;
}

UINT CDisconnectDrives::_FillDriveList(HWND hwnd, DWORD dwScope)
{
    UINT nAdded = 0;
    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);

    HANDLE hEnum = NULL;
    DWORD dwRes = WNetOpenEnum(dwScope, RESOURCETYPE_DISK, 0, NULL, &hEnum);
    if (NO_ERROR == dwRes)
    {
        do
        {
            BYTE rgBuffer[16 * 1024];
            DWORD cbSize = sizeof (rgBuffer);
            DWORD cEntries = -1;
            dwRes = WNetEnumResource(hEnum, &cEntries, (void*) rgBuffer, &cbSize);

            if ((ERROR_MORE_DATA == dwRes) ||
                (NO_ERROR == dwRes))
            {
                NETRESOURCE* pnrResults = (NETRESOURCE*) rgBuffer;

                for (DWORD iEntry = 0; iEntry < cEntries; iEntry ++)
                {
                    WCHAR szNone[MAX_PATH + 1];
                    NETRESOURCE* pnr = pnrResults + iEntry;

                    if (!_DriveAlreadyInList(hwndList, pnr))
                    {
                        nAdded ++;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                        if (pnr->lpLocalName)
                        {
                            lvi.pszText = pnr->lpLocalName;
                            lvi.lParam = TRUE; // Flag that says, "this connection has a local name (device letter)"
                        }
                        else
                        {
                            LoadString(g_hinst, IDS_NONE, szNone, ARRAYSIZE(szNone));
                            lvi.pszText = szNone;
                        }

                        lvi.iImage =  Shell_GetCachedImageIndex(L"shell32.dll", II_DRIVENET, 0x0);

                        int iItem = ListView_InsertItem(hwndList, &lvi);
                        if (iItem != -1)
                        {
                            LVTILEINFO lvti;
                            lvti.cbSize = sizeof(LVTILEINFO);
                            lvti.iItem = iItem;
                            lvti.cColumns = ARRAYSIZE(c_auTileSubItems);
                            lvti.puColumns = (UINT*)c_auTileSubItems;
                            ListView_SetTileInfo(hwndList, &lvti);

                            ListView_SetItemText(hwndList, iItem, 1, pnr->lpRemoteName);
                            ListView_SetItemText(hwndList, iItem, 2, pnr->lpComment);
                        }
                    }
                }
            }
        } while (ERROR_MORE_DATA == dwRes);

        WNetCloseEnum(hEnum);
    }

    return nAdded;
}

void CDisconnectDrives::_DoDisconnect(HWND hwnd)
{
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);
    int iSelectedItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    while (-1 != iSelectedItem)
    {
        WCHAR szRemoteName[MAX_PATH + 1];
        ListView_GetItemText(hwndList, iSelectedItem, COL_REMOTENAME, szRemoteName, ARRAYSIZE(szRemoteName));
        WCHAR szLocalName[MAX_PATH + 1];
        ListView_GetItemText(hwndList, iSelectedItem, COL_LOCALNAME, szLocalName, ARRAYSIZE(szLocalName));

        LVITEM lvi = {0};
        lvi.iItem = iSelectedItem;
        lvi.mask = LVIF_PARAM;
        ListView_GetItem(hwndList, &lvi);
        
        BOOL fHasDevice = (BOOL) lvi.lParam;

        // Try non-forcing disconnect
        DWORD dwRes = WNetCancelConnection2(fHasDevice ? szLocalName : szRemoteName, CONNECT_UPDATE_PROFILE, FALSE);

        if ((ERROR_OPEN_FILES == dwRes) ||
            (ERROR_DEVICE_IN_USE == dwRes))
        {
            if (IDYES == DisplayFormatMessage(hwnd, IDS_DISCONNECTDRIVETITLE, fHasDevice ? IDS_DISCONNECT_CONFIRM : IDS_DISCONNECT_CONFIRM_NODEV, MB_ICONWARNING | MB_YESNO, szLocalName, szRemoteName))
            {
                dwRes = WNetCancelConnection2(fHasDevice ? szLocalName : szRemoteName, CONNECT_UPDATE_PROFILE, TRUE);
            }
            else
            {
                dwRes = NO_ERROR;
            }
        }

        if (NO_ERROR != dwRes)
        {
            WCHAR szMessage[512];
            if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) dwRes, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            {
                DisplayFormatMessage(hwnd, IDS_DISCONNECTDRIVETITLE, IDS_DISCONNECTERROR, MB_ICONERROR | MB_OK, szLocalName, szRemoteName, szMessage);
            }
        }

        iSelectedItem = ListView_GetNextItem(hwndList, iSelectedItem, LVNI_SELECTED);
    }
}

void CDisconnectDrives::_EnableButtons(HWND hwnd)
{
    UINT nSelected = ListView_GetSelectedCount(GetDlgItem(hwnd, IDC_DRIVELIST));
    EnableWindow(GetDlgItem(hwnd, IDOK), (nSelected > 0));
}

STDAPI_(DWORD) SHDisconnectNetDrives(HWND hwndParent)
{
    TCHAR szCaption[256];
    LoadString(g_hinst, IDS_DISCONNECT_CAPTION, szCaption, ARRAYSIZE(szCaption));
    CEnsureSingleInstance ESI(szCaption);

    if (!ESI.ShouldExit())
    {
        CDisconnectDrives disc;
        disc.DoModal(g_hinst, MAKEINTRESOURCE(IDD_DISCONNECTDRIVES), NULL);
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\anp.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "pubwiz.h"
#pragma hdrstop


// add net place wizard (v2)

class CAddNetPlace : IWizardSite, IServiceProvider
{
public:
    CAddNetPlace();
    ~CAddNetPlace();
    void _ShowAddNetPlace();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    // dialog handlers
    static CAddNetPlace* s_GetANP(HWND hwnd, UINT uMsg, LPARAM lParam);

    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CAddNetPlace *panp = s_GetANP(hwnd, uMsg, lParam); return panp->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CAddNetPlace *panp = s_GetANP(hwnd, uMsg, lParam); return panp->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }

    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND _hwndFrame;
    LONG _cRef;

    IPublishingWizard *_ppw;            // publishing wizard object
    IResourceMap *_prm;                 // our resource map object
    CNetworkPlace _np;
};


// Construction/destruction

CAddNetPlace::CAddNetPlace() :
    _cRef(1)
{
    DllAddRef();
}

CAddNetPlace::~CAddNetPlace()
{   
    DllRelease();
}


// Reference counting of the object

ULONG CAddNetPlace::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CAddNetPlace::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CAddNetPlace::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAddNetPlace, IWizardSite),      // IID_IWizardSite
        QITABENT(CAddNetPlace, IServiceProvider), // IID_IServiceProvider
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// Helper functions

CAddNetPlace* CAddNetPlace::s_GetANP(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CAddNetPlace*)ppsp->lParam;
    }
    return (CAddNetPlace*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// Welcome/Intro dialog

INT_PTR CAddNetPlace::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndFrame = GetParent(hwnd);
            SendDlgItemMessage(hwnd, IDC_PUB_WELCOME, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);

            IXMLDOMNode *pdn;
            HRESULT hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("welcome"), &pdn);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[1024];

                _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOME, szBuffer);

                _prm->LoadString(pdn, TEXT("description"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOMEPROMPT, szBuffer);

                pdn->Release();
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    return TRUE;              

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// Were done, so lets create the link etc.

INT_PTR CAddNetPlace::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_PUB_DONE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);            
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case NM_CLICK:
                case NM_RETURN:
                    if (pnmh->idFrom == IDC_PUB_COMPLETEMSG)
                    {
                        _np.CreatePlace(hwnd, TRUE);
                        return TRUE;
                    }
                    break;

                case PSN_SETACTIVE:
                {
                    TCHAR szTemp[INTERNET_MAX_URL_LENGTH] = {0}; 
                    TCHAR szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH];

                    // using the manifest lets work out where the net place was created to.
                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = _ppw->GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdnUploadInfo;
                        if (S_OK == pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdnUploadInfo))
                        {
                            hr = GetURLFromElement(pdnUploadInfo, ELEMENT_TARGET, szTemp, ARRAYSIZE(szTemp));
                            if (SUCCEEDED(hr))
                            {
                                // set the target so that we create the place
                                _np.SetTarget(NULL, szTemp, NPTF_VALIDATE | NPTF_ALLOWWEBFOLDERS);

                                IXMLDOMNode *pdnTarget;
                                hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdnTarget);
                                if (hr == S_OK)
                                {
                                    // get the user name (for the FTP case)

                                    if (SUCCEEDED(GetStrFromAttribute(pdnTarget, ATTRIBUTE_USERNAME, szBuffer, ARRAYSIZE(szBuffer))))
                                        _np.SetLoginInfo(szBuffer, NULL);                        

                                    // lets get the prefered display name, if this is not found then we will default to
                                    // using the name generated by the net places code.

                                    if (SUCCEEDED(GetStrFromAttribute(pdnUploadInfo, ATTRIBUTE_FRIENDLYNAME, szTemp, ARRAYSIZE(szTemp))))
                                        _np.SetName(NULL, szTemp);

                                    pdnTarget->Release();
                                }
                            }
                            pdnUploadInfo->Release();
                        }

                        pdocManifest->Release();
                    }

                    // lets format up the text for the control.
                    FormatMessageString(IDS_ANP_SUCCESS, szBuffer, ARRAYSIZE(szBuffer), szTemp);
                    SetDlgItemText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);                                
                
                    // lets move the controls accordingly
                    UINT ctls[] = { IDC_PUB_OPENFILES };
                    int dy = SizeControlFromText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);
                    MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);
                    
                    // default to opening the place when the user closes this wizard.
                    CheckDlgButton(hwnd, IDC_PUB_OPENFILES, TRUE);
                
                    // were done.
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    _np.CreatePlace(hwnd, (IsDlgButtonChecked(hwnd, IDC_PUB_OPENFILES) == BST_CHECKED));
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)FALSE);
                    return TRUE;
                }
            }
            break;
        }
    }
    
    return FALSE;
}


// IServiceProvider 

STDMETHODIMP CAddNetPlace::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_ResourceMap)
        return _prm->QueryInterface(riid, ppv);

    *ppv = NULL;
    return E_FAIL;
}


// Site object helpers, these allow nagivation back and forward in the wizard

HRESULT CAddNetPlace::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_WELCOME);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}

HRESULT CAddNetPlace::GetNextPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_ANP_DONE);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}


// main entry point which shows the wizard

void CAddNetPlace::_ShowAddNetPlace()
{
    struct
    {
        INT idPage;
        INT idHeading;
        INT idSubHeading;
        DWORD dwFlags;
        DLGPROC dlgproc;
    }
    c_wpPages[] =
    {
        {IDD_PUB_WELCOME, 0, 0, PSP_HIDEHEADER, CAddNetPlace::s_WelcomeDlgProc},
        {IDD_ANP_DONE, 0, 0, PSP_HIDEHEADER, CAddNetPlace::s_DoneDlgProc},
    };

    // create the page array, we add the welcome page and the finished page
    // the rest is loaded as an extension to the wizard.

    HPROPSHEETPAGE hpages[10] = { 0 };
    for (int i = 0; i < ARRAYSIZE(c_wpPages) ; i++ )
    {                           
        PROPSHEETPAGE psp = { 0 };
        psp.dwSize = SIZEOF(PROPSHEETPAGE);
        psp.hInstance = g_hinst;
        psp.lParam = (LPARAM)this;
        psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | c_wpPages[i].dwFlags;
        psp.pszTemplate = MAKEINTRESOURCE(c_wpPages[i].idPage);
        psp.pfnDlgProc = c_wpPages[i].dlgproc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_ANP_CAPTION);
        psp.pszHeaderTitle = MAKEINTRESOURCE(c_wpPages[i].idHeading);
        psp.pszHeaderSubTitle = MAKEINTRESOURCE(c_wpPages[i].idSubHeading);
        hpages[i] = CreatePropertySheetPage(&psp);
    }

    // create the wizard extension (for publishing) and have it append its
    // pages, if that succeeds then lets show the wizard.

    HRESULT hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
    if (SUCCEEDED(hr))
    {
        hr = _prm->LoadResourceMap(TEXT("wizard"), TEXT("AddNetPlace"));
        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_PublishingWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPublishingWizard, &_ppw));
            if (SUCCEEDED(hr))
            {
                hr = _ppw->Initialize(NULL, SHPWHF_NOFILESELECTOR|SHPWHF_VALIDATEVIAWEBFOLDERS, TEXT("AddNetPlace"));          
                if (SUCCEEDED(hr))
                {
                    IUnknown_SetSite(_ppw, SAFECAST(this, IWizardSite*));           // we are the site
    
                    UINT nPages;
                    hr = _ppw->AddPages(&hpages[i], ARRAYSIZE(hpages)-i, &nPages);
                    if (SUCCEEDED(hr))
                    {
                        PROPSHEETHEADER psh = { 0 };
                        psh.dwSize = SIZEOF(PROPSHEETHEADER);
                        psh.hInstance = g_hinst;
                        psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
                        psh.pszbmHeader = MAKEINTRESOURCE(IDB_ANP_BANNER);
                        psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ANP_WATERMARK);
                        psh.phpage = hpages;
                        psh.nPages = i+nPages;
                        PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_ADDNETPLACE));
                    }

                    IUnknown_SetSite(_ppw, NULL); 
                }
                _ppw->Release();
            }
        }
        _prm->Release();
    }
}


// RunDll entry point used by the world to access the Add Net Place wizard.

void APIENTRY AddNetPlaceRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        CAddNetPlace *panp = new CAddNetPlace;
        if (panp)
        {
            panp->_ShowAddNetPlace();
            panp->Release();
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\data.cpp ===
#include "stdafx.h"
#include "resource.h"
#pragma hdrstop


// group list management

CGroupInfoList::CGroupInfoList()
{
}

CGroupInfoList::~CGroupInfoList()
{
    if (HDPA())
        DestroyCallback(DestroyGroupInfoCallback, NULL);
}

int CGroupInfoList::DestroyGroupInfoCallback(CGroupInfo* pGroupInfo, LPVOID pData)
{
    delete pGroupInfo;
    return 1;
}

HRESULT CGroupInfoList::Initialize()
{
    HRESULT hr = S_OK;
    
    NET_API_STATUS status;
    DWORD_PTR dwResumeHandle = 0;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;

    if (HDPA())
        DestroyCallback(DestroyGroupInfoCallback, NULL);

    // Create new list initially with 8 items
    if (Create(8))
    {
        // Now begin enumerating local groups
        LOCALGROUP_INFO_1* prgGroupInfo;

        // Read each local group
        BOOL fBreakLoop = FALSE;
        while (!fBreakLoop)
        {
            status = NetLocalGroupEnum(NULL, 1, (BYTE**) &prgGroupInfo, 
                8192, &dwEntriesRead, &dwTotalEntries, 
                &dwResumeHandle);

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
            {
                // We got some local groups - add information for all users in these local
                // groups to our list
                DWORD iGroup;
                for (iGroup = 0; iGroup < dwEntriesRead; iGroup ++)
                {

                    AddGroupToList(prgGroupInfo[iGroup].lgrpi1_name, 
                        prgGroupInfo[iGroup].lgrpi1_comment);
                }

                NetApiBufferFree((BYTE*) prgGroupInfo);
            
                // Maybe we don't have to try NetLocalGroupEnum again (if we got all the groups)
                fBreakLoop = (dwEntriesRead == dwTotalEntries);
            }
            else
            {
                fBreakLoop = TRUE;
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CGroupInfoList::AddGroupToList(LPCTSTR szGroup, LPCTSTR szComment)
{
    CGroupInfo* pGroupInfo = new CGroupInfo();
    if (!pGroupInfo)
        return E_OUTOFMEMORY;

    StrCpyN(pGroupInfo->m_szGroup, szGroup, ARRAYSIZE(pGroupInfo->m_szGroup));
    StrCpyN(pGroupInfo->m_szComment, szComment, ARRAYSIZE(pGroupInfo->m_szComment));
    return (-1 != AppendPtr(pGroupInfo)) ? S_OK : E_OUTOFMEMORY;
}


// user data manager

CUserManagerData::CUserManagerData(LPCTSTR pszCurrentDomainUser)
{
    m_szHelpfilePath[0] = TEXT('\0');

    // Initialize everything except for the user loader thread
    // and the group list here; the rest is done in
    // ::Initialize.
    
    // Fill in the computer name
    DWORD cchComputername = ARRAYSIZE(m_szComputername);
    ::GetComputerName(m_szComputername, &cchComputername);
 
    // Detect if 'puter is in a domain
    SetComputerDomainFlag();

    // Get the current user information
    DWORD cchUsername = ARRAYSIZE(m_LoggedOnUser.m_szUsername);
    DWORD cchDomain = ARRAYSIZE(m_LoggedOnUser.m_szDomain);
    GetCurrentUserAndDomainName(m_LoggedOnUser.m_szUsername, &cchUsername,
        m_LoggedOnUser.m_szDomain, &cchDomain);

    // Get the extra data for this user
    m_LoggedOnUser.GetExtraUserInfo();

    // We'll set logoff required only if the current user has been updated
    m_pszCurrentDomainUser = (LPTSTR) pszCurrentDomainUser;
    m_fLogoffRequired = FALSE;
}

CUserManagerData::~CUserManagerData()
{
}

HRESULT CUserManagerData::Initialize(HWND hwndUserListPage)
{
    CWaitCursor cur;
    m_GroupList.Initialize();
    m_UserListLoader.Initialize(hwndUserListPage);
    return S_OK;
}


// Registry access constants for auto admin logon
static const TCHAR szWinlogonSubkey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
static const TCHAR szAutologonValueName[] = TEXT("AutoAdminLogon");
static const TCHAR szDefaultUserNameValueName[] = TEXT("DefaultUserName");
static const TCHAR szDefaultDomainValueName[] = TEXT("DefaultDomainName");
static const TCHAR szDefaultPasswordValueName[] = TEXT("DefaultPassword");

BOOL CUserManagerData::IsAutologonEnabled()
{
    BOOL fAutologon = FALSE;

    // Read the registry to see if autologon is enabled
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szWinlogonSubkey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szResult[2];
        DWORD dwType;
        DWORD cbSize = sizeof(szResult);
        if (RegQueryValueEx(hkey, szAutologonValueName, 0, &dwType, (BYTE*) szResult, &cbSize) == ERROR_SUCCESS)
        {
            long lResult = StrToLong(szResult);
            fAutologon = (lResult != 0);
        }
        RegCloseKey(hkey);
    }

    return (fAutologon);
}

void CUserManagerData::SetComputerDomainFlag()
{
    m_fInDomain = ::IsComputerInDomain();
}

TCHAR* CUserManagerData::GetHelpfilePath()
{
    static const TCHAR szHelpfileUnexpanded[] = TEXT("%systemroot%\\system32\\users.hlp");
    if (m_szHelpfilePath[0] == TEXT('\0'))
    {
        ExpandEnvironmentStrings(szHelpfileUnexpanded, m_szHelpfilePath, 
            ARRAYSIZE(m_szHelpfilePath));
    }
    return (m_szHelpfilePath);
}

void CUserManagerData::UserInfoChanged(LPCTSTR pszUser, LPCTSTR pszDomain)
{
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2]; szDomainUser[0] = 0;

    MakeDomainUserString(pszDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));

    if (StrCmpI(szDomainUser, m_pszCurrentDomainUser) == 0)
    {
        m_fLogoffRequired = TRUE;
    }
}

BOOL CUserManagerData::LogoffRequired()
{
    return (m_fLogoffRequired);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\getpp.cpp ===
#include "stdafx.h"
#pragma hdrstop

#define PROPERTY_PASSPORTUSER               L"PassportUser"
#define PROPERTY_PASSPORTPASSWORD           L"PassportPassword"
#define PROPERTY_PASSPORTREMEMBERPASSWORD   L"PassportRememberPassword"
#define PROPERTY_PASSPORTUSEMSNEMAIL        L"PassportUseMSNExplorerEmail"
#define PROPERTY_PASSPORTMARSAVAILABLE      L"PassportMSNExplorerAvailable"

// Wizard pages
#define WIZPAGE_WELCOME         0
#define WIZPAGE_FINISH          1
#define WIZPAGE_STARTOFEXT      2    // First webwizard extension page
#define WIZPAGE_MAX             10

#define REGKEY_PASSPORT_INTERNET_SETTINGS     L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport"
#define REGVAL_PASSPORT_WIZARDCOMPLETE        L"RegistrationCompleted"
#define REGVAL_PASSPORT_NUMBEROFWIZARDRUNS    L"NumRegistrationRuns"

void BoldControl(HWND hwnd, int id);

class CPassportWizard : public IWizardSite, IServiceProvider, IPassportWizard
{
public:
    CPassportWizard();
    ~CPassportWizard();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IPassportWizard
    STDMETHODIMP Show(HWND hwndParent);
    STDMETHODIMP SetOptions(DWORD dwOptions);

protected:
    static CPassportWizard* s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam);    

    // Page Procs
    static INT_PTR CALLBACK s_WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPassportWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_WelcomePageProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR CALLBACK s_FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPassportWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FinishPageProc(hwnd, uMsg, wParam, lParam); }

    INT_PTR _WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _CreateMyWebDocumentsLink();
    HRESULT _ApplyChanges(HWND hwnd);
    HRESULT _CreateWizardPages(void);
    HRESULT _SetURLFromNexus();
    HRESULT _GetCurrentPassport();
    HRESULT _LaunchHotmailRegistration();
    BOOL _IsMSNExplorerAvailableForEmail();
    HRESULT _UseMSNExplorerForEmail();

    INT_PTR _WizardNext(HWND hwnd, int iPage);

    LONG _cRef;
    IPropertyBag* _ppb;                         // Property Bag 
    IWebWizardExtension* _pwwe;                 // Wizard host - used for HTML pages
    HPROPSHEETPAGE _rgWizPages[WIZPAGE_MAX];
};

STDAPI CPassportWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPassportWizard *pPPW = new CPassportWizard();
    if (!pPPW)
        return E_OUTOFMEMORY;

    HRESULT hr = pPPW->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pPPW->Release();
    return hr;
}

CPassportWizard::CPassportWizard() :
    _cRef(1)
{}

CPassportWizard::~CPassportWizard()
{
    ATOMICRELEASE(_ppb);
    ATOMICRELEASE(_pwwe);
}

// IUnknown
ULONG CPassportWizard::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPassportWizard::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPassportWizard::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPassportWizard, IServiceProvider),   // IID_IServiceProvider
        QITABENT(CPassportWizard, IWizardSite),        // IID_IWizardSite
        QITABENT(CPassportWizard, IModalWindow),       // IID_IModalWindow
        QITABENT(CPassportWizard, IPassportWizard),    // IID_IModalWindow
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IWizardSite
STDMETHODIMP CPassportWizard::GetNextPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _rgWizPages[WIZPAGE_FINISH];
    return S_OK;
}

STDMETHODIMP CPassportWizard::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _rgWizPages[WIZPAGE_WELCOME];
    return S_OK;
}


// IServiceProvider
STDMETHODIMP CPassportWizard::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;                // no result yet

    if (guidService == SID_WebWizardHost)
    {
        if (riid == IID_IPropertyBag)
            hr = _ppb->QueryInterface(riid, ppv);
    }

    return hr;
}

// IModalWindow

#define WIZDLG(name, dlgproc, dwFlags)   \
    { MAKEINTRESOURCE(IDD_GETPP_##name##), dlgproc, MAKEINTRESOURCE(IDS_GETPP_HEADER_##name##), MAKEINTRESOURCE(IDS_GETPP_SUBHEADER_##name##), dwFlags }

HRESULT CPassportWizard::_CreateWizardPages(void)
{
    static const WIZPAGE c_wpPages[] =
    {    
        WIZDLG(WELCOME,           CPassportWizard::s_WelcomePageProc,     PSP_HIDEHEADER),
        WIZDLG(FINISH,            CPassportWizard::s_FinishPageProc,      PSP_HIDEHEADER),
    };

    // if we haven't created the pages yet, then lets initialize our array of handlers.

    if (!_rgWizPages[0])
    {
        INITCOMMONCONTROLSEX iccex = { 0 };
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
        InitCommonControlsEx(&iccex);
        LinkWindow_RegisterClass();

        for (int i = 0; i < ARRAYSIZE(c_wpPages) ; i++ )
        {                           
            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = SIZEOF(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.lParam = (LPARAM)this;
            psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | 
                          PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                          c_wpPages[i].dwFlags;

            psp.pszTemplate = c_wpPages[i].idPage;
            psp.pfnDlgProc = c_wpPages[i].pDlgProc;
            psp.pszTitle = MAKEINTRESOURCE(IDS_GETPP_CAPTION);
            psp.pszHeaderTitle = c_wpPages[i].pHeading;
            psp.pszHeaderSubTitle = c_wpPages[i].pSubHeading;

            _rgWizPages[i] = CreatePropertySheetPage(&psp);
            if (!_rgWizPages[i])
            {
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

HRESULT CPassportWizard::_SetURLFromNexus()
{
    WCHAR szURL[INTERNET_MAX_URL_LENGTH];
    HRESULT hr = PassportGetURL(PASSPORTURL_REGISTRATION, szURL, ARRAYSIZE(szURL));
    if (SUCCEEDED(hr))
    {
        hr = _pwwe->SetInitialURL(szURL);
    }
    else
    {
        // Cause the webserviceerror to appear since we can't get a good URL
        hr = _pwwe->SetInitialURL(L"");
    }

    return hr;
}

HRESULT CPassportWizard::Show(HWND hwndParent)
{
    // create our wizard pages, these are required before we do anything
    HRESULT hr = _CreateWizardPages();
    if (SUCCEEDED(hr))
    {
        // we interface with the wizard host via a property bag, so lets create an
        // initialize that before we proceed.
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &_ppb));
        if (SUCCEEDED(hr))
        {
            // Provide a property telling Passport if MSN Explorer is available as an e-mail client
            // in the start menu
            SHPropertyBag_WriteBOOL(_ppb, PROPERTY_PASSPORTMARSAVAILABLE, _IsMSNExplorerAvailableForEmail());

            // create the object which will host the HTML wizard pages, these are shown in the frame
            hr = CoCreateInstance(CLSID_WebWizardHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWebWizardExtension, &_pwwe));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_pwwe, SAFECAST(this, IServiceProvider*));
        
                UINT cExtnPages = 0;
                hr = _pwwe->AddPages(_rgWizPages + WIZPAGE_STARTOFEXT, WIZPAGE_MAX - WIZPAGE_STARTOFEXT, &cExtnPages);
                if (SUCCEEDED(hr))
                {
                    PROPSHEETHEADER psh = { 0 };
                    psh.hwndParent = hwndParent;
                    psh.dwSize = SIZEOF(PROPSHEETHEADER);
                    psh.hInstance = g_hinst;
                    psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_STRETCHWATERMARK | PSH_HEADER | PSH_WATERMARK;
                    psh.pszbmHeader = MAKEINTRESOURCE(IDB_GETPP_BANNER);
                    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_GETPP_WATERMARK);
                    psh.phpage = _rgWizPages;
                    psh.nPages = (cExtnPages + WIZPAGE_STARTOFEXT);
                    psh.nStartPage = WIZPAGE_WELCOME;

                    // Return S_FALSE on cancel; otherwise S_OK;
                    hr = PropertySheet(&psh) ? S_OK : S_FALSE;
                }

                IUnknown_SetSite(_pwwe, NULL);
                ATOMICRELEASE(_pwwe);
            }
        }
        ATOMICRELEASE(_ppb);    
    }
    return hr;
}

HRESULT CPassportWizard::SetOptions(DWORD dwOptions)
{
    // Options are ignored
    return S_OK;
}

CPassportWizard* CPassportWizard::s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPassportWizard*)ppsp->lParam;
    }
    return (CPassportWizard*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

INT_PTR CPassportWizard::_WizardNext(HWND hwnd, int iPage)
{
    PropSheet_SetCurSel(GetParent(hwnd), _rgWizPages[iPage], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    return TRUE;
}

INT_PTR CPassportWizard::_WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
                BoldControl(hwnd, IDC_BOLD1);
                // Increment "NumRegistrationRuns" value in the registry
                HKEY hkey;
                if (NO_ERROR == RegCreateKeyEx(HKEY_CURRENT_USER, REGKEY_PASSPORT_INTERNET_SETTINGS, NULL, NULL, 0, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, &hkey, NULL))
                {
                    DWORD dwType;
                    DWORD nRuns;
                    DWORD cb = sizeof (nRuns);
                    if ((NO_ERROR != RegQueryValueEx(hkey, REGVAL_PASSPORT_NUMBEROFWIZARDRUNS, NULL, &dwType, (LPBYTE) &nRuns, &cb)) ||
                        (REG_DWORD != dwType))
                    {
                        nRuns = 0;
                    }

                    nRuns ++;
                    RegSetValueEx(hkey, REGVAL_PASSPORT_NUMBEROFWIZARDRUNS, NULL, REG_DWORD, (const BYTE *) &nRuns, sizeof (nRuns));
                    RegCloseKey(hkey);
                }
            }
            return TRUE;
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    return TRUE;
                case PSN_WIZNEXT:
                {
                    // we need ICW to have executed before we navigate to webbased UI
                    LaunchICW();
                    
                    if (SUCCEEDED(_SetURLFromNexus()))
                    {
                        HPROPSHEETPAGE hpageNext;
                        if (SUCCEEDED(_pwwe->GetFirstPage(&hpageNext)))
                        {
                            PropSheet_SetCurSel(GetParent(hwnd), hpageNext, -1);
                        }
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
                    return TRUE;
                }
                case NM_CLICK:
                case NM_RETURN:
                    switch ((int) wParam)
                    {
                        case IDC_PRIVACYLINK:
                            {
                                WCHAR szURL[INTERNET_MAX_URL_LENGTH];
                                HRESULT hr = PassportGetURL(PASSPORTURL_PRIVACY, szURL, ARRAYSIZE(szURL));
                                if (SUCCEEDED(hr))
                                {
                                    WCHAR szURLWithLCID[INTERNET_MAX_URL_LENGTH];
                                    LPCWSTR pszFormat = StrChr(szURL, L'?') ? L"%s&pplcid=%d":L"%s?pplcid=%d";
                                    if (wnsprintf(szURLWithLCID, ARRAYSIZE(szURLWithLCID), pszFormat, szURL, GetUserDefaultLCID()) > 0)
                                    {
                                        // Open the browser to the privacy policy site
                                        SHELLEXECUTEINFO shexinfo = {0};
                                        shexinfo.cbSize = sizeof (shexinfo);
                                        shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
                                        shexinfo.nShow = SW_SHOWNORMAL;
                                        shexinfo.lpFile = szURL;
                                        shexinfo.lpVerb = TEXT("open");
                                        ShellExecuteEx(&shexinfo);
                                    }                                    
                                }                                
                            }
                            return TRUE;
                    }
            }
            return FALSE;
        }
    }
    return FALSE;
}

// Make sure MSN Explorer exists as an email client
BOOL CPassportWizard::_IsMSNExplorerAvailableForEmail()
{
    BOOL fAvailable = FALSE;
    HKEY hkeyMSNEmail;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Clients\\Mail\\MSN Explorer", 0, KEY_READ, &hkeyMSNEmail))
    {
        fAvailable = TRUE;
        RegCloseKey(hkeyMSNEmail);
    }

    return fAvailable;
}

HRESULT CPassportWizard::_UseMSNExplorerForEmail()
{
    HRESULT hr = E_FAIL;

    if (_IsMSNExplorerAvailableForEmail())
    {
        HKEY hkeyDefaultEmail;
        // Change the default email program for the current user only
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Clients\\Mail", 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyDefaultEmail, NULL))
        {
            static WCHAR szMSNExplorer[] = L"MSN Explorer";
            if (ERROR_SUCCESS == RegSetValueEx(hkeyDefaultEmail, L"", 0, REG_SZ, (BYTE*) szMSNExplorer, sizeof(szMSNExplorer)))
            {
                hr = S_OK;

                SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Clients\\Mail"));
            }

            RegCloseKey(hkeyDefaultEmail);
        }
    }

    return hr;
}

HRESULT CPassportWizard::_ApplyChanges(HWND hwnd)
{
    // Read user, password, and auth DA.
    WCHAR szPassportUser[1024];
    HRESULT hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTUSER, szPassportUser, ARRAYSIZE(szPassportUser));
    if (SUCCEEDED(hr) && *szPassportUser)
    {
        WCHAR szPassportPassword[256];
        hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTPASSWORD, szPassportPassword, ARRAYSIZE(szPassportPassword));
        if (SUCCEEDED(hr) && *szPassportPassword)
        {
            BOOL fRememberPW = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPERTY_PASSPORTREMEMBERPASSWORD, FALSE);
            if (ERROR_SUCCESS == CredUIStoreSSOCredW(NULL, szPassportUser, szPassportPassword, fRememberPW))
            {
                hr = S_OK;

                // Write "RegistrationCompleted" value into the registry
                DWORD dwValue = 1;
                SHSetValue(HKEY_CURRENT_USER, REGKEY_PASSPORT_INTERNET_SETTINGS, REGVAL_PASSPORT_WIZARDCOMPLETE, REG_DWORD, &dwValue, sizeof (dwValue));

#if 0
                if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_MYWEBDOCUMENTSLINK, BM_GETCHECK, 0, 0))
                {
                    // Temporarily commented out - _CreateMyWebDocumentsLink();
                }

#endif
            }
            else
            {
                hr = E_FAIL;
            }

            if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPERTY_PASSPORTUSEMSNEMAIL, FALSE))
            {
                _UseMSNExplorerForEmail();
            }
        }
    }

    return hr;
}

INT_PTR CPassportWizard::_FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    // Temporarily commented out - SendDlgItemMessage(hwnd, IDC_MYWEBDOCUMENTSLINK, BM_SETCHECK, (WPARAM) BST_CHECKED, 0);

                    WCHAR szPassportUser[1024];

                    // Try to get the passport user name... we may have to add an error page if this fails... TODO
                    HRESULT hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTUSER, szPassportUser, ARRAYSIZE(szPassportUser));
                    if (SUCCEEDED(hr) && *szPassportUser)
                    {
                        SetDlgItemText(hwnd, IDC_YOURPASSPORT, szPassportUser);
                    }

                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_FINISH);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    // Previous page is the web wizard host.
                    if (SUCCEEDED(_SetURLFromNexus()))
                    {
                        HPROPSHEETPAGE hpageNext;
                        if (SUCCEEDED(_pwwe->GetFirstPage(&hpageNext)))
                        {
                            PropSheet_SetCurSel(GetParent(hwnd), hpageNext, -1);
                        }
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;

                case PSN_WIZFINISH:
                    _ApplyChanges(hwnd);
                    return TRUE;
            }
            break;
        }
    }
    return FALSE;
}

// Help requires a rundll entrypoint to run passport wizard
void APIENTRY PassportWizardRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IPassportWizard* pPW = NULL;
        hr = CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW));
        if (SUCCEEDED(hr))
        {
            pPW->SetOptions(PPW_LAUNCHEDBYUSER);
            pPW->Show(hwndStub);
            pPW->Release();
        }

        CoUninitialize();
    }
}

void BoldControl(HWND hwnd, int id)
{
    HWND hwndTitle = GetDlgItem(hwnd, id);

    // Get the existing font
    HFONT hfontOld = (HFONT) SendMessage(hwndTitle, WM_GETFONT, 0, 0);

    LOGFONT lf = {0};
    if (GetObject(hfontOld, sizeof(lf), &lf))
    {
        lf.lfWeight = FW_BOLD;

        HFONT hfontNew = CreateFontIndirect(&lf);
        if (hfontNew)
        {
            SendMessage(hwndTitle, WM_SETFONT, (WPARAM) hfontNew, FALSE);

            // Don't do this, its shared.
            // DeleteObject(hfontOld);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\dll.cpp ===
#include "stdafx.h"
#include "advpub.h"         // For REGINSTALL
#pragma hdrstop

#define DECL_CRTFREE
#include <crtfree.h>


// Fix the debug builds
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "netplwiz"
#define SZ_MODULE           "NETPLWIZ"

#define DECLARE_DEBUG
#include "debug.h"


// shell/lib files look for this instance variable
EXTERN_C HINSTANCE g_hinst = 0;
LONG g_cLocks = 0;
BOOL g_bMirroredOS = FALSE;


// DLL lifetime stuff

STDAPI_(BOOL) DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hinstDLL;
        g_hinst = hinstDLL;                         // For shell/lib files who extern him
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        SHFusionInitializeFromModule(hinstDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanUpIntroFont();
        SHFusionUninitialize();
    }
    
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;                        
}

STDAPI DllCanUnloadNow()
{
    return (g_cLocks == 0) ? S_OK:S_FALSE;
}
 
STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cLocks );
    InterlockedDecrement(&g_cLocks);
}


// helper to handle the SELFREG.INF parsing

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    _CallRegInstall("UnregDll", TRUE);

    HRESULT hres = _CallRegInstall("RegDll", FALSE);
    if ( SUCCEEDED(hres) )
    {
        // if this is server set the policy to restrict web publishing
        if (IsOS(OS_ANYSERVER))
        {
            hres = _CallRegInstall("RegDllServer", FALSE);
        }
        else
        {
            // this is a workstation; lets install the users and  password cpl
            hres = _CallRegInstall("RegDllWorkstation", FALSE);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer()
{
    return S_OK;
}


//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY( &CLSID_PublishingWizard, CPublishingWizard_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PublishDropTarget, CPublishDropTarget_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_UserPropertyPages, CUserPropertyPages_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_InternetPrintOrdering, CPublishDropTarget_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PassportWizard, CPassportWizard_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PassportClientServices, CPassportClientServices_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        _ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
 
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
            }
        }

    }

#ifdef ATL_ENABLED
    if (hr == CLASS_E_CLASSNOTAVAILABLE)
        hr = AtlGetClassObject(rclsid, riid, ppv);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\grpinfo.h ===
#ifndef GRPINFO_H_INCLUDED
#define GRPINFO_H_INCLUDED


// base implementation of the page/wizard object - handles state

class CGroupPageBase
{
public:
    // Public interface (in the case where you're not using a derived class
    CGroupPageBase(CUserInfo* pUserInfo, CDPA<CGroupInfo>* pGroupList);

    ~CGroupPageBase() 
    {
        if (NULL != m_hBoldFont)
            DeleteObject((HGDIOBJ) m_hBoldFont);
    }

    INT_PTR HandleGroupMessage(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL GetSelectedGroup(HWND hwnd, LPTSTR pszGroupOut, DWORD cchGroup, CUserInfo::GROUPPSEUDONYM* pgsOut);

protected:

    void InitializeLocalGroupCombo(HWND hwndCombo);
    void SetGroupDescription(HWND hwndCombo, HWND hwndEdit);
    void BoldGroupNames(HWND hwnd);
    void SelectGroup(HWND hwnd, LPCTSTR pszSelect);
    UINT RadioIdForGroup(LPCTSTR pszGroup);

protected:
    // Message handlers
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnRadioChanged(HWND hwnd, UINT idRadio);

protected:
    // Data
    CUserInfo* m_pUserInfo;
    CDPA<CGroupInfo>* m_pGroupList;
    HFONT m_hBoldFont;
};


// wizard page for exposing the group membership

class CGroupWizardPage: public CPropertyPage, public CGroupPageBase
{
public:
    CGroupWizardPage(CUserInfo* pUserInfo, 
        CDPA<CGroupInfo>* pGroupList): 
        CGroupPageBase(pUserInfo, pGroupList) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};


// property page for exposing group membership

class CGroupPropertyPage: public CPropertyPage, public CGroupPageBase
{
public:
    CGroupPropertyPage(CUserInfo* pUserInfo,
        CDPA<CGroupInfo>* pGroupList): 
        CGroupPageBase(pUserInfo, pGroupList) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};


#endif // !GRPINFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\helpids.h ===
#ifndef HELPIDS_USR_H
#define HELPIDS_USR_H

#define IDH_USER_LIST               1210    // User list box
#define IDH_ADDUSER_BUTTON          1211    // Add User button
#define IDH_REMOVEUSER_BUTTON       1212    // Remove User button
#define IDH_USERPROPERTIES_BUTTON   1213    // Properties button
#define IDH_PASSWORD_BUTTON         1216    // Set Password button
#define IDH_ADVANCED_BUTTON         1220    // Advanced button
#define IDH_SECUREBOOT_CHECK        1225    // Require c-a-d checkbox
#define IDH_AUTOLOGON_CHECK         1226    // Require user name and pw to log on
#define IDH_MANAGEPWD_BUTTON        1218    // Keyring button
#define IDH_PASSPORTWIZARD          1223    // Passport wizard button
 
#endif // !HELPIDS_USR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\grpinfo.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#pragma hdrstop

// Names of groups retrieved by SID
WCHAR g_szPowerUsers[MAX_GROUP + 1];
WCHAR g_szUsers[MAX_GROUP + 1];


/**************************************************************
 CGroupPageBase Implementation

  Functions common to both the group prop page and the group
  wizard page.
**************************************************************/
CGroupPageBase::CGroupPageBase(CUserInfo* pUserInfo, CDPA<CGroupInfo>* pGroupList)
{
    m_pUserInfo = pUserInfo;
    m_pGroupList = pGroupList;
    m_hBoldFont = NULL;
    
    // Load names for local groups based on SID
    if (FAILED(LookupLocalGroupName(DOMAIN_ALIAS_RID_POWER_USERS, g_szPowerUsers, ARRAYSIZE(g_szPowerUsers))))
    {
        *g_szPowerUsers = L'\0';
    }

    if (FAILED(LookupLocalGroupName(DOMAIN_ALIAS_RID_USERS, g_szUsers, ARRAYSIZE(g_szUsers))))
    {
        *g_szUsers = L'\0';
    }
}             
             
INT_PTR CGroupPageBase::HandleGroupMessage(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    };

    return FALSE;
}

void CGroupPageBase::InitializeLocalGroupCombo(HWND hwndCombo)
{
    ComboBox_ResetContent(hwndCombo);

    // Add all of the groups in the list to the box
    for(int i = 0; i < m_pGroupList->GetPtrCount(); i ++)
    {
        CGroupInfo* pGroupInfo = m_pGroupList->GetPtr(i);
        int index = ComboBox_AddString(hwndCombo, pGroupInfo->m_szGroup);
        ComboBox_SetItemData(hwndCombo, index, pGroupInfo->m_szComment);
    }

    TCHAR szSelectGroup[MAX_GROUP + 1];

    // Load a local group name from the resources to select by default
    // dsheldon: this will fail for MUI...not critical though
    LoadString(g_hinst, IDS_USR_DEFAULTGROUP, szSelectGroup, ARRAYSIZE(szSelectGroup));

    if (ComboBox_SelectString(hwndCombo, 0, szSelectGroup) == CB_ERR)
        ComboBox_SetCurSel(hwndCombo, 0);
}

void CGroupPageBase::SetGroupDescription(HWND hwndCombo, HWND hwndEdit)
{
    int iItem = ComboBox_GetCurSel(hwndCombo);
    TCHAR* pszDescription = (TCHAR*) ComboBox_GetItemData(hwndCombo, iItem);
    SetWindowText(hwndEdit, pszDescription);
}

BOOL CGroupPageBase::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Fill in the local group combo box
    HWND hwndCombo = GetDlgItem(hwnd, IDC_GROUPS);
    InitializeLocalGroupCombo(hwndCombo);

    HWND hwndEdit = GetDlgItem(hwnd, IDC_GROUPDESC);
    
    if ((NULL != m_pUserInfo) && (m_pUserInfo->m_szGroups[0] != TEXT('\0')))
    {
        // Select the local group corresponding to the first one in the user's groups
        // string
        TCHAR szSelect[MAX_GROUP + 1];

        // Copy the string since we might shorten our copy
        StrCpyN(szSelect, m_pUserInfo->m_szGroups, ARRAYSIZE(szSelect));
        
        TCHAR* pchEndOfFirst = StrChr(szSelect, TEXT(';'));

        if (pchEndOfFirst)
        {
            // More than one group; we'll fix that!
            *pchEndOfFirst = TEXT('\0');
        }

        SelectGroup(hwnd, szSelect);
    }
    else
    {
        // Select the power user group by default 
        SendDlgItemMessage(hwnd, IDC_POWERUSERS, BM_SETCHECK, 
            (WPARAM) BST_CHECKED, 0);

        OnRadioChanged(hwnd, IDC_POWERUSERS);
    }
   
    SetGroupDescription(hwndCombo, hwndEdit);

    // Bold the group names
    BoldGroupNames(hwnd);

    return TRUE;
}

BOOL CGroupPageBase::GetSelectedGroup(HWND hwnd, LPTSTR pszGroupOut, DWORD cchGroup, CUserInfo::GROUPPSEUDONYM* pgsOut)
{
    *pgsOut = CUserInfo::USEGROUPNAME;

    UINT idString = 0;
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_POWERUSERS)))
    {
        StrCpyN(pszGroupOut, g_szPowerUsers, cchGroup);
        *pgsOut = CUserInfo::STANDARD;
    }
    else if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_USERS)))
    {
        StrCpyN(pszGroupOut, g_szUsers, cchGroup);
        *pgsOut = CUserInfo::RESTRICTED;
    }
    else
    {
        // 'other' must be selected; get the string from the dropdown
        GetWindowText(GetDlgItem(hwnd, IDC_GROUPS), pszGroupOut, cchGroup);
    }

    return TRUE;
}

// Returns IDC_OTHER if no radio button id corresponds to the group
UINT CGroupPageBase::RadioIdForGroup(LPCTSTR pszGroup)
{
    UINT uiRadio = IDC_OTHER;                       // Assume IDC_OTHER to start
    if (0 == StrCmpI(pszGroup, g_szPowerUsers))
    {
        uiRadio = IDC_POWERUSERS;
    }
    else if (0 == StrCmpI(pszGroup, g_szUsers))
    {
        uiRadio = IDC_USERS;
    }

    return uiRadio;
}

// Disable/update as appropriate when radio selection changes
void CGroupPageBase::OnRadioChanged(HWND hwnd, UINT idRadio)
{
    BOOL fEnableGroupDropdown = (IDC_OTHER == idRadio);

    EnableWindow(GetDlgItem(hwnd, IDC_GROUPS), fEnableGroupDropdown);
    EnableWindow(GetDlgItem(hwnd, IDC_OTHER_STATIC), fEnableGroupDropdown);

    ShowWindow(GetDlgItem(hwnd, IDC_GROUPDESC), 
        fEnableGroupDropdown ? SW_SHOW : SW_HIDE);
}

void CGroupPageBase::SelectGroup(HWND hwnd, LPCTSTR pszSelect)
{
    // Always select the group in the 'other' dropdown
    ComboBox_SelectString(GetDlgItem(hwnd, IDC_GROUPS),
        -1, pszSelect);
    
    // Check the appropriate radio button
    UINT idRadio = RadioIdForGroup(pszSelect);
    Button_SetCheck(GetDlgItem(hwnd, idRadio), BST_CHECKED);

    OnRadioChanged(hwnd, idRadio);
}


void CGroupPageBase::BoldGroupNames(HWND hwnd)
{
    HWND hwndPowerUsers = GetDlgItem(hwnd, IDC_POWERUSERS);

    HFONT hfont = (HFONT) SendMessage(hwndPowerUsers, WM_GETFONT, 0, 0);

    if (hfont)
    {
        LOGFONT lf;
        if (FALSE != GetObject((HGDIOBJ) hfont, sizeof(lf), &lf))
        {
            lf.lfWeight = FW_BOLD;

            m_hBoldFont = CreateFontIndirect(&lf);

            if (NULL != m_hBoldFont)
            {
                // Set the font
                SendMessage(hwndPowerUsers, WM_SETFONT, 
                    (WPARAM) m_hBoldFont, 0);

                SendDlgItemMessage(hwnd, IDC_USERS,
                    WM_SETFONT, (WPARAM) m_hBoldFont, 0);

                SendDlgItemMessage(hwnd, IDC_OTHER,
                    WM_SETFONT, (WPARAM) m_hBoldFont, 0);
            }
        }
    }
}

BOOL CGroupPageBase::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(codeNotify)
    {
    case CBN_SELCHANGE:
        SetGroupDescription(hwndCtl, GetDlgItem(hwnd, IDC_GROUPDESC));
        PropSheet_Changed(GetParent(hwnd), hwnd);
        break;

    case BN_CLICKED:
        // Handle radio clicks
        switch (id)
        {
        case IDC_POWERUSERS:
        case IDC_USERS:
        case IDC_OTHER:
            PropSheet_Changed(GetParent(hwnd), hwnd);
            OnRadioChanged(hwnd, id);
        }
        break;
    }
    return FALSE;
}

/**************************************************************
 CGroupWizardPage Implementation
**************************************************************/

INT_PTR CGroupWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CGroupWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
        {
            PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_FINISH);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;
        }

        case PSN_WIZFINISH:
        {
            // Read in the local group name
            CUserInfo::GROUPPSEUDONYM gs;
            GetSelectedGroup(hwnd, m_pUserInfo->m_szGroups,
                ARRAYSIZE(m_pUserInfo->m_szGroups), &gs);

            // Don't close wizard by default
            LONG_PTR finishResult = (LONG_PTR) hwnd;

            CWaitCursor cur;
            if (SUCCEEDED(m_pUserInfo->Create(hwnd, gs)))
            {
                m_pUserInfo->m_fHaveExtraUserInfo = FALSE;
                // Close wizard
                finishResult = 0;
            }

            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, finishResult);
            return TRUE;
        }
    }
    return FALSE;
}

/**************************************************************
 CGroupPropertyPage Implementation
**************************************************************/

INT_PTR CGroupPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CGroupPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch(pnmh->code)
    {
        case PSN_APPLY:
            {
                // Check to see if the group needs updating on Apply
                TCHAR szTemp[MAX_GROUP + 1];

                // Read in the local group name
                CUserInfo::GROUPPSEUDONYM gs;
                GetSelectedGroup(hwnd, szTemp,
                    ARRAYSIZE(szTemp), &gs);

                if (StrCmp(szTemp, m_pUserInfo->m_szGroups) != 0)
                {
                    HRESULT hr = m_pUserInfo->UpdateGroup(hwnd, szTemp, gs);

                    if (SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
                        MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername,
                            szDomainUser, ARRAYSIZE(szDomainUser));

                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                            IDS_USR_UPDATE_GROUP_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);

                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    }
                }
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\makefile.inc ===
..\resource.rc : $(SELFREGNAME) ..\resource.h ..\publishing.rc ..\res\providers.xml ..\res\resourcemap.xml

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\misc.h ===
#ifndef MISC_H
#define MISC_H

#ifndef MAX
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#endif

#ifndef MIN
#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#endif


#define GetDlgItemTextLength(hwnd, id)              \
            GetWindowTextLength(GetDlgItem(hwnd, id))

#define WIZARDNEXT(hwnd, to)                        \
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)to)


// wait cursor management

class CWaitCursor 
{
  public:
    CWaitCursor();
    ~CWaitCursor();
    void WaitCursor();
    void RestoreCursor();

  private:
    HCURSOR _hCursor;
};

HRESULT BrowseToPidl(LPCITEMIDLIST pidl);

void FetchText(HWND hWndDlg, UINT uID, LPTSTR lpBuffer, DWORD dwMaxSize);
INT FetchTextLength(HWND hWndDlg, UINT uID);

HRESULT AttemptLookupAccountName(LPCTSTR szUsername, PSID* ppsid,
                                 LPTSTR szDomain, DWORD* pcchDomain, 
                                 SID_NAME_USE* psUse);

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...);
BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...);
BOOL FormatMessageTemplate(LPCTSTR pszTemplate, LPTSTR pszStrOut, DWORD cchSize, ...);

void MakeDomainUserString(LPCTSTR szDomain, LPCTSTR szUsername, LPTSTR szDomainUser, DWORD cchBuffer);
void DomainUserString_GetParts(LPCTSTR szDomainUser, LPTSTR szUser, DWORD cchUser, LPTSTR szDomain, DWORD cchDomain);
BOOL GetCurrentUserAndDomainName(LPTSTR UserName, LPDWORD cchUserName, LPTSTR DomainName, LPDWORD cchDomainName);
HRESULT IsUserLocalAdmin(HANDLE TokenHandle OPTIONAL, BOOL* pfIsAdmin);
BOOL IsComputerInDomain();
LPITEMIDLIST GetComputerParent();

void EnableControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, BOOL fEnable);
void OffsetControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, int dx, int dy);
void OffsetWindow(HWND hwnd, int dx, int dy);
HFONT GetIntroFont(HWND hwnd);
void CleanUpIntroFont();

void RemoveControl(HWND hwnd, UINT idControl, UINT idNextControl, const UINT* prgMoveControls, DWORD cControls, BOOL fShrinkParent);
void MoveControls(HWND hwnd, const UINT* prgControls, DWORD cControls, int dx, int dy);
int SizeControlFromText(HWND hwnd, UINT id, LPTSTR psz);

void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain);
int PropertySheetIcon(LPCPROPSHEETHEADER ppsh, LPCTSTR pszIcon);


// Stuff for the callback for IShellPropSheetExt::AddPages
#define MAX_PROPSHEET_PAGES     10

struct ADDPROPSHEETDATA
{
    HPROPSHEETPAGE rgPages[MAX_PROPSHEET_PAGES];
    int nPages;
};

BOOL AddPropSheetPageCallback(HPROPSHEETPAGE hpsp, LPARAM lParam);


// single instance management

class CEnsureSingleInstance
{
public:
    CEnsureSingleInstance(LPCTSTR szCaption);
    ~CEnsureSingleInstance();

    BOOL ShouldExit() { return m_fShouldExit;}

private:
    BOOL m_fShouldExit;
    HANDLE m_hEvent;
};


// BrowseForUser
//  S_OK = Username/Domain are Ok
//  S_FALSE = User clicked cancel
//  E_xxx = Error

HRESULT BrowseForUser(HWND hwndDlg, TCHAR* pszUser, DWORD cchUser, TCHAR* pszDomain, DWORD cchDomain);
int CALLBACK ShareBrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);


// Passport functions - implemented in PassportMisc.cpp
#define PASSPORTURL_REGISTRATION    L"RegistrationUrl"
#define PASSPORTURL_LOGON           L"LoginServerUrl"
#define PASSPORTURL_PRIVACY         L"Privacy"

HRESULT PassportGetURL(PCWSTR pszName, PWSTR pszBuf, DWORD cchBuf);
VOID    PassportForceNexusRepopulate();

// Launch ICW if it hasn't been run yet
void LaunchICW();

// LookupLocalGroupName - retrieves a local group name for a given RID.
// RID is one of these:
//  DOMAIN_ALIAS_RID_ADMINS
//  DOMAIN_ALIAS_RID_USERS
//  DOMAIN_ALIAS_RID_GUESTS
//  DOMAIN_ALIAS_RID_POWER_USERS
//  etc... (look in the SDK for other groups)
HRESULT LookupLocalGroupName(DWORD dwRID, LPWSTR pszName, DWORD cchName);

#endif //!MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\mnddlg.cpp ===
#include "stdafx.h"
#include "password.h"
#pragma hdrstop


// class defn's used for the map net drive dialog and its helpers

class CMapNetDriveMRU
{
public:
    CMapNetDriveMRU();
    ~CMapNetDriveMRU();

    BOOL IsValid() {return (NULL != m_hMRU);}
    BOOL FillCombo(HWND hwndCombo);
    BOOL AddString(LPCTSTR psz);

private:
    static const DWORD c_nMaxMRUItems;
    static const TCHAR c_szMRUSubkey[];
    
    HANDLE m_hMRU;

    static int CompareProc(LPCTSTR lpsz1, LPCTSTR lpsz2);
};

class CMapNetDrivePage: public CPropertyPage
{
public:
    CMapNetDrivePage(LPCONNECTDLGSTRUCTW pConnectStruct, DWORD* pdwLastError): 
         m_pConnectStruct(pConnectStruct), m_pdwLastError(pdwLastError)
     {*m_pdwLastError = WN_SUCCESS; m_szDomainUser[0] = m_szPassword[0] = TEXT('\0');}

protected:
    // Message handlers
    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
    BOOL OnDestroy(HWND hwnd);

    // Utility fn's
    void EnableReconnect(HWND hwnd);
    BOOL ReadReconnect();
    void WriteReconnect(BOOL fReconnect);
    void FillDriveBox(HWND hwnd);
    BOOL MapDrive(HWND hwnd);
private:
    BOOL m_fRecheckReconnect; // When (none) is selected as the drive letter, we disable reconnect; Should we reenable it when another drive letter is selected?
    LPCONNECTDLGSTRUCTW m_pConnectStruct;
    DWORD* m_pdwLastError;

    // Hold results of the "connect as" dialog
    TCHAR m_szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    TCHAR m_szPassword[MAX_PASSWORD + 1];

    // MRU list
    CMapNetDriveMRU m_MRU;
};

struct MapNetThreadData
{
    HWND hwnd;
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    TCHAR szPassword[MAX_PASSWORD + 1];
    TCHAR szPath[MAX_PATH + 1];
    TCHAR szDrive[3];
    BOOL fReconnect;
    HANDLE hEventCloseNow;
};

class CMapNetProgress: public CDialog
{
public:
    CMapNetProgress(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError):
                    m_pdata(pdata), m_pdwDevNum(pdwDevNum), m_pdwLastError(pdwLastError)
        {}

    ~CMapNetProgress()
        { if (m_hEventCloseNow != NULL) CloseHandle(m_hEventCloseNow); }

protected:
    // Message handlers
    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnMapSuccess(HWND hwnd, DWORD dwDevNum, DWORD dwLastError);

    // Thread
    static DWORD WINAPI MapDriveThread(LPVOID pvoid);
    static BOOL MapDriveHelper(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError);
    static BOOL ConfirmDisconnectDrive(HWND hWndDlg, LPCTSTR lpDrive, LPCTSTR lpShare, DWORD dwType);
    static BOOL ConfirmDisconnectOpenFiles(HWND hWndDlg);

private:
    // data
    MapNetThreadData* m_pdata;    

    DWORD* m_pdwDevNum;
    DWORD* m_pdwLastError;

    HANDLE m_hEventCloseNow;
};

class CConnectAsDlg: public CDialog
{
public:
    CConnectAsDlg(TCHAR* pszDomainUser, DWORD cchDomainUser, TCHAR* pszPassword, DWORD cchPassword):
          m_pszDomainUser(pszDomainUser), m_cchDomainUser(cchDomainUser), m_pszPassword(pszPassword), m_cchPassword(cchPassword)
      {}

    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
    TCHAR* m_pszDomainUser;
    DWORD m_cchDomainUser;

    TCHAR* m_pszPassword;
    DWORD m_cchPassword;
};


// x-position of share name in the combo box
#define SHARE_NAME_PIXELS   30      

// Drive-related Constants
#define DRIVE_NAME_STRING   TEXT(" :")
#define DRIVE_NAME_LENGTH   ((sizeof(DRIVE_NAME_STRING) - 1) / sizeof(TCHAR))

#define FIRST_DRIVE         TEXT('A')
#define LAST_DRIVE          TEXT('Z')
#define SHARE_NAME_INDEX    5   // Index of the share name in the drive string

#define SELECT_DONE         0x00000001  // The highlight has been set

// MPR Registry Constants
#define MPR_HIVE            HKEY_CURRENT_USER
#define MPR_KEY             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections")
#define MPR_VALUE           TEXT("SaveConnections")
#define MPR_YES             TEXT("yes")
#define MPR_NO              TEXT("no")

const DWORD CMapNetDriveMRU::c_nMaxMRUItems = 26; // 26 is the same as the run dialog
const TCHAR CMapNetDriveMRU::c_szMRUSubkey[] = TEXT("software\\microsoft\\windows\\currentversion\\explorer\\Map Network Drive MRU");

CMapNetDriveMRU::CMapNetDriveMRU() : m_hMRU(NULL)
{
    MRUINFO mruinfo;
    mruinfo.cbSize = sizeof (MRUINFO);
    mruinfo.uMax = c_nMaxMRUItems;
    mruinfo.fFlags = 0;
    mruinfo.hKey = HKEY_CURRENT_USER;
    mruinfo.lpszSubKey = c_szMRUSubkey;
    mruinfo.lpfnCompare = CompareProc;
    m_hMRU = CreateMRUList(&mruinfo);
}

BOOL CMapNetDriveMRU::FillCombo(HWND hwndCombo)
{
    if (!m_hMRU)
        return FALSE;

    ComboBox_ResetContent(hwndCombo);

    int nItem = 0;
    TCHAR szMRUItem[MAX_PATH + 1];

    while (TRUE)
    {
        int nResult = EnumMRUList(m_hMRU, nItem, (LPVOID) szMRUItem, ARRAYSIZE(szMRUItem));
        if (-1 != nResult)
        {
            ComboBox_AddString(hwndCombo, szMRUItem);               // Add the string
            nItem ++;
        }
        else
        {
            break;                          // No selection list!
        }
    }
    return TRUE;
}

BOOL CMapNetDriveMRU::AddString(LPCTSTR psz)
{
    if (m_hMRU && (-1 != AddMRUString(m_hMRU, psz)))
        return TRUE;

    return FALSE;
}

CMapNetDriveMRU::~CMapNetDriveMRU()
{
    if (m_hMRU)
        FreeMRUList(m_hMRU);
}

int CMapNetDriveMRU::CompareProc(LPCTSTR lpsz1, LPCTSTR lpsz2)
{
    return StrCmpI(lpsz1, lpsz2);
}


void CMapNetDrivePage::EnableReconnect(HWND hwnd)
{
    BOOL fEnable = !(m_pConnectStruct->dwFlags & CONNDLG_HIDE_BOX);
    EnableWindow(GetDlgItem(hwnd, IDC_RECONNECT), fEnable);
}

BOOL CMapNetDrivePage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Check or uncheck the "reconnect at logon" box (registry)
    Button_SetCheck(GetDlgItem(hwnd, IDC_RECONNECT), ReadReconnect() ? BST_CHECKED : BST_UNCHECKED);

    EnableReconnect(hwnd);

    ComboBox_LimitText(GetDlgItem(hwnd, IDC_FOLDER), MAX_PATH);

    // Set up the drive drop-list
    FillDriveBox(hwnd);

    // Set focus to default control
    return FALSE;
}

BOOL CMapNetDrivePage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_FOLDERBROWSE:
            {
                LPITEMIDLIST pidl;
                // Future consideration: Need a CSIDL for computers near me to root the browse
                if (SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl) == NOERROR)
                {
                    TCHAR szReturnedPath[MAX_PATH];
                    TCHAR szStartPath[MAX_PATH];
                    TCHAR szTitle[256];
                
                    // Get the path the user has typed so far; we'll try to begin
                    // the browse at this point
                    HWND hwndFolderEdit = GetDlgItem(hwnd, IDC_FOLDER);
                    FetchText(hwnd, IDC_FOLDER, szStartPath, ARRAYSIZE(szStartPath));

                    // Get the browse dialog title
                    LoadString(g_hinst, IDS_MND_SHAREBROWSE, szTitle, ARRAYSIZE(szTitle));

                    BROWSEINFO bi;
                    bi.hwndOwner = hwnd;
                    bi.pidlRoot = pidl;
                    bi.pszDisplayName = szReturnedPath;
                    bi.lpszTitle = szTitle;
                    // Show old-style dialog if we're running under WOW. RAID 216120
                    bi.ulFlags = (NULL == NtCurrentTeb()->WOW32Reserved) ? BIF_NEWDIALOGSTYLE : 0;
                    bi.lpfn = ShareBrowseCallback;
                    bi.lParam = (LPARAM) szStartPath;
                    bi.iImage = 0;

                    LPITEMIDLIST pidlReturned = SHBrowseForFolder(&bi);

                    if (pidlReturned != NULL)
                    {
                        if (SUCCEEDED(SHGetTargetFolderPath(pidlReturned, szReturnedPath, ARRAYSIZE(szReturnedPath))))
                        {
                            SetWindowText(hwndFolderEdit, szReturnedPath);

                            BOOL fEnableFinish = (szReturnedPath[0] != 0);
                            PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
                        }
                    
                        ILFree(pidlReturned);
                    }

                    ILFree(pidl);
                }
            }
            return TRUE;

        case IDC_DRIVELETTER:
            if ( CBN_SELCHANGE == codeNotify )
            {
                HWND hwndCombo = GetDlgItem(hwnd, IDC_DRIVELETTER);
                int iItem = ComboBox_GetCurSel(hwndCombo);
                BOOL fNone = (BOOL)ComboBox_GetItemData(hwndCombo, iItem);
                HWND hwndReconnect = GetDlgItem(hwnd, IDC_RECONNECT);

                if (fNone)
                {
                    if (IsWindowEnabled(hwndReconnect))
                    {
                        // going from non-none to (none) - remember if we're checked
                        m_fRecheckReconnect = (BST_CHECKED == SendMessage(hwndReconnect, BM_GETCHECK, 0, 0));
                        // Uncheck the box
                        SendMessage(hwndReconnect, BM_SETCHECK, (WPARAM) BST_UNCHECKED, 0);
                    }
                }
                else
                {
                    if (!IsWindowEnabled(hwndReconnect))
                    {
                        SendMessage(hwndReconnect, BM_SETCHECK, (WPARAM) m_fRecheckReconnect ? BST_CHECKED : BST_UNCHECKED, 0);
                    }
                }

                EnableWindow(GetDlgItem(hwnd, IDC_RECONNECT), !fNone);        
            }
            break;

        case IDC_FOLDER:
            if ((CBN_EDITUPDATE == codeNotify) || (CBN_SELCHANGE == codeNotify))
            {
                // Enable Finish only if something is typed into the folder box
                TCHAR szTemp[MAX_PATH];
                FetchText(hwnd, IDC_FOLDER, szTemp, ARRAYSIZE(szTemp));
                BOOL fEnableFinish = (CBN_SELCHANGE == codeNotify) || (lstrlen(szTemp));
            
                PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
                return TRUE;
            }
            break;

        default:
            break;
    }
    return FALSE;
}

BOOL CMapNetDrivePage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    BOOL fHandled = FALSE;

    switch (pnmh->code)
    {
    case PSN_SETACTIVE:
        {
            m_MRU.FillCombo(GetDlgItem(hwnd, IDC_FOLDER));

            // A path may have been specified. If so, use it
            TCHAR szPath[MAX_PATH + 1];
            if ((m_pConnectStruct->lpConnRes != NULL) && (m_pConnectStruct->lpConnRes->lpRemoteName != NULL))
            {
                // Copy over the string into our private buffer 
                StrCpyN(szPath, m_pConnectStruct->lpConnRes->lpRemoteName, ARRAYSIZE(szPath));
        
                if (m_pConnectStruct->dwFlags & CONNDLG_RO_PATH)
                {
                    // this is read only
                    EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
                    EnableWindow(GetDlgItem(hwnd, IDC_FOLDERBROWSE), FALSE);
                }
            }
            else
            {
                szPath[0] = TEXT('\0');
            }

            // Set the path
            SetWindowText(GetDlgItem(hwnd, IDC_FOLDER), szPath);

            // Enable Finish only if something is typed into the folder box
            BOOL fEnableFinish = lstrlen(szPath);
            PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
        }
        return TRUE;

    case PSN_QUERYINITIALFOCUS:
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) GetDlgItem(hwnd, IDC_FOLDER));
        return TRUE;

    case PSN_WIZFINISH:
        if (MapDrive(hwnd))
        {
            WriteReconnect(BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_RECONNECT)));
            // Allow wizard to exit
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
        }
        else
        {
            // Force wizard to stick around
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) GetDlgItem(hwnd, IDC_FOLDER));
        }
        return TRUE;

    case PSN_QUERYCANCEL:
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE);          // Allow cancel
        *m_pdwLastError = 0xFFFFFFFF;
        return TRUE;

    case NM_CLICK:
    case NM_RETURN:
        switch (idCtrl)
        {
            case IDC_CONNECTASLINK:
                {
                    CConnectAsDlg dlg(m_szDomainUser, ARRAYSIZE(m_szDomainUser), m_szPassword, ARRAYSIZE(m_szPassword));
                    dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_MND_CONNECTAS), hwnd);
                }
                return TRUE;

            case IDC_ADDPLACELINK:
                {
                    // Launch the ANP wizard
                    STARTUPINFO startupinfo = {0};
                    startupinfo.cb = sizeof(startupinfo);

                    TCHAR szCommandLine[] = TEXT("rundll32.exe netplwiz.dll,AddNetPlaceRunDll");

                    PROCESS_INFORMATION process_information;
                    if (CreateProcess(NULL, szCommandLine, NULL, NULL, 0, NULL, NULL, NULL, &startupinfo, &process_information))
                    {
                        CloseHandle(process_information.hProcess);
                        CloseHandle(process_information.hThread);
                        PropSheet_PressButton(GetParent(hwnd), PSBTN_CANCEL);
                    }
                    else
                    {
                        DisplayFormatMessage(hwnd, IDS_MAPDRIVE_CAPTION, IDS_MND_ADDPLACEERR, MB_ICONERROR | MB_OK);
                    }
                }
                return TRUE;

            default:
                break;
        }
        break;
    }

    return FALSE;
}

BOOL CMapNetDrivePage::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
{
    // If there are no listbox items, skip this message.
    if (lpDrawItem->itemID == -1)
        return TRUE;
    
    // Draw the text for the listbox items
    switch (lpDrawItem->itemAction)
    {    
        case ODA_SELECT: 
        case ODA_DRAWENTIRE:
        {              
            TCHAR       tszDriveName[MAX_PATH + DRIVE_NAME_LENGTH + SHARE_NAME_INDEX];
            LPTSTR      lpShare;
            TEXTMETRIC  tm;
            COLORREF    clrForeground;
            COLORREF    clrBackground;
            DWORD       dwExStyle = 0L;
            UINT        fuETOOptions = ETO_CLIPPED;
            ZeroMemory(tszDriveName, sizeof(tszDriveName));

            // Get the text string associated with the given listbox item
            if (ComboBox_GetLBTextLen(lpDrawItem->hwndItem, lpDrawItem->itemID) < ARRAYSIZE(tszDriveName))
            {
                ComboBox_GetLBText(lpDrawItem->hwndItem, lpDrawItem->itemID,  tszDriveName);
            }

            // Check to see if the drive name string has a share name at
            // index SHARE_NAME_INDEX.  If so, set lpShare to this location
            // and NUL-terminate the drive name.

            // Check for special (none) item and don't mess with the string in this case
            BOOL fNone = (BOOL) ComboBox_GetItemData(lpDrawItem->hwndItem, lpDrawItem->itemID);
            if ((*(tszDriveName + DRIVE_NAME_LENGTH) == L'\0') || fNone)
            {
                lpShare = NULL;
            }
            else
            {
                lpShare = tszDriveName + SHARE_NAME_INDEX;
                *(tszDriveName + DRIVE_NAME_LENGTH) = L'\0';
            }

            GetTextMetrics(lpDrawItem->hDC, &tm);
            clrForeground = SetTextColor(lpDrawItem->hDC,
                                         GetSysColor(lpDrawItem->itemState & ODS_SELECTED ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
            clrBackground = SetBkColor(lpDrawItem->hDC, 
                                        GetSysColor(lpDrawItem->itemState & ODS_SELECTED ? COLOR_HIGHLIGHT : COLOR_WINDOW));
            
            // check for RTL...
            dwExStyle = GetWindowLong(lpDrawItem->hwndItem, GWL_EXSTYLE);
            if(dwExStyle & WS_EX_RTLREADING)
               fuETOOptions |= ETO_RTLREADING; 

            // Draw the text into the listbox
            ExtTextOut(lpDrawItem->hDC,
                       LOWORD(GetDialogBaseUnits()) / 2,
                       (lpDrawItem->rcItem.bottom + lpDrawItem->rcItem.top - tm.tmHeight) / 2,
                       fuETOOptions | ETO_OPAQUE,
                       &lpDrawItem->rcItem,
                       tszDriveName, lstrlen(tszDriveName),
                       NULL);

            // If there's a share name, draw it in a second column
            // at (x = SHARE_NAME_PIXELS)
            if (lpShare != NULL)
            {
                ExtTextOut(lpDrawItem->hDC,
                           SHARE_NAME_PIXELS,
                           (lpDrawItem->rcItem.bottom + lpDrawItem->rcItem.top - tm.tmHeight) / 2,
                           fuETOOptions,
                           &lpDrawItem->rcItem,
                           lpShare, lstrlen(lpShare),
                           NULL);

                // Restore the original string
                *(tszDriveName + lstrlen(DRIVE_NAME_STRING)) = TEXT(' ');
            }

            // Restore the original text and background colors
            SetTextColor(lpDrawItem->hDC, clrForeground); 
            SetBkColor(lpDrawItem->hDC, clrBackground);

            // If the item is selected, draw the focus rectangle
            if (lpDrawItem->itemState & ODS_SELECTED)
            {
                DrawFocusRect(lpDrawItem->hDC, &lpDrawItem->rcItem); 
            }                     
            break;
        }
    }             
    return TRUE;
}

INT_PTR CMapNetDrivePage::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_DRAWITEM, OnDrawItem);
    }

    return FALSE;
}



// "Reconnect check" registry setting
BOOL CMapNetDrivePage::ReadReconnect()
{
    BOOL fReconnect = TRUE;

    if (m_pConnectStruct->dwFlags & CONNDLG_PERSIST)
    {
        fReconnect = TRUE;
    }
    else if (m_pConnectStruct->dwFlags & CONNDLG_NOT_PERSIST)
    {
        fReconnect = FALSE;
    }
    else
    {
        // User didn't specify -- check the registry.
        HKEY hkeyMPR;
        if (ERROR_SUCCESS == RegOpenKeyEx(MPR_HIVE, MPR_KEY, 0, KEY_READ, &hkeyMPR))
        {
            DWORD dwType;
            TCHAR szAnswer[ARRAYSIZE(MPR_YES) + ARRAYSIZE(MPR_NO)];
            DWORD cbSize = sizeof(szAnswer);

            if (ERROR_SUCCESS == RegQueryValueEx(hkeyMPR, MPR_VALUE, NULL,
                &dwType, (BYTE*) szAnswer, &cbSize))
            {
                fReconnect = (StrCmpI(szAnswer, (const TCHAR *) MPR_YES) == 0);
            }

            RegCloseKey(hkeyMPR);
        }            
    }
    return fReconnect;
}

void CMapNetDrivePage::WriteReconnect(BOOL fReconnect)
{
    // Don't write to the registry if the user didn't have a choice about reconnect
    if (!(m_pConnectStruct->dwFlags & CONNDLG_HIDE_BOX))
    {
        HKEY hkeyMPR;
        DWORD dwDisp;

        // User didn't specify -- check the registry.
        if (ERROR_SUCCESS == RegCreateKeyEx(MPR_HIVE, MPR_KEY, 0, NULL, 0, KEY_WRITE, NULL,
            &hkeyMPR, &dwDisp))
        {
            LPTSTR pszNewValue = (fReconnect ? MPR_YES : MPR_NO);

            RegSetValueEx(hkeyMPR, MPR_VALUE, NULL,
                REG_SZ, (BYTE*) pszNewValue, (lstrlen(pszNewValue) + 1) * sizeof (TCHAR));

            RegCloseKey(hkeyMPR);
        }            
    }
}


// This routine fills the drive letter drop-down list with all
// of the drive names and, if appropriate, the name of the share to which
// the drive is already connected

void CMapNetDrivePage::FillDriveBox(HWND hwnd)
{
    HWND    hWndCombo      = GetDlgItem(hwnd, IDC_DRIVELETTER);
    DWORD   dwFlags        = 0;
    DWORD   dwBufferLength = MAX_PATH - 1;
    TCHAR   szDriveName[SHARE_NAME_INDEX + MAX_PATH];
    TCHAR   szShareName[MAX_PATH - DRIVE_NAME_LENGTH];

    ZeroMemory(szDriveName, sizeof(szDriveName));
    ZeroMemory(szShareName, sizeof(szShareName));

    // lpDriveName looks like this: "<space>:<null>"
    StrCpyN(szDriveName, DRIVE_NAME_STRING, ARRAYSIZE(szDriveName));

    // lpDriveName looks like this: 
    // "<space>:<null><spaces until index SHARE_NAME_INDEX>"
    for (UINT i = DRIVE_NAME_LENGTH + 1; i < SHARE_NAME_INDEX; i++)
    {
        szDriveName[i] = L' ';
    }

    for (TCHAR cDriveLetter = LAST_DRIVE; cDriveLetter >= FIRST_DRIVE; cDriveLetter--)
    {        
        // lpDriveName looks like this: "<drive>:<null><lots of spaces>"
        szDriveName[0] = cDriveLetter;
        UINT uDriveType = GetDriveType(szDriveName);

        // NoRootDir == usually available, but may be mounted to a network drive that currently isn't
        // available - check for this!
        if (DRIVE_NO_ROOT_DIR == uDriveType)
        {
            if (ERROR_CONNECTION_UNAVAIL == WNetGetConnection(szDriveName, szShareName, &dwBufferLength))
            {
                // Pretend its a remote drive
                uDriveType = DRIVE_REMOTE;
                dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
            }
        }

        // Removable == floppy drives, Fixed == hard disk, CDROM == obvious :),
        // Remote == network drive already attached to a share
        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
            case DRIVE_FIXED:
            case DRIVE_CDROM:
                // These types of drives can't be mapped
                break;

            case DRIVE_REMOTE:
            {
                UINT    i;

                // Reset the share buffer length (it 
                // gets overwritten by WNetGetConnection)
                dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
                
                // Retrieve "\\server\share" for current drive
                DWORD dwRes = WNetGetConnection(szDriveName, szShareName, &dwBufferLength);
                if ((dwRes == NO_ERROR) || (dwRes == ERROR_CONNECTION_UNAVAIL))
                {
                    // lpDriveName looks like this: 
                    // "<drive>:<spaces until SHARE_NAME_INDEX><share name><null>"
                
                    szDriveName[DRIVE_NAME_LENGTH] = L' ';
                    StrCpyN(szDriveName + SHARE_NAME_INDEX, szShareName, ARRAYSIZE(szDriveName) - SHARE_NAME_INDEX);


                    // Store a FALSE into the item data for all items except the
                    // special (none) item
                    int iItem = ComboBox_AddString(hWndCombo, szDriveName);
                    ComboBox_SetItemData(hWndCombo, iItem, (LPARAM) FALSE);

                    // Reset the drive name to "<drive>:<null><lots of spaces>"
                    szDriveName[DRIVE_NAME_LENGTH] = L'\0';

                    for (i = DRIVE_NAME_LENGTH + 1; i < MAX_PATH + SHARE_NAME_INDEX; i++)
                    {
                        *(szDriveName + i) = L' ';
                    }
                    break;
                }
                else
                {                    
                    // If there's an error with this drive, ignore the drive
                    // and skip to the next one.  Note that dwBufferLength will
                    // only be changed if lpShareName contains MAX_PATH or more
                    // characters, which shouldn't ever happen.  For release,
                    // however, keep on limping along.

                    dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
                    break;
                }
            }

            default:                                                
            {
                // The drive is not already connected to a share

                // Suggest the first available and unconnected 
                // drive past the C drive
                DWORD dwIndex = ComboBox_AddString(hWndCombo, szDriveName);
                if (!(dwFlags & SELECT_DONE))
                {                
                    ComboBox_SetCurSel(hWndCombo, dwIndex);
                    dwFlags |= SELECT_DONE;
                }
                break;
            }
        }
    }
    // Add one more item - a special (none) item that if selected causes 
    // a deviceless connection to be created.

    LoadString(g_hinst, IDS_NONE, szDriveName, ARRAYSIZE(szDriveName));
    int iItem = ComboBox_AddString(hWndCombo, szDriveName);
    ComboBox_SetItemData(hWndCombo, iItem, (LPARAM) TRUE);


    // If there is no selection at this point, just select (none) item
    // This will happen when all drive letters are mapped

    if (ComboBox_GetCurSel(hWndCombo) == CB_ERR)
    {
        ComboBox_SetCurSel(hWndCombo, iItem);
    }
}

BOOL CMapNetDrivePage::MapDrive(HWND hwnd)
{
    BOOL fMapWorked = FALSE;
    
    HWND hwndCombo = GetDlgItem(hwnd, IDC_DRIVELETTER);
    int iItem = ComboBox_GetCurSel(hwndCombo);

    // Get this item's text and itemdata (to check if its the special (none) drive)
    BOOL fNone = (BOOL) ComboBox_GetItemData(hwndCombo, iItem);
        
    // Fill in the big structure that maps a drive
    MapNetThreadData* pdata = new MapNetThreadData;

    if (pdata != NULL)
    {
        // Set reconnect
        pdata->fReconnect = (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_RECONNECT)));

        // Set the drive
        if (fNone)
        {
            pdata->szDrive[0] = TEXT('\0');
        }
        else
        {
            ComboBox_GetText(hwndCombo, pdata->szDrive, ARRAYSIZE(pdata->szDrive));
        }

        // Set the net share
        FetchText(hwnd, IDC_FOLDER, pdata->szPath, ARRAYSIZE(pdata->szPath));
        PathRemoveBackslash(pdata->szPath);

        // Get an alternate username/password/domain if required
        // Domain/username
        StrCpyN(pdata->szDomainUser, m_szDomainUser, ARRAYSIZE(pdata->szDomainUser));

        // Password
        StrCpyN(pdata->szPassword, m_szPassword, ARRAYSIZE(pdata->szPassword));

        CMapNetProgress dlg(pdata, &m_pConnectStruct->dwDevNum, m_pdwLastError);
        
        // On IDOK == Close dialog!
        fMapWorked = (IDOK == dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_MND_PROGRESS_DLG), hwnd));
    }

    if (fMapWorked)
    {
        TCHAR szPath[MAX_PATH + 1];
        FetchText(hwnd, IDC_FOLDER, szPath, ARRAYSIZE(szPath));
        m_MRU.AddString(szPath);

        // If a drive letter wasn't assigned, open a window on the new drive now
        if (fNone)
        {
            // Use shellexecuteex to open a view folder
            SHELLEXECUTEINFO shexinfo = {0};
            shexinfo.cbSize = sizeof (shexinfo);
            shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = szPath;
            shexinfo.lpVerb = TEXT("open");

            ShellExecuteEx(&shexinfo);
        }
    }
    
    return fMapWorked;
}


// Little progress dialog implementation

// Private message for thread to signal dialog if successful
//  (DWORD) (WPARAM) dwDevNum - 0-based device number connected to (0xFFFFFFFF for none)
//  (DWORD) (LPARAM) dwRetVal - Return value
#define WM_MAPFINISH (WM_USER + 100)

INT_PTR CMapNetProgress::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        case WM_MAPFINISH: return OnMapSuccess(hwnd, (DWORD) wParam, (DWORD) lParam);
    }

    return FALSE;
}

BOOL CMapNetProgress::OnMapSuccess(HWND hwnd, DWORD dwDevNum, DWORD dwLastError)
{
    *m_pdwDevNum = dwDevNum;
    *m_pdwLastError = dwLastError;
    EndDialog(hwnd, ((dwLastError == WN_SUCCESS) ? IDOK : IDCANCEL));
    return TRUE;
}

BOOL CMapNetProgress::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HANDLE hThread = NULL;

    // Set the progress dialog text
    TCHAR szText[256]; *szText = 0;
    FormatMessageString(IDS_MND_PROGRESS, szText, ARRAYSIZE(szText), m_pdata->szPath);

    SetWindowText(GetDlgItem(hwnd, IDC_CONNECTING), szText);


    // We'll signal this guy when the thread should close down
    static const TCHAR EVENT_NAME[] = TEXT("Thread Close Event");
    m_hEventCloseNow = CreateEvent(NULL, TRUE, FALSE, EVENT_NAME);
    m_pdata->hEventCloseNow = NULL;

    if (m_hEventCloseNow != NULL)
    {
        // Get a copy of this puppy for the thread
        m_pdata->hEventCloseNow = OpenEvent(SYNCHRONIZE, FALSE, EVENT_NAME);

        if (m_pdata->hEventCloseNow != NULL)
        {
            m_pdata->hwnd = hwnd;

            // All we have to do is start up the worker thread, who will dutifully report back to us
            DWORD dwId;
            hThread = CreateThread(NULL, 0, CMapNetProgress::MapDriveThread, (LPVOID) m_pdata, 0, &dwId);
        }
    }

    // Abandon the poor little guy (he'll be ok)
    if (hThread != NULL)
    {
        CloseHandle(hThread);

        /* TAKE SPECIAL CARE
        At this point the thread owns m_pdata! Don't access it any more except on the thread.
        It may be deleted at any time! */

        m_pdata = NULL;
    }
    else
    {
        // Usually the thread would do this
        if (m_pdata->hEventCloseNow != NULL)
        {
            CloseHandle(m_pdata->hEventCloseNow);
        }
    
        delete m_pdata;

        // We just failed to create a thread. The computer must be near out of
        // resources.
        EndDialog(hwnd, IDCANCEL);
    }

    return FALSE;
}

BOOL CMapNetProgress::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (id == IDCANCEL)
    {
        SetEvent(m_hEventCloseNow); // Tell the thread to quit
        EndDialog(hwnd, id);
    }
    return FALSE;
}

DWORD CMapNetProgress::MapDriveThread(LPVOID pvoid)
{
    MapNetThreadData* pdata = (MapNetThreadData*) pvoid;

    DWORD dwDevNum;
    DWORD dwLastError;
    BOOL fSuccess = MapDriveHelper(pdata, &dwDevNum, &dwLastError);

    if (WAIT_OBJECT_0 == WaitForSingleObject(pdata->hEventCloseNow, 0))
    {
        // The user clicked cancel, don't call back to the progress wnd
    }
    else
    {
        PostMessage(pdata->hwnd, WM_MAPFINISH, (WPARAM) dwDevNum, 
            (LPARAM) dwLastError);
    }
    
    CloseHandle(pdata->hEventCloseNow);

    delete pdata;
    return 0;
}

BOOL CMapNetProgress::MapDriveHelper(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError)
{
    NETRESOURCE     nrResource = {0};
    LPTSTR          lpMessage = NULL;

    *pdwDevNum = 0;
   
    //
    // Fill in the NETRESOURCE structure -- the local name is the drive and
    // the remote name is \\server\share (stored in the global buffer).
    // The provider is NULL to let NT find the provider on its own.
    //
    nrResource.dwType         = RESOURCETYPE_DISK;
    nrResource.lpLocalName    = pdata->szDrive[0] == TEXT('\0') ? NULL : pdata->szDrive;
    nrResource.lpRemoteName   = pdata->szPath;
    nrResource.lpProvider     = NULL;

    BOOL fRetry = TRUE;
    while (fRetry)
    {        
        fRetry = FALSE;

        *pdwLastError = WNetAddConnection3(pdata->hwnd, &nrResource,
            pdata->szDomainUser[0] == TEXT('\0') ? NULL : pdata->szPassword, 
            pdata->szDomainUser[0] == TEXT('\0') ? NULL : pdata->szDomainUser, 
            pdata->fReconnect ? CONNECT_INTERACTIVE | CONNECT_UPDATE_PROFILE : CONNECT_INTERACTIVE);

        // Don't display anything if we're supposed to quit
        if (WAIT_OBJECT_0 == WaitForSingleObject(pdata->hEventCloseNow, 0))
        {   
            // We should quit (quietly exit if we just failed)!
            if (*pdwLastError != NO_ERROR)
            {
                *pdwLastError = ERROR_CANCELLED;
            }
        }

        switch (*pdwLastError)
        {
            case NO_ERROR:
                {
                    // Put the number of the connection into dwDevNum, where 
                    // drive A is 1, B is 2, ... Note that a deviceless connection
                    // is 0xFFFFFFFF
                    if (pdata->szDrive[0] == TEXT('\0'))
                    {
                        *pdwDevNum = 0xFFFFFFFF;
                    }
                    else
                    {
                        *pdwDevNum = *pdata->szDrive - FIRST_DRIVE + 1;
                    }
            
                    *pdwLastError = WN_SUCCESS;
                }
                break;

            //
            // The user cancelled the password dialog or cancelled the
            // connection through a different dialog
            //
            case ERROR_CANCELLED:
                {
                    *pdwLastError = RETCODE_CANCEL;
                }
                break;

            //
            // An error involving the user's password/credentials occurred, so
            // bring up the password prompt. - Only works for WINNT
            //
            case ERROR_ACCESS_DENIED:
            case ERROR_CANNOT_OPEN_PROFILE:
            case ERROR_INVALID_PASSWORD:
            case ERROR_LOGON_FAILURE:
            case ERROR_BAD_USERNAME:
                {
                    CPasswordDialog dlg(pdata->szPath, pdata->szDomainUser, ARRAYSIZE(pdata->szDomainUser), 
                        pdata->szPassword, ARRAYSIZE(pdata->szPassword), *pdwLastError);

                    if (IDOK == dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_WIZ_NETPASSWORD),
                        pdata->hwnd))
                    {
                        fRetry = TRUE;
                    }
                }
                break;

            // There's an existing/remembered connection to this drive
            case ERROR_ALREADY_ASSIGNED:
            case ERROR_DEVICE_ALREADY_REMEMBERED:

                // See if the user wants us to break the connection
                if (ConfirmDisconnectDrive(pdata->hwnd, 
                                            pdata->szDrive,
                                            pdata->szPath,
                                            *pdwLastError))
                {
                    // Break the connection, but don't force it 
                    // if there are open files
                    *pdwLastError = WNetCancelConnection2(pdata->szDrive,
                                                    CONNECT_UPDATE_PROFILE,
                                                    FALSE);
    
                    if (*pdwLastError == ERROR_OPEN_FILES || 
                        *pdwLastError == ERROR_DEVICE_IN_USE)
                    {                    
                        // See if the user wants to force the disconnection
                        if (ConfirmDisconnectOpenFiles(pdata->hwnd))
                        {
                            // Roger 1-9er -- we have confirmation, 
                            // so force the disconnection.
                            *pdwLastError = WNetCancelConnection2(pdata->szDrive,
                                                    CONNECT_UPDATE_PROFILE,
                                                    TRUE);

                            if (*pdwLastError == NO_ERROR)
                            {
                                fRetry = TRUE;
                            }
                            else
                            {
                                DisplayFormatMessage(pdata->hwnd, IDS_MAPDRIVE_CAPTION, IDS_CANTCLOSEFILES_WARNING,
                                    MB_OK | MB_ICONERROR);
                            }
                        }
                    }
                    else
                    {
                        fRetry = TRUE;
                    }
                }
                break;

            // Errors caused by an invalid remote path
            case ERROR_BAD_DEV_TYPE:
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_NETPATH:
                {

                    DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_INVALIDREMOTEPATH,
                        MB_OK | MB_ICONERROR, pdata->szPath);
                }
                break;

            // Provider is busy (e.g., initializing), so user should retry
            case ERROR_BUSY:
                {
                    DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_INVALIDREMOTEPATH,
                        MB_OK | MB_ICONERROR);
                }
                break;
            //
            // Network problems
            //
            case ERROR_NO_NET_OR_BAD_PATH:
            case ERROR_NO_NETWORK:
                {
                    DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_NONETWORK,
                        MB_OK | MB_ICONERROR);
                }
                break;

            // Share already mapped with different credentials
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION,
                        IDS_MND_ALREADYMAPPED, MB_OK | MB_ICONERROR);
                }

            //
            // Errors that we (in theory) shouldn't get -- bad local name 
            // (i.e., format of drive name is invalid), user profile in a bad 
            // format, or a bad provider.  Problems here most likely indicate 
            // an NT system bug.  Also note that provider-specific errors 
            // (ERROR_EXTENDED_ERROR) and trust failures are lumped in here 
            // as well, since the below errors will display an "Unexpected 
            // Error" message to the user.
            //
            case ERROR_BAD_DEVICE:
            case ERROR_BAD_PROFILE:
            case ERROR_BAD_PROVIDER:
            default:
                {
                    TCHAR szMessage[512];

                    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) *pdwLastError, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                        LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                    ::DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_MND_GENERICERROR, MB_OK|MB_ICONERROR, szMessage);
                }
                break;
            
        }
    }

    return (*pdwLastError == NO_ERROR);
}


/*++

Routine Description:

    This routine verifies that the user wants to break a pre-existing
    connection to a drive.

Arguments:

    hWndDlg -- HWND of the Completion page
    lpDrive -- The name of the drive to disconnect
    lpShare -- The share to which the "freed" drive will be connected
    dwType  -- The connection error -- ERROR_ALREADY_ASSIGNED 
               or ERROR_DEVICE_ALREADY_REMEMBERED
    
Return Value:

    TRUE if the user wants to break the connection, FALSE otherwise

--*/

BOOL CMapNetProgress::ConfirmDisconnectDrive(HWND hWndDlg, LPCTSTR lpDrive, LPCTSTR lpShare, DWORD dwType)
{
    TCHAR   tszConfirmMessage[2 * MAX_PATH + MAX_STATIC] = {0};
    TCHAR   tszCaption[MAX_CAPTION + 1] = {0};
    TCHAR   tszConnection[MAX_PATH + 1] = {0};

    DWORD   dwLength = MAX_PATH;

    LoadString(g_hinst, IDS_ERR_CAPTION, tszCaption, ARRAYSIZE(tszCaption));

    //
    // Bug #143955 -- call WNetGetConnection here since with two instances of
    // the wizard open and on the Completion page with the same suggested
    // drive, the Completion combo box doesn't contain info about the connected
    // share once "Finish" is selected on one of the two wizards.
    //
    DWORD dwRes = WNetGetConnection(lpDrive, tszConnection, &dwLength);
    if ((NO_ERROR == dwRes) || (ERROR_CONNECTION_UNAVAIL == dwRes))
    {
        //
        // Load the appropriate propmt string, based on the type of 
        // error we encountered
        //
        FormatMessageString((dwType == ERROR_ALREADY_ASSIGNED ? IDS_ERR_ALREADYASSIGNED : IDS_ERR_ALREADYREMEMBERED), 
                                        tszConfirmMessage, ARRAYSIZE(tszConfirmMessage), lpDrive, tszConnection, lpShare);

        return (MessageBox(hWndDlg, tszConfirmMessage, tszCaption, MB_YESNO | MB_ICONWARNING)
            == IDYES);
    }
    else
    {
        // The connection was invalid. Don't overwrite it just in case
        return FALSE;
    }
}


/*++

Routine Description:

    This routine verifies that the user wants to break a pre-existing
    connection to a drive where the user has open files/connections

Arguments:

    hWndDlg -- HWND of the Completion dialog

Return Value:

    TRUE if the user wants to break the connection, FALSE otherwise    

--*/

BOOL CMapNetProgress::ConfirmDisconnectOpenFiles(HWND hWndDlg)
{
    TCHAR tszCaption[MAX_CAPTION + 1] = {0};
    TCHAR tszBuffer[MAX_STATIC + 1] = {0};

    LoadString(g_hinst, IDS_ERR_OPENFILES, tszBuffer, ARRAYSIZE(tszBuffer));
    LoadString(g_hinst, IDS_ERR_CAPTION, tszCaption, ARRAYSIZE(tszCaption));

    return (MessageBox(hWndDlg, tszBuffer, tszCaption, MB_YESNO | MB_ICONWARNING) == IDYES);
}

// CConnectAsDlg Implementation - Windows NT only
// ----------------------------------------------

// Little "username and password" dialog for connecting as a different user - NT only
INT_PTR CConnectAsDlg::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CConnectAsDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Fill in the user name and password
    HWND hwndCredential = GetDlgItem(hwnd, IDC_CREDENTIALS);
    SendMessage(hwndCredential, CRM_SETUSERNAME, NULL, (LPARAM) m_pszDomainUser);
    SendMessage(hwndCredential, CRM_SETPASSWORD, NULL, (LPARAM) m_pszPassword);
    SendMessage(hwndCredential, CRM_SETUSERNAMEMAX, m_cchDomainUser - 1, NULL);
    SendMessage(hwndCredential, CRM_SETPASSWORDMAX, m_cchPassword - 1, NULL);

    TCHAR szUser[MAX_USER + 1];
    TCHAR szDomain[MAX_DOMAIN + 1];
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];

    DWORD cchUser = ARRAYSIZE(szUser);
    DWORD cchDomain = ARRAYSIZE(szDomain);
    ::GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain);
    ::MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));

    TCHAR szMessage[256];
    FormatMessageString(IDS_CONNECTASUSER, szMessage, ARRAYSIZE(szMessage), szDomainUser);

    SetWindowText(GetDlgItem(hwnd, IDC_MESSAGE), szMessage);

    if (!IsComputerInDomain())
        EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), FALSE);

    return FALSE;
}

BOOL CConnectAsDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_BROWSE:
            {
                // User wants to look up a username
                TCHAR szUser[MAX_USER + 1];
                TCHAR szDomain[MAX_DOMAIN + 1];
                if (S_OK == ::BrowseForUser(hwnd, szUser, ARRAYSIZE(szUser), 
                    szDomain, ARRAYSIZE(szDomain)))
                {
                    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
                    ::MakeDomainUserString(szDomain, szUser, szDomainUser,
                        ARRAYSIZE(szDomainUser));

                    // Ok clicked and buffers valid
                    SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_SETUSERNAME, NULL, (LPARAM) szDomainUser);
                }
            }
            return TRUE;

        case IDOK:
            // TODO: Figure out about the -1 thing here...
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETUSERNAME, (WPARAM) m_cchDomainUser - 1, (LPARAM) m_pszDomainUser);
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETPASSWORD, (WPARAM) m_cchPassword - 1, (LPARAM) m_pszPassword);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, id);
            return TRUE;
    }
    return FALSE;
}

// ----------------------------------------------

// This function creates the Shared Folder Wizard.
// Return Value:
//  Returns WN_SUCCESS if the drive connected with no problem or 
//  RETCODE_CANCEL (0xFFFFFFFF) if the user cancels the Wizard or there 
//  is an unexplained/unrecoverable error

STDAPI_(DWORD) NetPlacesWizardDoModal(CONNECTDLGSTRUCTW *pConnDlgStruct, NETPLACESWIZARDTYPE npwt, BOOL fIsROPath)
{
    DWORD dwReturn = RETCODE_CANCEL;
    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        INITCOMMONCONTROLSEX iccex = {0};
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES;
        InitCommonControlsEx(&iccex);

        CredUIInitControls();
        LinkWindow_RegisterClass();

        // See if we're already running
        TCHAR szCaption[256];
        LoadString(g_hinst, IDS_MAPDRIVE_CAPTION, szCaption, ARRAYSIZE(szCaption));
        CEnsureSingleInstance ESI(szCaption);

        if (!ESI.ShouldExit())
        {
            CMapNetDrivePage page(pConnDlgStruct, &dwReturn);

            PROPSHEETPAGE psp = {0};
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_MND_PAGE);
            page.SetPropSheetPageMembers(&psp);
            HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);

            PROPSHEETHEADER  psh = {0};
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE | PSH_NOAPPLYNOW;
            psh.pszCaption = szCaption;
            psh.hwndParent = pConnDlgStruct->hwndOwner;
            psh.nPages = 1;
            psh.nStartPage = 0;
            psh.phpage = &hpage;
            PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_PSW));
        }
        SHCoUninitialize(hrInit);
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\netpage.cpp ===
#include "stdafx.h"
#include "netpage.h"
#pragma hdrstop


CNetworkUserWizardPage::CNetworkUserWizardPage(CUserInfo* pUserInfo) :
    m_pUserInfo(pUserInfo)
{
}

INT_PTR CNetworkUserWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }

    return FALSE;
}

BOOL CNetworkUserWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_USER);
    Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
    return TRUE;
}

BOOL CNetworkUserWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
        {
            if (m_pUserInfo->m_psid != NULL)
            {
                LocalFree(m_pUserInfo->m_psid);
                m_pUserInfo->m_psid = NULL;
            }
            SetWizardButtons(hwnd, GetParent(hwnd));
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
        }
        return TRUE;

        case PSN_WIZNEXT:
        {
            // Read in the network user name and domain name
            if (FAILED(GetUserAndDomain(hwnd)))
            {
                // We don't have both!
                DisplayFormatMessage(hwnd, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_NETUSERNAME_ERROR,
                    MB_OK | MB_ICONERROR);

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else
            {
                if (::UserAlreadyHasPermission(m_pUserInfo, hwnd))
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
                }
                else
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}

BOOL CNetworkUserWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_BROWSE_BUTTON:
        {
            // Launch object picker to find a network account to give permissions to
            TCHAR szUser[MAX_USER + 1];
            TCHAR szDomain[MAX_DOMAIN + 1];
        
            if (S_OK == ::BrowseForUser(hwnd, szUser, ARRAYSIZE(szUser), szDomain, ARRAYSIZE(szDomain)))
            {
                SetDlgItemText(hwnd, IDC_USER, szUser);
                SetDlgItemText(hwnd, IDC_DOMAIN, szDomain);
            }
            return TRUE;
        }

        case IDC_USER:
        {
            if (codeNotify == EN_CHANGE)
            {
                SetWizardButtons(hwnd, GetParent(hwnd));
            }
            break;
        }
    }

    return FALSE;
}

void CNetworkUserWizardPage::SetWizardButtons(HWND hwnd, HWND hwndPropSheet)
{
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    DWORD dwUNLength = GetWindowTextLength(hwndUsername);
    PropSheet_SetWizButtons(hwndPropSheet, (dwUNLength == 0) ? 0 : PSWIZB_NEXT);
}

HRESULT CNetworkUserWizardPage::GetUserAndDomain(HWND hwnd)
{
    CWaitCursor cur;
    HRESULT hr = S_OK;

    // This code checks to ensure the user isn't trying
    // to add a well-known group like Everyone! This is bad
    // If the SID isn't read here, it is read in in CUserInfo::ChangeLocalGroup


    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];

    FetchText(hwnd, IDC_USER, m_pUserInfo->m_szUsername, ARRAYSIZE(m_pUserInfo->m_szUsername));
    FetchText(hwnd, IDC_DOMAIN, m_pUserInfo->m_szDomain, ARRAYSIZE(m_pUserInfo->m_szDomain));

    // If the username doesn't already contain a domain and the domain specified in blank
    if ((NULL == StrChr(m_pUserInfo->m_szUsername, TEXT('\\'))) && (0 == m_pUserInfo->m_szDomain[0]))
    {
        // Assume local machine for the domain
        DWORD cchName = ARRAYSIZE(m_pUserInfo->m_szDomain);
        
        if (!GetComputerName(m_pUserInfo->m_szDomain, &cchName))
        {
            *(m_pUserInfo->m_szDomain) = 0;
        }
    }

    ::MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

#ifdef _0
    // Try to find the SID for this user
    DWORD cchDomain = ARRAYSIZE(m_pUserInfo->m_szDomain);
    hr = AttemptLookupAccountName(szDomainUser, &m_pUserInfo->m_psid, m_pUserInfo->m_szDomain, &cchDomain, &m_pUserInfo->m_sUse);
    if (SUCCEEDED(hr))
    {
        // Make sure this isn't a well-known group like 'Everyone'
        if (m_pUserInfo->m_sUse == SidTypeWellKnownGroup)
        {
            hr = E_FAIL;
        }
    }
    else
    {
        // Failed to get the user's SID, just use the names provided
        // We'll get their SID once we add them
        m_pUserInfo->m_psid = NULL;
        hr = S_OK;
    }

#endif 

    // We'll get their SID once we add them
    m_pUserInfo->m_psid = NULL;

    if (FAILED(hr))
    {
        LocalFree(m_pUserInfo->m_psid);
        m_pUserInfo->m_psid = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\join.cpp ===
#include "stdafx.h"
#pragma hdrstop

//
// registry information
//

const WCHAR c_szWinLogon[]          = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon";

const WCHAR c_szAutoLogon[]         = L"AutoAdminLogon";
const WCHAR c_szDisableCAD[]        = L"DisableCAD";

const WCHAR c_szDefUserName[]       = L"DefaultUserName";
const WCHAR c_szDefDomain[]         = L"DefaultDomainName";
const WCHAR c_szDefPassword[]       = L"DefaultPassword";

const WCHAR c_szDefaultPwdKey[]     = L"DefaultPassword";

//
// registry helpers
//

BOOL _RegSetSZ(HKEY hk, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    DWORD dwSize = lstrlen(pszValue)*SIZEOF(WCHAR);
    return ERROR_SUCCESS == RegSetValueEx(hk, pszValueName, 0x0, REG_SZ, (BYTE *)pszValue, dwSize);
}

BOOL _RegSetDWORD(HKEY hk, LPCWSTR pszValueName, DWORD dwValue)
{
    DWORD dwSize = SIZEOF(dwValue);
    return ERROR_SUCCESS == RegSetValueEx(hk, pszValueName, 0x0, REG_DWORD, (BYTE *)&dwValue, dwSize);
}

BOOL _RegDelValue(HKEY hk, LPCWSTR pszValueName)
{
    return ERROR_SUCCESS == RegDeleteValue(hk, pszValueName);
}


INT_PTR CALLBACK _CredDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    LPCREDINFO pci = (LPCREDINFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch ( uMsg ) 
    {
        case WM_INITDIALOG:
        {
            pci = (LPCREDINFO)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            SetDlgItemText(hwnd, IDC_USER, pci->pszUser);
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), pci->cchUser - 1);

            SetDlgItemText(hwnd, IDC_DOMAIN, pci->pszDomain);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), pci->cchDomain - 1);

            SetDlgItemText(hwnd, IDC_PASSWORD, pci->pszPassword);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), pci->cchPassword - 1);

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch ( LOWORD(wParam) )
            {
                case IDOK:
                    {
                        FetchText(hwnd, IDC_DOMAIN, pci->pszDomain, pci->cchDomain);
                        FetchText(hwnd, IDC_USER, pci->pszUser, pci->cchUser);

                        if (StrChr(pci->pszUser, TEXT('@')))
                        {
                            *(pci->pszDomain) = 0;
                        }

                        GetDlgItemText(hwnd, IDC_PASSWORD, pci->pszPassword, pci->cchPassword);
                        return EndDialog(hwnd, IDOK);
                    }

                case IDCANCEL:
                    return EndDialog(hwnd, IDCANCEL);

                case IDC_USER:
                {
                    if ( HIWORD(wParam) == EN_CHANGE )
                    {
                        EnableWindow(GetDlgItem(hwnd, IDOK), FetchTextLength(hwnd, IDC_USER) > 0);

                        EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
                    }
                    break;
                }
            }
            return TRUE;
        }
    }

    return FALSE;
}


//
// attempt to join a domain/workgroup using the specified names and OU.
//

HRESULT _AttemptJoin(HWND hwnd, DWORD dwFlags, LPCWSTR pszDomain, LPCWSTR pszUser, LPCWSTR pszUserDomain, LPCWSTR pszPassword)
{
    HRESULT hr = S_OK;

#ifndef DONT_JOIN
    TCHAR szDomainUser[MAX_DOMAINUSER + 1];
    if ( pszUser )
        MakeDomainUserString(pszUserDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));

    NET_API_STATUS nas = NetJoinDomain(NULL, pszDomain, NULL, szDomainUser, pszPassword, dwFlags);
    if ( (nas == ERROR_ACCESS_DENIED) )
    {
        // perhaps an account exists, but we can't delete it so try and remove
        // the account create flag

        if ( dwFlags & NETSETUP_ACCT_CREATE )
        {    
            dwFlags &= ~NETSETUP_ACCT_CREATE;
            nas = NetJoinDomain(NULL, pszDomain, NULL, szDomainUser, *pszPassword ? pszPassword : NULL, dwFlags);
        }
    }

    if ( (nas != NERR_Success) && (nas != NERR_SetupAlreadyJoined) )
    {
        TCHAR szMessage[512];

        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) nas, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));
        
        ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_NAW_JOIN_GENERICERROR, MB_OK|MB_ICONERROR, szMessage);
        hr = HRESULT_FROM_WIN32(nas);
    }
#endif

    return hr;
}


void _ShowDcNotFoundErrorDialog(HWND hwnd, LPCWSTR pszDomain, LPCWSTR pszTitle)
{
    typedef void (*pfnShowDcNotFoundErrorDialog)(HWND, PCWSTR, PCWSTR);
    static HMODULE hNetID = NULL;
    static pfnShowDcNotFoundErrorDialog ShowDcNotFoundErrorDialog = NULL;

    if (!hNetID)
    {
        hNetID = LoadLibrary(L"netid.dll");
    }

    if (hNetID)
    {
        ShowDcNotFoundErrorDialog = (pfnShowDcNotFoundErrorDialog) GetProcAddress(hNetID, "ShowDcNotFoundErrorDialog");
        if (ShowDcNotFoundErrorDialog)
        {
            ShowDcNotFoundErrorDialog(hwnd, pszDomain, pszTitle);
        }
    }
}

//
// Handle moving from to a workgroup or domain.  To do this we are passed
// a structure containing all the information we need.
//
HRESULT JoinDomain(HWND hwnd, BOOL fDomain, LPCWSTR pszDomain, CREDINFO* pci, BOOL *pfReboot)
{
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0x0;
    LPWSTR pszCurrentDomain = NULL;
    NET_API_STATUS nas;
    BOOL fPassedCredentials = (pci && pci->pszUser && pci->pszUser[0] && pci->pszPassword);
    CWaitCursor cur;    

    //
    // lets validate the domain name before we go and use it, therefore avoiding
    // orphaning the computer too badly
    //

    nas = NetValidateName(NULL, pszDomain, NULL, NULL, fDomain ? NetSetupDomain:NetSetupWorkgroup);

    if (fDomain && (ERROR_NO_SUCH_DOMAIN == nas))
    {
        WCHAR szTitle[256];
        LoadString(g_hinst, IDS_NETWIZCAPTION, szTitle, ARRAYSIZE(szTitle));

        _ShowDcNotFoundErrorDialog(hwnd, pszDomain, szTitle);
        return E_FAIL;
    }

    if ( NERR_Success != nas )
    {
        ShellMessageBox(g_hinst, hwnd,
                        fDomain ? MAKEINTRESOURCE(IDS_ERR_BADDOMAIN) : MAKEINTRESOURCE(IDS_ERR_BADWORKGROUP), 
                        MAKEINTRESOURCE(IDS_NETWIZCAPTION),
                        MB_OK|MB_ICONWARNING,
                        pszDomain);
        return E_FAIL;
    }

    // 
    // now attempt to join the domain, prompt for credentails if the ones
    // specified are not good enough
    //

    if ( fDomain )
    {
        dwFlags |= NETSETUP_JOIN_DOMAIN|NETSETUP_ACCT_CREATE|NETSETUP_DOMAIN_JOIN_IF_JOINED;
    }
    else
    {
        nas = NetUnjoinDomain(NULL, NULL, NULL, NETSETUP_ACCT_DELETE);
        if ( (nas != NERR_Success) && (nas != NERR_SetupNotJoined) )
        {
            nas = NetUnjoinDomain(NULL, NULL, NULL, 0x0);
        }

        if ( (nas != NERR_Success) && (nas != NERR_SetupNotJoined) )
        {
            hres = E_UNEXPECTED;
            goto exit_gracefully;
        }

        *pfReboot = TRUE;               // we changed the domain
    }

    if ( !fDomain || fPassedCredentials)
    {
        if (fPassedCredentials)
        {
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, pci->pszUser, pci->pszDomain, pci->pszPassword);
        }
        else
        {
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, NULL, NULL, NULL);
        }
    }

    if ( fDomain && ((FAILED(hres) || (!fPassedCredentials))) )
    {
        do
        {
            if ( IDCANCEL == DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_PSW_JOINCREDENTIALS), 
                                                hwnd, _CredDlgProc, (LPARAM)pci) )
            {
                hres = E_FAIL;
                goto exit_gracefully;
            }

            // The dialog box changed the cursor from a wait cursor to an arrow cursor, so the cursor
            // needs to be changed back.. This call could be moved to _AttemptJoin (along with a call to
            // reset the cursor).  This call is made synchronously from the message loop for this hwnd
            cur.WaitCursor();            
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, pci->pszUser, pci->pszDomain, pci->pszPassword);

        }
        while ( FAILED(hres) );
    }

exit_gracefully:

    if ( SUCCEEDED(hres) )
    {
       ClearAutoLogon();
        *pfReboot = TRUE;               // we changed the domain
    }

    NetApiBufferFree(pszCurrentDomain);
    return hres;                                                                                                                                                                
}


//
// set and clear the auto admin logon state.
//
// we set the default user and default domain to the specified strings, we then blow away
// the clear text password stored in the registry to replace it with a password stored
// in the LSA secret space.
//

NTSTATUS _SetDefaultPassword(LPCWSTR PasswordBuffer)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (!NT_SUCCESS(Status))
        return Status;

    RtlInitUnicodeString(&SecretName, c_szDefaultPwdKey);
    RtlInitUnicodeString(&SecretValue, PasswordBuffer);

    Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
    LsaClose(LsaHandle);

    return Status;
}


//
// Set and clear auto logon for a particular
//

void SetAutoLogon(LPCWSTR pszUserName, LPCWSTR pszPassword)
{
#ifndef DONT_JOIN
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwComputerName = ARRAYSIZE(szComputerName);
    HKEY hk;

    GetComputerName(szComputerName, &dwComputerName);
    SetDefAccount(pszUserName, szComputerName);         // also clears auto logon

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szAutoLogon, L"1");             // auto admin logon
        _RegDelValue(hk, c_szDefPassword);              // use the LSA secret for the password
        RegCloseKey (hk);
    }

    _SetDefaultPassword(pszPassword);    
#endif
}


//
// clear the auto admin logon
//

STDAPI ClearAutoLogon(VOID)
{
#ifndef DONT_JOIN
    HKEY hk;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szAutoLogon, L"0");         // no auto admin logon
        _RegDelValue(hk, c_szDefPassword);  

        RegCloseKey(hk);
    }

    _SetDefaultPassword(L"");            // clear the LSA secret
#endif
    return S_OK;
}


//
// set the default account
//

void SetDefAccount(LPCWSTR pszUser, LPCWSTR pszDomain)
{
#ifndef DONT_JOIN
   ClearAutoLogon();

    HKEY hk;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szDefUserName, pszUser);             
        _RegSetSZ(hk, c_szDefDomain, pszDomain);
       RegCloseKey(hk);
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\netplace.h ===
#define NPTF_VALIDATE           0x00000001      // => validate the URL
#define NPTF_ALLOWWEBFOLDERS    0x00000002      // => allow binding to Web Folder locations
#define NPTF_SILENT             0x00000004      // => silent binding - no errors

class CNetworkPlace
{
public:
    CNetworkPlace();
    ~CNetworkPlace();

    // INetworkPlace
    HRESULT SetTarget(HWND hwnd, LPCWSTR pszTarget, DWORD dwFlags);
    HRESULT SetLoginInfo(LPCWSTR pszUser, LPCWSTR pszPassword);
    HRESULT SetName(HWND hwnd, LPCWSTR pszName);
    HRESULT SetDescription(LPCWSTR pszDescription);

    HRESULT GetTarget(LPWSTR pszBuffer, int cchBuffer)  
        { StrCpyN(pszBuffer, _szTarget, cchBuffer); return S_OK; }
    
    HRESULT GetName(LPWSTR pszBuffer, int cchBuffer);
    HRESULT GetIDList(HWND hwnd, LPITEMIDLIST *ppidl);
    HRESULT GetObject(HWND hwnd, REFIID riid, void **ppv);
    HRESULT CreatePlace(HWND hwnd, BOOL fOpen);

private:
    void _InvalidateCache();
    HRESULT _IDListFromTarget(HWND hwnd);
    HRESULT _TryWebFolders(HWND hwnd);
    BOOL _IsPlaceTaken(LPCTSTR pszName, LPTSTR pszPath);
    HRESULT _GetTargetPath(LPCITEMIDLIST pidl, LPTSTR pszPath, int cchPath);    

    LPITEMIDLIST _pidl;
    TCHAR _szTarget[INTERNET_MAX_URL_LENGTH];
    TCHAR _szName[MAX_PATH];
    TCHAR _szDescription[MAX_PATH];

    BOOL _fSupportWebFolders;           // apply hacks    
    BOOL _fIsWebFolder;                 // special case certain operations for Web Folders (office compat)
    BOOL _fDeleteWebFolder;             // if this is set then we must delete the Web Folder
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\netplace.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "msdasc.h"
#pragma hdrstop



CNetworkPlace::CNetworkPlace() :
    _pidl(NULL), _fSupportWebFolders(FALSE), _fIsWebFolder(FALSE), _fDeleteWebFolder(FALSE)
{
    _szTarget[0] = TEXT('\0');
    _szName[0] = TEXT('\0');
    _szDescription[0] = TEXT('\0');
}

// destructor - clean up our state
CNetworkPlace::~CNetworkPlace()
{
    _InvalidateCache();
}

void CNetworkPlace::_InvalidateCache()
{
    // web folders will create a shortcut to objects if we go through its binding
    // process, therefore when we attempt to invalidate our cache we should
    // clean up our mess.
    //
    // if the user has commited the change then we can/will keep the shortcut
    // around, otherwise we call the delete verb on it.

    if (_fIsWebFolder && _fDeleteWebFolder && _pidl)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        HRESULT hr = SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcm;
            hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_X_PPV_ARG(IContextMenu, NULL, &pcm));
            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFO ici = {0};
                ici.cbSize = sizeof (ici);
                ici.fMask = CMIC_MASK_FLAG_NO_UI;
                ici.lpVerb = "Delete";
                ici.nShow = SW_SHOWNORMAL;

                hr = pcm->InvokeCommand(&ici);
                pcm->Release();
            }
            psf->Release();
        }
    }

    // now clean up the rest of our state.

    ILFree(_pidl);
    _pidl = NULL;

    _szTarget[0] = TEXT('\0');
    _szName[0] = TEXT('\0');
    _szDescription[0] = TEXT('\0');

    _fIsWebFolder = FALSE;
    _fDeleteWebFolder = FALSE;
}


HRESULT CNetworkPlace::SetTarget(HWND hwnd, LPCWSTR pszTarget, DWORD dwFlags)
{
    _InvalidateCache();

    HRESULT hr = S_OK;
    if (pszTarget)
    {
        // set our state accordingly
        _fSupportWebFolders = (dwFlags & NPTF_ALLOWWEBFOLDERS) != 0;

        // copy the URL and prepare for parsing
        StrCpyN(_szTarget, pszTarget, ARRAYSIZE(_szTarget));

        INT cchTarget = lstrlen(_szTarget)-1;
        if ((_szTarget[cchTarget] == L'\\') || (_szTarget[cchTarget] == '/'))
        {
            _szTarget[cchTarget] = TEXT('\0');
        }

        if (dwFlags & NPTF_VALIDATE)
        {
            // connecting to a server root or local path is not supported
            if (PathIsUNCServer(_szTarget) || PathGetDriveNumber(_szTarget) != -1)
            {
                hr = E_INVALIDARG;                            
            }
            else
            {
                // check the policy to see if we are setting this.
                if (PathIsUNC(_szTarget) && SHRestricted(REST_NONETCONNECTDISCONNECT))
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    hr = _IDListFromTarget(hwnd);
                }
            }

            if (FAILED(hr))
            {
                if (hwnd && !(dwFlags & NPTF_SILENT))
                {
                    ::DisplayFormatMessage(hwnd, 
                                            IDS_ANP_CAPTION, 
                                            PathIsUNCServer(_szTarget) ? IDS_PUB_ONLYSERVER:IDS_CANTFINDFOLDER, 
                                            MB_OK|MB_ICONERROR);
                }
                _InvalidateCache();
            }
        }
    }
    
    return hr;
}


HRESULT CNetworkPlace::SetName(HWND hwnd, LPCWSTR pszName)
{
    HRESULT hr = S_OK;

    if (!_fIsWebFolder)
    {
        // check to see if we are going to overwrite an existing place, if we
        // are then display a prompt and let the user choose.  if they answer
        // yes, then have at it!

        TCHAR szPath[MAX_PATH];
        if (hwnd && _IsPlaceTaken(pszName, szPath))
        {
            if (IDNO == ::DisplayFormatMessage(hwnd, 
                                               IDS_ANP_CAPTION , IDS_FRIENDLYNAMEINUSE, 
                                               MB_YESNO|MB_ICONQUESTION, 
                                               pszName))
            {
                hr = E_FAIL;        
            }
        }
    }

    // if we succeed the above then lets use the new name.

    if (SUCCEEDED(hr))
        StrCpyN(_szName, pszName, ARRAYSIZE(_szName));

    return hr;
}


HRESULT CNetworkPlace::SetDescription(LPCWSTR pszDescription)
{
    StrCpyN(_szDescription, pszDescription, ARRAYSIZE(_szDescription));
    return S_OK;    
}


// recompute the URL based on the new user/password information that 
// we were just given.

HRESULT CNetworkPlace::SetLoginInfo(LPCWSTR pszUser, LPCWSTR pszPassword)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH + 1];
    TCHAR szExtraInfo[MAX_PATH + 1];                  // Includes Port Number and download type (ASCII, Binary, Detect)

    URL_COMPONENTS urlComps = {0};
    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    //  WARNING - the ICU_DECODE/ICU_ESCAPE is a lossy roundtrip - ZekeL - 26-MAR-2001
    //  many escaped characters are not correctly identified and re-escaped.
    //  any characters that are reserved for URL parsing purposes
    //  will be interpreted as their parsing char (ie '/').
    BOOL fResult = InternetCrackUrl(_szTarget, 0, 0, &urlComps);
    if (fResult)
    {
        urlComps.lpszUserName = (LPTSTR) pszUser;
        urlComps.dwUserNameLength = (pszUser ? lstrlen(pszUser) : 0);
        urlComps.lpszPassword = (LPTSTR) pszPassword;
        urlComps.dwPasswordLength = (pszPassword ? lstrlen(pszPassword) : 0);

        DWORD cchSize = ARRAYSIZE(_szTarget);
        fResult = InternetCreateUrl(&urlComps, (ICU_ESCAPE | ICU_USERNAME), _szTarget, &cchSize);

        // if we have a cached IDList then lets ensure that we clear it up
        // so that we rebind and the FTP namespace gets a crack at it.

        if (fResult && _pidl)
        {
            ILFree(_pidl);
            _pidl = NULL;
        }
    }
    return fResult ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CNetworkPlace::GetIDList(HWND hwnd, LPITEMIDLIST *ppidl)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        hr = SHILClone(_pidl, ppidl);
    }
    return hr;
}


HRESULT CNetworkPlace::GetObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, riid, _pidl, ppv);  
    }
    return hr;
}

HRESULT CNetworkPlace::GetName(LPWSTR pszBuffer, int cchBuffer)
{
    HRESULT hr = _IDListFromTarget(NULL);
    if (SUCCEEDED(hr))
    {
        StrCpyN(pszBuffer, _szName, cchBuffer);
        hr = S_OK;
    }
    return hr;
}


// check to see if we are going to overwrite a network place

BOOL CNetworkPlace::_IsPlaceTaken(LPCTSTR pszName, LPTSTR pszPath)
{
    BOOL fOverwriting = FALSE;

    SHGetSpecialFolderPath(NULL, pszPath, CSIDL_NETHOOD, TRUE);
    PathCombine(pszPath, pszPath, pszName);
    
    IShellFolder *psf;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;  
        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL)))
        {
            // we think we are going to overwrite an existing net place, so lets
            // check first to see if the place which is there is not actually
            // pointing at our new target.  if its is then we can just
            // ignore all of this.

            TCHAR szTarget[INTERNET_MAX_URL_LENGTH];
            hr = _GetTargetPath(pidl, szTarget, ARRAYSIZE(szTarget));
            if (FAILED(hr) || (0 != StrCmpI(szTarget, _szTarget)))
            {
                fOverwriting = TRUE;
            }
            ILFree(pidl);
        }
        psf->Release();
    }

    return fOverwriting;
}


// handle creating the web folders IDLIST for this item.  we check with the
// rosebud binder to find out if this scheme is supported, if so then
// we attempt to have the Web Folders code crack the URL

static const BYTE c_pidlWebFolders[] = 
{
    0x14,0x00,0x1F,0x0F,0xE0,0x4F,0xD0,0x20,
    0xEA,0x3A,0x69,0x10,0xA2,0xD8,0x08,0x00,
    0x2B,0x30,0x30,0x9D,0x14,0x00,0x2E,0x00,
    0x00,0xDF,0xEA,0xBD,0x65,0xC2,0xD0,0x11,
    0xBC,0xED,0x00,0xA0,0xC9,0x0A,0xB5,0x0F,
    0x00,0x00
};

HRESULT CNetworkPlace::_TryWebFolders(HWND hwnd)
{
    // lets see if Rosebud can handle this scheme item by checking the
    // scheme and seeing if the rosebud binder can handle it.
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH + 1];
    DWORD cchScheme = ARRAYSIZE(szScheme);
    HRESULT hr = UrlGetPart(_szTarget, szScheme, &cchScheme, URL_PART_SCHEME, 0);
    if (SUCCEEDED(hr))
    {
        IRegisterProvider *prp;
        hr = CoCreateInstance(CLSID_RootBinder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IRegisterProvider, &prp));
        if (SUCCEEDED(hr))
        {
            // let the web folders code have a go at creating a link to this storage,
            // the IDLIST we generate points to the folder inside My Computer (hidden)

            CLSID clsidOut;
            hr =  prp->GetURLMapping(szScheme, 0, &clsidOut);
            if (hr == S_OK)
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_IShellFolder, (LPCITEMIDLIST)c_pidlWebFolders, (void**)&psf);
                if (SUCCEEDED(hr))
                {
                    IBindCtx *pbc;
                    hr = CreateBindCtx(NULL, &pbc);
                    if (SUCCEEDED(hr))
                    {
                        BIND_OPTS bo = {sizeof(bo), 0, STGM_CREATE};
                        hr = pbc->SetBindOptions(&bo);
                        if (SUCCEEDED(hr))
                        {
                            // we need to pase NULL hWnd to this so that Web Folders doesn't display any
                            // UI, in particular its ever so useful NULL error message box... mumble mumble

                            LPITEMIDLIST pidl;
                            hr = psf->ParseDisplayName(NULL, pbc, _szTarget, NULL, &pidl, NULL);
                            if (SUCCEEDED(hr))
                            {
                                ASSERT(!_pidl);
                                hr = SHILCombine((LPCITEMIDLIST)c_pidlWebFolders, pidl, &_pidl);
                                ILFree(pidl);

                                _fDeleteWebFolder = TRUE;           // we now have the magic web folders link (clean it up)
                            }
                        }

                        pbc->Release();
                    }
                    psf->Release();
                }
            }
            else
            {
                hr = E_FAIL;
            }
            prp->Release();
        }
    }
    return hr;
}



// dereference a link and get the target path

HRESULT CNetworkPlace::_GetTargetPath(LPCITEMIDLIST pidl, LPTSTR pszPath, int cchPath)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHGetTargetFolderIDList(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, pszPath, cchPath, NULL);
        ILFree(pidlTarget);
    }
    return hr;
 }


// create an IDLIST for the target that we have, this code attempts to parse the name and
// then set our state for the item.  if we fail to parse then we attempt to have Web Folders
// look at it - this most common scenario for this will be the DAV RDR failing because
// the server isn't a DAV store, so instead we try Web Folders to handle WEC etc.

HRESULT CNetworkPlace::_IDListFromTarget(HWND hwnd)
{
    HRESULT hr = S_OK;
    if (!_pidl)
    {
        if (_szTarget[0])
        {
            _fIsWebFolder = FALSE;                      // not a web folder

            BINDCTX_PARAM rgParams[] = 
            { 
                { STR_PARSE_PREFER_FOLDER_BROWSING, NULL},
                { L"BUT NOT WEBFOLDERS", NULL},
            };
            IBindCtx *pbc;
            hr = BindCtx_RegisterObjectParams(NULL, rgParams, ARRAYSIZE(rgParams), &pbc);
            if (SUCCEEDED(hr))
            {
                IBindCtx *pbcWindow;
                hr = BindCtx_RegisterUIWindow(pbc, hwnd, &pbcWindow);
                if (SUCCEEDED(hr))
                {
                    SFGAOF sfgao;
                    hr = SHParseDisplayName(_szTarget, pbcWindow, &_pidl, SFGAO_FOLDER, &sfgao);

                    //  if we parsed something that turns out to not
                    //  be a folder, we want to throw it away
                    if (SUCCEEDED(hr) && !(sfgao & SFGAO_FOLDER))
                    {   
                        ILFree(_pidl);
                        _pidl = 0;
                        hr = E_FAIL;
                    }

                    // if that failed, its is a HTTP/HTTPS and we have web folders support then lets try
                    // and fall back to the old behaviour.

                    if (FAILED(hr) && _fSupportWebFolders)
                    {
                        DWORD scheme = GetUrlScheme(_szTarget);
                        if (scheme == URL_SCHEME_HTTP || scheme == URL_SCHEME_HTTPS)
                        {
                            switch (hr)
                            {
#if 0
                                case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
                                case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
                                case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
                                case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
#endif
                                case HRESULT_FROM_WIN32(ERROR_CANCELLED):
                                    break;

                                default:
                                {
                                    hr = _TryWebFolders(hwnd);
                                    if (SUCCEEDED(hr))
                                    {
                                        _fIsWebFolder = TRUE;
                                    }
                                }
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // given that we may have translated the name above for the parse
                        // to work, lets read back the name we used into our _szTarget.
                        SHGetNameAndFlags(_pidl, SHGDN_FORPARSING, _szTarget, ARRAYSIZE(_szTarget), NULL);
                    }
                    pbcWindow->Release();
                }
    
                // compute the place name for the location we have hit, this includes reusing
                // any places we have already created.

                if (SUCCEEDED(hr) && !_szName[0])
                {
                    SHGetNameAndFlags(_pidl, SHGDN_NORMAL, _szName, ARRAYSIZE(_szName), NULL);

                    TCHAR szPath[MAX_PATH];
                    if (!_fIsWebFolder && _IsPlaceTaken(_szName, szPath))
                    {
                        PathYetAnotherMakeUniqueName(szPath, szPath, NULL, NULL);
                        StrCpyN(_szName, PathFindFileName(szPath), ARRAYSIZE(_szName));     // update our state
                    }
                }
                pbc->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}


// handle creating the network place shortcut

HRESULT CNetworkPlace::CreatePlace(HWND hwnd, BOOL fOpen)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        // web folders already have their links created, therefore we can ignore this
        // whole process for them, and instead fall back to just executing their link.
        // 
        // for regular folders though we must attempt to find a unique name and create
        // the link, or if the link already exists that we can use then just open it.

        if (!_fIsWebFolder)
        {
            IShellLink *psl;
            hr = CoCreateInstance(CLSID_FolderShortcut, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(_pidl);

                if (SUCCEEDED(hr))
                    hr = psl->SetDescription(_szDescription[0] ? _szDescription:_szTarget);

                if (SUCCEEDED(hr))
                {
                    IPersistFile *ppf;
                    hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                    if (SUCCEEDED(hr))
                    {
                        // get the name to the shortcut, we assume that this is unique

                        TCHAR szPath[MAX_PATH];
                        SHGetSpecialFolderPath(NULL, szPath, CSIDL_NETHOOD, TRUE);
                        PathCombine(szPath, szPath, _szName);

                        hr = ppf->Save(szPath, TRUE);
                        ppf->Release();
                    }
                }
                psl->Release();
            }
        }
        else
        {
            // this is the web folder case, so we now need to set the display
            // name for this guy.  note that we don't have any control over
            // the description text we are going to be seeing.

            IShellFolder *psf;
            LPCITEMIDLIST pidlLast;
            hr = SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlNew;
                hr = psf->SetNameOf(hwnd, pidlLast, _szName, SHGDN_INFOLDER, &pidlNew);
                if (SUCCEEDED(hr))
                {
                    _fDeleteWebFolder = FALSE;
                    //Web folders will return S_FALSE with bogus pidlNew if _szName is the same as the current name
                    if (S_OK == hr)
                    {
                        ILFree(_pidl);
                        hr = SHILCombine((LPCITEMIDLIST)c_pidlWebFolders, pidlNew, &_pidl);
                    }
                }
                psf->Release();
            }
        }
    
        // now open the target if thats what they asked for

        if (SUCCEEDED(hr) && fOpen)
        {
            LPITEMIDLIST pidlNetPlaces;
            hr = SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidlNetPlaces);
            if (SUCCEEDED(hr))
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlNetPlaces, &psf));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = psf->ParseDisplayName(hwnd, NULL, _szName, NULL, &pidl, NULL);
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlToOpen;
                        hr = SHILCombine(pidlNetPlaces, pidl, &pidlToOpen);
                        if (SUCCEEDED(hr))
                        {
                            BrowseToPidl(pidlToOpen);
                            ILFree(pidlToOpen);
                        }
                        ILFree(pidl);
                    }
                    psf->Release();
                }
                ILFree(pidlNetPlaces);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\misc.cpp ===
#include "stdafx.h"
#include <objsel.h>         // Object picker
#include <dsrole.h>
#include "icwcfg.h"
#pragma hdrstop



// Wait cursor object

CWaitCursor::CWaitCursor() :
    _hCursor(NULL)
{
    WaitCursor();
}

CWaitCursor::~CWaitCursor()
{
    RestoreCursor();
}

void CWaitCursor::WaitCursor()
{ 
    _hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); 
}

void CWaitCursor::RestoreCursor()
{ 
    if (_hCursor)
     { 
        SetCursor(_hCursor); 
        _hCursor = NULL; 
    } 
}

HRESULT BrowseToPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // Use shellexecuteex to open a view on the pidl
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_IDLIST | SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpIDList = (void*) pidl;
    shexinfo.lpVerb = TEXT("open");

    hr = ShellExecuteEx(&shexinfo) ? S_OK : E_FAIL;

    return hr;
}


void FetchText(HWND hWndDlg, UINT uID, LPTSTR lpBuffer, DWORD dwMaxSize)
{
    TCHAR*  pszTemp;
    LPTSTR  pszString;

    *lpBuffer = L'\0';

    HWND hwndCtl = GetDlgItem(hWndDlg, uID);

    if (hwndCtl)
    {
        int iSize = GetWindowTextLength(hwndCtl);

        pszTemp = new TCHAR[iSize + 1];

        if (pszTemp)
        {
            GetWindowText(hwndCtl, pszTemp, iSize + 1);

            pszString = pszTemp;
            while (*pszString == L' ')
            {
                pszString = CharNext(pszString);
            }

            if (*pszString )
            {
                StrCpyN(lpBuffer, pszString, dwMaxSize);

                pszString = lpBuffer+(lstrlen(lpBuffer)-1);
                while ( (pszString > lpBuffer) && (*pszString == L' ') )
                    pszString--;

                pszString = CharNext(pszString);
                *pszString = L'\0';
            }

            delete [] pszTemp;
        }
    }
}

INT FetchTextLength(HWND hWndDlg, UINT uID) 
{
    TCHAR szBuffer[MAX_PATH];
    FetchText(hWndDlg, uID, szBuffer, ARRAYSIZE(szBuffer));
    return lstrlen(szBuffer);
}

HRESULT AttemptLookupAccountName(LPCTSTR szUsername, PSID* ppsid,
                                LPTSTR szDomain, DWORD* pcchDomain, SID_NAME_USE* psUse)
{
    // First try to find required size of SID
    DWORD cbSid = 0;
    DWORD cchDomain = *pcchDomain;
    BOOL fSuccess = LookupAccountName(NULL, szUsername, *ppsid, &cbSid, szDomain, pcchDomain, psUse);

    *ppsid = LocalAlloc(0, cbSid);      // Now create the SID buffer and try again
    if (!*ppsid )
        return E_OUTOFMEMORY;

    *pcchDomain = cchDomain;
    
    if (!LookupAccountName(NULL, szUsername, *ppsid, &cbSid, szDomain, pcchDomain, psUse))
    {
        // Free our allocated SID
        LocalFree(*ppsid);
        *ppsid = NULL;
        return E_FAIL;
    }
    return S_OK;
}

BOOL FormatMessageTemplate(LPCTSTR pszTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    va_list vaParamList;
    va_start(vaParamList, cchSize);
    BOOL fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, pszTemplate, 0, 0, pszStrOut, cchSize, &vaParamList);
    va_end(vaParamList);
    return fResult;
}

BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    BOOL fResult = FALSE;

    va_list vaParamList;
    
    TCHAR szFormat[MAX_STATIC + 1];
    if (LoadString(g_hinst, idTemplate, szFormat, ARRAYSIZE(szFormat)))
    {
        va_start(vaParamList, cchSize);
        
        fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, pszStrOut, cchSize, &vaParamList);

        va_end(vaParamList);
    }

    return fResult;
}

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...)
{
    int iResult = IDCANCEL;
    TCHAR szError[MAX_STATIC + 1]; *szError = 0;
    TCHAR szCaption[MAX_CAPTION + 1];
    TCHAR szFormat[MAX_STATIC + 1]; *szFormat = 0;

    // Load and format the error body
    if (LoadString(g_hinst, idFormatString, szFormat, ARRAYSIZE(szFormat)))
    {
        va_list arguments;
        va_start(arguments, uType);

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, szError, ARRAYSIZE(szError), &arguments))
        {
            // Load the caption
            if (LoadString(g_hinst, idCaption, szCaption, MAX_CAPTION))
            {
                iResult = MessageBox(hwnd, szError, szCaption, uType);
            }
        }

        va_end(arguments);
    }
    return iResult;
}

void EnableControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, BOOL fEnable)
{
    DWORD i;
    for (i = 0; i < cIDs; i ++)
    {
        EnableWindow(GetDlgItem(hwnd, prgIDs[i]), fEnable);
    }
}

void MakeDomainUserString(LPCTSTR szDomain, LPCTSTR szUsername, LPTSTR szDomainUser, DWORD cchBuffer)
{
    *szDomainUser = 0;

    if ((!szDomain) || szDomain[0] == TEXT('\0'))
    {
        // No domain - just use username
        StrCpyN(szDomainUser, szUsername, cchBuffer);
    }
    else
    {
        // Otherwise we have to build a DOMAIN\username string
        wnsprintf(szDomainUser, cchBuffer, TEXT("%s\\%s"), szDomain, szUsername);
    }    
}

// From the NT knowledge base
#define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes

BOOL GetCurrentUserAndDomainName(LPTSTR UserName, LPDWORD cchUserName, LPTSTR DomainName, LPDWORD cchDomainName)
{
    HANDLE hToken;
    
    UCHAR InfoBuffer[ MY_BUFSIZE ];
    DWORD cbInfoBuffer = MY_BUFSIZE;
    
    SID_NAME_USE snu;
    BOOL bSuccess;
    
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) 
    {
        if(GetLastError() == ERROR_NO_TOKEN) 
        {   
            // attempt to open the process token, since no thread token  exists
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
                return FALSE;
        } 
        else 
        {
            return FALSE;
        }
    }
    
    bSuccess = GetTokenInformation(hToken, TokenUser, InfoBuffer, cbInfoBuffer, &cbInfoBuffer);
    CloseHandle(hToken);

    if(!bSuccess) 
        return FALSE;

    return LookupAccountSid(NULL, ((PTOKEN_USER)InfoBuffer)->User.Sid, UserName, cchUserName, DomainName, cchDomainName, &snu);
}

// Pass NULL as TokenHandle to see if thread token is admin
HRESULT IsUserLocalAdmin(HANDLE TokenHandle, BOOL* pfIsAdmin)
{
    // First we must check if the current user is a local administrator; if this is
    // the case, our dialog doesn't even display

    PSID psidAdminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY security_nt_authority = SECURITY_NT_AUTHORITY;
    
    BOOL fSuccess = ::AllocateAndInitializeSid(&security_nt_authority, 2, 
                                               SECURITY_BUILTIN_DOMAIN_RID, 
                                               DOMAIN_ALIAS_RID_ADMINS, 
                                               0, 0, 0, 0, 0, 0,
                                               &psidAdminGroup);
    if (fSuccess)
    {
        // See if the user for this process is a local admin
        fSuccess = CheckTokenMembership(TokenHandle, psidAdminGroup, pfIsAdmin);
        FreeSid(psidAdminGroup);
    }

    return fSuccess ? S_OK:E_FAIL;
}

BOOL IsComputerInDomain()
{
    static BOOL fInDomain = FALSE;
    static BOOL fValid = FALSE;

    if (!fValid)
    {
        fValid = TRUE;

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdspdinfb = {0};
        DWORD err = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, 
            (BYTE**) &pdspdinfb);

        if ((err == NO_ERROR) && (pdspdinfb != NULL))
        {
            if ((pdspdinfb->MachineRole == DsRole_RoleStandaloneWorkstation) ||
                (pdspdinfb->MachineRole == DsRole_RoleStandaloneServer))
            {
                fInDomain = FALSE;
            }
            else
            {
                fInDomain = TRUE;
            }

            DsRoleFreeMemory(pdspdinfb);
        }
    }

    return fInDomain;
}

void OffsetControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, int dx, int dy)
{
    for (DWORD i = 0; i < cIDs; i ++)
        OffsetWindow(GetDlgItem(hwnd, prgIDs[i]), dx, dy);
}

void OffsetWindow(HWND hwnd, int dx, int dy)
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rc, 2);
    OffsetRect(&rc, dx, dy);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}

BOOL AddPropSheetPageCallback(HPROPSHEETPAGE hpsp, LPARAM lParam)
{
    // lParam is really a ADDPROPSHEETDATA*
    ADDPROPSHEETDATA* ppsd = (ADDPROPSHEETDATA*)lParam;
    if (ppsd->nPages < ARRAYSIZE(ppsd->rgPages))
    {
        ppsd->rgPages[ppsd->nPages++] = hpsp;
        return TRUE;
    }
    return FALSE;
}

// Code to ensure only one instance of a particular window is running
CEnsureSingleInstance::CEnsureSingleInstance(LPCTSTR szCaption)
{
    // Create an event
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, szCaption);

    // If any weird errors occur, default to running the instance
    m_fShouldExit = FALSE;

    if (NULL != m_hEvent)
    {
        // If our event isn't signaled, we're the first instance
        m_fShouldExit = (WAIT_OBJECT_0 == WaitForSingleObject(m_hEvent, 0));

        if (m_fShouldExit)
        {
            // app should exit after calling ShouldExit()

            // Find and show the caption'd window
            HWND hwndActivate = FindWindow(NULL, szCaption);
            if (IsWindow(hwndActivate))
            {
                SetForegroundWindow(hwndActivate);
            }
        }
        else
        {
            // Signal that event
            SetEvent(m_hEvent);
        }
    }
}

CEnsureSingleInstance::~CEnsureSingleInstance()
{
    if (NULL != m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}


// Browse for a user
//
// This routine activates the appropriate Object Picker to allow
// the user to select a user
// uiTextLocation  -- The resource ID of the Edit control where the selected 
//                    object should be printed 

HRESULT BrowseForUser(HWND hwndDlg, TCHAR* pszUser, DWORD cchUser, TCHAR* pszDomain, DWORD cchDomain)
{
    DSOP_SCOPE_INIT_INFO scopeInfo = {0};
    scopeInfo.cbSize = sizeof (scopeInfo);
    scopeInfo.flType = 
        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE   |
        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE | 
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN      |
        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN    |
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN            |
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    scopeInfo.flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    scopeInfo.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    scopeInfo.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    scopeInfo.FilterFlags.Uplevel.flMixedModeOnly = 0;
    scopeInfo.FilterFlags.Uplevel.flNativeModeOnly = 0;
    scopeInfo.pwzADsPath = NULL;
    scopeInfo.pwzDcName = NULL;
    scopeInfo.hr = E_FAIL;

    DSOP_INIT_INFO initInfo = {0};
    initInfo.cbSize = sizeof (initInfo);
    initInfo.pwzTargetComputer = NULL;
    initInfo.cDsScopeInfos = 1;
    initInfo.aDsScopeInfos = &scopeInfo;
    initInfo.flOptions = 0;

    IDsObjectPicker* pPicker;
    
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (LPVOID*)&pPicker);
    if (SUCCEEDED(hr))
    {
        hr = pPicker->Initialize(&initInfo);
        if (SUCCEEDED(hr))
        {
            IDataObject* pdo;
            hr = pPicker->InvokeDialog(hwndDlg, &pdo);            // S_FALSE indicates cancel
            if ((S_OK == hr) && (NULL != pdo))
            {
                // Get the DS_SELECTION_LIST out of the data obj
                FORMATETC fmt;
                fmt.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
                fmt.ptd = NULL;
                fmt.dwAspect = DVASPECT_CONTENT;
                fmt.lindex = -1;
                fmt.tymed = TYMED_HGLOBAL;

                STGMEDIUM medium = {0};
                
                hr = pdo->GetData(&fmt, &medium);

                if (SUCCEEDED(hr))
                {
                    DS_SELECTION_LIST* plist;
                    plist = (DS_SELECTION_LIST*)
                        GlobalLock(medium.hGlobal);

                    if (NULL != plist)
                    {
                        if (plist->cItems >= 1)
                        {
                            WCHAR szWinNTProviderName[MAX_DOMAIN + MAX_USER + 10];
                            StrCpyN(szWinNTProviderName, plist->aDsSelection[0].pwzADsPath, ARRAYSIZE(szWinNTProviderName));

                            // Is the name in the correct format?
                            if (StrCmpNI(szWinNTProviderName, TEXT("WinNT://"), 8) == 0)
                            {
                                // Yes, copy over the user name and password
                                LPTSTR szDomain = szWinNTProviderName + 8;
                                LPTSTR szUser = StrChr(szDomain, TEXT('/'));
                                if (szUser)
                                {
                                    LPTSTR szTemp = CharNext(szUser);
                                    *szUser = 0;
                                    szUser = szTemp;

                                    // Just in case, remove the trailing slash
                                    LPTSTR szTrailingSlash = StrChr(szUser, TEXT('/'));
                                    if (szTrailingSlash)
                                        *szTrailingSlash = 0;

                                    StrCpyN(pszUser, szUser, cchUser);
                                    StrCpyN(pszDomain, szDomain, cchDomain);

                                    hr = S_OK;
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = E_UNEXPECTED;                          // No selection list!
                    }
                    GlobalUnlock(medium.hGlobal);
                }
                pdo->Release();
            }
        }
        pPicker->Release();
    }
    return hr;
}


//
// create the intro/done large font for wizards
// 

static HFONT g_hfontIntro = NULL;

HFONT GetIntroFont(HWND hwnd)
{
    if ( !g_hfontIntro )
    {
        TCHAR szBuffer[64];
        NONCLIENTMETRICS ncm = { 0 };
        LOGFONT lf;

        ncm.cbSize = SIZEOF(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        lf = ncm.lfMessageFont;
        LoadString(g_hinst, IDS_TITLEFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
        lf.lfWeight = FW_BOLD;

        LoadString(g_hinst, IDS_TITLEFONTSIZE, szBuffer, ARRAYSIZE(szBuffer));
        lf.lfHeight = 0 - (GetDeviceCaps(NULL, LOGPIXELSY) * StrToInt(szBuffer) / 72);

        g_hfontIntro = CreateFontIndirect(&lf);
    }
    return g_hfontIntro;
}

void CleanUpIntroFont()
{
    if (g_hfontIntro)
    {
        DeleteObject(g_hfontIntro);
        g_hfontIntro = NULL;
    }
}

void DomainUserString_GetParts(LPCTSTR szDomainUser, LPTSTR szUser, DWORD cchUser, LPTSTR szDomain, DWORD cchDomain)
{
    // Check for invalid args
    if ((!szUser) ||
        (!szDomain) ||
        (!cchUser) ||
        (!cchDomain))
    {
        return;
    }
    else
    {
        *szUser = 0;
        *szDomain = 0;

        TCHAR szTemp[MAX_USER + MAX_DOMAIN + 2];
        StrCpyN(szTemp, szDomainUser, ARRAYSIZE(szTemp));

        LPTSTR szWhack = StrChr(szTemp, TEXT('\\'));

        if (!szWhack)
        {
            // Also check for forward slash to be friendly
            szWhack = StrChr(szTemp, TEXT('/'));
        }

        if (szWhack)
        {
            LPTSTR szUserPointer = szWhack + 1;
            *szWhack = 0;

            // Temp now points to domain.
            StrCpyN(szDomain, szTemp, cchDomain);
            StrCpyN(szUser, szUserPointer, cchUser);
        }
        else
        {
            // Don't have a domain name - just a username
            StrCpyN(szUser, szTemp, cchUser);
        }
    }
}

LPITEMIDLIST GetComputerParent()
{
    LPITEMIDLIST pidl = NULL;

    IShellFolder *psfDesktop;
    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        TCHAR szName[MAX_PATH];
        szName[0] = szName[1] = L'\\';

        LPTSTR pszAfterWhacks = szName + 2;
        DWORD cchName = ARRAYSIZE(szName) - 2;
        if (GetComputerName(pszAfterWhacks, &cchName))
        {
            hres = psfDesktop->ParseDisplayName(NULL, NULL, szName, NULL, &pidl, NULL);
            if (SUCCEEDED(hres))
            {
                ILRemoveLastID(pidl);
            }
        }
        else
        {
            hres = E_FAIL;
        }

        psfDesktop->Release();
    }

    if (FAILED(hres) && pidl)
    {
        ILFree(pidl);
        pidl = NULL;
    }

    return pidl;    
}

int CALLBACK ShareBrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        {
            // Try to set the selected item according to the path string passed in lpData
            LPTSTR pszPath = (LPTSTR) lpData;

            if (pszPath && pszPath[0])
            {
                int i = lstrlen(pszPath) - 1;
                if ((pszPath[i] == TEXT('\\')) ||
                    (pszPath[i] == TEXT('/')))
                {
                    pszPath[i] = 0;
                }
   
                SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) (LPTSTR) pszPath);
            }
            else
            {
                // Try to get the computer's container folder
                LPITEMIDLIST pidl = GetComputerParent();

                if (pidl)
                {
                    SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) FALSE, (LPARAM) (LPTSTR) pidl);                
                    ILFree(pidl);
                }
            }
        }
        break;

    case BFFM_SELCHANGED:
        // Disable OK if this isn't a UNC path type thing
        {
            TCHAR szPath[MAX_PATH];
            LPITEMIDLIST pidl = (LPITEMIDLIST) lParam;

            BOOL fEnableOk = FALSE;
            
            if (SUCCEEDED(SHGetTargetFolderPath(pidl, szPath, ARRAYSIZE(szPath))))
            {
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_ATTRIBUTES);

                // Enable OK only if this is a file folder
                if (sfi.dwAttributes & SFGAO_FILESYSTEM)
                {
                    fEnableOk = PathIsUNC(szPath);
                }
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) fEnableOk);
        }
        break;
    }
    return 0;
}


void RemoveControl(HWND hwnd, UINT idControl, UINT idNextControl, const UINT* prgMoveControls, DWORD cControls, BOOL fShrinkParent)
{
    HWND hwndControl = GetDlgItem(hwnd, idControl);
    HWND hwndNextControl = GetDlgItem(hwnd, idNextControl);
    RECT rcControl;
    RECT rcNextControl;

    if (hwndControl && GetWindowRect(hwndControl, &rcControl) && 
        hwndNextControl && GetWindowRect(hwndNextControl, &rcNextControl))
    {
        int dx = rcControl.left - rcNextControl.left;
        int dy = rcControl.top - rcNextControl.top;

        MoveControls(hwnd, prgMoveControls, cControls, dx, dy);

        if (fShrinkParent)
        {
            RECT rcParent;

            if (GetWindowRect(hwnd, &rcParent))
            {
                MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rcParent, 2);

                rcParent.right += dx;
                rcParent.bottom += dy;

                SetWindowPos(hwnd, NULL, 0, 0, RECTWIDTH(rcParent), RECTHEIGHT(rcParent), SWP_NOMOVE | SWP_NOZORDER);
            }
        }

        EnableWindow(hwndControl, FALSE);
        ShowWindow(hwndControl, SW_HIDE);
    }
}

void MoveControls(HWND hwnd, const UINT* prgControls, DWORD cControls, int dx, int dy)
{
    DWORD iControl;
    for (iControl = 0; iControl < cControls; iControl ++)
    {
        HWND hwndControl = GetDlgItem(hwnd, prgControls[iControl]);
        RECT rcControl;

        if (hwndControl && GetWindowRect(hwndControl, &rcControl))
        {
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcControl, 2);
            SetWindowPos(hwndControl, NULL, rcControl.left + dx, rcControl.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }
    }
}


// compute the size of a control based on the you are going to set into it, 
// returning the delta in size.

int SizeControlFromText(HWND hwnd, UINT id, LPTSTR psz)
{
    HDC hdc = GetDC(hwnd);
    if (hdc)
    {   
        HFONT hfDialog = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
        HFONT hfOld = (HFONT)SelectObject(hdc, hfDialog);

        RECT rc;
        GetClientRect(GetDlgItem(hwnd, id), &rc);

        int cy = RECTHEIGHT(rc);
        int dy = DrawTextEx(hdc, psz, -1, &rc, 
                            DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS |
                            DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL,
                             NULL) - cy;

        SetWindowPos(GetDlgItem(hwnd, id), NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOMOVE|SWP_NOZORDER);

        if (hfOld)
            SelectObject(hdc, hfOld);

        ReleaseDC(hwnd, hdc);
        return dy;
    }
    return 0;
}


void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain)
{
    BOOL fEnable;

    // Get the string the user is typing
    TCHAR* pszLogonName;
    int cchBuffer = (int)SendMessage(hwndUsername, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) LocalAlloc(0, cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwndUsername, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);

        // Disable the domain combo if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com
        fEnable = (NULL == StrChr(pszLogonName, TEXT('@')));

        EnableWindow(hwndDomain, fEnable);

        LocalFree(pszLogonName);
    }
}


//
//  Set our Alt+Tab icon for the duration of a modal property sheet.
//

int PropertySheetIcon(LPCPROPSHEETHEADER ppsh, LPCTSTR pszIcon)
{
    int     iResult;
    HWND    hwnd, hwndT;
    BOOL    fChangedIcon = FALSE;
    HICON   hicoPrev;

    // This trick doesn't work for modeless property sheets
    _ASSERT(!(ppsh->dwFlags & PSH_MODELESS));

    // Don't do this if the property sheet itself already has an icon
    _ASSERT(ppsh->hIcon == NULL);

    // Walk up the parent/owner chain until we find the master owner.
    //
    // We need to walk the parent chain because sometimes we are given
    // a child window as our lpwd->hwnd.  And we need to walk the owner
    // chain in order to find the owner whose icon will be used for
    // Alt+Tab.
    //
    // GetParent() returns either the parent or owner.  Normally this is
    // annoying, but we luck out and it's exactly what we want.

    hwnd = ppsh->hwndParent;
    while ((hwndT = GetParent(hwnd)) != NULL)
    {
        hwnd = hwndT;
    }

    // If the master owner isn't visible we can futz his icon without
    // screwing up his appearance.
    if (!IsWindowVisible(hwnd))
    {
        HICON hicoNew = LoadIcon(g_hinst, pszIcon);
        hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
        fChangedIcon = TRUE;
    }

    iResult = (int)PropertySheet(ppsh);

    // Clean up our icon now that we're done
    if (fChangedIcon)
    {
        // Put the old icon back
        HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
        if (hicoNew)
            DestroyIcon(hicoNew);
    }

    return iResult;
}


// Launch ICW shiznits

BOOL IsICWCompleted()
{
    DWORD dwICWCompleted = 0;
    DWORD dwICWSize = sizeof(dwICWCompleted);
    SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwICWSize);

    // 99/01/15 #272829 vtan: This is a horrible hack!!! If ICW has
    // not been run but settings have been made manually then values
    // in HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections
    // exists with the values given. Look for the presence of a key
    // to resolve that settings are present but that ICW hasn't been
    // launched.

    // The ideal solution is to get ICW to make this determination
    // for us BUT TO NOT LAUNCH ICWCONN1.EXE IN THE PROCESS.
    // Currently it will only launch. There is no way to get the
    // desired result without a launch.

    // 99/02/01 #280138 vtan: Well the solution put in for #272829
    // doesn't work. So peeking at the CheckConnectionWizard()
    // source in inetcfg\export.cpp shows that it uses a
    // wininet.dll function to determine whether manually configured
    // internet settings exist. It also exports this function so
    // look for it and bind to it dynamically.

    if (dwICWCompleted == 0)
    {

#define SMART_RUNICW    TRUE
#define SMART_QUITICW   FALSE

        HINSTANCE hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            typedef DWORD (WINAPI *PFNISSMARTSTART) ();
            PFNISSMARTSTART pfnIsSmartStart = reinterpret_cast<PFNISSMARTSTART>(GetProcAddress(hICWInst, "IsSmartStart"));
            if (pfnIsSmartStart)
            {
                dwICWCompleted = BOOLIFY(pfnIsSmartStart() == SMART_QUITICW);
            }
            FreeLibrary(hICWInst);
        }
    }
    return (dwICWCompleted != 0);
}

void LaunchICW()
{
    static BOOL s_fCheckedICW = FALSE;

    if (!s_fCheckedICW && !IsICWCompleted())
    {
       // Prevent an error in finding the ICW from causing this to execute over and over again.

        s_fCheckedICW = TRUE;
        HINSTANCE hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            PFNCHECKCONNECTIONWIZARD pfnCheckConnectionWizard;

            pfnCheckConnectionWizard = reinterpret_cast<PFNCHECKCONNECTIONWIZARD>(GetProcAddress(hICWInst, "CheckConnectionWizard"));
            if (pfnCheckConnectionWizard != NULL)
            {
                // If the user cancels ICW then it needs to be launched again.

                s_fCheckedICW = FALSE;
                
                DWORD dwICWResult;
                pfnCheckConnectionWizard(ICW_LAUNCHFULL | ICW_LAUNCHMANUAL, &dwICWResult);
            }
            FreeLibrary(hICWInst);
        }
    }
}

HRESULT LookupLocalGroupName(DWORD dwRID, LPWSTR pszName, DWORD cchName)
{
    HRESULT hr = E_FAIL;

    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY security_nt_authority = SECURITY_NT_AUTHORITY;
    
    BOOL fSuccess = ::AllocateAndInitializeSid(&security_nt_authority, 2, 
                                               SECURITY_BUILTIN_DOMAIN_RID, 
                                               dwRID, 
                                               0, 0, 0, 0, 0, 0,
                                               &psidGroup);
    if (fSuccess)
    {
        // Get the name
        WCHAR szDomain[MAX_GROUP + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);
        SID_NAME_USE type;
        fSuccess = LookupAccountSid(NULL, psidGroup, pszName, &cchName, szDomain, &cchDomain, &type);
        FreeSid(psidGroup);

        hr = fSuccess ? S_OK : E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\netpage.h ===
#ifndef NETPAGE_H
#define NETPAGE_H

class CNetworkUserWizardPage: public CPropertyPage
{
public:
    CNetworkUserWizardPage(CUserInfo* pUserInfo);

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);


private:
    // Data
    CUserInfo* m_pUserInfo;

private:
    // Functions
    void SetWizardButtons(HWND hwnd, HWND hwndPropSheet);
    HRESULT GetUserAndDomain(HWND hwnd);
};

#endif //!NETPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\netwiz.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#include <dsgetdc.h>        // DsGetDCName and DS structures
#include <ntdsapi.h>
#include <activeds.h>       // ADsGetObject
#include <rasdlg.h>
#include <raserror.h>
#pragma hdrstop


CGroupPageBase* g_pGroupPageBase;       // used for the group page

DWORD g_dwWhichNet = 0;
UINT g_uWizardIs = NAW_NETID; 

BOOL g_fRebootOnExit = FALSE;           
BOOL g_fShownLastPage = FALSE;          
BOOL g_fCreatedConnection = FALSE;      // we created a RAS connection during the wizard, therefore kill it on exit
BOOL g_fMachineRenamed = FALSE;

WCHAR g_szUser[MAX_DOMAINUSER + 1] = { L'\0' };
WCHAR g_szDomain[MAX_DOMAIN + 1] = { L'\0' };
WCHAR g_szCompDomain[MAX_DOMAIN + 1] = { L'\0' };

// default workgroup to be joined 
#define DEFAULT_WORKGROUP   L"WORKGROUP"

// Set the Wizard buttons for the dialog
void SetWizardButtons(HWND hwndPage, DWORD dwButtons)
{
    HWND hwndParent = GetParent(hwndPage);

    if (g_uWizardIs != NAW_NETID)
    {
        EnableWindow(GetDlgItem(hwndParent,IDHELP),FALSE);
        ShowWindow(GetDlgItem(hwndParent,IDHELP),SW_HIDE);
    }

    if (g_fRebootOnExit) 
    {
        TCHAR szBuffer[80];
        LoadString(g_hinst, IDS_CLOSE, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hwndParent, IDCANCEL, szBuffer);
    }
    
    PropSheet_SetWizButtons(hwndParent, dwButtons);
}


// intro dialog - set the title text etc

INT_PTR CALLBACK _IntroDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT);
                    return TRUE;              

                case PSN_WIZNEXT:
                {
                    switch (g_uWizardIs)
                    {
                    case NAW_PSDOMAINJOINED:
                        WIZARDNEXT(hwnd, IDD_PSW_ADDUSER);
                        break;
                    default:
                        // Let the wizard go to the next page
                        break;
                    }
                        

                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}                                    


// how do they use this machine? corp/vs home

INT_PTR CALLBACK _HowUseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CheckRadioButton(hwnd, IDC_NETWORKED, IDC_NOTNETWORKED, IDC_NETWORKED);
            return TRUE;
    
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_WELCOME);
                    return TRUE;

                case PSN_WIZNEXT:
                {                    
                    if (IsDlgButtonChecked(hwnd, IDC_NETWORKED) == BST_CHECKED)
                    {
                        WIZARDNEXT(hwnd, IDD_PSW_WHICHNET);
                    }
                    else
                    {
                        g_dwWhichNet = IDC_NONE;

                        if (SUCCEEDED(JoinDomain(hwnd, FALSE, DEFAULT_WORKGROUP, NULL, &g_fRebootOnExit)))
                        {
                            WIZARDNEXT(hwnd, IDD_PSW_DONE);
                        }
                        else
                        {
                            WIZARDNEXT(hwnd, -1);
                        }
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// determine the network they want to join

INT_PTR CALLBACK _WhichNetDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CheckRadioButton(hwnd, IDC_DOMAIN, IDC_WORKGROUP, IDC_DOMAIN);
            return TRUE;
    
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_HOWUSE);
                    return TRUE;

                case PSN_WIZNEXT:
                {                    
                    if (IsDlgButtonChecked(hwnd, IDC_DOMAIN) == BST_CHECKED)
                    {
                        g_dwWhichNet = IDC_DOMAIN;
                        WIZARDNEXT(hwnd, IDD_PSW_DOMAININFO);
                    }
                    else
                    {
                        g_dwWhichNet = IDC_WORKGROUP;
                        WIZARDNEXT(hwnd, IDD_PSW_WORKGROUP);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// we are joining a workgroup etc

INT_PTR CALLBACK _WorkgroupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            Edit_LimitText(GetDlgItem(hwnd, IDC_WORKGROUP), MAX_WORKGROUP);
            SetDlgItemText(hwnd, IDC_WORKGROUP, DEFAULT_WORKGROUP);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
                    if (!FetchTextLength(hwnd, IDC_WORKGROUP))
                        dwButtons &= ~PSWIZB_NEXT;

                    SetWizardButtons(hwnd, dwButtons);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_WHICHNET);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    WCHAR szWorkgroup[MAX_WORKGROUP+1];
                    FetchText(hwnd, IDC_WORKGROUP, szWorkgroup, ARRAYSIZE(szWorkgroup));

                    if (SUCCEEDED(JoinDomain(hwnd, FALSE, szWorkgroup, NULL, &g_fRebootOnExit)))
                    {
                        ClearAutoLogon();
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }
                    else
                    {
                        WIZARDNEXT(hwnd, -1);
                    }
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wParam) == EN_CHANGE)
            {
                DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
                if (!FetchTextLength(hwnd, IDC_WORKGROUP))
                    dwButtons &= ~PSWIZB_NEXT;

                SetWizardButtons(hwnd, dwButtons);
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


// were done, show the final page

INT_PTR CALLBACK _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    TCHAR szBuffer[MAX_PATH];

                    // change the closing prompt if we are supposed to be

                    LoadString(g_hinst, 
                               g_fRebootOnExit ? IDS_NETWIZFINISHREBOOT:IDS_NETWIZFINISH, 
                               szBuffer, ARRAYSIZE(szBuffer));
            
                    SetDlgItemText(hwnd, IDC_FINISHSTATIC, szBuffer);
                    SetWizardButtons(hwnd, PSWIZB_BACK|PSWIZB_FINISH);

                    g_fShownLastPage = TRUE;                    // show the last page of the wizard

                    return TRUE;
                }

                case PSN_WIZBACK:
                {
                    switch (g_dwWhichNet)
                    {
                        case IDC_DOMAIN:
                            WIZARDNEXT(hwnd, g_fMachineRenamed ? IDD_PSW_COMPINFO : IDD_PSW_ADDUSER);
                            break;

                        case IDC_WORKGROUP:
                            WIZARDNEXT(hwnd, IDD_PSW_WORKGROUP);
                            break;

                        case IDC_NONE:
                            WIZARDNEXT(hwnd, IDD_PSW_HOWUSE);
                            break;
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// subclass this is used for the setup scenario where we want to remove various
// buttons and stop the dialog from being moved.  therefore we subclass the
// wizard during its creation and lock its place.

static WNDPROC _oldDlgWndProc;

LRESULT CALLBACK _WizardSubWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // on WM_WINDOWPOSCHANGING and the window is moving then lets centre it onto the
    // desktop window.  unfortunately setting the DS_CENTER bit doesn't buy us anything
    // as the wizard is resized after creation.
    //

    if (uMsg == WM_WINDOWPOSCHANGING)
    {
        LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
        RECT rcDlg, rcDesktop;

        GetWindowRect(hwnd, &rcDlg);
        GetWindowRect(GetDesktopWindow(), &rcDesktop);

        lpwp->x = ((rcDesktop.right-rcDesktop.left)-(rcDlg.right-rcDlg.left))/2;
        lpwp->y = ((rcDesktop.bottom-rcDesktop.top)-(rcDlg.bottom-rcDlg.top))/2;
        lpwp->flags &= ~SWP_NOMOVE;
    }

    return _oldDlgWndProc(hwnd, uMsg, wParam, lParam);        
}

int CALLBACK _PropSheetCB(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
        // in pre-create lets set the window styles accorindlgy
        //      - remove the context menu and system menu

        case PSCB_PRECREATE:
        {
            DLGTEMPLATE *pdlgtmp = (DLGTEMPLATE*)lParam;
            pdlgtmp->style &= ~(DS_CONTEXTHELP|WS_SYSMENU);
            break;
        }

        // we now have a dialog, so lets sub class it so we can stop it being
        // move around.

        case PSCB_INITIALIZED:
        {
            if (g_uWizardIs != NAW_NETID)
                _oldDlgWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_WizardSubWndProc);

            break;
        }
    }

    return FALSE;
}


// gather domain information about the user

INT_PTR CALLBACK _DomainInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE: 
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                {
                    if ( g_uWizardIs != NAW_NETID )
                        WIZARDNEXT(hwnd, IDD_PSW_WELCOME);

                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}                                    



// handle searching the active directory for an object

//
// Search columns are returns as a ADS_SEARCH_COLUMN which is like a variant,
// but, the data form is more specific to a DS.
//
// We only need strings, therefore barf if any other type is given to us.
//

HRESULT _GetStringFromColumn(ADS_SEARCH_COLUMN *pasc, LPWSTR pBuffer, INT cchBuffer)
{
    switch ( pasc->dwADsType )
    {
        case ADSTYPE_DN_STRING:
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
            StrCpyN(pBuffer, pasc->pADsValues[0].DNString, cchBuffer);
            break;

        default:
            return E_FAIL;
    }

    return S_OK;
}


//
// Search the DS for a computer object that matches this computer name, if
// we find one then try and crack the name to give us something that
// can be used to join a domain.
//

HRESULT _FindComputerInDomain(LPWSTR pszUserName, LPWSTR pszUserDomain, LPWSTR pszSearchDomain, LPWSTR pszPassword, BSTR *pbstrCompDomain)
{
    HRESULT hres; 
    CWaitCursor cur;
    HRESULT hrInit = SHCoInitialize();

    WCHAR wszComputerObjectPath[MAX_PATH + 1] = { 0 };          // path to the computer object

    // Lets try and deterrmine the domain to search by taking the users domain and
    // calling DsGetDcName with it.

    PDOMAIN_CONTROLLER_INFO pdci;
    DWORD dwres = DsGetDcName(NULL, pszSearchDomain, NULL, NULL, DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED, &pdci);
    if ( (NO_ERROR == dwres) && pdci->DnsForestName )
    {
        TCHAR szDomainUser[MAX_DOMAINUSER + 1];
        MakeDomainUserString(pszUserDomain, pszUserName, szDomainUser, ARRAYSIZE(szDomainUser));

        WCHAR szBuffer[MAX_PATH + 1];
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), L"GC://%s", pdci->DnsForestName);

        // now open the GC with the domain user (formatting the forest name above)

        IDirectorySearch* pds = NULL;
        hres = ADsOpenObject(szBuffer, szDomainUser, pszPassword, ADS_SECURE_AUTHENTICATION, IID_PPV_ARG(IDirectorySearch, &pds));
        if (SUCCEEDED(hres))
        {
            // we have a GC object, so lets search it...

            ADS_SEARCHPREF_INFO prefInfo[1];
            prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
            prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
            prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;
        
            hres = pds->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
            if (SUCCEEDED(hres))
            {
                LPWSTR c_aszAttributes[] = { L"ADsPath", };

                // using the computer name for this object lets scope the query accordingly
            
                WCHAR szComputerName[MAX_COMPUTERNAME + 1];
                DWORD dwComputerName = ARRAYSIZE(szComputerName);
                GetComputerName(szComputerName, &dwComputerName);
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), L"(&(sAMAccountType=805306369)(sAMAccountName=%s$))", szComputerName);

                // issue the query

                ADS_SEARCH_HANDLE hSearch = NULL;
                hres = pds->ExecuteSearch(szBuffer, c_aszAttributes, ARRAYSIZE(c_aszAttributes), &hSearch);
                if (SUCCEEDED(hres))
                {
                    // we executed the search, so we can now attempt to read the results back
                    hres = pds->GetNextRow(hSearch);
                    if (SUCCEEDED(hres) && (hres != S_ADS_NOMORE_ROWS))
                    {
                        // we received a result back, so lets get the ADsPath of the computer
                        ADS_SEARCH_COLUMN ascADsPath;
                        hres = pds->GetColumn(hSearch, L"ADsPath", &ascADsPath);
                        if (SUCCEEDED(hres))
                            hres = _GetStringFromColumn(&ascADsPath, wszComputerObjectPath, ARRAYSIZE(wszComputerObjectPath));
                    }
                    pds->CloseSearchHandle(hSearch);
                }
            }
            pds->Release();
        }
        NetApiBufferFree(pdci);
    }
    else
    {
        hres = E_FAIL;
    }

    // So we found an object that is of the category computer, and it has the same name
    // as the computer object we are looking for.  Lets try and crack the name now
    // and determine which domain it is in.

    if (SUCCEEDED(hres))
    {
        IADsPathname* padp = NULL;
        hres = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (LPVOID*)&padp);
        if (SUCCEEDED(hres))
        {
            hres = padp->Set(wszComputerObjectPath, ADS_SETTYPE_FULL);
            if (SUCCEEDED(hres))
            {
                BSTR bstrX500DN = NULL;
                hres = padp->Retrieve(ADS_FORMAT_X500_DN, &bstrX500DN);
                if (SUCCEEDED(hres))
                {
                    PDS_NAME_RESULT pdnr = NULL;
                    dwres = DsCrackNames(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                             DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                                             1, &bstrX500DN,  &pdnr);

                    if ( (NO_ERROR == dwres) && (pdnr->cItems == 1))
                    {
                        // try and get the NETBIOS name for the domain
                        dwres = DsGetDcName(NULL, pdnr->rItems->pDomain, NULL, NULL, DS_IS_DNS_NAME|DS_RETURN_FLAT_NAME, &pdci);
                        if (NO_ERROR == dwres)
                        {
                            if ( pbstrCompDomain )
                                *pbstrCompDomain = SysAllocString(pdci->DomainName);

                            hres = ((pbstrCompDomain && !*pbstrCompDomain)) ? E_OUTOFMEMORY:S_OK;
                        }
                        else
                        {   
                            hres = E_FAIL;                  // no flat name for the domain
                        }

                        DsFreeNameResult(pdnr);
                    }
                    else
                    {
                        hres = E_FAIL;                      // failed to find the computer in the domain
                    }

                    SysFreeString(bstrX500DN);
                }
            }
            padp->Release();
        }
    }

    SHCoUninitialize(hrInit);
    return hres;
}


// This is the phonebook callback, it is used to notify the book of the user name, domain
// and password to be used in this connection.  It is also used to receive changes made by
// the user.

VOID WINAPI _PhoneBkCB(ULONG_PTR dwCallBkID, DWORD dwEvent, LPWSTR pszEntry, void *pEventArgs)
{
    RASNOUSER *pInfo = (RASNOUSER *)pEventArgs;
    CREDINFO *pci = (CREDINFO *)dwCallBkID;

    switch ( dwEvent )
    {
        case RASPBDEVENT_NoUser:
        {
            // 
            // we are about to initialize the phonebook dialog, therefore
            // lets pass through our credential information.
            //

            pInfo->dwSize = SIZEOF(RASNOUSER);
            pInfo->dwFlags = 0;
            pInfo->dwTimeoutMs = 0;
            StrCpyN(pInfo->szUserName, pci->pszUser, ARRAYSIZE(pInfo->szUserName));
            StrCpyN(pInfo->szDomain, pci->pszDomain, ARRAYSIZE(pInfo->szDomain));
            StrCpyN(pInfo->szPassword, pci->pszPassword, ARRAYSIZE(pInfo->szPassword));

            break;     
        }

        case RASPBDEVENT_NoUserEdit:
        {
            //
            // the user has changed the credetials we supplied for the
            // login, therefore we must update them in our copy accordingly.
            //

            if ( pInfo->szUserName[0] )
                StrCpyN(pci->pszUser, pInfo->szUserName, pci->cchUser);

            if ( pInfo->szPassword[0] )
                StrCpyN(pci->pszPassword, pInfo->szPassword, pci->cchPassword);

            if ( pInfo->szDomain[0] )
                StrCpyN(pci->pszDomain, pInfo->szDomain, pci->cchDomain);

            break;
        }
    }
}


// modify the RAS key for allowing phone book edits - so we can create a connectiod
// during setup.

BOOL SetAllowKey(DWORD dwNewValue, DWORD* pdwOldValue)
{
    BOOL fValueWasSet = FALSE;

    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_USERS,  TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook"), NULL,
                                            TEXT(""), REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkey, NULL))
    {
        const LPCTSTR pcszAllowEdit = TEXT("AllowLogonPhonebookEdits");

        if (NULL != pdwOldValue)
        {
            DWORD dwType = 0;
            DWORD cbSize = sizeof(DWORD);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, pcszAllowEdit, NULL, &dwType, (LPBYTE)pdwOldValue, &cbSize))
            {
                *pdwOldValue = 0;                   // Assume FALSE if the value doesn't exist
            }
        }

        // Set the new value
        if (ERROR_SUCCESS == RegSetValueEx(hkey, pcszAllowEdit, NULL, REG_DWORD, (CONST BYTE*) &dwNewValue, sizeof (DWORD)))
        {
            fValueWasSet = TRUE;
        }

        RegCloseKey(hkey);
    }

    return fValueWasSet;
}

//
// The user is trying to advance from the user info tab in the Wizard.  Therefore
// we must take the information they have entered and:
//
//  - log in using RAS (if ras is selected)
//  - try and locate a computer object
//  - if we find a computer object then allow them to use it
//  
// If we failed to find a computer object, or the user found one and decided not
// to use then we advance them to the 'computer info' page in the wizard.  If
// they decide to use it then we must apply it and advance to permissions.
//

void _DoUserInfoNext(HWND hwnd)
{
    HRESULT hres;
    WCHAR szPassword[MAX_PASSWORD + 1];
    BSTR bstrCompDomain = NULL;
    LONG idNextPage = -1;
    TCHAR szSearchDomain[MAX_DOMAIN + 1]; *szSearchDomain = 0;
    BOOL fTranslateNameTriedAndFailed = FALSE;

    // fSetAllowKey - Have we set the regval that says "allow connectiod creation before logon?"
    BOOL fSetAllowKey = FALSE;
    DWORD dwPreviousAllowValue = 0;

    //
    // read the user, domain and password from the dialog.  then 
    // lets search for the computer object that matches the currently
    // configure computer name.
    //

    FetchText(hwnd, IDC_USER, g_szUser, ARRAYSIZE(g_szUser));
    FetchText(hwnd, IDC_DOMAIN, g_szDomain, ARRAYSIZE(g_szDomain));
    FetchText(hwnd, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));

    // Handle possible UPN case
    if (StrChr(g_szUser, TEXT('@')))
    {
        *g_szDomain = 0;
    }

    //
    // before we search for the computer object lets check to see if we should be using RAS 
    // to get ourselves onto the network.
    //

    if ( IsDlgButtonChecked(hwnd, IDC_DIALUP) == BST_CHECKED )
    {    
        fSetAllowKey = SetAllowKey(1, &dwPreviousAllowValue);

        // Its ok to use globals here - we want to overwrite them.
        CREDINFO ci = { g_szUser, ARRAYSIZE(g_szUser), 
                        g_szDomain, ARRAYSIZE(g_szDomain),
                        szPassword, ARRAYSIZE(szPassword) };

        RASPBDLG info = { 0 };
        info.dwSize = SIZEOF(info);
        info.hwndOwner = hwnd;
        info.dwFlags = RASPBDFLAG_NoUser;
        info.pCallback = _PhoneBkCB;
        info.dwCallbackId = (ULONG_PTR)&ci;

        if ( !RasPhonebookDlg(NULL, NULL, &info) )
        {
            hres = E_FAIL;              // failed to show the phone book
            goto exit_gracefully;
        }

        // Signal that the wizard has created a RAS connection.
        // Just to be extra paranoid, only do this if the wizard isn't a NETID wizard

        if (g_uWizardIs != NAW_NETID)
        {
            g_fCreatedConnection = TRUE;
        }

        SetDlgItemText(hwnd, IDC_USER, g_szUser);
        SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);
    }

    //
    // now attempt to look up the computer object in the user domain.
    //

    if (StrChr(g_szUser, TEXT('@')))
    {
        TCHAR szDomainUser[MAX_DOMAINUSER + 1];
        ULONG ch = ARRAYSIZE(szDomainUser);
    
        if (TranslateName(g_szUser, NameUserPrincipal, NameSamCompatible, szDomainUser, &ch))
        {
            TCHAR szUser[MAX_USER + 1];
            DomainUserString_GetParts(szDomainUser, szUser, ARRAYSIZE(szUser), szSearchDomain, ARRAYSIZE(szSearchDomain));
        }
        else
        {
            fTranslateNameTriedAndFailed = TRUE;
        }
    }

    if (0 == *szSearchDomain)
        StrCpyN(szSearchDomain, g_szDomain, ARRAYSIZE(szSearchDomain));

    hres = _FindComputerInDomain(g_szUser, g_szDomain, szSearchDomain, szPassword, &bstrCompDomain);
    switch ( hres )
    {
        case S_OK:
        {
            StrCpyN(g_szCompDomain, bstrCompDomain, ARRAYSIZE(g_szCompDomain));     // they want to change the domain

            //
            // we found an object in the DS that matches the current computer name
            // and domain.  show the domain to the user before we join, allowing them
            // to confirm that this is what they want to do.
            //

            if ( IDYES == ShellMessageBox(g_hinst, hwnd,
                                          MAKEINTRESOURCE(IDS_ABOUTTOJOIN), MAKEINTRESOURCE(IDS_USERINFO),
                                          MB_YESNO|MB_ICONQUESTION, 
                                          bstrCompDomain) )
            {
                // 
                // they don't want to modify the parameters so lets do the join.
                //

                idNextPage = IDD_PSW_ADDUSER;
                            
                // Make local copies of the user/domain buffers since we don't want to modify globals
                TCHAR szUser[MAX_DOMAINUSER + 1]; StrCpyN(szUser, g_szUser, ARRAYSIZE(szUser));
                TCHAR szDomain[MAX_DOMAIN + 1]; StrCpyN(szDomain, g_szDomain, ARRAYSIZE(szDomain));
                
                CREDINFO ci = {szUser, ARRAYSIZE(szUser), szDomain, ARRAYSIZE(szDomain), szPassword, ARRAYSIZE(szPassword)};
                if ( FAILED(JoinDomain(hwnd, TRUE, bstrCompDomain, &ci, &g_fRebootOnExit)) )
                {
                    idNextPage = -1;            // don't advance they failed to join
                }                
            }
            else
            {
                idNextPage = IDD_PSW_COMPINFO;
            }

            break;
        }
        
        case HRESULT_FROM_WIN32(ERROR_INVALID_DOMAINNAME):
        {
            // the domain was invalid, so we should really tell them
            ShellMessageBox(g_hinst, hwnd,
                            MAKEINTRESOURCE(IDS_ERR_BADDOMAIN), MAKEINTRESOURCE(IDS_USERINFO),
                            MB_OK|MB_ICONWARNING, g_szDomain);
            break;            

        }

        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
        case HRESULT_FROM_WIN32(ERROR_BAD_USERNAME):
        {
            // this was a credentail failure, so lets tell the user they got something
            // wrong, and let them correct it.
            if (!fTranslateNameTriedAndFailed)
            {
                ShellMessageBox(g_hinst, hwnd,
                                MAKEINTRESOURCE(IDS_ERR_BADPWUSER), MAKEINTRESOURCE(IDS_USERINFO),
                                MB_OK|MB_ICONWARNING);
                break;            
            }
            else
            {
                // Fall through... We tried to translate a UPN but we failed, so
                // we want to act as if we just failed to find a computer account
            }
        }


        default:
        {
            // failed to find a computer that matches the information we have, therefore
            // lets advance to the computer information page.
            idNextPage = IDD_PSW_COMPINFO;
            break;
        }
    }

exit_gracefully:
    
    // Reset the "allow connectiod creation before login" value if appropriate
    if (fSetAllowKey)
        SetAllowKey(dwPreviousAllowValue, NULL);

    SysFreeString(bstrCompDomain);
    SetDlgItemText(hwnd, IDC_PASSWORD, L"");

    WIZARDNEXT(hwnd, idNextPage);                       
}


//
// wizard page to handle the user information (name, password and domain);
// 

BOOL _UserInfoBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;

    // the username/domain fields cannot be blank

    if ( !FetchTextLength(hwnd, IDC_USER) )
        dwButtons &= ~PSWIZB_NEXT;
    
    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_DOMAIN)))
    {
        if ( !FetchTextLength(hwnd, IDC_DOMAIN) )
            dwButtons &= ~PSWIZB_NEXT;
    }

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;
}

INT_PTR CALLBACK _UserInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_DOMAINUSER);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), MAX_PASSWORD);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);

            // if we are launched from the netid tab then lets read the current 
            // user and domain and display accordingly.

            if ( g_uWizardIs == NAW_NETID ) 
            {
                DWORD dwcchUser = ARRAYSIZE(g_szUser);
                DWORD dwcchDomain = ARRAYSIZE(g_szDomain);
                GetCurrentUserAndDomainName(g_szUser, &dwcchUser, g_szDomain, &dwcchDomain);
                ShowWindow(GetDlgItem(hwnd, IDC_DIALUP), SW_HIDE);
            }

            SetDlgItemText(hwnd, IDC_USER, g_szUser);
            SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);

            EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));

            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    return _UserInfoBtnState(hwnd);

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_DOMAININFO);
                    return TRUE;

                case PSN_WIZNEXT:
                    _DoUserInfoNext(hwnd);      // handles setting the next page etc
                    return TRUE;
            }
            break;
        }

        case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
            case EN_CHANGE:
                if ((IDC_USER == LOWORD(wParam)) || (IDC_DOMAIN == LOWORD(wParam)))
                {
                    EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
                    _UserInfoBtnState(hwnd);
                }
            }
            break;
        }
    }

    return FALSE;
}



// modifying the computer name etc

BOOL _IsTCPIPAvailable(void)
{
    BOOL fTCPIPAvailable = FALSE;
    HKEY hk;
    DWORD dwSize = 0;

    // we check to see if the TCP/IP stack is installed and which object it is
    // bound to, this is a string, we don't check the value only that the
    // length is non-zero.

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                       TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),
                                       0x0, 
                                       KEY_QUERY_VALUE, &hk) )
    {
        if ( ERROR_SUCCESS == RegQueryValueEx(hk, TEXT("Export"), 0x0, NULL, NULL, &dwSize) )
        {
            if ( dwSize > 2 )
            {
                fTCPIPAvailable = TRUE;
            }
        }
        RegCloseKey(hk);
    }

    return (fTCPIPAvailable);
}


BOOL _ChangeMachineName(HWND hwnd, WCHAR* pszDomainUser, WCHAR* pszPassword)
{
    BOOL fSuccess = FALSE;

    // the user has entered a short computer name (possibly a DNS host name), retrieve it
    WCHAR szNewShortMachineName[MAX_COMPUTERNAME + 1];
    FetchText(hwnd, IDC_COMPUTERNAME, szNewShortMachineName, ARRAYSIZE(szNewShortMachineName));
    
    // get the current short computer name
    WCHAR szOldShortMachineName[MAX_COMPUTERNAME + 1];
    DWORD cchShort = ARRAYSIZE(szOldShortMachineName);
    BOOL fGotOldName = GetComputerName(szOldShortMachineName, &cchShort);
    if (fGotOldName)
    {
        // did the user change the short computer name?
        if (0 != StrCmpI(szOldShortMachineName, szNewShortMachineName))
        {
            g_fMachineRenamed = TRUE;            
            // if so we need to rename the machine in the domain. For this we need the NetBIOS computer name
            WCHAR szNewNetBIOSMachineName[MAX_COMPUTERNAME + 1];

            // Get the netbios name from the short name
            DWORD cchNetbios = ARRAYSIZE(szNewNetBIOSMachineName);
            DnsHostnameToComputerName(szNewShortMachineName, szNewNetBIOSMachineName, &cchNetbios);

            // rename the computer in the domain
            NET_API_STATUS rename_status = ::NetRenameMachineInDomain(0, szNewNetBIOSMachineName,
                pszDomainUser, pszPassword, NETSETUP_ACCT_CREATE);

            // if the domain rename succeeded
            BOOL fDomainRenameSucceeded = (rename_status == ERROR_SUCCESS);
            if (fDomainRenameSucceeded)
            {
                // set the new short name locally
                BOOL fLocalRenameSucceeded;

                // do we have TCPIP?
                if (_IsTCPIPAvailable())
                {
                    // We can set the name using the short name
                    fLocalRenameSucceeded = ::SetComputerNameEx(ComputerNamePhysicalDnsHostname,
                        szNewShortMachineName);
                }
                else
                {
                    // We need to set using the netbios name - kind of a hack
                    fLocalRenameSucceeded = ::SetComputerNameEx(ComputerNamePhysicalNetBIOS,
                        szNewNetBIOSMachineName);
                }

                fSuccess = fLocalRenameSucceeded;
            }

			// Handle errors that may have occured changing the name
            if (rename_status != ERROR_SUCCESS)
            {
                TCHAR szMessage[512];

                switch (rename_status)
                {
                case NERR_UserExists:
                    {
                        // We don't really mean "user exists" in this case, we mean
                        // "computer name exists", so load that reason string
                        LoadString(g_hinst, IDS_COMPNAME_EXISTS, szMessage, ARRAYSIZE(szMessage));
                    }
                    break;
                default:
                    {
                        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) rename_status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));
                    }
                    break;
                }

                // Note that this is not a hard error, so we use the information icon
                ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_NAW_NAMECHANGE_ERROR, MB_OK|MB_ICONINFORMATION, szMessage);
            }
        }
		else
		{
			// Computer name hasn't changed - just return success
			fSuccess = TRUE;
		}
    }

    return(fSuccess);
}


// handle processing the changes

HRESULT _ChangeNameAndJoin(HWND hwnd)
{
    WCHAR szDomain[MAX_DOMAIN + 1];
    WCHAR szUser[MAX_DOMAINUSER + 1]; szUser[0] = 0;
    WCHAR szPassword[MAX_PASSWORD + 1]; szPassword[0] = 0;

    BOOL fNameChangeSucceeded = FALSE;
    FetchText(hwnd, IDC_DOMAIN, szDomain, ARRAYSIZE(szDomain));

    // try to join the new domain
    
    TCHAR szUserDomain[MAX_DOMAIN + 1]; *szUserDomain = 0;
    CREDINFO ci = { szUser, ARRAYSIZE(szUser), szUserDomain, ARRAYSIZE(szUserDomain), szPassword, ARRAYSIZE(szPassword) };

    HRESULT hres = JoinDomain(hwnd, TRUE, szDomain, &ci, &g_fRebootOnExit);
    if (SUCCEEDED(hres))
    {
#ifndef DONT_JOIN
        LPTSTR pszUser = szUser[0] ? szUser : NULL;
        LPTSTR pszPassword = szPassword[0] ?szPassword : NULL;
        fNameChangeSucceeded = _ChangeMachineName(hwnd, pszUser, pszPassword);
#endif
    }

    return hres;;
}


// ensure the wizard buttons reflect what we can do

BOOL _CompInfoBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;

    if ( !FetchTextLength(hwnd, IDC_COMPUTERNAME) )
        dwButtons &= ~PSWIZB_NEXT;
    if ( !FetchTextLength(hwnd, IDC_DOMAIN) )
        dwButtons &= ~PSWIZB_NEXT;

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;
}


BOOL _ValidateMachineName(HWND hwnd)
{
    BOOL fNameInUse = FALSE;
    NET_API_STATUS name_status = NERR_Success;

    // the user has entered a short computer name (possibly a DNS host name), retrieve it
    WCHAR szNewShortMachineName[MAX_COMPUTERNAME + 1];
    FetchText(hwnd, IDC_COMPUTERNAME, szNewShortMachineName, ARRAYSIZE(szNewShortMachineName));
    
    // get the current short computer name
    WCHAR szOldShortMachineName[MAX_COMPUTERNAME + 1];
    DWORD cchShort = ARRAYSIZE(szOldShortMachineName);
    BOOL fGotOldName = GetComputerName(szOldShortMachineName, &cchShort);
    if (fGotOldName)
    {
        // did the user change the short computer name?
        if (0 != StrCmpI(szOldShortMachineName, szNewShortMachineName))
        {
            // first we need to check the flat, netbios name
            WCHAR szNewNetBIOSMachineName[MAX_COMPUTERNAME + 1];

            // Get the netbios name from the short name
            DWORD cchNetbios = ARRAYSIZE(szNewNetBIOSMachineName);
            DnsHostnameToComputerName(szNewShortMachineName, szNewNetBIOSMachineName, &cchNetbios);
            
            name_status = NetValidateName(NULL, szNewNetBIOSMachineName, NULL, NULL, NetSetupMachine);
        }
    }

    if (name_status != NERR_Success)
    {
        TCHAR szMessage[512];

        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) name_status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

        ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_MACHINENAMEINUSE, MB_ICONERROR | MB_OK, szMessage);
    }

    return (name_status == NERR_Success);
}


INT_PTR CALLBACK _CompInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
            Edit_LimitText(GetDlgItem(hwnd, IDC_COMPUTERNAME), MAX_COMPUTERNAME);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    WCHAR szCompName[MAX_PATH + 1], szMessage[MAX_PATH+MAX_DOMAIN];
                    DWORD dwBuffer = ARRAYSIZE(szCompName);

                    // fill in the user domain

                    FormatMessageString(IDS_COMPNOTFOUND, szMessage, ARRAYSIZE(szMessage), g_szDomain);
                    SetDlgItemText(hwnd, IDC_COMPINFO, szMessage);

                    // default the computer name to something sensible

                    GetComputerName(szCompName, &dwBuffer);

                    SetDlgItemText(hwnd, IDC_COMPUTERNAME, szCompName);
                    SetDlgItemText(hwnd, IDC_DOMAIN, g_szCompDomain);

                    return _CompInfoBtnState(hwnd);
                }

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_USERINFO);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    INT idNextPage = -1;

                    if (_ValidateMachineName(hwnd))
                    {
                        if (SUCCEEDED(_ChangeNameAndJoin(hwnd)))
                        {
                            if (!g_fMachineRenamed)
                            {
                                idNextPage = IDD_PSW_ADDUSER;
                            }
                            else
                            {
                                idNextPage = IDD_PSW_DONE;
                            }
                        }
                    }

                    WIZARDNEXT(hwnd, idNextPage);
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if ( HIWORD(wParam) == EN_CHANGE )
                return _CompInfoBtnState(hwnd);

            break;
        }
    }

    return FALSE;
}




// changing the group membership for the user, adds a domain user to a local group on the machine
// eg. NET LOCALGROUP /ADD

BOOL _AddUserToGroup(HWND hwnd, LPCTSTR pszLocalGroup, LPCWSTR pszUser, LPCWSTR pszDomain)
{
#ifndef DONT_JOIN
    BOOL fResult = FALSE;
    NET_API_STATUS nas;
    LOCALGROUP_MEMBERS_INFO_3 lgm;
    TCHAR szDomainUser[MAX_DOMAINUSER + 1];
    CWaitCursor cur;

    MakeDomainUserString(pszDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));
    lgm.lgrmi3_domainandname = szDomainUser;

    nas = NetLocalGroupAddMembers(NULL, pszLocalGroup, 3, (BYTE *)&lgm, 1);
    switch ( nas )
    {
        // Success conditions
        case NERR_Success:
        case ERROR_MEMBER_IN_GROUP:
        case ERROR_MEMBER_IN_ALIAS:
        {
            fResult = TRUE;
            break;
        }
        case ERROR_INVALID_MEMBER:
        {
            DisplayFormatMessage(hwnd, 
                                 IDS_PERMISSIONS, IDS_ERR_BADUSER,                            
                                 MB_OK|MB_ICONWARNING, pszUser, pszDomain);
                        
            break;
        }

        case ERROR_NO_SUCH_MEMBER:
        {
            DisplayFormatMessage(hwnd,
                                 IDS_PERMISSIONS, IDS_ERR_NOSUCHUSER,
                                 MB_OK|MB_ICONWARNING, pszUser, pszDomain);
            break;
        }
        default:
        {
            TCHAR szMessage[512];

            if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) nas, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

            ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_ERR_ADDUSER, MB_OK|MB_ICONERROR, szMessage);

            fResult = FALSE;

            break;
        }
    }

    return(fResult);
#else
    return TRUE;
#endif
}



// ensure the wizard buttons reflect what we can do

BOOL _PermissionsBtnState(HWND hwnd)
{
    // Next is always valid
    DWORD dwButtons = PSWIZB_NEXT | PSWIZB_BACK;

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;              
}

// BtnState function for _AddUserDlgProc

BOOL _AddUserBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
    BOOL fEnableEdits;

    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_ADDUSER)))
    {
        // Enable the user and domain edits
        fEnableEdits = TRUE;

        if ( !FetchTextLength(hwnd, IDC_USER) )
            dwButtons &= ~PSWIZB_NEXT;
    }
    else
    {
        // Disable user and domain edits
        fEnableEdits = FALSE;
    }

    EnableWindow(GetDlgItem(hwnd, IDC_USER), fEnableEdits);

    if (fEnableEdits)
    {
        EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_DOMAIN), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_USER_STATIC), fEnableEdits);
    EnableWindow(GetDlgItem(hwnd, IDC_DOMAIN_STATIC), fEnableEdits);
    SetWizardButtons(hwnd, dwButtons);
    return TRUE;              
}

INT_PTR CALLBACK _AddUserDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_DOMAINUSER);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
            Button_SetCheck(GetDlgItem(hwnd, IDC_ADDUSER), BST_CHECKED);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    SetDlgItemText(hwnd, IDC_USER, g_szUser);
                    SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);

                    _AddUserBtnState(hwnd);
                    return TRUE;
                }
                case PSN_WIZBACK:
                {
                    if ( g_uWizardIs == NAW_PSDOMAINJOINED )
                        WIZARDNEXT(hwnd, IDD_PSW_WELCOME);
                    else
                        WIZARDNEXT(hwnd, IDD_PSW_USERINFO);

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_ADDUSER)))
                    {
                        FetchText(hwnd, IDC_USER, g_szUser, ARRAYSIZE(g_szUser));
                        FetchText(hwnd, IDC_DOMAIN, g_szDomain, ARRAYSIZE(g_szDomain));

                        if (StrChr(g_szUser, TEXT('@')))
                        {
                            *g_szDomain = 0;
                        }

                        WIZARDNEXT(hwnd, IDD_PSW_PERMISSIONS);
                    }
                    else
                    {
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }

                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            switch ( HIWORD(wParam) )
            {            
                case EN_CHANGE:
                case BN_CLICKED:
                    _AddUserBtnState(hwnd);
                    break;
            }
            break;
        }
    }

    return FALSE;
}


//
// DlgProc for the permissions page.
//

INT_PTR CALLBACK _PermissionsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Handle local-group related messages
    g_pGroupPageBase->HandleGroupMessage(hwnd, uMsg, wParam, lParam);

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    // Set the "What level of access do you want to grant %S" message

                    TCHAR szMessage[256];
                    TCHAR szDisplayName[MAX_DOMAINUSER];
    
                    // Make a domain/user string
                    MakeDomainUserString(g_szDomain, g_szUser, szDisplayName, ARRAYSIZE(szDisplayName));

                    FormatMessageString(IDS_WHATACCESS_FORMAT, szMessage, ARRAYSIZE(szMessage), szDisplayName);
                    SetDlgItemText(hwnd, IDC_WHATACCESS, szMessage);
                    
                    return _PermissionsBtnState(hwnd);
                }
                case PSN_WIZBACK:
                {
                    WIZARDNEXT(hwnd, IDD_PSW_ADDUSER);

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    // Get the local group here! TODO
                    TCHAR szGroup[MAX_GROUP + 1];

                    CUserInfo::GROUPPSEUDONYM gs;
                    g_pGroupPageBase->GetSelectedGroup(hwnd, szGroup, ARRAYSIZE(szGroup), &gs);

                    if ( !_AddUserToGroup(hwnd, szGroup, g_szUser, g_szDomain) )
                    {
                        WIZARDNEXT(hwnd, -1);
                    }
                    else
                    {
                        SetDefAccount(g_szUser, g_szDomain);
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }

                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            switch ( HIWORD(wParam) )
            {            
                case EN_CHANGE:
                    return _PermissionsBtnState(hwnd);
            }
            break;
        }
    }

    return FALSE;
}


// pages that make up the wizard

#define WIZDLG(name, dlgproc, dwFlags)   \
            { MAKEINTRESOURCE(IDD_PSW_##name##), dlgproc, MAKEINTRESOURCE(IDS_##name##), MAKEINTRESOURCE(IDS_##name##_SUB), dwFlags }

WIZPAGE pages[] =
{    
    WIZDLG(WELCOME,     _IntroDlgProc,       PSP_HIDEHEADER),
    WIZDLG(HOWUSE,      _HowUseDlgProc,      0),
    WIZDLG(WHICHNET,    _WhichNetDlgProc,    0),
    WIZDLG(DOMAININFO,  _DomainInfoDlgProc,  0),
    WIZDLG(USERINFO,    _UserInfoDlgProc,    0),
    WIZDLG(COMPINFO,    _CompInfoDlgProc,    0),
    WIZDLG(ADDUSER,     _AddUserDlgProc,     0),
    WIZDLG(PERMISSIONS, _PermissionsDlgProc, 0),
    WIZDLG(WORKGROUP,   _WorkgroupDlgProc,   0),
    WIZDLG(DONE,        _DoneDlgProc,        PSP_HIDEHEADER), 
};

STDAPI NetAccessWizard(HWND hwnd, UINT uType, BOOL *pfReboot)
{
    // init comctrl

    INITCOMMONCONTROLSEX iccex = { 0 };
    iccex.dwSize = sizeof (iccex);
    iccex.dwICC = ICC_LISTVIEW_CLASSES;

    InitCommonControlsEx(&iccex);

    switch (uType)
    {
        case NAW_NETID:
            break;

        case NAW_PSDOMAINJOINFAILED:
            g_dwWhichNet = IDC_NONE;
            g_uWizardIs = uType;
            break;

        case NAW_PSDOMAINJOINED:
            g_dwWhichNet = IDC_DOMAIN;
            g_uWizardIs = uType;
            break;

        default:
            return E_INVALIDARG;
    }

    // create the pages

    HPROPSHEETPAGE rghpage[ARRAYSIZE(pages)];
    INT cPages = 0;
    for (cPages = 0 ; cPages < ARRAYSIZE(pages) ; cPages++)
    {                           
        PROPSHEETPAGE psp = { 0 };
        WCHAR szBuffer[MAX_PATH] = { 0 };

        psp.dwSize = SIZEOF(PROPSHEETPAGE);
        psp.hInstance = g_hinst;
        psp.lParam = cPages;
        psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | 
                            PSP_USEHEADERSUBTITLE | pages[cPages].dwFlags;
        psp.pszTemplate = pages[cPages].idPage;
        psp.pfnDlgProc = pages[cPages].pDlgProc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_NETWIZCAPTION);
        psp.pszHeaderTitle = pages[cPages].pHeading;
        psp.pszHeaderSubTitle = pages[cPages].pSubHeading;

        rghpage[cPages] = CreatePropertySheetPage(&psp);
    }

    // display the wizard

    PROPSHEETHEADER psh = { 0 };
    psh.dwSize = SIZEOF(PROPSHEETHEADER);
    psh.hwndParent = hwnd;
    psh.hInstance = g_hinst;
    psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | 
                            PSH_STRETCHWATERMARK | PSH_HEADER | PSH_USECALLBACK;
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_PSW_BANNER);
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_PSW_WATERMARK);
    psh.nPages = cPages;
    psh.phpage = rghpage;
    psh.pfnCallback = _PropSheetCB;

    // Create the global CGroupPageBase object if necessary
    CGroupInfoList grouplist;
    if (SUCCEEDED(grouplist.Initialize()))
    {
        g_pGroupPageBase = new CGroupPageBase(NULL, &grouplist);

        if (NULL != g_pGroupPageBase)
        {
            PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_PSW));
            delete g_pGroupPageBase;
        }
    }

    //
    // Hang up the all RAS connections if the wizard created one. It is assumed that no non-wizard connections will
    // exist at this time. 90% of the time, they've just changed their domain membership anyway to they will
    // be just about to reboot. Hanging up all connections MAY cause trouble if: There were existing connections
    // before the pre-logon wizard started AND the user cancelled after making connections with the wizard but before
    // changing their domain. There are no situations where this currently happens.
    //

    if (g_fCreatedConnection)
    {
        RASCONN* prgrasconn = (RASCONN*) LocalAlloc(0, sizeof(RASCONN));

        if (NULL != prgrasconn)
        {
            prgrasconn[0].dwSize = sizeof(RASCONN);

            DWORD cb = sizeof(RASCONN);
            DWORD nConn = 0;

            DWORD dwSuccess = RasEnumConnections(prgrasconn, &cb, &nConn);

            if (ERROR_BUFFER_TOO_SMALL == dwSuccess)
            {
                LocalFree(prgrasconn);
                prgrasconn = (RASCONN*) LocalAlloc(0, cb);

                if (NULL != prgrasconn)
                {
                    prgrasconn[0].dwSize = sizeof(RASCONN);
                    dwSuccess = RasEnumConnections(prgrasconn, &cb, &nConn);
                }
            }

            if (0 == dwSuccess)
            {
                // Make sure we have one and only one connection before hanging up
                for (DWORD i = 0; i < nConn; i ++)
                {
                    RasHangUp(prgrasconn[i].hrasconn);
                }
            }

            LocalFree(prgrasconn);
        }
    }

    //
    // restart the machine if we need to, eg: the domain changed
    //

    if (pfReboot)
        *pfReboot = g_fRebootOnExit;

    //
    // if this is coming from setup, then lets display the message
    //

    if (g_fRebootOnExit && !g_fShownLastPage && (g_uWizardIs != NAW_NETID))
    {
        ShellMessageBox(g_hinst, 
                        hwnd,
                        MAKEINTRESOURCE(IDS_RESTARTREQUIRED), MAKEINTRESOURCE(IDS_NETWIZCAPTION),
                        MB_OK);        
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\password.h ===
#ifndef PASSWORD_H_INCLUDED
#define PASSWORD_H_INCLUDED


// password dialog (used for users cpl)

class CPasswordDialog: public CDialog
{
public:
    CPasswordDialog(TCHAR* pszResourceName, TCHAR* pszDomainUser, DWORD cchDomainUser, 
        TCHAR* pszPassword, DWORD cchPassword, DWORD dwError): 
        m_pszResourceName(pszResourceName),
        m_pszDomainUser(pszDomainUser),
        m_cchDomainUser(cchDomainUser),
        m_pszPassword(pszPassword),
        m_cchPassword(cchPassword),
        m_dwError(dwError)
        {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    // Data
    TCHAR* m_pszResourceName;

    TCHAR* m_pszDomainUser;
    DWORD m_cchDomainUser;

    TCHAR* m_pszPassword;
    DWORD m_cchPassword;

    DWORD m_dwError;
};


// base class containing common stuff for the password prop page and set password dialog

class CPasswordPageBase
{
public:
    CPasswordPageBase(CUserInfo* pUserInfo): m_pUserInfo(pUserInfo) {}

protected:
    // Helpers
    BOOL DoPasswordsMatch(HWND hwnd);

protected:
    // Data
    CUserInfo* m_pUserInfo;
};

class CPasswordWizardPage: public CPropertyPage, public CPasswordPageBase
{
public:
    CPasswordWizardPage(CUserInfo* pUserInfo): CPasswordPageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};

class CChangePasswordDlg: public CDialog, public CPasswordPageBase
{
public:
    CChangePasswordDlg(CUserInfo* pUserInfo): CPasswordPageBase(pUserInfo) {}

    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};



#endif //!PASSWORD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubhelp.cpp ===
#include "stdafx.h"
#include "shimgdata.h"
#include "shui.h"
#include "netplace.h"
#include <Ntquery.h>
#include <shellp.h>
#include "pubwiz.h"
#include "gdiplus\gdiplus.h"
#include "imgprop.h"
#pragma hdrstop


// handle the provider list XML document, reading properties etc.

HRESULT GetStrFromElement(IXMLDOMNode *pdn, LPCTSTR pszElementName, LPTSTR pszBuffer, int cch)
{
    HRESULT hr;

    IXMLDOMNode *pdnElement;
    if (pszElementName)
        hr = pdn->selectSingleNode((BSTR)pszElementName, &pdnElement);
    else
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnElement));

    if (SUCCEEDED(hr) && (hr == S_OK))
    {
        VARIANT var = {VT_BSTR};
        hr = pdnElement->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdnElement->Release();
    }
    return (hr == S_FALSE) ? E_FAIL:hr;
}

HRESULT GetStrFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPTSTR pszBuffer, int cch)
{
    IXMLDOMElement *pdel;
    HRESULT hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
    if (SUCCEEDED(hr))
    {
        VARIANT var = {VT_BSTR};
        hr = pdel->getAttribute((BSTR)pszAttribute, &var);
        if (S_OK == hr)
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdel->Release();
    }
    return (hr == S_FALSE) ? E_FAIL:hr;
}

HRESULT GetIntFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, int *piValue)
{
    TCHAR szBuffer[64];
    HRESULT hr = GetStrFromAttribute(pdn, pszAttribute, szBuffer, ARRAYSIZE(szBuffer));
    if (SUCCEEDED(hr))
    {
        hr = StrToIntEx(szBuffer, STIF_SUPPORT_HEX, piValue) ? S_OK:E_FAIL;
    }
    return hr;
}

HRESULT CreateElement(IXMLDOMDocument *pdoc, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelResult)
{
    IXMLDOMElement *pdel;
    HRESULT hr = pdoc->createElement((BSTR)pszName, &pdel);
    if (SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = NODE_TEXT;

        IXMLDOMNode *pdnText;
        hr = pdoc->createNode(var, NULL, NULL, &pdnText);
        if (SUCCEEDED(hr))
        {
            if (pvar)
                hr = pdnText->put_nodeTypedValue(*pvar);

            if (SUCCEEDED(hr))
            {
                IXMLDOMNode *pdn;
                hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdn));
                if (SUCCEEDED(hr))
                {
                    hr = pdn->appendChild(pdnText, NULL);
                    pdn->Release();
                }
            }
            pdnText->Release();
        }

        hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMElement, ppdelResult));
        pdel->Release();
    }
    return hr;
}

HRESULT CreateAndAppendElement(IXMLDOMDocument *pdoc, IXMLDOMNode *pdnParent, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelOut)
{
    IXMLDOMElement *pdel;
    HRESULT hr = CreateElement(pdoc, pszName, pvar, &pdel);
    if (SUCCEEDED(hr))
    {
        hr = pdnParent->appendChild(pdel, NULL);
        if (SUCCEEDED(hr) && ppdelOut)
        {
            hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMElement, ppdelOut));
        }
        pdel->Release();
    }
    return hr;
}

void SpewXML(IUnknown *punk)
{
    IXMLDOMNode *pdn;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdn));
    if (SUCCEEDED(hr))
    {
        BSTR bstrXML;
        hr = pdn->get_xml(&bstrXML);
        if (SUCCEEDED(hr))
        {
            MessageBox(NULL, bstrXML, NULL, MB_OK);
            SysFreeString(bstrXML);
        }
        pdn->Release();
    }
}


// this helper is here for compatibility with previous manifest formats, first look for
// a HREF attribute, if its not defined then look for the body text to be the URL.

HRESULT GetURLFromElement(IXMLDOMNode *pdn, LPCTSTR pszElement, LPTSTR pszBuffer, int cch)
{
    IXMLDOMNode *pdnElement;
    HRESULT hr = pdn->selectSingleNode((BSTR)pszElement, &pdnElement);
    if (hr == S_OK)
    {
        hr = GetStrFromAttribute(pdnElement, L"href", pszBuffer, cch);
        pdnElement->Release();
    }

    if (hr != S_OK)
        hr = GetStrFromElement(pdn, pszElement, pszBuffer, cch);

    return hr;
}


// set an attribute to a string

HRESULT SetAttributeFromStr(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPCTSTR pszValue)
{
    VARIANT var;
    HRESULT hr = InitVariantFromStr(&var, pszValue);
    if (SUCCEEDED(hr))
    {
        IXMLDOMElement *pdel;
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
        if (SUCCEEDED(hr))
        {
            hr = pdel->setAttribute((BSTR)pszAttribute, var);
            pdel->Release();
        }
        VariantClear(&var);
    }
    return hr;
}


// wrapper for WNetGetConnection to fix drive root case.

DWORD SHWNetGetConnection(LPCTSTR lpLocalName, LPCTSTR lpRemoteName, LPDWORD lpnLength)
{
    WCHAR szLocalName[3];

    // Kludge allert, don't pass c:\ to API, instead only pass C:
    if (lpLocalName && lstrlen(lpLocalName) > 2)
    {
        szLocalName[0] = lpLocalName[0];
        szLocalName[1] = L':';
        szLocalName[2] = 0;
        lpLocalName = szLocalName;
    }

    return WNetGetConnection(lpLocalName, (LPWSTR)lpRemoteName, lpnLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\password.cpp ===
#include "stdafx.h"
#include "password.h"
#pragma hdrstop


// password prompt dialog

INT_PTR CPasswordDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    default:
        break;
    }

    return FALSE;
}

BOOL CPasswordDialog::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szMessage[MAX_PATH + MAX_DOMAIN + MAX_USER + 256 + 2]; szMessage[0] = 0;

    //
    // Limit the size of the edit controls + Set username/password
    //
    HWND hwndCredential = GetDlgItem(hwnd, IDC_CREDENTIALS);
    SendMessage(hwndCredential, CRM_SETUSERNAME, NULL, (LPARAM) m_pszDomainUser);
    SendMessage(hwndCredential, CRM_SETPASSWORD, NULL, (LPARAM) m_pszPassword);
    SendMessage(hwndCredential, CRM_SETUSERNAMEMAX, m_cchDomainUser - 1, NULL);
    SendMessage(hwndCredential, CRM_SETPASSWORDMAX, m_cchPassword - 1, NULL);
    
    // We may need to generate a user name here to use if no user name was
    // passed in
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    LPTSTR pszUserNameToUse;

    if (*m_pszDomainUser)
    {
        pszUserNameToUse = m_pszDomainUser;
    }
    else
    {
        szDomainUser[0] = 0;

        TCHAR szUser[MAX_USER + 1];
        DWORD cchUser = ARRAYSIZE(szUser);
        TCHAR szDomain[MAX_DOMAIN + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);

        GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain);
        
        MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));
        pszUserNameToUse = szDomainUser;
    }

    FormatMessageString(IDS_PWD_STATIC, szMessage, ARRAYSIZE(szMessage), m_pszResourceName, pszUserNameToUse);
    SetDlgItemText(hwnd, IDC_MESSAGE, szMessage);

    // Now set the error message description

    TCHAR szError[512];
    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, m_dwError, 0, szError, ARRAYSIZE(szError), NULL))
    {
        LoadString(g_hinst, IDS_ERR_UNEXPECTED, szError, ARRAYSIZE(szError));
    }
    SetDlgItemText(hwnd, IDC_ERROR, szError);

    return TRUE;
}

BOOL CPasswordDialog::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id) 
    {
    case IDOK:
        {
            // Read the username and password from the dialog.
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETUSERNAME, (WPARAM) m_cchDomainUser - 1, (LPARAM) m_pszDomainUser);
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETPASSWORD, (WPARAM) m_cchPassword - 1, (LPARAM) m_pszPassword);
        }
        // Fall through
    case IDCANCEL:
        EndDialog(hwnd, id);
        return TRUE;
    }

    return FALSE;
}


// page implementation - used for wizards etc

BOOL CPasswordPageBase::DoPasswordsMatch(HWND hwnd)
{
    TCHAR szConfirmPW[MAX_PASSWORD + 1];
    TCHAR szPassword[MAX_PASSWORD + 1];

    GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
    GetWindowText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), szConfirmPW,ARRAYSIZE(szConfirmPW));

    BOOL fMatch = (StrCmp(szPassword, szConfirmPW) == 0);
    if (!fMatch)
    {
        // Display a message saying the passwords don't match
        DisplayFormatMessage(hwnd, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_ERR_PWDNOMATCH,  MB_OK | MB_ICONERROR);
    }

    return fMatch;
}

INT_PTR CPasswordWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }

    return FALSE;
}

BOOL CPasswordWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    Edit_LimitText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    return TRUE;
}

BOOL CPasswordWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            // Verify that the passwords match
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), m_pUserInfo->m_szPasswordBuffer,
                                    ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                // Hide the password
                m_pUserInfo->HidePassword();
                EndDialog(hwnd, IDOK);
            }
            else
            {
                m_pUserInfo->ZeroPassword();
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        
        default:
            break;
    }

    return TRUE;
}

BOOL CPasswordWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT | PSWIZB_BACK);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;

        case PSN_WIZNEXT:
        {
            // Save the data the user has entered
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), 
                                         m_pUserInfo->m_szPasswordBuffer, 
                                          ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                // Hide the password
                m_pUserInfo->HidePassword();
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            }
            else
            {
                m_pUserInfo->ZeroPassword();
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            return TRUE;
        }
    }
    return FALSE;
}



INT_PTR CChangePasswordDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CChangePasswordDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    Edit_LimitText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    return TRUE;
}

BOOL CChangePasswordDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), m_pUserInfo->m_szPasswordBuffer,
                                            ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                m_pUserInfo->HidePassword();                // Hide the password

                // Update the password
                BOOL fBadPasswordFormat;
                if (SUCCEEDED(m_pUserInfo->UpdatePassword(&fBadPasswordFormat)))
                {
                    EndDialog(hwnd, IDOK);
                }
                else
                {
                    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
                    MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername, 
                                            szDomainUser, ARRAYSIZE(szDomainUser));

                    if (fBadPasswordFormat)
                    {
                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                            IDS_USR_UPDATE_PASSWORD_TOOSHORT_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);
                    }
                    else
                    {
                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                            IDS_USR_UPDATE_PASSWORD_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);
                    }
                }
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        
        default:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubcopy.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "pubwiz.h"
#pragma hdrstop


// IEnumShellItems - used to expose the transfer list as a set of IShellItems

class CTransferItemEnum : public IEnumShellItems
{
public:
    CTransferItemEnum(LPCTSTR pszPath, IStorage *pstg, CDPA<TRANSFERITEM> *_pdpaItems);
    ~CTransferItemEnum();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next)(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt)
        { return S_OK; }
    STDMETHOD(Reset)()
        { _iItem = 0; return S_OK; }
    STDMETHOD(Clone)(IEnumShellItems **ppenum)
        { return S_OK; }

private:
    long _cRef;

    TCHAR _szPath[MAX_PATH];
    int _cchPath;
    IStorage *_pstg;
    CDPA<TRANSFERITEM> *_pdpaItems;

    int _iItem;

    BOOL _GetNextItem(TRANSFERITEM **ppti);
    LPTSTR _GetNextComponent(LPTSTR pszPath);
};


// A IShellItem that represents an IStorage to the copy engine - limited functionality

class CTransferStgItem : public IShellItem
{
public:
    CTransferStgItem(LPCTSTR pszPath, int cchName, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems);
    ~CTransferStgItem();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IShellItem
    STDMETHODIMP BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv);
    STDMETHODIMP GetParent(IShellItem **ppsi)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName);
    STDMETHODIMP GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags);        
    STDMETHODIMP Compare(IShellItem *psi, SICHINTF hint, int *piOrder)
        { return E_NOTIMPL; }

private:
    long _cRef;

    TCHAR _szPath[MAX_PATH];
    IStorage *_pstg;
    CDPA<TRANSFERITEM> *_pdpaItems;
};


// IShellItem implementation that will return a storage to anybody
// querying it.  We generate the in folder name from the path
// we are initialized from, and the attributes are fixed for the items.

CTransferStgItem::CTransferStgItem(LPCTSTR pszPath, int cchName, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems) :
    _cRef(1), _pstg(pstg), _pdpaItems(pdpaItems)
{
    StrCpyN(_szPath, pszPath, (int)min(ARRAYSIZE(_szPath), cchName));
    _pstg->AddRef();
}

CTransferStgItem::~CTransferStgItem()
{
    _pstg->Release();
}

ULONG CTransferStgItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferStgItem::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CTransferStgItem::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTransferStgItem, IShellItem),    // IID_IShellItem
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CTransferStgItem::BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv)
{
    HRESULT hr = E_UNEXPECTED;
    if (rguidHandler == BHID_StorageEnum)
    {
        CTransferItemEnum *ptie = new CTransferItemEnum(_szPath, _pstg, _pdpaItems);
        if (ptie)
        {
            hr = ptie->QueryInterface(riid, ppv);
            ptie->Release(); 
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CTransferStgItem::GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    HRESULT hr = E_UNEXPECTED;
    if ((sigdnName == SIGDN_PARENTRELATIVEPARSING) ||
        (sigdnName == SIGDN_PARENTRELATIVEEDITING) ||
        (sigdnName == SIGDN_PARENTRELATIVEFORADDRESSBAR))
    {
        hr = SHStrDupW(PathFindFileName(_szPath), ppszName);
    }
    return hr;
}

HRESULT CTransferStgItem::GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags)
{
    *psfgaoFlags = SFGAO_STORAGE;
    return S_OK;
}


// enumerator, this takes a DPA and returns IShellItems for the streams and
// storages it finds.   the storages are contructed dynamically based on 
// the destination paths specified.

CTransferItemEnum::CTransferItemEnum(LPCTSTR pszPath, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems) :
    _cRef(1), _iItem(0), _pstg(pstg), _pdpaItems(pdpaItems)
{
    StrCpyN(_szPath, pszPath, ARRAYSIZE(_szPath));
    _cchPath = lstrlen(_szPath);
    _pstg->AddRef();
}

CTransferItemEnum::~CTransferItemEnum()
{
    _pstg->Release();
}

ULONG CTransferItemEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferItemEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CTransferItemEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTransferItemEnum, IEnumShellItems),    // IID_IEnumShellItems
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// next enumerator for the items that we have in the DPA, this works by comparing the root
// that we have against the items in our list.   those who match that criteria can then

BOOL CTransferItemEnum::_GetNextItem(TRANSFERITEM **ppti)
{
    BOOL fResult = FALSE;
    if (_iItem < _pdpaItems->GetPtrCount())
    {
        TRANSFERITEM *pti = _pdpaItems->GetPtr(_iItem);
        if (StrCmpNI(_szPath, pti->szFilename, _cchPath) == 0)
        {
            *ppti = pti;
            fResult = TRUE;
        }
        _iItem++;
    }
    return fResult;
}

LPTSTR CTransferItemEnum::_GetNextComponent(LPTSTR pszPath)
{
    LPTSTR pszResult = pszPath;

    if (*pszResult == TEXT('\\'))
        pszResult++;

    while (*pszResult && (*pszResult != TEXT('\\')))
        pszResult++;

    if (*pszResult == TEXT('\\'))
        pszResult++;

    return pszResult;        
}

HRESULT CTransferItemEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    if (!celt || !rgelt)
        return E_INVALIDARG;                    // fail bad mojo

    if (pceltFetched)
        *pceltFetched = 0;                  
    
    HRESULT hr = S_FALSE;
    while (SUCCEEDED(hr) && (celt > 0) && (_iItem < _pdpaItems->GetPtrCount()))
    {
        // we still have some space in the buffer, and we haven't returned all
        // the items yet, so we can still itterate over the data set that we have
        // we have.

        TRANSFERITEM *pti;
        if (_GetNextItem(&pti))
        {
            TCHAR szFilename[MAX_PATH];
            StrCpyN(szFilename, pti->szFilename, ARRAYSIZE(szFilename));

            // storage or a stream, storages have trailing component names, if we
            // dont have that then we can assume its a create and pass out a IShellItem.

            LPTSTR pszNextComponent = _GetNextComponent(szFilename+_cchPath);
            if (!*pszNextComponent)
            {
                // create a wrapped shell item so that we can return the compressed
                // object back to the caller.

                if (!pti->psi)
                {
                    hr = SHCreateShellItem(NULL, NULL, pti->pidl, &pti->psi);            
                    if (SUCCEEDED(hr) && pti->fResizeOnUpload)
                    {
                        IImageRecompress *pir;
                        hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                        if (SUCCEEDED(hr))
                        {
                            IStream *pstrm;
                            hr = pir->RecompressImage(pti->psi, pti->cxResize, pti->cyResize, pti->iQuality, _pstg, &pstrm);
                            if (hr == S_OK)
                            {
                                STATSTG stat;
                                hr = pstrm->Stat(&stat, STATFLAG_DEFAULT);
                                if (SUCCEEDED(hr))
                                {
                                    IDynamicStorage *pdstg;
                                    hr = _pstg->QueryInterface(IID_PPV_ARG(IDynamicStorage, &pdstg));
                                    if (SUCCEEDED(hr))
                                    {
                                        IShellItem *psi;
                                        hr = pdstg->BindToItem(stat.pwcsName, IID_PPV_ARG(IShellItem, &psi));
                                        if (SUCCEEDED(hr))
                                        {
                                            IUnknown_Set((IUnknown**)&pti->psi, psi);
                                        }
                                        pdstg->Release();
                                    }
                                    CoTaskMemFree(stat.pwcsName);
                                }
                                pstrm->Release();
                            }
                            pir->Release();
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = pti->psi->QueryInterface(IID_PPV_ARG(IShellItem, rgelt));
                    if (SUCCEEDED(hr))
                    {
                        rgelt++;
                        celt--;
                        if (pceltFetched)
                        {
                            (*pceltFetched)++;
                        }
                    }
                }
            }
            else
            {
                // Its a storage, so lets create a dummy IShellItem that represents this
                // and pass it to the caller.  Then walk forward until we have skipped
                // all the items in this storage.

                int cchName = (int)(pszNextComponent-szFilename);
                CTransferStgItem *ptsi = new CTransferStgItem(szFilename, cchName, _pstg, _pdpaItems);
                if (ptsi)
                {
                    hr = ptsi->QueryInterface(IID_PPV_ARG(IShellItem, rgelt++));
                    if (SUCCEEDED(hr))
                    {
                        celt--;
                        if (pceltFetched)
                        {
                            (*pceltFetched)++;
                        }
                    }
                    ptsi->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // Skip the children of this storage

                TRANSFERITEM *ptiNext;
                while (_GetNextItem(&ptiNext))
                {
                    if (0 != StrCmpNI(ptiNext->szFilename, szFilename, cchName))
                    {
                        _iItem--;               // we hit an item that doesn't match the criteria
                        break;   
                    }
                }
            }
        }
    }
    return hr;
}


// all this code relates to using the RDR to transfer items to the destination site
// rather than using the manifest to handle the transfer via a HTTP POST.

class CTransferThread : IUnknown
{
public:
    CTransferThread();

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT BeginTransfer(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
    
protected:
    ~CTransferThread();
    
    static DWORD CALLBACK s_ThreadProc(void *pv);

    DWORD _ThreadProc();
    HRESULT _InitSourceEnum(IEnumShellItems **ppesi);
    HRESULT _SetProgress(DWORD dwCompleted, DWORD dwTotal);
    
    LONG _cRef;
    TRANSFERINFO _ti;
    CDPA<TRANSFERITEM> _dpaItems;

    IStream *_pstrmSink;

    CNetworkPlace _np;
};


// Main transfer thread object, this calls the shell item processor to copy
// items using the manifest we received back from the site.

CTransferThread::CTransferThread() :
    _cRef(1)
{
    DllAddRef();
}

CTransferThread::~CTransferThread()
{
    ATOMICRELEASE(_pstrmSink);
    _dpaItems.DestroyCallback(_FreeTransferItems, NULL);
    DllRelease();
}

ULONG CTransferThread::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferThread::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CTransferThread::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



// being the transfer of items, by creating a background thread which handles the upload.

HRESULT CTransferThread::BeginTransfer(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    _ti = *pti;
    _dpaItems.Attach(pdpaItems->Detach()); // we have ownership of the DPA now

    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_ITransferAdviseSink, ptas, &_pstrmSink);
    if (SUCCEEDED(hr))
    {
        AddRef();
        hr = SHCreateThread(s_ThreadProc, this, CTF_INSIST | CTF_COINIT, NULL) ? S_OK:E_FAIL;
        if (FAILED(hr))
        {
            Release();
        }
    }

    return hr;
}

DWORD CALLBACK CTransferThread::s_ThreadProc(void *pv)
{
    CTransferThread *pTransfer = (CTransferThread*)pv;
    return pTransfer->_ThreadProc();
}

HRESULT CTransferThread::_InitSourceEnum(IEnumShellItems **ppesi)
{
    IStorage *pstg;
    HRESULT hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorage, &pstg));
    {
        CTransferItemEnum *ptie = new CTransferItemEnum(L"", pstg, &_dpaItems);
        if (ptie)
        {
            hr = ptie->QueryInterface(IID_PPV_ARG(IEnumShellItems, ppesi));
            ptie->Release();
        }
        else
        {  
            hr = E_OUTOFMEMORY;
        }
        pstg->Release();
    }
    return hr;
}

DWORD CTransferThread::_ThreadProc()
{
    IEnumShellItems *penum =NULL;
    HRESULT hr = _InitSourceEnum(&penum);
    if (SUCCEEDED(hr))
    {
        hr = _np.SetTarget(_ti.hwnd, _ti.szFileTarget, NPTF_SILENT|NPTF_VALIDATE);          
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = _np.GetIDList(_ti.hwnd, &pidl);
            if (SUCCEEDED(hr))
            {
                IShellItem *psiDest;
                hr = SHCreateShellItem(NULL, NULL, pidl, &psiDest);
                if (SUCCEEDED(hr))
                {
                    IStorageProcessor *psp;
                    hr = CoCreateInstance(CLSID_StorageProcessor, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorageProcessor, &psp));
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwCookie = 0;

                        ITransferAdviseSink *ptas;
                        hr = CoGetInterfaceAndReleaseStream(_pstrmSink, IID_PPV_ARG(ITransferAdviseSink, &ptas));
                        _pstrmSink = NULL;

                        if (SUCCEEDED(hr))
                        {
                            hr = psp->Advise(ptas, &dwCookie);
                            ptas->Release();
                        }

                        hr = psp->Run(penum, psiDest, STGOP_COPY, STOPT_NOPROGRESSUI);

                        if (dwCookie)
                            psp->Unadvise(dwCookie);
                        
                        psp->Release();
                    }
                    psiDest->Release();
                }
                ILFree(pidl);
            }
        }
        penum->Release();
    }

    // notify the fg thread that this has happened.

    PostMessage(_ti.hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

    // were done transfering the files so lets start to clear up - in particular
    // lets attempt to create the net work place.

    if (_ti.szLinkTarget[0] && !(_ti.dwFlags & SHPWHF_NONETPLACECREATE))
    {
        CNetworkPlace np;
        if (SUCCEEDED(np.SetTarget(_ti.hwnd, _ti.szLinkTarget, 0x0)))
        {
            if (_ti.szLinkName[0])
                np.SetName(NULL, _ti.szLinkName);
            if (_ti.szLinkDesc[0])
                np.SetDescription(_ti.szLinkDesc);            

            np.CreatePlace(_ti.hwnd, FALSE);
        }
    }

    Release();
    return 0;
}


// helper to create and initialize the transfer engine

HRESULT PublishViaCopyEngine(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    CTransferThread *ptt = new CTransferThread();
    if (!ptt)
        return E_OUTOFMEMORY;

    HRESULT hr = ptt->BeginTransfer(pti, pdpaItems, ptas);
    ptt->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\passportmisc.cpp ===
#include <stdafx.h>
#include "misc.h"

#define HTTPS_URL_SCHEME            L"https://"
#define HTTPS_URL_SCHEME_CCH        (ARRAYSIZE(HTTPS_URL_SCHEME) - 1)

//  wininet reg key
#define WININET_REG_LOC   L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\passport"
#define WININET_NEXUS_API   "ForceNexusLookupExW"
#define PASSPORT_MAX_URL    1024

typedef BOOL (STDAPICALLTYPE *PFNFORCENEXUSLOOKUPEXW) (
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    );

// Misc functions
VOID    PassportForceNexusRepopulate();

class CPassportClientServices : 
    public CObjectSafety,
    public CImpIDispatch,
    public IPassportClientServices
{
public:
    CPassportClientServices() : 
        CImpIDispatch(LIBID_Shell32, 1, 0, IID_IPassportClientServices),
        _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo)
    { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
    { return CImpIDispatch::GetTypeInfo(iTInfo, lcid, ppTInfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
    { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId); }
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    { return CImpIDispatch::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr); }

    // IPassportClientServices
    STDMETHOD(MemberExists)(BSTR bstrUser, BSTR bstrPassword, VARIANT_BOOL* pvfExists);

private:
    long _cRef;
};

STDAPI CPassportClientServices_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPassportClientServices *pPCS = new CPassportClientServices();
    if (!pPCS)
        return E_OUTOFMEMORY;

    HRESULT hr = pPCS->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pPCS->Release();
    return hr;
}

ULONG CPassportClientServices::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPassportClientServices::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPassportClientServices::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPassportClientServices, IObjectSafety),             // IID_IObjectSafety
        QITABENT(CPassportClientServices, IDispatch),                 // IID_IDispatch
        QITABENT(CPassportClientServices, IPassportClientServices),   // IID_IPassportClientServices
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// DONT_USE_HTTPS - Uncomment this #define to turn off secure sending of information - for debugging purposes only
HRESULT CPassportClientServices::MemberExists(BSTR bstrUser, BSTR bstrPassword, VARIANT_BOOL* pvfExists)
{
    *pvfExists = VARIANT_FALSE;

    WCHAR szURL[PASSPORT_MAX_URL];
    HRESULT hr = PassportGetURL(PASSPORTURL_LOGON, szURL, PASSPORT_MAX_URL);
    if (SUCCEEDED(hr))
    {
        PBYTE lpBuffer = NULL;
        if (0 == StrCmpNI(szURL, HTTPS_URL_SCHEME, HTTPS_URL_SCHEME_CCH))
        {
            PWSTR pszServer = szURL + HTTPS_URL_SCHEME_CCH;
            //  NULL terminate
            PWSTR psz = wcschr(pszServer, L'/');
            if (psz)
            {
                *psz = L'\0';
            }

            HINTERNET hInternet = InternetOpen(L"Shell Registration",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0);
            if (hInternet)
            {
                HINTERNET hConnection = InternetConnectW(hInternet,
                                                  pszServer,
                                                  INTERNET_DEFAULT_HTTPS_PORT,
                                                  bstrUser,
                                                  bstrPassword,
                                                  INTERNET_SERVICE_HTTP,
                                                  0,
                                                  0);
                if (psz)
                {
                    *psz = L'/';
                }

                if (hConnection)
                {
                    //  set username/pwd
                    //  send the GET request
                    HINTERNET hRequest = HttpOpenRequest(hConnection,
                                                     NULL,
                                                     psz,
                                                     L"HTTP/1.1",
                                                     NULL,
                                                     NULL,
                                                     INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_SECURE,
                                                     0);
                    if (hRequest)
                    {
                        if (HttpSendRequest(hRequest, NULL, 0, NULL, 0))
                        {
                            DWORD dwStatus, dwLength = sizeof(dwStatus);
                            if (HttpQueryInfo(hRequest,
                                              HTTP_QUERY_STATUS_CODE |
                                                HTTP_QUERY_FLAG_NUMBER,
                                              &dwStatus,
                                              &dwLength,
                                              NULL))
                            {
                                //  if 200, member is there ...
                                if (dwStatus == 200)
                                {
                                    *pvfExists = VARIANT_TRUE;
                                }
                            }
                        }
                        InternetCloseHandle(hRequest);
                    }
                    InternetCloseHandle(hConnection);
                }
                InternetCloseHandle(hInternet);
            }
        }
    }

    return S_OK;
}

//
//  read registry for the desired URL
//

HRESULT _PassportGetURLFromHKey(HKEY hkey, PCWSTR pszName, PWSTR pszBuf, DWORD cchBuf)
{
    HRESULT hr = E_FAIL;

    HKEY hk;
    LONG lErr = RegOpenKeyExW(hkey,
                              WININET_REG_LOC,
                              0,
                              KEY_READ,
                              &hk);
    if (!lErr)
    {
        DWORD type;
        DWORD cbBuf = cchBuf * sizeof WCHAR;
        lErr = RegQueryValueExW(hk,
                               pszName,
                               0,
                               &type,
                               (PBYTE)pszBuf,
                               &cbBuf);
        if ((!lErr) &&
            (L'\0' != *pszBuf))
        {
           hr = S_OK;
        }

        RegCloseKey(hk);
    }

    return hr;
}

HRESULT PassportGetURL(PCWSTR pszName, PWSTR pszBuf, DWORD cchBuf)
{
    PassportForceNexusRepopulate();
    
    HRESULT hr = _PassportGetURLFromHKey(HKEY_LOCAL_MACHINE, pszName, pszBuf, cchBuf);

    if (FAILED(hr))
    {
        hr = _PassportGetURLFromHKey(HKEY_CURRENT_USER, pszName, pszBuf, cchBuf);
    }

    return hr;
}

//
//  populate nexus values
//

// #define USE_PRIVATE_WININET
VOID PassportForceNexusRepopulate()
{
    HMODULE hm = LoadLibraryA("wininet.dll");
    if (hm)
    {
        PFNFORCENEXUSLOOKUPEXW pfnForceNexusLookupExW = (PFNFORCENEXUSLOOKUPEXW) GetProcAddress(hm, WININET_NEXUS_API);
        if (pfnForceNexusLookupExW)
        {
            pfnForceNexusLookupExW(TRUE, NULL, 0, NULL, 0);
        }
        FreeLibrary(hm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubpost.cpp ===
#include "stdafx.h"
#include "pubwiz.h"
#include "netplace.h"
#pragma hdrstop


// this code works by building a multi-part post

LARGE_INTEGER g_li0 = {0};


// IStream class that wraps up the multi-part post into a single object.

#define BOUNDARY TEXT("------WindowsPublishWizard")

LPCTSTR c_pszBoundary    = (TEXT("--") BOUNDARY);
LPCTSTR c_pszBoundaryEOF = (TEXT("\r\n") TEXT("--") BOUNDARY TEXT("--"));
LPWSTR  c_pszContentType = (TEXT("multipart/form-data; boundary=") BOUNDARY);

LPCTSTR c_szFmtContent   = (TEXT("content-disposition: form-data; name=\"%s\""));
LPCTSTR c_szFmtFilename  = (TEXT("; filename=\"%s\""));
LPCTSTR c_szCRLF         = (TEXT("\r\n"));


/* 8c1e9993-7a84-431d-8c03-527f0fb147c5 */
CLSID IID_IPostStream = {0x8c1e9993, 0x7a84, 0x431d, {0x8c, 0x03, 0x52, 0x7f, 0x0f, 0xb1, 0x47, 0xc5}};

DECLARE_INTERFACE_(IPostStream, IStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // **** IPostStream ****
    STDMETHOD(SetTransferSink)(ITransferAdviseSink *ptas, ULONGLONG ulTotal, ULONGLONG ulCurrent);
};


// stream wrapper that expoes the binary data for the file as a multi-part stream object

class CPostStream : public IPostStream
{
public:
    CPostStream();

    HRESULT Initialize(IStorage *pstg, TRANSFERITEM *pti);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)( REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // *** IStream methods ***
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(VOID const *pv, ULONG cb, ULONG *pcbWritten)
        { return E_NOTIMPL; }
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
        { return E_NOTIMPL; }
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize)
        { return E_NOTIMPL; }
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
        { return E_NOTIMPL; }
    STDMETHOD(Commit)(DWORD grfCommitFlags)
        { return E_NOTIMPL; }
    STDMETHOD(Revert)()
        { return E_NOTIMPL; }
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return E_NOTIMPL; }
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return E_NOTIMPL; }
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm)
        { return E_NOTIMPL; }

    STDMETHOD(SetTransferSink)(ITransferAdviseSink *ptas, ULONGLONG ulTotal, ULONGLONG ulCurrent);

protected:
    ~CPostStream();

    static int s_ReleaseStream(IStream *pstrm, void *pv);

    HRESULT _WriteString(IStream *pstrm, LPCTSTR pszString);
    HRESULT _WriteStringCRLF(IStream *pstrm, LPCTSTR pszString);
    HRESULT _AddBoundaryMarker(IStream *pstrm, BOOL fLeadingCRLF, LPCTSTR pszName, LPCTSTR pszFilename);
    HRESULT _AddStream(IStream *pstrm);
    HRESULT _CreateMemoryStream(REFIID riid, void **ppv);

    LONG _cRef;

    IShellItem *_psi;
    ITransferAdviseSink *_ptas;

    // stream array we use to transfer the bits
    CDPA<IStream> _dpaStreams;
    int _iCurStream;

    // current seek pointers into the stream
    ULONGLONG _ulCurrent;
    ULONGLONG _ulTotal;

    // current seek pointers overal into the transfer
    ULONGLONG _ulOverallCurrent;
    ULONGLONG _ulOverallTotal;
};


// unknown / qi handler

CPostStream::CPostStream() :
    _cRef(1)
{
}

CPostStream::~CPostStream()
{
    if (_dpaStreams != NULL)
    {
        _dpaStreams.DestroyCallback(s_ReleaseStream, this);
        _iCurStream = 0;
    }

    if (_ptas)
        _ptas->Release();
}


// handle IUnknown

ULONG CPostStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostStream::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPostStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPostStream, IStream),    // IID_IStream
        QITABENT(CPostStream, IPostStream),    // IID_IPostStream
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



// handle writing data into a stream for building the post

HRESULT CPostStream::_WriteString(IStream *pstrm, LPCTSTR pszString)
{
// T2A conversion, can we do a UTF8 encode at this point?
    USES_CONVERSION;
    ULONG cb = lstrlen(pszString) * sizeof(CHAR);
    return pstrm->Write(T2A(pszString), cb, NULL);
}

HRESULT CPostStream::_WriteStringCRLF(IStream *pstrm, LPCTSTR pszString)
{
    HRESULT hr = _WriteString(pstrm, pszString);
    if (SUCCEEDED(hr))
    {
        hr = _WriteString(pstrm, c_szCRLF);
    }
    return hr;
}

HRESULT CPostStream::_AddBoundaryMarker(IStream *pstrm, BOOL fLeadingCRLF, LPCTSTR pszName, LPCTSTR pszFilename)
{
    HRESULT hr = S_OK;

    // add the boundary marker
    if (fLeadingCRLF)
        hr = _WriteString(pstrm, c_szCRLF);

    if (SUCCEEDED(hr))
    {
        hr = _WriteStringCRLF(pstrm, c_pszBoundary);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[MAX_PATH];        
            
            // format up the content disp + name attribute           
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), c_szFmtContent, pszName);
            hr = _WriteString(pstrm, szBuffer);
       
            // if we have a filename then lets put that into the line also
            if (SUCCEEDED(hr) && pszFilename)
            {
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), c_szFmtFilename, pszFilename);
                hr = _WriteString(pstrm, szBuffer);
            }

            // finish it off with a CR/LF            
            if (SUCCEEDED(hr))
            {
                _WriteString(pstrm, c_szCRLF);
                _WriteString(pstrm, c_szCRLF);
            }
        }
    }

    return hr;
}


// stream management functions

int CPostStream::s_ReleaseStream(IStream *pstrm, void *pv)
{
    pstrm->Release();
    return 1;
}

HRESULT CPostStream::_AddStream(IStream *pstrm)
{
    HRESULT hr = (-1 == _dpaStreams.AppendPtr(pstrm)) ? E_FAIL:S_OK;
    if (SUCCEEDED(hr))
    {
        pstrm->AddRef();
    }
    return hr;
}

HRESULT CPostStream::_CreateMemoryStream(REFIID riid, void **ppv)
{
    IStream *pstrm = SHCreateMemStream(NULL, 0);
    if (!pstrm)
        return E_OUTOFMEMORY;

    // lets add it to our list and return a refernce if needed

    HRESULT hr = _AddStream(pstrm);
    if (SUCCEEDED(hr))
    {
        hr = pstrm->QueryInterface(riid, ppv);
    }
    pstrm->Release();
    return hr;
}


// handle initialising the handler

HRESULT CPostStream::Initialize(IStorage *pstg, TRANSFERITEM *pti)
{
    HRESULT hr = pti->psi->QueryInterface(IID_PPV_ARG(IShellItem, &_psi));
    if (SUCCEEDED(hr))
    {
        hr = _dpaStreams.Create(4) ? S_OK:E_FAIL;
        if (SUCCEEDED(hr))
        {
            // first comes the file bits, this consists of two stream:
            //
            //  1) boundary marker
            //  2) file bits (reference to real bits on file system)

            IStream *pstrm;
            hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = _AddBoundaryMarker(pstrm, FALSE, pti->szName, pti->szFilename);
                if (SUCCEEDED(hr))
                {
                    IStream *pstrmFile;

                    // if we are recompressing this stream then apply it accordingly by
                    // creating an in memory stream that represents the file bits.

                    if (pti->fResizeOnUpload)
                    {
                        IImageRecompress *pir;
                        hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                        if (SUCCEEDED(hr))
                        {
                            hr = pir->RecompressImage(_psi, pti->cxResize, pti->cyResize, pti->iQuality, pstg, &pstrmFile);
                            pir->Release();
                        }
                    }

                    if (!pti->fResizeOnUpload || (hr != S_OK))
                        hr = _psi->BindToHandler(NULL, BHID_Stream, IID_PPV_ARG(IStream, &pstrmFile));

                    if (SUCCEEDED(hr))
                    {
                        hr = _AddStream(pstrmFile);
                        pstrmFile->Release();
                    }
                }
                pstrm->Release();
            }

            // now do we have any form data we need to write into the stream?

            if (pti->dsaFormData != NULL)
            {
                for (int iFormData = 0; SUCCEEDED(hr) && (iFormData < pti->dsaFormData.GetItemCount()); iFormData++)
                {
                    FORMDATA *pfd = pti->dsaFormData.GetItemPtr(iFormData);
                    ASSERT(pfd != NULL);

                    IStream *pstrm;
                    hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szBuffer[MAX_PATH];
                
                        // convert the variants - useful for passing across thread boundary
                        // to strings and form into a stream.

                        VariantToStr(&pfd->varName, szBuffer, ARRAYSIZE(szBuffer));                        
                        hr = _AddBoundaryMarker(pstrm, TRUE, szBuffer, NULL);
                        if (SUCCEEDED(hr))
                        {
                            VariantToStr(&pfd->varValue, szBuffer, ARRAYSIZE(szBuffer));
                            hr = _WriteString(pstrm, szBuffer);
                        }
                        pstrm->Release();
                    }
                }
            }

            // write EOF into a stream which will be returned.

            if (SUCCEEDED(hr))
            {
                IStream *pstrm;
                hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
                if (SUCCEEDED(hr))
                {
                    hr = _WriteStringCRLF(pstrm, c_pszBoundaryEOF);
                    pstrm->Release();
                }
            }

            // now handle our prep for post, this consists of walking all the streams
            // and processing the data.

            if (SUCCEEDED(hr))
            {
                // now get the total for the stream object that we are going to upload to the site
                STATSTG ststg;
                hr = this->Stat(&ststg, STATFLAG_NONAME);
                if (SUCCEEDED(hr))
                {
                    _ulTotal = ststg.cbSize.QuadPart;
                }

                // seek all the streams to the begining so that we can read from them
                for (int iStream = 0; iStream < _dpaStreams.GetPtrCount(); iStream++)
                {
                    IStream *pstrm = _dpaStreams.GetPtr(iStream);
                    ASSERT(pstrm != NULL);

                    pstrm->Seek(g_li0, 0, NULL);
                }
            }
        }
    }
    return hr;
}

HRESULT CPostStream::SetTransferSink(ITransferAdviseSink *ptas, ULONGLONG ulMax, ULONGLONG ulCurrent)
{
    _ulOverallTotal = ulMax;
    _ulOverallCurrent = ulCurrent;
       
    return ptas->QueryInterface(IID_PPV_ARG(ITransferAdviseSink, &_ptas));
}


// IStream methods

HRESULT CPostStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    ULONG cbReadTotal = 0;
    ULONG cbLeftToRead = cb;

    // cancel the stream

    if (_ptas && (_ptas->QueryContinue() == S_FALSE))
    {    
        hr = ERROR_CANCELLED;
    }

    // loop over the streams reading the bits from them

    while ((SUCCEEDED(hr) && hr != S_FALSE) && cbLeftToRead && (_iCurStream < _dpaStreams.GetPtrCount()))
    {
        IStream *pstrm = _dpaStreams.GetPtr(_iCurStream);
        ASSERT(pstrm != NULL);

        ULONG cbReadThisStream;
        hr = pstrm->Read(pv, cbLeftToRead, &cbReadThisStream);
    
        if (SUCCEEDED(hr))
        {
            cbLeftToRead -= cbReadThisStream;
            cbReadTotal += cbReadThisStream;
            pv = (char *)pv + cbReadThisStream;

            if (cbLeftToRead)
            {
                _iCurStream++;
                hr = S_OK;
            }
        }
    }

    // update our seek pointer so we know where we are and notify the progress object

    _ulCurrent = min(_ulTotal, (_ulCurrent + cbReadTotal));
    _ulOverallCurrent = min(_ulOverallTotal, (_ulOverallCurrent + cbReadTotal));
    
    if (_ptas)
    {
        _ptas->OperationProgress(STGOP_COPY, NULL, NULL, _ulOverallTotal, _ulOverallCurrent);
        _ptas->OperationProgress(STGOP_COPY, _psi, NULL, _ulTotal, _ulCurrent);
    }

    // write back the count for the caller
    if (pcbRead)
        *pcbRead = cbReadTotal;

    return hr;
}

HRESULT CPostStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if (grfStatFlag != STATFLAG_NONAME)
        return E_INVALIDARG;

    ZeroMemory(pstatstg, sizeof(*pstatstg));

    HRESULT hr = S_OK;
    for (int iStream = 0 ; SUCCEEDED(hr) && (iStream < _dpaStreams.GetPtrCount()); iStream++)
    {
        IStream *pstrm = _dpaStreams.GetPtr(iStream);
        ASSERT(pstrm != NULL);

        STATSTG ststg;
        hr = pstrm->Stat(&ststg, STATFLAG_NONAME);
        if (SUCCEEDED(hr))
        {
            pstatstg->cbSize.QuadPart += ststg.cbSize.QuadPart;
        }        
    }
    return hr;
}


// create wrapper, this initializes the object and returns a reference to it.

HRESULT CreatePostStream(TRANSFERITEM *pti, IStorage *pstg, IStream **ppstrm)
{
    CPostStream *pps = new CPostStream();
    if (!pps)
        return E_OUTOFMEMORY;

    HRESULT hr = pps->Initialize(pstg, pti);
    if (SUCCEEDED(hr))
    {
        hr = pps->QueryInterface(IID_PPV_ARG(IStream, ppstrm));
    }
    pps->Release();
    return hr;
}


// this engine posts the files to the site using the manifest

class CPostThread : public IUnknown
{
public:
    CPostThread(TRANSFERINFO *pti);

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT BeginTransfer(CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
    
protected:
    ~CPostThread();

    static DWORD CALLBACK s_ThreadProc(void *pv);
    DWORD _ThreadProc();

    LONG _cRef;

    TRANSFERINFO _ti;                   // transfer info structure 
    CDPA<TRANSFERITEM> _dpaItems;
    IStream *_pstrmSink;
    IStorage *_pstg;

    ULONGLONG _ulTotal;
    ULONGLONG _ulCurrent;
};


// construction destruction

CPostThread::CPostThread(TRANSFERINFO *pti) :
    _cRef(1),
    _ti(*pti)
{
    DllAddRef();
}

CPostThread::~CPostThread()
{
    if (_pstrmSink)
        _pstrmSink->Release();

    if (_pstg)
        _pstg->Release();

    _dpaItems.DestroyCallback(_FreeTransferItems, NULL);

    DllRelease();
}

ULONG CPostThread::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostThread::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPostThread::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// thread which handles the posting of the files to the site we walk the DPA that we
// have and post each individual file.

DWORD CPostThread::s_ThreadProc(void *pv)
{
    CPostThread *ppt = (CPostThread*)pv;
    return ppt->_ThreadProc();
}   

DWORD CPostThread::_ThreadProc()
{
    ITransferAdviseSink *ptas;
    HRESULT hr = CoGetInterfaceAndReleaseStream(_pstrmSink, IID_PPV_ARG(ITransferAdviseSink, &ptas));
    _pstrmSink = NULL;

    if (SUCCEEDED(hr))
    {
        _ulTotal = 0;
        _ulCurrent = 0;

        // lets create a dyanmic storage that we can use for building the post
        // data into, this will be passed to the stream creator to us.

        hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorage, &_pstg));

        // our pre flight sets the global size of the transfer and creates streams for
        // the objects we want to move over.   now get the advise sink and start
        // processing the files.

        for (int iItem = 0 ; SUCCEEDED(hr) && (iItem < _dpaItems.GetPtrCount()); iItem++)
        {   
            TRANSFERITEM *pti = _dpaItems.GetPtr(iItem);

            hr = SHCreateShellItem(NULL, NULL, pti->pidl, &pti->psi);
            if (SUCCEEDED(hr))
            {
                ptas->PreOperation(STGOP_STATS, pti->psi, NULL);

                hr = CreatePostStream(pti, _pstg, &pti->pstrm);
                if (SUCCEEDED(hr))
                {
                    hr = pti->pstrm->Stat(&pti->ststg, STATFLAG_NONAME);
                    if (SUCCEEDED(hr))
                    {
                        _ulTotal += pti->ststg.cbSize.QuadPart;
                    }
                }                

                ptas->PostOperation(STGOP_STATS, pti->psi, NULL, hr);
            }
        }
        
        for (int iItem = 0 ; SUCCEEDED(hr) && (iItem < _dpaItems.GetPtrCount()); iItem++)
        {   
            TRANSFERITEM *pti = _dpaItems.GetPtr(iItem);

            if (ptas->QueryContinue() == S_FALSE)
            {    
                hr = STRESPONSE_CANCEL;
            }
    
            if (SUCCEEDED(hr))
            {
                // notify the object that we are going to transfer
                ptas->PreOperation(STGOP_COPY, pti->psi, NULL);

                IPostStream *pps;
                if (ptas && SUCCEEDED(pti->pstrm->QueryInterface(IID_PPV_ARG(IPostStream, &pps))))
                {
                    pps->SetTransferSink(ptas, _ulTotal, _ulCurrent);
                    pps->Release();
                }

                IXMLHttpRequest *preq;
                hr = CoCreateInstance(CLSID_XMLHTTPRequest, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLHttpRequest, &preq));
                if (SUCCEEDED(hr))
                {
                    VARIANT varNULL = {0};
                    VARIANT varAsync = {VT_BOOL};
                    varAsync.boolVal = VARIANT_FALSE;

                    // open a post request to the destination that we have
                    hr = preq->open(pti->szVerb, pti->szURL, varAsync, varNULL, varNULL);
                    if (SUCCEEDED(hr))
                    {
                        // set it up to post with a multi-part
                        hr = preq->setRequestHeader(L"content-type", c_pszContentType);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varBody = {VT_UNKNOWN};
                            varBody.punkVal = pti->pstrm;

                            hr = preq->send(varBody);
                            if (SUCCEEDED(hr))
                            {
                                long lStatus;
                                hr = preq->get_status(&lStatus);
                                if (SUCCEEDED(hr))
                                {
                                    switch (lStatus)
                                    {
                                        case HTTP_STATUS_OK:
                                        case HTTP_STATUS_CREATED:
                                            hr = S_OK;
                                            break;

                                        default:
                                            hr = E_FAIL;
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    preq->Release();
                }

                // notify the site that the transfer is complete
                ptas->PostOperation(STGOP_COPY, pti->psi, NULL, hr);

                // update our seek pointer for progress
                _ulCurrent = min((_ulCurrent + pti->ststg.cbSize.QuadPart), _ulTotal);
            }
        }

        // notify the foreground that the wizard has finished uploading the bits to the site.

        PostMessage(_ti.hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

        // if that succeeded then lets try and create a net place that points to the place
        // we are uploading the files to.  of course we can only do this if they place
        // a shortcut entry into the 

        if (_ti.szLinkTarget[0] && !(_ti.dwFlags & SHPWHF_NONETPLACECREATE))
        {
            CNetworkPlace np;
            if (SUCCEEDED(np.SetTarget(_ti.hwnd, _ti.szLinkTarget, 0x0)))
            {
                if (_ti.szLinkName[0])
                    np.SetName(NULL, _ti.szLinkName);
                if (_ti.szLinkDesc[0])
                    np.SetDescription(_ti.szLinkDesc);            

                np.CreatePlace(_ti.hwnd, FALSE);
            }
        }

        ptas->Release();
    }

    Release();
    return 0L;
}


// handle initializing and kicking off the post thread which will handle the transter of the bits.

HRESULT CPostThread::BeginTransfer(CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    _dpaItems.Attach(pdpaItems->Detach()); // we have ownership of the DPA now

    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_ITransferAdviseSink, ptas, &_pstrmSink);
    if (SUCCEEDED(hr))
    {
        AddRef();
        hr = SHCreateThread(s_ThreadProc, this, CTF_INSIST | CTF_COINIT, NULL) ? S_OK:E_FAIL;
        if (FAILED(hr))
        {
            Release();
        }
    }

    return hr;
}


// create the posting object and initialize it

HRESULT PublishViaPost(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    CPostThread *ppt = new CPostThread(pti);
    if (!ppt)
        return E_OUTOFMEMORY;

    HRESULT hr = ppt->BeginTransfer(pdpaItems, ptas);
    ppt->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubdrop.cpp ===
#include "stdafx.h"
#include "pubwiz.h"
#pragma hdrstop


typedef struct
{
   CLSID clsidWizard;           // which wizard is being invoked
   IStream *pstrmDataObj;       // IDataObject marshall object
   IStream *pstrmView;          // IFolderView marshall object
} PUBWIZDROPINFO;

// This is the drop target object which exposes the publishing wizard

class CPubDropTarget : public IDropTarget, IPersistFile, IWizardSite, IServiceProvider, CObjectWithSite
{
public:
    CPubDropTarget(CLSID clsidWizard, IFolderView *pfv);
    ~CPubDropTarget();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
        { *pClassID = _clsidWizard; return S_OK; };

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragLeave(void)
        { return S_OK; };
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return GetNextPage(phPage); }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    CLSID _clsidWizard;        
    LONG _cRef;

    HWND _hwndFrame;

    IPublishingWizard *_ppw;   
    IResourceMap *_prm;        
    IUnknown *_punkFTM;        
    IFolderView *_pfv;

    TCHAR _szSiteName[MAX_PATH];
    TCHAR _szSiteURL[INTERNET_MAX_URL_LENGTH];

    // helpers
    static void s_FreePubWizDropInfo(PUBWIZDROPINFO *ppwdi);
    static DWORD s_PublishThreadProc(void *pv);
    void _Publish(IDataObject *pdo);
    INT_PTR _InitDonePage(HWND hwnd);
    void _OpenSiteURL();
   
    // dialog handlers
    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPubDropTarget *ppdt = s_GetPDT(hwnd, uMsg, lParam); return ppdt->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPubDropTarget *ppdt = s_GetPDT(hwnd, uMsg, lParam); return ppdt->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }

    static CPubDropTarget* s_GetPDT(HWND hwnd, UINT uMsg, LPARAM lParam);
    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    friend void PublishRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
};


// Construction/destruction

CPubDropTarget::CPubDropTarget(CLSID clsidWizard, IFolderView *pfv) :
    _clsidWizard(clsidWizard), _cRef(1)
{
    // use the FTM to make the call back interface calls unmarshalled
    CoCreateFreeThreadedMarshaler(SAFECAST(this, IDropTarget *), &_punkFTM);

    // addref the IFolderView object we might be given
    IUnknown_Set((IUnknown**)&_pfv, pfv);

    DllAddRef();
}

CPubDropTarget::~CPubDropTarget()
{
    ATOMICRELEASE(_punkFTM);
    ATOMICRELEASE(_pfv);
    DllRelease();
}

// Reference counting of the object

ULONG CPubDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPubDropTarget::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPubDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPubDropTarget, IObjectWithSite),  // IID_IObjectWithSite
        QITABENT(CPubDropTarget, IWizardSite),      // IID_IWizardSite
        QITABENT(CPubDropTarget, IDropTarget),      // IID_IDropTarget
        QITABENT(CPubDropTarget, IPersistFile),     // IID_IPersistFile
        QITABENT(CPubDropTarget, IServiceProvider), // IID_IServiceProvider
        {0, 0},
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && _punkFTM)
    {
        hr = _punkFTM->QueryInterface(riid, ppv);
    }
    return hr;

}


// retrieve the 'this' ptr for the dialog

CPubDropTarget* CPubDropTarget::s_GetPDT(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPubDropTarget*)ppsp->lParam;
    }
    return (CPubDropTarget*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// Welcome dialog. 

INT_PTR CPubDropTarget::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndFrame = GetParent(hwnd);
            SendDlgItemMessage(hwnd, IDC_PUB_WELCOME, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);

            IXMLDOMNode *pdn;
            HRESULT hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("welcome"), &pdn);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[512];

                _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOME, szBuffer);

                _prm->LoadString(pdn, TEXT("description"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOMEPROMPT, szBuffer);

                pdn->Release();
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
#if 0 
                    if (_fSkipWelcome)
                    {
                        _fSkipWelcome = FALSE;
                        HPROPSHEETPAGE hpage;
                        if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                        {
                            int i = PropSheet_PageToIndex(GetParent(hwnd), hpage);
                            if (i > 0) //cannot be zero because that's our index
                            {
                                UINT_PTR id = PropSheet_IndexToId(GetParent(hwnd), i);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)id);
                            }
                        }
                    }
#endif
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    return TRUE;              
                }

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// layout the controls on the done page

INT_PTR CPubDropTarget::_InitDonePage(HWND hwnd)
{
    HRESULT hrFromTransfer = E_FAIL; // default to that based on not getting any state back!
    
    // these are the states we can read back from the manifest

    BOOL fHasSiteName = FALSE;
    BOOL fHasNetPlace = FALSE;
    BOOL fHasFavorite = FALSE;
    BOOL fHasURL = FALSE;

    // lets crack the manifest and work out whats what with the publish that
    // we just performed.

    IXMLDOMDocument *pdocManifest;
    HRESULT hr = _ppw->GetTransferManifest(&hrFromTransfer, &pdocManifest);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdnUploadInfo;
        hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdnUploadInfo);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdel;
            VARIANT var;

            // lets pick up the site name from the manifest, this will be an attribute on the
            // upload info element.

            hr = pdnUploadInfo->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
            if (SUCCEEDED(hr))
            {
                hr = pdel->getAttribute(ATTRIBUTE_FRIENDLYNAME, &var);
                if (hr == S_OK)
                {
                    StrCpyN(_szSiteName, var.bstrVal, ARRAYSIZE(_szSiteName));
                    VariantClear(&var);

                    fHasSiteName = TRUE;
                }

                pdel->Release();
            }

            // lets now try and pick up the site URL node, this is going to either
            // be the file target, or HTML UI element.

            IXMLDOMNode *pdnURL;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_HTMLUI, &pdnURL);
            
            if (hr == S_FALSE)
                hr = pdnUploadInfo->selectSingleNode(ELEMENT_NETPLACE, &pdnURL);

            if (hr== S_FALSE)
                hr = pdnUploadInfo->selectSingleNode(ELEMENT_TARGET, &pdnURL);

            if (hr == S_OK)
            {
                hr = pdnURL->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    // attempt to read the HREF attribute, if that is defined
                    // the we use it, otherwise (for compatibility with B2, we need
                    // to get the node text and use that instead).

                    hr = pdel->getAttribute(ATTRIBUTE_HREF, &var);
                    if (hr != S_OK)
                        hr = pdel->get_nodeTypedValue(&var);

                    if (hr == S_OK)
                    {
                        StrCpyN(_szSiteURL, var.bstrVal, ARRAYSIZE(_szSiteURL));
                        VariantClear(&var);

                        fHasURL = TRUE;             // we now have the URL
                    }

                    pdel->Release();
                }
                pdnURL->Release();
            }

            // lets check for the favorite - if the element is present then we assume that
            // it was created.

            IXMLDOMNode *pdnFavorite;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_FAVORITE, &pdnFavorite);
            if (hr == S_OK)
            {
                pdnFavorite->Release();
                fHasFavorite = TRUE;
            }

            // lets check for the net place element - if the element is present then we
            // will assume it was created.

            IXMLDOMNode *pdnNetPlace;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_NETPLACE, &pdnNetPlace);
            if (hr == S_OK)
            {
                pdnNetPlace->Release();
                fHasNetPlace = TRUE;
            }

            pdnUploadInfo->Release();
        }
        pdocManifest->Release();
    }

    // adjust the resources on the done page to reflect the wizard that was invoked
    // and more importantly the success / failure that ocurred.

    IXMLDOMNode *pdn;
    hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("done"), &pdn);
    if (SUCCEEDED(hr))
    {
        TCHAR szBuffer[384 + INTERNET_MAX_URL_LENGTH];                   // enough for URL + text

        _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hwnd, IDC_PUB_DONE, szBuffer);

        if (hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            _prm->LoadString(pdn, TEXT("cancel"), szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (FAILED(hrFromTransfer))
        {
            _prm->LoadString(pdn, TEXT("failure"), szBuffer, ARRAYSIZE(szBuffer));
        }
        else
        {
            TCHAR szIntro[128] = {0};
            TCHAR szLink[128 +INTERNET_MAX_URL_LENGTH] = {0};
            TCHAR szConclusion[128] = {0};

            // get the intro text - this is common for all success pages

            _prm->LoadString(pdn, TEXT("success"), szIntro, ARRAYSIZE(szIntro));

            // if we have a link then we sometimes have a intro for that also

            if (fHasURL)
            {
                TCHAR szFmt[MAX_PATH];
                if (SUCCEEDED(_prm->LoadString(pdn, TEXT("haslink"), szFmt, ARRAYSIZE(szFmt))))
                {
                    wnsprintf(szLink, ARRAYSIZE(szLink), szFmt, fHasSiteName ? _szSiteName:_szSiteURL);
                }
            }   

            // then for some scenarios we have a postscript about creating favorites/netplaces

            if (fHasFavorite && fHasNetPlace)
            {
                _prm->LoadString(pdn, TEXT("hasfavoriteandplace"), szConclusion, ARRAYSIZE(szConclusion));
            }
            else if (fHasNetPlace)
            {
                _prm->LoadString(pdn, TEXT("hasplace"), szConclusion, ARRAYSIZE(szConclusion));
            }
            else if (fHasFavorite)
            {
                _prm->LoadString(pdn, TEXT("hasfavorite"), szConclusion, ARRAYSIZE(szConclusion));
            }

            // format it all into one string that we can set into the control
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s%s%s"), szIntro, szLink, szConclusion);
        }

        // update the message based on the strings we loaded. lets move the controls accordingly

        SetDlgItemText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);

        UINT ctls[] = { IDC_PUB_OPENFILES };
        int dy = SizeControlFromText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);
        MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);

        // show/hide the "open these files check" based on the URL that we might have

        BOOL fShowOpen = fHasURL && SUCCEEDED(hrFromTransfer) && (_clsidWizard == CLSID_PublishDropTarget);
        ShowWindow(GetDlgItem(hwnd, IDC_PUB_OPENFILES), fShowOpen ? SW_SHOW:SW_HIDE);
        CheckDlgButton(hwnd, IDC_PUB_OPENFILES, fShowOpen);

        pdn->Release();
    }

    // set the buttons to reflect what we can do in the wizard
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH|PSWIZB_BACK);
    return TRUE;
}

void CPubDropTarget::_OpenSiteURL()
{
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof(shexinfo);
    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpVerb = TEXT("open");
    shexinfo.lpFile =_szSiteURL;
    ShellExecuteEx(&shexinfo);
}

INT_PTR CPubDropTarget::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_PUB_DONE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case NM_CLICK:
                case NM_RETURN:
                    if (pnmh->idFrom == IDC_PUB_COMPLETEMSG)
                    {
                        _OpenSiteURL();
                        return TRUE;
                    }
                    break;

                case PSN_SETACTIVE:
                    return _InitDonePage(hwnd);

                case PSN_WIZBACK:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetLastPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    if (IsDlgButtonChecked(hwnd, IDC_PUB_OPENFILES) == BST_CHECKED)
                    {
                        _OpenSiteURL();
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)FALSE);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// IServiceProvider 

STDMETHODIMP CPubDropTarget::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_ResourceMap)
    {
        return _prm->QueryInterface(riid, ppv);
    }
    else if ((guidService == SID_SFolderView) && _pfv)
    {
        return _pfv->QueryInterface(riid, ppv);
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}


// site object helpers, these allow nagivation back and forward in the wizard

HRESULT CPubDropTarget::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_WELCOME);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}

HRESULT CPubDropTarget::GetNextPage(HPROPSHEETPAGE *phPage)
{
   int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_DONE);
   *phPage = PropSheet_IndexToPage(_hwndFrame, i);
   return S_OK;
}


// our publishing object

void CPubDropTarget::_Publish(IDataObject *pdo)
{
    // wizard implementation 

    struct
    {
        LPCTSTR idPage;
        LPCTSTR pszPage;    
        DWORD dwFlags;
        DLGPROC dlgproc;
    }
    _wizardpages[] =
    {
        {MAKEINTRESOURCE(IDD_PUB_WELCOME), TEXT("welcome"), PSP_HIDEHEADER, CPubDropTarget::s_WelcomeDlgProc},
        {MAKEINTRESOURCE(IDD_PUB_DONE),    TEXT("done"),    PSP_HIDEHEADER, CPubDropTarget::s_DoneDlgProc},
    };

    // load the resource map for this instance of the wizard

    HRESULT hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
    if (SUCCEEDED(hr))
    {
        // if this is the printing wizard then configure accordingly
        //  (eg. remove ADVANCED, FOLDERCREATEION and NETPLACES).

        DWORD dwFlags = 0x0;
        LPTSTR pszWizardDefn = TEXT("PublishingWizard");

        if (_clsidWizard == CLSID_InternetPrintOrdering)
        {
            dwFlags |= SHPWHF_NONETPLACECREATE|SHPWHF_NORECOMPRESS;
            pszWizardDefn = TEXT("InternetPhotoPrinting");
        }

        hr = _prm->LoadResourceMap(TEXT("wizard"), pszWizardDefn);
        if (SUCCEEDED(hr))
        {
            // create the page array, we add the welcome page and the finished page
            // the rest is loaded as an extension to the wizard.

            HPROPSHEETPAGE hpages[10] = { 0 };
            for (int cPages = 0; SUCCEEDED(hr) && (cPages < ARRAYSIZE(_wizardpages)); cPages++)
            {               
                // find resource map for this page of the wizard

                IXMLDOMNode *pdn;
                hr = _prm->SelectResourceScope(TEXT("dialog"), _wizardpages[cPages].pszPage, &pdn);
                if (SUCCEEDED(hr))
                {
                    TCHAR szTitle[MAX_PATH], szHeading[MAX_PATH], szSubHeading[MAX_PATH];

                    _prm->LoadString(pdn, TEXT("title"), szTitle, ARRAYSIZE(szTitle));
                    _prm->LoadString(pdn, TEXT("heading"), szHeading, ARRAYSIZE(szHeading));
                    _prm->LoadString(pdn, TEXT("subheading"), szSubHeading, ARRAYSIZE(szSubHeading));

                    PROPSHEETPAGE psp = { 0 };
                    psp.dwSize = sizeof(PROPSHEETPAGE);
                    psp.hInstance = g_hinst;
                    psp.lParam = (LPARAM)this;
                    psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | _wizardpages[cPages].dwFlags;
                    psp.pszTemplate = _wizardpages[cPages].idPage;
                    psp.pfnDlgProc = _wizardpages[cPages].dlgproc;
                    psp.pszTitle = szTitle;
                    psp.pszHeaderTitle = szHeading;        
                    psp.pszHeaderSubTitle = szSubHeading;  
                    hpages[cPages] = CreatePropertySheetPage(&psp);
                    hr = ((hpages[cPages]) != NULL) ? S_OK:E_FAIL;

                    pdn->Release();
                }
            }

            // lets create the web publishing wizard, this will handle the transfer
            // and destination selection for the upload.

            hr = CoCreateInstance(CLSID_PublishingWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPublishingWizard, &_ppw));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_ppw, SAFECAST(this, IWizardSite*));
                hr = _ppw->Initialize(pdo, dwFlags, pszWizardDefn);
                if (SUCCEEDED(hr))
                {
                    UINT cExtnPages;    
                    hr = _ppw->AddPages(&hpages[cPages], ARRAYSIZE(hpages)-cPages, &cExtnPages);
                    if (SUCCEEDED(hr))
                    {
                        cPages += cExtnPages;
                    }
                }
            }

            // ... that all worked so lets show the wizard.  on our way our remember
            // to clear up the objects

            if (SUCCEEDED(hr))
            {
                PROPSHEETHEADER psh = { 0 };
                psh.dwSize = sizeof(PROPSHEETHEADER);
                psh.hInstance = g_hinst;
                psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | (PSH_WATERMARK|PSH_USEHBMWATERMARK) | (PSH_HEADER|PSH_USEHBMHEADER);
                psh.phpage = hpages;
                psh.nPages = cPages;

                _prm->LoadBitmap(NULL, TEXT("header"), &psh.hbmHeader);
                _prm->LoadBitmap(NULL, TEXT("watermark"), &psh.hbmWatermark);

                if (psh.hbmHeader && psh.hbmWatermark)
                    PropertySheet(&psh);

                if (psh.hbmHeader)
                    DeleteObject(psh.hbmHeader);
                if (psh.hbmWatermark)
                    DeleteObject(psh.hbmWatermark);
            }

            IUnknown_SetSite(_ppw, NULL);                   // discard the publishing wizard
            IUnknown_Set((IUnknown**)&_ppw, NULL);
        }

        IUnknown_Set((IUnknown**)&_prm, NULL);                  // no more resource map
    }
}


// handle the drop operation, as the publishing wizard can take a long time we
// marshall the IDataObject and then create a worker thread which can
// handle showing the wizard.

void CPubDropTarget::s_FreePubWizDropInfo(PUBWIZDROPINFO *ppwdi)
{
    if (ppwdi->pstrmDataObj)
        ppwdi->pstrmDataObj->Release();
    if (ppwdi->pstrmView)
        ppwdi->pstrmView->Release();

    LocalFree(ppwdi);
}

DWORD CPubDropTarget::s_PublishThreadProc(void *pv)
{
    PUBWIZDROPINFO *ppwdi = (PUBWIZDROPINFO*)pv;
    if (ppwdi)
    {
        // ICW must have run before we go too far down this path
        LaunchICW();        
 
        // get the IDataObject, we need this to handle th drop
        IDataObject *pdo;
        HRESULT hr = CoGetInterfaceAndReleaseStream(ppwdi->pstrmDataObj, IID_PPV_ARG(IDataObject, &pdo));
        ppwdi->pstrmDataObj = NULL; // CoGetInterfaceAndReleaseStream always releases; NULL out.
        if (SUCCEEDED(hr))
        {   
            // try to unmarshall the IFolderView object we will use.
            IFolderView *pfv = NULL;
            if (ppwdi->pstrmView)
            {
                CoGetInterfaceAndReleaseStream(ppwdi->pstrmView, IID_PPV_ARG(IFolderView, &pfv));
                ppwdi->pstrmView = NULL; // CoGetInterfaceAndReleaseStream always releases; NULL out.
            }

            CPubDropTarget *ppw = new CPubDropTarget(ppwdi->clsidWizard, pfv);
            if (ppw)
            {
                ppw->_Publish(pdo);
                ppw->Release();
            }
    
            if (pfv)
                pfv->Release();

            pdo->Release();
        }  
        s_FreePubWizDropInfo(ppwdi);
    }
    return 0;    
}

STDMETHODIMP CPubDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    // create an instance of the wizard on another thread, package up any parameters
    // into a structure for the thread to handle (eg. the drop target)

    PUBWIZDROPINFO *ppwdi = (PUBWIZDROPINFO*)LocalAlloc(LPTR, sizeof(PUBWIZDROPINFO));
    if (ppwdi)
    {
        ppwdi->clsidWizard = _clsidWizard;

        // lets get the IFolderView object and marshall it for the bg thread

        IFolderView *pfv;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
        {
            CoMarshalInterThreadInterfaceInStream(IID_IFolderView, pfv, &ppwdi->pstrmView);
            pfv->Release();
        }
        
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &ppwdi->pstrmDataObj);
        if (SUCCEEDED(hr))
        {
            hr = SHCreateThread(s_PublishThreadProc, ppwdi, CTF_THREAD_REF|CTF_COINIT, NULL) ? S_OK:E_FAIL;
        }

        if (FAILED(hr))
        {
            s_FreePubWizDropInfo(ppwdi);
        }
    }
    return hr;
}


// create instance

STDAPI CPublishDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPubDropTarget *pwiz = new CPubDropTarget(*poi->pclsid, NULL);
    if (!pwiz)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pwiz->Release();
    return hr;
}

// invoke the publishing wizard to point at a particular directory

void APIENTRY PublishRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        CLSID clsid = CLSID_PublishDropTarget;
        UINT csidl = CSIDL_PERSONAL;

        if (0 == StrCmpIA(pszCmdLine, "/print"))
        {
            clsid = CLSID_InternetPrintOrdering;
            csidl = CSIDL_MYPICTURES;
        }

        LPITEMIDLIST pidl;
        hr = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                IDataObject *pdo;
                hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_X_PPV_ARG(IDataObject, NULL, &pdo));
                if (SUCCEEDED(hr))
                {
                    CPubDropTarget *pdt = new CPubDropTarget(clsid, NULL);
                    if (pdt)
                    {
                        pdt->_Publish(pdo);
                        pdt->Release();
                    }
                    pdo->Release();
                }
                psf->Release();
            }
            ILFree(pidl);
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubwiz.cpp ===
#include "stdafx.h"
#include "shimgdata.h"
#include "shui.h"
#include "netplace.h"
#include <Ntquery.h>
#include <shellp.h>
#include "pubwiz.h"
#include "gdiplus\gdiplus.h"
#include "imgprop.h"
#include "shdguid.h"
#include "urlmon.h"
#include "xmldomdid.h"
#include "winnlsp.h"
#pragma hdrstop


// Helpers - moved to shell/lib in longhorn
HRESULT GetServiceCurrentState(LPCWSTR pszService, DWORD *pdwCurrentState)
{
    HRESULT hr = E_FAIL;
    *pdwCurrentState = SERVICE_STOPPED;
    SC_HANDLE hscm = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (hscm)
    {
        SC_HANDLE hsvc = OpenService(hscm, pszService, SERVICE_QUERY_STATUS);
        if (hsvc)
        {
            SERVICE_STATUS ss;
            if (QueryServiceStatus(hsvc, &ss))
            {
                *pdwCurrentState = ss.dwCurrentState;
                hr = S_OK;
            }
            CloseServiceHandle(hsvc);
        }
        CloseServiceHandle(hscm);
    }

    if (FAILED(hr))
    {
        // Return interesting error codes, like service not found or access denied
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
        {
            // However, never return success
            hr = E_FAIL;
        }
    }

    return hr;
}

BOOL IsWebDavAvailable()
{
    DWORD dwCurrentState;
    return (SUCCEEDED(GetServiceCurrentState(L"WebClient", &dwCurrentState)) && 
        (dwCurrentState == SERVICE_RUNNING));
}


// handle the events from the DOM as we load

#define XMLDOC_LOADING      1
#define XMLDOC_LOADED       2
#define XMLDOC_INTERACTIVE  3
#define XMLDOC_COMPLETED    4


// this message is posted to the parent HWND, the lParam parse result

#define MSG_XMLDOC_COMPLETED    WM_APP

class CXMLDOMStateChange : public IDispatch
{
public:
    CXMLDOMStateChange(IXMLDOMDocument *pdoc, HWND hwnd); 
    ~CXMLDOMStateChange();
    HRESULT Advise(BOOL fAdvise);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();        
    STDMETHODIMP_(ULONG) Release();

    // IDispatch
    STDMETHODIMP GetTypeInfoCount( UINT *pctinfo) 
        { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
        { return E_NOTIMPL; }    
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
        { return E_NOTIMPL; }    
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvar, EXCEPINFO *pExcepInfo, UINT *puArgErr);

private:
    long _cRef;
    IXMLDOMDocument *_pdoc;
    DWORD _dwCookie;
    HWND _hwnd;
};


// construction and IUnknown

CXMLDOMStateChange::CXMLDOMStateChange(IXMLDOMDocument *pdoc, HWND hwnd) :
    _cRef(1), _dwCookie(0), _hwnd(hwnd)
{
    IUnknown_Set((IUnknown**)&_pdoc, pdoc);
}

CXMLDOMStateChange::~CXMLDOMStateChange()
{
    IUnknown_Set((IUnknown**)&_pdoc, NULL);
}

ULONG CXMLDOMStateChange::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CXMLDOMStateChange::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CXMLDOMStateChange::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CXMLDOMStateChange, IDispatch),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}


// handle the advise/unadvise to the parent object

HRESULT CXMLDOMStateChange::Advise(BOOL fAdvise)
{
    IConnectionPointContainer *pcpc;
    HRESULT hr = _pdoc->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc));
    if (SUCCEEDED(hr))
    {
        IConnectionPoint *pcp;
        hr = pcpc->FindConnectionPoint(DIID_XMLDOMDocumentEvents, &pcp);
        if (SUCCEEDED(hr))
        {
            if (fAdvise)
            {
                hr = pcp->Advise(SAFECAST(this, IDispatch *), &_dwCookie);
            }
            else if (_dwCookie)
            {
                hr = pcp->Unadvise(_dwCookie);
                _dwCookie = 0;
            }
            pcp->Release();
        }
        pcpc->Release();
    }
    return hr;
}


// handle the invoke for the doc state changing

HRESULT CXMLDOMStateChange::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvar, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT hr = S_OK;
    switch (dispIdMember)
    {
        case DISPID_XMLDOMEVENT_ONREADYSTATECHANGE:
        {            
            long lReadyState;
            if (SUCCEEDED(_pdoc->get_readyState(&lReadyState)))
            {
                if (lReadyState == XMLDOC_COMPLETED)
                {
                    IXMLDOMParseError *pdpe;
                    hr = _pdoc->get_parseError(&pdpe);
                    if (SUCCEEDED(hr))
                    {
                        long lError;
                        hr = pdpe->get_errorCode(&lError);
                        if (SUCCEEDED(hr))
                        {
                            hr = (HRESULT)lError;
                        }
                        PostMessage(_hwnd, MSG_XMLDOC_COMPLETED, 0, (LPARAM)hr);
                        pdpe->Release();
                    }
                }
            }
            break;
        }
    }
    return hr;
}


// copied from shell stuff - should be in public header

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

DEFINE_SCID(SCID_NAME,              PSGUID_STORAGE, PID_STG_NAME);
DEFINE_SCID(SCID_TYPE,              PSGUID_STORAGE, PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_SIZE,              PSGUID_STORAGE, PID_STG_SIZE);
DEFINE_SCID(SCID_WRITETIME,         PSGUID_STORAGE, PID_STG_WRITETIME);

DEFINE_SCID(SCID_ImageCX,           PSGUID_IMAGESUMMARYINFORMATION, PIDISI_CX);
DEFINE_SCID(SCID_ImageCY,           PSGUID_IMAGESUMMARYINFORMATION, PIDISI_CY);


// provider XML defines the following properties

#define DEFAULT_PROVIDER_SCOPE          TEXT("PublishingWizard")

#define FMT_PROVIDER                    TEXT("providermanifest/providers[@scope='%s']")
#define FMT_PROVIDERS                   TEXT("providermanifest/providers[@scope='%s']/provider")

#define ELEMENT_PROVIDERMANIFEST        L"providermanifest"
#define ELEMENT_PROVIDERS               L"providers"

#define ELEMENT_PROVIDER                L"provider"
#define ATTRIBUTE_ID                    L"id"
#define ATTRIBUTE_SUPPORTEDTYPES        L"supportedtypes"
#define ATTRIBUTE_REQUIRESWEBDAV        L"requiresWebDAV"
#define ATTRIBUTE_DISPLAYNAME           L"displayname"
#define ATTRIBUTE_DESCRIPTION           L"description"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_ICONPATH              L"iconpath"
#define ATTRIBUTE_ICON                  L"icon"

#define ELEMENT_STRINGS                 L"strings"
#define ATTRIBUTE_LANGID                L"langid"

#define ELEMENT_STRING                  L"string"
#define ATTRIBUTE_LANGID                L"langid"
#define ATTRIBUTE_ID                    L"id"


// registry state is stored under the this key

#define SZ_REGKEY_PUBWIZ                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\PublishingWizard")

// per machine values in the registry

#define SZ_REGVAL_SERVICEPARTNERID      TEXT("PartnerID")


// these are stored per machine under the provider

#define SZ_REGVAL_FILEFILTER            TEXT("ContentTypeFilter")
#define SZ_REGVAL_DEFAULTPROVIDERICON   TEXT("DefaultIcon")

// per user values in the registry

#define SZ_REGVAL_DEFAULTPROVIDER       TEXT("DefaultProvider")

// per provider settings

#define SZ_REGVAL_MRU                   TEXT("LocationMRU")
#define SZ_REGVAL_ALTPROVIDERS          TEXT("Providers")


// Properties exposed by the property bag (from the Web Service)

#define PROPERTY_EXTENSIONCOUNT         TEXT("UniqueExtensionCount")
#define PROPERTY_EXTENSION              TEXT("UniqueExtension")

#define PROPERTY_TRANSFERMANIFEST       TEXT("TransferManifest")


// This is the COM object that exposes the publishing wizard

#define WIZPAGE_WHICHFILE           0   // which file should we publish
#define WIZPAGE_FETCHINGPROVIDERS   1   // provider download page
#define WIZPAGE_PROVIDERS           2   // pick a service provider
#define WIZPAGE_RESIZE              3   // resample the data?
#define WIZPAGE_COPYING             4   // copying page
#define WIZPAGE_LOCATION            5   // location page (advanced)
#define WIZPAGE_FTPUSER             6   // username / password (advanced)
#define WIZPAGE_FRIENDLYNAME        7   // friendly name
#define WIZPAGE_MAX                 8


// resize information

struct
{
    int cx;
    int cy;
    int iQuality;
} 
_aResizeSettings[] = 
{
    { 0, 0, 0 },
    { 640,  480, 80 },          // low quality
    { 800,  600, 80 },          // medium quality
    { 1024, 768, 80 },          // high quality
};

typedef enum
{
    RESIZE_NONE = 0,
    RESIZE_SMALL,
    RESIZE_MEDIUM,
    RESIZE_LARGE,
} RESIZEOPTION;


class CPublishingWizard : public IServiceProvider, IPublishingWizard, CObjectWithSite, ITransferAdviseSink, ICommDlgBrowser, IOleWindow, IWizardSite
{
public:
    CPublishingWizard();
    ~CPublishingWizard();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IWizardExtension
    STDMETHODIMP AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages);
    STDMETHODIMP GetFirstPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetLastPage(HPROPSHEETPAGE *phPage);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage);

    // IPublishingWizard
    STDMETHODIMP Initialize(IDataObject *pdo, DWORD dwFlags, LPCTSTR pszServiceProvider);
    STDMETHODIMP GetTransferManifest(HRESULT *phrFromTransfer, IXMLDOMDocument **pdocManifest);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd)
        { *phwnd = _hwndCopyingPage; return S_OK; }
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnter)
        { return E_NOTIMPL; }

    // ICommDlgBrowser
    STDMETHOD(OnDefaultCommand)(IShellView *ppshv)
        { return E_NOTIMPL; }
    STDMETHOD(OnStateChange)(IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject)(IShellView *ppshv, LPCITEMIDLIST lpItem);

    // ITransferAdviseSink
    STDMETHODIMP PreOperation (const STGOP op, IShellItem *psiItem, IShellItem *psiDest);
    STDMETHODIMP ConfirmOperation(IShellItem *psiItem, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
        { return STRESPONSE_CONTINUE; }
    STDMETHODIMP OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ulTotal, ULONGLONG ulComplete);
    STDMETHODIMP PostOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
        { return S_OK; }
    STDMETHODIMP QueryContinue()
        { return _fCancelled ? S_FALSE : S_OK; }

private:
    LONG _cRef;                                 // object lifetime count

    IDataObject *_pdo;                          // data object provided by the site
    IDataObject *_pdoSelection;                 // this is the selection IDataObject - used instead of _pdo if defined

    DWORD _dwFlags;                             // flags provided by the site
    TCHAR _szProviderScope[MAX_PATH];           // provider scope (eg. Web Publishing)

    BOOL _fOfferResize;                         // show the resize page - pictures/music etc
    RESIZEOPTION _ro;                           // resize setting we will use

    BOOL _fUsingTemporaryProviders;             // temporary provider listed pull in, replace when we can
    BOOL _fRecomputeManifest;                   // recompute the manifest
    BOOL _fRepopulateProviders;                 // repopulate the providers list
    BOOL _fShownCustomLocation;                 // show the custom locaiton page
    BOOL _fShownUserName;                       // password page was shown
    BOOL _fValidating;                          // validating a server (Advanced path);
    BOOL _fCancelled;                           // operation was cancelled
    BOOL _fTransferComplete;                    // transfer completed.

    HWND _hwndSelector;                         // hwnd for the selector dialog
    HWND _hwndCopyingPage;

    int _iPercentageComplete;                   // % compelte of this transfer
    DWORD _dwTotal;
    DWORD _dwCompleted;

    int _cFiles;                                // maximum number of files
    int _iFile;                                 // current file we are on

    HRESULT _hrFromTransfer;                    // result of the transfer performed

    HPROPSHEETPAGE _aWizPages[WIZPAGE_MAX];     // page handles for this wizard (so we can navigate)

    IPropertyBag *_ppb;                         // property bag object exposed from the site
    IWebWizardExtension *_pwwe;                 // host for the HTML wizard pages
    IResourceMap *_prm;                         // resource map object we create if we can't query from the host

    IXMLDOMDocument *_pdocProviders;            // XML dom which exposes the providers
    CXMLDOMStateChange *_pdscProviders;         // DOMStateChange for the provider list

    IXMLDOMDocument *_pdocManifest;             // document describing the files to be transfered
    LPITEMIDLIST *_aItems;                      // array of items we copied
    UINT _cItems;

    IAutoComplete2 *_pac;                       // auto complete object
    IUnknown *_punkACLMulti;                    // IObjMgr object that exposes all the enumerators
    IACLCustomMRU *_pmru;                       // custom MRU for the objects we want to list
    CNetworkPlace _npCustom;                    // net place object for handling the custom entry

    HCURSOR _hCursor;

    IFolderView *_pfv;                          // file selector view object
    TCHAR _szFilter[MAX_PATH];                  // filter string read from the registry

    static CPublishingWizard* s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam);
    static int s_FreeStringProc(void* pFreeMe, void* pData);
    static HRESULT s_SetPropertyFromDisp(IPropertyBag *ppb, LPCWSTR pszID, IDispatch *pdsp);
    static DWORD CALLBACK s_ValidateThreadProc(void *pv);
    static int s_CompareItems(TRANSFERITEM *pti1, TRANSFERITEM *pti2, CPublishingWizard *ppw);
    static UINT s_SelectorPropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp);

    static INT_PTR s_SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_SelectorDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FetchProvidersDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_ProviderDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_ResizeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_CopyDlgProc(hwnd, uMsg, wParam, lParam); }

    static INT_PTR s_LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_LocationDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_UserNameDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FriendlyNameDlgProc(hwnd, uMsg, wParam, lParam); }

    // these are used for publishing
    INT_PTR _SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // these are used for ANP
    INT_PTR _LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _FreeProviderList();
    HRESULT _GetProviderKey(HKEY hkRoot, DWORD dwAccess, LPCTSTR pszSubKey, HKEY *phkResult);
    void _MapDlgItemText(HWND hwnd, UINT idc, LPCTSTR pszDlgID, LPCTSTR pszResourceID);
    HRESULT _GetResourceMap(IResourceMap **pprm);
    HRESULT _LoadMappedString(LPCTSTR pszDlgID, LPCTSTR pszResourceID, LPTSTR pszBuffer, int cch);
    HRESULT _CreateWizardPages();
    INT_PTR _WizardNext(HWND hwnd, int iPage);            
    HRESULT _AddExtenisonToList(HDPA hdpa, LPCTSTR pszExtension);
    HRESULT _InitPropertyBag(LPCTSTR pszURL);
    int _GetSelectedItem(HWND hwndList);
    void _GetDefaultProvider(LPTSTR pszProvider, int cch);
    void _SetDefaultProvider(IXMLDOMNode *pdn);
    HRESULT _FetchProviderList(HWND hwnd);
    HRESULT _MergeLocalProviders();
    int _AddProvider(HWND hwnd, IXMLDOMNode *pdn);
    void _PopulateProviderList(HWND hwnd);
    void _ProviderEnableNext(HWND hwnd);
    void _ProviderGetDispInfo(LV_DISPINFO *plvdi);
    HRESULT _ProviderNext(HWND hwnd, HPROPSHEETPAGE *phPage);
    void _SetWaitCursor(BOOL bOn);
    void _ShowExampleTip(HWND hwnd);
    void _LocationChanged(HWND hwnd);
    void _UserNameChanged(HWND hwnd);
    DWORD _GetAutoCompleteFlags(DWORD dwFlags);
    HRESULT _InitAutoComplete();
    void _InitLocation(HWND hwnd);
    HRESULT _AddCommonItemInfo(IXMLDOMNode *pdn, TRANSFERITEM *pti);
    HRESULT _AddTransferItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn);
    HRESULT _AddPostItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn);
    void _FreeTransferManifest();
    HRESULT _AddFilesToManifest(IXMLDOMDocument *pdocManifest);
    HRESULT _BuildTransferManifest();
    HRESULT _GetUniqueTypeList(BOOL fIncludeFolder, HDPA *phdpa);
    HRESULT _InitTransferInfo(IXMLDOMDocument *pdocManifest, TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems);
    void _TryToValidateDestination(HWND hwnd);
    void _InitProvidersDialog(HWND hwnd);    
    void _SetProgress(DWORD dwCompleted, DWORD dwTotal);
    BOOL _HasAttributes(IShellItem *psi, SFGAOF flags);
    HRESULT _BeginTransfer(HWND hwnd);
    HPROPSHEETPAGE _TransferComplete(HRESULT hrFromTransfer);
    void _FriendlyNameChanged(HWND hwnd);
    HRESULT _CreateFavorite(IXMLDOMNode *pdnUploadInfo);
    int _GetRemoteIcon(LPCTSTR pszID, BOOL fCanRefresh);
    HRESULT _GetSiteURL(LPTSTR pszBuffer, int cchBuffer, LPCTSTR pszFilenameToCombine);
    void _StateChanged();
    void _ShowHideFetchProgress(HWND hwnd, BOOL fShow);
    void _FetchComplete(HWND hwnd, HRESULT hrFromFetch);
    HRESULT _GetProviderString(IXMLDOMNode *pdn, USHORT idPrimary, USHORT idSub, LPCTSTR pszID, LPTSTR pszBuffer, int cch);
    HRESULT _GetProviderString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch);
    HRESULT _GeoFromLocaleInfo(LCID lcid, GEOID *pgeoID);
    HRESULT _GetProviderListFilename(LPTSTR pszFile, int cchFile);
};


// publishing wizard obj

CPublishingWizard::CPublishingWizard() :
    _cRef(1), _fRecomputeManifest(TRUE), _hrFromTransfer(S_FALSE)
{  
    StrCpyN(_szProviderScope, DEFAULT_PROVIDER_SCOPE, ARRAYSIZE(_szProviderScope));  // fill the default provider scope
    DllAddRef();
}

CPublishingWizard::~CPublishingWizard()
{   
    if (_pwwe)
    {
        IUnknown_SetSite(_pwwe, NULL);
        _pwwe->Release();
    }

    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pdoSelection);
    ATOMICRELEASE(_prm);

    _FreeProviderList();
    _FreeTransferManifest();

    DllRelease();
}

ULONG CPublishingWizard::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublishingWizard::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPublishingWizard::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPublishingWizard, IWizardSite),         // IID_IWizardSite
        QITABENT(CPublishingWizard, IObjectWithSite),     // IID_IObjectWithSite
        QITABENT(CPublishingWizard, IServiceProvider),    // IID_IServiceProvider
        QITABENT(CPublishingWizard, IPublishingWizard),   // IID_IPublishingWizard
        QITABENT(CPublishingWizard, ITransferAdviseSink), // IID_ITransferAdviseSink
        QITABENTMULTI(CPublishingWizard, IQueryContinue, ITransferAdviseSink), // IID_IQueryContinue        
        QITABENT(CPublishingWizard, IOleWindow),          // IID_IOleWindow
        QITABENT(CPublishingWizard, ICommDlgBrowser),     // IID_ICommDlgBrowser
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CPublishingWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPublishingWizard *pwiz = new CPublishingWizard();
    if (!pwiz)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pwiz->Release();
    return hr;
}


// IPublishingWizard methods

HRESULT CPublishingWizard::Initialize(IDataObject *pdo, DWORD dwOptions, LPCTSTR pszServiceProvider)
{
    IUnknown_Set((IUnknown**)&_pdo, pdo);
    IUnknown_Set((IUnknown**)&_pdoSelection, NULL);

    _dwFlags = dwOptions;
    _fRecomputeManifest = TRUE;     // _fRepopulateProviders set when manifest rebuilt

    if (!pszServiceProvider)
        pszServiceProvider = DEFAULT_PROVIDER_SCOPE;

    StrCpyN(_szProviderScope, pszServiceProvider, ARRAYSIZE(_szProviderScope));

    return S_OK;
}

HRESULT CPublishingWizard::GetTransferManifest(HRESULT *phrFromTransfer, IXMLDOMDocument **ppdocManifest)
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppb)
    {
        if (phrFromTransfer)
            *phrFromTransfer = _hrFromTransfer;

        if (ppdocManifest)
        {
            VARIANT var = {VT_DISPATCH};
            hr = _ppb->Read(PROPERTY_TRANSFERMANIFEST, &var, NULL);
            if (SUCCEEDED(hr))
            {
                hr = var.pdispVal->QueryInterface(IID_PPV_ARG(IXMLDOMDocument, ppdocManifest));
                VariantClear(&var);
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}


// Wizard site methods

STDMETHODIMP CPublishingWizard::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    return S_OK;
}

STDMETHODIMP CPublishingWizard::GetNextPage(HPROPSHEETPAGE *phPage)
{
    // lets get the next page we'd need to show if all else fails.

    IWizardSite *pws;
    HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
    if (SUCCEEDED(hr))
    {
        hr = pws->GetNextPage(phPage);
        pws->Release();
    }

    // if we have not transfered and we have a IDataObject then we should
    // advance to one of the special pages we are supposed to show.

    if (!_fTransferComplete && _pdo)
    {
        *phPage = _aWizPages[_fOfferResize ? WIZPAGE_RESIZE:WIZPAGE_COPYING];
    }

    return hr;
}

STDMETHODIMP CPublishingWizard::GetCancelledPage(HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_NOTIMPL;
    if (!_fTransferComplete)
    {
        *phPage = _TransferComplete(HRESULT_FROM_WIN32(ERROR_CANCELLED)); 
        if (*phPage)
            hr = S_OK;
    }
    else
    {
        IWizardSite *pws;
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
        if (SUCCEEDED(hr))
        {
            hr = pws->GetCancelledPage(phPage);
            pws->Release();
        }
    }
    return hr;
}


// Service provider object

STDMETHODIMP CPublishingWizard::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_WebWizardHost)
    {
        if (riid == IID_IPropertyBag)
        {
            return _ppb->QueryInterface(riid, ppv);
        }
    }
    else if (guidService == SID_SCommDlgBrowser)
    {
        return this->QueryInterface(riid, ppv);
    }
    else if (_punkSite)
    {
        return IUnknown_QueryService(_punkSite, guidService, riid, ppv);
    }
    return E_FAIL;
}


// IWizardExtension methods

HRESULT CPublishingWizard::_CreateWizardPages()
{
    const struct
    {
        LPCTSTR pszID;
        int idPage;
        DLGPROC dlgproc;
        UINT idsHeading;
        UINT idsSubHeading;
        LPFNPSPCALLBACK pfnCallback;
    } 
    _wp[] = 
    {
        {TEXT("wp:selector"),    IDD_PUB_SELECTOR,       CPublishingWizard::s_SelectorDlgProc, IDS_PUB_SELECTOR, IDS_PUB_SELECTOR_SUB, NULL},
        {TEXT("wp:fetching"),    IDD_PUB_FETCHPROVIDERS, CPublishingWizard::s_FetchProvidersDlgProc, IDS_PUB_FETCHINGPROVIDERS, IDS_PUB_FETCHINGPROVIDERS_SUB, CPublishingWizard::s_SelectorPropPageProc},
        {TEXT("wp:destination"), IDD_PUB_DESTINATION,    CPublishingWizard::s_ProviderDlgProc, IDS_PUB_DESTINATION, IDS_PUB_DESTINATION_SUB, NULL},
        {TEXT("wp:resize"),      IDD_PUB_RESIZE,         CPublishingWizard::s_ResizeDlgProc, IDS_PUB_RESIZE, IDS_PUB_RESIZE_SUB, NULL},
        {TEXT("wp:copying"),     IDD_PUB_COPY,           CPublishingWizard::s_CopyDlgProc, IDS_PUB_COPY, IDS_PUB_COPY_SUB, NULL},
        {TEXT("wp:location"),    IDD_PUB_LOCATION,       CPublishingWizard::s_LocationDlgProc, IDS_PUB_LOCATION, IDS_PUB_LOCATION_SUB, NULL},
        {TEXT("wp:ftppassword"), IDD_PUB_FTPPASSWORD,    CPublishingWizard::s_UserNameDlgProc, IDS_PUB_FTPPASSWORD, IDS_PUB_FTPPASSWORD_SUB, NULL},
        {TEXT("wp:friendlyname"),IDD_ANP_FRIENDLYNAME,   CPublishingWizard::s_FriendlyNameDlgProc, IDS_ANP_FRIENDLYNAME, IDS_ANP_FRIENDLYNAME_SUB, NULL},
    };

    // if we haven't created the pages yet, then lets initialize our array of handlers.

    HRESULT hr = S_OK;
    if (!_aWizPages[0])
    {
        INITCOMMONCONTROLSEX iccex = { 0 };
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
        InitCommonControlsEx(&iccex);

        LinkWindow_RegisterClass();             // we will use the link window (can this be removed)

        for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(_wp)) ; i++ )
        {                           
            TCHAR szHeading[MAX_PATH], szSubHeading[MAX_PATH];

            // if we have a resource map then load the heading and sub heading text
            // if there is no resource map from the parent object then we must default
            // the strings.

            IResourceMap *prm;
            hr = _GetResourceMap(&prm);
            if (SUCCEEDED(hr))
            {
                IXMLDOMNode *pdn;
                hr = prm->SelectResourceScope(TEXT("dialog"), _wp[i].pszID, &pdn);
                if (SUCCEEDED(hr))
                {
                    prm->LoadString(pdn, L"heading", szHeading, ARRAYSIZE(szHeading));
                    prm->LoadString(pdn, L"subheading", szSubHeading, ARRAYSIZE(szSubHeading));
                    pdn->Release();
                }
                prm->Release();
            }

            if (FAILED(hr))
            {
                LoadString(g_hinst, _wp[i].idsHeading, szHeading, ARRAYSIZE(szHeading));
                LoadString(g_hinst, _wp[i].idsSubHeading, szSubHeading, ARRAYSIZE(szSubHeading));
            }

            // lets create the page now that we have loaded the relevant strings, more mapping
            // will occur later (during dialog initialization)

            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = SIZEOF(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.lParam = (LPARAM)this;
            psp.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.pszTemplate = MAKEINTRESOURCE(_wp[i].idPage);
            psp.pfnDlgProc = _wp[i].dlgproc;

            psp.pszHeaderTitle = szHeading;
            psp.pszHeaderSubTitle = szSubHeading;

            if (_wp[i].pfnCallback)
            {
                psp.dwFlags |= PSP_USECALLBACK;
                psp.pfnCallback = _wp[i].pfnCallback;
            }

            _aWizPages[i] = CreatePropertySheetPage(&psp);
            hr = _aWizPages[i] ? S_OK:E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CPublishingWizard::AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages)
{ 
    // create our pages and then copy the handles to the buffer

    HRESULT hr = _CreateWizardPages();
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < ARRAYSIZE(_aWizPages); i++)
        {
            aPages[i] = _aWizPages[i];
        }

        // we also leverage the HTML host for showing pages from the sites we are
        // interacting with.

        hr = CoCreateInstance(CLSID_WebWizardHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWebWizardExtension, &_pwwe));
        if (SUCCEEDED(hr))
        {

// NOTE: this site should be broken into a seperate object so we avoid any circular reference issues
// NOTE: there is code in websvc.cpp that attempts to break this by listening for the page 
// NOTE: destruction and then releasing its site.

            IUnknown_SetSite(_pwwe, (IObjectWithSite*)this);

            UINT nPages;
            if (SUCCEEDED(_pwwe->AddPages(&aPages[i], cPages-i, &nPages)))
            {
                i += nPages;
            }
        }

        *pnPages = i;           // the number of pages we added
    }
    return hr;
}


// navigation pages

STDMETHODIMP CPublishingWizard::GetFirstPage(HPROPSHEETPAGE *phPage)
{ 
    if (_dwFlags & SHPWHF_NOFILESELECTOR)
    {
        *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    }
    else
    {
        *phPage = _aWizPages[WIZPAGE_WHICHFILE];
    }
    return S_OK;
}

STDMETHODIMP CPublishingWizard::GetLastPage(HPROPSHEETPAGE *phPage)
{ 
    if (_fShownCustomLocation)
    {
        *phPage = _aWizPages[WIZPAGE_FRIENDLYNAME];
    }
    else
    {
        *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    }

    return S_OK;
}


// computer this pointers for the page objects

CPublishingWizard* CPublishingWizard::s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPublishingWizard*)ppsp->lParam;
    }
    return (CPublishingWizard*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// initialize a property in the property bag from an IUnknown pointer.

HRESULT CPublishingWizard::s_SetPropertyFromDisp(IPropertyBag *ppb, LPCWSTR pszID, IDispatch *pdsp)
{
    VARIANT var = { VT_DISPATCH };
    HRESULT hr = pdsp->QueryInterface(IID_PPV_ARG(IDispatch, &var.pdispVal));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Write(pszID, &var);
        VariantClear(&var);
    }
    return hr;
}


// get the resource map from the site, if we can get it then us it, otherwise
// we need to load the resouce map local to this DLL. 

HRESULT CPublishingWizard::_GetResourceMap(IResourceMap **pprm)
{
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_ResourceMap, IID_PPV_ARG(IResourceMap, pprm));
    if (FAILED(hr))
    {
        if (!_prm)
        {
            hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
            if (SUCCEEDED(hr))
            {
                hr = _prm->LoadResourceMap(TEXT("wizard"), _szProviderScope);
                if (SUCCEEDED(hr))
                {
                    hr = _prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));
                }
            }
        }
        else 
        {
            hr = _prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));
        }
    }
    return hr;
}


// handle loading resource map strings

HRESULT CPublishingWizard::_LoadMappedString(LPCTSTR pszDlgID, LPCTSTR pszResourceID, LPTSTR pszBuffer, int cch)
{
    IResourceMap *prm;
    HRESULT hr = _GetResourceMap(&prm);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = prm->SelectResourceScope(TEXT("dialog"), pszDlgID, &pdn);
        if (SUCCEEDED(hr))
        {
            hr = prm->LoadString(pdn, pszResourceID, pszBuffer, cch);
            pdn->Release();
        }
        prm->Release();
    }
    return hr;
}

void CPublishingWizard::_MapDlgItemText(HWND hwnd, UINT idc, LPCTSTR pszDlgID, LPCTSTR pszResourceID)
{
    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(_LoadMappedString(pszDlgID, pszResourceID, szBuffer, ARRAYSIZE(szBuffer))))
    {
        SetDlgItemText(hwnd, idc, szBuffer);
    }
}


// Set the wizard next (index to hpage translation)

INT_PTR CPublishingWizard::_WizardNext(HWND hwnd, int iPage)
{
    PropSheet_SetCurSel(GetParent(hwnd), _aWizPages[iPage], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    return TRUE;
}


// get a provider key from the registry

HRESULT CPublishingWizard::_GetProviderKey(HKEY hkBase, DWORD dwAccess, LPCTSTR pszSubKey, HKEY *phkResult)
{
    TCHAR szBuffer[MAX_PATH];
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), (SZ_REGKEY_PUBWIZ TEXT("\\%s")), _szProviderScope);

    if (pszSubKey)
    {
        StrCatBuff(szBuffer, TEXT("\\"), ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, pszSubKey, ARRAYSIZE(szBuffer));
    }

    DWORD dwResult = RegOpenKeyEx(hkBase, szBuffer, 0, dwAccess, phkResult);
    if ((dwResult != ERROR_SUCCESS) && (dwAccess != KEY_READ))
    {
        dwResult = RegCreateKeyEx(hkBase, szBuffer, 0, NULL, REG_OPTION_NON_VOLATILE, dwAccess, NULL, phkResult, NULL);
    }

    return (ERROR_SUCCESS == dwResult) ? S_OK:E_FAIL;
}


// compute the site URL based on the stored information we have
// Enable this only for testing purposes. Allows registry to override manifest location. #define USE_REGISTRY_BASED_URL
HRESULT CPublishingWizard::_GetSiteURL(LPTSTR pszBuffer, int cchBuffer, LPCTSTR pszFilenameToCombine)
{
    DWORD cch = cchBuffer;
#ifdef USE_REGISTRY_BASED_URL
    WCHAR szURL[INTERNET_MAX_URL_LENGTH] = {0};
    DWORD cbURL = sizeof (szURL);
    SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_PUBWIZ, L"ProviderUrl", NULL, szURL, &cbURL);
    if (*szURL)
    {
        return UrlCombine(szURL, pszFilenameToCombine, pszBuffer, &cch, 0);
    }
#endif

    return UrlCombine(TEXT("http://shell.windows.com/publishwizard/"), pszFilenameToCombine, pszBuffer, &cch, 0);
}


// get the data object from the site that we have

CLIPFORMAT g_cfHIDA = 0;

void InitClipboardFormats()
{
    if (g_cfHIDA == 0)
        g_cfHIDA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
}


// DPA helpers for comparing and destroying a TRANSFERITEM structure

int CALLBACK CPublishingWizard::s_CompareItems(TRANSFERITEM *pti1, TRANSFERITEM *pti2, CPublishingWizard *ppw)
{
    return StrCmpI(pti1->szFilename, pti2->szFilename);
}

int _FreeFormData(FORMDATA *pfd, void *pvState)
{
    VariantClear(&pfd->varName);
    VariantClear(&pfd->varValue);
    return 1;
}

int _FreeTransferItems(TRANSFERITEM *pti, void *pvState)
{
    ILFree(pti->pidl);

    if (pti->psi)
        pti->psi->Release();

    if (pti->pstrm)
        pti->pstrm->Release();

    if (pti->dsaFormData != NULL)
        pti->dsaFormData.DestroyCallback(_FreeFormData, NULL);

    LocalFree(pti);
    return 1;
}

HRESULT CPublishingWizard::_AddCommonItemInfo(IXMLDOMNode *pdn, TRANSFERITEM *pti)
{
    // default to the user selected resize (this will only be set if
    // we are using the Web Publishing Wizard).

    if (_ro != RESIZE_NONE)
    {
        pti->fResizeOnUpload = TRUE;
        pti->cxResize = _aResizeSettings[_ro].cx;
        pti->cyResize = _aResizeSettings[_ro].cy;
        pti->iQuality = _aResizeSettings[_ro].iQuality;
    }

    // give the site ultimate control over the resizing that is performed,
    // by checking for the <resize/> element in the manifest.

    IXMLDOMNode *pdnResize;
    HRESULT hr = pdn->selectSingleNode(ELEMENT_RESIZE, &pdnResize);
    if (hr == S_OK)
    {
        int cx, cy, iQuality;

        hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_CX, &cx);
        if (SUCCEEDED(hr))
            hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_CY, &cy);
        if (SUCCEEDED(hr))
            hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_QUALITY, &iQuality);
        
        if (SUCCEEDED(hr))
        {
            pti->fResizeOnUpload = TRUE;
            pti->cxResize = cx;
            pti->cyResize = cy;
            pti->iQuality = iQuality;
        }

        pdnResize->Release();
    }

    return S_OK;
}

HRESULT CPublishingWizard::_AddTransferItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn)
{
    HRESULT hr = E_OUTOFMEMORY;
    TRANSFERITEM *pti = (TRANSFERITEM*)LocalAlloc(LPTR, sizeof(*pti));
    if (pti)
    {
        // copy the destination, and then the IDLIST for the item without 
        // that we cannot push the file.

        hr = GetStrFromAttribute(pdn, ATTRIBUTE_DESTINATION, pti->szFilename, ARRAYSIZE(pti->szFilename));
        if (SUCCEEDED(hr))
        {
            int iItem;
            hr = GetIntFromAttribute(pdn, ATTRIBUTE_ID, &iItem);
            if (SUCCEEDED(hr))
            {
                if ((iItem >= 0) && (iItem < (int)_cItems))
                {
                    hr = SHILClone(_aItems[iItem], &pti->pidl);
                }
                else
                {
                    hr = E_INVALIDARG;              // index is invalid, therefore can't handle item.
                }                 
            }
        }   

        // lets add the common transfer item info
        if (SUCCEEDED(hr))
            hr = _AddCommonItemInfo(pdn, pti);

        // if we have a structure then lets append it to the DPA
        if (SUCCEEDED(hr))
            hr = (-1 == pdpaItems->AppendPtr(pti)) ? E_OUTOFMEMORY:S_OK;

        // failed
        if (FAILED(hr))
        {
            _FreeTransferItems(pti);
        }
    }
    return hr;
}

HRESULT CPublishingWizard::_AddPostItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn)
{
    HRESULT hr = E_OUTOFMEMORY;
    TRANSFERITEM *pti = (TRANSFERITEM*)LocalAlloc(LPTR, sizeof(*pti));
    if (pti)
    {
        // get the post data, from this we can work out how to post the data
        IXMLDOMNode *pdnPostData;
        if (pdn->selectSingleNode(ELEMENT_POSTDATA, &pdnPostData) == S_OK)
        {
            // we must have a HREF for the post value
            hr = GetStrFromAttribute(pdnPostData, ATTRIBUTE_HREF, pti->szURL, ARRAYSIZE(pti->szURL));
            if (SUCCEEDED(hr))
            {
                // we must be able to get a posting name from the element
                hr = GetStrFromAttribute(pdnPostData, ATTRIBUTE_NAME, pti->szName, ARRAYSIZE(pti->szName));
                if (SUCCEEDED(hr))
                {
                    // lets get the posting name, we get that from the filename attribute, if that
                    // is not defined then try and compute it from the source information
                    // if that isn't defined the use the name attribute they gave us earlier.

                    if (FAILED(GetStrFromAttribute(pdnPostData, ATTRIBUTE_FILENAME, pti->szFilename, ARRAYSIZE(pti->szFilename))))
                    {
                        TCHAR szSource[MAX_PATH];
                        if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_SOURCE, szSource, ARRAYSIZE(szSource))))
                        {
                            StrCpyN(pti->szFilename, PathFindFileName(szSource), ARRAYSIZE(pti->szFilename));
                        }
                        else
                        {
                            StrCpyN(pti->szFilename, pti->szName, ARRAYSIZE(pti->szFilename));
                        }
                    }

                    // lets get the verb we should be using (and default accordingly), therefore
                    // we can ignore the result.

                    StrCpyN(pti->szVerb, TEXT("POST"), ARRAYSIZE(pti->szVerb));
                    GetStrFromAttribute(pdnPostData, ATTRIBUTE_VERB, pti->szVerb, ARRAYSIZE(pti->szVerb));

                    // pick up the IDLIST for the item

                    int iItem;
                    hr = GetIntFromAttribute(pdn, ATTRIBUTE_ID, &iItem);
                    if (SUCCEEDED(hr))
                    {
                        hr = SHILClone(_aItems[iItem], &pti->pidl);
                    }

                    // do we have any form data that needs to be passed to the transfer engine
                    // and therefore to the site.  if so lets package it up now.

                    IXMLDOMNodeList *pnl;
                    if (SUCCEEDED(hr) && (S_OK == pdnPostData->selectNodes(ELEMENT_FORMDATA, &pnl)))
                    {
                        hr = pti->dsaFormData.Create(4) ? S_OK:E_FAIL;
                        if (SUCCEEDED(hr))
                        {
                            // walk the selection filling the DSA, each structure contains
                            // two VARIANTs which we can push across to the bg thread describing the
                            // form data we want the site to receive.

                            long cSelection;
                            hr = pnl->get_length(&cSelection);
                            for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
                            {
                                IXMLDOMNode *pdnFormData;
                                hr = pnl->get_item(lNode, &pdnFormData);
                                if (SUCCEEDED(hr))
                                {
                                    FORMDATA fd = {0};

                                    hr = pdnFormData->get_nodeTypedValue(&fd.varValue);
                                    if (SUCCEEDED(hr))
                                    {
                                        IXMLDOMElement *pdelFormData;
                                        hr = pdnFormData->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelFormData));
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = pdelFormData->getAttribute(ATTRIBUTE_NAME, &fd.varName);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = (-1 == pti->dsaFormData.AppendItem(&fd)) ? E_FAIL:S_OK;
                                            }
                                            pdelFormData->Release();
                                        }
                                    }

                                    // failed to fully create the form data, so lets release
                                    if (FAILED(hr))
                                        _FreeFormData(&fd, NULL);

                                    pdnFormData->Release();
                                }
                            }
                            pnl->Release();
                        }
                    }
                }
            }
        }   
        else
        {
            hr = E_FAIL;
        }

        // lets add the common transfer item info
        if (SUCCEEDED(hr))
            hr = _AddCommonItemInfo(pdn, pti);

        // if we have a structure then lets append it to the DPA
        if (SUCCEEDED(hr))
            hr = (-1 == pdpaItems->AppendPtr(pti)) ? E_OUTOFMEMORY:S_OK;

        // failed
        if (FAILED(hr))
            _FreeTransferItems(pti);
    }
    return hr;
}


HRESULT CPublishingWizard::_InitTransferInfo(IXMLDOMDocument *pdocManifest, TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems)
{
    // pull the destination and shortcut information from the manifest into the 
    // transfer info structure.

    IXMLDOMNode *pdn;
    HRESULT hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
    if (SUCCEEDED(hr))
    {
        if (hr == S_OK)
        {
            // get the friendly name for the site, this is stored in the upload information, this can fail.

            if (FAILED(GetStrFromAttribute(pdn, ATTRIBUTE_FRIENDLYNAME, pti->szSiteName, ARRAYSIZE(pti->szSiteName))))
            {
                // B2: handle this so that MSN still works, we moved the friendly name attribute to
                //     a to the <uploadinfo/> element, however they were locked down and couldn't take
                //     that change, therefore ensure that we pick this up from its previous location.

                IXMLDOMNode *pdnTarget;
                if (S_OK == pdn->selectSingleNode(ELEMENT_TARGET, &pdnTarget))
                {
                    GetStrFromAttribute(pdnTarget, ATTRIBUTE_FRIENDLYNAME, pti->szSiteName, ARRAYSIZE(pti->szSiteName));
                    pdnTarget->Release();
                }
            }

            // from the manifest lets read the file location and then the net place creation information
            // this is then placed into the transfer info strucuture which we used on the bg thread
            // to both upload the files and also create a net place.

            if (FAILED(GetURLFromElement(pdn, ELEMENT_TARGET, pti->szFileTarget, ARRAYSIZE(pti->szFileTarget))))
            {
                pti->fUsePost = TRUE; // if we don't get the target string then we are posting
            }

            // we have the target for upload to, then lets pick up the optional information about
            // the site, and the net place.

            if (SUCCEEDED(GetURLFromElement(pdn, ELEMENT_NETPLACE, pti->szLinkTarget, ARRAYSIZE(pti->szLinkTarget))))
            {
                IXMLDOMNode *pdnNetPlace;
                if (pdn->selectSingleNode(ELEMENT_NETPLACE, &pdnNetPlace) == S_OK)
                {
                    GetStrFromAttribute(pdnNetPlace, ATTRIBUTE_FILENAME, pti->szLinkName, ARRAYSIZE(pti->szLinkName));
                    GetStrFromAttribute(pdnNetPlace, ATTRIBUTE_COMMENT, pti->szLinkDesc, ARRAYSIZE(pti->szLinkDesc));
                    pdnNetPlace->Release();
                }

                // fix up the site name from the link description if its not defined.

                if (!pti->szSiteName[0] && pti->szLinkDesc)
                {
                    StrCpyN(pti->szSiteName, pti->szLinkDesc, ARRAYSIZE(pti->szSiteName));
                }
            }

            // get the site URL
            GetURLFromElement(pdn, ELEMENT_HTMLUI, pti->szSiteURL, ARRAYSIZE(pti->szSiteURL));
        }
        else
        {
            hr = E_FAIL;
        }
    }

    // if they want a DPA of items then lets create them one, this is also based on the manifest.

    if (SUCCEEDED(hr) && pdpaItems)
    {
        hr = (pdpaItems->Create(16)) ? S_OK:E_OUTOFMEMORY;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList *pnl;
            hr = pdocManifest->selectNodes(XPATH_ALLFILESTOUPLOAD, &pnl);
            if (hr == S_OK)
            {
                long cSelection;
                hr = pnl->get_length(&cSelection);
                for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
                {
                    IXMLDOMNode *pdn;
                    hr = pnl->get_item(lNode, &pdn);
                    if (SUCCEEDED(hr))
                    {
                        if (pti->fUsePost)
                            hr = _AddPostItem(pdpaItems, pdn);
                        else
                            hr = _AddTransferItem(pdpaItems, pdn);

                        pdn->Release();
                    }
                }
                pnl->Release();
            }

            // if we are *NOT* posting then sort the DPA so that we can support 
            // enum items correctly.

            if (!pti->fUsePost)
            {
                pdpaItems->SortEx(s_CompareItems, this);             // sort the DPA so we can search better
            }
        }
    }

    return hr;
}


// File selector dialog

HRESULT CPublishingWizard::IncludeObject(IShellView *ppshv, LPCITEMIDLIST pidl)
{
    BOOL fInclude = FALSE;

    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetIDListFromUnk(ppshv, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
        if (SUCCEEDED(hr))
        {
            // cannot publish folders, but can publish ZIP files (which are both folder and stream at the same time)
            if (!(SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER))
            {
                // filter based on the content type if we are given a filter string
                if (_szFilter[0])
                {
                    TCHAR szBuffer[MAX_PATH];
                    hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szBuffer, ARRAYSIZE(szBuffer));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szContentType[MAX_PATH];
                        DWORD cch = ARRAYSIZE(szContentType);
                        hr = AssocQueryString(0, ASSOCSTR_CONTENTTYPE, szBuffer, NULL, szContentType, &cch);
                        fInclude = SUCCEEDED(hr) && PathMatchSpec(szContentType, _szFilter);
                    }
                }
                else
                {
                    fInclude = TRUE;
                }
            }
            psf->Release();
        }
        ILFree(pidlFolder);
    }

    return fInclude ? S_OK:S_FALSE;
}


// handle the state changing in the dialog and therefore us updating the buttons & status

void CPublishingWizard::_StateChanged()
{
    int cItemsChecked = 0;
    int cItems = 0;

    if (_pfv)
    {
        _pfv->ItemCount(SVGIO_ALLVIEW, &cItems);
        _pfv->ItemCount(SVGIO_CHECKED, &cItemsChecked);
    }

    // format and display the status bar for this item

    TCHAR szFmt[MAX_PATH];
    if (FAILED(_LoadMappedString(L"wp:selector", L"countfmt", szFmt, ARRAYSIZE(szFmt))))
    {
        LoadString(g_hinst, IDS_PUB_SELECTOR_FMT, szFmt, ARRAYSIZE(szFmt));
    }

    TCHAR szBuffer[MAX_PATH];
    FormatMessageTemplate(szFmt, szBuffer, ARRAYSIZE(szBuffer), cItemsChecked, cItems);
    SetDlgItemText(_hwndSelector, IDC_PUB_SELECTORSTATUS, szBuffer);

    // ensure that Next is only enabled when we have checked some items in the view
    PropSheet_SetWizButtons(GetParent(_hwndSelector), ((cItemsChecked > 0) ? PSWIZB_NEXT:0) | PSWIZB_BACK);
}

HRESULT CPublishingWizard::OnStateChange(IShellView *pshv, ULONG uChange)
{
    if (uChange == CDBOSC_STATECHANGE)
    {
        _StateChanged();
        _fRecomputeManifest = TRUE;
    }
    return S_OK;
}


UINT CPublishingWizard::s_SelectorPropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    CPublishingWizard *ppw = (CPublishingWizard*)ppsp->lParam;
    switch (uMsg)
    {
        case PSPCB_CREATE:
            return TRUE;

        // we are cleaning up the page, lets ensure that we release file view object
        // if we have one.  that way our reference count correctly reflects our state
        // rather than us ending up with a circular reference to other objects

        case PSPCB_RELEASE:
            if (ppw->_pfv)
            {
                IUnknown_SetSite(ppw->_pfv, NULL);
                ATOMICRELEASE(ppw->_pfv);
            }
            break;
    }
    return FALSE;
}

INT_PTR CPublishingWizard::_SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndSelector = hwnd;

            // lets read the default state for this provider from a key in the registry
            // this will define the types of files we are going to allow, the format is
            // a spec (eg. image/* means all images), each element can be seperated by a ;

            HKEY hkProvider;
            HRESULT hr = _GetProviderKey(HKEY_LOCAL_MACHINE, KEY_READ, NULL, &hkProvider);
            if (SUCCEEDED(hr))
            {
                DWORD cbFilter = sizeof(TCHAR)*ARRAYSIZE(_szFilter);
                SHGetValue(hkProvider, NULL, SZ_REGVAL_FILEFILTER, NULL, _szFilter, &cbFilter);
                RegCloseKey(hkProvider);
            }

            // create the file picker object, align with the hidden control on the window
            // and initialize with the IDataObject which contains the selection.

            hr = CoCreateInstance(CLSID_FolderViewHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IFolderView, &_pfv));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_pfv, (IObjectWithSite*)this);

                IFolderViewHost *pfvh;
                hr = _pfv->QueryInterface(IID_PPV_ARG(IFolderViewHost, &pfvh));
                if (SUCCEEDED(hr))
                {
                    RECT rc;
                    GetWindowRect(GetDlgItem(hwnd, IDC_PUB_SELECTOR), &rc);
                    MapWindowRect(HWND_DESKTOP, hwnd, &rc);

                    InitClipboardFormats(); // initialize walks data object
                    hr = pfvh->Initialize(hwnd, _pdo, &rc);
                    if (SUCCEEDED(hr))
                    {
                        HWND hwndPicker;
                        hr = IUnknown_GetWindow(_pfv, &hwndPicker);
                        if (SUCCEEDED(hr))
                        {
                            SetWindowPos(hwndPicker, HWND_TOP, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE);
                        }
                    }
                    pfvh->Release();
                }

                if (FAILED(hr))
                {
                    ATOMICRELEASE(_pfv);
                }
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PUB_ALL:
                    case IDC_PUB_NOTHING:
                        if (_pfv)
                        {
                            int cItems;
                            HRESULT hr = _pfv->ItemCount(SVGIO_ALLVIEW, &cItems);            
                            for (int iItem = 0; SUCCEEDED(hr) && (iItem != cItems); iItem++)
                            {
                                BOOL fSelect = (LOWORD(wParam) == IDC_PUB_ALL);
                                hr = _pfv->SelectItem(iItem, SVSI_NOSTATECHANGE | (fSelect ? SVSI_CHECK:0));
                            }
                            break;
                        }
                }
                break;
            }
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    if (_pfv)
                    {
                        _StateChanged();
                        PostMessage(hwnd, WM_APP, 0, 0);
                    }
                    else
                    {
                        // no IFolderView, so lets skip this page.
                        int i = PropSheet_PageToIndex(GetParent(hwnd), _aWizPages[WIZPAGE_FETCHINGPROVIDERS]);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)PropSheet_IndexToId(GetParent(hwnd), i));
                    }
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    if (_fRecomputeManifest && _pfv)
                    {
                        IDataObject *pdo;
                        HRESULT hr = _pfv->Items(SVGIO_CHECKED, IID_PPV_ARG(IDataObject, &pdo));
                        if (SUCCEEDED(hr))
                        {
                            IUnknown_Set((IUnknown**)&_pdoSelection, pdo); 
                            pdo->Release();
                        }
                    }
                    return _WizardNext(hwnd, WIZPAGE_FETCHINGPROVIDERS);
                }

                case PSN_WIZBACK:
                {
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                            }
                            pws->Release();
                        }
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }

        // this is to work around the issue where defview (listview) forces a redraw of itself
        // in a non-async way when it receives a SetFocus, therefore causing it to render
        // incorrectly in the wizard frame.  to fix this we post ourselves a WM_APP during the
        // handle of PSN_SETACTIVE, and then turn around and call RedrawWindow.

        case WM_APP:
        {
            HWND hwndPicker;
            if (SUCCEEDED(IUnknown_GetWindow(_pfv, &hwndPicker)))
            {
                RedrawWindow(hwndPicker, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            }
            break;
        }
    }
    return FALSE;
}


// tidy up and release the providers list

void CPublishingWizard::_FreeProviderList()
{   
    if (_pdscProviders)
        _pdscProviders->Advise(FALSE);

    IUnknown_Set((IUnknown**)&_pdscProviders, NULL);
    IUnknown_Set((IUnknown**)&_pdocProviders, NULL);            // discard the previous providers.
}


// begin a download of the provider list, we pull the providers list async from the server
// therefore we need to register a state change monitor so that we can pull the information
// dynamically and then receive a message to merge in our extra data.

#define FETCH_TIMERID 1
#define FETCH_TIMEOUT 1000

HRESULT CPublishingWizard::_GeoFromLocaleInfo(LCID lcid, GEOID *pgeoID)
{
    TCHAR szBuf[128] = {0};
    if (GetLocaleInfo(lcid, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, ARRAYSIZE(szBuf)) > 0)
    {
        *pgeoID = *((LPDWORD)szBuf);
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CPublishingWizard::_GetProviderListFilename(LPTSTR pszFile, int cchFile)
{
    HRESULT hr = S_OK;

    GEOID idGEO = GetUserGeoID(GEOCLASS_NATION);
    if (idGEO == GEOID_NOT_AVAILABLE)
    {
        hr = _GeoFromLocaleInfo(GetUserDefaultLCID(), &idGEO);
        if (FAILED(hr))
            hr = _GeoFromLocaleInfo(GetSystemDefaultLCID(), &idGEO);
        if (FAILED(hr))
            hr = _GeoFromLocaleInfo((MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)), &idGEO); // default to US English
    }

    if (SUCCEEDED(hr) && (idGEO != GEOID_NOT_AVAILABLE))
    {
        // read the provider prefix from the registry
    
        int cchProvider = 0;
        DWORD cbFile = sizeof(TCHAR)*cchFile;
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_PUBWIZ, SZ_REGVAL_SERVICEPARTNERID, NULL, pszFile, &cbFile))
        {
            StrCatBuff(pszFile, TEXT("."), cchFile);
            cchProvider = lstrlen(pszFile);
        }        

        // build <contrycode>.xml into the buffer (as a suffix of the partner if needed)

        GetGeoInfo(idGEO, GEO_ISO3, pszFile + cchProvider, cchFile - cchProvider, 0);
        StrCatBuff(pszFile, TEXT(".xml"), cchFile);
        CharLowerBuff(pszFile, lstrlen(pszFile));
    }
    else if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CPublishingWizard::_FetchProviderList(HWND hwnd)
{    
    _FreeProviderList();
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DISABLED_BY_POLICY);
    if (!SHRestricted(REST_NOWEBSERVICES))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocProviders));
        if (SUCCEEDED(hr))
        {
            TCHAR szFile[MAX_PATH];
            hr = _GetProviderListFilename(szFile, ARRAYSIZE(szFile));
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[INTERNET_MAX_URL_LENGTH];                
                hr = _GetSiteURL(szBuffer, ARRAYSIZE(szBuffer), szFile);
                if (SUCCEEDED(hr))
                {
                    LaunchICW();

                    if (InternetGoOnline(szBuffer, hwnd, 0))
                    {
                        _pdscProviders = new CXMLDOMStateChange(_pdocProviders, hwnd);
                        if (_pdscProviders)
                        {
                            hr = _pdscProviders->Advise(TRUE);
                            if (SUCCEEDED(hr))
                            {
                                VARIANT varName;
                                hr = InitVariantFromStr(&varName, szBuffer);
                                if (SUCCEEDED(hr))
                                {
                                    VARIANT_BOOL fSuccess;
                                    hr = _pdocProviders->load(varName, &fSuccess);
                                    if (FAILED(hr) || (fSuccess != VARIANT_TRUE))
                                    {
                                        hr = FAILED(hr) ? hr:E_FAIL;
                                    }
                                    VariantClear(&varName);
                                }
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
    }

    // if any of this failed then lets post ourselves the completed message 
    // with the failure code, at which point we can then load the default document.

    if (FAILED(hr))
        PostMessage(hwnd, MSG_XMLDOC_COMPLETED, 0, (LPARAM)hr);                   

    return hr;
}

void CPublishingWizard::_FetchComplete(HWND hwnd, HRESULT hr)
{
    // if we failed to load the document then lets pull in the default provider
    // list from our DLL, this can also fail, but its unlikely to.  we recreate
    // the XML DOM object to ensure our state is pure.

    _fUsingTemporaryProviders = FAILED(hr);         
    _fRepopulateProviders = TRUE;               // provider list will have changed!

    if (FAILED(hr))
    {
        _FreeProviderList();
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocProviders));
        if (SUCCEEDED(hr))
        {
            VARIANT varName;
            hr = InitVariantFromStr(&varName, TEXT("res://netplwiz.dll/xml/providers.xml"));
            if (SUCCEEDED(hr))
            {
                VARIANT_BOOL fSuccess = VARIANT_FALSE;
                hr = _pdocProviders->load(varName, &fSuccess);
                if (FAILED(hr) || (fSuccess != VARIANT_TRUE))
                {
                    hr = FAILED(hr) ? hr:E_FAIL;
                }
                VariantClear(&varName);
            }
        }
    }

    KillTimer(hwnd, FETCH_TIMERID);
    _ShowHideFetchProgress(hwnd, FALSE);
    _WizardNext(hwnd, WIZPAGE_PROVIDERS);
}

void CPublishingWizard::_ShowHideFetchProgress(HWND hwnd, BOOL fShow)
{
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS), fShow ? SW_SHOW:SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC1), fShow ? SW_SHOW:SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC2), fShow ? SW_SHOW:SW_HIDE);
    SendDlgItemMessage(hwnd, IDC_PUB_SRCHPROVIDERS, PBM_SETMARQUEE, (WPARAM)fShow, 0);
}

INT_PTR CPublishingWizard::_FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _MapDlgItemText(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC1, L"wp:destination", L"downloading");
            break;

        case MSG_XMLDOC_COMPLETED:
            _FetchComplete(hwnd, (HRESULT)lParam);
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fFetch = TRUE;
                    if (_pdocProviders && !_fUsingTemporaryProviders)
                    {
                        long lReadyState;
                        HRESULT hr = _pdocProviders->get_readyState(&lReadyState);
                        if (SUCCEEDED(hr) && (lReadyState == XMLDOC_COMPLETED))
                        {
                            _WizardNext(hwnd, WIZPAGE_PROVIDERS);
                            fFetch = FALSE;
                        }
                    }
                    
                    if (fFetch)
                    {                        
                        SetTimer(hwnd, FETCH_TIMERID, FETCH_TIMEOUT, NULL);
                        _FetchProviderList(hwnd);
                        PropSheet_SetWizButtons(GetParent(hwnd), 0x0);
                    }
                    return TRUE;
                }
            }
            break;
        }

        case WM_TIMER:
        {
            KillTimer(hwnd, FETCH_TIMERID);
            _ShowHideFetchProgress(hwnd, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}



// Destination page

int CPublishingWizard::_GetSelectedItem(HWND hwndList)
{
    int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_FOCUSED|LVNI_SELECTED);
    if (iSelected == -1)
    {
        iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    }
    return iSelected;
}

void CPublishingWizard::_ProviderEnableNext(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_BACK;
    
    // there must be an item available in the list, and it must have a ID property defined
    // for it so it can be enabled.

    int iSelected = _GetSelectedItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS));
    if (iSelected != -1)
    {
        LVITEM lvi = { 0 };
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;

        if (ListView_GetItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &lvi))
        {
            IXMLDOMNode *pdn = (IXMLDOMNode*)lvi.lParam;
            TCHAR szID[INTERNET_MAX_URL_LENGTH];                
            if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ID, szID, ARRAYSIZE(szID))))
            {
                dwButtons |= PSWIZB_NEXT;
            }
        }
    }

    PropSheet_SetWizButtons(GetParent(hwnd), dwButtons);
}


// extract an icon resource from the provider XML documents.  the icons are stored as
// mime encoded bitmaps that we decode into files in the users settings folder.  we return
// an index to the shared image list.

int CPublishingWizard::_GetRemoteIcon(LPCTSTR pszID, BOOL fCanRefresh)
{
    int iResult = -1;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];                
    HRESULT hr = _GetSiteURL(szURL, ARRAYSIZE(szURL), pszID);
    if (SUCCEEDED(hr))
    {
        TCHAR szFilename[MAX_PATH];
        hr = URLDownloadToCacheFile(NULL, szURL, szFilename, ARRAYSIZE(szFilename), 0x0, NULL);
        if (SUCCEEDED(hr))
        {
            iResult = Shell_GetCachedImageIndex(szFilename, 0x0, 0x0);
        }
    }

    return iResult;
}


// get the provider list from the internet

struct 
{
    LPTSTR pszAttribute;
    BOOL fIsString;
}
aProviderElements[] =
{
    { ATTRIBUTE_SUPPORTEDTYPES, FALSE },
    { ATTRIBUTE_REQUIRESWEBDAV, FALSE },
    { ATTRIBUTE_DISPLAYNAME,    TRUE },
    { ATTRIBUTE_DESCRIPTION,    TRUE },
    { ATTRIBUTE_HREF,           FALSE },
    { ATTRIBUTE_ICONPATH,       FALSE },
    { ATTRIBUTE_ICON,           FALSE },
};

HRESULT CPublishingWizard::_MergeLocalProviders()
{
    TCHAR szBuffer[MAX_PATH];
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), FMT_PROVIDER, _szProviderScope);

    IXMLDOMNode *pdn;
    HRESULT hr = _pdocProviders->selectSingleNode(szBuffer, &pdn);
    if (hr == S_OK)
    {
        HKEY hk;
        hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_READ, SZ_REGVAL_ALTPROVIDERS, &hk);
        if (SUCCEEDED(hr))
        {
            for (int i =0; SUCCEEDED(hr) && (RegEnumKey(hk, i, szBuffer, ARRAYSIZE(szBuffer)) == ERROR_SUCCESS); i++)
            {
                // the manifest always overrides the entries that are stored in the registry,
                // therefore if there is an element in the document that has a matching ID to the
                // one in the registry then lets handle it.

                TCHAR szSelectValue[MAX_PATH];
                wnsprintf(szSelectValue, ARRAYSIZE(szSelectValue), TEXT("provider[@id=\"%s\"]"), szBuffer);
    
                IXMLDOMNode *pdnProvider;
                if (pdn->selectSingleNode(szSelectValue, &pdnProvider) == S_FALSE)
                {
                    IPropertyBag *ppb;
                    hr = SHCreatePropertyBagOnRegKey(hk, szBuffer, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb));
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMElement *pdel;
                        hr = _pdocProviders->createElement(ELEMENT_PROVIDER, &pdel);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetAttributeFromStr(pdel, ATTRIBUTE_ID, szBuffer);
                            if (SUCCEEDED(hr))
                            {
                                // loop and replicate all the attributes from the property bag 
                                // into the element.  once we have done that we can add
                                // the element to the provider list.

                                for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(aProviderElements)); i++)
                                {
                                    VARIANT var = {0};
                                    if (SUCCEEDED(ppb->Read(aProviderElements[i].pszAttribute, &var, NULL)))
                                    {
                                        hr = pdel->setAttribute(aProviderElements[i].pszAttribute, var);
                                        VariantClear(&var);
                                    }
                                }
                                               
                                if (SUCCEEDED(hr))
                                {
                                    hr = pdn->appendChild(pdel, NULL);
                                }
                            }
                            pdel->Release();
                        }
                        ppb->Release();
                    }
                }
                else
                {
                    pdnProvider->Release();
                }
            }
            RegCloseKey(hk);
        }            
        pdn->Release();
    }
    return hr;
}

void CPublishingWizard::_GetDefaultProvider(LPTSTR pszProvider, int cch)
{
    HKEY hk;
    HRESULT hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_READ, NULL, &hk);
    if (SUCCEEDED(hr))
    {
        DWORD cb = cch*sizeof(*pszProvider);
        SHGetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDER, NULL, pszProvider, &cb);
        RegCloseKey(hk);
    }
}

void CPublishingWizard::_SetDefaultProvider(IXMLDOMNode *pdn)
{
    TCHAR szProvider[MAX_PATH];
    HRESULT hr = GetStrFromAttribute(pdn, ATTRIBUTE_ID, szProvider, ARRAYSIZE(szProvider));
    if (SUCCEEDED(hr))
    {
        HKEY hk;
        hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_WRITE, NULL, &hk);
        if (SUCCEEDED(hr))
        {
            // store the default provider value
            DWORD cb = (lstrlen(szProvider)+1)*sizeof(*szProvider);
            SHSetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDER, REG_SZ, szProvider, cb);

            // we now need to replicate the properties from the DOM into the registry so that 
            // the user can always get to the specified site.  to make this easier we 
            // will create a property bag that we will copy values using.

            TCHAR szBuffer[MAX_PATH];
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), (SZ_REGVAL_ALTPROVIDERS TEXT("\\%s")), szProvider);

            IPropertyBag *ppb;
            hr = SHCreatePropertyBagOnRegKey(hk, szBuffer, STGM_CREATE | STGM_WRITE, IID_PPV_ARG(IPropertyBag, &ppb));
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement *pdel;
                hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(aProviderElements)); i++)
                    {
                        VARIANT varEmpty = {0}; // VT_EMPTY
                        if (aProviderElements[i].fIsString)
                        {
                            hr = _GetProviderString(pdn, aProviderElements[i].pszAttribute, szBuffer, ARRAYSIZE(szBuffer));
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropertyBag_WriteStr(ppb, aProviderElements[i].pszAttribute, szBuffer);
                            }
                            else
                            {
                                // clear out any old value for this attribute that may be stored in the registry
                                ppb->Write(aProviderElements[i].pszAttribute, &varEmpty);
                            }
                        }
                        else
                        {
                            VARIANT var = {0};
                            if (S_OK == pdel->getAttribute(aProviderElements[i].pszAttribute, &var))
                            {
                                hr = ppb->Write(aProviderElements[i].pszAttribute, &var);
                                VariantClear(&var);
                            }
                            else
                            {
                                // clear out any old value for this attribute that may be stored in the registry
                                ppb->Write(aProviderElements[i].pszAttribute, &varEmpty);
                            }
                        }
                    }
                    pdel->Release();
                }
                ppb->Release();
            }

            RegCloseKey(hk);
        }
    }
}


// load a localized string from the XML node for the provider

HRESULT CPublishingWizard::_GetProviderString(IXMLDOMNode *pdn, USHORT idPrimary, USHORT idSub, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("strings[@langid='%04x']/string[@id='%s'][@langid='%04x']"), idPrimary, pszID, idSub);

    IXMLDOMNode *pdnString;
    HRESULT hr = pdn->selectSingleNode(szPath, &pdnString);
    if (hr == S_OK)
    {
        VARIANT var = {VT_BSTR};
        hr = pdnString->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdnString->Release();
    }

    return hr;
}

HRESULT CPublishingWizard::_GetProviderString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    *pszBuffer = TEXT('\0');

    LANGID idLang = GetUserDefaultLangID();
    HRESULT hr = _GetProviderString(pdn, PRIMARYLANGID(idLang), SUBLANGID(idLang), pszID, pszBuffer, cch);
    if (hr == S_FALSE)
    {
        hr = _GetProviderString(pdn, PRIMARYLANGID(idLang), SUBLANG_NEUTRAL, pszID, pszBuffer, cch);
        if (hr == S_FALSE)
        {
            hr = _GetProviderString(pdn, LANG_NEUTRAL, SUBLANG_NEUTRAL, pszID, pszBuffer, cch);
            if (hr == S_FALSE)
            {
                hr = GetStrFromAttribute(pdn, pszID, pszBuffer, cch);
            }
        }
    }
    
    SHLoadIndirectString(pszBuffer, pszBuffer, cch, NULL);
    return hr;
}


// populate the provider list on the destination page

#define TILE_DISPLAYNAME    0
#define TILE_DESCRIPTION    1
#define TILE_MAX            1

const UINT c_auTileColumns[] = {TILE_DISPLAYNAME, TILE_DESCRIPTION};
const UINT c_auTileSubItems[] = {TILE_DESCRIPTION};

int CPublishingWizard::_AddProvider(HWND hwnd, IXMLDOMNode *pdn)
{
    // fill out the item information

    LV_ITEM lvi = { 0 };
    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
    lvi.iItem = ListView_GetItemCount(hwnd);            // always append!
    lvi.lParam = (LPARAM)pdn;  
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.iImage = -1;                                    // set to the default state

    // read the icon location and put that onto the item

    TCHAR szIcon[MAX_PATH];
    if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ICONPATH, szIcon, ARRAYSIZE(szIcon))))
    {
        int resid = PathParseIconLocation(szIcon);
        lvi.iImage =  Shell_GetCachedImageIndex(szIcon, resid, 0x0);
    }
    else if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ICON, szIcon, ARRAYSIZE(szIcon))))
    {
        lvi.iImage = _GetRemoteIcon(szIcon, TRUE);
    }   
    
    // if that failed then lets try and compute a sensible default icon for us to use

    if (lvi.iImage == -1)
    {
        // under the provider key for the install lets see if there is a default icon that we
        // should be using.  if not, or if that fails to extract then lets use the publishing one.

        HKEY hk;
        if (SUCCEEDED(_GetProviderKey(HKEY_LOCAL_MACHINE, KEY_READ, NULL, &hk)))
        {
            DWORD cb = ARRAYSIZE(szIcon)*sizeof(*szIcon);
            if (ERROR_SUCCESS == SHGetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDERICON, NULL, szIcon, &cb))
            {
                int resid = PathParseIconLocation(szIcon);
                lvi.iImage = Shell_GetCachedImageIndex(szIcon, resid, 0x0);         // default to the publishing icon
            }
            RegCloseKey(hk);
        }

        if (lvi.iImage == -1)
            lvi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), -244, 0x0);
    }

    int iResult = ListView_InsertItem(hwnd, &lvi);
    if (iResult != -1)
    {
        pdn->AddRef();                                  // it was added to the view, so take reference

        LVTILEINFO lvti;
        lvti.cbSize = sizeof(LVTILEINFO);
        lvti.iItem = iResult;
        lvti.cColumns = ARRAYSIZE(c_auTileSubItems);
        lvti.puColumns = (UINT*)c_auTileSubItems;
        ListView_SetTileInfo(hwnd, &lvti);
    }

    return iResult;
}

void CPublishingWizard::_PopulateProviderList(HWND hwnd)
{
    BOOL fWebDavAvailable = IsWebDavAvailable();
    HWND hwndList = GetDlgItem(hwnd, IDC_PUB_PROVIDERS);

    // setup the view with the tiles that we want to show and the
    // icon lists - shared with the shell.

    ListView_DeleteAllItems(hwndList);
    ListView_SetView(hwndList, LV_VIEW_TILE);

    for (int i=0; i<ARRAYSIZE(c_auTileColumns); i++)
    {
        LV_COLUMN col;
        col.mask = LVCF_SUBITEM;
        col.iSubItem = c_auTileColumns[i];
        ListView_InsertColumn(hwndList, i, &col);
    }

    RECT rc;
    GetClientRect(hwndList, &rc);

    LVTILEVIEWINFO lvtvi;
    lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
    lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
    lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    lvtvi.sizeTile.cx = RECTWIDTH(rc) - GetSystemMetrics(SM_CXVSCROLL);
    lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
    ListView_SetTileViewInfo(hwndList, &lvtvi);

    if (_pdocProviders)
    {
        long lReadyState;
        HRESULT hr = _pdocProviders->get_readyState(&lReadyState);
        if (SUCCEEDED(hr) && (lReadyState == XMLDOC_COMPLETED))
        {
            // lets merge in the local providers, these are local to this user,
            // we check for duplicates so this shouldn't present too much hardship.

            _MergeLocalProviders();

            // format a query to return the providers that match our publishing scope,
            // this will allow the wizard to show different lists of providers for
            // web publishing vs. internet printing

            WCHAR szBuffer[MAX_PATH];
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), FMT_PROVIDERS, _szProviderScope);

            IXMLDOMNodeList *pnl;
            hr = _pdocProviders->selectNodes(szBuffer, &pnl);
            if (hr == S_OK)
            {
                long cSelection;
                hr = pnl->get_length(&cSelection);
                if (SUCCEEDED(hr) && (cSelection > 0))
                {
                    // get the list of unique types from the selection we are going to try and publish

                    HDPA hdpaUniqueTypes = NULL;
                    _GetUniqueTypeList(FALSE, &hdpaUniqueTypes);      // don't care if this fails - ptr is NULL

                    // we need the default provider to highlight correctly, using this we can then 
                    // populate the list from the provider manfiest

                    TCHAR szDefaultProvider[MAX_PATH] = {0};
                    _GetDefaultProvider(szDefaultProvider, ARRAYSIZE(szDefaultProvider));

                    int iDefault = 0;
                    for (long lNode = 0; lNode != cSelection; lNode++)
                    {
                        IXMLDOMNode *pdn;
                        hr = pnl->get_item(lNode, &pdn);
                        if (SUCCEEDED(hr))
                        {
                            // filter based on the list of types they support, this is optional
                            // if they don't specify anything then they are in the list,
                            // otherwise the format is assumed to be a file spec, eg *.bmp;*.jpg; etc.

                            BOOL fSupported = TRUE;
                            if (hdpaUniqueTypes)
                            {
                                hr = GetStrFromAttribute(pdn, ATTRIBUTE_SUPPORTEDTYPES, szBuffer, ARRAYSIZE(szBuffer));
                                if (SUCCEEDED(hr))
                                {
                                    fSupported = FALSE;
                                    for (int i = 0; !fSupported && (i < DPA_GetPtrCount(hdpaUniqueTypes)); i++)
                                    {
                                        LPCTSTR pszExtension = (LPCTSTR)DPA_GetPtr(hdpaUniqueTypes, i);
                                        fSupported = PathMatchSpec(pszExtension, szBuffer);
                                    }                            
                                }
                            }

                            // If WebDav isn't installed, we don't support providers that require webdav
                            if (fSupported && !fWebDavAvailable)
                            {
                                hr = GetStrFromAttribute(pdn, ATTRIBUTE_REQUIRESWEBDAV, szBuffer, ARRAYSIZE(szBuffer));
                                if (SUCCEEDED(hr))
                                {
                                    fSupported = FALSE;
                                }
                            }

                            // if this is a supported item then lets add it to the list

                            if (fSupported)
                            {
                                 hr = GetStrFromAttribute(pdn, ATTRIBUTE_ID, szBuffer, ARRAYSIZE(szBuffer));
                                 if (SUCCEEDED(hr))
                                 {
                                     int i = _AddProvider(hwndList, pdn); 
                                     if ((i != -1) && (0 == StrCmpI(szBuffer, szDefaultProvider)))
                                     {
                                         iDefault = i;
                                     }
                                }
                            }

                            pdn->Release();
                        }
                    }

                    ListView_SetItemState(hwndList, iDefault, LVIS_SELECTED, LVIS_SELECTED);
                    ListView_EnsureVisible(hwndList, iDefault, FALSE);

                    if (hdpaUniqueTypes)
                        DPA_DestroyCallback(hdpaUniqueTypes, s_FreeStringProc, 0);
                }            
                else
                {
                    // we have no providers that match this criteria therefore lets
                    // create a dummy one which shows this to the caller

                    IXMLDOMElement *pdelProvider;
                    hr = _pdocManifest->createElement(ELEMENT_FILE, &pdelProvider);
                    if (SUCCEEDED(hr))
                    {
                        IResourceMap *prm;
                        hr = _GetResourceMap(&prm);
                        if (SUCCEEDED(hr))
                        {
                            // get the no providers string
                            if (FAILED(_LoadMappedString(L"wp:selector", L"noprovider", szBuffer, ARRAYSIZE(szBuffer))))
                                LoadString(g_hinst, IDS_PUB_NOPROVIDER, szBuffer, ARRAYSIZE(szBuffer));

                            hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_DISPLAYNAME, szBuffer);

                            // get the sub-text for the no providers
                            if (SUCCEEDED(hr))
                            {
                                if (FAILED(_LoadMappedString(L"wp:selector", L"noproviderdesc", szBuffer, ARRAYSIZE(szBuffer))))
                                    LoadString(g_hinst, IDS_PUB_NOPROVIDERDESC, szBuffer, ARRAYSIZE(szBuffer));
                                
                                hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_DESCRIPTION, szBuffer);
                            }

                            // lets put together a resource string for the icon we are going to show
                            if (SUCCEEDED(hr))
                            {
                                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("netplwiz.dll,-%d"), IDI_NOPROVIDERS);
                                hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_ICONPATH, szBuffer);
                            }

                            // lets add a provider from the free standing node
                            if (SUCCEEDED(hr))
                            {
                                IXMLDOMNode *pdnProvider;
                                hr = pdelProvider->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnProvider));
                                if (SUCCEEDED(hr))
                                {
                                    _AddProvider(hwndList, pdnProvider);
                                    pdnProvider->Release();
                                }
                            }

                            prm->Release();
                        }
                        pdelProvider->Release();
                    }
                }
                pnl->Release();
            }
        }
    }

    _fRepopulateProviders = FALSE;      // providers have been populated
}


// handle next in the provider (destination) page

HRESULT CPublishingWizard::_ProviderNext(HWND hwnd, HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_FAIL;
    int iSelected = _GetSelectedItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS));
    if (iSelected != -1)
    {
        LVITEM lvi = { 0 };
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;

        if (ListView_GetItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &lvi))
        {
            IXMLDOMNode *pdn = (IXMLDOMNode*)lvi.lParam;

            // set the default provider from the node value

            _SetDefaultProvider(pdn);

            // now try and navigate to the web page, if no URL then show advanced path

            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
            if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL))))
            {
                // get the folder creation flag from the site so that we can set the HTML wizard 
                // into the correct state.   note that the site doesn't need to specify this
                // and we will default to TRUE - eg. do folder creation, this allows the current
                // hosts to work without modification.

                hr = _InitPropertyBag(szURL);
                if (SUCCEEDED(hr))
                {
                    hr = _pwwe->GetFirstPage(phPage);
                }
            }
            else
            {
                // No URL was specified, so lets go through the advanced path where
                // the user gets to type a location and we create connection to that
                // (replaced the old Add Net Place functionality);

                *phPage = _aWizPages[WIZPAGE_LOCATION];
                hr = S_OK;
            }
        }
    }
    return hr;
}

void CPublishingWizard::_ProviderGetDispInfo(LV_DISPINFO *plvdi)
{
    if (plvdi->item.mask & LVIF_TEXT)
    {
        IXMLDOMNode *pdn = (IXMLDOMNode*)plvdi->item.lParam;
        switch (plvdi->item.iSubItem)
        {
            case TILE_DISPLAYNAME:
                _GetProviderString(pdn, ATTRIBUTE_DISPLAYNAME, plvdi->item.pszText, plvdi->item.cchTextMax);
                break;
            
            case TILE_DESCRIPTION:
                _GetProviderString(pdn, ATTRIBUTE_DESCRIPTION, plvdi->item.pszText, plvdi->item.cchTextMax);
                break;
            default:
                ASSERTMSG(0, "ListView is asking for wrong column in publishing wizard");
                break;
        }
    }
}
    
void CPublishingWizard::_InitProvidersDialog(HWND hwnd)
{
    // initial the dialog accordingly
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr = _LoadMappedString(L"wp:destination", L"providercaption", szBuffer, ARRAYSIZE(szBuffer));
    if (SUCCEEDED(hr))
    {
        SetDlgItemText(hwnd, IDC_PUB_PROVIDERSCAPTION, szBuffer);

        // lets size the caption area as needed, and move controls around as needed
        UINT ctls[] = { IDC_PUB_PROVIDERSLABEL, IDC_PUB_PROVIDERS};
        int dy = SizeControlFromText(hwnd, IDC_PUB_PROVIDERSCAPTION, szBuffer);
        MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);

        // adjust the provider dialog size as needed
        RECT rc;
        GetWindowRect(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &rc);
        SetWindowPos(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc)-dy, SWP_NOZORDER|SWP_NOMOVE);
    }    

    // set the caption for the providers control
    _MapDlgItemText(hwnd, IDC_PUB_PROVIDERSLABEL, L"wp:destination", L"providerslabel");

    // set the image list to the list view
    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), himlSmall, LVSIL_SMALL);
};

INT_PTR CPublishingWizard::_ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _InitProvidersDialog(hwnd);
            return TRUE;
           
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case LVN_GETDISPINFO:
                    _ProviderGetDispInfo((LV_DISPINFO*)pnmh);
                    return TRUE;

                case LVN_ITEMCHANGED:
                    _ProviderEnableNext(hwnd);
                    return TRUE;

                case LVN_DELETEITEM:
                {
                    NMLISTVIEW *nmlv = (NMLISTVIEW*)lParam;
                    IXMLDOMNode *pdn = (IXMLDOMNode*)nmlv->lParam;
                    pdn->Release();
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    _fTransferComplete = FALSE;             // we haven't started to tranfser yet
                    _fShownCustomLocation = FALSE;          // we haven't shown the custom location page
                    
                    if (_fRecomputeManifest)
                        _BuildTransferManifest();   

                    if (_fRepopulateProviders)
                        _PopulateProviderList(hwnd);        // if the manifest changes, so might the providers!

                    _ProviderEnableNext(hwnd);
                    return TRUE;              
                }                                 

                // when going back from the destination page, lets determine from the
                // site where we should be going.

                case PSN_WIZBACK:
                {
                    if (_dwFlags & SHPWHF_NOFILESELECTOR)
                    {
                        if (_punkSite) 
                        {
                            IWizardSite *pws;
                            if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                            {
                                HPROPSHEETPAGE hpage;
                                if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                                {
                                    PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                }
                                pws->Release();
                            }
                        }
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    }
                    else
                    {
                        _WizardNext(hwnd, WIZPAGE_WHICHFILE);
                    }
                    return TRUE;
                }

                // when going forward lets query the next page, set the selection
                // and then let the foreground know whats going on.

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ProviderNext(hwnd, &hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }

                // the item was activated, therefore we need to goto the next (in this case the page for the provider).

                case LVN_ITEMACTIVATE:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ProviderNext(hwnd, &hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}                                    


// Resample/Resize dialog.  This dialog is displayed when we determine that there
// are images that need to be resized.

INT_PTR CPublishingWizard::_ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Button_SetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE), BST_CHECKED);
            Button_SetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL), BST_CHECKED);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
                    return TRUE;
                
                case PSN_WIZBACK:
                {
                    // if we went through the custom location stuff then navigate back into there.

                    if (_fShownCustomLocation)
                        return _WizardNext(hwnd, _fShownUserName ? WIZPAGE_FTPUSER:WIZPAGE_LOCATION);

                    return _WizardNext(hwnd, WIZPAGE_PROVIDERS);
                }

                case PSN_WIZNEXT:
                {
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE)) == BST_CHECKED)
                    {   
                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL)) == BST_CHECKED)
                            _ro = RESIZE_SMALL;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZEMEDIUM)) == BST_CHECKED)
                            _ro = RESIZE_MEDIUM;
                        else 
                            _ro = RESIZE_LARGE;
                    }                
                    else
                    {
                        _ro = RESIZE_NONE;
                    }
                    return _WizardNext(hwnd, WIZPAGE_COPYING);
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if ((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDC_PUB_RESIZE))
            {
                BOOL fEnable = Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE)) == BST_CHECKED;
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZEMEDIUM), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZELARGE), fEnable);
            }
            break;
        }
    }
    return FALSE;
}                                    


// this is called before we transfer each item, we look at the IShellItem we have and
// try to update either our stats, or the indicator that this is a new file we are processing.

BOOL CPublishingWizard::_HasAttributes(IShellItem *psi, SFGAOF flags)
{
    BOOL fReturn = FALSE;
    SFGAOF flagsOut;
    if (SUCCEEDED(psi->GetAttributes(flags, &flagsOut)) && (flags & flagsOut))
    {
        fReturn = TRUE;
    }
    return fReturn;
}

HRESULT CPublishingWizard::PreOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
{
    if (psiItem && _HasAttributes(psiItem, SFGAO_STREAM))
    {
        if (STGOP_COPY == op)
        {
            // lets fill in the details of the file

            LPOLESTR pstrName;
            HRESULT hr = psiItem->GetDisplayName(SIGDN_PARENTRELATIVEEDITING, &pstrName);
            if (SUCCEEDED(hr))
            {
                SetDlgItemText(_hwndCopyingPage, IDC_PUB_COPYFILE, pstrName);
                CoTaskMemFree(pstrName);
            }

            // lets update the progress bar for the number of files we are transfering.

            _iFile++;       

            SendDlgItemMessage(_hwndCopyingPage, IDC_PUB_TRANSPROGRESS, PBM_SETRANGE32, 0, (LPARAM)_cFiles);
            SendDlgItemMessage(_hwndCopyingPage, IDC_PUB_TRANSPROGRESS, PBM_SETPOS, (WPARAM)_iFile, 0);

            TCHAR szBuffer[MAX_PATH];
            FormatMessageString(IDS_PUB_COPYINGFMT, szBuffer, ARRAYSIZE(szBuffer), _iFile, _cFiles);
            SetDlgItemText(_hwndCopyingPage, IDC_PUB_LABELTRANSPROG, szBuffer);

            // get the thumbnail and show it.

            IExtractImage *pei;
            hr = psiItem->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pei));
            if (SUCCEEDED(hr))
            {
                SIZE sz = {120,120};
                WCHAR szImage[MAX_PATH];
                DWORD dwFlags = 0;

                hr = pei->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    HBITMAP hbmp;
                    hr = pei->Extract(&hbmp);
                    if (SUCCEEDED(hr))
                    {
                        if (!PostMessage(_hwndCopyingPage, PWM_UPDATEICON, (WPARAM)IMAGE_BITMAP, (LPARAM)hbmp))
                        {
                            DeleteObject(hbmp);
                        }
                    }
                }
                pei->Release();
            }

            // if that failed then lets get the icon for the file and place that into the dialog,
            // this is less likely to fail - I hope.

            if (FAILED(hr))
            {
                IPersistIDList *ppid;
                hr = psiItem->QueryInterface(IID_PPV_ARG(IPersistIDList, &ppid));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = ppid->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCWSTR)pidl, -1, &sfi, sizeof(sfi), SHGFI_ICON|SHGFI_PIDL|SHGFI_ADDOVERLAYS))
                        {
                            if (!PostMessage(_hwndCopyingPage, PWM_UPDATEICON, (WPARAM)IMAGE_ICON, (LPARAM)sfi.hIcon))
                            {
                                DeleteObject(sfi.hIcon);
                            }
                        }
                        ILFree(pidl);
                    }
                    ppid->Release();
                }
            }
        }
        else if (STGOP_STATS == op)
        {
            _cFiles++;
        }
    }
    return S_OK;
}


// while we are moving the bits of the file ensure that we update the progress bar accordingly.

void CPublishingWizard::_SetProgress(DWORD dwCompleted, DWORD dwTotal)
{
    if (_dwTotal != dwTotal)
        _dwTotal = dwTotal;
        
    if (_dwCompleted != dwCompleted)
        _dwCompleted = dwCompleted;

    PostMessage(_hwndCopyingPage, PWM_UPDATE, (WPARAM)dwCompleted, (LPARAM)dwTotal);
}

HRESULT CPublishingWizard::OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ulTotal, ULONGLONG ulComplete)
{
    if (psiItem && (op == STGOP_COPY))
    {
        ULARGE_INTEGER uliCompleted, uliTotal;

        uliCompleted.QuadPart = ulComplete;
        uliTotal.QuadPart = ulTotal;

        // If we are using the top 32 bits, scale both numbers down.
        // Note that I'm using the attribute that dwTotalHi is always larger than dwCompleted

        ASSERT(uliTotal.HighPart >= uliCompleted.HighPart);
        while (uliTotal.HighPart)
        {
            uliCompleted.QuadPart >>= 1;
            uliTotal.QuadPart >>= 1;
        }

        ASSERT((0 == uliCompleted.HighPart) && (0 == uliTotal.HighPart));       // Make sure we finished scaling down.
        _SetProgress(uliCompleted.LowPart, uliTotal.LowPart);
    }

    return S_OK;
}


// Method to invoke the transfer engine

HRESULT CPublishingWizard::_BeginTransfer(HWND hwnd)
{
    // initialize the dialog before we start the copy process.

    _dwCompleted = -1;                  // progress bars are reset
    _dwTotal = -1;
    _iPercentageComplete = -1;

    _cFiles = 0;                        // haven't transfered any files yet
    _iFile = 0;

    _hrFromTransfer = S_FALSE;
    _fCancelled = FALSE;

    // set the state of the controls ready to perform the transfer

    SetDlgItemText(hwnd, IDC_PUB_COPYFILE, TEXT(""));
    SendMessage(hwnd, PWM_UPDATE, 0, 0);
    PropSheet_SetWizButtons(GetParent(hwnd), 0x0);

    // initialize the transfer object ready to move the bits to the site

    ITransferAdviseSink *ptas;
    HRESULT hr = this->QueryInterface(IID_PPV_ARG(ITransferAdviseSink, &ptas));
    if (SUCCEEDED(hr))
    {
        // build the list of files for use to transfer to the site, this we
        // key of the transfer manifest which is stored in our property bag.

        IXMLDOMDocument *pdocManifest;
        hr = GetTransferManifest(NULL, &pdocManifest);
        if (SUCCEEDED(hr))
        {
            TRANSFERINFO ti = {0};
            ti.hwnd = hwnd;
            ti.dwFlags = _dwFlags;

            CDPA<TRANSFERITEM> dpaItems;
            hr = _InitTransferInfo(pdocManifest, &ti, &dpaItems);
            if (SUCCEEDED(hr))
            {
                if (ti.fUsePost)
                {
                    hr = PublishViaPost(&ti, &dpaItems, ptas);
                }
                else
                {
                    hr = PublishViaCopyEngine(&ti, &dpaItems, ptas);
                }
            }                                            

            dpaItems.DestroyCallback(_FreeTransferItems, NULL); // will have been detached by thread if handled
            pdocManifest->Release();
        }

        if (FAILED(hr))           
            PostMessage(hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

        ptas->Release();
    }
    return hr;
}


// create a link back to the site, this is keyed off information stored in the manifest.

HRESULT CPublishingWizard::_CreateFavorite(IXMLDOMNode *pdnUploadInfo)
{
    // lets pick up the favorite element from the manifest, this should define all
    // that is needed for us to create a link in to the favorites menu.

    IXMLDOMNode *pdn;
    HRESULT hr = pdnUploadInfo->selectSingleNode(ELEMENT_FAVORITE, &pdn);
    if (S_OK == hr)
    {
        // we need an URL to create the link using.

        WCHAR szURL[INTERNET_MAX_URL_LENGTH] = {0};
        hr = GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL));
        if (SUCCEEDED(hr))
        {
            // we need a name to save the link as.

            WCHAR szName[MAX_PATH] = {0};
            hr = GetStrFromAttribute(pdn, ATTRIBUTE_NAME, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                IShellLink *psl;
                hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    hr = psl->SetPath(szURL);                    // set the target

                    // if that works then lets try and put a comment onto the link - this is an optional
                    // value for the <favorite/> element.

                    if (SUCCEEDED(hr))
                    {
                        WCHAR szComment[MAX_PATH] = {0};
                        if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_COMMENT, szComment, ARRAYSIZE(szComment))))
                        {
                            hr = psl->SetDescription(szComment);     // set the comment
                        }
                    }

                    // assuming all that works then lets persist the link into the users
                    // favorites folder, this inturn will create it on their favaorites menu.

                    if (SUCCEEDED(hr))
                    {
                        WCHAR szFilename[MAX_PATH];
                        if (SHGetSpecialFolderPath(NULL, szFilename, CSIDL_FAVORITES, TRUE))
                        {
                            PathAppend(szFilename, szName);
                            PathRenameExtension(szFilename, TEXT(".lnk"));

                            IPersistFile *ppf;
                            hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                            if (SUCCEEDED(hr))
                            {
                                hr = ppf->Save(szFilename, TRUE);
                                ppf->Release();
                            }
                        }
                    }

                    psl->Release();
                }
            }
        }
        pdn->Release();
    }

    return hr;
}


// When transfer is complete we need to determine which page we are going to show
// this will either come from the site or it will be a HTML page hosted
// on the site.

HPROPSHEETPAGE CPublishingWizard::_TransferComplete(HRESULT hrFromTransfer)
{
    HPROPSHEETPAGE hpResult = NULL;

    // convert the HRESULT From something that will have come from the 
    // transfer engine into something the outside world will understand.

    if (hrFromTransfer == STRESPONSE_CANCEL)
        hrFromTransfer = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    
    // tag ourselves as in the "completed transfer" state, therefore the site knows where to
    // navigate to next.

    _fTransferComplete = TRUE;
    _hrFromTransfer = hrFromTransfer;

    // get the next page from the site, this will either be the done or 
    // cancelled page based on the result of the site.

    IWizardSite *pws;
    HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
    if (SUCCEEDED(hr))
    {
        if (_hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            hr = pws->GetCancelledPage(&hpResult);
        }
        else
        {
            hr = pws->GetNextPage(&hpResult);
        }
        pws->Release();
    }

    // lets put the result into the manifest that we we can read it back later.

    IXMLDOMDocument *pdocManifest;
    hr = GetTransferManifest(NULL, &pdocManifest);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
        if (hr == S_OK)
        {
            // if there is a success/failure page defined then lets handle it accordingly

            WCHAR szPageToShow[INTERNET_MAX_URL_LENGTH] = {0};
            if (SUCCEEDED(_hrFromTransfer))
            {
                hr = GetURLFromElement(pdn, ELEMENT_SUCCESSPAGE, szPageToShow, ARRAYSIZE(szPageToShow));
            }
            else
            {
                if (_hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                    hr = GetURLFromElement(pdn, ELEMENT_CANCELLEDPAGE, szPageToShow, ARRAYSIZE(szPageToShow));

                if ((_hrFromTransfer != HRESULT_FROM_WIN32(ERROR_CANCELLED)) || FAILED(hr))
                    hr = GetURLFromElement(pdn, ELEMENT_FAILUREPAGE, szPageToShow, ARRAYSIZE(szPageToShow));
            }

            // if we have the page then lets navigate to it, this will give us the succes
            // failure pages from the site.

            if (SUCCEEDED(hr) && szPageToShow[0])
            {
                hr = _pwwe->SetInitialURL(szPageToShow);
                if (SUCCEEDED(hr))
                {
                    hr = _pwwe->GetFirstPage(&hpResult);
                }
            }

            // lets do the final processing of the transfer (creating net places, favorites etc)

            _CreateFavorite(pdn);

            pdn->Release();
        }

        pdocManifest->Release();
    }

    return hpResult;
}


// this is the copying dialog.   this displays the progress bar and other information as
// we transfer the files from the users m/c to the site.

INT_PTR CPublishingWizard::_CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hwndCopyingPage = hwnd;
            return FALSE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _BeginTransfer(hwnd);
                    return TRUE;

                case PSN_QUERYCANCEL:
                {
                    _fCancelled = TRUE;
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)TRUE);
                    return TRUE;
                }
            }
            break;
        }

        case WM_CTLCOLORSTATIC:
        {
            // we want the preview filled with a white background.
            if (GetDlgCtrlID((HWND)lParam) == IDC_PUB_PREVIEW)
            {
                return (INT_PTR)(COLOR_3DHILIGHT+1);
            }
            return FALSE;
        }

        case PWM_TRANSFERCOMPLETE:
        {
            PropSheet_SetCurSel(GetParent(hwnd), _TransferComplete((HRESULT)lParam), -1);
            break;
        }

        case PWM_UPDATE:
        {
            DWORD dwTotal = (DWORD)lParam;
            DWORD dwCompleted = (DWORD)wParam;

            SendDlgItemMessage(hwnd, IDC_PUB_FILEPROGRESS, PBM_SETRANGE32, 0, (LPARAM)dwTotal);
            SendDlgItemMessage(hwnd, IDC_PUB_FILEPROGRESS, PBM_SETPOS, (WPARAM)dwCompleted, 0);

            // compute the percentage of the file copied.

            int iPercentage = 0;
            if (dwTotal > 0)
                iPercentage = (dwCompleted * 100) / dwTotal;

            if (_iPercentageComplete != iPercentage)
            {
                TCHAR szBuffer[MAX_PATH];
                FormatMessageString(IDS_PUB_COMPLETEFMT, szBuffer, ARRAYSIZE(szBuffer), iPercentage);
                SetDlgItemText(_hwndCopyingPage, IDC_PUB_LABELFILEPROG, szBuffer);
            }

            break;
        }

        case PWM_UPDATEICON:
        {
            HWND hwndThumbnail = GetDlgItem(hwnd, IDC_PUB_PREVIEW);
            DWORD dwStyle = (DWORD)GetWindowLongPtr(hwndThumbnail, GWL_STYLE) & ~(SS_BITMAP|SS_ICON);
            if (wParam == IMAGE_BITMAP)
            {
                SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_BITMAP);
                HBITMAP hbmp = (HBITMAP)SendMessage(hwndThumbnail, STM_SETIMAGE, wParam, lParam);
                if (hbmp)
                {
                    DeleteObject(hbmp);
                }               
            }
            else if (wParam == IMAGE_ICON)
            {
                SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_ICON);
                HICON hIcon = (HICON)SendMessage(hwndThumbnail, STM_SETIMAGE, wParam, lParam);
                if (hIcon)
                {
                    DeleteObject(hIcon);
                }
            }
            else
            {
                DeleteObject((HGDIOBJ)lParam);
            }
            break;
        }
    }

    return FALSE;
}


// Manage the list of file types

HRESULT CPublishingWizard::_AddExtenisonToList(HDPA hdpa, LPCTSTR pszExtension)
{
    UINT iItem = 0;
    UINT nItems = DPA_GetPtrCount(hdpa);
    BOOL fFound = FALSE;

    for ( ;(iItem < nItems) && !fFound; iItem++)
    {
        LPCTSTR pszExtensionInDPA = (LPCTSTR) DPA_GetPtr(hdpa, iItem);
        if (pszExtensionInDPA)
        {
            fFound = (0 == StrCmpI(pszExtension, pszExtensionInDPA));
        }
    }

    HRESULT hr = S_OK;
    if (!fFound)
    {
        LPTSTR pszAlloc;
        hr = E_OUTOFMEMORY;
        pszAlloc = StrDup(pszExtension);
        if (pszAlloc)
        {
            if (DPA_ERR == DPA_AppendPtr(hdpa, (void*)pszAlloc))
            {
                LocalFree(pszAlloc);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

int CPublishingWizard::s_FreeStringProc(void* pFreeMe, void* pData)
{
    LocalFree(pFreeMe);
    return 1;
}

HRESULT CPublishingWizard::_GetUniqueTypeList(BOOL fIncludeFolder, HDPA *phdpa)
{
    *phdpa = NULL;

    HRESULT hr = (*phdpa = DPA_Create(10)) ? S_OK:E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        // check for the folders type - eg. we have folders

        if (fIncludeFolder)
        {
            IXMLDOMNode *pdn;
            hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
            if (hr == S_OK)
            {
                IXMLDOMElement *pdel;
                hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    VARIANT var;                    
                    if (pdel->getAttribute(ATTRIBUTE_HASFOLDERS, &var) == S_OK)
                    {
                        if ((var.vt == VT_BOOL) && (var.boolVal == VARIANT_TRUE))
                        {
                            hr = _AddExtenisonToList(*phdpa, TEXT("Folder"));
                        }
                        VariantClear(&var);    
                    }
                    pdel->Release();
                }
                pdn->Release();
            }
        }

        // walk the file nodes building the extension list for us            

        IXMLDOMNodeList *pnl;
        hr = _pdocManifest->selectNodes(XPATH_ALLFILESTOUPLOAD, &pnl);
        if (hr == S_OK)
        {
            long cSelection;
            hr = pnl->get_length(&cSelection);
            for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
            {
                IXMLDOMNode *pdn;
                hr = pnl->get_item(lNode, &pdn);
                if (SUCCEEDED(hr))
                {
                    TCHAR szBuffer[MAX_PATH];
                    hr = GetStrFromAttribute(pdn, ATTRIBUTE_EXTENSION, szBuffer, ARRAYSIZE(szBuffer));
                    if (SUCCEEDED(hr))
                    {
                        hr = _AddExtenisonToList(*phdpa, szBuffer);
                    }
                    pdn->Release();
                }
            }
            pnl->Release();
        }

        // clean up the type DPA if we failed....

        if (FAILED(hr))
        {
            DPA_DestroyCallback(*phdpa, s_FreeStringProc, 0);
            *phdpa = NULL;
        }
    }
    return hr;
}


// initialize the property bag we want to give to the site so that
// they can display the correct HTML and direct the user in the 
// right direction.

HRESULT CPublishingWizard::_InitPropertyBag(LPCTSTR pszURL)
{
    HRESULT hr = S_OK;

    // lets initialize the wizard object so that we show the correct
    // pages, to determine this we need to 

    if (pszURL)
        hr = _pwwe->SetInitialURL(pszURL);

    // now compile a list of the unique types, this will be placed into the
    // property bag.  at this time we can also determine if there
    // are any images in our list, and therefore if we should prompt accordingly.

    _fOfferResize = FALSE;              // no resize

    ATOMICRELEASE(_ppb);
    hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &_ppb));
    if (SUCCEEDED(hr))
    {
        INT cExtensions = 0;

        // get the list of unique extensions and put those into the
        // property bag for the site to query - this should be removed in time and
        // we should have the site favor the file Manifest

        HDPA hdpa;
        hr = _GetUniqueTypeList(TRUE, &hdpa);
        if (SUCCEEDED(hr))
        {
            for (int i = 0; (i < DPA_GetPtrCount(hdpa)) && (SUCCEEDED(hr)); i++)
            {
                LPCTSTR pszExtension = (LPCTSTR)DPA_GetPtr(hdpa, i);
                if (pszExtension)
                {
                    if (!(_dwFlags & SHPWHF_NORECOMPRESS))
                        _fOfferResize = (_fOfferResize || PathIsImage(pszExtension));

                    TCHAR szProperty[255];
                    wnsprintf(szProperty, ARRAYSIZE(szProperty), PROPERTY_EXTENSION TEXT("%d"), PROPERTY_EXTENSION, i);

                    hr = SHPropertyBag_WriteStr(_ppb, szProperty, pszExtension);
                    if (SUCCEEDED(hr))
                    {
                        cExtensions++;
                    }
                }
            }
            DPA_DestroyCallback(hdpa, s_FreeStringProc, 0);
        }

        // initialize property bag with UI elements (ignoring the error from above, just won't have an
        // extension list to present)

        SHPropertyBag_WriteInt(_ppb, PROPERTY_EXTENSIONCOUNT, cExtensions);

        // we should always have a manifest object, therefore lets put it into the
        // property bag so that the site can extract it.

        IXMLDOMDocument *pdocManifest;
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &pdocManifest));
        if (SUCCEEDED(hr))
        {
            VARIANT varCurManifest = { VT_DISPATCH };
            hr = _pdocManifest->QueryInterface(IID_PPV_ARG(IDispatch, &varCurManifest.pdispVal));
            if (SUCCEEDED(hr))
            {
                // load the manifest into the new document that we have.
                VARIANT_BOOL fSuccess;
                hr = pdocManifest->load(varCurManifest, &fSuccess);
                if ((fSuccess == VARIANT_TRUE) && (hr == S_OK))
                {
                    hr = s_SetPropertyFromDisp(_ppb, PROPERTY_TRANSFERMANIFEST, pdocManifest);
                }
                VariantClear(&varCurManifest);
            }
        }
    }

    return hr;
}


// handle building the file manifest from the IDataObject, this consists of walking the list of
// files and putting together a 

class CPubWizardWalkCB : public INamespaceWalkCB
{
public:
    CPubWizardWalkCB(IXMLDOMDocument *pdocManifest);
    ~CPubWizardWalkCB();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

private:
    LONG _cRef;                                 // object lifetime count

    TCHAR _szWalkPath[MAX_PATH];                // path of the folder we are walking
    INT _idFile;                                // id of file we have walked    
    IXMLDOMDocument *_pdocManifest;             // manifest we are populating

    void _AddImageMetaData(IShellFolder2 *psf2, LPCITEMIDLIST pidl, IXMLDOMElement *pdel);
};

CPubWizardWalkCB::CPubWizardWalkCB(IXMLDOMDocument *pdocManifest) :
    _cRef(1), _pdocManifest(pdocManifest)
{
    _pdocManifest->AddRef();
    _szWalkPath[0] = TEXT('\0');                // no path yet.
}

CPubWizardWalkCB::~CPubWizardWalkCB()
{
    _pdocManifest->Release();
}


// IUnknown

ULONG CPubWizardWalkCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPubWizardWalkCB::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPubWizardWalkCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPubWizardWalkCB, INamespaceWalkCB),    // IID_INamespaceWalkCB
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


void CPubWizardWalkCB::_AddImageMetaData(IShellFolder2 *psf2, LPCITEMIDLIST pidl, IXMLDOMElement *pdel)
{
    struct
    {
        LPWSTR pszID;
        const SHCOLUMNID *pscid;
    } 
    _aMetaData[] = 
    {
        {L"cx", &SCID_ImageCX},
        {L"cy", &SCID_ImageCY},
    };

// eventually break this into a helper function, or read this from the info tip

    for (int i = 0; i < ARRAYSIZE(_aMetaData); i++)
    {
        VARIANT var = {0};
        HRESULT hr = psf2->GetDetailsEx(pidl, _aMetaData[i].pscid, &var);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdelProperty;
            hr = CreateAndAppendElement(_pdocManifest, pdel, ELEMENT_IMAGEDATA, &var, &pdelProperty);
            if (SUCCEEDED(hr))
            {
                hr = SetAttributeFromStr(pdelProperty, ATTRIBUTE_ID, _aMetaData[i].pszID);
                pdelProperty->Release();
            }
            VariantClear(&var);
        }
    }
}


// INamepsaceWalkCB

HRESULT CPubWizardWalkCB::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IXMLDOMNode *pdn;
    HRESULT hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
    if (hr == S_OK)
    {
        IXMLDOMElement *pdel;
        hr = _pdocManifest->createElement(ELEMENT_FILE, &pdel);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[MAX_PATH];
            VARIANT var;

            // pass out the unique IDs for each of the elements in the tree
            var.vt = VT_I4;
            var.lVal = _idFile++;
            pdel->setAttribute(ATTRIBUTE_ID, var);
            
            // must be able to get the path for the item so that we can 
            hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szBuffer, ARRAYSIZE(szBuffer));
            if (SUCCEEDED(hr))
            {
                // source path
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_SOURCE, szBuffer);

                // extension = (extension to file)
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_EXTENSION, PathFindExtension(szBuffer));

                // lets put the content type
                TCHAR szContentType[MAX_PATH];
                DWORD cch = ARRAYSIZE(szContentType);
                if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, szBuffer, NULL, szContentType, &cch)))
                {
                    hr = SetAttributeFromStr(pdel, ATTRIBUTE_CONTENTTYPE, szContentType);
                }
            }

            // put the proposed destination into the node
            hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING|SHGDN_INFOLDER, szBuffer, ARRAYSIZE(szBuffer));
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];
                PathCombine(szPath, _szWalkPath, szBuffer);
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_DESTINATION, szBuffer);
            }

            // handle those properties we can get from the shell folder via GetDetailsEx 
            IShellFolder2 *psf2;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                // push the size into the attribute list for the item
                if (SUCCEEDED(psf2->GetDetailsEx(pidl, &SCID_SIZE, &var)))
                {
                    pdel->setAttribute(ATTRIBUTE_SIZE, var);
                    VariantClear(&var);
                }

                // lets inject the meta data
                IXMLDOMElement *pdelMetaData;
                hr = CreateAndAppendElement(_pdocManifest, pdel, ELEMENT_METADATA, NULL, &pdelMetaData);
                if (SUCCEEDED(hr))
                {
                    _AddImageMetaData(psf2, pidl, pdelMetaData);
                    pdelMetaData->Release();
                }

                psf2->Release();
            }        

            // append the node to the list that we already have
            hr = pdn->appendChild(pdel, NULL);
            pdel->Release();
        }
        pdn->Release();
    }
    return S_OK;                            
}

HRESULT CPubWizardWalkCB::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // build the name of the folder we have entered.

    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING|SHGDN_INFOLDER|SHGDN_FORADDRESSBAR, szBuffer, ARRAYSIZE(szBuffer))))
    {
        PathAppend(_szWalkPath, szBuffer);
    }
    
    // lets update the files root to indicate that we are going to be using folders.

    IXMLDOMNode *pdn;
    HRESULT hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
    if (hr == S_OK)
    {
        IXMLDOMElement *pdel;
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BOOL;
            var.boolVal = VARIANT_TRUE;
            hr = pdel->setAttribute(ATTRIBUTE_HASFOLDERS, var);
            pdel->Release();
        }
        pdn->Release();
    }

    // now update the folders list with the new folder that we have just entered, first
    // try to find the folder list, if not found then create it.

    IXMLDOMNode *pdnFolders;
    hr = _pdocManifest->selectSingleNode(XPATH_FOLDERSROOT, &pdnFolders);
    if (hr == S_FALSE)
    {
        IXMLDOMNode *pdnRoot;
        hr = _pdocManifest->selectSingleNode(XPATH_MANIFEST, &pdnRoot);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdelRoot;
            hr = pdnRoot->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelRoot));
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement *pdelFolders;
                hr = CreateAndAppendElement(_pdocManifest, pdelRoot, ELEMENT_FOLDERS, NULL, &pdelFolders);
                if (SUCCEEDED(hr))
                {
                    hr = pdelFolders->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnFolders));
                    pdelFolders->Release();
                }
                pdelRoot->Release();
            }
            pdnRoot->Release();
        }
    }    

    // assuming we now have the folder list, lets now create a new element for this folder.

    if (SUCCEEDED(hr) && pdnFolders)
    {
        IXMLDOMElement *pdelFolder;
        hr = _pdocManifest->createElement(ELEMENT_FOLDER, &pdelFolder);
        if (SUCCEEDED(hr))
        {
            hr = SetAttributeFromStr(pdelFolder, ATTRIBUTE_DESTINATION, _szWalkPath);
            if (SUCCEEDED(hr))
            {
                hr = pdnFolders->appendChild(pdelFolder, NULL);
            }
            pdelFolder->Release();
        }
    }

    return S_OK;                            // always succeed so we can transfer folders
}

HRESULT CPubWizardWalkCB::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    PathRemoveFileSpec(_szWalkPath);
    return S_OK;
}


// construct the manifest based on the document we have

HRESULT CPublishingWizard::_AddFilesToManifest(IXMLDOMDocument *pdocManifest)
{
    HRESULT hr = S_OK;
    if (_pdo || _pdoSelection)
    {
        CWaitCursor cur;        // might take some time

        INamespaceWalk *pnsw;
        hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
        if (SUCCEEDED(hr))
        {
            InitClipboardFormats();

            CPubWizardWalkCB *pwcb = new CPubWizardWalkCB(pdocManifest);
            if (pwcb)
            {
                hr = pnsw->Walk(_pdoSelection ? _pdoSelection:_pdo, NSWF_NONE_IMPLIES_ALL, 0, SAFECAST(pwcb, INamespaceWalkCB *));
                if (SUCCEEDED(hr))
                {
                    hr = pnsw->GetIDArrayResult(&_cItems, &_aItems);
                }
                pwcb->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            pnsw->Release();
        }
    }
    return hr;
}

HRESULT CPublishingWizard::_BuildTransferManifest()
{
    _FreeTransferManifest();

    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocManifest));
    if (SUCCEEDED(hr))
    {
        IXMLDOMElement *pdelDoc;
        hr = CreateElement(_pdocManifest, ELEMENT_TRANSFERMANIFEST, NULL, &pdelDoc);
        if (SUCCEEDED(hr))
        {
            hr = _pdocManifest->putref_documentElement(pdelDoc);
            if (SUCCEEDED(hr))
            {
                hr = CreateAndAppendElement(_pdocManifest, pdelDoc, ELEMENT_FILES, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = _AddFilesToManifest(_pdocManifest);
                }
            }
            pdelDoc->Release();
        }
    }

    _fRecomputeManifest = FALSE;        // the manifest has been recomputed, therefore we don't need to this again.
    _fRepopulateProviders = TRUE;       // the provider list may have changed b/c the manifest changed.

    return hr;
}

void CPublishingWizard::_FreeTransferManifest()
{
    ATOMICRELEASE(_pdocManifest);
    if (_aItems)
    {
        FreeIDListArray(_aItems, _cItems);
        _aItems = NULL;
        _cItems = 0;
    }
}



// Advanced location dialog, including the browse button....

typedef struct
{
    LPTSTR pszPath;
    IDataObject *pdo;
} BROWSEINIT;

int _BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    BROWSEINIT *pbi = (BROWSEINIT *)lpData;
    switch (uMsg)
    {
        case BFFM_INITIALIZED:
        {
            LPTSTR pszPath = pbi->pszPath;
            if (pszPath && pszPath[0])
            {
                int i = lstrlen(pszPath) - 1;
                if ((pszPath[i] == TEXT('\\')) || (pszPath[i] == TEXT('/')))
                {
                    pszPath[i] = 0;
                }   
                SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) (LPTSTR)pszPath);
            }
            else
            {
                LPITEMIDLIST pidl;
                HRESULT hr = SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl);
                if (SUCCEEDED(hr))
                {
                    SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)FALSE, (LPARAM)((LPTSTR)pidl));
                    ILFree(pidl);
                }
            }
            break;
        }

        case BFFM_SELCHANGED:
        {
            BOOL fEnableOK = FALSE;
            LPCITEMIDLIST pidl = (LPCITEMIDLIST)lParam;

            // if we have a IDataObject then check to see if we can drop it onto the
            // destination we are given.  this is used by the publishing process
            // to ensure that we enable/disable the OK.

            if (pbi->pdo)
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
                {
                    IDropTarget *pdt;
                    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IDropTarget, &pdt))))
                    {
                        POINTL ptl = {0};
                        DWORD dwEffect = DROPEFFECT_COPY;
                        if (SUCCEEDED(pdt->DragEnter(pbi->pdo, 0, ptl, &dwEffect)))
                        {
                            fEnableOK = (dwEffect & DROPEFFECT_COPY);
                            pdt->DragLeave();
                        }
                        pdt->Release();
                    }
                    psf->Release();
                }
            }
            else
            {
                ULONG rgInfo = SFGAO_STORAGE;
                if (SUCCEEDED(SHGetNameAndFlags(pidl, 0, NULL, 0, &rgInfo)))
                {
                    fEnableOK = (rgInfo & SFGAO_STORAGE);
                }
                else
                {
                    fEnableOK = TRUE;
                }
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM)fEnableOK);
            break;
        }
    }
    return 0;
}

void CPublishingWizard::_SetWaitCursor(BOOL bOn)
{
    if (bOn)
    {
        _hCursor = SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    }
    else if (_hCursor)
    {
        SetCursor(_hCursor); 
        _hCursor = NULL; 
    }
}

// Publishing location pages

void CPublishingWizard::_ShowExampleTip(HWND hwnd)
{
    TCHAR szTitle[256], szExamples[256];
    LoadString(g_hinst, IDS_NETPLACE_EXAMPLES_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hinst, IDS_NETPLACE_EXAMPLES, szExamples, ARRAYSIZE(szExamples));

    EDITBALLOONTIP ebt = {0};
    ebt.cbStruct = sizeof(ebt);
    ebt.pszTitle = szTitle;
    ebt.pszText = szExamples;

    SetFocus(GetDlgItem(hwnd, IDC_FOLDER_EDIT));         // set focus before the balloon

    HWND hwndEdit = (HWND)SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_GETEDITCONTROL, 0, 0L);
    Edit_ShowBalloonTip(hwndEdit, &ebt);
}

void CPublishingWizard::_LocationChanged(HWND hwnd)
{
    if (_fValidating)
    {
        PropSheet_SetWizButtons(GetParent(hwnd), 0);
    }
    else
    {
        int cchLocation = FetchTextLength(hwnd, IDC_FOLDER_EDIT);
        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK|((cchLocation >0) ? PSWIZB_NEXT:0));
    }
}


// auto complete bits

#define SZ_REGKEY_AUTOCOMPLETE_TAB      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB    TEXT("Always Use Tab")

#define REGSTR_PATH_AUTOCOMPLETE        TEXT("Software\\Microsoft\\windows\\CurrentVersion\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

#define BOOL_NOT_SET                    0x00000005

DWORD CPublishingWizard::_GetAutoCompleteFlags(DWORD dwFlags)
{
    DWORD dwACOptions = 0;

    if (!(SHACF_AUTOAPPEND_FORCE_OFF & dwFlags) &&
          ((SHACF_AUTOAPPEND_FORCE_ON & dwFlags) ||
            SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, FALSE)))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (!(SHACF_AUTOSUGGEST_FORCE_OFF & dwFlags) &&
          ((SHACF_AUTOSUGGEST_FORCE_ON & dwFlags) ||
            SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, TRUE)))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    if (SHACF_USETAB & dwFlags)
        dwACOptions |= ACO_USETAB;
    
    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 

    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;
    
    return dwACOptions;
}

HRESULT CPublishingWizard::_InitAutoComplete()
{
    HRESULT hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &_pac));
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &_punkACLMulti));
        if (SUCCEEDED(hr))
        {
            IObjMgr *pomMulti;
            hr = _punkACLMulti->QueryInterface(IID_PPV_ARG(IObjMgr, &pomMulti));
            if (SUCCEEDED(hr))
            {
                // add the file system auto complete object (for handling UNC's etc)

                IUnknown *punk;
                hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punk);
                    punk->Release();
                }

                // add the publishing wizard auto complete object (for handling HTTP etc)

                IUnknown *punkCustomACL;
                hr = CoCreateInstance(CLSID_ACLCustomMRU, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkCustomACL));
                if (SUCCEEDED(hr))
                {
                    hr = punkCustomACL->QueryInterface(IID_PPV_ARG(IACLCustomMRU, &_pmru));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szKey[MAX_PATH];
                        wnsprintf(szKey, ARRAYSIZE(szKey), (SZ_REGKEY_PUBWIZ TEXT("\\%s\\") SZ_REGVAL_MRU), _szProviderScope);

                        hr = _pmru->Initialize(szKey, 26);
                        if (SUCCEEDED(hr))
                        {
                            hr = pomMulti->Append(punkCustomACL);
                        }
                    }
                    punkCustomACL->Release();
                }
                
                pomMulti->Release();
            }
        }
    }

    return hr;
}


// handle MRU of places you can publish to

void CPublishingWizard::_InitLocation(HWND hwnd)
{
    // lets initialize the auto complete list of folders that we have
    HRESULT hr = _InitAutoComplete();
    if (SUCCEEDED(hr))
    {
        IEnumString *penum;
        hr = _pmru->QueryInterface(IID_PPV_ARG(IEnumString, &penum));
        if (SUCCEEDED(hr))
        {
            penum->Reset();           // reset the enumerator ready for us to populate the list

            LPOLESTR pszEntry;
            ULONG ulFetched;

            while ((penum->Next(1, &pszEntry, &ulFetched) == S_OK) && ulFetched == 1)
            {
                COMBOBOXEXITEM cbei = {0};
                cbei.mask = CBEIF_TEXT;
                cbei.pszText = pszEntry;
                SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_INSERTITEM, 0, (LPARAM)&cbei);

                CoTaskMemFree(pszEntry);
            }
            penum->Release();
        }

        // enable auto complete for this control.
        HWND hwndEdit = (HWND)SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_GETEDITCONTROL, 0, 0L);
        _pac->Init(hwndEdit, _punkACLMulti, NULL, NULL);
        _pac->SetOptions(_GetAutoCompleteFlags(0));

        // limit text on the edit control
        ComboBox_LimitText(GetDlgItem(hwnd, IDC_FOLDER_EDIT), INTERNET_MAX_URL_LENGTH);

        // if the policy says no map drive etc, then lets remove it
        BOOL fHide = SHRestricted(REST_NOENTIRENETWORK) || SHRestricted(REST_NONETCONNECTDISCONNECT);
        ShowWindow(GetDlgItem(hwnd, IDC_BROWSE), fHide ? SW_HIDE:SW_SHOW);
    }
}


// validation thread, this is performed on a background thread to compute if
// the resource is valid.

#define PWM_VALIDATEDONE (WM_APP)  // -> validate done (HRESULT passed in LPARAM)

typedef struct
{
    HWND hwnd;                                      // parent HWND
    BOOL fAllowWebFolders;                          // allow web folders during validation
    TCHAR szFileTarget[INTERNET_MAX_URL_LENGTH];    // destination for file copy
} VALIDATETHREADDATA;

DWORD CALLBACK CPublishingWizard::s_ValidateThreadProc(void *pv)
{
    VALIDATETHREADDATA *pvtd = (VALIDATETHREADDATA*)pv;
    HRESULT hr = E_FAIL;

    // validate the site
    CNetworkPlace np;    
    hr = np.SetTarget(pvtd->hwnd, pvtd->szFileTarget, NPTF_VALIDATE | (pvtd->fAllowWebFolders ? NPTF_ALLOWWEBFOLDERS:0));
    np.SetTarget(NULL, NULL, 0);

    PostMessage(pvtd->hwnd, PWM_VALIDATEDONE, 0, (LPARAM)hr);
    LocalFree(pvtd);
    return 0;
}

void CPublishingWizard::_TryToValidateDestination(HWND hwnd)
{
    TCHAR szDestination[INTERNET_MAX_URL_LENGTH];
    FetchText(hwnd, IDC_FOLDER_EDIT, szDestination, ARRAYSIZE(szDestination));

    // lets walk the list source files and try to match to the destination we have.
    // we don't want to let source be the destination

    BOOL fHitItem = FALSE;    
    LPITEMIDLIST pidl = ILCreateFromPath(szDestination);
    if (pidl)
    {
        BOOL fUNC = PathIsUNC(szDestination); //only if destination is UNC Path do we need to check if source is a mapped drive
        for (UINT iItem = 0; (iItem != _cItems) && !fHitItem; iItem++)
        {
            LPITEMIDLIST pidlSrcDir = ILClone(_aItems[iItem]);
            if (pidlSrcDir)
            {
                ILRemoveLastID(pidlSrcDir);
                fHitItem = ILIsEqual(pidlSrcDir, pidl) || (!ILIsEmpty(pidlSrcDir) && ILIsParent(pidlSrcDir, pidl, FALSE));
                if (!fHitItem && fUNC)
                {
                    WCHAR szPath[MAX_PATH];
                    if (SUCCEEDED(SHGetPathFromIDList(pidlSrcDir, szPath)) && !PathIsUNC(szPath))
                    {
                        WCHAR szSource[MAX_PATH];
                        DWORD cchSource = ARRAYSIZE(szSource);
                        DWORD dwType = SHWNetGetConnection(szPath, szSource, &cchSource);
                        if ((dwType == NO_ERROR) || (dwType == ERROR_CONNECTION_UNAVAIL))
                        {
                            fHitItem = (StrCmpNI(szSource, szDestination, lstrlen(szSource)) == 0);
                        }
                    }
                }
                ILFree(pidlSrcDir);
            }
        }
        ILFree(pidl);
    }

    // if we didn't get a hit that way then lets spin up a thread which will do the
    // validation of the server and the connection - this is a lengthy operation
    // and will post a result to the window.

    if (!fHitItem)
    {
        VALIDATETHREADDATA *pvtd = (VALIDATETHREADDATA*)LocalAlloc(LPTR, sizeof(*pvtd));
        if (pvtd)
        {
            pvtd->hwnd = hwnd;
            pvtd->fAllowWebFolders = (_dwFlags & SHPWHF_VALIDATEVIAWEBFOLDERS) != 0;

            // fetch the user typed url
            StrCpyN(pvtd->szFileTarget, szDestination, ARRAYSIZE(pvtd->szFileTarget));

            // we have the thread data read, so lets begin the validation
            // by creating the thread - our state is set to indicate we are in the
            // validate mode.

            _fValidating = TRUE;                        // we are going to begin validating
            _SetWaitCursor(TRUE);               

            if (!SHCreateThread(s_ValidateThreadProc, pvtd, CTF_INSIST | CTF_COINIT, NULL))
            {
                LocalFree(pvtd);

                _fValidating = FALSE;
                _SetWaitCursor(FALSE);
            }
        }
    }
    else
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_PUB_SAMETARGET), NULL, MB_ICONEXCLAMATION | MB_OK);
        PostMessage(hwnd, PWM_VALIDATEDONE, 0, (LPARAM)E_FAIL);
    }

    // ensure the state of the controls reflects what we are trying to do.

    _LocationChanged(hwnd);
    EnableWindow(GetDlgItem(hwnd, IDC_FOLDER_EDIT), !_fValidating);
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), !_fValidating);
}


// this is the dialog proc for the location dialog.

INT_PTR CPublishingWizard::_LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _MapDlgItemText(hwnd, IDC_PUB_LOCATIONCAPTION, L"wp:location", L"locationcaption");
            _InitLocation(hwnd);
            return TRUE;
        }

        case WM_DESTROY:
        {
            ATOMICRELEASE(_pac);
            ATOMICRELEASE(_punkACLMulti);
            ATOMICRELEASE(_pmru);
            return FALSE;
        }
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_BROWSE:
                {
                    LPITEMIDLIST pidl;
                    if (SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl) == S_OK)
                    {
                        TCHAR szPath[MAX_PATH];
                        FetchText(hwnd, IDC_FOLDER_EDIT, szPath, ARRAYSIZE(szPath));
                        
                        TCHAR szTitle[MAX_PATH];
                        if (FAILED(_LoadMappedString(L"wp:location", L"browsecaption", szTitle, ARRAYSIZE(szTitle))))
                        {
                            LoadString(g_hinst, IDS_PUB_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
                        }

                        // lets initialize our state structure for the browse dialog.  based on this we can then
                        // attempt to select a network place.  from here we will also pass the IDataObject
                        // we have (there may not be one of course)

                        BROWSEINIT binit = {szPath};      

                        if (_pdoSelection)
                            _pdoSelection->QueryInterface(IID_PPV_ARG(IDataObject, &binit.pdo));
                        else if (_pdo)
                            _pdo->QueryInterface(IID_PPV_ARG(IDataObject, &binit.pdo));

                        BROWSEINFO bi = {0};
                        bi.hwndOwner = hwnd;
                        bi.pidlRoot = pidl;
                        bi.lpszTitle = szTitle;
                        bi.ulFlags = BIF_NEWDIALOGSTYLE;
                        bi.lpfn = _BrowseCallback;
                        bi.lParam = (LPARAM)&binit;

                        LPITEMIDLIST pidlReturned = SHBrowseForFolder(&bi);
                        if (pidlReturned)
                        {
                            if (SUCCEEDED(SHGetNameAndFlags(pidlReturned, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
                                SetDlgItemText(hwnd, IDC_FOLDER_EDIT, szPath);

                            ILFree(pidlReturned);
                        }

                        if (binit.pdo)
                            binit.pdo->Release();

                        ILFree(pidl);
                    }
                    return TRUE;
                }

                case IDC_FOLDER_EDIT:
                    if (HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        _LocationChanged(hwnd);
                    }
                    return TRUE;
            }
            break;
        }

        case WM_SETCURSOR:
            if (_fValidating)
            {
                SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
                return TRUE;
            }
            return FALSE;

        case PWM_VALIDATEDONE:
        {
            _fValidating = FALSE;
            _LocationChanged(hwnd);
            _SetWaitCursor(FALSE);

            HRESULT hr = _InitPropertyBag(NULL);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH], szURL[INTERNET_MAX_URL_LENGTH];
                FetchText(hwnd, IDC_FOLDER_EDIT, szURL, ARRAYSIZE(szURL));
               
                // push the destination site into the property bag, and then initialize
                // our site with the right information
                
                IXMLDOMDocument *pdocManifest;
                hr = GetTransferManifest(NULL, &pdocManifest);
                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode *pdnRoot;
                    hr = pdocManifest->selectSingleNode(XPATH_MANIFEST, &pdnRoot);
                    if (hr == S_OK)
                    {
                        IXMLDOMElement *pdelRoot;
                        hr = pdnRoot->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelRoot));
                        if (SUCCEEDED(hr))
                        {
                            IXMLDOMElement *pdelUploadInfo;
                            hr = CreateAndAppendElement(_pdocManifest, pdelRoot, ELEMENT_UPLOADINFO, NULL, &pdelUploadInfo);
                            if (SUCCEEDED(hr))
                            {
                                IXMLDOMElement *pdelTarget;
                                hr = CreateAndAppendElement(_pdocManifest, pdelUploadInfo, ELEMENT_TARGET, NULL, &pdelTarget);
                                if (SUCCEEDED(hr))
                                {
                                    hr = SetAttributeFromStr(pdelTarget, ATTRIBUTE_HREF, szURL);
                                    pdelTarget->Release();
                                }
                                pdelUploadInfo->Release();
                            }
                            pdelRoot->Release();
                        }
                        pdnRoot->Release();
                    }
                    pdocManifest->Release();
                }

                // lets now process the result

                hr = (HRESULT)lParam;
                if (S_OK == hr)
                {
                    BOOL fGotoNextPage = TRUE;

                    // fake a return so auto complete can do its thing
                    SendMessage(GetDlgItem(hwnd, IDC_FOLDER_EDIT), WM_KEYDOWN, VK_RETURN, 0x1c0001);

                    // add the string to the MRU
                    if (_pmru)
                        _pmru->AddMRUString(szURL);

                    // lets sniff the string they entered, if its a URL and its FTP
                    // then we must special case the password in the URL, otherwise
                    // we jump directly to the friendly name handling.

                    URL_COMPONENTS urlComps = {0};
                    urlComps.dwStructSize = sizeof(urlComps);
                    urlComps.lpszScheme = szBuffer;
                    urlComps.dwSchemeLength = ARRAYSIZE(szBuffer);

                    if (InternetCrackUrl(szURL, 0, ICU_DECODE, &urlComps) 
                                    && (INTERNET_SCHEME_FTP == urlComps.nScheme))
                    {
                        URL_COMPONENTS urlComps = {0};
                        urlComps.dwStructSize = sizeof(URL_COMPONENTS);
                        urlComps.nScheme = INTERNET_SCHEME_FTP;
                        urlComps.lpszUserName = szBuffer;
                        urlComps.dwUserNameLength = ARRAYSIZE(szBuffer);

                        // if the user specified a user name, if not then goto the FTP user
                        // page (we known its a FTP location)

                        if (!InternetCrackUrl(szURL, 0, 0, &urlComps) || !szBuffer[0])
                        {
                            _WizardNext(hwnd, WIZPAGE_FTPUSER);
                            fGotoNextPage = FALSE;
                        }
                    }

                    if (fGotoNextPage)
                        _WizardNext(hwnd, WIZPAGE_FRIENDLYNAME);
                }
            }

            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER_EDIT), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), TRUE);

            if (FAILED(((HRESULT)lParam)))
                _ShowExampleTip(hwnd);

            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _fShownCustomLocation = TRUE;           // so we navigate back to this page
                    _fShownUserName = FALSE;
                    _LocationChanged(hwnd);
                    return TRUE;

                case PSN_WIZBACK:
                    return _WizardNext(hwnd, WIZPAGE_PROVIDERS);
        
                case PSN_WIZNEXT:
                    _TryToValidateDestination(hwnd);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;

                case NM_CLICK:
                case NM_RETURN:
                {
                    if (pnmh->idFrom == IDC_EXAMPLESLINK)
                    {
                        _ShowExampleTip(hwnd);
                        return TRUE;
                    }
                }
            }
            break;
        }
    }
    return FALSE;
}


// FTP login dialog - handle the messages for this

void CPublishingWizard::_UserNameChanged(HWND hwnd)
{
    BOOL fAnonymousLogin = IsDlgButtonChecked(hwnd, IDC_PASSWORD_ANONYMOUS);

    ShowWindow(GetDlgItem(hwnd, IDC_USER), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
    ShowWindow(GetDlgItem(hwnd, IDC_USERNAME_LABEL), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
    ShowWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME), (fAnonymousLogin ? SW_SHOW : SW_HIDE));
    ShowWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME_LABEL), (fAnonymousLogin ? SW_SHOW : SW_HIDE));

    // Hide the "You will be prompted for the password when you connect to the FTP server" text on anonymous
    EnableWindow(GetDlgItem(hwnd, IDC_PWD_PROMPT), !fAnonymousLogin);
    ShowWindow(GetDlgItem(hwnd, IDC_PWD_PROMPT), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
}

INT_PTR CPublishingWizard::_UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            CheckDlgButton(hwnd, IDC_PASSWORD_ANONYMOUS, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME_LABEL), FALSE);
            SetWindowText(GetDlgItem(hwnd, IDC_ANON_USERNAME), TEXT("Anonymous"));
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_PASSWORD_ANONYMOUS:
                    _UserNameChanged(hwnd);
                    return TRUE;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    _fShownUserName = TRUE;     // so we can navigate back properly
                    _UserNameChanged(hwnd);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    return _WizardNext(hwnd, WIZPAGE_LOCATION);
        
                case PSN_WIZNEXT:
                {
                    // if we can get a user name then lets push it into the property
                    // bag, a NULL string == anonymous logon

                    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH] = {0};
                    if (!IsDlgButtonChecked(hwnd, IDC_PASSWORD_ANONYMOUS))
                    {
                        FetchText(hwnd, IDC_USER, szUserName, ARRAYSIZE(szUserName));
                    }
            
                    // get the sites property bag, and persist the string into it,
                    // if we have done that then we can go to the next page.

                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdn;
                        hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdn);
                        if (hr == S_OK)
                        {
                            hr = SetAttributeFromStr(pdn, ATTRIBUTE_USERNAME, szUserName);
                            pdn->Release();
                        }
                        pdocManifest->Release();
                    }

                    return _WizardNext(hwnd, WIZPAGE_FRIENDLYNAME);
                }
            }
            break;
        }
    }
    return FALSE;
}


// set the friendly name for the web place - if it doesn't already exist

void CPublishingWizard::_FriendlyNameChanged(HWND hwnd)
{
    int cchLocation = FetchTextLength(hwnd, IDC_NETPLNAME_EDIT);
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK |((cchLocation >0) ? PSWIZB_NEXT:0));
}

INT_PTR CPublishingWizard::_FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // lets get the limit information for the nethood folder

        case WM_INITDIALOG:
        {
            LPITEMIDLIST pidlNetHood;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETHOOD, &pidlNetHood)))
            {
                IShellFolder *psf;
                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlNetHood, &psf))))
                {
                    SHLimitInputEdit(GetDlgItem(hwnd, IDC_NETPLNAME_EDIT), psf);
                    psf->Release();
                }
                ILFree(pidlNetHood);
            }
            _FriendlyNameChanged(hwnd);
            break;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_NETPLNAME_EDIT:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        _FriendlyNameChanged(hwnd);
                        return TRUE;
                    }
                    break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {     
                    // read from the manifest the target URL that we are going to be putting the
                    // files to, from this we can compute the friendly name information.

                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdn;
                        hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdn);
                        if (hr == S_OK)
                        {
                            TCHAR szURL[INTERNET_MAX_URL_LENGTH];            
                            hr = GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL));
                            if (SUCCEEDED(hr))
                            {
                                _npCustom.SetTarget(hwnd, szURL, (_dwFlags & SHPWHF_VALIDATEVIAWEBFOLDERS) ? NPTF_ALLOWWEBFOLDERS:0);

                                TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
                                hr = GetStrFromAttribute(pdn, ATTRIBUTE_USERNAME, szUserName, ARRAYSIZE(szUserName));
                                if (SUCCEEDED(hr))
                                    _npCustom.SetLoginInfo(szUserName, NULL);                        

                                TCHAR szBuffer[MAX_PATH + INTERNET_MAX_URL_LENGTH];
                                if (FormatMessageString(IDS_COMPLETION_STATIC, szBuffer, ARRAYSIZE(szBuffer), szURL))
                                {
                                    SetDlgItemText(hwnd, IDC_COMPLETION_STATIC, szBuffer);
                                }

                                // Create a default name and display it
                                hr = _npCustom.GetName(szBuffer, ARRAYSIZE(szBuffer));
                                SetDlgItemText(hwnd, IDC_NETPLNAME_EDIT, SUCCEEDED(hr) ? szBuffer:TEXT(""));

                                // Update the button state for the page etc.
                                _FriendlyNameChanged(hwnd);
                            }                                    
                            pdn->Release();
                        }
                    }
                    return TRUE;
                }

                case PSN_WIZBACK:
                    _WizardNext(hwnd, _fShownUserName ? WIZPAGE_FTPUSER:WIZPAGE_LOCATION);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    TCHAR szFriendlyName[MAX_PATH];
                    FetchText(hwnd, IDC_NETPLNAME_EDIT, szFriendlyName, ARRAYSIZE(szFriendlyName));

                    // set the name of the new place, if this fails then the name is already taken
                    // and UI will have been displayed saying so, and they responded with a 
                    // NO to the overwrite prompt.

                    HRESULT hr = _npCustom.SetName(hwnd, szFriendlyName);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMDocument *pdocManifest;
                        HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                        if (SUCCEEDED(hr))
                        {
                            IXMLDOMNode *pdn;
                            hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
                            if (hr == S_OK)
                            {
                                hr = SetAttributeFromStr(pdn, ATTRIBUTE_FRIENDLYNAME, szFriendlyName);
                                pdn->Release();
                            }
                            pdocManifest->Release();
                        }

                        // Clean up after our custom netplace now.
                        // This way everything works for webfolders when the outer ANP netplace
                        // creates the webfolder. DSheldon 387476
                        _npCustom.SetTarget(NULL, NULL, 0x0);

                        if (_pdo)
                        {
                            _WizardNext(hwnd, _fOfferResize ? WIZPAGE_RESIZE:WIZPAGE_COPYING);
                        }
                        else
                        {
                            IWizardSite *pws;
                            hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
                            if (SUCCEEDED(hr))
                            {
                                HPROPSHEETPAGE hpage;
                                hr = pws->GetNextPage(&hpage);
                                if (SUCCEEDED(hr))
                                {
                                    PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                }
                                pws->Release();
                            }
                        }
                    }                    

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\resourcemap.cpp ===
#include "stdafx.h"
#pragma hdrstop


class CResourceMap : public IResourceMap, IPersistFile
{
public:
    CResourceMap();
    ~CResourceMap();

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID)
        { *pClassID = CLSID_NULL; return S_OK; }

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IResourceMap
    STDMETHODIMP LoadResourceMap(LPCTSTR pszClass, LPCTSTR pszID);
    STDMETHODIMP SelectResourceScope(LPCTSTR pszResourceType, LPCTSTR pszID, IXMLDOMNode **ppdn);
    STDMETHODIMP LoadBitmap(IXMLDOMNode *pdn, LPCTSTR pszID, HBITMAP *pbm);
    STDMETHODIMP LoadString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch);

private:
    LONG _cRef;
    TCHAR _szMapURL[MAX_PATH];
    IXMLDOMNode *_pdnRsrcMap;           // XML node which describes this wizard
};


CResourceMap::CResourceMap() : 
    _cRef(1)
{
}

CResourceMap::~CResourceMap()
{
    ATOMICRELEASE(_pdnRsrcMap);
}


ULONG CResourceMap::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CResourceMap::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CResourceMap::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CResourceMap, IResourceMap),             // IID_IResourceMap
        QITABENTMULTI(CResourceMap, IPersist, IPersistFile), // rare IID_IPersist
        QITABENT(CResourceMap, IPersistFile),             // IID_IPersistFile
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDAPI CResourceMap_Initialize(LPCWSTR pszURL, IResourceMap **pprm)
{
    CResourceMap *prm = new CResourceMap;
    if (!prm)
        return E_OUTOFMEMORY;

    // load from the URL we were given
    IPersistFile *ppf;
    HRESULT hr = prm->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Load(pszURL, 0x0);
        ppf->Release();
    }

    // if that succeeded then lets get the IResourceMap for the caller
    if (SUCCEEDED(hr))
        hr = prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));

    prm->Release();
    return hr;
}


// IPersistFile support

HRESULT CResourceMap::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    StrCpyN(_szMapURL, pszFileName, ARRAYSIZE(_szMapURL));
    ATOMICRELEASE(_pdnRsrcMap);
    return S_OK;
}
HRESULT CResourceMap::GetCurFile(LPOLESTR *ppszFileName)
{
    *ppszFileName = NULL;
    HRESULT hr = E_FAIL;
    if (_szMapURL[0])
    {
        *ppszFileName = SysAllocString(_szMapURL);
        hr = *ppszFileName ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}


// IResourceMap support

HRESULT CResourceMap::LoadResourceMap(LPCTSTR pszResourceClass, LPCTSTR pszID)
{
    IXMLDOMDocument *pdocWizardDefn;
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &pdocWizardDefn));
    if (SUCCEEDED(hr))
    {
        ATOMICRELEASE(_pdnRsrcMap);    

        VARIANT varName;
        hr = InitVariantFromStr(&varName, _szMapURL);
        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fSuccess;
            hr = pdocWizardDefn->load(varName, &fSuccess);
            if (hr == S_OK)
            {
                if (fSuccess == VARIANT_TRUE)
                {
                    TCHAR szPath[MAX_PATH];
                    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("resourcemap/%s[@id='%s']"), pszResourceClass, pszID);
                    hr = pdocWizardDefn->selectSingleNode(szPath, &_pdnRsrcMap);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            VariantClear(&varName);
        }
        pdocWizardDefn->Release();
    }
    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;
}


HRESULT CResourceMap::SelectResourceScope(LPCTSTR pszResourceType, LPCTSTR pszID, IXMLDOMNode **ppdn)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("%s[@id='%s']"), pszResourceType, pszID);

    HRESULT hr = _pdnRsrcMap->selectSingleNode(szPath, ppdn);
    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;         // the call can return S_FALSE  
}


HRESULT CResourceMap::LoadBitmap(IXMLDOMNode *pdn, LPCTSTR pszID, HBITMAP *phbm)
{
    *phbm = NULL;

    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("bitmap[@id='%s']"), pszID);

    IXMLDOMNode *pn;
    HRESULT hr = (pdn ? pdn:_pdnRsrcMap)->selectSingleNode(szPath, &pn);
    if (hr == S_OK)
    {
        VARIANT var;    
        hr = pn->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            VariantToStr(&var, szPath, ARRAYSIZE(szPath));
            VariantClear(&var);

            INT idRes = PathParseIconLocation(szPath) * -1;      // fix -ve resource ID
            HINSTANCE hinst = LoadLibrary(szPath);
            if (hinst)
            {
                *phbm = (HBITMAP)LoadImage(hinst, MAKEINTRESOURCE(idRes),IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
                FreeLibrary(hinst);
            }
        }
        pn->Release();
    }
    return *phbm ? S_OK:E_FAIL;;
}


HRESULT CResourceMap::LoadString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("text[@id='%s']"), pszID);

    IXMLDOMNode *pn;
    HRESULT hr = (pdn ? pdn:_pdnRsrcMap)->selectSingleNode(szPath, &pn);
    if (hr == S_OK)
    {
        VARIANT var;
        hr = pn->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            SHLoadIndirectString(pszBuffer, pszBuffer, cch, NULL);
            VariantClear(&var);
        }
        pn->Release();
    }

    // try global strings if this load fails

    if ((hr != S_OK) && (pdn != NULL))
    {
        hr = LoadString(NULL, pszID, pszBuffer, cch);  // note: this->LoadString, since we want to use global map
    }

    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;         // the call can return S_FALSE  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDI_USR_USERS                   102
#define IDI_ADDNETPLACE                 107
#define IDI_USR_LOCALUSER_ICON          108
#define IDI_CERTIFICATES                111
#define IDI_USR_GROUP_ICON              112
#define IDI_USR_DOMAINUSER_ICON         110
#define IDI_WIZ_BULLET                  124
#define IDI_REQUIRECAD                  125
#define IDI_SECURITYCHECK               126

#define IDD_USR_FINDNETUSER_WIZARD_PAGE 111
#define IDD_USR_USERLIST_PAGE           105

#define IDB_MND_WATERMARK               100
#define IDB_USR_BANNER                  102
#define IDB_GETPP_DOTNET                103

#define IDD_MND_DLG                     106
#define IDD_MND_PAGE                    106
#define IDD_MND_PROGRESS_DLG            112
#define IDD_MND_CONNECTAS               124

#define IDD_USR_AUTOLOGON_DLG           113
#define IDD_USR_CHOOSEGROUP_PROP_PAGE   114
#define IDD_USR_USERNAME_PROP_PAGE      115
#define IDD_USR_SETPASSWORD_DLG         116
#define IDD_USR_SECURITYCHECK_DLG       117
#define IDD_USR_ADVANCED_PAGE           118

#define IDD_WIZ_NETPASSWORD             119

#define IDI_NOPROVIDERS                 200

#define IDC_CREDENTIALS                 512

#define IDC_WELCOME_STATIC              1000
#define IDC_WELCOME_TITLE               1000
#define IDC_USER_LIST                   1001
#define IDC_FOLDER_STATIC               1002
#define IDC_REMOVEUSER_BUTTON           1003
#define IDC_NETPLNAME_EDIT              1004
#define IDC_ADVANCED_BUTTON             1005
#define IDC_LOGGEDON_STATIC             1006
#define IDC_LOGGEDIN_STATIC             1007
#define IDC_FINDUSER_BUTTON             1008
#define IDC_CONFIRMPASSWORD             1009
#define IDC_USER                        1010
#define IDC_BROWSE                      1011
#define IDC_FULLNAME                    1012
#define IDC_PASSWORD                    1013
#define IDC_ADDUSER_BUTTON              1014
#define IDC_PWGROUP_STATIC              1015
#define IDC_SERVER_LIST                 1016
#define IDC_USERPROPERTIES_BUTTON       1017
#define IDC_PASSWORD_STATIC             1019
#define IDC_LOGON_RADIO1                1019
#define IDC_NOAUTOLOGON                 1019
#define IDC_LOGON_RADIO2                1020
#define IDC_AUTOLOGON                   1020
#define IDC_PASSWORD_BUTTON             1021
#define IDC_NETWORKED                   1021
#define IDC_AUTOLOGON_CHECK             1022
#define IDC_NOTNETWORKED                1022
#define IDC_DESCRIPTION                 1023
#define IDC_USERSLABEL                  1023
#define IDC_GROUPS                      1024
#define IDC_PASSWORDLABEL               1024
#define IDC_GROUPDESC                   1025
#define IDC_CONFIRMPASSWORDLABEL        1025
#define IDC_USERS                       1026
#define IDC_BROWSE_BUTTON               1027
#define IDC_DOMAIN                      1028
#define IDC_CANTRUNCPL_STATIC           1029
#define IDC_DOMAIN_STATIC               1030
#define IDC_USERLISTPAGE_ICON           1032
#define IDC_LISTTITLE_STATIC            1033
#define IDC_CURRENTUSER_ICON            1034
#define IDC_FOLDER                      1034
#define IDC_FOLDERBROWSE                1035
#define IDC_DRIVELETTER                 1036
#define IDC_RECONNECT                   1038
#define IDC_DIFFUSER                    1039
#define IDC_USER_STATIC                 1041
#define IDC_FINDINDSLINK                1044
#define IDC_CONNECTASLINK               1044
#define IDC_ADDPLACELINK                1045
#define IDC_ADVANCEDLINK                1046
#define IDC_CONNECTING                  1047
#define IDC_REQUIRECAD                  1048
#define IDC_POWERUSERS                  1050
#define IDC_ADDUSER                     1051
#define IDC_DONTADDUSER                 1052
#define IDC_OTHER                       1053
#define IDC_WHATACCESS                  1054
#define IDC_COMPLETE_TITLE              1055
#define IDC_EXAMPLESLINK                1056
#define IDC_FINISHSTATIC                1057
#define IDC_ERROR                       1059
#define IDC_ULISTPG_TEXT                1060
#define IDC_CERT_ICON                   1061
#define IDC_CERT_TEXT                   1062
#define IDC_BOOT_ICON                   1063
#define IDC_BOOT_TEXT                   1064
#define IDC_PROVIDERS                   1066
#define IDC_MANAGEPWD_BUTTON            1068
#define IDC_DRIVELIST                   1071
#define IDC_MYWEBDOCUMENTSLINK          1073
#define IDC_PRIVACYLINK                 1074
#define IDC_OTHEROPTIONS_LINK           1075

// add net place wizard

#define IDB_ANP_BANNER                  2000
#define IDB_ANP_WATERMARK               2001

#define IDD_ANP_WELCOME                 2000
#define IDD_ANP_DONE                    2001
#define IDD_ANP_FRIENDLYNAME            2002

#define IDC_ANP_SUCCESS                 2001

#define IDS_ANP_CAPTION                 2000
#define IDS_ANP_FRIENDLYNAME            2001
#define IDS_ANP_FRIENDLYNAME_SUB        2002

#define IDS_ANP_PROVIDER                2010
#define IDS_ANP_PROVIDER_SUB            2011
#define IDS_ANP_PROVIDER_CAP            2012

#define IDS_ANP_LOCATION                2013
#define IDS_ANP_LOCATION_SUB            2014
#define IDS_ANP_LOCATION_BROWSE         2016

#define IDS_ANP_OTHERNAME               2017
#define IDS_ANP_OTHERDESCRIPTION        2018

#define IDS_ANP_WELCOME_PROMPT          2020
#define IDS_ANP_WELCOME_DESC            2021

#define IDS_ANP_SUCCESS                 2030


// internet printing wizard

#define IDB_IPP_BANNER                  2100
#define IDB_IPP_WATERMARK               2101

#define IDD_IPP_WELCOME                 2100
#define IDD_IPP_DONE                    2101
#define IDD_IPP_COPY                    2102

#define IDS_IPP_CAPTION                 2100
#define IDS_IPP_WELCOME_PROMPT          2101
#define IDS_IPP_WELCOME_DESC            2102

#define IDS_IPP_COPY                    2110
#define IDS_IPP_COPY_SUB                2111

#define IDS_IPP_COMPLETED               2120
#define IDS_IPP_SUCCESS                 2121
#define IDS_IPP_FAILURE                 2122

#define IDS_IPP_PROVIDER                2123
#define IDS_IPP_PROVIDER_SUB            2124
#define IDS_IPP_PROVIDER_CAP            2125

#define IDS_IPP_CANCEL                  2126

#define IDS_IPP_PROVIDER_LABEL          2127

#define IDS_IPP_SELECTOR                2128
#define IDS_IPP_SELECTOR_SUB            2129
#define IDS_IPP_SELECTOR_FMT            2130

#define IDS_IPP_PROVIDER_DLOAD          2131

#define IDS_IPP_HASLINK                 2132

#define IDS_IPP_NOPROVIDER              2135
#define IDS_IPP_NOPROVIDERDESC          2136

#define IDS_WEBSVC_HEADER               2140

// publish to the web wizard

#define IDB_PUB_BANNER                  2200
#define IDB_PUB_WATERMARK               2201

#define IDD_PUB_WELCOME                 2200
#define IDD_PUB_DONE                    2201
#define IDD_PUB_COPY                    2202

#define IDS_PUB_CAPTION                 2200
#define IDS_PUB_WELCOME_PROMPT          2201
#define IDS_PUB_WELCOME_DESC            2202

#define IDS_PUB_COPY                    2210
#define IDS_PUB_COPY_SUB                2211

#define IDS_PUB_COMPLETED               2220
#define IDS_PUB_SUCCESS                 2221
#define IDS_PUB_FAILURE                 2222
#define IDS_PUB_CANCEL                  2223

#define IDS_PUB_HASLINK                 2224
#define IDS_PUB_HASNETPLACE             2225
#define IDS_PUB_HASFAVORITE             2226
#define IDS_PUB_HASNETPLACEANDFAVORITE  2227

#define IDS_PUB_SELECTOR                2231
#define IDS_PUB_SELECTOR_SUB            2232
#define IDS_PUB_SELECTOR_FMT            2233

#define IDS_PUB_NOPROVIDER              2235
#define IDS_PUB_NOPROVIDERDESC          2236



// other controls etc

#define IDC_FOLDER_EDIT                 4199
#define IDC_SELECTFOLDER_STATIC         4211
#define IDC_SELECTFOLDER_LIST           4213
#define IDC_COMPLETION_STATIC           4221
#define IDC_COMPLETION_RECONNECT_CHECK  4223
#define IDC_COMPLETION_DRIVE_COMBO      4226
#define IDC_PWD_STATIC                  4246
#define IDC_PASSWORD_ANONYMOUS          4249
#define IDC_ANON_USERNAME               4250
#define IDC_USERNAME_LABEL              4251
#define IDC_PWD_PROMPT                  4252
#define IDC_COMPINFO                    4253
#define IDC_YOURPASSPORT                4254
#define IDC_PASSPORTWIZARD              4258
#define IDC_BOLD1                       4259

#define IDI_PSW                         4400

#define IDB_PSW_BANNER                  4410
#define IDB_PSW_WATERMARK               4411

#define IDB_GETPP_BANNER                4412
#define IDB_GETPP_WATERMARK             4413

#define IDD_PSW_PERMISSIONS             4420
#define IDD_PSW_DOMAININFO              4421
#define IDD_PSW_USERINFO                4422
#define IDD_PSW_DONE                    4423
#define IDD_PSW_WHICHNET                4424
#define IDD_PSW_WORKGROUP               4425
#define IDD_PSW_AUTOLOGON               4426
#define IDD_PSW_WELCOME                 4427
#define IDD_PSW_JOINCREDENTIALS         4428
#define IDD_PSW_COMPINFO                4429

#define IDD_USR_CHOOSEGROUP_WIZARD_PAGE 4430
#define IDD_USR_PASSWORD_WIZARD_PAGE    4431
#define IDD_USR_USERNAME_WIZARD_PAGE    4432

#define IDD_PSW_HOWUSE                  4433
#define IDD_PSW_ADDUSER                 4434

#define IDD_GETPP_WELCOME               4435
#define IDD_GETPP_FINISH                4437

#define IDS_MAPDRIVE_CAPTION            4449
#define IDS_NETWIZCAPTION               4450
#define IDS_WORKGROUP                   4451
#define IDS_PERMISSIONS                 4456
#define IDS_PERMISSIONS_SUB             4457
#define IDS_WHICHNET                    4458
#define IDS_WHICHNET_SUB                4459
#define IDS_WORKGROUP_SUB               4460
#define IDS_DOMAININFO                  4461
#define IDS_DOMAININFO_SUB              4462
#define IDS_COMPINFO                    4463
#define IDS_COMPINFO_SUB                4464
#define IDS_USERINFO                    4465
#define IDS_USERINFO_SUB                4466
#define IDS_DONE                        4467
#define IDS_DONE_SUB                    4468
#define IDS_WELCOME_SUB                 4470
#define IDS_ABOUTTOJOIN                 4471
#define IDS_AUTOLOGON                   4475
#define IDS_AUTOLOGON_SUB               4476
#define IDS_HOWUSE                      4477
#define IDS_HOWUSE_SUB                  4478
#define IDS_COMPNOTFOUND                4479
#define IDS_NETWIZFINISHREBOOT          4480
#define IDS_NETWIZFINISH                4481
#define IDS_RESTARTREQUIRED             4482

#define IDS_PUB_DESTINATION             4529
#define IDS_PUB_DESTINATION_SUB         4530
#define IDS_PUB_BROWSETITLE             4536
#define IDS_PUB_RESIZE                  4547
#define IDS_PUB_RESIZE_SUB              4548
#define IDS_PUB_PATHNOTTHERE            4554
#define IDS_PUB_PATHNOTTHERETITLE       4555
#define IDS_PUB_INVALIDRESOURCE         4557
#define IDS_PUB_ONLYSERVER              4558

#define IDS_PUB_COMPLETEFMT             4559
#define IDS_PUB_COPYINGFMT              4560

#define IDS_PUB_FETCHINGPROVIDERS       4561
#define IDS_PUB_FETCHINGPROVIDERS_SUB   4562
#define IDS_PUB_SAMETARGET              4563

#define IDS_PUB_LOCATION                4570
#define IDS_PUB_LOCATION_SUB            4571
#define IDS_PUB_FTPPASSWORD             4572
#define IDS_PUB_FTPPASSWORD_SUB         4573
#define IDS_PUB_FRIENDLYNAME            4574
#define IDS_PUB_FRIENDLYNAME_SUB        4575

#define IDC_NONE                        4500
#define IDC_DIALUP                      4501
#define IDC_WORKGROUP                   4504
#define IDC_COMPUTERNAME                4505
#define IDC_TITLE                       4508
#define IDC_MESSAGE                     4509
#define IDC_ANON_USERNAME_LABEL         4510
#define IDC_OTHER_STATIC                4511

#define IDC_PUB_WELCOME                 4513
#define IDC_PUB_WELCOMEPROMPT           4514
#define IDC_PUB_DONE                    4521
#define IDC_PUB_COMPLETEMSG             4526
#define IDC_PUB_COPYPROMPT              4524
#define IDC_PUB_COPYPROGRESS            4525
#define IDC_PUB_LOCATIONCAPTION         4526
#define IDC_PUB_OPENFILES               4527
#define IDC_PUB_PREVIEW                 4528

#define IDC_PUB_ALL                     4529
#define IDC_PUB_NOTHING                 4530
#define IDC_PUB_SELECTOR                4531
#define IDC_PUB_SELECTORSTATUS          4532

#define IDC_PUB_SRCHPROVIDERS           4533
#define IDC_PUB_SRCHPROVIDERS_STATIC1   4534
#define IDC_PUB_SRCHPROVIDERS_STATIC2   4535

#define IDC_PUB_PROVIDERSCAPTION        4540
#define IDC_PUB_PROVIDERS               4541
#define IDC_PUB_PROVIDERSLABEL          4542

#define IDC_PUB_RESIZE                  4545
#define IDC_PUB_RESIZESMALL             4546
#define IDC_PUB_RESIZEMEDIUM            4547
#define IDC_PUB_RESIZELARGE             4548

#define IDC_PUB_COPYFILE                4550
#define IDC_PUB_LABELFILEPROG           4551
#define IDC_PUB_FILEPROGRESS            4552
#define IDC_PUB_LABELTRANSPROG          4553
#define IDC_PUB_TRANSPROGRESS           4554

#define IDS_ERR_BADUSER                 12009
#define IDS_ERR_NOSUCHUSER              12010
#define IDS_ERR_JOINWGFAIL              12011
#define IDS_ERR_FAILTOFIND              12012
#define IDS_ERR_BADPWUSER               12013
#define IDS_ERR_PWDNOMATCH              12014
#define IDS_ERR_BADDOMAIN               12015
#define IDS_CONNECT_DRIVE_CAPTION       12053
#define IDS_OPENFILES_WARNING           12062
#define IDS_MPRHELPFILENAME             12067
#define IDS_WELCOME                     12101
#define IDS_COMPLETION                  12104
#define IDS_COMPLETION_STATIC           12110
#define IDS_CLOSE                       12111
#define IDS_ERR_CAPTION                 12120
#define IDS_ERR_OPENFILES               12121
#define IDS_ERR_ALREADYASSIGNED         12122
#define IDS_ERR_ALREADYREMEMBERED       12123
#define IDS_ERR_INVALIDREMOTEPATH       12124
#define IDS_ERR_PROVIDERBUSY            12125
#define IDS_ERR_NONETWORK               12126
#define IDS_ERR_UNEXPECTED              12127
#define IDS_FIRSTCOLUMN                 12140
#define IDS_SECONDCOLUMN                12141
#define IDS_PWD_STATIC                  12150
#define IDS_TITLEFONTNAME               12152
#define IDS_TITLEFONTSIZE               12153
#define IDS_NONE                        12154
#define IDS_CANTFINDFOLDER              12155
#define IDS_CONNECTASUSER               12156
#define IDS_CANTCLOSEFILES_WARNING      12164

#define IDS_USR_DESC                    12165
#define IDS_USR_NEWUSERWIZARD_CAPTION   12166
#define IDS_USR_TITLEFONTNAME           12167
#define IDS_USR_TITLEFONTSIZE           12168
#define IDS_USR_NAME_COLUMN             12169
#define IDS_USR_DOMAIN_COLUMN           12170
#define IDS_USR_GROUP_COLUMN            12171
#define IDS_USR_LOGGEDINAS              12172
#define IDS_USR_LOGGEDINAS_NOFULLNAME   12173
#define IDS_USR_TOOLTIPFULLNAME_FORMAT  12174
#define IDS_USR_TOOLTIPCOMMENT_FORMAT   12175
#define IDS_USR_TOOLTIPBOTH_FORMAT      12176
#define IDS_USR_PASSWORDSDONTMATCH_ERROR 12177
#define IDS_USR_NOUSERNAMEENTERED_ERROR 12178
#define IDS_USR_DEFAULTGROUP            12179
#define IDS_USR_NETUSERNAME_ERROR       12180
#define IDS_USR_REMOVEUSER_WARNING      12181
#define IDS_USR_APPLET_CAPTION          12182
#define IDS_USR_REMOVE_MISC_ERROR       12183
#define IDS_USR_COULDNTFINDUSER_ERROR   12184
#define IDS_USR_PWGROUP_FORMAT          12185
#define IDS_USR_PWMESSAGE_FORMAT        12186
#define IDS_USR_CREATE_MISC_ERROR       12187
#define IDS_USR_CREATE_USEREXISTS_ERROR 12188
#define IDS_USR_BADUSERINFO_ERROR       12189
#define IDS_USR_PROPERTIES_ERROR        12190
#define IDS_USR_CREATE_GROUPEXISTS_ERROR 12191
#define IDS_USR_YOURPWMESSAGE_FORMAT    12195
#define IDS_USR_CANTCHANGEPW_FORMAT     12196
#define IDS_USR_CANTRUNCPL_FORMAT       12197
#define IDS_USR_CANTOPENCPLASUSER_ERROR 12198
#define IDS_USR_UPDATE_PASSWORD_TOOSHORT_ERROR 12199
#define IDS_USR_UPDATE_FULLNAME_ERROR   12200
#define IDS_USR_UPDATE_GROUP_ERROR      12201
#define IDS_USR_UPDATE_PASSWORD_ERROR   12202
#define IDS_USR_UPDATE_USERNAME_ERROR   12203
#define IDS_USR_UPDATE_DESCRIPTION_ERROR 12204
#define IDS_USR_CREATE_PASSWORDTOOSHORT_ERROR 12205
#define IDS_ADMINISTRATOR               12206
#define IDS_MND_ADDPLACELINK            12207
#define IDS_MND_HIDEADVANCED            12208
#define IDS_MND_SHOWADVANCED            12209
#define IDS_MND_SHAREBROWSE             12210
#define IDS_MND_FINDINDS                12211
#define IDS_MND_ADDPLACEERR             12212
#define IDS_MND_PROGRESS                12213
#define IDS_MND_ALREADYMAPPED           12214
#define IDS_ADDUSER                     12218
#define IDS_ADDUSER_SUB                 12219
#define IDS_WHATACCESS_FORMAT           12220
#define IDS_USR_CHANGEGROUP_ERR         12222
#define IDS_NETPLACE_EXAMPLES           12223
#define IDS_NETPLACE_EXAMPLES_TITLE     12224
#define IDS_BADFRIENDLYNAME             12225
#define IDS_COULDNTRENAMEPLACE          12226
#define IDS_MND_GENERICERROR            12228
#define IDS_NAW_JOIN_GENERICERROR       12229
#define IDS_NAW_NAMECHANGE_ERROR        12230
#define IDS_COMPNAME_EXISTS             12231
#define IDS_ERR_ADDUSER                 12232
#define IDS_LOGOFFREQUIRED              12233
#define IDS_USERSANDPASSWORDS           12234
#define IDS_USERCREATE_GENERICERROR     12235
#define IDS_BADSTANDARDUSER             12236
#define IDS_BADRESTRICTEDUSER           12237
#define IDS_MACHINENAMEINUSE            12238
#define IDS_FRIENDLYNAMEINUSE           12239
#define IDS_ERR_BADUSERNAME             12240
#define IDS_ERR_BADWORKGROUP            12241

#define IDS_GETPP_HEADER_WELCOME        12243
#define IDS_GETPP_SUBHEADER_WELCOME     12244
#define IDS_GETPP_HEADER_FINISH         12247
#define IDS_GETPP_SUBHEADER_FINISH      12248
#define IDS_GETPP_CAPTION               12249

#define IDS_DISCONNECTDRIVETITLE        13000
#define IDS_DISCONNECT_CONFIRM          13001
#define IDS_DISCONNECTERROR             13002
#define IDS_NONETDRIVES                 13003
#define IDS_DISCONNECT_CONFIRM_NODEV    13004
#define IDS_DISCONNECT_CAPTION          13005

// These are extension wizard pages, therefore they must be defined
// within this range (see shpriv.idl for details).

#define IDD_PUB_DESTINATION             20480
#define IDD_PUB_RESIZE                  20481
#define IDD_WEB_DLG                     20483
#define IDD_PUB_LOCATION                20484
#define IDD_PUB_FTPPASSWORD             20485
#define IDD_PUB_SELECTOR                20486
#define IDD_PUB_FETCHPROVIDERS          20487

#define IDD_DISCONNECTDRIVES            21000

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1072
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\sources.inc ===
SELFREGNAME= $(O)\netplwiz_selfreg.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

USE_NT_PRODUCT_VER = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME= netplwiz
TARGETTYPE= DYNLINK
TARGETPATH= obj

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

DLLENTRY=DllMain
DLLDEF=$(O)\netplwiz.def

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\stdafx.h

#
# Fusionized
#
SXS_ASSEMBLY_NAME=Microsoft.Windows.Shell.NetPlacesWizard
SXS_ASSEMBLY_VERSION=1.0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=placeswizard.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1

NTTARGETFILE0   = $(SELFREGNAME)

MISCFILES=\
    $(MISCFILES)        \
    ..\res\lusrmgr.msc

MSC_WARNING_LEVEL=/W3 /WX

USE_MSVCRT=1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS=\
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\gdi32.lib    \
            $(SHELL_LIB_PATH)\shell32p.lib \
            $(SHELL_LIB_PATH)\shlwapip.lib \
            $(SHELL_LIB_PATH)\shuuid.lib \
            $(SHELL_LIB_PATH)\shguidp.lib \
            $(SHELL_LIB_PATH)\ieguidp.lib \
            $(SHELL_LIB_PATH)\shfusion.lib    \
            $(SDK_LIB_PATH)\wininet.lib  \
            $(SDK_LIB_PATH)\netapi32.lib \
            $(SDK_LIB_PATH)\activeds.lib \
            $(SDK_LIB_PATH)\adsiid.lib   \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\mpr.lib      \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\ntdsapi.lib  \
            $(SDK_LIB_PATH)\rasdlg.lib   \
            $(SDK_LIB_PATH)\rasapi32.lib \
            $(SDK_LIB_PATH)\secur32.lib  \
            $(SDK_LIB_PATH)\msdasc.lib   \
            $(DS_LIB_PATH)\creduip.lib   \
            $(SDK_LIB_PATH)\urlmon.lib   \
            $(CCSHELL_DIR)\lib\$O\stock.lib

C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE -D_UNICODE -DUSE_MIRRORING -DUXCTRL_VERSION=0x0100

DELAYLOAD= WININET.DLL;RASDLG.DLL;RASAPI32.DLL;ACTIVEDS.DLL;CREDUI.DLL
DLOAD_ERROR_HANDLER = kernel32

# BASE_INC_PATH for validc.h, DS_INC_PATH for iadsp.h
INCLUDES=..\;$(BASE_INC_PATH);$(DS_INC_PATH);$(PROJECT_ROOT)\lib\$(O)
	
USE_ATL=1	

SOURCES=\
        ..\resource.rc  \
        ..\anp.cpp      \
        ..\dll.cpp      \
        ..\dialog.cpp   \
        ..\misc.cpp     \
        ..\netwiz.cpp   \
        ..\join.cpp     \
        ..\data.cpp     \
        ..\netpage.cpp  \
        ..\netplace.cpp \
        ..\misc.cpp     \
        ..\password.cpp \
        ..\userinfo.cpp \
        ..\resourcemap.cpp \
        ..\grpinfo.cpp  \
        ..\mnddlg.cpp   \
        ..\unpage.cpp   \
        ..\pubwiz.cpp   \
        ..\pubcopy.cpp  \
        ..\pubdrop.cpp  \
        ..\pubhelp.cpp  \
        ..\pubpost.cpp  \
        ..\usercpl.cpp  \
        ..\getpp.cpp    \
        ..\disconndlg.cpp \
        ..\passportmisc.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\stdafx.h ===
#ifndef STDAFX_H_INCLUDED
#define STDAFX_H_INCLUDED

#undef ATL_MIN_CRT

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>

#include <windows.h>        // basic windows functionality
#include <windowsx.h>
#include <commctrl.h>       // ImageList, ListView
#include <comctrlp.h>
#include <shfusion.h>
#include <string.h>         // string functions
#include <crtdbg.h>         // _ASSERT macro
#include <objbase.h>
#include <shconv.h>
#include <wininet.h>
#include <lm.h>
#include <validc.h>         // specifies valid characters for user names, etc.
#include <wincrui.h>        // credui

#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobj.h>         // Needed by dsclient.h
#include <shlobjp.h>
#include <shlguid.h>
#include <shlguidp.h>
#include <ieguidp.h>
#include <shellp.h>         
#include <ccstock.h>
#include <dpa.h>
#include <varutil.h>
#include <cowsite.h>
#include <objsafe.h>
#include <cobjsafe.h>

// our concept of what domain, password and user names should be

#define MAX_COMPUTERNAME    LM20_CNLEN
#define MAX_USER            LM20_UNLEN
#define MAX_UPN             UNLEN
#define MAX_PASSWORD        PWLEN
#define MAX_DOMAIN          MAX_PATH
#define MAX_WORKGROUP       LM20_DNLEN      
#define MAX_GROUP           GNLEN

// MAX_DOMAINUSER can hold: <domain>/<username> or <upn>
#define MAX_DOMAINUSER      MAX(MAX_UPN, MAX_USER + MAX_DOMAIN + 1)


// our headers

#include "dialog.h"
#include "helpids.h"
#include "misc.h"
#include "cfdefs.h"
#include "dspsprt.h"
#include "resource.h"
#include "userinfo.h"
#include "dialog.h"
#include "data.h"


// global state

EXTERN_C HINSTANCE g_hinst;
extern LONG g_cLocks;

// resource mapper object - used for wizard chaining

STDAPI CResourceMap_Initialize(LPCWSTR pszURL, IResourceMap **pprm);


// constructors for COM objects

STDAPI CPublishingWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CUserPropertyPages_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CUserSidDataObject_CreateInstance(PSID psid, IDataObject **ppdo);
STDAPI CPassportWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CPassportClientServices_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

extern const CLSID CLISD_PublishDropTarget;
STDAPI CPublishDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);


// template for defining wizard pages

typedef struct 
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
} WIZPAGE;

typedef struct
{
    LPWSTR pszUser;
    INT cchUser;
    LPWSTR pszDomain;
    INT cchDomain;
    LPWSTR pszPassword;
    INT cchPassword;
} CREDINFO, * LPCREDINFO;

HRESULT JoinDomain(HWND hwnd, BOOL fDomain, LPCWSTR pDomain, CREDINFO* pci, BOOL *pfReboot);
VOID SetAutoLogon(LPCWSTR pszUserName, LPCWSTR pszPassword);
VOID SetDefAccount(LPCWSTR pszUserName, LPCWSTR pszDomain);


// for the users.cpl (shared between usercpl.cpp & userlist.cpp)

// All "add user to list" operations are done on the main UI thread - the
// filler thread posts this message to add a user
#define WM_ADDUSERTOLIST (WM_USER + 101)
//                  (LPARAM) CUserInfo* - the user to add to the listview
//                  (WPARAM) BOOL       - select this user (should always be 0 for now)


// Wizard text-related constants
#define MAX_CAPTION         256      // Maximum size of a caption in the Wizard
#define MAX_STATIC          1024     // Maximum size of static text in the Wizard


// Wizard error return value
#define RETCODE_CANCEL      0xffffffff


// keep the debug libraries working...
#ifdef DBG
 #if !defined (DEBUG)
  #define DEBUG
 #endif
#else
 #undef DEBUG
#endif

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

#endif // !STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\unpage.h ===
#ifndef UNPAGE_H
#define UNPAGE_H


class CUsernamePageBase
{
protected:
    CUsernamePageBase(CUserInfo* pUserInfo): m_pUserInfo(pUserInfo) {}

protected:
    // Message handlers
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

protected:
    // Data
    CUserInfo* m_pUserInfo;
};

class CUsernameWizardPage: public CPropertyPage, public CUsernamePageBase
{
public:
    CUsernameWizardPage(CUserInfo* pUserInfo): CUsernamePageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
    // Functions
    void SetWizardButtons(HWND hwnd, HWND hwndPropSheet);
};

class CUsernamePropertyPage: public CPropertyPage, public CUsernamePageBase
{
public:
    CUsernamePropertyPage(CUserInfo* pUserInfo): CUsernamePageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};

#endif //!UNPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\pubwiz.h ===
HRESULT GetStrFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPTSTR pszBuffer, int cch);
HRESULT SetAttributeFromStr(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPCTSTR pszValue);
HRESULT GetIntFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, int *piValue);
HRESULT CreateElement(IXMLDOMDocument *pdoc, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelResult);
HRESULT CreateAndAppendElement(IXMLDOMDocument *pdoc, IXMLDOMNode *pdnParent, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelOut);
void SpewXML(IUnknown *punk);
HRESULT GetURLFromElement(IXMLDOMNode *pdn, LPCTSTR pszElement, LPTSTR pszBuffer, int cch);
DWORD SHWNetGetConnection(LPCWSTR lpLocalName, LPCTSTR lpRemoteName, LPDWORD lpnLength);


// used to communicate between the transfer logic and the main page.

#define PWM_UPDATE              WM_APP+1
#define PWM_TRANSFERCOMPLETE    WM_APP+2
#define PWM_UPDATEICON          WM_APP+3


// transfer manifest information, this is used to communicate between the site and the publishing
// wizard to move the files between the local storage and the site.

// <transfermanfiest>
//      <folderlist>
//          <folder destination="xyz"/>
//      </folderlist>
//      <filelist [usesfolders=-1]/>
//          <file id=x source="path" size="xyz" destination="xyz" extension=".jpg">
//              [<resize cx=<width> cy=<height> quality=<0-100>>]
//              <metadata>
//                  <imageproperty id=""></imageproperty>
//              </metadata>    
//              <post href="href" name="<name section>" [verb=""] [filename="filename"]
//                  <formdata name="<name section>"></formdata>
//              </post>
//      </filelist>
//      <uploadinfo friendlyname="site name">
//          <target [username="username"] href="http://www.diz.com</target"/>
//          <netplace filename="filename" comment="link comment" href="http:/www.diz.com"/>
//          <htmlui href="href://toopenwhenwizardcloses"/>
//          <successpage href="http://www.diz.com/uploadok.htm"/>
//          <favorite href="http://somesite.com" filename="" comment=""/>
//          <failurepage href="http://www.diz.com/uploadok.htm/">
//      </uploadinfo>
// </transfermanifest>

#define ELEMENT_TRANSFERMANIFEST        L"transfermanifest"

#define ELEMENT_FOLDERS                 L"folderlist"

#define ELEMENT_FOLDER                  L"folder"
#define ATTRIBUTE_DESTINATION           L"destination"

#define ELEMENT_FILES                   L"filelist"
#define ATTRIBUTE_HASFOLDERS            L"usesfolders"

#define ELEMENT_FILE                    L"file"             
#define ATTRIBUTE_ID                    L"id"
#define ATTRIBUTE_EXTENSION             L"extension"
#define ATTRIBUTE_CONTENTTYPE           L"contenttype"
#define ATTRIBUTE_SIZE                  L"size"
#define ATTRIBUTE_SOURCE                L"source"
#define ATTRIBUTE_DESTINATION           L"destination"

#define ELEMENT_METADATA                L"metadata"

#define ELEMENT_IMAGEDATA               L"imageproperty"
#define ATTRIBUTE_ID                    L"id"

#define ELEMENT_RESIZE                  L"resize"
#define ATTRIBUTE_CX                    L"cx"
#define ATTRIBUTE_CY                    L"cy"
#define ATTRIBUTE_QUALITY               L"quality"

#define ELEMENT_POSTDATA                L"post"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_VERB                  L"verb"
#define ATTRIBUTE_NAME                  L"name"
#define ATTRIBUTE_FILENAME              L"filename"

#define ELEMENT_FORMDATA                L"formdata"
#define ATTRIBUTE_NAME                  L"name"

#define ELEMENT_UPLOADINFO              L"uploadinfo"
#define ATTRIBUTE_FRIENDLYNAME          L"friendlyname"

#define ELEMENT_TARGET                  L"target"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_USERNAME              L"username"

#define ELEMENT_NETPLACE                L"netplace"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_FILENAME              L"filename"
#define ATTRIBUTE_COMMENT               L"comment"

#define ELEMENT_HTMLUI                  L"htmlui"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_PUBLISHWIZARD           L"publishwizard"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_SUCCESSPAGE             L"successpage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_FAILUREPAGE             L"failurepage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_CANCELLEDPAGE           L"cancelledpage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_FAVORITE                L"favorite"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_NAME                  L"name"
#define ATTRIBUTE_COMMENT               L"comment"    


// xpaths for common items

#define XPATH_MANIFEST                  ELEMENT_TRANSFERMANIFEST 
#define XPATH_FOLDERSROOT               ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FOLDERS
#define XPATH_FILESROOT                 ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FILES
#define XPATH_ALLFILESTOUPLOAD          ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FILES L"/" ELEMENT_FILE
#define XPATH_UPLOADINFO                ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_UPLOADINFO
#define XPATH_UPLOADTARGET              ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_UPLOADINFO  L"/" ELEMENT_TARGET
#define XPATH_PUBLISHWIZARD             ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_PUBLISHWIZARD


// stuff relating to the file transfer engine

typedef struct
{
    HWND hwnd;                                      // parent HWND for any messages / dialogs
    DWORD dwFlags;                                  // flags from original wizard ::SetOptions

    BOOL fUsePost;                                  // use post to transfer the bits

    TCHAR szSiteName[MAX_PATH];                     // site name - shown in wizard
    TCHAR szSiteURL[MAX_PATH];                      // site URL - opened in the browser

    TCHAR szFileTarget[INTERNET_MAX_URL_LENGTH];    // destination for file copy

    TCHAR szLinkTarget[INTERNET_MAX_URL_LENGTH];    // destination for favorites link etc
    TCHAR szLinkName[MAX_PATH];
    TCHAR szLinkDesc[MAX_PATH];
} TRANSFERINFO;

typedef struct
{
    VARIANT varName;                                // name of the form value
    VARIANT varValue;                               // its value
} FORMDATA;

typedef struct
{
    BOOL fResizeOnUpload;                           // this item should be resized

    LPITEMIDLIST pidl;                              // pidl of the item we are posting    
    TCHAR szFilename[MAX_PATH];                     // filename to associate with the object

    TCHAR szVerb[10];                               // verb used for transfer
    TCHAR szName[MAX_PATH];                         // name for the object we are posting 
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];           // destination for file copy
    CDSA<FORMDATA> dsaFormData;                     // form data for extra information published

    int cxResize;                                   // height and width of item for resizing
    int cyResize;
    int iQuality;

    IShellItem *psi;                                // shell item for each of the objects
    IStream *pstrm;                                 // posting stream (for file bits)
    STATSTG ststg;                                  // stat of the file
} TRANSFERITEM;


// post engines which handle the transfer of files accordingly

int _FreeTransferItems(TRANSFERITEM *pti, void *pvState = NULL);
HRESULT PublishViaCopyEngine(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
HRESULT PublishViaPost(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\unpage.cpp ===
#include "stdafx.h"
#include "unpage.h"
#pragma hdrstop



HRESULT ValidateName(LPCTSTR pszName)
{
    // We need to use illegal fat chars, says SBurns
    TCHAR* pszBadChars = ILLEGAL_FAT_CHARS;
    HRESULT hrStringOK = S_OK;

    while ((NULL != *pszBadChars) && (hrStringOK == S_OK))
    {
        if (NULL != StrChr(pszName, *pszBadChars))
        {
            hrStringOK = E_FAIL;
        }
        else
        {
            pszBadChars = CharNext(pszBadChars);
        }
    }

    if (SUCCEEDED(hrStringOK))
    {
        // See if the whole string is dots
        TCHAR* pszChar = const_cast<TCHAR*>(pszName);
        BOOL fAllDots = TRUE;

        while (fAllDots && (0 != *pszChar))
        {
            if (TEXT('.') == *pszChar)
            {
                pszChar = CharNext(pszChar);
            }
            else
            {
                fAllDots = FALSE;
            }
        }
        
        if (fAllDots)
        {
            hrStringOK = E_FAIL;
        }
    }

    return hrStringOK;
}


/*************************************
 CUsernamePageBase Implementation
*************************************/

BOOL CUsernamePageBase::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Limit the text of the username, fullname and description fields
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    HWND hwndFullName = GetDlgItem(hwnd, IDC_FULLNAME);
    HWND hwndDescription = GetDlgItem(hwnd, IDC_DESCRIPTION);

    Edit_LimitText(hwndUsername, ARRAYSIZE(m_pUserInfo->m_szUsername) - 1);
    SetWindowText(hwndUsername, m_pUserInfo->m_szUsername);

    Edit_LimitText(hwndFullName, ARRAYSIZE(m_pUserInfo->m_szFullName) - 1);
    SetWindowText(hwndFullName, m_pUserInfo->m_szFullName);

    Edit_LimitText(hwndDescription, ARRAYSIZE(m_pUserInfo->m_szComment) - 1);
    SetWindowText(hwndDescription, m_pUserInfo->m_szComment);

    return TRUE;
}


/*************************************
 CUsernameWizardPage Implementation
*************************************/

INT_PTR CUsernameWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }
    return FALSE;
}

BOOL CUsernameWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            SetWizardButtons(hwnd, GetParent(hwnd));
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;

        case PSN_WIZNEXT:
            // Save the data the user has entered
            FetchText(hwnd, IDC_USER, m_pUserInfo->m_szUsername, ARRAYSIZE(m_pUserInfo->m_szUsername));
            FetchText(hwnd, IDC_FULLNAME, m_pUserInfo->m_szFullName, ARRAYSIZE(m_pUserInfo->m_szFullName));
            FetchText(hwnd, IDC_DESCRIPTION, m_pUserInfo->m_szComment, ARRAYSIZE(m_pUserInfo->m_szComment));

            if (S_OK != ValidateName(m_pUserInfo->m_szUsername))
            {
                // Username is invalid. warn now
                ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_ERR_BADUSERNAME, MB_ICONERROR | MB_OK);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else if (::UserAlreadyHasPermission(m_pUserInfo, hwnd))
            {
                // Don't let the user continue if the user they've selected already
                // has permission to use this machine
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else
            {
                // We have a username (otherwise next would be disabled)
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            }
            return TRUE;
    }
    return FALSE;
}

BOOL CUsernameWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == EN_CHANGE)
    {
        SetWizardButtons(hwnd, GetParent(hwnd));
        return TRUE;
    }
    return FALSE;
}

void CUsernameWizardPage::SetWizardButtons(HWND hwnd, HWND hwndPropSheet)
{
    HWND hwndEdit = GetDlgItem(hwnd, IDC_USER);
    DWORD dwUNLength = GetWindowTextLength(hwndEdit);
    PropSheet_SetWizButtons(hwndPropSheet, (dwUNLength == 0) ? 0 : PSWIZB_NEXT);
}

/*************************************
 CUsernamePropertyPage Implementation
*************************************/

INT_PTR CUsernamePropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }
    return FALSE;
}

BOOL CUsernamePropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == EN_CHANGE)
    {
        PropSheet_Changed(GetParent(hwnd), hwnd);
        return TRUE;
    }
    return FALSE;
}

BOOL CUsernamePropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            TCHAR szTemp[256];
            HRESULT hr;
            LONG lResult = PSNRET_NOERROR;

            // Try to update the username
            FetchText(hwnd, IDC_USER, szTemp, ARRAYSIZE(szTemp));

            TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
            ::MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername,
                                        szDomainUser, ARRAYSIZE(szDomainUser));

            if (StrCmp(szTemp, m_pUserInfo->m_szUsername) != 0)
            {
                hr = m_pUserInfo->UpdateUsername(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                        IDS_USR_UPDATE_USERNAME_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            // Try to update the full name
            FetchText(hwnd, IDC_FULLNAME, szTemp, ARRAYSIZE(szTemp));
            if (StrCmp(szTemp, m_pUserInfo->m_szFullName) != 0)
            {
                hr = m_pUserInfo->UpdateFullName(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                        IDS_USR_UPDATE_FULLNAME_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            // Try to update the description
            FetchText(hwnd, IDC_DESCRIPTION, szTemp, ARRAYSIZE(szTemp));
            if (StrCmp(szTemp, m_pUserInfo->m_szComment) != 0)
            {
                hr = m_pUserInfo->UpdateDescription(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                        IDS_USR_UPDATE_DESCRIPTION_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lResult);
            return TRUE;
        }

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Map Network Drives/Network Places Wizard"
#define VER_INTERNALNAME_STR            "netplwiz"
#define VER_LEGALCOPYRIGHT_YEARS        "1998-2002"
#define VER_ORIGINALFILENAME_STR        "netplwiz.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\usercpl.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#include "unpage.h"
#include "netpage.h"
#include "password.h"
#include "cryptui.h"        // for certificate mgr
#pragma hdrstop


// Certificate Manager helper static functions and delay-load stuff
class CCertificateAPI
{
public:
    static BOOL ManagePasswords(HWND hwnd);
    static BOOL Wizard(HWND hwnd);

private:
    static BOOL m_fFailed;
    static HINSTANCE m_hInstCryptUI;
};

BOOL CCertificateAPI::m_fFailed = FALSE;
HINSTANCE CCertificateAPI::m_hInstCryptUI = NULL;


// CCertificateAPI::ManagePasswords - launch certificate manager
typedef BOOL (WINAPI *PFNCRYPTUIDLGCERTMGR)(IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);
BOOL CCertificateAPI::ManagePasswords(HWND hwnd)
{
    // Use shellexecuteex to open up the keyring control panel
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_DOENVSUBST;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpFile = L"%windir%\\system32\\rundll32.exe";
    shexinfo.lpParameters = L"shell32.dll,Control_RunDLL keymgr.dll";
    shexinfo.lpVerb = TEXT("open");

    return ShellExecuteEx(&shexinfo);
}


// CCertificateAPI::Wizard - launch the enrollment wizard

typedef BOOL (WINAPI *PFNCRYPTUIWIZCERTREQUEST)(IN DWORD dwFlags,
                                                IN OPTIONAL HWND, IN OPTIONAL LPCWSTR pwszWizardTitle,
                                                IN PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
                                                OUT OPTIONAL PCCERT_CONTEXT *ppCertContext, 
                                                OUT OPTIONAL DWORD *pCAdwStatus);

BOOL CCertificateAPI::Wizard(HWND hwnd)
{
    static PFNCRYPTUIWIZCERTREQUEST pCryptUIWizCertRequest = NULL;

    if ((m_hInstCryptUI == NULL) && (!m_fFailed))
    {
        m_hInstCryptUI = LoadLibrary(TEXT("cryptui.dll"));
    }

    if (m_hInstCryptUI != NULL)
    {
        pCryptUIWizCertRequest = (PFNCRYPTUIWIZCERTREQUEST)
            GetProcAddress(m_hInstCryptUI, "CryptUIWizCertRequest");
    }

    if (pCryptUIWizCertRequest)
    {
        CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW CertRequestPvkNew = {0};
        CertRequestPvkNew.dwSize=sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW); 

        CRYPTUI_WIZ_CERT_REQUEST_INFO CertRequestInfo = {0}; 
        CertRequestInfo.dwSize=sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO);
        CertRequestInfo.dwPurpose=CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.dwPvkChoice=CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
        CertRequestInfo.pPvkNew=&CertRequestPvkNew;

        // This can take a while!
        CWaitCursor cur;
        pCryptUIWizCertRequest(0, hwnd, NULL, &CertRequestInfo, NULL, NULL);  
    }
    else
    {
        m_fFailed = TRUE;
    }
    
    return (!m_fFailed);
}


// handle auto logon of users

class CAutologonUserDlg: public CDialog
{
public:
    CAutologonUserDlg(LPTSTR szInitialUser)
        {m_pszUsername = szInitialUser;}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    LPTSTR m_pszUsername;
};


INT_PTR CAutologonUserDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CAutologonUserDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    HWND hwndPassword = GetDlgItem(hwnd, IDC_PASSWORD);
    HWND hwndConfirm = GetDlgItem(hwnd, IDC_CONFIRMPASSWORD);

    // limit the text with of the controls
    Edit_LimitText(hwndUsername, MAX_USER);
    Edit_LimitText(hwndPassword, MAX_PASSWORD);
    Edit_LimitText(hwndConfirm, MAX_PASSWORD);

    // Populate the username field and set focus to password
    SetWindowText(hwndUsername, m_pszUsername);
    SetFocus(hwndPassword);
    BOOL fSetDefaultFocus = FALSE;

    return (fSetDefaultFocus);
}

BOOL CAutologonUserDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            {
                TCHAR szUsername[MAX_USER + 1];
                TCHAR szPassword[MAX_PASSWORD + 1];
                TCHAR szConfirm[MAX_PASSWORD + 1];

                FetchText(hwnd, IDC_USER, szUsername, ARRAYSIZE(szUsername));
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
                GetWindowText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), szConfirm, ARRAYSIZE(szConfirm));

                if (StrCmp(szConfirm, szPassword) != 0)
                {
                    // Display a message saying the passwords don't match
                    DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_ERR_PWDNOMATCH, MB_OK | MB_ICONERROR);
                    break;
                }
                else
                {
                    // Actually apply the autologon
                    SetAutoLogon(szUsername, szPassword);
                    SecureZeroMemory(szPassword, ARRAYSIZE(szPassword));
                }
            }
        
            // Fall through
        case IDCANCEL:
            EndDialog(hwnd, id);
    }

    return (TRUE);
}


// user list page (the main page the user sees)

class CUserlistPropertyPage: public CPropertyPage
{
public:
    CUserlistPropertyPage(CUserManagerData* pdata): m_pData(pdata) 
        {m_himlLarge = NULL;}
    ~CUserlistPropertyPage();

    static HRESULT AddUserToListView(HWND hwndList, CUserInfo* pUserInfo, BOOL fSelectUser = FALSE);

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnGetInfoTip(HWND hwndList, LPNMLVGETINFOTIP pGetInfoTip);
    BOOL OnListViewItemChanged(HWND hwnd);
    BOOL OnListViewDeleteItem(HWND hwndList, int iItem);
    BOOL OnHelp(HWND hwnd, LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hwnd);
    BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
    long OnApply(HWND hwnd);
    HRESULT InitializeListView(HWND hwndList, BOOL fShowDomain);
    HRESULT LaunchNewUserWizard(HWND hwndParent);
    HRESULT LaunchAddNetUserWizard(HWND hwndParent);
    HRESULT LaunchUserProperties(HWND hwndParent);
    HRESULT LaunchSetPasswordDialog(HWND hwndParent);
    CUserInfo* GetSelectedUserInfo(HWND hwndList);
    void OnRemove(HWND hwnd);
    int ConfirmRemove(HWND hwnd, CUserInfo* pUserInfo);
    void RemoveSelectedUserFromList(HWND hwndList, BOOL fFreeUserInfo);
    void SetPageState(HWND hwnd);
    HRESULT SetAutologonState(HWND hwnd, BOOL fAutologon);
    void SetupList(HWND hwnd);
    HPSXA AddExtraUserPropPages(ADDPROPSHEETDATA* ppsd, PSID psid);
    
    static int CALLBACK ListCompare(LPARAM lParam1, LPARAM lParam2, 
	    LPARAM lParamSort);

    CUserManagerData* m_pData;
    HIMAGELIST m_himlLarge;

    // When a column header is clicked, the list is sorted based on that column
    // When this happens, we store the column number here so that if the same
    // column is clicked again, we sort it in reverse. A 0 is stored if no
    // column should be sorted in reverse when clicked.
    int m_iReverseColumnIfSelected;

    BOOL m_fAutologonCheckChanged;
};


// Help ID array
static const DWORD rgUserListHelpIds[] =
{
    IDC_AUTOLOGON_CHECK,        IDH_AUTOLOGON_CHECK,
    IDC_LISTTITLE_STATIC,       IDH_USER_LIST,
    IDC_USER_LIST,              IDH_USER_LIST,
    IDC_ADDUSER_BUTTON,         IDH_ADDUSER_BUTTON,
    IDC_REMOVEUSER_BUTTON,      IDH_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,  IDH_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_STATIC,        IDH_PASSWORD_BUTTON,
    IDC_CURRENTUSER_ICON,       IDH_PASSWORD_BUTTON,
    IDC_PASSWORD_BUTTON,        IDH_PASSWORD_BUTTON,
    IDC_PWGROUP_STATIC,         (DWORD) -1,
    IDC_ULISTPG_TEXT,           (DWORD) -1,
    IDC_USERLISTPAGE_ICON,      (DWORD) -1,
    0, 0
};

// Control ID arrays for enabling/disabling/moving
static const UINT rgidDisableOnAutologon[] =
{
    IDC_USER_LIST,
    IDC_ADDUSER_BUTTON,
    IDC_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_BUTTON
};

static const UINT rgidDisableOnNoSelection[] =
{
    IDC_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_BUTTON
};

static const UINT rgidMoveOnNoAutologonCheck[] =
{
    IDC_LISTTITLE_STATIC,
    IDC_USER_LIST,
};

CUserlistPropertyPage::~CUserlistPropertyPage()
{
    if (m_himlLarge != NULL)
        ImageList_Destroy(m_himlLarge);
}

INT_PTR CUserlistPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_SETCURSOR, OnSetCursor);

        case WM_HELP: 
            return OnHelp(hwndDlg, (LPHELPINFO) lParam);

        case WM_CONTEXTMENU: 
            return OnContextMenu((HWND) wParam);

        case WM_ADDUSERTOLIST: 
            return SUCCEEDED(AddUserToListView(GetDlgItem(hwndDlg, IDC_USER_LIST), (CUserInfo*)lParam, (BOOL) wParam));
    }
    
    return FALSE;
}

BOOL CUserlistPropertyPage::OnHelp(HWND hwnd, LPHELPINFO pHelpInfo)
{
    WinHelp((HWND) pHelpInfo->hItemHandle, m_pData->GetHelpfilePath(), 
                    HELP_WM_HELP, (ULONG_PTR) (LPTSTR)rgUserListHelpIds);

    return TRUE;
}

BOOL CUserlistPropertyPage::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, m_pData->GetHelpfilePath(), 
                    HELP_CONTEXTMENU, (ULONG_PTR) (LPTSTR)rgUserListHelpIds);

    return TRUE;
}

BOOL CUserlistPropertyPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    InitializeListView(hwndList, m_pData->IsComputerInDomain());
    m_pData->Initialize(hwnd);

    SetupList(hwnd);
    
    m_fAutologonCheckChanged = FALSE;

    return TRUE;
}

BOOL CUserlistPropertyPage::OnListViewDeleteItem(HWND hwndList, int iItem)
{
    LVITEM lvi = {0};
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;
    ListView_GetItem(hwndList, &lvi);

    CUserInfo* pUserInfo = (CUserInfo*)lvi.lParam;
    if (NULL != pUserInfo)
    {
        delete pUserInfo;
    }
    return TRUE;
}

BOOL CUserlistPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            long applyEffect = OnApply(hwnd);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, applyEffect);
            break;
        }

        case LVN_GETINFOTIP:
            return OnGetInfoTip(pnmh->hwndFrom, (LPNMLVGETINFOTIP) pnmh);
            break;

        case LVN_ITEMCHANGED:
            return OnListViewItemChanged(hwnd);
            break;

        case LVN_DELETEITEM:
            return OnListViewDeleteItem(GetDlgItem(hwnd, IDC_USER_LIST), ((LPNMLISTVIEW) pnmh)->iItem);

        case NM_DBLCLK:
            LaunchUserProperties(hwnd);
            return TRUE;

        case LVN_COLUMNCLICK:
        {
            int iColumn = ((LPNMLISTVIEW) pnmh)->iSubItem;
        
            // Want to work with 1-based columns so we can use zero as
            // a special value
            iColumn += 1;

            // If we aren't showing the domain column because we're in
            // non-domain mode, then map column 2 (group since we're not in
            // domain mode to column 3 since the callback always expects 
            // the columns to be, "username", "domain", "group".
            if ((iColumn == 2) && (!m_pData->IsComputerInDomain()))
            {
                iColumn = 3;
            }

            if (m_iReverseColumnIfSelected == iColumn)
            {
                m_iReverseColumnIfSelected = 0;
                iColumn = -iColumn;
            }
            else
            {
                m_iReverseColumnIfSelected = iColumn;
            }

            ListView_SortItems(pnmh->hwndFrom, ListCompare, (LPARAM) iColumn);
            return TRUE;
        }

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL CUserlistPropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_ADDUSER_BUTTON:
            if (m_pData->IsComputerInDomain())
            {
                // Launch the wizard to add a network user to a local group
                LaunchAddNetUserWizard(hwnd);
            }
            else
            {
                // No domain; create a new local machine user
                LaunchNewUserWizard(hwnd);
            }
            return TRUE;

        case IDC_REMOVEUSER_BUTTON:
            OnRemove(hwnd);
            return TRUE;
        
        case IDC_AUTOLOGON_CHECK:
        {
            m_fAutologonCheckChanged = TRUE;
            BOOL fAutoLogon = (BST_UNCHECKED == SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));
            SetAutologonState(hwnd, fAutoLogon);
            SetPageState(hwnd);
            break;
        }

        case IDC_ADVANCED_BUTTON:
        {
            static const TCHAR szMMCCommandLineFormat[] = TEXT("mmc.exe /computer=%s %%systemroot%%\\system32\\lusrmgr.msc");
        
            TCHAR szMMCCommandLine[MAX_PATH];
            TCHAR szExpandedCommandLine[MAX_PATH];

            wnsprintf(szMMCCommandLine, ARRAYSIZE(szMMCCommandLine), szMMCCommandLineFormat, m_pData->GetComputerName());
            if (ExpandEnvironmentStrings(szMMCCommandLine, szExpandedCommandLine,  ARRAYSIZE(szExpandedCommandLine)) > 0)
            {
                PROCESS_INFORMATION pi;
                STARTUPINFO si = {0};
                si.cb = sizeof (si);
                if (CreateProcess(NULL, szExpandedCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
                {
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
            break;
        }

        case IDC_PASSWORD_BUTTON:
            LaunchSetPasswordDialog(hwnd);
            break;

        case IDC_USERPROPERTIES_BUTTON:
            LaunchUserProperties(hwnd);
            break;
    }

    return FALSE;
}

BOOL CUserlistPropertyPage::OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    BOOL fHandled = FALSE;

    if (m_pData->GetUserListLoader()->InitInProgress())
    {
        // If the thread is filling, handle by setting the appstarting cursor
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        fHandled = TRUE;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, fHandled);
    return TRUE;
}


BOOL CUserlistPropertyPage::OnGetInfoTip(HWND hwndList, LPNMLVGETINFOTIP pGetInfoTip)
{
    // Get the UserInfo structure for the selected item
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pGetInfoTip->iItem;
    lvi.iSubItem = 0;

    if ((lvi.iItem >= 0) && (ListView_GetItem(hwndList, &lvi)))
    {
        // Ensure full name and comment are available
        CUserInfo* pUserInfo = (CUserInfo*)lvi.lParam;
        pUserInfo->GetExtraUserInfo();

        // Make a string containing our "Full Name: %s\nComment: %s" message
        if ((pUserInfo->m_szFullName[0] != TEXT('\0')) &&
                        (pUserInfo->m_szComment[0] != TEXT('\0')))
        {
            // We have a full name and comment
            FormatMessageString(IDS_USR_TOOLTIPBOTH_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szFullName, pUserInfo->m_szComment);
        }
        else if (pUserInfo->m_szFullName[0] != TEXT('\0'))
        {
            // We only have full name
            FormatMessageString(IDS_USR_TOOLTIPFULLNAME_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szFullName);
        }
        else if (pUserInfo->m_szComment[0] != TEXT('\0'))
        {
            // We only have comment
            FormatMessageString(IDS_USR_TOOLTIPCOMMENT_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szComment);
        }
        else
        {
            // We have no extra information - do nothing (show no tip)
        }
    }

    return TRUE;
}

struct MYCOLINFO
{
    int percentWidth;
    UINT idString;
};

HRESULT CUserlistPropertyPage::InitializeListView(HWND hwndList, BOOL fShowDomain)
{
    // Array of icon ids icons 0, 1, and 2 respectively
    static const UINT rgIcons[] = 
    {
        IDI_USR_LOCALUSER_ICON,
        IDI_USR_DOMAINUSER_ICON,
        IDI_USR_GROUP_ICON
    };

    // Array of relative column widths, for columns 0, 1, and 2 respectively
    static const MYCOLINFO rgColWidthsWithDomain[] = 
    {
        {40, IDS_USR_NAME_COLUMN},
        {30, IDS_USR_DOMAIN_COLUMN},
        {30, IDS_USR_GROUP_COLUMN}
    };

    static const MYCOLINFO rgColWidthsNoDomain[] =
    {
        {50, IDS_USR_NAME_COLUMN},
        {50, IDS_USR_GROUP_COLUMN}
    };

    // Create a listview with three columns
    RECT rect;
    GetClientRect(hwndList, &rect);

    // Width of our window minus width of a verticle scroll bar minus one for the
    // little bevel at the far right of the header.
    int cxListView = (rect.right - rect.left) - GetSystemMetrics(SM_CXVSCROLL) - 1;

    // Make our columns
    int i;
    int nColumns; 
    const MYCOLINFO* pColInfo;
    if (fShowDomain)
    {
        nColumns = ARRAYSIZE(rgColWidthsWithDomain);
        pColInfo = rgColWidthsWithDomain;
    }
    else
    {
        nColumns = ARRAYSIZE(rgColWidthsNoDomain);
        pColInfo = rgColWidthsNoDomain;
    }      

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    for (i = 0; i < nColumns; i++)
    {
        TCHAR szText[MAX_PATH];
        // Load this column's caption
        LoadString(g_hinst, pColInfo[i].idString, szText, ARRAYSIZE(szText));

        lvc.iSubItem = i;
        lvc.cx = (int) MulDiv(pColInfo[i].percentWidth, cxListView, 100);
        lvc.pszText = szText;

        ListView_InsertColumn(hwndList, i, &lvc);
    }

    UINT flags = ILC_MASK;
    if(IS_WINDOW_RTL_MIRRORED(hwndList))
    {
        flags |= ILC_MIRROR;
    }

    // Create an image list for the listview
    HIMAGELIST himlSmall = ImageList_Create(16, 16, flags, 0, ARRAYSIZE(rgIcons));

    // Large image lists for the "set password" group icon
    m_himlLarge = ImageList_Create(32, 32, flags, 0, ARRAYSIZE(rgIcons));
    if (himlSmall && m_himlLarge)
    {
        // Add our icons to the image list
        for(i = 0; i < ARRAYSIZE(rgIcons); i ++)
        {
            HICON hIconSmall = (HICON) LoadImage(g_hinst, MAKEINTRESOURCE(rgIcons[i]), IMAGE_ICON, 16, 16, 0);
            if (hIconSmall)
            {
                ImageList_AddIcon(himlSmall, hIconSmall);
                DestroyIcon(hIconSmall);
            }

            HICON hIconLarge = (HICON) LoadImage(g_hinst, MAKEINTRESOURCE(rgIcons[i]), IMAGE_ICON, 32, 32, 0);
            if (hIconLarge)
            {
                ImageList_AddIcon(m_himlLarge, hIconLarge);
                DestroyIcon(hIconLarge);
            }
        }
    }

    ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);

    // Set extended styles for the listview
    ListView_SetExtendedListViewStyleEx(hwndList, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    // Set some settings for our tooltips - stolen from defview.cpp code
    HWND hwndInfoTip = ListView_GetToolTips(hwndList);
    if (hwndInfoTip != NULL)
    {
        //make the tooltip window  to be topmost window
        SetWindowPos(hwndInfoTip, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // increase the ShowTime (the delay before we show the tooltip) to 2 times the default value
        LRESULT uiShowTime = SendMessage(hwndInfoTip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
        SendMessage(hwndInfoTip, TTM_SETDELAYTIME, TTDT_INITIAL, uiShowTime * 2);
    }

    return S_OK;
}

HRESULT CUserlistPropertyPage::AddUserToListView(HWND hwndList, 
                                                 CUserInfo* pUserInfo,
                                                 BOOL fSelectUser /* = FALSE */)
{
    if (!pUserInfo->m_fAccountDisabled)
    {
        LVITEM lvi = { 0 };

        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; 
        lvi.pszText = pUserInfo->m_szUsername;
        lvi.iImage = pUserInfo->m_userType;
        lvi.lParam = (LPARAM) pUserInfo;

        // Always select the first loaded user
        if (ListView_GetItemCount(hwndList) == 0)
            fSelectUser = TRUE;

        if (fSelectUser)
        {
            lvi.mask |= LVIF_STATE;
            lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        }

        int iItem = ListView_InsertItem(hwndList, &lvi);
        if (iItem >= 0)
        {
            if (fSelectUser)
                ListView_EnsureVisible(hwndList, iItem, FALSE);           // Make the item visible

            // Success! Now add the subitems (domain, groups)
            lvi.iItem = iItem;
            lvi.mask = LVIF_TEXT;
    
            // Only add the domain field if the user is in a domain
            if (::IsComputerInDomain())
            {
                lvi.iSubItem = 1;
                lvi.pszText = pUserInfo->m_szDomain;
                ListView_SetItem(hwndList, &lvi);

                // User is in a domain; group should be third column
                lvi.iSubItem = 2;
            }
            else
            {
                // User isn't in a domain, group should be second column
                lvi.iSubItem = 1;
            }

            // Add group regardless of whether user is in a domain
            lvi.pszText = pUserInfo->m_szGroups;
            ListView_SetItem(hwndList, &lvi);
        }
    }
    /*
    else
    {
        // Do we leak the pUserInfo for disabled user accounts?
    }
    */

    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchNewUserWizard(HWND hwndParent)
{
    static const int nPages = 3;
    int cPages = 0;
    HPROPSHEETPAGE rghPages[nPages];

    // Create a new user record
    CUserInfo* pNewUser = new CUserInfo;
    if ( !pNewUser )
    {
        DisplayFormatMessage(hwndParent, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_CREATE_MISC_ERROR, MB_OK | MB_ICONERROR);
        return E_OUTOFMEMORY;
    }

    pNewUser->InitializeForNewUser();
    pNewUser->m_userType = CUserInfo::LOCALUSER;

    PROPSHEETPAGE psp = {0};
    // Common propsheetpage settings
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;

    // Page 1: Username entry page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_WIZARD_PAGE);
    CUsernameWizardPage page1(pNewUser);
    page1.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 2: Password page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_PASSWORD_WIZARD_PAGE);
    CPasswordWizardPage page2(pNewUser);
    page2.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 3: Local group addition
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_WIZARD_PAGE);
    CGroupWizardPage page3(pNewUser, m_pData->GetGroupList());
    page3.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    PROPSHEETHEADER psh = {0};
    psh.dwSize = sizeof (psh);
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = nPages;
    psh.phpage = rghPages;

    if (PropertySheet(&psh) == IDOK)
    {
        AddUserToListView(GetDlgItem(hwndParent, IDC_USER_LIST), pNewUser, TRUE);
    }
    else
    {
        // User clicked cancel
        delete pNewUser;
        pNewUser = NULL;
    }
    
    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchAddNetUserWizard(HWND hwndParent)
{
    HRESULT hr = S_OK;

    static const int nPages = 2;
    int cPages = 0;
    HPROPSHEETPAGE rghPages[nPages];

    // Create a new user record
    CUserInfo* pNewUser = new CUserInfo;
    if ( !pNewUser )
    {
        DisplayFormatMessage(hwndParent, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_CREATE_MISC_ERROR, MB_OK | MB_ICONERROR);
        return E_OUTOFMEMORY;
    }

    pNewUser->InitializeForNewUser();
    pNewUser->m_userType = CUserInfo::DOMAINUSER;

    PROPSHEETPAGE psp = {0};
    // Common propsheetpage settings
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;

    // Page 1: Find a network user page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_FINDNETUSER_WIZARD_PAGE);
    CNetworkUserWizardPage page1(pNewUser);
    page1.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 2: Local group addition
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_WIZARD_PAGE);
    CGroupWizardPage page2(pNewUser, m_pData->GetGroupList());
    page2.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    PROPSHEETHEADER psh = {0};
    psh.dwSize = sizeof (psh);
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = nPages;
    psh.phpage = rghPages;

    if (PropertySheet(&psh) == IDOK)
    {
        AddUserToListView(GetDlgItem(hwndParent, IDC_USER_LIST), pNewUser, TRUE);
        m_pData->UserInfoChanged(pNewUser->m_szUsername, pNewUser->m_szDomain);
    }
    else
    {
        // No errors, but the user clicked Cancel...
        delete pNewUser;
        pNewUser = NULL;
    }

    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchUserProperties(HWND hwndParent)
{
    HRESULT hr = S_OK;

    HWND hwndList = GetDlgItem(hwndParent, IDC_USER_LIST);
    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo != NULL)
    {
        pUserInfo->GetExtraUserInfo();

        // page addition information
        ADDPROPSHEETDATA apsd;
        apsd.nPages = 0;

        // Common propsheetpage settings
        PROPSHEETPAGE psp = {0};
        psp.dwSize = sizeof (psp);
        psp.hInstance = g_hinst;
        psp.dwFlags = PSP_DEFAULT;

        // If we have a local user, show both the username and group page, ow
        // just the group page
        // Page 1: Username entry page
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_PROP_PAGE);
        CUsernamePropertyPage page1(pUserInfo);
        page1.SetPropSheetPageMembers(&psp);

        // Only actually create the prop page if we have a local user
        if (pUserInfo->m_userType == CUserInfo::LOCALUSER)
        {
            apsd.rgPages[apsd.nPages++] = CreatePropertySheetPage(&psp);
        }

        // Always add the second page
        // Page 2: Local group addition
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_PROP_PAGE);
        CGroupPropertyPage page2(pUserInfo, m_pData->GetGroupList());
        page2.SetPropSheetPageMembers(&psp);
        apsd.rgPages[apsd.nPages++] = CreatePropertySheetPage(&psp);

        HPSXA hpsxa = AddExtraUserPropPages(&apsd, pUserInfo->m_psid);

        PROPSHEETHEADER psh = {0};
        psh.dwSize = sizeof (psh);
        psh.dwFlags = PSH_DEFAULT | PSH_PROPTITLE;

        TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
        MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

        psh.pszCaption = szDomainUser;
        psh.hwndParent = hwndParent;
        psh.hInstance = g_hinst;
        psh.nPages = apsd.nPages;
        psh.phpage = apsd.rgPages;
 
        int iRetCode = (int)PropertySheet(&psh);

        if (hpsxa != NULL)
            SHDestroyPropSheetExtArray(hpsxa);

        if (iRetCode == IDOK)
        {
            // PropSheet_Changed(GetParent(hwndParent), hwndParent);

            // So that we don't delete this pUserInfo when we remove
            // this user from the list:
            m_pData->UserInfoChanged(pUserInfo->m_szUsername, (pUserInfo->m_szDomain[0] == 0) ? NULL : pUserInfo->m_szDomain);
            RemoveSelectedUserFromList(hwndList, FALSE);
            AddUserToListView(hwndList, pUserInfo, TRUE);
        }
    }

    return S_OK;
}


CUserInfo* CUserlistPropertyPage::GetSelectedUserInfo(HWND hwndList)
{
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (iItem >= 0)
    {
        LVITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;
        if (ListView_GetItem(hwndList, &lvi))
        {
            return (CUserInfo*)lvi.lParam;
        }
    }
    return NULL;
}


void CUserlistPropertyPage::RemoveSelectedUserFromList(HWND hwndList, BOOL fFreeUserInfo)
{
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    // If we don't want to delete this user info, better set it to NULL
    if (!fFreeUserInfo)
    {
        LVITEM lvi = {0};
        lvi.iItem = iItem;
        lvi.mask = LVIF_PARAM;
        lvi.lParam = (LPARAM) (CUserInfo*) NULL;
        ListView_SetItem(hwndList, &lvi);
    }

    ListView_DeleteItem(hwndList, iItem);

    int iSelect = iItem > 0 ? iItem - 1 : 0;
    ListView_SetItemState(hwndList, iSelect, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    SetFocus(hwndList);
}


void CUserlistPropertyPage::OnRemove(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);

    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo)
    {
        if (ConfirmRemove(hwnd, pUserInfo) == IDYES)
        {
            if (SUCCEEDED(pUserInfo->Remove()))
            {
                RemoveSelectedUserFromList(hwndList, TRUE);
            }
            else
            {
               TCHAR szDisplayName[MAX_USER + MAX_DOMAIN + 2];
                ::MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, 
                                        szDisplayName, ARRAYSIZE(szDisplayName));

                DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_REMOVE_MISC_ERROR, MB_ICONERROR | MB_OK, szDisplayName);
            }
        }
    }
}

int CUserlistPropertyPage::ConfirmRemove(HWND hwnd, CUserInfo* pUserInfo)
{
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));
    return DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_USR_REMOVEUSER_WARNING, 
                                                    MB_ICONEXCLAMATION | MB_YESNO, szDomainUser);
}

void CUserlistPropertyPage::SetPageState(HWND hwnd)
{
    BOOL fAutologon = (BST_UNCHECKED == 
                SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));

    EnableControls(hwnd, rgidDisableOnAutologon, ARRAYSIZE(rgidDisableOnAutologon),
                !fAutologon);

    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo)
    {
        TCHAR szPWGroup[128];
        FormatMessageString(IDS_USR_PWGROUP_FORMAT, szPWGroup, ARRAYSIZE(szPWGroup), pUserInfo->m_szUsername);
        SetWindowText(GetDlgItem(hwnd, IDC_PWGROUP_STATIC), szPWGroup);

        TCHAR szPWMessage[128];

        // If the logged on user is the selected user
        CUserInfo* pLoggedOnUser = m_pData->GetLoggedOnUserInfo();
        if ((StrCmpI(pUserInfo->m_szUsername, pLoggedOnUser->m_szUsername) == 0) &&
                        (StrCmpI(pUserInfo->m_szDomain, pLoggedOnUser->m_szDomain) == 0))
        {
            LoadString(g_hinst, IDS_USR_YOURPWMESSAGE_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage));
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_BUTTON), FALSE);
        }
        // If the user is a local user
        else if (pUserInfo->m_userType == CUserInfo::LOCALUSER)
        {
            // We can set this user's password
            FormatMessageString(IDS_USR_PWMESSAGE_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage), pUserInfo->m_szUsername);
        }
        else
        {
            // Nothing can be done with this user's password
            // the selected user may be a domain user or a group or something
            // We can set this user's password
            FormatMessageString(IDS_USR_CANTCHANGEPW_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage), pUserInfo->m_szUsername);
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_BUTTON), FALSE);
        }

        SetWindowText(GetDlgItem(hwnd, IDC_PASSWORD_STATIC), szPWMessage);

        // Set the icon for the user
        HICON hIcon = ImageList_GetIcon(m_himlLarge, pUserInfo->m_userType, ILD_NORMAL);
        Static_SetIcon(GetDlgItem(hwnd, IDC_CURRENTUSER_ICON), hIcon);
    }
    else
    {
        EnableControls(hwnd, rgidDisableOnNoSelection, ARRAYSIZE(rgidDisableOnNoSelection), FALSE);
    }
}

HRESULT CUserlistPropertyPage::SetAutologonState(HWND hwnd, BOOL fAutologon)
{
    PropSheet_Changed(GetParent(hwnd), hwnd);
    return S_OK;
}

BOOL CUserlistPropertyPage::OnListViewItemChanged(HWND hwnd)
{
    SetPageState(hwnd);
    return TRUE;
}

long CUserlistPropertyPage::OnApply(HWND hwnd)
{
    long applyEffect = PSNRET_NOERROR;

    BOOL fAutologonSet = (BST_UNCHECKED == SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));
    if (!fAutologonSet)
    {
        ClearAutoLogon();           // Ensure autologon is cleared
    }
    else if (m_fAutologonCheckChanged)
    {
        CUserInfo* pSelectedUser = GetSelectedUserInfo(GetDlgItem(hwnd, IDC_USER_LIST));

        TCHAR szNullName[] = TEXT("");
        CAutologonUserDlg dlg((pSelectedUser != NULL) ? pSelectedUser->m_szUsername : szNullName);
        if (dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_AUTOLOGON_DLG), hwnd) == IDCANCEL)
        {
            applyEffect = PSNRET_INVALID_NOCHANGEPAGE;
        }
    }

    m_fAutologonCheckChanged = FALSE;

    if (applyEffect == PSNRET_INVALID_NOCHANGEPAGE)
    {
        m_pData->Initialize(hwnd);          // Reload the data and list
        SetupList(hwnd);
    }

    return applyEffect;
}

void CUserlistPropertyPage::SetupList(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    
    // Disable autologon check box in the domain case where autologon isn't // enabled
    HWND hwndCheck = GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK);
    if (m_pData->IsComputerInDomain() && !m_pData->IsAutologonEnabled())
    {
        ShowWindow(hwndCheck, SW_HIDE);
        EnableWindow(hwndCheck, FALSE);

        // Move most controls up a bit if the autologon is not visible
        RECT rcBottom;
        GetWindowRect(GetDlgItem(hwnd, IDC_LISTTITLE_STATIC), &rcBottom);

        RECT rcTop;
        GetWindowRect(hwndCheck, &rcTop);

        int dy = rcTop.top - rcBottom.top;

        OffsetControls(hwnd, rgidMoveOnNoAutologonCheck, 
                          ARRAYSIZE(rgidMoveOnNoAutologonCheck), 0, dy);

        // Grow the list by this amount also
        RECT rcList;
        GetWindowRect(hwndList, &rcList);

        SetWindowPos(hwndList, NULL, 0, 0, rcList.right - rcList.left, 
                           rcList.bottom - rcList.top - dy, SWP_NOZORDER|SWP_NOMOVE);
    }

    SendMessage(hwndCheck, BM_SETCHECK, 
                            m_pData->IsAutologonEnabled() ? BST_UNCHECKED : BST_CHECKED, 0);

    // Set the text in the set password group.
    SetPageState(hwnd);
}

HRESULT CUserlistPropertyPage::LaunchSetPasswordDialog(HWND hwndParent)
{
    CUserInfo* pUserInfo = GetSelectedUserInfo(GetDlgItem(hwndParent, IDC_USER_LIST));
    if ((pUserInfo != NULL) && (pUserInfo->m_userType == CUserInfo::LOCALUSER))
    {
        CChangePasswordDlg dlg(pUserInfo);
        dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_SETPASSWORD_DLG), hwndParent);
        return S_OK;
    }
    return E_FAIL;
}

#define MAX_EXTRA_PAGES   10

HPSXA CUserlistPropertyPage::AddExtraUserPropPages(ADDPROPSHEETDATA* ppsd, PSID psid)
{
    HPSXA hpsxa = NULL;

    IDataObject *pdo;
    HRESULT hr = CUserSidDataObject_CreateInstance(psid, &pdo);
    if (SUCCEEDED(hr))
    {
        hpsxa = SHCreatePropSheetExtArrayEx(HKEY_LOCAL_MACHINE, REGSTR_USERPROPERTIES_SHEET, MAX_EXTRA_PAGES, pdo);
        if (hpsxa)
        {
            SHAddFromPropSheetExtArray(hpsxa, AddPropSheetPageCallback, (LPARAM) ppsd);
        }
        pdo->Release();
    }
    return hpsxa;
}


// ListCompare
//  Compares list items in for sorting the listview by column
//  lParamSort gets the 1-based column index. If lParamSort is negative
//  it indicates that the given column should be sorted in reverse.

int CUserlistPropertyPage::ListCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CUserInfo* pUserInfo1 = (CUserInfo*)lParam1;
    CUserInfo* pUserInfo2 = (CUserInfo*)lParam2;
    int iColumn = (int)lParamSort;

    BOOL fReverse = FALSE;
    if (iColumn < 0)
    {
        fReverse = TRUE;
        iColumn = -iColumn;
    }

    int iResult = 0;            // they match...    
    switch (iColumn)
    {
        case 1:
            iResult = lstrcmpi(pUserInfo1->m_szUsername, pUserInfo2->m_szUsername);
            break;

        case 2:
            iResult = lstrcmpi(pUserInfo1->m_szDomain, pUserInfo2->m_szDomain);
            break;

        case 3:
            iResult = lstrcmpi(pUserInfo1->m_szGroups, pUserInfo2->m_szGroups);
            break;
    }
    
    if (fReverse)
        iResult = -iResult;
    
    return iResult;
}


// The DoModal call for this dialog will return IDOK if the applet should be
// shown or IDCANCEL if the users.cpl should exit without displaying the applet.

// dsheldon - TODO: Remove this dialog and don't let non-admins runas the cpl

class CSecurityCheckDlg: public CDialog
{
public:
    CSecurityCheckDlg(LPCTSTR pszDomainUser):
        m_pszDomainUser(pszDomainUser)
        {}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int id, NMHDR* pnmhdr);
    HRESULT RelaunchAsUser(HWND hwnd);

    LPCTSTR m_pszDomainUser;
};


// implementation

INT_PTR CSecurityCheckDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }
    return FALSE;
}

BOOL CSecurityCheckDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // First we must check if the current user is a local administrator; if this is
    // the case, our dialog doesn't even display
    
    BOOL fIsLocalAdmin;
    if (SUCCEEDED(IsUserLocalAdmin(NULL, &fIsLocalAdmin)))
    {
        if (fIsLocalAdmin)
        {
            EndDialog(hwnd, IDOK);  // We want to continue and launch the applet (don't display the security check dlg)
        }
    }
    else
    {
        EndDialog(hwnd, IDCANCEL);
    }

    // Set the "can't launch User Options" message
    TCHAR szUsername[MAX_USER + 1];
    DWORD cchUsername = ARRAYSIZE(szUsername);

    TCHAR szDomain[MAX_DOMAIN + 1];
    DWORD cchDomain = ARRAYSIZE(szDomain);
    if (GetCurrentUserAndDomainName(szUsername, &cchUsername, szDomain, &cchDomain))
    {
        TCHAR szDomainAndUsername[MAX_DOMAIN + MAX_USER + 2];

        MakeDomainUserString(szDomain, szUsername, szDomainAndUsername, ARRAYSIZE(szDomainAndUsername));

        TCHAR szMessage[256];
        if (FormatMessageString(IDS_USR_CANTRUNCPL_FORMAT, szMessage, ARRAYSIZE(szMessage), szDomainAndUsername))
        {
            SetWindowText(GetDlgItem(hwnd, IDC_CANTRUNCPL_STATIC), szMessage);
        }

        TCHAR szAdministrator[MAX_USER + 1];

        LoadString(g_hinst, IDS_ADMINISTRATOR, szAdministrator, ARRAYSIZE(szAdministrator));

        SetWindowText(GetDlgItem(hwnd, IDC_USER), szAdministrator);

        TCHAR szMachine[MAX_COMPUTERNAME + 1];
        
        DWORD dwSize = ARRAYSIZE(szMachine);
        ::GetComputerName(szMachine, &dwSize);

        SetWindowText(GetDlgItem(hwnd, IDC_DOMAIN), szMachine);
    }

    // Limit the text in the edit fields
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    Edit_LimitText(hwndUsername, MAX_USER);

    HWND hwndDomain = GetDlgItem(hwnd, IDC_DOMAIN);
    Edit_LimitText(hwndDomain, MAX_DOMAIN);

    HWND hwndPassword = GetDlgItem(hwnd, IDC_PASSWORD);
    Edit_LimitText(hwndPassword, MAX_PASSWORD);

    if (!IsComputerInDomain())
    {
        // Don't need domain box
        EnableWindow(hwndDomain, FALSE);
        ShowWindow(hwndDomain, SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_DOMAIN_STATIC), SW_HIDE);

        // Move up the OK/Cancel buttons and text and shrink the dialog
        RECT rcDomain;
        GetWindowRect(hwndDomain, &rcDomain);

        RECT rcPassword;
        GetWindowRect(hwndPassword, &rcPassword);
        
        int dy = (rcPassword.top - rcDomain.top);
        // dy is negative 

        OffsetWindow(GetDlgItem(hwnd, IDOK), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDCANCEL), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDC_PASSWORD_STATIC), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDC_OTHEROPTIONS_LINK), 0, dy);

        RECT rcDialog;
        GetWindowRect(hwnd, &rcDialog);

        rcDialog.bottom += dy;  

        MoveWindow(hwnd, rcDialog.left, rcDialog.top, rcDialog.right-rcDialog.left,
                    rcDialog.bottom-rcDialog.top, FALSE);
    }

    return TRUE;
}

BOOL CSecurityCheckDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            if (SUCCEEDED(RelaunchAsUser(hwnd)))
            {
                EndDialog(hwnd, IDCANCEL);
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return TRUE;
    }
    return FALSE;
}

BOOL CSecurityCheckDlg::OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    BOOL fHandled = FALSE;

    switch (pnmhdr->code)
    {
    // Handle link window clicks
    case NM_CLICK:
    case NM_RETURN:
        {
            if (IDC_OTHEROPTIONS_LINK == id)
            {
                // First link in the control is "manage passwords", second is "passport wizard"

                NMLINKWND* pnm = (NMLINKWND*) pnmhdr;
                if (0 == pnm->item.iLink)
                {
                    // Launch "manage passwords"
                    CCertificateAPI::ManagePasswords(hwnd);
                }
                else if (1 == pnm->item.iLink)
                {
                    // Launch passport wizard
                    IPassportWizard *pPW;
                    if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
                    {
                        pPW->SetOptions(PPW_LAUNCHEDBYUSER);
                        pPW->Show(hwnd);
                        pPW->Release();
                    }
                }
                fHandled = TRUE;
            }
        }
        break;
    };

    return fHandled;
}

HRESULT CSecurityCheckDlg::RelaunchAsUser(HWND hwnd)
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;

    TCHAR szUsername[MAX_USER + 1];
    FetchText(hwnd, IDC_USER, szUsername, ARRAYSIZE(szUsername));

    TCHAR szDomain[MAX_DOMAIN + 1];
    FetchText(hwnd, IDC_DOMAIN, szDomain, ARRAYSIZE(szDomain));

    // If the user didn't type a domain
    if (szDomain[0] == TEXT('\0'))
    {
        // Use this machine as the domain
        DWORD cchComputername = ARRAYSIZE(szDomain);
        ::GetComputerName(szDomain, &cchComputername);
    }

    TCHAR szPassword[MAX_PASSWORD + 1];
    GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
    
    // Now relaunch ourselves with this information
    STARTUPINFO startupinfo = {0};
    startupinfo.cb = sizeof (startupinfo);

    WCHAR c_szCommandLineFormat[] = L"rundll32.exe netplwiz.dll,UsersRunDll %s";

    // Put the "real" user name in the command-line so that we know what user is
    // actually logged on to the machine even though we are re-launching in a different
    // user context
    WCHAR szCommandLine[ARRAYSIZE(c_szCommandLineFormat) + MAX_DOMAIN + MAX_USER + 2];
    wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), c_szCommandLineFormat, m_pszDomainUser);

    PROCESS_INFORMATION process_information;
    if (CreateProcessWithLogonW(szUsername, szDomain, szPassword, LOGON_WITH_PROFILE, NULL,
        szCommandLine, 0, NULL, NULL, &startupinfo, &process_information))
    {
        CloseHandle(process_information.hProcess);
        CloseHandle(process_information.hThread);
        hr = S_OK;
    }
    else
    {
        DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_USR_CANTOPENCPLASUSER_ERROR, MB_OK|MB_ICONERROR);
    }
    return hr;
}

// Advanced Property Page

class CAdvancedPropertyPage: public CPropertyPage
{
public:
    CAdvancedPropertyPage(CUserManagerData* pdata): 
      m_pData(pdata),
      m_fRebootRequired(FALSE) {}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnHelp(HWND hwnd, LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hwnd);
    void ReadRequireCad(BOOL* pfRequireCad, BOOL* pfSetInPolicy);
    void WriteRequireCad(BOOL fRequireCad);

    CUserManagerData* m_pData;
    BOOL m_fRebootRequired;

};

// Relevant regkeys/regvals
#define REGKEY_WINLOGON         \
         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")

#define REGKEY_WINLOGON_POLICY  \
         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")

#define REGVAL_DISABLE_CAD      TEXT("DisableCAD")

void CAdvancedPropertyPage::ReadRequireCad(BOOL* pfRequireCad, BOOL* pfSetInPolicy)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    BOOL fDisableCad;
    NT_PRODUCT_TYPE nttype;

    *pfRequireCad = TRUE;
    *pfSetInPolicy = FALSE; 

    if (!RtlGetNtProductType(&nttype))
    {
        nttype = NtProductWinNt;
    }

    // By default, don't require CAD for workstations not
    // on a domain only
    if ((NtProductWinNt == nttype) && !IsComputerInDomain())
    {
        *pfRequireCad = FALSE;
    }

    // Read the setting from the machine preferences
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON, 0, 
        KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        if (ERROR_SUCCESS == RegQueryValueEx (hkey, REGVAL_DISABLE_CAD, NULL, &dwType,
                        (LPBYTE) &fDisableCad, &dwSize))
        {
            *pfRequireCad = !fDisableCad;
        }

        RegCloseKey (hkey);
    }

    // Check if C-A-D is disabled via policy

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON_POLICY, 0, KEY_READ,
                     &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        if (ERROR_SUCCESS == RegQueryValueEx (hkey, REGVAL_DISABLE_CAD, NULL, &dwType,
                            (LPBYTE) &fDisableCad, &dwSize))
        {
            *pfRequireCad = !fDisableCad;
            *pfSetInPolicy = TRUE;
        }

        RegCloseKey (hkey);
    }
}

void CAdvancedPropertyPage::WriteRequireCad(BOOL fRequireCad)
{
    HKEY hkey;
    DWORD dwDisp;
    BOOL fDisableCad = !fRequireCad;

    if (ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON, 0, 
        NULL, 0, KEY_WRITE, NULL, &hkey, &dwDisp))
    {
        RegSetValueEx(hkey, REGVAL_DISABLE_CAD, 0, REG_DWORD,
                        (LPBYTE) &fDisableCad, sizeof(fDisableCad));

        RegCloseKey (hkey);
    }
}

static const DWORD rgAdvHelpIds[] = 
{
    IDC_ADVANCED_BUTTON,        IDH_ADVANCED_BUTTON,
    IDC_BOOT_ICON,              IDH_SECUREBOOT_CHECK,
    IDC_BOOT_TEXT,              IDH_SECUREBOOT_CHECK,
    IDC_REQUIRECAD,             IDH_SECUREBOOT_CHECK,
    IDC_MANAGEPWD_BUTTON,       IDH_MANAGEPWD_BUTTON,
    IDC_PASSPORTWIZARD,         IDH_PASSPORTWIZARD,
    IDC_CERT_ICON,              (DWORD) -1,
    IDC_CERT_TEXT,              (DWORD) -1,
    0, 0
};

INT_PTR CAdvancedPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        case WM_HELP: return OnHelp(hwndDlg, (LPHELPINFO) lParam);
        case WM_CONTEXTMENU: return OnContextMenu((HWND) wParam);
    }
    
    return FALSE;
}

BOOL CAdvancedPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    BOOL fReturn = FALSE;
    switch (pnmh->code)
    {
        case PSN_APPLY:
            {
                HWND hwndCheck = GetDlgItem(hwnd, IDC_REQUIRECAD);
                BOOL fRequireCad = (BST_CHECKED == Button_GetCheck(hwndCheck));

                // See if a change is really necessary
                BOOL fOldRequireCad;
                BOOL fDummy;

                ReadRequireCad(&fOldRequireCad, &fDummy);

                if (fRequireCad != fOldRequireCad)
                {
                    WriteRequireCad(fRequireCad);
                    // m_fRebootRequired = TRUE;
                    // Uncomment the line above if it ever becomes necessary to reboot the machine - it isn't now.
                }

                // xxx->lParam == 0 means Ok as opposed to Apply
                if ((((PSHNOTIFY*) pnmh)->lParam) && m_fRebootRequired) 
                {
                    PropSheet_RebootSystem(GetParent(hwnd));
                }

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                fReturn = TRUE;
            }
            break;
    }
    return fReturn;
}

BOOL CAdvancedPropertyPage::OnHelp(HWND hwnd, LPHELPINFO pHelpInfo)
{
    WinHelp((HWND) pHelpInfo->hItemHandle, m_pData->GetHelpfilePath(), 
            HELP_WM_HELP, (ULONG_PTR) (LPTSTR)rgAdvHelpIds);

    return TRUE;
}

BOOL CAdvancedPropertyPage::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, m_pData->GetHelpfilePath(), HELP_CONTEXTMENU, (ULONG_PTR) (LPTSTR)rgAdvHelpIds);

    return TRUE;
}

BOOL CAdvancedPropertyPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Do the required mucking for the Require C-A-D checkbox...
    // Read the setting for the require CAD checkbox
    BOOL fRequireCad;
    BOOL fSetInPolicy;

    ReadRequireCad(&fRequireCad, &fSetInPolicy);

    HWND hwndCheck = GetDlgItem(hwnd, IDC_REQUIRECAD);
    // Disable the check if set in policy
    EnableWindow(hwndCheck, !fSetInPolicy);

    // Set the check accordingly
    Button_SetCheck(hwndCheck, 
        fRequireCad ? BST_CHECKED : BST_UNCHECKED);

    return TRUE;
}
    
BOOL CAdvancedPropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDC_MANAGEPWD_BUTTON:
        {
            CCertificateAPI::ManagePasswords(hwnd);
        }
        break;

    case IDC_PASSPORTWIZARD:
        {
            IPassportWizard *pPW;
            if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
            {
                pPW->SetOptions(PPW_LAUNCHEDBYUSER);
                pPW->Show(hwnd);
                pPW->Release();
            }
        }
        break;

    case IDC_ADVANCED_BUTTON:
        {
            // Launch the MMC local user manager
            STARTUPINFO startupinfo = {0};
            startupinfo.cb = sizeof (startupinfo);

            PROCESS_INFORMATION process_information;

            static const TCHAR szMMCCommandLine[] = 
                TEXT("mmc.exe %systemroot%\\system32\\lusrmgr.msc computername=localmachine");
            
            TCHAR szExpandedCommandLine[MAX_PATH];

            if (ExpandEnvironmentStrings(szMMCCommandLine, szExpandedCommandLine, 
                ARRAYSIZE(szExpandedCommandLine)) > 0)
            {
                if (CreateProcess(NULL, szExpandedCommandLine, NULL, NULL, FALSE, 0, NULL, NULL,
                    &startupinfo, &process_information))
                {
                    CloseHandle(process_information.hProcess);
                    CloseHandle(process_information.hThread);
                }
            }
        }
        break;

    case IDC_REQUIRECAD:
        PropSheet_Changed(GetParent(hwnd), hwnd);
        break;
    }

    return FALSE;
}


// users control panel entry point

void APIENTRY UsersRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    *szDomainUser = 0;

    // Get the "real" user of this machine - this may be passed in the cmdline
    if (0 == *pszCmdLine)
    {
        // user wasn't passed, assume its the currently logged on user
        TCHAR szUser[MAX_USER + 1];
        DWORD cchUser = ARRAYSIZE(szUser);
        TCHAR szDomain[MAX_DOMAIN + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);

        if (0 != GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain))
        {
            MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));
        }
    }
    else
    {
        // User name was passed in, just copy it
        MultiByteToWideChar(GetACP(), 0, pszCmdLine, -1, szDomainUser, ARRAYSIZE(szDomainUser));
    }

    // Initialize COM, but continue even if this fails.
    BOOL fComInited = SUCCEEDED(CoInitialize(NULL));

    // See if we're already running
    TCHAR szCaption[256];
    LoadString(g_hinst, IDS_USR_APPLET_CAPTION, szCaption, ARRAYSIZE(szCaption));
    CEnsureSingleInstance ESI(szCaption);

    if (!ESI.ShouldExit())
    {
        LinkWindow_RegisterClass();

        // Create the security check dialog to ensure the logged-on user
        // is a local admin
        CSecurityCheckDlg dlg(szDomainUser);

        if (dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_SECURITYCHECK_DLG), NULL) == IDOK)
        {
            // Create the shared user mgr object
            CUserManagerData data(szDomainUser);

            // Create the property sheet and page template
            // Maximum number of pages
            ADDPROPSHEETDATA ppd;
            ppd.nPages = 0;

            // Settings common to all pages
            PROPSHEETPAGE psp = {0};
            psp.dwSize = sizeof (psp);
            psp.hInstance = g_hinst;

            // Create the userlist property sheet page and its managing object
            psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERLIST_PAGE);
            CUserlistPropertyPage userListPage(&data);
            userListPage.SetPropSheetPageMembers(&psp);
            ppd.rgPages[ppd.nPages++] = CreatePropertySheetPage(&psp);
    
            psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_ADVANCED_PAGE);
            CAdvancedPropertyPage advancedPage(&data);
            advancedPage.SetPropSheetPageMembers(&psp);
            ppd.rgPages[ppd.nPages++] = CreatePropertySheetPage(&psp);

            HPSXA hpsxa = SHCreatePropSheetExtArrayEx(HKEY_LOCAL_MACHINE, REGSTR_USERSANDPASSWORDS_CPL, 10, NULL);
            if (hpsxa != NULL)
                SHAddFromPropSheetExtArray(hpsxa, AddPropSheetPageCallback, (LPARAM)&ppd);

            // Create the prop sheet
            PROPSHEETHEADER psh = {0};
            psh.dwSize = sizeof (psh);
            psh.dwFlags = PSH_DEFAULT;
            psh.hwndParent = hwndStub;
            psh.hInstance = g_hinst;
            psh.pszCaption = szCaption;
            psh.nPages = ppd.nPages;
            psh.phpage = ppd.rgPages;

            // Show the property sheet
            int iRetCode = PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_USR_USERS));
    
            if (hpsxa != NULL)
            {
                SHDestroyPropSheetExtArray(hpsxa);
            }

            if (iRetCode == -1)
            {
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
                // Special case when we must restart or reboot
                if (iRetCode == ID_PSREBOOTSYSTEM)
                {
                    RestartDialogEx(NULL, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);                
                }
                else if (iRetCode == ID_PSRESTARTWINDOWS)
                {
                    RestartDialogEx(NULL, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);                
                }
                else if (data.LogoffRequired())
                {
                    int iLogoff = DisplayFormatMessage(NULL, IDS_USERSANDPASSWORDS, IDS_LOGOFFREQUIRED, MB_YESNO | MB_ICONQUESTION);

                    if (iLogoff == IDYES)
                    {
                        // Tell explorer to log off the "real" logged on user. We need to do this
                        // since they may be running U&P as a different user.
                        HWND hwnd = FindWindow(TEXT("Shell_TrayWnd"), TEXT(""));
                        if ( hwnd )
                        {
                            UINT uMsg = RegisterWindowMessage(TEXT("Logoff User"));

                            PostMessage(hwnd, uMsg, 0,0);
                        } 
                    }
                }
            }
        }
        else
        {
            // Security check told us to exit; either another instance of the CPL is starting
            // with admin priviledges or the user cancelled on the sec. check. dlg.
            hr = E_FAIL;
        }
    }

    if (fComInited)
        CoUninitialize();
}


// user property property page object

class CUserPropertyPages: public IShellExtInit, IShellPropSheetExt
{
public:
    CUserPropertyPages();
    ~CUserPropertyPages();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdo, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
        { return E_NOTIMPL; }

private:
    LONG _cRef;

    CUserInfo *_pUserInfo;                     // The user for the property sheet
    CUsernamePropertyPage *_pUserNamePage;     // Basic info page, only shown for local users
    CGroupPropertyPage *_pGroupPage;           // The group page, which is common to both local and domain users
    CGroupInfoList _GroupList;                 // The group list, used by the group page
};


CUserPropertyPages::CUserPropertyPages() : 
    _cRef(1)
{   
    DllAddRef();
}
    
CUserPropertyPages::~CUserPropertyPages()
{
    if (_pUserInfo)
        delete _pUserInfo;
    if (_pUserNamePage)
        delete _pUserNamePage;
    if (_pGroupPage)
        delete _pGroupPage;

    DllRelease();
}

ULONG CUserPropertyPages::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CUserPropertyPages::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CUserPropertyPages::QueryInterface(REFIID riid, LPVOID* ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserPropertyPages, IShellExtInit),            // IID_IShellExtInit
        QITABENT(CUserPropertyPages, IShellPropSheetExt),       // IID_IShellPropSheetExt
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IShellExtInit

HRESULT CUserPropertyPages::Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdo, HKEY hkeyProgID)
{
    // Request the user's SID from the data object
    FORMATETC fmt = {0};
    fmt.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_USERPROPPAGESSID);
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.tymed = TYMED_HGLOBAL;

    STGMEDIUM medium = { 0 };
    HRESULT hr = pdo->GetData(&fmt, &medium);
    if (SUCCEEDED(hr))
    {
        // medium.hGlobal is the user's SID; make sure it isn't null and that
        // we haven't already set our copy of the SID
        if ((medium.hGlobal != NULL) && (_pUserInfo == NULL))
        {
            PSID psid = (PSID) GlobalLock(medium.hGlobal);
            if (IsValidSid(psid))
            {
                // Create a user info structure to party on
                _pUserInfo = new CUserInfo;
                if (_pUserInfo)
                {
                    hr = _pUserInfo->Load(psid, TRUE);
                    if (SUCCEEDED(hr))
                    {
                        hr = _GroupList.Initialize();                          // Get the groups
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;              // hGlobal was NULL or prop sheet was already init'ed
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


// AddPages - handles adding the property pages

HRESULT CUserPropertyPages::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    PROPSHEETPAGE psp = {0};
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;

    if (_pUserInfo->m_userType == CUserInfo::LOCALUSER)
    {
        // Add the local user prop pages
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_PROP_PAGE);

        _pUserNamePage = new CUsernamePropertyPage(_pUserInfo);
        if (_pUserNamePage != NULL)
        {
            _pUserNamePage->SetPropSheetPageMembers(&psp);
            lpfnAddPage(CreatePropertySheetPage(&psp), lParam);
        }
    }

    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_PROP_PAGE);

    _pGroupPage = new CGroupPropertyPage(_pUserInfo, &_GroupList);
    if (_pGroupPage != NULL)
    {
        _pGroupPage->SetPropSheetPageMembers(&psp);
        lpfnAddPage(CreatePropertySheetPage(&psp), lParam);
    }

    return S_OK;
}

STDAPI CUserPropertyPages_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CUserPropertyPages *pupp = new CUserPropertyPages();
    if (!pupp)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pupp->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pupp->Release();
    return hr;
}



// expose the SID for a user via an IDataObject

class CUserSidDataObject: public IDataObject
{
public:
    CUserSidDataObject();
    ~CUserSidDataObject();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDataObject
    STDMETHODIMP GetData(FORMATETC* pFormatEtc, STGMEDIUM* pMedium);
    STDMETHODIMP GetDataHere(FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
        { return E_NOTIMPL; }
    STDMETHODIMP QueryGetData(FORMATETC* pFormatEtc)
        { return E_NOTIMPL; }
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC* pFormatetcIn, FORMATETC* pFormatetcOut)
        { return E_NOTIMPL; }
    STDMETHODIMP SetData(FORMATETC* pFormatetc, STGMEDIUM* pmedium, BOOL fRelease)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc)
        { return E_NOTIMPL; }
    STDMETHODIMP DAdvise(FORMATETC* pFormatetc, DWORD advf, IAdviseSink* pAdvSink, DWORD * pdwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP DUnadvise(DWORD dwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA ** ppenumAdvise)
        { return E_NOTIMPL; }

    HRESULT SetSid(PSID psid);

private:
    LONG _cRef;
    PSID _psid;
};


CUserSidDataObject::CUserSidDataObject() :
    _cRef(1)
{
    DllAddRef();
}

CUserSidDataObject::~CUserSidDataObject()
{
    if (_psid)
        LocalFree(_psid);

    DllRelease();
}

ULONG CUserSidDataObject::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CUserSidDataObject::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CUserSidDataObject::QueryInterface(REFIID riid, LPVOID* ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserSidDataObject, IDataObject),    // IID_IDataObject
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CUserSidDataObject::GetData(FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
{
    HRESULT hr = QueryGetData(pFormatEtc);
    if (SUCCEEDED(hr))
    {
        pMedium->pUnkForRelease = (IDataObject*)this;
        AddRef();                                              // reference to ourself

        pMedium->tymed = TYMED_HGLOBAL;
        pMedium->hGlobal = (HGLOBAL)_psid;
    }
    return hr;
}

HRESULT CUserSidDataObject::SetSid(PSID psid)
{
    if (!psid)
        return E_INVALIDARG;

    if (_psid == NULL)
    {
        DWORD cbSid = GetLengthSid(psid);

        _psid = (PSID)LocalAlloc(0, cbSid);
        if (!_psid)
            return E_OUTOFMEMORY;

        if (CopySid(cbSid, _psid, psid))
            return S_OK;
    }

    return E_FAIL;
}

STDAPI CUserSidDataObject_CreateInstance(PSID psid, IDataObject **ppdo)
{
    CUserSidDataObject *pusdo = new CUserSidDataObject();
    
    if (!pusdo)
        return E_OUTOFMEMORY;

    HRESULT hr = pusdo->SetSid(psid);
    if (SUCCEEDED(hr))
    {
        hr = pusdo->QueryInterface(IID_PPV_ARG(IDataObject, ppdo));
    }
    pusdo->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\cdlbsc.cpp ===
#include <urlmon.h>
#include "cdlbsc.hpp"
#include "resource.h"

CodeDownloadBSC::CodeDownloadBSC( HWND hwnd, HWND hdlg, LPITEMIDLIST pidlUpdate )
{
    _cRef = 1;
    _pIBinding = NULL;
    _hwnd = hwnd;
    _pidlUpdate = pidlUpdate;
    _hdlg = hdlg;  
}

CodeDownloadBSC::~CodeDownloadBSC()
{
    if ( _pidlUpdate )
        ILFree( _pidlUpdate );
}

HRESULT CodeDownloadBSC::Abort()
{
    return _pIBinding->Abort();
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if ( riid == IID_IWindowForBindingUI )
    {
         *ppv = (IWindowForBindingUI *)this;
    }

    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::Release()
{
    if (--_cRef)
    {
        return _cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
    }
    _pIBinding = pib;

    if (_pIBinding != NULL)
    {
        _pIBinding->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    if ( _hdlg != NULL )
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_COMPLETE,
                    SUCCEEDED(hresult) ? TRUE : FALSE);

    if ( SUCCEEDED(hresult) && _pidlUpdate )
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, _pidlUpdate, NULL);
        SHChangeNotifyHandleEvents();
    }
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    if ( _hdlg != NULL )
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_COMPLETE, TRUE );
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

STDMETHODIMP CodeDownloadBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    if ( _hdlg != NULL )
    {
        // convert progress to a percentage - 0->100
        LPARAM lprog;
        if ( ulStatusCode == BINDSTATUS_ENDDOWNLOADDATA )
            lprog = 100;
        else
            lprog = (ulProgressMax != 0)? (ulProgress * 100) / ulProgressMax : 0;
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_PROGRESS, lprog );
    }

    return S_OK;
}


STDMETHODIMP CodeDownloadBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
   // *pgrfBINDF |= BINDF_SILENTOPERATION;
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetWindow( REFGUID rguidReason, HWND __RPC_FAR *phwnd )
{
    *phwnd = _hwnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\userinfo.h ===
#ifndef USERINFO_H_INCLUDED
#define USERINFO_H_INCLUDED


class CUserInfo
{
public:
    // Typedefs
    enum USERTYPE
    {
        LOCALUSER = 0,
        DOMAINUSER,
        GROUP
    };

    // Group pseudonym tells any functions that may change a user's group that the
    // user selected an option button that says something like "standard user" or
    // "restricted user" instead of selecting the real group name from a list.
    // In this case, the group change functions may display custom error messages that
    // mention "standard user access" instead of "power users group", for example.
    enum GROUPPSEUDONYM
    {
        RESTRICTED = 0,
        STANDARD,
        USEGROUPNAME
    };

public:
    // Functions
    CUserInfo();
    ~CUserInfo();
    HRESULT Load(PSID psid, BOOL fLoadExtraInfo = NULL);
    HRESULT Reload(BOOL fLoadExtraInfo = NULL);

    HRESULT Create(HWND hwndError, GROUPPSEUDONYM grouppseudonym);
    
    HRESULT UpdateUsername(LPTSTR pszNewUsername);
    HRESULT UpdateFullName(LPTSTR pszFullName);
    HRESULT UpdatePassword(BOOL* pfBadPWFormat);
    HRESULT UpdateGroup(HWND hwndError, LPTSTR pszGroup, GROUPPSEUDONYM grouppseudonym);
    HRESULT UpdateDescription(LPTSTR pszDescription);
    
    HRESULT Remove();
    HRESULT InitializeForNewUser();
    HRESULT GetExtraUserInfo();
    HRESULT SetUserType();
    HRESULT SetLocalGroups();

    void HidePassword();
    void RevealPassword();
    void ZeroPassword();

public:
    // Data

    // Index of this user's icon (local, domain, group)
    USERTYPE m_userType;

    TCHAR m_szUsername[MAX_USER + 1];
    TCHAR m_szDomain[MAX_DOMAIN + 1];
    TCHAR m_szComment[MAXCOMMENTSZ];
    TCHAR m_szFullName[MAXCOMMENTSZ];

    // Only if we're creating a new user:
    TCHAR m_szPasswordBuffer[MAX_PASSWORD + 1];
    UNICODE_STRING m_Password;
    UCHAR m_Seed;

    // Room for AT LEAST two group names plus a ';' a ' ' and a '\0'
    TCHAR m_szGroups[MAX_GROUP * 2 + 3];

    // The user's SID
    PSID m_psid;
    SID_NAME_USE m_sUse;

    // Is the account disabled
    BOOL m_fAccountDisabled;

    // Have we read the user's full name and comment yet?
    BOOL m_fHaveExtraUserInfo;
private:
    // Helpers
    HRESULT RemoveFromLocalGroups();
    HRESULT ChangeLocalGroups(HWND hwndError, GROUPPSEUDONYM grouppseudonym);
    HRESULT SetAccountDisabled();
};

class CUserListLoader
{
public:
    CUserListLoader();
    ~CUserListLoader();

    HRESULT Initialize(HWND hwndUserListPage);

    void EndInitNow() {m_fEndInitNow = TRUE;}
    BOOL InitInProgress() 
    {return (WAIT_OBJECT_0 != WaitForSingleObject(m_hInitDoneEvent, 0));}

private:
    HRESULT UpdateFromLocalGroup(LPWSTR szLocalGroup);
    HRESULT AddUserInformation(PSID psid);
    BOOL HasUserBeenAdded(PSID psid);    

    static DWORD WINAPI InitializeThread(LPVOID pvoid);
private:
    // Data
    HWND m_hwndUserListPage;
    HANDLE m_hInitDoneEvent;
    BOOL m_fEndInitNow;
    CDPA<CUserInfo> m_dpaAddedUsers;
};

// User info functions
BOOL UserAlreadyHasPermission(CUserInfo* pUserInfo, HWND hwndMsgParent);

#endif // !USERINFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\netplwiz\userinfo.cpp ===
#include "stdafx.h"
#include "userinfo.h"
#pragma hdrstop

/*******************************************************************
 CUserInfo implementation
*******************************************************************/

CUserInfo::CUserInfo() 
{
    m_fHaveExtraUserInfo = FALSE;
    m_psid = NULL;
}

CUserInfo::~CUserInfo()
{
    if (m_psid != NULL)
        LocalFree(m_psid);

    ZeroPassword();
}

HRESULT CUserInfo::Reload(BOOL fLoadExtraInfo /* = NULL */)
{
    // Initialize the structure and add it to the head of the list
    DWORD cchUsername = ARRAYSIZE(m_szUsername);
    DWORD cchDomain = ARRAYSIZE(m_szDomain);

    if (LookupAccountSid(NULL, m_psid, m_szUsername, &cchUsername, m_szDomain, &cchDomain, &m_sUse))
    {
        m_fHaveExtraUserInfo = FALSE;
        if (fLoadExtraInfo)
            GetExtraUserInfo();

        SetUserType();
        SetAccountDisabled();
        return SetLocalGroups();
    }
    return E_FAIL;
}

HRESULT CUserInfo::SetLocalGroups()
{
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

    DWORD dwEntriesRead;
    DWORD dwTotalEntries;
    BOOL fMore = TRUE;
    DWORD iNextGroupName = 0;
    BOOL fAddElipses = FALSE;

    HRESULT hr = S_OK;
    while (fMore)
    {
        LOCALGROUP_USERS_INFO_0* prglgrui0;
        NET_API_STATUS status = NetUserGetLocalGroups(NULL, szDomainUser, 0, 0, 
                                                       (BYTE**) &prglgrui0, 2048, 
                                                       &dwEntriesRead, &dwTotalEntries);

        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            for (DWORD i = 0; i < dwEntriesRead; i++)
            {
                DWORD iThisGroupName = iNextGroupName;
                iNextGroupName += lstrlen(prglgrui0[i].lgrui0_name) + 2;

                if (iNextGroupName < (ARRAYSIZE(m_szGroups) - 1))
                {
                    lstrcpy(&m_szGroups[iThisGroupName], prglgrui0[i].lgrui0_name);
                    lstrcpy(&m_szGroups[iNextGroupName - 2], TEXT("; "));
                }
                else
                {
                    fAddElipses = TRUE;
                    if (iThisGroupName + 3 >= (ARRAYSIZE(m_szGroups)))
                        iThisGroupName -= 3;

                    lstrcpy(&m_szGroups[iThisGroupName], TEXT("..."));

                    // No need to read more; we're out o' buffer
                    fMore = FALSE;
                }
            }
            NetApiBufferFree((void*) prglgrui0);
        }
        else
        {
            hr = E_FAIL;
        }

        if (status != ERROR_MORE_DATA)
        {
            fMore = FALSE;
        }
    }

    // There is an extra ';' at the end. Nuke it
    if (!fAddElipses && ((iNextGroupName - 2) < (ARRAYSIZE(m_szGroups))))
    {
        m_szGroups[iNextGroupName - 2] = TEXT('\0');
    }

    // Absolutely guarantee the string ends in a null
    m_szGroups[ARRAYSIZE(m_szGroups) - 1] = TEXT('\0');

    return hr;
}

HRESULT CUserInfo::Load(PSID psid, BOOL fLoadExtraInfo /* = NULL */)
{
    CUserInfo();            // Nuke the record first

    // Make a copy of the SID
    DWORD cbSid = GetLengthSid(psid);
    m_psid = (PSID) LocalAlloc(NULL, cbSid);
    if (!m_psid)
        return E_OUTOFMEMORY;

    CopySid(cbSid, m_psid, psid);
    return Reload(fLoadExtraInfo);
}

HRESULT CUserInfo::Create(HWND hwndError, GROUPPSEUDONYM grouppseudonym)
{
    NET_API_STATUS status = NERR_Success;

    CWaitCursor cur;

    HRESULT hr = E_FAIL;
    if (m_userType == CUserInfo::LOCALUSER)
    {
        // Fill in the big, ugly structure containing information about our new user
        USER_INFO_2 usri2 = {0};
        usri2.usri2_name = T2W(m_szUsername);

        // Reveal the password
        RevealPassword();

        usri2.usri2_password = T2W(m_szPasswordBuffer);
        usri2.usri2_priv = USER_PRIV_USER;
        usri2.usri2_comment = T2W(m_szComment);

        if (m_szPasswordBuffer[0] == TEXT('\0'))
            usri2.usri2_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT | UF_PASSWD_NOTREQD;
        else
            usri2.usri2_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT;

        usri2.usri2_full_name = T2W(m_szFullName);
        usri2.usri2_acct_expires = TIMEQ_FOREVER;
        usri2.usri2_max_storage = USER_MAXSTORAGE_UNLIMITED;

        TCHAR szCountryCode[7];
        if (0 < GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ICOUNTRY, szCountryCode, ARRAYSIZE(szCountryCode)))
        {
            usri2.usri2_country_code = (DWORD) StrToLong(szCountryCode);
        }

        usri2.usri2_code_page = GetACP();

        // Create the user
        status = NetUserAdd(NULL, 2, (BYTE*) &usri2, NULL);

        // Hide the password
        HidePassword();

        switch (status)
        {
            case NERR_Success:
                hr = S_OK;
                break;
            
            case NERR_PasswordTooShort:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_PASSWORDTOOSHORT_ERROR, MB_ICONERROR | MB_OK);

                break;
            case NERR_GroupExists:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_GROUPEXISTS_ERROR, MB_ICONERROR | MB_OK);
                break;

            case NERR_UserExists:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_USEREXISTS_ERROR, MB_ICONERROR | MB_OK, 
                                        m_szUsername);
                break;

            default:
            {
                TCHAR szMessage[512];

                if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                    LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, IDS_USERCREATE_GENERICERROR, MB_ICONERROR | MB_OK, szMessage);
                break;
            }
        }
    }
    else 
    {
        hr = S_OK;          // m_userType == DOMAINUSER or GROUP
    }

    if (SUCCEEDED(hr))
    {
        hr = ChangeLocalGroups(hwndError, grouppseudonym);
        if (SUCCEEDED(hr))
        {
            // User type may have been updated by ChangeLocalGroups -  // relect that!
            SetUserType();
        }
    }

    return hr;
}

HRESULT CUserInfo::Remove()
{
    CWaitCursor cur;
    if (m_userType == CUserInfo::LOCALUSER)
    {
        // Try to actually remove this local user (this may fail!)

        NET_API_STATUS status = NetUserDel(NULL, m_szUsername);
        if (status != NERR_Success)
        {
            return E_FAIL;
        }
    }
    else
    {
        // We can only delete local users. For all others the best we can do is 
        // remove them from all local groups

        return RemoveFromLocalGroups();
    }
    return S_OK;
}

HRESULT CUserInfo::InitializeForNewUser()
{
    CUserInfo();                // Nuke the record first

    m_fHaveExtraUserInfo = TRUE;
    m_sUse = SidTypeUser;
    m_userType = LOCALUSER;

    return S_OK;
}

HRESULT CUserInfo::RemoveFromLocalGroups()
{
    // Create a data structure we'll need to pass to NetLocalGroupxxx functions
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));    
    LOCALGROUP_MEMBERS_INFO_3 rglgrmi3[] = {{szDomainUser}};

    // Try and remove the user/group from ALL local groups. The reason
    // for this is the NetUserGetLocalGroups won't work for groups, even
    // well-known ones. For instance, it will fail for "Everyone" even
    // though "Everyone" may very well belong to local groups.

    DWORD_PTR dwResumeHandle = 0;

    BOOL fMoreData = TRUE;
    while (fMoreData)
    {
        DWORD dwEntriesRead;
        DWORD dwTotalEntries;
        LOCALGROUP_INFO_0* plgrpi0 = NULL;

        NET_API_STATUS status = NetLocalGroupEnum(NULL, 0, (BYTE**)&plgrpi0, 8192, 
                                                   &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);
 
        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            for (DWORD i = 0; i < dwEntriesRead; i ++)
            {
                status = NetLocalGroupDelMembers(NULL, plgrpi0[i].lgrpi0_name, 3,
                                                  (BYTE*) rglgrmi3, ARRAYSIZE(rglgrmi3));
            }

            if (dwEntriesRead == dwTotalEntries)
            {
                fMoreData = FALSE;
            }

            NetApiBufferFree(plgrpi0);
        }
        else
        {
            fMoreData = FALSE;
        }
    }
    return S_OK;
}

HRESULT CUserInfo::SetUserType()
{
    TCHAR szComputerName[MAX_COMPUTERNAME + 1];
    DWORD cchComputerName = ARRAYSIZE(szComputerName);
    ::GetComputerName(szComputerName, &cchComputerName);

    // Figure out what type of user we're talking about
    
    if ((m_sUse == SidTypeWellKnownGroup) || (m_sUse == SidTypeGroup))
    {
        m_userType = GROUP;
    }
    else
    {
        // User type - see if this user is a local one
        if ((m_szDomain[0] == TEXT('\0')) || 
                (StrCmpI(m_szDomain, szComputerName) == 0))
        {
            m_userType = LOCALUSER;             // Local user
        }
        else
        {
            m_userType = DOMAINUSER;            // User is a network one
        }
    }

    return S_OK;
}

HRESULT CUserInfo::SetAccountDisabled()
{
    m_fAccountDisabled = FALSE;

    USER_INFO_1* pusri1 = NULL;
    NET_API_STATUS status = NetUserGetInfo(NULL, T2W(m_szUsername), 1, (BYTE**)&pusri1);
    if (NERR_Success == status)
    {
        if (pusri1->usri1_flags & UF_ACCOUNTDISABLE)
        {
            m_fAccountDisabled = TRUE;
        }

        NetApiBufferFree(pusri1);
    }

    return S_OK;
}

HRESULT CUserInfo::GetExtraUserInfo()
{
    USES_CONVERSION;

    CWaitCursor cur;

    if (!m_fHaveExtraUserInfo)
    {
        NET_API_STATUS status;
        USER_INFO_11* pusri11 = NULL;

        // Even if we fail to the info, we only want to try once since it may take a long time
        m_fHaveExtraUserInfo = TRUE;

        // Get the name of the domain's DC if we aren't talking about a local user
#ifdef _0 // Turns out this is REALLY slow to fail if the DsGetDcName call fails
        if (m_userType != LOCALUSER)
        {

            DOMAIN_CONTROLLER_INFO* pDCInfo;
            DWORD dwErr = DsGetDcName(NULL,  m_szDomain, NULL,  NULL, DS_IS_FLAT_NAME, &pDCInfo);
            if (dwErr != NO_ERROR)
                return E_FAIL;

            // Get the user's detailed information (we really need full name and comment)
            // Need to use level 11 here since this allows a domain user to query their
            // information

            status = NetUserGetInfo(T2W(pDCInfo->DomainControllerName), T2W(m_szUsername), 11, (BYTE**)&pusri11);   
            NetApiBufferFree(pDCInfo);
        }
        else
#endif //0
        {
            status = NetUserGetInfo(NULL, T2W(m_szUsername), 11, (BYTE**)&pusri11);
        }

        if (status != NERR_Success)
            return E_FAIL;

        StrCpyN(m_szComment, W2T(pusri11->usri11_comment), ARRAYSIZE(m_szComment));
        StrCpyN(m_szFullName, W2T(pusri11->usri11_full_name), ARRAYSIZE(m_szFullName));

        NetApiBufferFree(pusri11);
    }
    return S_OK;
}

// ChangeLocalGroups
// Removes the specified user from all current local groups and adds them to the
// SINGLE local group specified in pUserInfo->szGroups
HRESULT CUserInfo::ChangeLocalGroups(HWND hwndError, GROUPPSEUDONYM grouppseudonym)
{
    // First, remove the user from all existing local groups
    HRESULT hr = RemoveFromLocalGroups();
    if (SUCCEEDED(hr))
    {
        TCHAR szDomainAndUser[MAX_USER + MAX_DOMAIN + 2];
        ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainAndUser, ARRAYSIZE(szDomainAndUser));

        // Create a data structure we'll need to pass to NetLocalGroupxxx functions
        LOCALGROUP_MEMBERS_INFO_3 rglgrmi3[] = {{szDomainAndUser}};
    
        // Now add the user to the SINGLE localgroup that should be specified in 
        // m_szGroups; Assert this is the case!
        NET_API_STATUS status = NetLocalGroupAddMembers(NULL, T2W(m_szGroups), 3, 
                                                            (BYTE*) rglgrmi3, ARRAYSIZE(rglgrmi3));
        if (status == NERR_Success)
        {
            // We may now need to get the user's SID. This happens if we are
            // changing local groups for a domain user and we couldn't read their
            // SID since they weren't in the local SAM.

            DWORD cchDomain = ARRAYSIZE(m_szDomain);
            hr = ::AttemptLookupAccountName(szDomainAndUser, &m_psid, m_szDomain, &cchDomain, &m_sUse);
            if (FAILED(hr))
            {
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_MISC_ERROR, MB_ICONERROR | MB_OK);
            }
        }
        else
        {
            switch(status)
            {
                case ERROR_NO_SUCH_MEMBER:
                {
                    switch (grouppseudonym)
                    {
                        case RESTRICTED:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, 
                                                    IDS_BADRESTRICTEDUSER, MB_ICONERROR | MB_OK, szDomainAndUser);
                            break;
    
                        case STANDARD:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, 
                                                    IDS_BADSTANDARDUSER, MB_ICONERROR | MB_OK, szDomainAndUser);
                            break;
    
                        case USEGROUPNAME:
                        default:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                                    IDS_USR_CHANGEGROUP_ERR, MB_ICONERROR | MB_OK, szDomainAndUser, m_szGroups);
                            break;
                    }
                    break;
                }

                default:
                {
                    TCHAR szMessage[512];

                    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                        LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                    ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, IDS_ERR_ADDUSER, MB_ICONERROR | MB_OK, szMessage);
                }            
            }            
            hr = E_FAIL;
        }
    }
    
    return hr;
}

HRESULT CUserInfo::UpdateUsername(LPTSTR pszNewUsername)
{
    CWaitCursor cur;

    USER_INFO_0 usri0;
    usri0.usri0_name = T2W(pszNewUsername);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 0, (BYTE*) &usri0, &dwErr);
    if (status != NERR_Success)
        return E_FAIL;

    StrCpyN(m_szUsername, pszNewUsername, ARRAYSIZE(m_szUsername));
    return S_OK;
}

HRESULT CUserInfo::UpdateFullName(LPTSTR pszFullName)
{
    CWaitCursor cur;

    USER_INFO_1011 usri1011;
    usri1011.usri1011_full_name = T2W(pszFullName);
    DWORD dwErr;

    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1011, (BYTE*) &usri1011, &dwErr);
    if (status != NERR_Success)
        return E_FAIL;

    StrCpyN(m_szFullName, pszFullName, ARRAYSIZE(m_szFullName));
    return S_OK;
}

HRESULT CUserInfo::UpdatePassword(BOOL* pfBadPWFormat)
{
    CWaitCursor cur;

    RevealPassword();

    USER_INFO_1003 usri1003;
    usri1003.usri1003_password = T2W(m_szPasswordBuffer);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1003, (BYTE*)&usri1003, &dwErr);

    ZeroPassword();     // Kill the password

    if (pfBadPWFormat != NULL)
        *pfBadPWFormat = (status == NERR_PasswordTooShort);

    return (status == NERR_Success) ? S_OK:E_FAIL;
}

HRESULT CUserInfo::UpdateGroup(HWND hwndError, LPTSTR pszGroup, GROUPPSEUDONYM grouppseudonym)
{
    CWaitCursor cur;

    // Save the old group before we change it
    TCHAR szOldGroups[MAX_GROUP * 2 + 3];
    StrCpyN(szOldGroups, m_szGroups, ARRAYSIZE(szOldGroups));

    // Try to change the local group
    StrCpyN(m_szGroups, pszGroup, ARRAYSIZE(m_szGroups));
    HRESULT hr = ChangeLocalGroups(hwndError, grouppseudonym);

    if (FAILED(hr))
        StrCpyN(m_szGroups, szOldGroups, ARRAYSIZE(m_szGroups));           // Restore the old group in case of failure

    return hr;
}

HRESULT CUserInfo::UpdateDescription(LPTSTR pszDescription)
{
    CWaitCursor cur;

    USER_INFO_1007 usri1007;
    usri1007.usri1007_comment = T2W(pszDescription);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1007,  (BYTE*) &usri1007, &dwErr);

    if (status != NERR_Success)
        return E_FAIL;

    StrCpyN(m_szComment, pszDescription, ARRAYSIZE(m_szComment));
    return S_OK;
}

void CUserInfo::HidePassword()
{
    m_Seed = 0;
    RtlInitUnicodeString(&m_Password, m_szPasswordBuffer);
    RtlRunEncodeUnicodeString(&m_Seed, &m_Password);
}

void CUserInfo::RevealPassword()
{
    RtlRunDecodeUnicodeString(m_Seed, &m_Password);
}

void CUserInfo::ZeroPassword()
{
    SecureZeroMemory(m_szPasswordBuffer, ARRAYSIZE(m_szPasswordBuffer));
}


/*******************************************************************
 CUserListLoader implementation
*******************************************************************/

CUserListLoader::CUserListLoader()
{
    m_hInitDoneEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
}

CUserListLoader::~CUserListLoader()
{
    EndInitNow();
    WaitForSingleObject(m_hInitDoneEvent, INFINITE);
}

BOOL CUserListLoader::HasUserBeenAdded(PSID psid)
{
    // Walk the user list looking for a given username and domain
    CUserInfo* pUserInfo = NULL;
    BOOL fFound = FALSE;
    for (int i = 0; i < m_dpaAddedUsers.GetPtrCount(); i ++)
    {
        pUserInfo = m_dpaAddedUsers.GetPtr(i);
        if (pUserInfo->m_psid && psid && EqualSid(pUserInfo->m_psid, psid))
        {
            fFound = TRUE;
            break;
        }
    }
    return fFound;
}

HRESULT CUserListLoader::Initialize(HWND hwndUserListPage)
{
    if (!m_hInitDoneEvent)
    {
        return E_FAIL;
    }

    // Tell any existing init thread to exit and wait for it to do so
    m_fEndInitNow = TRUE;
    WaitForSingleObject(m_hInitDoneEvent, INFINITE);
    ResetEvent(m_hInitDoneEvent);

    m_fEndInitNow = FALSE;
    m_hwndUserListPage = hwndUserListPage;

    // Launch the initialize thread
    DWORD InitThreadId;
    HANDLE hInitThread = CreateThread(NULL, 0, CUserListLoader::InitializeThread, (LPVOID) this, 0, &InitThreadId);
    if (hInitThread == NULL)
        return E_FAIL;

    CloseHandle(hInitThread);           // Let this thread go about his/her merry way
    return S_OK;
}

HRESULT CUserListLoader::UpdateFromLocalGroup(LPWSTR szLocalGroup)
{
    USES_CONVERSION;
    DWORD_PTR dwResumeHandle = 0;

    HRESULT hr = S_OK;
    BOOL fBreakLoop = FALSE;
    while(!fBreakLoop)
    {
        LOCALGROUP_MEMBERS_INFO_0* prgMembersInfo;
        DWORD dwEntriesRead = 0;
        DWORD dwTotalEntries = 0;

        NET_API_STATUS status = NetLocalGroupGetMembers(NULL, szLocalGroup, 0, (BYTE**) &prgMembersInfo,        
                                                         8192, &dwEntriesRead, 
                                                         &dwTotalEntries, &dwResumeHandle);
    
        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            // for all the members in the structure, lets add them
            DWORD iMember;
            for (iMember = 0; ((iMember < dwEntriesRead) && (!m_fEndInitNow)); iMember ++)
            {
                hr = AddUserInformation(prgMembersInfo[iMember].lgrmi0_sid);
            }

            NetApiBufferFree((BYTE*) prgMembersInfo);

            // See if we can avoid calling NetLocalGroupGetMembers again
            fBreakLoop = ((dwEntriesRead == dwTotalEntries) || m_fEndInitNow);
        }
        else
        {
            fBreakLoop = TRUE;
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CUserListLoader::AddUserInformation(PSID psid)
{
    // Only add this user if we haven't already
    if (!HasUserBeenAdded(psid))
    {
        CUserInfo *pUserInfo = new CUserInfo;
        if (!pUserInfo)
            return E_OUTOFMEMORY;

        if (SUCCEEDED(pUserInfo->Load(psid, FALSE)))
        {
            PostMessage(m_hwndUserListPage, WM_ADDUSERTOLIST, (WPARAM) FALSE, (LPARAM)pUserInfo);
            m_dpaAddedUsers.AppendPtr(pUserInfo);            // Remember we've added this user
        }
    }
    return S_OK;
}

DWORD CUserListLoader::InitializeThread(LPVOID pvoid)
{
    CUserListLoader *pthis = (CUserListLoader*)pvoid;

    // First delete any old list
    PostMessage(GetDlgItem(pthis->m_hwndUserListPage, IDC_USER_LIST), LVM_DELETEALLITEMS, 0, 0);

    // Create a list of adready-added users so we don't add a user twice
    // if they're in multiple local groups
    if (pthis->m_dpaAddedUsers.Create(8))
    {
        // Read each local group
        DWORD_PTR dwResumeHandle = 0;

        BOOL fBreakLoop = FALSE;
        while (!fBreakLoop)
        {
            DWORD dwEntriesRead = 0;
            DWORD dwTotalEntries = 0;
            LOCALGROUP_INFO_1* prgGroupInfo;
            NET_API_STATUS status = NetLocalGroupEnum(NULL, 1, (BYTE**) &prgGroupInfo, 
                                                      8192, &dwEntriesRead, &dwTotalEntries, 
                                                      &dwResumeHandle);

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
            {
                // We got some local groups - add information for all users in these local groups to our list
                DWORD iGroup;
                for (iGroup = 0; ((iGroup < dwEntriesRead) && (!pthis->m_fEndInitNow)); iGroup ++)
                {
                    pthis->UpdateFromLocalGroup(prgGroupInfo[iGroup].lgrpi1_name);
                }

                NetApiBufferFree((BYTE*) prgGroupInfo);
    
                // Maybe we don't have to try NetLocalGroupEnum again (if we got all the groups)
                fBreakLoop = ((dwEntriesRead == dwTotalEntries) || pthis->m_fEndInitNow);
            }
            else
            {
                fBreakLoop = TRUE;
            }
        }

        // Its okay to orphan any CUserInfo pointers stored here; they'll be
        // released when the ulistpg exits or reinits.
        pthis->m_dpaAddedUsers.Destroy();
    }

    SetEvent(pthis->m_hInitDoneEvent);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return 0;
}

// User utility functions

BOOL UserAlreadyHasPermission(CUserInfo* pUserInfo, HWND hwndMsgParent)
{
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    ::MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

    BOOL fHasPermission = FALSE;

    // See if this user is already in local groups on this machine
    DWORD dwEntriesRead, dwIgnore2;
    LOCALGROUP_USERS_INFO_0* plgrui0 = NULL;
    if (NERR_Success == NetUserGetLocalGroups(NULL, szDomainUser, 0, 0, 
                                                (LPBYTE*)&plgrui0, 8192, 
                                                &dwEntriesRead, &dwIgnore2))
    {
        fHasPermission = (0 != dwEntriesRead);
        NetApiBufferFree((LPVOID) plgrui0);
    }

    if ((NULL != hwndMsgParent) && (fHasPermission))
    {
        // Display an error; the user doesn't have permission
        TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
        MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, 
                                szDomainUser, ARRAYSIZE(szDomainUser));

        DisplayFormatMessage(hwndMsgParent, IDS_USR_NEWUSERWIZARD_CAPTION, 
                                IDS_USR_CREATE_USEREXISTS_ERROR, MB_OK | MB_ICONINFORMATION, 
                                szDomainUser);
    }

    return fHasPermission;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\cleanoc.cpp ===
#include "ParseInf.h"
#include "general.h"
#include <shlwapi.h>
#include <wininet.h>

//#define USE_SHORT_PATH_NAME    1

#define REG_PATH_IE_CACHE_LIST  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")

#define cCachePathsMax 5    // maximum number of legacy caches + the current cache du jour


struct OCCFindData
{
    LPCLSIDLIST_ITEM m_pcliHead;
    LPCLSIDLIST_ITEM m_pcliTail;
    struct {
        TCHAR  m_sz[MAX_PATH];
        DWORD  m_cch;
    } m_aCachePath[cCachePathsMax];

    OCCFindData();
    ~OCCFindData();
 
    BOOL    IsCachePath( LPCTSTR szPath );

    // Control List operations
    HRESULT          AddListItem( LPCTSTR szFileName, LPCTSTR szCLSID, DWORD dwIsDistUnit );
    LPCLSIDLIST_ITEM TakeFirstItem(void);
};

DWORD CCacheLegacyControl::s_dwType = 1;
DWORD CCacheDistUnit::s_dwType = 2;

HRESULT CCacheLegacyControl::Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID )
{
    HRESULT hr = S_OK;

    lstrcpyn(m_szFile, szFile, ARRAYSIZE(m_szFile));
    lstrcpyn(m_szCLSID, szCLSID, ARRAYSIZE(m_szCLSID));

    // Get full user type name
    m_szName[0] = '\0';
    DWORD dw = sizeof(m_szName);
    LRESULT lResult = RegQueryValue(hkeyCLSID, m_szCLSID, m_szName,  (LONG*)&dw);
    // if the fails, we should get a resource string (seanf 5/9/97 )
    // Get type lib id
    TCHAR szTypeLibValName[MAX_PATH];
    CatPathStrN( szTypeLibValName, szCLSID, HKCR_TYPELIB, ARRAYSIZE(szTypeLibValName) );

    dw = sizeof(m_szTypeLibID);
    lResult = RegQueryValue( hkeyCLSID, szTypeLibValName, m_szTypeLibID, (LONG*)&dw);
    if (lResult != ERROR_SUCCESS)
        m_szTypeLibID[0] = TEXT('\0');

    // Set Codebase
    m_szCodeBase[0] = '\0';
    m_szVersion[0] = '\0';
    hr = DoParse( m_szFile, m_szCLSID );

    return hr;
}

HRESULT CCacheDistUnit::Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID, HKEY hkeyDist, LPCTSTR szDU )
{
    HRESULT hr = S_OK;
    HKEY    hkeyDU;
    HKEY    hkeyDLInfo; // DownloadInformation subkey
    HKEY    hkeyVers;   // InstalledVersion subkey
    HKEY    hkeyCOM;    // subkey of HKCR\CLSID, used if outside of cache dir
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dw;
    TCHAR   szNameT[MAX_PATH];
    UINT    uiVerSize = 0;
    DWORD   dwVerSize = 0;
    DWORD   dwHandle = 0;
    BYTE   *pbBuffer = NULL;
    HANDLE  hFile;
    FILETIME ftLastAccess;
    BOOL bRunOnNT5 = FALSE;
    OSVERSIONINFO osvi;
    VS_FIXEDFILEINFO     *lpVSInfo = NULL;
    
    if ( szFile[0] == '\0' &&
         RegOpenKeyEx( hkeyCLSID, szCLSID, 0, KEY_READ, &hkeyCOM ) == ERROR_SUCCESS )
    {
        LONG lcb = sizeof(szNameT);
        lResult = RegQueryValue( hkeyCOM, INPROCSERVER, szNameT, &lcb );

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVERX86, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVERX86, szNameT, &lcb );
        }

        RegCloseKey( hkeyCOM );
    }
    else
        lstrcpyn( szNameT, szFile, ARRAYSIZE(szNameT));

    if ( lResult != ERROR_SUCCESS ) // needed to find file path but couldn't
        szNameT[0] = '\0';
    
    hr = CCacheLegacyControl::Init( hkeyCLSID, szNameT, szCLSID );

    if ( FAILED(hr) )
        return hr;

    lResult = RegOpenKeyEx(hkeyDist, szDU, 0, KEY_READ, &hkeyDU);
    if (lResult != ERROR_SUCCESS)
        return E_FAIL;

    // Get CLSID
    lstrcpyn(m_szCLSID, szDU, MAX_DIST_UNIT_NAME_LEN);

    // Get full user type name - only override the control name if DU name is not empty
    dw = sizeof(szNameT);
    lResult = RegQueryValue(hkeyDU, NULL, szNameT, (LONG*)&dw);
    if ( lResult == ERROR_SUCCESS && szNameT[0] != '\0' )
    {
        lstrcpyn( m_szName, szNameT, ARRAYSIZE(m_szName) );
    }
    else if ( *m_szName == '\0' ) // worst case, if we still don't have a name, a GUID will suffice
        lstrcpyn( m_szName, szDU, ARRAYSIZE(m_szName) ); 

    // Get type lib id
    // Get type lib id
    TCHAR szTypeLibValName[MAX_PATH];
    CatPathStrN(szTypeLibValName, m_szCLSID, HKCR_TYPELIB, ARRAYSIZE(szTypeLibValName));
    dw = sizeof(m_szTypeLibID);
    lResult = RegQueryValue( hkeyCLSID, szTypeLibValName, m_szTypeLibID, (LONG*)&dw);
    if (lResult != ERROR_SUCCESS)
        (m_szTypeLibID)[0] = TEXT('\0');

    m_szCodeBase[0] ='\0';
    lResult = RegOpenKeyEx(hkeyDU, REGSTR_DOWNLOAD_INFORMATION, 0, KEY_READ, &hkeyDLInfo);
    if (lResult == ERROR_SUCCESS)
    {
        dw = sizeof(m_szCodeBase);
        HRESULT hrErr = RegQueryValueEx(hkeyDLInfo, REGSTR_DLINFO_CODEBASE, NULL, NULL,
                                        (unsigned char *)m_szCodeBase, &dw);
        RegCloseKey( hkeyDLInfo );
    }

    // Get Version from DU branch

    m_szVersion[0] ='\0';
    lResult = RegOpenKeyEx(hkeyDU, REGSTR_INSTALLED_VERSION, 0,
                           KEY_READ, &hkeyVers);
    if (lResult == ERROR_SUCCESS)
    {
        dw = sizeof(m_szVersion);
        RegQueryValueEx(hkeyVers, NULL, NULL, NULL, (LPBYTE)m_szVersion, &dw);
        RegCloseKey(hkeyVers);
    }
    
    // The version specified in the COM branch is the definitive word on
    // what the version is. If a key exists in the COM branch, use the version
    // that is found inside the InProcServer/LocalServer.

    if (RegOpenKeyEx( hkeyCLSID, szCLSID, 0, KEY_READ, &hkeyCOM ) == ERROR_SUCCESS) 
    {
        LONG lcb = sizeof(szNameT);
        lResult = RegQueryValue( hkeyCOM, INPROCSERVER32, szNameT, &lcb );

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVERX86, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVERX86, szNameT, &lcb );
        }

        RegCloseKey( hkeyCOM );

        // HACK! GetFileVersionInfoSize and GetFileVersionInfo modify
        // the last access time of the file under NT5! This causes us
        // to retrieve the wrong last access time when removing expired
        // controls. This hack gets the last access time before the
        // GetFileVersionInfo calls, and sets it back afterwards.
        // See IE5 RAID #56927 for details. This code should be removed
        // when NT5 fixes this bug.
        
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);

        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.dwMajorVersion == 5) {
            bRunOnNT5 = TRUE;
        }

        if (bRunOnNT5) {
            hFile = CreateFile(szNameT, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                       
            if (hFile != INVALID_HANDLE_VALUE) {
                GetFileTime(hFile, NULL, &ftLastAccess, NULL);
                CloseHandle(hFile);
            }
        }
        
        dwVerSize = GetFileVersionInfoSize((char *)szNameT, &dwHandle);
        pbBuffer = new BYTE[dwVerSize];
        if (!pbBuffer)
        {
            return E_OUTOFMEMORY;
        }
        if (GetFileVersionInfo((char *)szNameT, 0, dwVerSize, pbBuffer))
        {
            if (VerQueryValue(pbBuffer, "\\", (void **)&lpVSInfo, &uiVerSize))
            {
                wsprintf(m_szVersion, "%d,%d,%d,%d", (lpVSInfo->dwFileVersionMS >> 16) & 0xFFFF
                                                   , lpVSInfo->dwFileVersionMS & 0xFFFF
                                                   , (lpVSInfo->dwFileVersionLS >> 16) & 0xFFFF
                                                   , lpVSInfo->dwFileVersionLS & 0xFFFF);
            }
        }
            
        delete [] pbBuffer;

        if (bRunOnNT5) {
            hFile = CreateFile(szNameT, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile != INVALID_HANDLE_VALUE) {
                SetFileTime(hFile, NULL, &ftLastAccess, NULL);
                CloseHandle(hFile);
            }
        }

    }
        
    RegCloseKey( hkeyDU );

    return DoParseDU( m_szFile, m_szCLSID);
}

HRESULT MakeCacheItemFromControlList( HKEY hkeyClass, // HKCR\CLSID
                                      HKEY hkeyDist,  // HKLM\SOFTWARE\MICROSOFT\Code Store Database\Distribution Units
                                      LPCLSIDLIST_ITEM pcli,
                                      CCacheItem **ppci )
{
    HRESULT hr = E_FAIL;

    *ppci = NULL;
    if ( pcli->bIsDistUnit )
    {
        CCacheDistUnit *pcdu = new CCacheDistUnit();
        if ( pcdu != NULL &&
             SUCCEEDED(hr = pcdu->Init( hkeyClass,
                                   pcli->szFile,
                                   pcli->szCLSID, 
                                   hkeyDist, 
                                   pcli->szCLSID)) )
            *ppci = pcdu;
        else
            hr = E_OUTOFMEMORY;
    } 
    else
    {
        CCacheLegacyControl     *pclc = new CCacheLegacyControl();
        if ( pclc != NULL &&
             SUCCEEDED(hr = pclc->Init( hkeyClass,
                                        pcli->szFile, 
                                        pcli->szCLSID )) )
            *ppci = pclc;
        else
            hr = E_OUTOFMEMORY;

    }

    return hr;
}

OCCFindData::OCCFindData() : m_pcliHead(NULL), m_pcliTail(NULL)
{
    LONG    lResult;
    HKEY  hkeyCacheList;

    for ( int i = 0; i < cCachePathsMax; i++ )
    {
        m_aCachePath[i].m_cch = 0;
        m_aCachePath[i].m_sz[0] = '\0';
    }

    // Unhook occache as a shell extension for the cache folders.
    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            REG_PATH_IE_CACHE_LIST,
                            0x0,
                            KEY_READ,
                            &hkeyCacheList );

    if ( lResult == ERROR_SUCCESS ) {
        DWORD dwIndex;
        TCHAR szName[MAX_PATH];
        DWORD cbName;
        DWORD cbValue;

        for ( dwIndex = 0, cbName = sizeof(szName), cbValue = MAX_PATH * sizeof(TCHAR); 
              dwIndex < cCachePathsMax; 
              dwIndex++, cbName = sizeof(szName), cbValue = MAX_PATH * sizeof(TCHAR) )
        {
            lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                    szName, &cbName, 
                                    NULL, NULL,
                                    (LPBYTE)m_aCachePath[dwIndex].m_sz, &cbValue );
            m_aCachePath[dwIndex].m_cch = lstrlen( m_aCachePath[dwIndex].m_sz );
        }
        // We leave this key in place because it is the only record we have of the
        // cache folders and would be useful to future installations of IE
        RegCloseKey( hkeyCacheList );
    }
}

OCCFindData::~OCCFindData()
{
    if ( m_pcliHead )
        RemoveList(m_pcliHead);
}

BOOL OCCFindData::IsCachePath( LPCTSTR szPath )
{
    BOOL fMatch = FALSE;

    for ( int i = 0; i < cCachePathsMax && !fMatch; i++ )
        fMatch = m_aCachePath[i].m_cch != 0 &&
                 LStrNICmp( szPath, m_aCachePath[i].m_sz, m_aCachePath[i].m_cch ) == 0;
    return fMatch;
}

HRESULT OCCFindData::AddListItem( LPCTSTR szFile, LPCTSTR szCLSID, DWORD dwIsDistUnit )
{
    HRESULT hr = S_OK;

    if ( m_pcliTail == NULL )
    {
        m_pcliTail = new CLSIDLIST_ITEM;
        if (m_pcliHead == NULL)
            m_pcliHead = m_pcliTail;
    }
    else
    {
        m_pcliTail->pNext = new CLSIDLIST_ITEM;
        m_pcliTail = m_pcliTail->pNext;
    }

    if ( m_pcliTail != NULL ) 
    {
        m_pcliTail->pNext = NULL;
        lstrcpyn(m_pcliTail->szFile, szFile, MAX_PATH);
        lstrcpyn(m_pcliTail->szCLSID, szCLSID, MAX_DIST_UNIT_NAME_LEN);
        m_pcliTail->bIsDistUnit = dwIsDistUnit;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

LPCLSIDLIST_ITEM OCCFindData::TakeFirstItem(void)
{
    LPCLSIDLIST_ITEM pcli = m_pcliHead;
 
    if (m_pcliHead != NULL)
    {
        m_pcliHead = m_pcliHead;
        m_pcliHead = m_pcliHead->pNext;
        if ( m_pcliHead == NULL )
            m_pcliTail = NULL;
    }

    return pcli;
}

BOOL IsDUDisplayable(HKEY hkeyDU)
{
    BOOL bRet = FALSE;

    if (hkeyDU) 
    {
        if (IsShowAllFilesEnabled()) 
        {
            bRet = TRUE;
        }
        else
        {
            DWORD dwType = 0, dwSystem = 0, dwSize = sizeof(dwSystem);
            long lResult = RegQueryValueEx(hkeyDU, VALUE_SYSTEM, NULL, &dwType, (LPBYTE)&dwSystem, &dwSize);
            bRet = (lResult == ERROR_SUCCESS && dwSystem == TRUE) ? (FALSE) : (TRUE);
        }
    }
    return bRet;
}

BOOL IsShowAllFilesEnabled()
{
    HKEY hkey = 0;
    BOOL bRet = FALSE;
    DWORD dwShowAll = 0;

    DWORD lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) 
    {
        DWORD dwType, dwSize = sizeof(dwShowAll);
        lResult = RegQueryValueEx(hkey, REGSTR_SHOW_ALL_FILES, NULL, &dwType, (LPBYTE)&dwShowAll, &dwSize);
        if (lResult == ERROR_SUCCESS) 
        {
            bRet = (dwShowAll != 0);
        }
        RegCloseKey(hkey);
    }

    return bRet;
}

void ToggleShowAllFiles()
{
    DWORD dwShowAll = !IsShowAllFilesEnabled();
    HKEY hkey = 0;
    DWORD lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_ALL_ACCESS, &hkey);

    if (lResult == ERROR_SUCCESS) 
    {
        RegSetValueEx(hkey, REGSTR_SHOW_ALL_FILES, 0, REG_DWORD, (CONST BYTE *)&dwShowAll, sizeof(dwShowAll));
        RegCloseKey(hkey);
    }
}

LONG WINAPI FindFirstControl(HANDLE& hFindHandle, HANDLE& hControlHandle, LPCTSTR pszCachePath)
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dw = 0;
    HKEY hKeyClass = NULL;
    HKEY hKeyMod = NULL;
    HKEY hKeyDist = NULL;
    TCHAR szT[MAX_PATH];             // scratch buffer
    int cEnum = 0;
    CCacheItem *pci = NULL;
    LPCLSIDLIST_ITEM pcli = NULL;
    TCHAR szDUName[MAX_DIST_UNIT_NAME_LEN];
    
    OCCFindData *poccfd = new OCCFindData();
    if ( poccfd == NULL )
    {
        lResult = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT_FINDFIRSTCONTROL;
    }
    
    // Open up the HKCR\CLSID key.
    lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, HKCR_CLSID, 0, KEY_READ, &hKeyClass);
    if (ERROR_SUCCESS != lResult)
        goto EXIT_FINDFIRSTCONTROL;

    // Search for legacy controls found in the COM branch
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MODULE_USAGE, 0, KEY_READ, &hKeyMod);
    if (ERROR_SUCCESS != lResult)
        goto EXIT_FINDFIRSTCONTROL;

    // Enumerate the known modules and build up a list of the owners.
    // This is a search for legacy controls.
    while ((lResult = RegEnumKey(hKeyMod, cEnum++, szT, ARRAYSIZE(szT))) == ERROR_SUCCESS)
    {
        TCHAR szClient[MAX_CLIENT_LEN];
        HKEY hKeyClsid = NULL;
        HKEY hkeyMUEntry = NULL;

        lResult = RegOpenKeyEx( hKeyMod, szT, 0, KEY_READ, &hkeyMUEntry );
        if (ERROR_SUCCESS != lResult)
            continue;

        // Fetch the module owner.
        // If the module owner is in the COM branch AND
        //    ( the owner lives in the cache OR it has an INF in the cache )
        // Then add the _owner_ to our list of legacy controls.
        // In the INF case, we may be looking at a control that was re-registered
        // outside of the cache.
        // If it doesn't have these properties, then it is either a DU module or
        // was installed by something other than MSICD. In either case, we'll skip it
        // at least for now.
        dw = sizeof(szClient);
        lResult = RegQueryValueEx(hkeyMUEntry, VALUE_OWNER, NULL, NULL, (LPBYTE)szClient, &dw);
        if (ERROR_SUCCESS != lResult)
            continue;

        lResult = RegOpenKeyEx(hKeyClass, szClient, 0, KEY_READ, &hKeyClsid);
        if (ERROR_SUCCESS == lResult)
        {
            TCHAR szCLocation[MAX_PATH];     // Canonical path of control
            TCHAR szLocation[MAX_PATH];      // Location in COM CLSID reg tree.

            // Look for InprocServer[32] or LocalServer[32] key
            dw = sizeof(szLocation);
            lResult = RegQueryValue(hKeyClsid, INPROCSERVER32, szLocation, (PLONG)&dw);
            if (lResult != ERROR_SUCCESS)
            {
                dw = sizeof(szLocation);
                lResult = RegQueryValue(hKeyClsid, LOCALSERVER32, szLocation, (PLONG)&dw);
            }

            RegCloseKey(hKeyClsid);
            hKeyClsid = NULL;

            if ( lResult == ERROR_SUCCESS )
            {
                BOOL bAddOwner;

                // see if we've already got an entry for this one.
                for ( pcli = poccfd->m_pcliHead;
                      pcli != NULL && lstrcmp( szClient, pcli->szCLSID ) != 0;
                      pcli = pcli->pNext );
                
                if ( pcli == NULL ) // not found - possibly add new item
                {
                    // Canonicalize the path for use in comparisons with cache dirs
                    if ( OCCGetLongPathName(szCLocation, szLocation, MAX_PATH) == 0 )
                        lstrcpyn( szCLocation, szLocation, MAX_PATH );

                    // Is the owner in our cache?
                    bAddOwner = poccfd->IsCachePath( szCLocation );

                    if ( !bAddOwner )
                    {
                        // does it have an INF in our cache(s)?
                        // We'll appropriate szDCachePath
                        for ( int i = 0; i < cCachePathsMax && !bAddOwner; i++ )
                        {
                            if ( poccfd->m_aCachePath[i].m_sz != '\0' )
                            {
                                CatPathStrN( szT, poccfd->m_aCachePath[i].m_sz, PathFindFileName( szCLocation ), MAX_PATH);

                                // Note if another copy of the owner exists within the cache(s).
                                // This would be a case of re-registration.
                                if ( PathFileExists( szT ) )
                                {
                                    // add our version of the control.
                                    lstrcpyn( szCLocation, szT, MAX_PATH );
                                    bAddOwner = TRUE;
                                }
                                else
                                    bAddOwner =  PathRenameExtension( szT, INF_EXTENSION ) &&
                                                 PathFileExists( szT );
                            } // if cache path
                        } // for each cache directory
                    } // if check for cached INF

                    if ( bAddOwner ) 
                    {
                        HKEY hkeyDUCheck = 0;
                        char achBuf[MAX_REGPATH_LEN];

                        wnsprintfA(achBuf, MAX_REGPATH_LEN, "%s\\%s", REGSTR_PATH_DIST_UNITS, szClient);

                        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achBuf, 0, KEY_READ, &hkeyDUCheck);

                        if (lResult != ERROR_SUCCESS) 
                        {
                            // This is a legacy control with no corresponding DU
                            poccfd->AddListItem( szCLocation, szClient, FALSE );
                        }
                        else 
                        {
                            if (IsDUDisplayable(hkeyDUCheck)) 
                            {
                                // Legacy control w/ DU keys that is displayable
                                poccfd->AddListItem( szCLocation, szClient, FALSE );
                            }
                            RegCloseKey(hkeyDUCheck);
                        }
                    }
                } // if owner we haven't seen before
            } // if owner has local or inproc server
        } // if owner has COM entry 
        RegCloseKey( hkeyMUEntry );
    } // while enumerating Module Usage
 
    // we're finished with module usage
    RegCloseKey(hKeyMod);

    // Now search distribution units

    // Check for duplicates - distribution units for controls we detected above

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_READ, &hKeyDist);
    if (lResult == ERROR_SUCCESS)
    {
        cEnum = 0;
        // Enumerate distribution units and queue them up in the list
        while ((lResult = RegEnumKey(hKeyDist, cEnum++, szDUName, ARRAYSIZE(szDUName))) == ERROR_SUCCESS)
        {
            // We should only display DU's installed by code download.
            HKEY  hkeyDU;
            DWORD dwType;
            
            lResult = RegOpenKeyEx( hKeyDist, szDUName, 0, KEY_READ, &hkeyDU );
            Assert( lResult == ERROR_SUCCESS );

            if ((ERROR_SUCCESS != lResult) ||
                !IsDUDisplayable(hkeyDU)) 
            {
                continue;
            }

            szT[0] = '\0';
            DWORD cb = sizeof(szT);
            lResult = RegQueryValueEx( hkeyDU, DU_INSTALLER_VALUE, NULL, &dwType, (LPBYTE)szT, &cb );
            
            Assert( lResult == ERROR_SUCCESS ); // properly-formed DU will have this
            Assert( dwType == REG_SZ );         // properly-formed DU's have a string here

            // Check for an installed version. We might just have a DU that has an AvailableVersion
            // but hasn't been installed yet.
            lResult = RegQueryValue( hkeyDU, REGSTR_INSTALLED_VERSION, NULL, NULL );

            RegCloseKey( hkeyDU );

            if ( lstrcmpi( szT, CDL_INSTALLER ) == 0 &&
                 lResult == ERROR_SUCCESS ) // from InstalledVersion RegQueryValue
            {
                // If we can convert the unique name to a GUID, then this DU
                // may have already been added on the first pass through the
                // COM branch.
                CLSID clsidDummy = CLSID_NULL;
                WORD szDummyStr[MAX_CTRL_NAME_SIZE];
                BOOL bFoundDuplicate = FALSE;

                MultiByteToWideChar(CP_ACP, 0, szDUName, -1, szDummyStr, ARRAYSIZE(szDummyStr));
                if ((CLSIDFromString(szDummyStr, &clsidDummy) == S_OK))
                {
                    for (pcli = poccfd->m_pcliHead; pcli; pcli = pcli->pNext)
                    {
                        if (!lstrcmpi(szDUName, pcli->szCLSID))
                        {
                            // Duplicate found. Use dist unit information to
                            // fill in additional fields if it is the first
                            // entry in the list
                            bFoundDuplicate = TRUE;
                            pcli->bIsDistUnit = TRUE;
                            break;
                        }
                    }                     
                }

                if (!bFoundDuplicate)
                {
                    // Okay we're looking at some sort of Java scenario. We have a distribution unit, but
                    // no corresponding entry in the COM branch. This generally means we've got a DU that
                    // consists of java packages. It can also mean that we're dealing with a java/code download
                    // backdoor introduced in IE3. In this case, an Object tag gets a CAB downloaded that
                    // installs Java classes and sets of a CLSID that invokes MSJava.dll on the class ( ESPN's
                    // sportszone control/applet works this way ). In the first case, we get the name
                    // squared-away when we parse the DU. In the latter case, we need to try and pick the name
                    // up from the COM branch.  
                    hr = poccfd->AddListItem( "", szDUName, TRUE );
                    if ( FAILED(hr) )
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;
                        goto EXIT_FINDFIRSTCONTROL;
                    }
                } // if no duplicate - add DU to the list
            } // if installed by MSICD
        } // while enumerating DU's
    } // if we can open the DU key.
    else
        lResult = ERROR_NO_MORE_ITEMS; // if no DU's then make due with our legacy controls, if any

    pcli = poccfd->TakeFirstItem();
    if (pcli)
    {
        hr = MakeCacheItemFromControlList(hKeyClass, hKeyDist, pcli, &pci);
        delete pcli;
        if ( FAILED(hr) )
            lResult = hr;
    }

    if (hKeyDist)
    {
        RegCloseKey(hKeyDist);
        hKeyDist = 0;
    }


    // Clean up

    if (lResult != ERROR_NO_MORE_ITEMS)
        goto EXIT_FINDFIRSTCONTROL;

    if (pci == NULL)
        lResult = ERROR_NO_MORE_ITEMS;
    else
    {
        lResult = ERROR_SUCCESS;
    }

    hFindHandle = (HANDLE)poccfd;
    hControlHandle = (HANDLE)pci;

EXIT_FINDFIRSTCONTROL:

    if (hKeyDist)
        RegCloseKey(hKeyDist);

    if (hKeyClass)
        RegCloseKey(hKeyClass);

    if (lResult != ERROR_SUCCESS)
    {
        if ( pci != NULL )
            delete pci;
        if ( poccfd != NULL )
            delete poccfd;
        hFindHandle = INVALID_HANDLE_VALUE;
        hControlHandle = INVALID_HANDLE_VALUE;
    }

    return lResult;
}

LONG WINAPI FindNextControl(HANDLE& hFindHandle, HANDLE& hControlHandle)
{
    LONG         lResult = ERROR_SUCCESS;
    HRESULT      hr = S_OK;
    HKEY         hKeyClass = NULL;
    
    CCacheItem   *pci = NULL;
    OCCFindData  *poccfd = (OCCFindData *)hFindHandle;

    LPCLSIDLIST_ITEM pcli = poccfd->TakeFirstItem();
    hControlHandle = INVALID_HANDLE_VALUE;

    if (pcli == NULL)
    {
        lResult = ERROR_NO_MORE_ITEMS;
        goto EXIT_FINDNEXTCONTROL;
    }

    if ((lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, HKCR_CLSID, 0, KEY_READ, &hKeyClass)) != ERROR_SUCCESS)
        goto EXIT_FINDNEXTCONTROL;

    if ( pcli->bIsDistUnit )
    {
        HKEY hKeyDist;

        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0,
                                KEY_READ, &hKeyDist);

        if ( lResult == ERROR_SUCCESS ) 
        {
            hr  = MakeCacheItemFromControlList( hKeyClass,
                                                hKeyDist,
                                                pcli,
                                                &pci );
            if ( FAILED(hr) )
                lResult = hr;

            RegCloseKey( hKeyDist );
        }
    }
    else
    {
        // This is not a distribution unit. Fill in CCachItem information
        // from the COM branch.
        hr  = MakeCacheItemFromControlList(hKeyClass, NULL, pcli, &pci );
        if ( FAILED(hr) )
            lResult = hr;
    }

    hControlHandle = (HANDLE)pci;

EXIT_FINDNEXTCONTROL:

    if (hKeyClass)
        RegCloseKey(hKeyClass);

    if (pcli != NULL)
    {
        delete pcli;
    }

    return lResult;
}

void WINAPI FindControlClose(HANDLE hFindHandle)
{
    if (hFindHandle == INVALID_HANDLE_VALUE ||
        hFindHandle == (HANDLE)0)
        return;

    delete (OCCFindData*)hFindHandle;
}

void WINAPI ReleaseControlHandle(HANDLE hControlHandle)
{
    if (hControlHandle == INVALID_HANDLE_VALUE ||
        hControlHandle == (HANDLE)0)
        return;

    delete (CCacheItem *)hControlHandle;
}

HRESULT WINAPI RemoveControlByHandle(HANDLE hControlHandle, BOOL bForceRemove /* = FALSE */)
{
    return RemoveControlByHandle2( hControlHandle, bForceRemove, FALSE );
}


HRESULT WINAPI RemoveControlByName(LPCTSTR lpszFile, LPCTSTR lpszCLSID, LPCTSTR lpszTypeLibID, BOOL bForceRemove, /* = FALSE */ DWORD dwIsDistUnit /* = FALSE */)
{
    return RemoveControlByName2( lpszFile, lpszCLSID, lpszTypeLibID, bForceRemove, dwIsDistUnit, FALSE);
}

LONG WINAPI GetControlDependentFile(int iFile, HANDLE hControlHandle, LPTSTR lpszFile, LPDWORD lpdwSize, BOOL bToUpper /* = FALSE */)
{
    CCacheItem *pci = (CCacheItem *)hControlHandle;

    if (iFile < 0 || lpszFile == NULL || lpdwSize == NULL)
        return ERROR_BAD_ARGUMENTS;

    // loop through the list of files to find the one indicated
    // by the given index.
    // this way is dumb but since a control does not depend on
    // too many files, it's ok
    CFileNode *pFileNode = pci->GetFirstFile();
    for (int i = 0; i < iFile && pFileNode != NULL; i++)
        pFileNode = pci->GetNextFile();

    if (pFileNode == NULL)
    {
        lpszFile[0] = TEXT('\0');
        lpdwSize = 0;
        return ERROR_NO_MORE_FILES;
    }

    // Make a fully qualified filename
    if (pFileNode->GetPath() != NULL)
    {
        CatPathStrN( lpszFile, pFileNode->GetPath(), pFileNode->GetName(), MAX_PATH);
    }
    else
    {
        lstrcpy(lpszFile, pFileNode->GetName());
    }

    if (FAILED(GetSizeOfFile(lpszFile, lpdwSize)))
        *lpdwSize = 0;

    // to upper case if required
    if (bToUpper)
        CharUpper(lpszFile);

    return ERROR_SUCCESS;
}

// determine if a control or one of its associated files can be removed
// by reading its SharedDlls count
BOOL WINAPI IsModuleRemovable(LPCTSTR lpszFile)
{
    TCHAR szFile[MAX_PATH];
    TCHAR szT[MAX_PATH];

    if (lpszFile == NULL)
        return FALSE;

    if ( OCCGetLongPathName(szFile, lpszFile, MAX_PATH) == 0 )
        lstrcpyn( szFile, lpszFile, MAX_PATH );

    // Don't ever pull something out of the system directory.
    // This is a "safe" course of action because it is not reasonable
    // to expect the user to judge whether yanking this file damage other
    // software installations or the system itself.
    GetSystemDirectory(szT, MAX_PATH);
    if (StrStrI(szFile, szT))
        return FALSE;

    // check moduleusage if a control is safe to remove
    if (LookUpModuleUsage(szFile, NULL, szT, MAX_PATH) != S_OK)
        return FALSE;

    // if we don't know who the owner of the module is, it's not
    // safe to remove
    if (lstrcmpi(szT, UNKNOWNOWNER) == 0)
        return FALSE;
    else
    {
        // check shareddlls if a control is safe to remove
        LONG cRef;

        HRESULT hr = SetSharedDllsCount( szFile, -1, &cRef );

        return cRef == 1;
    }
}

BOOL WINAPI GetControlInfo(HANDLE hControlHandle, UINT nFlag, 
                           DWORD *pdwData, LPTSTR pszData, int nBufLen)
{
    if (hControlHandle == 0 || hControlHandle == INVALID_HANDLE_VALUE)
        return FALSE;

    BOOL bResult = TRUE;
    LPCTSTR pStr = NULL;
    DWORD dw = 0;

    switch (nFlag)
    {
    case GCI_NAME:     // get friend name of control
        pStr = ((CCacheItem *)hControlHandle)->m_szName;
        break;

    case GCI_FILE:     // get filename of control (with full path)
        pStr = ((CCacheItem *)hControlHandle)->m_szFile;
        // if there is no file, but there is a package list, fake it
        // with the path to the first package's ZIP file.
        if ( *pStr == '\0' )
        {
            CPNode *ppn = ((CCacheItem *)hControlHandle)->GetFirstPackage();
            if (ppn)
            {
                pStr = ppn->GetPath();
                if (!pStr)
                {
                    return FALSE; // this means hControlHandle is an invalid arg
                }
            }
        }

        if ( pStr && *pStr == TEXT('\0') )
        {
            CPNode *pfn = ((CCacheItem *)hControlHandle)->GetFirstFile();
            if ( pfn != NULL )
                pStr = pfn->GetPath();
        }
        break;

    case GCI_DIST_UNIT_VERSION:
        pStr = ((CCacheItem *)hControlHandle)->m_szVersion;
        break;

    case GCI_CLSID:    // get CLSID of control
        pStr = ((CCacheItem *)hControlHandle)->m_szCLSID;
        break;

    case GCI_TYPELIBID:  // get TYPELIB id of control
        pStr = ((CCacheItem *)hControlHandle)->m_szTypeLibID;
        break;

    case GCI_TOTALSIZE:  // get total size in bytes
        dw = ((CCacheItem *)hControlHandle)->GetTotalFileSize();
        break;

    case GCI_SIZESAVED:  // get total size restored if control is removed
        dw = ((CCacheItem *)hControlHandle)->GetTotalSizeSaved();
        break;

    case GCI_TOTALFILES:  // get total number of files related to control
        dw = (DWORD)(((CCacheItem *)hControlHandle)->GetTotalFiles());
        break;

    case GCI_CODEBASE:  // get CodeBase for control
        pStr = ((CCacheItem *)hControlHandle)->m_szCodeBase;
        break;

    case GCI_ISDISTUNIT:
        dw = ((CCacheItem *)hControlHandle)->ItemType() == CCacheDistUnit::s_dwType;
        break;

    case GCI_STATUS:
        dw = ((CCacheItem *)hControlHandle)->GetStatus();
        break;

    case GCI_HAS_ACTIVEX:
        dw = ((CCacheItem *)hControlHandle)->GetHasActiveX();
        break;

    case GCI_HAS_JAVA:
        dw = ((CCacheItem *)hControlHandle)->GetHasJava();
        break;
    }

    if (nFlag == GCI_TOTALSIZE ||
        nFlag == GCI_SIZESAVED ||
        nFlag == GCI_TOTALFILES ||
        nFlag == GCI_ISDISTUNIT ||
        nFlag == GCI_STATUS ||
        nFlag == GCI_HAS_ACTIVEX ||
        nFlag == GCI_HAS_JAVA)
    {
        bResult = pdwData != NULL;
        if (bResult)
            *pdwData = dw;
    }
    else
    {
        bResult = pszData && pStr;
        if (bResult)
            lstrcpyn(pszData, pStr, nBufLen);
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// API to be called by Advpack.dll

// Define list node to be used in a linked list of control
struct tagHANDLENODE;
typedef struct tagHANDLENODE HANDLENODE;
typedef HANDLENODE* LPHANDLENODE;
struct tagHANDLENODE
{
    HANDLE hControl;
    struct tagHANDLENODE* pNext;
};

// Given a handle to a control, get the control's last access time
// Result is stored in a FILETIME struct
HRESULT GetLastAccessTime(HANDLE hControl, FILETIME *pLastAccess)
{
    Assert(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    Assert(pLastAccess != NULL);

    HRESULT hr = S_OK;
    WIN32_FIND_DATA fdata;
    HANDLE h = INVALID_HANDLE_VALUE;
    LPCTSTR  lpszFile = NULL;
    CCacheItem *pci = (CCacheItem *)hControl;
    CPNode *ppn;

    if (pci->m_szFile[0] != 0)
        lpszFile = pci->m_szFile;
    else if ( (ppn = pci->GetFirstPackage()) != NULL )
        lpszFile = ppn->GetPath();
    else if ( (ppn = pci->GetFirstFile()) != NULL )
        lpszFile = ppn->GetPath();
        
    if ( lpszFile )
        h = FindFirstFile(lpszFile, &fdata);

    if (h == INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME stNow;
        GetLocalTime(&stNow);
        SystemTimeToFileTime(&stNow, pLastAccess); 
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        // Convert file time to local file time, then file time to 
        // system time.  Set those fields to be ignored to 0, and
        // set system time back to file time.
        // FILETIME struct is used because API for time comparison
        // only works on FILETIME.

//        SYSTEMTIME sysTime;

        FindClose(h);
        FileTimeToLocalFileTime(&(fdata.ftLastAccessTime), pLastAccess);
    }

    return hr;
}

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime /* = NULL */,
                              PFNDOBEFOREREMOVAL pfnDoBefore /* = NULL */,
                              PFNDOAFTERREMOVAL pfnDoAfter /* = NULL */,
                              DWORD dwSizeLimit /* = 0 */
                              )
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_FALSE;
    DWORD dwSize = 0, dwTotalSize = 0;
    HANDLE hFind = NULL, hControl = NULL;
    LPHANDLENODE pHead = NULL, pCur = NULL;
    FILETIME timeLastAccess, timeRemovePrior;
    UINT cCnt = 0;
    TCHAR szFile[MAX_PATH];

    // ignore all fields except wYear, wMonth and wDay
    if (pLastAccessTime != NULL)
    {
        pLastAccessTime->wDayOfWeek = 0; 
        pLastAccessTime->wHour = 0; 
        pLastAccessTime->wMinute = 0; 
        pLastAccessTime->wSecond = 0; 
        pLastAccessTime->wMilliseconds = 0; 
    }

    // loop through all controls and put in a list the
    // ones that are accessed before the given date and
    // are safe to uninstall
    lResult = FindFirstControl(hFind, hControl);
    for (;lResult == ERROR_SUCCESS;
          lResult = FindNextControl(hFind, hControl))
    {
        // check last access time
        if (pLastAccessTime != NULL)
        {
            GetLastAccessTime(hControl, &timeLastAccess);
            SystemTimeToFileTime(pLastAccessTime, &timeRemovePrior);
            if (CompareFileTime(&timeLastAccess, &timeRemovePrior) > 0)
            {
                ReleaseControlHandle(hControl);
                continue;
            }
        }

        // check if control is safe to remove
        GetControlInfo(hControl, GCI_FILE, NULL, szFile, MAX_PATH);
        if (!IsModuleRemovable(szFile))
        {
            ReleaseControlHandle(hControl);
            continue;
        }

        // put control in a list
        if (pHead == NULL)
        {
            pHead = new HANDLENODE;
            pCur = pHead;
        }
        else
        {
            pCur->pNext = new HANDLENODE;
            pCur = pCur->pNext;
        }

        if (pCur == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto EXIT_REMOVECONTROLBYLASTACCESSDATE;
        }
        
        pCur->pNext = NULL;
        pCur->hControl = hControl;
        cCnt += 1;

        // calculate total size
        GetControlInfo(pCur->hControl, GCI_SIZESAVED, &dwSize, NULL, NULL);
        dwTotalSize += dwSize;
    }
        
    // quit if total size restored is less than the given amount
    if (dwTotalSize < dwSizeLimit)
        goto EXIT_REMOVECONTROLBYLASTACCESSDATE;

    // traverse the list and remove each control
    for (pCur = pHead; pCur != NULL; cCnt--)
    {
        hr = S_OK;
        pHead = pHead->pNext;

        // call callback function before removing a control
        if (pfnDoBefore == NULL || SUCCEEDED(pfnDoBefore(pCur->hControl, cCnt)))
        {
            hr = RemoveControlByHandle(pCur->hControl);

            // call callback function after removing a control, passing it the
            // result of the removal
            if (pfnDoAfter != NULL && FAILED(pfnDoAfter(hr, cCnt - 1)))
            {
                pHead = pCur;   // set pHead back to head of list
                goto EXIT_REMOVECONTROLBYLASTACCESSDATE;
            }
        }

        // release memory used by the control handle
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
        pCur = pHead;
    }

EXIT_REMOVECONTROLBYLASTACCESSDATE:

    FindControlClose(hFind);

    // release memory taken up by the list
    for (pCur = pHead; pCur != NULL; pCur = pHead)
    {
        pHead = pHead->pNext;
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
    }

    return hr;
}

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved)
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_FALSE;
    HANDLE hFind = NULL, hControl = NULL;
    LPHANDLENODE pHead = NULL, pCur = NULL;
    FILETIME ftNow, ftMinLastAccess, ftLastAccess;
    LARGE_INTEGER liMinLastAccess;
    SYSTEMTIME stNow;
    UINT cCnt = 0;

    GetLocalTime( &stNow );
    SystemTimeToFileTime(&stNow, &ftNow);

    // loop through all controls and put in a list the
    // ones that are accessed before the given date and
    // are safe to uninstall
    lResult = FindFirstControl(hFind, hControl);
    for (;lResult == ERROR_SUCCESS;
          lResult = FindNextControl(hFind, hControl))
    {
        CCacheItem *pci = (CCacheItem *)hControl;

        // Controls must have a last access time of at least ftMinLastAccess or they will
        // expire by default. If they have the Office Auto-expire set, then they may
        // have to pass a higher bar.

        liMinLastAccess.LowPart = ftNow.dwLowDateTime;
        liMinLastAccess.HighPart = ftNow.dwHighDateTime;
        // We add one to GetExpireDays to deal with bug  17151. The last access time
        // returned by the file system is truncated down to 12AM, so we need to 
        // expand the expire interval to ensure that this truncation does not cause
        // the control to expire prematurely.
        liMinLastAccess.QuadPart -= ((pci->GetExpireDays()+1) * 864000000000L); //24*3600*10^7
        ftMinLastAccess.dwLowDateTime = liMinLastAccess.LowPart;
        ftMinLastAccess.dwHighDateTime = liMinLastAccess.HighPart;

        GetLastAccessTime(hControl, &ftLastAccess); // ftLastAccess is a local file time

        if (CompareFileTime(&ftLastAccess, &ftMinLastAccess) >= 0)
        {
            ReleaseControlHandle(hControl);
            continue;
        }


        // put control in a list
        if (pHead == NULL)
        {
            pHead = new HANDLENODE;
            pCur = pHead;
        }
        else
        {
            pCur->pNext = new HANDLENODE;
            pCur = pCur->pNext;
        }

        if (pCur == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pCur->pNext = NULL;
        pCur->hControl = hControl;
        cCnt += 1;
    }

    // traverse the list and remove each control
    for (pCur = pHead; pCur != NULL; cCnt--)
    {
        hr = S_OK;
        pHead = pHead->pNext;

        hr = RemoveControlByHandle2(pCur->hControl, FALSE, TRUE);

        // release memory used by the control handle
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
        pCur = pHead;
    }

cleanup:

    FindControlClose(hFind);

    // release memory taken up by the list, if any left
    for (pCur = pHead; pCur != NULL; pCur = pHead)
    {
        pHead = pHead->pNext;
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\cdlbsc.hpp ===
#ifndef __CDLBSC_INCLUDED__
#define __CDLBSC_INCLUDED__

#include "init.h"
#include <urlmon.h>

#define DOWNLOAD_PROGRESS  0x9001
#define DOWNLOAD_COMPLETE  0x9002

class CodeDownloadBSC : public IBindStatusCallback, public IWindowForBindingUI {
    public:
        CodeDownloadBSC( HWND hwnd, HWND hdlg, LPITEMIDLIST pidlUpdate = NULL );
        virtual ~CodeDownloadBSC();
        HRESULT Abort();

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID ridd, void **ppv );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
    
        // IBindStatusCallback methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo);
        STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding *pib);
        STDMETHODIMP GetPriority(LONG *pnPriority);
        STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                      FORMATETC *pformatetc,
                                      STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
        STDMETHODIMP OnLowResource(DWORD dwReserved);
        STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);

        // IWindowForBindingUI
        STDMETHODIMP GetWindow( REFGUID rguidReason, HWND __RPC_FAR *phwnd ); 

        HWND            _hdlg;          // progress dialog

    protected:
        IBinding        *_pIBinding; // ibinding from code dl'er
        DWORD           _cRef;
        HWND            _hwnd;          // owner window
        LPITEMIDLIST    _pidlUpdate;    // pidl for item we are updating
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "init.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "occache"
#define SZ_MODULE           "OCCACHE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\dlg.h ===
#ifndef DLG_H
#define DLG_H

#include <windows.h>
#include <windowsx.h>
#include <debug.h>

typedef void (*PFN)();

typedef union tagMMF {
    PFN pfn;

    LRESULT (*pfn_lwwwl)(HWND, UINT, WPARAM, LPARAM);
    BOOL    (*pfn_bwwwl)(HWND, UINT, WPARAM, LPARAM);
    void    (*pfn_vv)();
    BOOL    (*pfn_bv)();
    void    (*pfn_vw)(WPARAM);
    BOOL    (*pfn_bw)(WPARAM);
    void    (*pfn_vh)(HANDLE);
    BOOL    (*pfn_bh)(HANDLE);
    BOOL    (*pfn_bhl)(HANDLE, LPARAM);
    void    (*pfn_vhww)(HANDLE, UINT, WORD);
    void    (*pfn_vhhw)(HANDLE, HANDLE, WORD);
} MMF;

typedef enum tagMSIG {
    ms_end = 0,

    ms_lwwwl,   // LRESULT (HWND, UINT, WORD, LPARAM)
    ms_bwwwl,   // BOOL    (HWND, UINT, WORD, LPARAM)
    ms_vv,      // void    (void)
    ms_bv,      // BOOL    (void)
    ms_vw,      // void    (WPARAM)
    ms_bw,      // BOOL    (WPARAM)
    ms_vh,      // void    (HANDLE)
    ms_bh,      // BOOL    (HANDLE)
    ms_bhl,     // BOOL    (HANDLE, LPARAM)
    ms_vhww,    // void    (HANDLE, UINT,   WORD)
    ms_vhhw,    // void    (HANDLE, HANDLE, WORD)
} MSIG;

typedef struct tagMSD {
    UINT msg;
    MSIG ms;
    PFN  pfn;
} MSD;
typedef MSD *PMSD;

typedef struct tagCMD {
    UINT nID, nLastID;
    MSIG ms;
    PFN  pfn;
} CMD;
typedef CMD *PCMD;

INT_PTR Dlg_MsgProc(const MSD *pmsd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);
BOOL Msg_OnCmd(const CMD *pcmd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\dlg.cpp ===
#include "dlg.h"
#include "utils.h"

#include <mluisupp.h>

INT_PTR Dlg_MsgProc(const MSD *pmsd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    MMF  mmf;
    INT_PTR fResult = FALSE;

    if (msg == WM_SETFONT) {
//      MACRO_LI_SmartRemoveFlags(LIF_LINE);
//      Out(LI0("Dialog is created..."));
    }

    ASSERT(pmsd != NULL);
    for (; pmsd->ms != ms_end; pmsd++)
        if (pmsd->msg == msg) {
            mmf.pfn = pmsd->pfn;

            switch (pmsd->ms) {
            case ms_lwwwl:
                fResult = (INT_PTR)(*mmf.pfn_lwwwl)(hDlg, msg, wp, lp);
                break;

            case ms_bwwwl:
                fResult = (*mmf.pfn_bwwwl)(hDlg, msg, wp, lp);
                break;

            case ms_vv:
                (*mmf.pfn_vv)();
                fResult = TRUE;
                break;

            case ms_bv:
                fResult = (*mmf.pfn_bv)();
                break;

            case ms_vw:
                (*mmf.pfn_vw)(wp);
                fResult = TRUE;
                break;

            case ms_vh:
                (*mmf.pfn_vh)(hDlg);
                fResult = TRUE;
                break;

            case ms_bh:
                fResult = (*mmf.pfn_bh)(hDlg);
                break;

            case ms_bhl:
                fResult = (*mmf.pfn_bhl)(hDlg, lp);
                break;

            default:
                ASSERT(FALSE);
            }

            break;
        }

    if (msg == WM_NCDESTROY) {
//      MACRO_LI_SmartRemoveFlags(LIF_LINE);
//      Out(LI0("Dialog is destroying..."));
    }

    return fResult;
}

BOOL Msg_OnCmd(const CMD *pcmd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    MMF  mmf;
    UINT nID     = GET_WM_COMMAND_ID(wp, lp);
    BOOL fResult = FALSE;

    //----- Look for message map entry -----
    for (; pcmd->ms != ms_end; pcmd++)
        if ((pcmd->nLastID <= pcmd->nID && pcmd->nID == nID) ||
            (nID >= pcmd->nID && nID <= pcmd->nLastID))
            break;
    if (pcmd->ms == ms_end) {
        if (nID == IDOK || nID == IDCANCEL)
            EndDialog(hDlg, nID);

        return fResult;
    }

    //----- Dispatch based on function signature -----
    mmf.pfn = pcmd->pfn;
    switch (pcmd->ms) {
    case ms_vv:
        (*mmf.pfn_vv)();
        fResult = TRUE;
        break;

    case ms_bv:
        fResult = (*mmf.pfn_bv)();
        break;

    case ms_vw:
        (*mmf.pfn_vw)(nID);
        fResult = TRUE;
        break;

    case ms_vh:
        (*mmf.pfn_vh)(hDlg);
        fResult = TRUE;
        break;

    case ms_bh:
        fResult = (*mmf.pfn_bh)(hDlg);
        break;

    case ms_vhww:
        (*mmf.pfn_vhww)(hDlg, nID, GET_WM_COMMAND_CMD(wp, lp));
        fResult = TRUE;
        break;

    case ms_vhhw:
        (*mmf.pfn_vhhw)(hDlg, GetDlgItem(hDlg, nID),
            GET_WM_COMMAND_CMD(wp, lp));
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);
    }

    //----- Special processing -----
    if (nID == IDOK || nID == IDCANCEL)
        if (pcmd->ms != ms_end) {
            if (fResult)
                EndDialog(hDlg, nID);
        }
        else
            EndDialog(hDlg, nID);

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\emptyvol.cpp ===
#include "init.h"
#include <emptyvc.h>
#include <regstr.h>
#include "general.h"
#include "dlg.h"
#include "emptyvol.h"
#include "parseinf.h"

#define MAX_DRIVES                 26   // there are 26 letters only

// {8369AB20-56C9-11d0-94E8-00AA0059CE02}
const CLSID CLSID_EmptyControlVolumeCache = {
                            0x8369ab20, 0x56c9, 0x11d0, 
                            0x94, 0xe8, 0x0, 0xaa, 0x0,
                            0x59, 0xce, 0x2};

/******************************************************************************
    class CEmptyControlVolumeCache
******************************************************************************/

class CEmptyControlVolumeCache : public IEmptyVolumeCache
{
public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEmptyVolumeCache Methods
    STDMETHODIMP Initialize(HKEY hRegKey, LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags);
    STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb);
    STDMETHODIMP Purge(DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb);
    STDMETHODIMP ShowProperties(HWND hwnd);
    STDMETHODIMP Deactivate(DWORD *pdwFlags);

// Attributes
public:
    static HRESULT IsControlExpired(HANDLE hControl, BOOL fUseCache = TRUE);

// Implementation
public:
    // Constructor and destructor
    CEmptyControlVolumeCache();
    virtual ~CEmptyControlVolumeCache();

protected:
        // implementation data helpers

    // Note. Write operations are only perfomed by the private functions
    //       prefixed cpl_XXX. Read access is not restricted.
    LPCACHE_PATH_NODE m_pPathsHead,
                      m_pPathsTail;

    // Note. Write operations are only perfomed by the private functions
    //       prefixed chl_XXX. Read access is not restricted.
    LPCONTROL_HANDLE_NODE m_pControlsHead,
                          m_pControlsTail;

    WCHAR     m_szVol[4];
    DWORDLONG m_dwTotalSize;
    ULONG     m_cRef;

        // implementation helper routines

    // cpl prefix stands for CachePathsList
    HRESULT cpl_Add(LPCTSTR pszCachePath);
    void    cpl_Remove();
    HRESULT cpl_CreateForVolume(LPCWSTR pszVolume = NULL);

    // chl prefix stands for ControlHandlesList
    HRESULT chl_Find(HANDLE hControl,
        LPCONTROL_HANDLE_NODE *rgp = NULL, UINT nSize = 1) const;
    HRESULT chl_Add(HANDLE hControl);
    void    chl_Remove(LPCONTROL_HANDLE_NODE rgp[2]);
    HRESULT chl_Remove(HANDLE hControl = NULL);
    HRESULT chl_CreateForPath(LPCTSTR pszCachePath,
        DWORDLONG *pdwUsedInFolder = NULL);

    friend HRESULT _stdcall EmptyControl_CreateInstance(IUnknown *pUnkOuter,
        REFIID riid, LPVOID* ppv);

//  friend BOOL CALLBACK EmptyControl_PropertiesDlgProc(HWND hDlg,
//      UINT msg, WPARAM wp, LPARAM lp);
};


STDAPI EmptyControl_CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CEmptyControlVolumeCache *pCRC = new CEmptyControlVolumeCache;
    if (pCRC == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pCRC->QueryInterface(riid, ppv);
    pCRC->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache constructor and destructor

CEmptyControlVolumeCache::CEmptyControlVolumeCache()
{
    DllAddRef();

    m_pPathsHead = m_pPathsTail = NULL;
    m_pControlsHead = m_pControlsTail = NULL;

    m_szVol[0] = L'\0';
    m_dwTotalSize = 0;
    m_cRef = 1;
}

CEmptyControlVolumeCache::~CEmptyControlVolumeCache()
{
    ASSERT(m_cRef == 0);
    cpl_Remove();
    chl_Remove();

    DllRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache attributes


// CEmptyControlVolumeCache::IsControlExpired
// Check if a control has not been accessed for more than N days. If there is
// no registry entry, default is DEFAULT_DAYS_BEFORE_EXPIRE.
//
// Parameters: fUseCache can be used to not go to the registry for the value
// of N above.
//
// Returns: either the Win32 error converted to HRESULT or
//          S_OK if control is expired and S_FALSE if not;
//
// Used by: only by CEmptyControlVolumeCache::chl_CreateForPath
//
HRESULT CEmptyControlVolumeCache::IsControlExpired(HANDLE hControl,
    BOOL fUseCache /*= TRUE*/)
{
    SYSTEMTIME    stNow;
    FILETIME      ftNow;
    FILETIME      ftLastAccess;
    LARGE_INTEGER timeExpire;
    HRESULT       hr = S_OK;

    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);

    // don't expire controls with uncertain access time.
    if (FAILED(GetLastAccessTime(hControl, &ftLastAccess)))
        return S_FALSE;
 
    //----- Time calculations (wierd looking) -----
    // Add to last access date the length of time before a control expires
    timeExpire.LowPart  = ftLastAccess.dwLowDateTime;
    timeExpire.HighPart = ftLastAccess.dwHighDateTime;
    timeExpire.QuadPart += (((CCacheItem*)hControl)->GetExpireDays() * 864000000000L); //24*3600*10^7

    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    return CompareFileTime((FILETIME*)&timeExpire, &ftNow) <= 0 ?
        S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache CachePathsList routines

// CEmptyControlVolumeCache::cpl_Add
// Check if a control has not been accessed for more than N days. If there is
// no registry entry, default is DEFAULT_DAYS_BEFORE_EXPIRE.
//
// Parameters: a cache folder path to add.
//
// Returns: E_OUTOFMEMORY or
//          S_FALSE if path is already in the list or S_OK if added.
//
// Used by: only by CEmptyControlVolumeCache::cpl_CreateForVolume
//
HRESULT CEmptyControlVolumeCache::cpl_Add(LPCTSTR pszCachePath)
{
    LPCACHE_PATH_NODE pNode;

    ASSERT(pszCachePath != NULL);

    for (pNode = m_pPathsHead; pNode != NULL; pNode = pNode->pNext)
        if (lstrcmpi(pNode->szCachePath, pszCachePath) == 0)
            break;
    if (pNode != NULL)
        return S_FALSE;

    pNode = new CACHE_PATH_NODE;
    if (pNode == NULL)
        return E_OUTOFMEMORY;

    lstrcpyn(pNode->szCachePath, pszCachePath, MAX_PATH);
    pNode->pNext = NULL;
    if (m_pPathsHead == NULL)
        m_pPathsHead = pNode;
    else
        m_pPathsTail->pNext = pNode;
    m_pPathsTail = pNode;

    return S_OK;
}

// CEmptyControlVolumeCache::cpl_Remove
// Remove all paths from the internal list.
//
// Parameters: none;
//
// Returns: void;
//
// Used by: several obvious places
//
void CEmptyControlVolumeCache::cpl_Remove()
{
    // remove cache path list
    for (LPCACHE_PATH_NODE pCur = m_pPathsHead;
         m_pPathsHead != NULL;
         pCur = m_pPathsHead) {

        m_pPathsHead = m_pPathsHead->pNext;
        delete[] pCur;
    }
    m_pPathsTail = NULL;
}

// CEmptyControlVolumeCache::cpl_CreateForVolume
// Build a list of paths to cache folders.
//
// Parameters: volume (or drive) where these folders are;
//
// Returns: S_OK or one out of the bunch of obvious errors;
//
// Used by: only by IEmptyVolumeCache::GetSpaceUsed
//
HRESULT CEmptyControlVolumeCache::cpl_CreateForVolume(LPCWSTR pszVolume)
{
    HKEY    hkey = NULL;
    HRESULT hr   = E_FAIL;
    int     iDriveNum;

    ASSERT(pszVolume != NULL);
    iDriveNum = PathGetDriveNumberW(pszVolume);
    if (iDriveNum < 0)
        return E_INVALIDARG;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_ACTIVEX_CACHE, 0,
            KEY_READ, &hkey) != ERROR_SUCCESS)
        return E_FAIL;

    TCHAR szCachePath[MAX_PATH],
          szValue[MAX_PATH];
    DWORD dwIndex    = 0,
          dwValueLen = MAX_PATH, dwLen = MAX_PATH;

    cpl_Remove();
    while (RegEnumValue(hkey, dwIndex++, szValue, &dwValueLen, NULL, NULL,
               (LPBYTE)szCachePath, &dwLen) == ERROR_SUCCESS) {
        dwLen = dwValueLen = MAX_PATH;

        if (PathGetDriveNumber(szCachePath) != iDriveNum)
            continue;

        // we must have added at least one successfully to get a success code..
        hr = cpl_Add(szCachePath);
        if (FAILED(hr))
            break;
    }
    RegCloseKey(hkey);

    if (FAILED(hr))
        cpl_Remove();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache ControlHandlesList routines

// CEmptyControlVolumeCache::chl_Find
// Find and return a location for the specified handle in the internal list.
// if (rgp == NULL), only result matters;
// if (rgp != NULL),
//     if (nSize == 1), *rgp is going to have found item (if it's there)
//     if (nSize >= 2), *rgp[0] = prev to the found item, and *rgp[1] is the
//                      item.
//
// Parameters: explained above;
//
// Returns: S_OK if the item is found, S_FALSE otherwise or
//          one out of the bunch of obvious errors;
//
// Used by: CEmptyControlVolumeCache::chl_Add and
//          CEmptyControlVolumeCache::chl_Remove
//
HRESULT CEmptyControlVolumeCache::chl_Find(HANDLE hControl,
    LPCONTROL_HANDLE_NODE *rgp /*= NULL*/, UINT nSize /*= 1*/) const
{
    LPCONTROL_HANDLE_NODE pCur,
                          pPrev = NULL;

    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    for (pCur = m_pControlsHead; pCur != NULL; pCur = pCur->pNext) {
        if (pCur->hControl == hControl)
            break;
        pPrev = pCur;
    }
    if (pCur == NULL)
        pPrev = NULL;                           // zero out possible return

    if (rgp != NULL && nSize > 0)
        if (nSize == 1)
            *rgp = pCur;
        else { /* if (nSize >= 2) */
            rgp[0] = pPrev;
            rgp[1] = pCur;
        }

    return (pCur != NULL) ? S_OK : E_FAIL;
}

HRESULT CEmptyControlVolumeCache::chl_Add(HANDLE hControl)
{
    LPCONTROL_HANDLE_NODE pNode;
    DWORD                 dwSize;

    // Note. Retail build assumes that handle is not in the list.
    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    ASSERT(FAILED(chl_Find(hControl)));

    pNode = new CONTROL_HANDLE_NODE;
    if (pNode == NULL)
        return E_OUTOFMEMORY;

    GetControlInfo(hControl, GCI_SIZESAVED, &dwSize, NULL, 0);

    pNode->hControl = hControl;
    pNode->pNext    = NULL;

    if (m_pControlsHead == NULL)
        m_pControlsHead = pNode;
    else {
        ASSERT(m_pControlsHead != NULL);
        m_pControlsTail->pNext = pNode;
    }
    m_pControlsTail = pNode;

    m_dwTotalSize += dwSize;
    return S_OK;
}

void CEmptyControlVolumeCache::chl_Remove(LPCONTROL_HANDLE_NODE rgp[2])
{
    DWORD dwSize;

    if (m_pControlsHead == NULL || (rgp[0] != NULL && rgp[1] == NULL))
        return;

    if (rgp[0] != NULL)
        rgp[0]->pNext = rgp[1]->pNext;
    else {
        rgp[1] = m_pControlsHead;
        m_pControlsHead = m_pControlsHead->pNext;
    }

    if (rgp[1] == m_pControlsTail)
        m_pControlsTail = rgp[0];

    if (GetControlInfo(rgp[1]->hControl, GCI_SIZESAVED, &dwSize, NULL, 0))
    {
        // only proceeed if GetControlInfo succeeds
    
        // Note. This code assumes that the size of a control didn't change since
        //       it was added.
        m_dwTotalSize -= dwSize;
    }
    
    ReleaseControlHandle(rgp[1]->hControl);
    delete rgp[1];
}

HRESULT CEmptyControlVolumeCache::chl_Remove(HANDLE hControl /*= NULL*/)
{
    LPCONTROL_HANDLE_NODE rgp[2] = { NULL, NULL };
    HRESULT hr;

    ASSERT(hControl != INVALID_HANDLE_VALUE);
    if (hControl != NULL) {
        hr = chl_Find(hControl, rgp, 2);
        if (FAILED(hr))
            return hr;

        chl_Remove(rgp);
        return S_OK;
    }

    while (m_pControlsHead != NULL)
        chl_Remove(rgp);

    ASSERT(m_pControlsHead == NULL && m_pControlsTail == NULL);
    return S_OK;
}

// CEmptyControlVolumeCache::chl_CreateForPath
// Calculate the size in bytes taken up by controls in the control cache
// folder specified.
//
// Parameters: pszCachePath is a path to the controls cache folder;
//             pdwSpaceUsed is the result
//
// Used by: only by IEmptyVolumeCache::GetSpaceUsed
//
HRESULT CEmptyControlVolumeCache::chl_CreateForPath(LPCTSTR pszCachePath,
    DWORDLONG *pdwUsedInFolder /*= NULL*/)
{
    DWORDLONG dwCopy;
    HANDLE    hFind    = NULL,
              hControl = NULL;
    LONG      lResult;
    BOOL      fCache   = FALSE;

    dwCopy = m_dwTotalSize;
    for (lResult = FindFirstControl(hFind, hControl, pszCachePath);
         lResult == ERROR_SUCCESS;
         lResult = FindNextControl(hFind, hControl)) {

        lResult = HRESULT_CODE(IsControlExpired(hControl, fCache));
        fCache  = TRUE;
        if (lResult != ERROR_SUCCESS)
            continue;

        lResult = HRESULT_CODE(chl_Add(hControl));
        if (lResult != ERROR_SUCCESS)
            break;
    }
    FindControlClose(hFind);

    if (lResult == ERROR_NO_MORE_ITEMS)
        lResult = ERROR_SUCCESS;

    if (pdwUsedInFolder != NULL) {
        *pdwUsedInFolder = m_dwTotalSize - dwCopy;
    }
    return HRESULT_FROM_WIN32(lResult);
}


/******************************************************************************
    IUnknown Methods
******************************************************************************/

STDMETHODIMP CEmptyControlVolumeCache::QueryInterface(REFIID iid, void** ppv)
{
    if (ppv == NULL)
        return E_POINTER;
    *ppv = NULL;

    if (iid != IID_IUnknown && iid != IID_IEmptyVolumeCache)
        return E_NOINTERFACE;

    *ppv = (void *)this;
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CEmptyControlVolumeCache::AddRef()
{
    return (++m_cRef);
}

STDMETHODIMP_(ULONG) CEmptyControlVolumeCache::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}


/******************************************************************************
    IEmptyVolumeCache Methods
******************************************************************************/

STDMETHODIMP CEmptyControlVolumeCache::Initialize(HKEY hRegKey,
    LPCWSTR pszVolume, LPWSTR *ppszDisplayName, LPWSTR *ppszDescription,
    DWORD *pdwFlags)
{
    if (pszVolume == NULL)
        return E_POINTER;

    if (ppszDisplayName == NULL || ppszDescription == NULL)
        return E_POINTER;

    if (pdwFlags == NULL)
        return E_POINTER;

    StrCpyNW(m_szVol, pszVolume, ARRAYSIZE(m_szVol));
    cpl_Remove();
    chl_Remove();
    
    if (lstrlenW(m_szVol) == 0) {
        return E_UNEXPECTED;
    }

    if (FAILED(cpl_CreateForVolume(m_szVol))) {
        return E_FAIL;
    }

    *ppszDisplayName = *ppszDescription = NULL;
    *pdwFlags = EVCF_HASSETTINGS | EVCF_ENABLEBYDEFAULT |
        EVCF_ENABLEBYDEFAULT_AUTO;
    return S_OK;
}

STDMETHODIMP CEmptyControlVolumeCache::GetSpaceUsed(DWORDLONG *pdwSpaceUsed,
    IEmptyVolumeCacheCallBack *picb)
{
    LPCACHE_PATH_NODE pCur;
    HRESULT hr = S_OK;

    if (pdwSpaceUsed == NULL) {
        hr = E_POINTER;
        goto LastNotification;
    }
    *pdwSpaceUsed = 0;

    if (lstrlenW(m_szVol) == 0) {
        hr = E_UNEXPECTED;
        goto LastNotification;
    }

    for (pCur = m_pPathsHead; pCur != NULL; pCur = pCur->pNext) {
        DWORDLONG dwlThisItem = 0;
        if (FAILED(chl_CreateForPath(pCur->szCachePath, &dwlThisItem)))
            hr = S_FALSE;                       // at least one failed

        m_dwTotalSize += dwlThisItem;
        
        if (picb != NULL)
            picb->ScanProgress(m_dwTotalSize, 0, NULL);
    }
//  cpl_Remove();                               // because of ShowProperties

    *pdwSpaceUsed = m_dwTotalSize;

LastNotification:
    if (picb != NULL)
        picb->ScanProgress(m_dwTotalSize, EVCCBF_LASTNOTIFICATION, NULL);
    return hr;
}

STDMETHODIMP CEmptyControlVolumeCache::Purge(DWORDLONG dwSpaceToFree,
    IEmptyVolumeCacheCallBack *picb)
{
    LPCONTROL_HANDLE_NODE rgp[2] = { NULL, NULL };
    DWORDLONG dwSpaceFreed;
    HANDLE    hControl;
    DWORD     dwSize;
    HRESULT   hr;

    if (m_pControlsHead == NULL) {
        DWORDLONG dwSpaceUsed;

        hr = GetSpaceUsed(&dwSpaceUsed, picb);
        if (FAILED(hr) || m_pControlsHead == NULL)
            hr = FAILED(hr) ? hr : STG_E_NOMOREFILES;

        if (picb != NULL)
            picb->PurgeProgress(0, dwSpaceToFree, EVCCBF_LASTNOTIFICATION,
                NULL);

        return hr;
    }

    dwSpaceFreed = 0;
    ASSERT(m_pControlsHead != NULL);
    while (m_pControlsHead != NULL) {
        hControl = m_pControlsHead->hControl;
        ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);

        GetControlInfo(hControl, GCI_SIZESAVED, &dwSize, NULL, 0);

        hr = RemoveControlByHandle2(hControl, FALSE, TRUE);
        if (SUCCEEDED(hr)) {
            dwSpaceFreed += dwSize;

            if (picb != NULL)
                picb->PurgeProgress(dwSpaceFreed, dwSpaceToFree, 0, NULL);
        }
        chl_Remove(rgp);

        if (dwSpaceFreed >= dwSpaceToFree)
            break;
    }

    if (picb != NULL)
        picb->PurgeProgress(dwSpaceFreed, dwSpaceToFree, 0, NULL);

    return S_OK;
}

// Note. This function opens the last cache folder in the internal list.
STDMETHODIMP CEmptyControlVolumeCache::ShowProperties(HWND hwnd)
{
    // Note. (According to SeanF) The codedownload engine will query
    //       ActiveXCache key under HKLM\SOFTWARE\Microsoft\Windows\
    //       CurrentVersion\Internet Settings. The value of this key should
    //       be equal to the last item in the CachePathsList which is why
    //       navigation below is done for the tail.
    if (m_pPathsTail == NULL || m_pPathsTail->szCachePath == NULL)
        return E_UNEXPECTED;

    ShellExecute(hwnd, NULL, m_pPathsTail->szCachePath, NULL, NULL, SW_SHOW);
    return S_OK;
/*
    int iDlgResult;

    iDlgResult = MLDialogBoxWrap(MLGetHinst(), MAKEINTRESOURCE(IDD_PROP_EXPIRE), hwnd,
        EmptyControl_PropertiesDlgProc);

    return iDlgResult == IDOK ? S_OK : S_FALSE;
*/
}

STDMETHODIMP CEmptyControlVolumeCache::Deactivate(DWORD *pdwFlags)
{
    if (pdwFlags == NULL)
        return E_INVALIDARG;
    *pdwFlags = 0;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

/*
static void msg_OnInitDialog(HWND hDlg);
static BOOL msg_OnCommand(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);

static BOOL cmd_OnOK(HWND hDlg);

INT_PTR CALLBACK EmptyControl_PropertiesDlgProc(HWND hDlg,
    UINT msg, WPARAM wp, LPARAM lp)
{
    static MSD rgmsd[] = {
        { WM_INITDIALOG, ms_vh,    (PFN)msg_OnInitDialog },
        { WM_COMMAND,    ms_bwwwl, (PFN)msg_OnCommand    },
        { WM_NULL,       ms_end,   (PFN)NULL             }
    };

    return Dlg_MsgProc(rgmsd, hDlg, msg, wp, lp);
}

void msg_OnInitDialog(HWND hDlg)
{
    UINT nDays;

    CEmptyControlVolumeCache::GetDaysBeforeExpire(&nDays);
    SetDlgItemInt(hDlg, IDC_EDIT_EXPIRE, nDays, FALSE);
}

BOOL msg_OnCommand(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    static CMD rgcmd[] = {
        { IDOK, 0, ms_bh,  (PFN)cmd_OnOK },
        { 0,    0, ms_end, (PFN)NULL     }
    };

    return Msg_OnCmd(rgcmd, hDlg, msg, wp, lp);
}

BOOL cmd_OnOK(HWND hDlg)
{
    UINT nDays;
    BOOL fWorked;

    nDays = GetDlgItemInt(hDlg, IDC_EDIT_EXPIRE, &fWorked, FALSE);
    if (!fWorked) {
        MessageBeep(-1);
        SetFocus(GetDlgItem(hDlg, IDC_EDIT_EXPIRE));
        return FALSE;
    }

    CEmptyControlVolumeCache::SetDaysBeforeExpire(nDays);
    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\enum.cpp ===
#include "enum.h"

BOOL GetVersion(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf);
BOOL GetTimeInfo(
               BOOL bCreation, LPCONTROLPIDL pcpidl, 
               FILETIME* lpTime, LPTSTR lpszBuf, BOOL bShowTime);

// Also defined in nt\private\inet\urlmon\isctrl.cxx
const TCHAR *g_pszLastCheckDateKey = "LastCheckDate";
const TCHAR *g_pszUpdateInfo = "UpdateInfo";

#if defined(ALIGNMENT_MACHINE)
BOOL
__inline
static
uaGetControlInfo(
    IN     HANDLE hControlHandle,
    IN     UINT nFlag,
    IN OUT DWORD UNALIGNED *lpdwuData,
    IN OUT LPTSTR lpszBuf,
    IN     int nBufLen
    )
{
    DWORD dwData;
    LPDWORD lpdwData;
    BOOL result;

    if (lpdwuData != NULL) {
        dwData = *lpdwuData;
	lpdwData = &dwData;
    } else {
        lpdwData = NULL;
    }

    result = GetControlInfo( hControlHandle,
                             nFlag,
			     lpdwData,
			     lpszBuf,
			     nBufLen );

    if (lpdwuData != NULL) {
        *lpdwuData = dwData;
    }

    return result;
}

BOOL
__inline
static
uaGetTimeInfo(
    IN     BOOL bCreation,
    IN OUT LPCONTROLPIDL pcpidl,
    IN OUT FILETIME UNALIGNED *lpuTime,
    IN OUT LPTSTR lpszBuf,
    IN     BOOL bShowTime
    )
{
    FILETIME time;
    LPFILETIME lpTime;
    BOOL result;

    if (lpuTime != NULL) {
        time = *lpuTime;
	lpTime = &time;
    } else {
        lpTime = NULL;
    }

    result = GetTimeInfo( bCreation,
                          pcpidl,
			  lpTime,
			  lpszBuf,
			  bShowTime );

    if (lpuTime != NULL) {
        *lpuTime = time;
    }

    return result;
}

#else
#define uaGetControlInfo GetControlInfo
#define uaGetTimeInfo    GetTimeInfo
#endif

    
    

///////////////////////////////////////////////////////////////////////////////
// IEnumIDList methods

CControlFolderEnum::CControlFolderEnum(STRRET &str, LPCITEMIDLIST pidl, UINT shcontf) :
    m_shcontf(shcontf)
{
    DebugMsg(DM_TRACE, TEXT("cfe - CControlFolderEnum() called"));
    m_cRef = 1;
    DllAddRef();

    m_bEnumStarted = FALSE;
    m_hEnumControl = NULL;

    StrRetToBuf(&str, pidl, m_szCachePath, MAX_PATH);

    SHGetMalloc(&m_pMalloc);          // won't fail
}

CControlFolderEnum::~CControlFolderEnum()
{
    Assert(m_cRef == 0);         // we should always have a zero ref count here
    DebugMsg(DM_TRACE, TEXT("cfe - ~CControlFolderEnum() called."));
    DllRelease();
}

HRESULT CControlFolderEnum_CreateInstance(
                                      LPITEMIDLIST pidl, 
                                      UINT shcontf,
                                      LPENUMIDLIST *ppeidl)

{
    DebugMsg(DM_TRACE,("cfe - CreateInstance() called."));

    if (pidl == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr;
    LPSHELLFOLDER pshf = NULL;
    if (FAILED(hr = SHGetDesktopFolder(&pshf)))
        return hr;

    STRRET name;
    hr = pshf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &name);
    if (FAILED(hr))
        return hr;

    *ppeidl = NULL;                 // null the out param

    CControlFolderEnum *pCFE = new CControlFolderEnum(name, pidl, shcontf);
    if (!pCFE)
        return E_OUTOFMEMORY;
    
    *ppeidl = pCFE;

    return S_OK;
}

BOOL GetVersion(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf)
{
    Assert(pcpidl != NULL);
    LPCTSTR pszLocation = GetStringInfo(pcpidl, SI_LOCATION);

    DWORD dwBufLen;
    DWORD dwHandle;
    BOOL fResult = FALSE;
    UINT uLen;
    VS_FIXEDFILEINFO *pVersionInfo = NULL;

    // Quick copy to handle failure cases
    lstrcpy(lpszBuf, g_szUnknownData);

    if ((dwBufLen = ::GetFileVersionInfoSize(
                                    (LPTSTR)pszLocation, 
                                    &dwHandle)) == 0)
    return FALSE;

    BYTE *pbData = new BYTE[dwBufLen];
    if (pbData == NULL)
        return FALSE;

    if (GetFileVersionInfo((LPTSTR)pszLocation, dwHandle, dwBufLen, pbData))
    {
        fResult = VerQueryValue(pbData, "\\", (LPVOID*)&pVersionInfo, &uLen);
        
        if (fResult)
        {
            wsprintf(lpszBuf, "%d,%d,%d,%d",
                    (pVersionInfo->dwFileVersionMS & 0xffff0000)>>16,
                    (pVersionInfo->dwFileVersionMS & 0xffff),
                    (pVersionInfo->dwFileVersionLS & 0xffff0000)>>16,
                    (pVersionInfo->dwFileVersionLS & 0xffff));
        }

    }

    delete [] pbData;

    return fResult;
}

BOOL GetTimeInfo(
             BOOL bCreation, 
             LPCONTROLPIDL pcpidl, 
             FILETIME* lpTime,
             LPTSTR lpszBuf,
             BOOL bShowTime)
{
    Assert(pcpidl != NULL);
        Assert (lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    LPCTSTR pszLocation = GetStringInfo(pcpidl, SI_LOCATION);

    BOOL fResult = TRUE;
    HANDLE hFile = NULL;
        WIN32_FIND_DATA findFileData;
        TCHAR szTime[TIMESTAMP_MAXSIZE];
    TCHAR szDate[TIMESTAMP_MAXSIZE];
        SYSTEMTIME sysTime;
        FILETIME localTime;

        hFile = FindFirstFile(pszLocation, &findFileData);

    if (hFile != INVALID_HANDLE_VALUE)
    {
                // Get the creation time and date information.
        if (bCreation)
        {
            *lpTime = findFileData.ftCreationTime;
                    FileTimeToLocalFileTime(&findFileData.ftCreationTime, &localTime);
        }
        else
        {
            *lpTime = findFileData.ftLastAccessTime;
                    FileTimeToLocalFileTime(&findFileData.ftLastAccessTime, &localTime);
        }

        FileTimeToSystemTime(&localTime, &sysTime);

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &sysTime,
            NULL,
            szDate,
            TIMESTAMP_MAXSIZE);

        lstrcpy(lpszBuf, szDate);

        if (bShowTime)
        {
            GetTimeFormat(
                LOCALE_SYSTEM_DEFAULT,
                TIME_NOSECONDS,
                &sysTime,
                NULL,
                szTime,
                TIMESTAMP_MAXSIZE
                );

            lstrcat(lpszBuf, TEXT(" "));
            lstrcat(lpszBuf, szTime);
        }

            FindClose(hFile);
    }
    else
    {
        fResult = FALSE;
        lstrcpy(lpszBuf, g_szUnknownData);
        lpTime->dwLowDateTime = lpTime->dwHighDateTime = 0;
    }

        return fResult;
}

LPCONTROLPIDL CreateControlPidl(IMalloc *pmalloc, HANDLE hControl)
{
    Assert(pmalloc != NULL);

    DWORD dw;
    GetControlInfo(hControl, GCI_TOTALFILES, &dw, NULL, 0);
    ULONG ulSize = sizeof(CONTROLPIDL) + sizeof(USHORT);
    ulSize += (dw - 1) * sizeof(DEPENDENTFILEINFO);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)pmalloc->Alloc(ulSize);

    if (pcpidl)
    {
        memset(pcpidl, 0, ulSize);
        pcpidl->cb = (USHORT)(ulSize - sizeof(USHORT));

        pcpidl->ci.cTotalFiles = (UINT)dw;
        uaGetControlInfo(hControl, GCI_TOTALSIZE, &(pcpidl->ci.dwTotalFileSize), NULL, 0);
        uaGetControlInfo(hControl, GCI_SIZESAVED, &(pcpidl->ci.dwTotalSizeSaved), NULL, 0);
        GetControlInfo(hControl, GCI_NAME, NULL, pcpidl->ci.szName, CONTROLNAME_MAXSIZE);
        GetControlInfo(hControl, GCI_FILE, NULL, pcpidl->ci.szFile, MAX_PATH);
        GetControlInfo(hControl, GCI_CLSID, NULL, pcpidl->ci.szCLSID, MAX_CLSID_LEN);
        GetControlInfo(hControl, GCI_TYPELIBID, NULL, pcpidl->ci.szTypeLibID, MAX_CLSID_LEN);
        uaGetTimeInfo(TRUE, pcpidl, &(pcpidl->ci.timeCreation), pcpidl->ci.szCreation, TRUE);
        uaGetTimeInfo(FALSE, pcpidl, &(pcpidl->ci.timeLastAccessed), pcpidl->ci.szLastAccess, FALSE);

        GetControlInfo(hControl, GCI_CODEBASE, NULL, pcpidl->ci.szCodeBase, INTERNET_MAX_URL_LENGTH);
        uaGetControlInfo(hControl, GCI_ISDISTUNIT, &(pcpidl->ci.dwIsDistUnit), NULL, 0);
        uaGetControlInfo(hControl, GCI_STATUS, &(pcpidl->ci.dwStatus), NULL, 0);
        uaGetControlInfo(hControl, GCI_HAS_ACTIVEX, &(pcpidl->ci.dwHasActiveX), NULL, 0);
        uaGetControlInfo(hControl, GCI_HAS_JAVA, &(pcpidl->ci.dwHasJava), NULL, 0);
        if (pcpidl->ci.dwIsDistUnit)
        {
            GetControlInfo(hControl, GCI_DIST_UNIT_VERSION, NULL, pcpidl->ci.szVersion, VERSION_MAXSIZE);
        }
        else
        {
            GetVersion(pcpidl, pcpidl->ci.szVersion);
        }

        LONG lResult = ERROR_SUCCESS;
        DEPENDENTFILEINFO UNALIGNED *pInfo = &(pcpidl->ci.dependentFile);
        dw = GetTotalNumOfFiles(pcpidl);
        for (UINT iFile = 0; iFile < (UINT)dw; iFile++)
        {
    	    DWORD alignedSize = pInfo->dwSize;
            lResult = GetControlDependentFile(
                                       iFile,
                                       hControl,
                                       pInfo->szFile,
                                       &alignedSize,
                                       TRUE);
            pInfo->dwSize = alignedSize;
            if (lResult != ERROR_SUCCESS)
                break;
            pInfo = (LPDEPENDENTFILEINFO)(pInfo + 1);
        }
    }

    return pcpidl;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CControlFolderEnum::QueryInterface(REFIID iid,void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cfe - QueryInterface called."));
    
    if ((iid == IID_IEnumIDList) || (iid == IID_IUnknown))
    {
        *ppv = (void *)this;
        AddRef();
        return S_OK;
    }
    
    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CControlFolderEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG CControlFolderEnum::Release(void)
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CControlFolderEnum::Next(
                             ULONG celt, 
                             LPITEMIDLIST *rgelt, 
                             ULONG *pceltFetched)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Next() called."));

    // If asking for stuff we don't have, say we don't have any
    if (!(m_shcontf & SHCONTF_NONFOLDERS))
        return S_FALSE;

    LONG lres = ERROR_SUCCESS;
    HANDLE hControl = NULL;
    LPCONTROLPIDL pcpidl = NULL;

    lres = (!m_bEnumStarted ? 
                  FindFirstControl(m_hEnumControl, hControl, m_szCachePath) :
                  FindNextControl(m_hEnumControl, hControl));

    if (pceltFetched)
        *pceltFetched = (lres == ERROR_SUCCESS ? 1 : 0);

    if (lres != ERROR_SUCCESS)
        goto EXIT_NEXT;

    pcpidl = CreateControlPidl(m_pMalloc, hControl);
    if (pcpidl == NULL)
    {
        lres = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT_NEXT;
    }

    m_bEnumStarted = TRUE;
    rgelt[0] = (LPITEMIDLIST)pcpidl;

EXIT_NEXT:

    ReleaseControlHandle(hControl);

    if (lres != ERROR_SUCCESS)
    {
        if (pcpidl != NULL)
        {
            m_pMalloc->Free(pcpidl);
            pcpidl = NULL;
        }
        FindControlClose(m_hEnumControl);
        m_bEnumStarted = FALSE;
        rgelt[0] = NULL;
    }

    return HRESULT_FROM_WIN32(lres);
}

HRESULT CControlFolderEnum::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Skip() called."));
    return E_NOTIMPL;
}

HRESULT CControlFolderEnum::Reset()
{
    DebugMsg(DM_TRACE, TEXT("cfe - Reset() called."));
    return E_NOTIMPL;
}

HRESULT CControlFolderEnum::Clone(IEnumIDList **ppenum)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Clone() called."));
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\emptyvol.h ===
#ifndef __EMPTY_VOLUME_CACHE__
#define __EMPTY_VOLUME_CACHE__

#include "utils.h"

// Define node storing a path read from the registry in a singly-linked list.
typedef struct _TAG_CACHE_PATH_NODE CACHE_PATH_NODE;
typedef CACHE_PATH_NODE* LPCACHE_PATH_NODE;
struct _TAG_CACHE_PATH_NODE
{
    TCHAR szCachePath[MAX_PATH];

    LPCACHE_PATH_NODE pNext;
};

// Define node storing control handles in a singly-linked list.
typedef struct _TAG_CONTROL_HANDLE_NODE CONTROL_HANDLE_NODE;
typedef CONTROL_HANDLE_NODE* LPCONTROL_HANDLE_NODE;
struct _TAG_CONTROL_HANDLE_NODE
{
    HANDLE hControl;

    LPCONTROL_HANDLE_NODE pNext;
};

// Define node storing heads and tails of control handle lists in a 
// singly-linked list.
// There is a control handle list for each volume.
typedef struct _TAG_CONTROL_HANDLE_HEADER CONTROL_HANDLE_HEADER;
typedef CONTROL_HANDLE_HEADER* LPCONTROL_HANDLE_HEADER;
struct _TAG_CONTROL_HANDLE_HEADER
{
    DWORD dwSpaceUsed;
    int   nDriveNum;

    LPCONTROL_HANDLE_NODE pHandlesHead;
    LPCONTROL_HANDLE_NODE pHandlesTail;

    LPCONTROL_HANDLE_HEADER pNext;
};

// Handles to activeX controls are cached in memory during calls to
// GetSpaceUsed so that re-enumeration is not needed for subsequent
// calls to Purge.
//
// The structure for storing control handles for various volumes is:
//
//                                m_pControlsTail -+
//                                                 |
//                                                \|/
//   m_pControlsHead --> Header01 --> Header02 --> Header03 --> NULL
//                       |            |            |
//                       +- C:        +- D:        +- E:
//                       |            |            |
//                       +- Head01    +- Head02    +- Head03
//                       |            |            |
//                       +- Tail01    +- Tail02    +- Tail03
//
// where 
//      HeaderXX is of type CONTROL_HANDLE_HEADER, and
//      HeadXX and TailXX are of type LPCONTROL_HANDLE_NODE.
//
// HeadXX and TailXX are respectively head and tail pointers to a list
// of handles.  Those are handles to controls installed on the drive
// specified in HeaderXX.
//


#endif // __EMPTY_VOLUME_CACHE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\enum.h ===
#ifndef __CONTROL_ENUM__
#define __CONTROL_ENUM__

#include "general.h"

class CControlFolderEnum : public IEnumIDList
{
public:
    CControlFolderEnum(STRRET &str, LPCITEMIDLIST pidl, UINT shcontf);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods 
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum);

protected:
    ~CControlFolderEnum();

    UINT                m_cRef;      // ref count
    UINT                m_shcontf;   // enumeration flags
    LPMALLOC            m_pMalloc;
    HANDLE              m_hEnumControl;
    BOOL                m_bEnumStarted;
    TCHAR               m_szCachePath[MAX_PATH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\filenode.cpp ===
// Implementation of class CFileNode
//
// During parsing an inf file, information about each file
// is stored in an instance of this class.  Such information
// includes the name of the file, its section in the inf file,
// its location (directory), etc.

#include "filenode.h"

CPNode::CPNode(LPCTSTR szName)
{
    Assert (szName != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    m_pNext = NULL;
    m_bRemovable = FALSE;
}

CPNode::~CPNode()
{
    if (m_pNext != NULL)
        delete m_pNext;
}

// insert a new file node into list
//HRESULT CFileNode::Insert(LPCTSTR szName, LPCTSTR szSection)
HRESULT CPNode::Insert(CPNode* pNewNode)
{
    if (pNewNode == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    m_pNext = pNewNode;
    return S_OK;
}

// get the file node placed right after this one in list
CPNode* CPNode::GetNext() const
{
    return m_pNext;
}

// tell the path in which this file is located
HRESULT CPNode::SetStr(LPTSTR lpszMember, LPCTSTR lpszNew )
{
    Assert (lpszNew != NULL);
    if (lpszNew == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    lstrcpyn(lpszMember, lpszNew, MAX_PATH); // all our string members are MAX_PATH
    return S_OK;
}

// retrieve the name of the file represented by this node
LPCTSTR CPNode::GetName() const
{
    return m_szName;
}


// retrieve the path of the file represented by this node
LPCTSTR CPNode::GetPath() const
{
    return (m_szPath[0] == '\0' ? NULL : m_szPath);
}

// constructor
CPackageNode::CPackageNode(LPCTSTR szName, LPCTSTR szNamespace, LPCTSTR szPath) : CPNode(szName)
{
    Assert (szNamespace != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    lstrcpyn(m_szNamespace, szNamespace, MAX_PATH);
    if (szPath != NULL)
    {
        lstrcpyn(m_szPath, szPath, MAX_PATH);
    }
    else
    {
        m_szPath[0] = '\0';
    }
    m_pNext = NULL;
    m_fIsSystemClass = FALSE;
}

// destructor
CPackageNode::~CPackageNode()
{
}

// retrieve the name of the section in the inf file which
// which the file represented by this node was installed
LPCTSTR CPackageNode::GetNamespace() const
{
    return m_szNamespace;
}

// constructor
CFileNode::CFileNode(LPCTSTR szName, LPCTSTR szSection, LPCTSTR szPath) : CPNode(szName)
{
    Assert (szSection != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    lstrcpyn(m_szSection, szSection, MAX_PATH);
    if (szPath != NULL)
    {
        lstrcpyn(m_szPath, szPath, MAX_PATH);
    }
    else
    {
        m_szPath[0] = '\0';
    }
    m_pNext = NULL;
}

// destructor
CFileNode::~CFileNode()
{
}



// retrieve the name of the section in the inf file which
// which the file represented by this node was installed
LPCTSTR CFileNode::GetSection() const
{
    return m_szSection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\folder.cpp ===
#include "general.h"
#include "folder.h"
#include "utils.h"

#include <mluisupp.h>

#define CPP_FUNCTIONS
#include <crtfree.h>

// string displayed to represent missing data
TCHAR g_szUnknownData[64];

int CompareVersion(LPCTSTR lpszVersion1, LPCTSTR lpszVersion2);

///////////////////////////////////////////////////////////////////////////////
// IShellFolder methods

CControlFolder::CControlFolder()
{
    DebugMsg(DM_TRACE,TEXT("cf - CControlFolder() called."));
    m_cRef = 1;
    DllAddRef();

    // initialize g_szUnknownData, a string used to represent missing data
    if (g_szUnknownData[0] == 0)
        MLLoadString(IDS_UNKNOWNDATA, g_szUnknownData, ARRAYSIZE(g_szUnknownData));
}       

CControlFolder::~CControlFolder()
{
    Assert(m_cRef == 0);                 // should always have zero
    DebugMsg(DM_TRACE, TEXT("cf - ~CControlFolder() called."));

    if (m_pidl)
        ILFree(m_pidl);

    DllRelease();
}    

STDAPI ControlFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CControlFolder *pCFolder = new CControlFolder;
    if (!pCFolder)
        return E_OUTOFMEMORY;

    HRESULT hr = pCFolder->QueryInterface(riid, ppvOut);
    pCFolder->Release();

    return hr;
}

HRESULT CControlFolder::QueryInterface(REFIID iid, void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cf - QueryInterface() called."));
    
    if ((iid == IID_IUnknown) || (iid == IID_IShellFolder))
    {
        *ppv = (void *)(IShellFolder*)this;
    }
    else if ((iid == IID_IPersistFolder) || (iid == IID_IPersist)) 
    {
        *ppv = (void *)(IPersistFolder*)this;
    }
    else if (iid == IID_IPersistFolder2)
    {
        *ppv = (void *)(IPersistFolder2*)this;
    }
    else if (iid == IID_IContextMenu)
    {
        *ppv = (void *)(IContextMenu*)this;
    }
    else if (iid == IID_IShellView)
    {
        // this is a total hack... return our view object from this folder
        //
        // the desktop.ini file for "Temporary Internet Files" has UICLSID={guid of this object}
        // this lets us implment only ths IShellView for this folder, leaving the IShellFolder
        // to the default file system. this enables operations on the pidls that are stored in
        // this folder that would otherwise faile since our IShellFolder is not as complete
        // as the default (this is the same thing the font folder does).
        //
        // to support this with defview we would either have to do a complete wrapper object
        // for the view implemenation, or add this hack that hands out the view object, this
        // assumes we know the order of calls that the shell makes to create this object
        // and get the IShellView implementation
        // 
        return ControlFolderView_CreateInstance(this, m_pidl, ppv);
    }
    else
    {
        *ppv = NULL;     // null the out param
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CControlFolder::AddRef()
{
    return ++m_cRef;
}

ULONG CControlFolder::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

HRESULT CControlFolder::ParseDisplayName(
                                    HWND hwndOwner, 
                                    LPBC pbcReserved,
                                    LPOLESTR lpszDisplayName, 
                                    ULONG *pchEaten,
                                    LPITEMIDLIST *ppidl, 
                                    ULONG *pdwAttributes)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - ParseDisplayName() called."));
    *ppidl = NULL;              // null the out param
    return E_FAIL;
}

HRESULT CControlFolder::EnumObjects(
                               HWND hwndOwner, 
                               DWORD grfFlags,
                               LPENUMIDLIST *ppenumIDList)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - EnumObjects() called."));

    // Cannot filter on grfFlags yet - Corel Gallery expects to receive
    // an empty enumerator.

    return CControlFolderEnum_CreateInstance(m_pidl, grfFlags, ppenumIDList);
}

HRESULT CControlFolder::BindToObject(
                                LPCITEMIDLIST pidl, 
                                LPBC pbcReserved,
                                REFIID riid, 
                                void **ppvOut)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - BindToObject() called."));
    *ppvOut = NULL;         // null the out param
    return E_FAIL;
}

HRESULT CControlFolder::BindToStorage(
                                   LPCITEMIDLIST pidl, 
                                   LPBC pbcReserved,
                                   REFIID riid, 
                                   void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - BindToStorage() called."));
    *ppv = NULL;         // null the out param
    return E_NOTIMPL;
}

HRESULT CControlFolder::CompareIDs(
                              LPARAM lParam, 
                              LPCITEMIDLIST pidl1, 
                              LPCITEMIDLIST pidl2)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - CompareIDs() called."));

    int iRet;
    LPCONTROLPIDL pcpidl1 = (LPCONTROLPIDL)pidl1;
    LPCONTROLPIDL pcpidl2 = (LPCONTROLPIDL)pidl2;
    LPCSTR lpszStr[2] = {NULL, NULL};

    if (pcpidl1 == NULL || pcpidl2 == NULL)
        return E_INVALIDARG;
        
    switch (lParam) {
    case SI_CONTROL:
        iRet = lstrcmpi(
                 GetStringInfo(pcpidl1, SI_CONTROL),      
                 GetStringInfo(pcpidl2, SI_CONTROL));
        break;

    case SI_VERSION:
        lpszStr[0] = GetStringInfo(pcpidl1, SI_VERSION);
        lpszStr[1] = GetStringInfo(pcpidl2, SI_VERSION);
        if (lstrcmp(lpszStr[0], g_szUnknownData) == 0)
                        iRet = -1;
                else if (lstrcmp(lpszStr[1], g_szUnknownData) == 0)
                        iRet = 1;
        else
            iRet = CompareVersion(lpszStr[0], lpszStr[1]);
        break;

    case SI_CREATION:
    case SI_LASTACCESS:
        {
            FILETIME time[2];
            GetTimeInfo(pcpidl1, (int)lParam, &(time[0]));
            GetTimeInfo(pcpidl2, (int)lParam, &(time[1]));
            iRet = CompareFileTime(&(time[0]), &(time[1]));
        }
        break;

    case SI_STATUS:
        iRet = GetStatus(pcpidl1) - GetStatus(pcpidl2);
        break;
            
    case SI_TOTALSIZE:
        {
            DWORD dwSize1 = GetSizeSaved((LPCONTROLPIDL)pidl1); 
            DWORD dwSize2 = GetSizeSaved((LPCONTROLPIDL)pidl2);
            iRet = (dwSize1 == dwSize2 ? 0 : (dwSize1 > dwSize2 ? 1 : -1));
        }
        break;

    default:
        iRet = -1;
    }

    return ResultFromShort((SHORT)iRet);
}

HRESULT CControlFolder::CreateViewObject(
                                    HWND hwndOwner, 
                                    REFIID riid, 
                                    void **ppvOut)
{
    HRESULT hres;

    DebugMsg(DM_TRACE, TEXT("cf - sf - CreateViewObject() called."));

    if (riid == IID_IShellView)
    {
        hres = ControlFolderView_CreateInstance(this, m_pidl, ppvOut);
    }
    else if (riid == IID_IContextMenu)
    {
        hres = ControlFolder_CreateInstance(NULL, riid, ppvOut);
    }
    else
    {
        *ppvOut = NULL;         // null the out param
        hres = E_NOINTERFACE;
    }
    
    return hres;    
}

HRESULT CControlFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    // Should we initialize this for each item in here?  In other words,
    // if cidl > 1, then we should initialize each entry in the prgInOut array

    Assert(cidl == 1);
    
    *prgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET | SFGAO_CANMOVE | SFGAO_CANDELETE;
    return NOERROR;
}

HRESULT CControlFolder::GetUIObjectOf(
                                 HWND hwndOwner, 
                                 UINT cidl, 
                                 LPCITEMIDLIST *apidl,
                                 REFIID riid, 
                                 UINT *prgfInOut, 
                                 void **ppvOut)
{
    HRESULT hres;

    if ((riid == IID_IDataObject) || 
        (riid == IID_IExtractIcon) || 
        (riid == IID_IContextMenu))
    {
       hres = CControlItem_CreateInstance(this, cidl, apidl, riid, ppvOut);
    }
    else
    {
        *ppvOut = NULL;         // null the out param
        hres = E_FAIL;
    }
    return hres;    
}

HRESULT CControlFolder::GetDisplayNameOf(
                                    LPCITEMIDLIST pidl, 
                                    DWORD uFlags, 
                                    LPSTRRET lpName)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - GetDisplayNameOf() called."));

    if (pidl)
    {
        lpName->uType = STRRET_CSTR;

        // for the history, we'll use the title if we have one, otherwise we'll use
        // the url filename.
        if (uFlags & SHGDN_FORPARSING)
            lstrcpyn(
                 lpName->cStr, 
                 GetStringInfo((LPCONTROLPIDL)pidl, SI_LOCATION), 
                 ARRAYSIZE(lpName->cStr));
        else
            lstrcpyn(
                 lpName->cStr, 
                 GetStringInfo((LPCONTROLPIDL)pidl, SI_CONTROL), 
                 ARRAYSIZE(lpName->cStr));

        return NOERROR;    
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CControlFolder::SetNameOf(
                             HWND hwndOwner, 
                             LPCITEMIDLIST pidl,
                             LPCOLESTR lpszName, 
                             DWORD uFlags, 
                             LPITEMIDLIST *ppidlOut)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - SetNameOf() called."));
    
    *ppidlOut = NULL;               // null the out param
    return E_FAIL;    
}

///////////////////////////////////////////////////////////////////////////////
// Helper functions

int CompareVersion(LPCTSTR lpszVersion1, LPCTSTR lpszVersion2)
{
    LPCTSTR pszVerNum[2] = {lpszVersion1, lpszVersion2};
        int nVerNum[2];
        int nResult = 0;

        while (nResult == 0 && *(pszVerNum[0]) != '\0' && *(pszVerNum[1]) != '\0')
        {
                nVerNum[0] = StrToInt(pszVerNum[0]++);
                nVerNum[1] = StrToInt(pszVerNum[1]++);
                nResult = ((nVerNum[0] < nVerNum[1]) ? 
                                        (-1) :
                                    (nVerNum[0] > nVerNum[1] ? 1 : 0));
        }

        return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\filenode.h ===
///////////////////////////////////////////////////////////////////////////////
// Declaration of class CFileNode

#ifndef __FILE_NODE__
#define __FILE_NODE__

#include "utils.h"

class CPNode
{
// Construction and Destruction
public:
    CPNode(LPCTSTR szName );
    virtual ~CPNode();
// Data members
protected:
    TCHAR   m_szName[MAX_PATH];
    TCHAR   m_szPath[MAX_PATH];
    BOOL    m_bRemovable;
    CPNode  *m_pNext;
// Operations
public:
    HRESULT Insert(CPNode* pNewNode);
    CPNode* GetNext() const;
    HRESULT SetStr( LPTSTR lpszMember, LPCTSTR lpszNew);
    HRESULT SetName(LPCTSTR lpszName) { return SetStr( m_szName, lpszName ); };
    LPCTSTR GetName() const;
    HRESULT SetPath(LPCTSTR lpszPath)  { return SetStr( m_szPath, lpszPath ); };
    LPCTSTR GetPath() const;
    void SetRemovable( BOOL bRemovable ) { m_bRemovable = bRemovable; };
    BOOL GetRemovable(void) { return m_bRemovable; };
};

class CPackageNode : public CPNode
{
// Construction and Destruction
public:
    CPackageNode(LPCTSTR szName, LPCTSTR szNamespace = NULL, LPCTSTR szPath = NULL);
    virtual ~CPackageNode();
// Data members
protected:
    TCHAR m_szNamespace[MAX_PATH];
    BOOL  m_fIsSystemClass;
// Operations
public:
    CPackageNode* GetNextPackageNode() const { return (CPackageNode *)m_pNext; };
    HRESULT SetNamespace(LPCTSTR lpszNamespace)  { return SetStr( m_szNamespace, lpszNamespace ); };
    LPCTSTR GetNamespace() const;
    HRESULT SetIsSystemClass(BOOL fIsSystemClass) { m_fIsSystemClass = fIsSystemClass; return S_OK; };
    BOOL GetIsSystemClass() { return m_fIsSystemClass; };
};

class CFileNode : public CPNode
{
// Construction and Destruction
public:
    CFileNode(LPCTSTR szName, LPCTSTR szSection, LPCTSTR szPath = NULL);
    virtual ~CFileNode();
// Data members
protected:
    TCHAR m_szSection[MAX_PATH];
// Operations
public:
    CFileNode* GetNextFileNode() const { return (CFileNode *)m_pNext; };
    HRESULT SetSection(LPCTSTR lpszSection)  { return SetStr( m_szSection, lpszSection ); };
    LPCTSTR GetSection() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\folder.h ===
#ifndef __CONTROL_FOLDER__
#define __CONTROL_FOLDER__

#include "general.h"

// forward declaration
class CControlFolder;
class CControlItem;

HRESULT CControlFolderEnum_CreateInstance(
                                      LPITEMIDLIST pidl,
                                      UINT shcontf,
                                      LPENUMIDLIST *ppeidl);

HRESULT CControlItem_CreateInstance(
                               CControlFolder *pCFolder,
                               UINT cidl, 
                               LPCITEMIDLIST *ppidl, 
                               REFIID riid, 
                               void **ppvOut);

HRESULT ControlFolderView_Command(HWND hwnd, UINT uID);

UINT MergeMenuHierarchy(
                    HMENU hmenuDst, 
                    HMENU hmenuSrc, 
                    UINT idcMin, 
                    UINT idcMax);

///////////////////////////////////////////////////////////////////////////////
// CControlFolder declaration

class CControlFolder : public IShellFolder, 
                       public IPersistFolder2,
                       public IContextMenu
{
    // CControlFolder interfaces
    friend CControlItem;
    friend HRESULT ControlFolderView_CreateInstance(CControlFolder *pHCFolder, LPCITEMIDLIST pidl, void **ppvOut);
    friend HRESULT ControlFolderView_DidDragDrop(
                                            HWND hwnd, 
                                            IDataObject *pdo, 
                                            DWORD dwEffect);
        
public:
    CControlFolder();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(
                             HWND hwndOwner, 
                             LPBC pbcReserved,
			                 LPOLESTR lpszDisplayName, 
                             ULONG *pchEaten,
			                 LPITEMIDLIST *ppidl, 
                             ULONG *pdwAttributes);

    STDMETHODIMP EnumObjects(
                        HWND hwndOwner, 
                        DWORD grfFlags,
			            LPENUMIDLIST *ppenumIDList);

    STDMETHODIMP BindToObject(
                          LPCITEMIDLIST pidl, 
                          LPBC pbcReserved,
			              REFIID riid, 
                          void **ppvOut);

    STDMETHODIMP BindToStorage(
                          LPCITEMIDLIST pidl, 
                          LPBC pbcReserved,
			              REFIID riid, 
                          void **ppvObj);

    STDMETHODIMP CompareIDs(
                        LPARAM lParam, 
                        LPCITEMIDLIST pidl1, 
                        LPCITEMIDLIST pidl2);

    STDMETHODIMP CreateViewObject(
                             HWND hwndOwner, 
                             REFIID riid, 
                             void **ppvOut);

    STDMETHODIMP GetAttributesOf(
                            UINT cidl, 
                            LPCITEMIDLIST *apidl,
			                ULONG *rgfInOut);

    STDMETHODIMP GetUIObjectOf(
                          HWND hwndOwner, 
                          UINT cidl, 
                          LPCITEMIDLIST *apidl,
			              REFIID riid, 
                          UINT *prgfInOut, 
                          void **ppvOut);

    STDMETHODIMP GetDisplayNameOf(
                          LPCITEMIDLIST pidl, 
                          DWORD uFlags, 
                          LPSTRRET lpName);

    STDMETHODIMP SetNameOf(
                      HWND hwndOwner, 
                      LPCITEMIDLIST pidl,
			          LPCOLESTR lpszName, 
                      DWORD uFlags, 
                      LPITEMIDLIST *ppidlOut);

    // IShellIcon Methods 
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist Methods 
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder Methods
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IContextMenu Methods -- This handles the background context menus
    STDMETHODIMP QueryContextMenu(
                              HMENU hmenu, 
                              UINT indexMenu, 
                              UINT idCmdFirst,
                              UINT idCmdLast, 
                              UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(
                              UINT_PTR idCmd, 
                              UINT uType,
                              UINT *pwReserved,
                              LPTSTR pszName, 
                              UINT cchMax);

protected:
    ~CControlFolder();

    UINT            m_cRef;
    LPITEMIDLIST    m_pidl;
    LPMALLOC        m_pMalloc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\general.h ===
#ifndef __GENERAL__
#define __GENERAL__

#include "resource.h"
#include "init.h"
#include <cleanoc.h>
#include <wininet.h>

#define VERSION_MAXSIZE 50
#define TIMESTAMP_MAXSIZE 64
#define MESSAGE_MAXSIZE 200
#define CONTROLNAME_MAXSIZE 200
#define MAX_KILOBYTE_ABBREV_LEN 16

// Needed for FindFirstControl/FindNextControl
#define MAX_CTRL_NAME_SIZE                      2048
#define MAX_DIST_UNIT_NAME_LEN                  MAX_PATH
#define MAX_CLIENT_LEN                          1024
#define MAX_REGENTRY_SIZE                       1024
#define MAX_CLSID_LEN                           40

// conlumn identifiers
#define NUM_COLUMNS 6
enum {
    SI_CONTROL = 0,    // column
    SI_STATUS,         // column
    SI_TOTALSIZE,      // column
    SI_CREATION,       // column
    SI_LASTACCESS,     // column
    SI_VERSION,        // column
    SI_LOCATION,
    SI_CLSID,
    SI_TYPELIBID,
    SI_CODEBASE
};

// control status flags moved to cleanoc.h ( in iedev\inc )

// struct containing info about a control
struct tagDEPENDENTFILEINFO
{
    TCHAR szFile[MAX_PATH];
    DWORD dwSize;
};
typedef tagDEPENDENTFILEINFO DEPENDENTFILEINFO;
typedef DEPENDENTFILEINFO* LPDEPENDENTFILEINFO;

struct tagCACHECTRLINFO
{
    TCHAR             szName[CONTROLNAME_MAXSIZE];
    TCHAR             szFile[MAX_PATH];
    TCHAR             szCLSID[MAX_CLSID_LEN];
    TCHAR             szTypeLibID[MAX_CLSID_LEN];
    TCHAR             szVersion[VERSION_MAXSIZE];
    TCHAR             szLastAccess[TIMESTAMP_MAXSIZE];
    TCHAR             szCreation[TIMESTAMP_MAXSIZE];
    TCHAR             szLastChecked[TIMESTAMP_MAXSIZE];

    TCHAR             szCodeBase[INTERNET_MAX_URL_LENGTH];
    DWORD             dwIsDistUnit;

    DWORD             dwHasActiveX;
    DWORD             dwHasJava;
    
    DWORD             dwTotalFileSize;
    DWORD             dwTotalSizeSaved;
    UINT              cTotalFiles;
    DWORD             dwStatus;
    FILETIME          timeCreation;
    FILETIME          timeLastAccessed;
    DEPENDENTFILEINFO dependentFile;

};
typedef tagCACHECTRLINFO CACHECTRLINFO;
typedef CACHECTRLINFO* LPCACHECTRLINFO;

// PIDL format for this folder...
struct tagCONTROLPIDL
{
    USHORT cb;
    CACHECTRLINFO ci;
};
typedef tagCONTROLPIDL CONTROLPIDL;
typedef UNALIGNED CONTROLPIDL* LPCONTROLPIDL;

// common expiration
#define DEFAULT_DAYS_BEFORE_EXPIRE 60
#define DEFAULT_DAYS_BEFORE_AUTOEXPIRE 15

// misc macros
#define IS_VALID_CONTROLPIDL(pidl)  (TRUE)
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

// helper functions
LPCTSTR GetStringInfo(LPCONTROLPIDL lpcpidl, int nFlag);
BOOL GetTimeInfo(LPCONTROLPIDL lpcpidl, int nFlag, FILETIME* lpTime);
UINT GetTotalNumOfFiles(LPCONTROLPIDL lpcpidl);
DWORD GetSizeSaved(LPCONTROLPIDL lpcpidl);
BOOL GetSizeSaved(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf);
UINT GetStatus(LPCONTROLPIDL pcpidl);
BOOL GetStatus(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf, int nBufSize);
BOOL GetDependentFile(
                  LPCONTROLPIDL lpcpidl, 
                  UINT iFile, 
                  LPTSTR lpszFile, 
                  DWORD *pdwSize);
HICON GetDefaultOCIcon(LPCONTROLPIDL lpcpidl);
void GetContentBools(LPCONTROLPIDL pcpidl, BOOL *pbHasActiveX, BOOL *pbHasJava );
HRESULT GetLastAccessTime(HANDLE hControl, FILETIME *pLastAccess);


HRESULT CreatePropDialog(
                     HWND hwnd, 
                     LPCONTROLPIDL pcpidl); 
void GenerateEvent(
              LONG lEventId, 
              LPITEMIDLIST pidlFolder, 
              LPITEMIDLIST pidlIn, 
              LPITEMIDLIST pidlNewIn);
HCURSOR StartWaitCur();
void EndWaitCur(HCURSOR hCurOld);

void GetDaysBeforeExpireGeneral(ULONG *pnDays);
void GetDaysBeforeExpireAuto(ULONG *pnDays);

HRESULT WINAPI RemoveControlByName2(
                         LPCTSTR lpszFile,
                         LPCTSTR lpszCLSID,
                         LPCTSTR lpszTypeLibID,
                         BOOL bForceRemove, /* = FALSE */
                         DWORD dwIsDistUnit, /* = FALSE */
                         BOOL bSilent);

HRESULT WINAPI RemoveControlByHandle2(
                         HANDLE hControlHandle,
                         BOOL bForceRemove, /* = FALSE */
                         BOOL bSilent);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\general.cpp ===
#include "general.h"
#include "parseinf.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// For retriving data from a CONTROLDATA struct

UINT GetTotalNumOfFiles(LPCONTROLPIDL lpcpidl)
{
    return (lpcpidl != NULL ? lpcpidl->ci.cTotalFiles : 0);
}

DWORD GetSizeSaved(LPCONTROLPIDL lpcpidl)
{
    return (lpcpidl != NULL ? lpcpidl->ci.dwTotalSizeSaved : 0);
}

BOOL GetSizeSaved(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf)
{
    Assert(pcpidl != NULL);
    Assert(lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    DWORD dwTotal = GetSizeSaved(pcpidl);
    if (dwTotal > 0)
    {
        TCHAR szSize[20];
        TCHAR szBuf[MAX_KILOBYTE_ABBREV_LEN + 1];

        dwTotal = (dwTotal < 1024 ? 1024 : dwTotal);
        wsprintf(szSize, "%d", (dwTotal / 1024));

        // insert commas to separate groups of digits
        int nLen = lstrlen(szSize);
        int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
        TCHAR *pCh = szSize + j;
        for (; i < j; i++)
            lpszBuf[i] = szSize[i];
        for (; *pCh != '\0'; i++, pCh++)
        {
            if (((pCh - szSize) % 3 == j) && (i > 0))
                lpszBuf[i++] = ',';
            lpszBuf[i] = *pCh;
        }
        lpszBuf[i] = '\0';

        MLLoadString(IDS_KILOBYTE_ABBREV, szBuf, MAX_KILOBYTE_ABBREV_LEN);
        lstrcat(lpszBuf, szBuf);
    }
    else
    {
        lstrcpy(lpszBuf, g_szUnknownData);
    }

    return TRUE;
}

UINT GetStatus(LPCONTROLPIDL pcpidl)
{
    return (pcpidl != NULL ? pcpidl->ci.dwStatus : STATUS_CTRL_UNKNOWN);
}

BOOL GetStatus(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf, int nBufSize)
{
    Assert(pcpidl != NULL);
    Assert(lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    switch (GetStatus(pcpidl))
    {
    case STATUS_CTRL_UNKNOWN:
        MLLoadString(IDS_STATUS_UNKNOWN, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_INSTALLED:
        MLLoadString(IDS_STATUS_INSTALLED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_SHARED:
        MLLoadString(IDS_STATUS_SHARED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_DAMAGED:
        MLLoadString(IDS_STATUS_DAMAGED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_UNPLUGGED:
        MLLoadString(IDS_STATUS_UNPLUGGED, lpszBuf, nBufSize);
        break;
    default:
        lstrcpy(lpszBuf, g_szUnknownData);
    }

    return TRUE;
}

BOOL GetTimeInfo(LPCONTROLPIDL lpcpidl, int nFlag, FILETIME* lpTime)
{
    Assert(lpcpidl != NULL && lpTime != NULL);

    if (lpcpidl == NULL || lpTime == NULL)
        return FALSE;

    BOOL fResult = TRUE;

    switch (nFlag)
    {
    case SI_CREATION:
        *lpTime = lpcpidl->ci.timeCreation;
        break;

    case SI_LASTACCESS:
        *lpTime = lpcpidl->ci.timeLastAccessed;
        break;

    default:
        lpTime->dwLowDateTime = lpTime->dwLowDateTime = 0;
        fResult = FALSE;
    }

    return fResult;
}

LPCTSTR GetStringInfo(LPCONTROLPIDL lpcpidl, int nFlag)
{
    switch (nFlag)
    {
    case SI_CONTROL:
        return (lpcpidl != NULL ? lpcpidl->ci.szName : NULL);
    case SI_LOCATION:
        return (lpcpidl != NULL ? lpcpidl->ci.szFile : NULL);
    case SI_VERSION:
        return (lpcpidl != NULL ? lpcpidl->ci.szVersion : NULL);
    case SI_CLSID:
        return (lpcpidl != NULL ? lpcpidl->ci.szCLSID : NULL);
    case SI_CREATION:
        return (lpcpidl != NULL ? lpcpidl->ci.szCreation : NULL);
    case SI_LASTACCESS:
        return (lpcpidl != NULL ? lpcpidl->ci.szLastAccess : NULL);
    case SI_TYPELIBID:
        return (lpcpidl != NULL ? lpcpidl->ci.szTypeLibID : NULL);
    case SI_CODEBASE:
        return (lpcpidl != NULL ? lpcpidl->ci.szCodeBase : NULL);

    }

    return NULL;
}

BOOL GetDependentFile(
                  LPCONTROLPIDL lpcpidl, 
                  UINT iFile, 
                  LPTSTR lpszFile, 
                  DWORD *pdwSize)
{
    if (lpszFile == NULL || 
        pdwSize == NULL ||
        iFile >= GetTotalNumOfFiles(lpcpidl))
    {
        return FALSE;
    }

    DEPENDENTFILEINFO UNALIGNED *pInfo = &(lpcpidl->ci.dependentFile);
    lstrcpy(lpszFile, (pInfo + iFile)->szFile);
    *pdwSize = (pInfo + iFile)->dwSize;

    return TRUE;
}

void GetContentBools( LPCONTROLPIDL lpcpidl, BOOL *pbHasActiveX, BOOL *pbHasJava )
{
    if ( lpcpidl != NULL )
    {
        *pbHasActiveX = lpcpidl->ci.dwHasActiveX != 0;
        *pbHasJava = lpcpidl->ci.dwHasJava != 0;
    }
    else
    {
        *pbHasActiveX = *pbHasJava = FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Other helper functions

void GenerateEvent(
              LONG lEventId, 
              LPITEMIDLIST pidlFolder, 
              LPITEMIDLIST pidlIn, 
              LPITEMIDLIST pidlNewIn)
{
    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        SHChangeNotifyHandleEvents();
        ILFree(pidl);
    }
}

HICON GetDefaultOCIcon(LPCONTROLPIDL lpcpidl)
{
    DWORD idIcon = IDI_DEFAULTOCXICON;

    if ( lpcpidl->ci.dwIsDistUnit )
    {
        if ( lpcpidl->ci.dwHasJava )
        {
            if ( lpcpidl->ci.dwHasActiveX )
                idIcon = IDI_DEFAULTMIXEDICON;
            else
                idIcon = IDI_DEFAULTJAVAICON;
        }
    }

    return LoadIcon(g_hInst, MAKEINTRESOURCE(idIcon));
}



HCURSOR StartWaitCur()
{
    HCURSOR hCur = LoadCursor(NULL, IDC_WAIT);
    return (hCur != NULL ? SetCursor(hCur) : NULL);
}

void EndWaitCur(HCURSOR hCurOld)
{
    if (hCurOld != NULL)
        SetCursor(hCurOld);
}


// The place to get the # of days before a control becomes expired.
const LPCTSTR g_lpszKeyExpire = TEXT("SOFTWARE\\Microsoft\\Windows"
    "\\CurrentVersion\\Internet Settings\\ActiveX Cache\\Expire");
const LPCTSTR g_szValueExpire = TEXT("DaysBeforeExpire");
const LPCTSTR g_szValueAutoExpire = TEXT("DaysBeforeAutoExpire");
ULONG g_nDaysGeneral = 0;
ULONG g_nDaysAuto = 0;

void GetDaysBeforeExpire(ULONG *pnDays, BOOL fGeneral)
{
    HKEY  hkey;
    DWORD dwSize  = sizeof(ULONG);
    LONG  lResult;

    ASSERT(pnDays != NULL);

    if ( fGeneral && g_nDaysGeneral )
    {
        *pnDays = g_nDaysGeneral;
        return;
    }
    else if ( !fGeneral && g_nDaysAuto )
    {
        *pnDays = g_nDaysAuto;
        return;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_lpszKeyExpire, 0, KEY_READ,
        &hkey);
    if (lResult == ERROR_SUCCESS) {
        lResult = RegQueryValueEx(hkey, (fGeneral ? g_szValueExpire : g_szValueAutoExpire), NULL, NULL,
            (LPBYTE)pnDays, &dwSize);
        RegCloseKey(hkey);
    }
    if (lResult != ERROR_SUCCESS)
        *pnDays = (fGeneral ? DEFAULT_DAYS_BEFORE_EXPIRE : DEFAULT_DAYS_BEFORE_AUTOEXPIRE);

    if ( fGeneral )
        g_nDaysGeneral = *pnDays;
    else
        g_nDaysAuto = *pnDays;
}

void GetDaysBeforeExpireGeneral(ULONG *pnDays)
{
    GetDaysBeforeExpire(pnDays, TRUE);
}

void GetDaysBeforeExpireAuto(ULONG *pnDays)
{
    GetDaysBeforeExpire(pnDays, FALSE);
}

HRESULT WINAPI RemoveControlByHandle2(
                         HANDLE hControlHandle,
                         BOOL bForceRemove, /* = FALSE */
                         BOOL bSilent)
{
    CCacheItem *pci = (CCacheItem *)hControlHandle;
    CoFreeUnusedLibraries();
    return pci->RemoveFiles( pci->m_szTypeLibID, bForceRemove, pci->ItemType() == CCacheDistUnit::s_dwType, bSilent );
}

HRESULT WINAPI RemoveControlByName2(
                         LPCTSTR lpszFile,
                         LPCTSTR lpszCLSID,
                         LPCTSTR lpszTypeLibID,
                         BOOL bForceRemove, /* = FALSE */
                         DWORD dwIsDistUnit, /* = FALSE */
                         BOOL bSilent)
{
    if (lpszFile == NULL || lpszCLSID == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    CoFreeUnusedLibraries();

    HRESULT hr = S_OK;
    CParseInf parseInf;

    if (!dwIsDistUnit)
    {
        hr = parseInf.DoParse(lpszFile, lpszCLSID);
    }
    else
    {
        hr = parseInf.DoParseDU(lpszFile, lpszCLSID);
    }
    if (SUCCEEDED(hr))
    {
        hr = parseInf.RemoveFiles(lpszTypeLibID, bForceRemove, dwIsDistUnit, bSilent);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\global.h ===
// New default name for ActiveX cache folder!
#define REG_OCX_CACHE_DIR  TEXT("Downloaded Program Files")
#define REG_OCX_OLD_CACHE_DIR  TEXT("Occache")
#define REG_OCX_CACHE_VALUE_NAME TEXT("ActiveXCache")
#define REG_OCX_CACHE_SUBKEY TEXT("ActiveX Cache")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\item.cpp ===
#include <urlmon.h>
#include "item.h"
#include <webcheck.h>
#include "utils.h"
#include "parseinf.h"

#include <mluisupp.h>

extern "C" HRESULT GetControlFolderPath(LPTSTR lpszDir, ULONG ulSizeBuf);
typedef HRESULT (STDAPICALLTYPE *PFNASYNCINSTALLDU)(LPCWSTR,LPCWSTR, LPCWSTR, DWORD,
                                                    DWORD,LPCWSTR, IBindCtx *, LPVOID, DWORD );


// registered clipboard formats
//UINT g_cfFileDescriptor = 0;
//UINT g_cfFileContents = 0;
//UINT g_cfURL = 0;
UINT g_cfPrefDropEffect = 0;

///////////////////////////////////////////////////////////////////////////////
// CControlItem methods.

CControlItem::CControlItem() 
{
    DebugMsg(DM_TRACE, TEXT("ci - CControlItem() called."));
    DllAddRef();
    m_cRef = 1;
    m_piciUpdate = NULL;
    m_pcpidlUpdate = NULL;
    m_pcdlbsc = NULL;
}        

CControlItem::~CControlItem()
{
    Assert(m_cRef == 0);                 // we should have zero ref count here

    DebugMsg(DM_TRACE, TEXT("ci - ~CControlItem() called."));

    LocalFree((HLOCAL)m_ppcei);

    if (m_pCFolder != NULL)
        m_pCFolder->Release();          // release the pointer to the sf

    DllRelease();
}

HRESULT CControlItem::Initialize(CControlFolder *pCFolder, UINT cidl, LPCITEMIDLIST *ppidl)
{
    m_ppcei = (LPCONTROLPIDL*)LocalAlloc(LPTR, cidl * sizeof(LPCONTROLPIDL));
    if (m_ppcei == NULL)
        return E_OUTOFMEMORY;
    
    m_cItems = cidl;
    m_pCFolder = pCFolder;

    for (UINT i = 0; i < cidl; i++)
        m_ppcei[i] = (LPCONTROLPIDL)(ppidl[i]);

    m_pCFolder->AddRef();      // we're going to hold onto this pointer, so
                               // we need to AddRef it.
    return NOERROR;
}        

HRESULT CControlItem_CreateInstance(
                               CControlFolder *pCFolder,
                               UINT cidl, 
                               LPCITEMIDLIST *ppidl, 
                               REFIID riid, 
                               void **ppvOut)
{
    *ppvOut = NULL;                 // null the out param

//    if (!_ValidateIDListArray(cidl, ppidl))
//        return E_FAIL;

    CControlItem *pCItem = new CControlItem;
    if (pCItem == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pCItem->Initialize(pCFolder, cidl, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = pCItem->QueryInterface(riid, ppvOut);
    }
    pCItem->Release();

    if (g_cfPrefDropEffect == 0)
    {
//        g_cfFileDescriptor = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR); // "FileContents"
//        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);     // "FileDescriptor"
//        g_cfURL = RegisterClipboardFormat(TEXT("UniformResourceLocator"));  // "UniformResourceLocator"
        g_cfPrefDropEffect = RegisterClipboardFormat(TEXT("Preferred DropEffect"));// "Preferred DropEffect"
    }

    return hr;
}

HRESULT CControlItem::QueryInterface(REFIID iid, void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("ci - QueryInterface() called."));
    
    if ((iid == IID_IUnknown) || (iid == IID_IContextMenu))
    {
        *ppv = (LPVOID)(IContextMenu*)this;
    }
    else if (iid == IID_IDataObject) 
    {
        *ppv = (LPVOID)(IDataObject*)this;
    }
    else if (iid == IID_IExtractIcon) 
    {
        *ppv = (LPVOID)(IExtractIcon*)this;
    }
    else if (iid == CLSID_ControlFolder)    // really should be CLSID_ControlFolderItem
    {
        *ppv = (void *)this; // for our friends
    }
    else
    {
        *ppv = NULL;     // null the out param
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CControlItem::AddRef()
{
    return ++m_cRef;
}

ULONG CControlItem::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

HRESULT CControlItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef _DEBUG_
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, "#%d", pFEIn->cfFormat);

    DebugMsg(DM_TRACE, TEXT("ci - do - GetData(%s)"), szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfPrefDropEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = CreatePrefDropEffect(pSTM);
    else 
        hres = E_FAIL;      // FAIL WHEN YOU DON'T SUPPORT IT!!!

    return hres;
}

HRESULT CControlItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - GetDataHere() called."));
    return E_NOTIMPL;
}

HRESULT CControlItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef _DEBUG_
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, "#%d", pFEIn->cfFormat);

    DebugMsg(DM_TRACE, TEXT("ci - do - QueryGetData(%s)"), szName);
#endif

    if (pFEIn->cfFormat == g_cfPrefDropEffect)
    {
        DebugMsg(DM_TRACE, TEXT("                  format supported."));
        return NOERROR;
    }

    return S_FALSE;
}

HRESULT CControlItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - GetCanonicalFormatEtc() called."));
    return DATA_S_SAMEFORMATETC;
}

HRESULT CControlItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    DebugMsg(DM_TRACE,TEXT("ci - do - SetData() called."));
    return E_NOTIMPL;
}

HRESULT CControlItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC ControlFmte[1] = {
        {(CLIPFORMAT)g_cfPrefDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
    };

    DebugMsg(DM_TRACE, TEXT("ci - do - EnumFormatEtc() called."));

    return SHCreateStdEnumFmtEtc(ARRAYSIZE(ControlFmte), ControlFmte, ppEnum);
}

HRESULT CControlItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
    LPDWORD pdwConnection)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - DAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::DUnadvise(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - DUnAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - EnumAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = DROPEFFECT_COPY;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}

HRESULT CControlItem::Remove(HWND hwnd)
{
    TCHAR szMsg[MESSAGE_MAXSIZE];
    TCHAR szBuf[MESSAGE_MAXSIZE];

    if ( !g_fAllAccess )
    {
        // The current user does not have the access privileges to modify the
        // keys we need to tweak to remove a control, so let 'em know and bail
        // out quickly.
        MLLoadString(IDS_WARNING_USERNOACCESS, szMsg, ARRAYSIZE(szMsg));
        MLLoadString(IDS_MBTITLE_REMOVECONTROL, szBuf, ARRAYSIZE(szBuf));
        MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONWARNING);
        return S_FALSE;
    }

    szMsg[0] = '\0';

    if (m_cItems == 1)
    {
//        if(!PathFileExists(GetStringInfo(m_ppcei[0], SI_LOCATION)) ||
//           IsModuleRemovable(GetStringInfo(m_ppcei[0], SI_LOCATION)))
        {
            MLLoadString(IDS_WARNING_SINGLEREMOVAL, szBuf, ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[0], SI_CONTROL));
        }
    }
    else
    {
        MLLoadString(IDS_WARNING_MULTIPLEREMOVAL, szMsg, ARRAYSIZE(szMsg));
    }

    if (szMsg[0] != '\0')
    {
        MLLoadString(IDS_MBTITLE_REMOVECONTROL, szBuf, ARRAYSIZE(szBuf));

        if (MessageBox(hwnd, szMsg, szBuf, MB_YESNO | MB_ICONWARNING) != IDYES)
        {
            return S_FALSE;
        }
    }

    // set wait cursor
    HRESULT hr = S_OK;
    HCURSOR hCurOld = StartWaitCur();
    LPCTSTR pszTypeLibId = NULL;

    for (UINT i = 0; i < m_cItems; i++)
    {
        Assert(m_ppcei[i] != NULL);
        if (m_ppcei[i] == NULL)
        {
            hr = E_FAIL;
            break;
        }

        pszTypeLibId = GetStringInfo(m_ppcei[i], SI_TYPELIBID);
        if (SUCCEEDED(hr = RemoveControlByName2(
                                   GetStringInfo(m_ppcei[i], SI_LOCATION),
                                   GetStringInfo(m_ppcei[i], SI_CLSID),
                                   (pszTypeLibId[0] == '\0' ? NULL : pszTypeLibId),
                                   TRUE, (m_ppcei[i])->ci.dwIsDistUnit, FALSE)))
        {
            if ( hr == S_FALSE )
            {
                MLLoadString(
                      IDS_ERROR_NOUNINSTALLACTION, 
                      szBuf, 
                      ARRAYSIZE(szBuf));
                wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
                MLLoadString(
                      IDS_MBTITLE_NOUNINSTALLACTION,
                      szBuf,
                      ARRAYSIZE(szBuf));
                MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONWARNING);
            }

            GenerateEvent(
                     SHCNE_DELETE, 
                     m_pCFolder->m_pidl, 
                     (LPITEMIDLIST)(m_ppcei[i]), 
                     NULL);
        }
        else if (hr == STG_E_SHAREVIOLATION)
        {
            MLLoadString(
                  IDS_CONTROL_INUSE, 
                  szBuf, 
                  ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
            MLLoadString(
                  IDS_MBTITLE_SHAREVIOLATION,
                  szBuf,
                  ARRAYSIZE(szBuf));
            MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONSTOP);
        }
        else
        {
            MLLoadString(
                  IDS_ERROR_REMOVEFAIL,
                  szBuf, 
                  ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
            MLLoadString(
                  IDS_MBTITLE_REMOVEFAIL,
                  szBuf,
                  ARRAYSIZE(szBuf));
            MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONSTOP);
            break;
        }
    }

    EndWaitCur(hCurOld);

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtractIcon Methods

STDMETHODIMP CControlItem::GetIconLocation(
                            UINT uFlags,
                            LPSTR szIconFile,
                            UINT cchMax,
                            int *piIndex,
                            UINT *pwFlags)
{
    Assert(szIconFile != NULL);
    Assert(m_cItems == 1);

    if (szIconFile == NULL)
        return S_FALSE;

    *piIndex = 0;
    *pwFlags = 0;

    if (uFlags != GIL_FORSHELL)
        return S_FALSE;

    *pwFlags = GIL_NOTFILENAME|GIL_PERINSTANCE;

    if (cchMax > (UINT)lstrlen(GetStringInfo(m_ppcei[0], SI_LOCATION)))
    {
        lstrcpy(szIconFile, GetStringInfo(m_ppcei[0], SI_LOCATION));
        return NOERROR;
    }

    szIconFile[0] = '\0';
    return S_FALSE;
}

STDMETHODIMP CControlItem::Extract(
                    LPCSTR pszFile,
                    UINT nIconIndex,
                    HICON *phiconLarge,
                    HICON *phiconSmall,
                    UINT nIconSize)
{
    *phiconLarge = ExtractIcon(g_hInst, pszFile, nIconIndex);
    if (*phiconLarge == NULL)
    {   
        *phiconLarge = GetDefaultOCIcon( m_ppcei[0] );
        Assert(*phiconLarge != NULL);
    }
    *phiconSmall = *phiconLarge;

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
// IContextMenu Methods

const struct {
    LPCTSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    {TEXT("Remove"), IDM_CTRL_REMOVECONTROL},
    {TEXT("Properties"),  IDM_CTRL_PROPERTIES},
    {TEXT("Update"), IDM_CTRL_UPDATE},
    {TEXT("Delete"), IDM_CTRL_REMOVECONTROL},
    {NULL, 0}  // terminator
};

int GetCmdID(LPCTSTR pszCmd)
{
    if ((DWORD_PTR)pszCmd <= 0xFFFF)
        return (int)LOWORD(pszCmd);

    for (int i = 0; rgcmds[i].pszVerb != NULL; i++)
        if (lstrcmpi(pszCmd, rgcmds[i].pszVerb) == 0)
            return rgcmds[i].idCmd;

    return -1;
}

HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    hmParent = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (!hmParent)
        return NULL;

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

UINT MergePopupMenu(
                HMENU *phMenu, 
                UINT idResource, 
                UINT uSubOffset, 
                UINT indexMenu,  
                UINT idCmdFirst, 
                UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    
    DestroyMenu(hmMerge);
    return idCmdLast;
}

HRESULT CControlItem::QueryContextMenu(
                                  HMENU hmenu, 
                                  UINT indexMenu, 
                                  UINT idCmdFirst,
                                  UINT idCmdLast, 
                                  UINT uFlags)
{
    UINT idLastMerged = 0;

    DebugMsg(DM_TRACE, TEXT("ci - cm - QueryContextMenu() called."));
    
    if (uFlags & CMF_DVFILE)
    {
        idLastMerged = MergePopupMenu(
                            &hmenu,
                            IDR_FILE_MERGE, 
                            0, 
                            indexMenu, 
                            idCmdFirst,
                            idCmdLast);
        if (IsShowAllFilesEnabled()) {
            CheckMenuItem(hmenu, 1, MF_BYPOSITION | MF_CHECKED);
        }
        else {
            CheckMenuItem(hmenu, 1, MF_BYPOSITION | MF_UNCHECKED);
        }

    }
    else if (!(uFlags & CMF_VERBSONLY))
    {
        DWORD                     dwState = 0;

        // Must have a connection and not be working offline to be able
        // to update.

        if (InternetGetConnectedState(&dwState, 0) && !IsGlobalOffline()) {
            idLastMerged = MergePopupMenu(
                                &hmenu,
                                IDR_POPUP_CONTROLCONTEXT, 
                                0, 
                                indexMenu, 
                                idCmdFirst,
                                idCmdLast);
        }
        else {
            idLastMerged = MergePopupMenu(
                                &hmenu,
                                IDR_POPUP_CONTROLCONTEXT_NO_UPDATE,
                                0, 
                                indexMenu, 
                                idCmdFirst,
                                idCmdLast);
        }
        SetMenuDefaultItem(hmenu, idLastMerged - idCmdFirst, MF_BYPOSITION); // make the last menu, Properties, the default
    }

    return ResultFromShort(idLastMerged - idCmdFirst);    // number of menu items    
}

HRESULT CControlItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = GetCmdID((LPCTSTR)(pici->lpVerb));
    HRESULT hres = S_OK;
//  LPOLESTR                 szMimeType = NULL;
//  LPOLESTR                 szExtension = NULL;
//  LPOLESTR                 szCodeBase = NULL;
//  IBindCtx                *pbc = NULL;
//  CodeDownloadBSC         *pCDLBSC = NULL;

    DebugMsg(DM_TRACE, TEXT("ci - cm - InvokeCommand() called."));

    if (idCmd == IDM_CTRL_REMOVECONTROL)
    {
        hres = Remove(pici->hwnd);
    }
    else if (idCmd == IDM_CTRL_SHOWALL) {
        ToggleShowAllFiles();
        GenerateEvent(SHCNE_UPDATEITEM, m_pCFolder->m_pidl, 0, NULL);
    }
    else
    {
        for (i = 0; i < m_cItems && SUCCEEDED(hres); i++)
            if (m_ppcei[i]) 
            {
                switch (idCmd)
                {
                case IDM_CTRL_PROPERTIES: 
                    hres = CreatePropDialog(pici->hwnd, m_ppcei[i]);
                    break;;

                case IDM_CTRL_UPDATE:
                    hres = Update( pici, m_ppcei[i] );
 /*
                    hres = CreateBindCtx(0, &pbc);
                    if (SUCCEEDED(hres)) {
                        LPITEMIDLIST pidlUpdate = ILCombine(m_pCFolder->m_pidl,(LPITEMIDLIST)(m_ppcei[i]));
                     
                        // destructor of CodeDownloadBSC will free pidlUpdate 
                        if ( pidlUpdate != NULL &&
                             (pCDLBSC = new CodeDownloadBSC( pici->hwnd, pidlUpdate )) != NULL && 
                             SUCCEEDED(hres = RegisterBindStatusCallback(pbc, pCDLBSC, NULL, 0)))
                        {
                            PFNASYNCINSTALLDU        pfnAsyncInstallDU;
                            HINSTANCE                hModule;

                            pCDLBSC->Release();
                            hModule = LoadLibrary("URLMON.DLL");

#ifdef UNICODE
                            WCHAR swzCodeBase =  (m_ppcei[i])->ci.szCodeBase;
                            WCHAR swzDUName = (m_ppcei[i])->ci.szCLSID;
#else
                            MAKE_WIDEPTR_FROMANSI(swzCodeBase, (m_ppcei[i])->ci.szCodeBase);
                            MAKE_WIDEPTR_FROMANSI(swzDUName, (m_ppcei[i])->ci.szCLSID);
#endif

                            pfnAsyncInstallDU = (PFNASYNCINSTALLDU)GetProcAddress((HMODULE)hModule, "AsyncInstallDistributionUnit");
                            pfnAsyncInstallDU( swzDUName, szMimeType, szExtension,
                                               0xFFFFFFFF, 0xFFFFFFFF,
                                               swzCodeBase,
                                               pbc,
                                               NULL, 0);
                            FreeLibrary(hModule);
                        } 
                        else
                        {
                            if ( pCDLBSC != NULL )
                                delete pCDLBSC;
                            else if ( pidlUpdate != NULL )
                                ILFree( pidlUpdate );
                        }

                        if (pbc != NULL) {
                            pbc->Release();
                        }
                    }
*/
                    break;

                default:
                    hres = E_FAIL;
                    break;
                }
            }
    }

    return hres;
}

HRESULT CControlItem::GetCommandString(
                                   UINT_PTR idCmd, 
                                   UINT uFlags, 
                                   UINT *pwReserved,
                                   LPTSTR pszName, 
                                   UINT cchMax)
{
    HRESULT hres = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("ci - cm - GetCommandString() called."));

    pszName[0] = '\0';

    if (uFlags == GCS_VERB)
    {
        for (int i = 0; rgcmds[i].pszVerb != NULL; i++)
            if (idCmd == rgcmds[i].idCmd)
            {
                lstrcpyn(pszName, rgcmds[i].pszVerb, cchMax);
                hres = NOERROR;
            }
    }
    else if (uFlags == GCS_HELPTEXT)
    {
        hres = NOERROR;

        switch (idCmd)
        {
        case IDM_CTRL_REMOVECONTROL:
            MLLoadString(IDS_HELP_REMOVECONTROL, pszName, cchMax);
            break;
        case IDM_CTRL_PROPERTIES:
            MLLoadString(IDS_HELP_PROPERTIES, pszName, cchMax);
            break;
        case IDM_CTRL_UPDATE:
            MLLoadString(IDS_HELP_UPDATE, pszName, cchMax);
            break;
        default:
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT
CControlItem::Update(LPCMINVOKECOMMANDINFO pici, LPCONTROLPIDL pcpidl )
{
    HRESULT         hres = NOERROR;

    m_piciUpdate = pici;
    m_pcpidlUpdate = pcpidl;

    if (pici->hwnd)
    {
        INT_PTR nRes = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_OCUPDATE),
                                  pici->hwnd, CControlItem::DlgProc, (LPARAM)this);
    }

    return hres;
}

INT_PTR CControlItem::DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;
    CControlItem* pctlitem = (CControlItem*)GetWindowLongPtr(hDlg, DWLP_USER);
    HRESULT     hr = S_OK;
    IBindCtx    *pbc = NULL;
    LPOLESTR    szMimeType = NULL;
    LPOLESTR    szExtension = NULL;
    TCHAR       szBuf[MESSAGE_MAXSIZE];

    switch (msg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pctlitem = (CControlItem*)lParam;

        MLLoadString(IDS_UPDATE_CAPTION, szBuf, ARRAYSIZE(szBuf));
        lstrcatn( szBuf, pctlitem->m_pcpidlUpdate->ci.szName, ARRAYSIZE(szBuf));
        SetWindowText( hDlg, szBuf );

        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr)) 
        {
            LPITEMIDLIST pidlUpdate = ILCombine(pctlitem->m_pCFolder->m_pidl,(LPITEMIDLIST)(pctlitem->m_pcpidlUpdate));
     
            // destructor of CodeDownloadBSC will free pidlUpdate
            // if new succeeds but register fails, we'll deallocate pidlUpdate twice.
            if ( pidlUpdate != NULL &&
                 (pctlitem->m_pcdlbsc = new CodeDownloadBSC( pctlitem->m_piciUpdate->hwnd, hDlg, pidlUpdate )) != NULL && 
                 SUCCEEDED(hr = RegisterBindStatusCallback(pbc, pctlitem->m_pcdlbsc, NULL, 0)))
            {
                PFNASYNCINSTALLDU        pfnAsyncInstallDU;
                HINSTANCE                hModule;

                hModule = LoadLibrary("URLMON.DLL");

    #ifdef UNICODE
                WCHAR swzCodeBase =  pctlitem->m_pcpidlUpdate->ci.szCodeBase;
                WCHAR swzDUName = pctlitem->m_pcpidlUpdate->ci.szCLSID;
    #else
                MAKE_WIDEPTR_FROMANSI(swzCodeBase, pctlitem->m_pcpidlUpdate->ci.szCodeBase);
                MAKE_WIDEPTR_FROMANSI(swzDUName, pctlitem->m_pcpidlUpdate->ci.szCLSID);
    #endif

                pfnAsyncInstallDU = (PFNASYNCINSTALLDU)GetProcAddress((HMODULE)hModule, "AsyncInstallDistributionUnit");
                if ( pfnAsyncInstallDU != NULL )
                    hr = pfnAsyncInstallDU( swzDUName, szMimeType, szExtension,
                                           0xFFFFFFFF, 0xFFFFFFFF,
                                           swzCodeBase,
                                           pbc,
                                           NULL, 0);
                else
                    hr = E_FAIL;

                FreeLibrary(hModule);
            } 
            else
            {
                if ( pctlitem->m_pcdlbsc != NULL )
                {
                    delete pctlitem->m_pcdlbsc;
                    pctlitem->m_pcdlbsc = NULL;
                }
                else if ( pidlUpdate != NULL )
                    ILFree( pidlUpdate );
            }

            if (pbc != NULL) {
                pbc->Release();
            }
        }

        if ( SUCCEEDED(hr) )
        {
            Animate_Open(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), IDA_DOWNLOAD);
            Animate_Play(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), 0, -1, -1);
        }
        else
            EndDialog(hDlg, FALSE);
        fRet = 0;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            Assert( pctlitem->m_pcdlbsc != NULL );
            hr = pctlitem->m_pcdlbsc->Abort();
            Assert( SUCCEEDED( hr ) );
            EndDialog(hDlg, FALSE);
            break;

        case DOWNLOAD_PROGRESS:
            SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETPOS,
                        lParam, 0);
            break;

        case DOWNLOAD_COMPLETE:
            if (lParam)
                SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETPOS,
                            100, 0);
            EndDialog(hDlg, lParam);
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, FALSE);
        break;

    case WM_DESTROY:
        Assert( pctlitem->m_pcdlbsc != NULL );
        pctlitem->m_pcdlbsc->_hdlg = NULL;
        pctlitem->m_pcdlbsc->Release();
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}

BOOL CControlItem::IsGlobalOffline()
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\init.h ===
#ifndef __INIT__
#define __INIT__

#define CONST_VTABLE
#ifndef STRICT
#define STRICT
#endif
#ifndef WINVER
#define WINVER 0x0400
#define _WIN32_WINDOWS 0x0400
#endif

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <shlobj.h>         // in \sdk\inc
#include <shellapi.h>

#include <crtfree.h>        // don't use CRT libs
#include <ccstock.h>        // in ccshell\inc
#include <shsemip.h>        // in ccshell\inc
#include <shellp.h>             // in ccshell\inc
#include <debug.h>              // in ccshell\inc
#include <shguidp.h>        // in ccshell\inc
#include <advpub.h>

#ifdef __cplusplus
extern "C" {
#endif
    
extern HINSTANCE g_hInst;
extern BOOL      g_fAllAccess;
extern const CLSID CLSID_ControlFolder;
extern const CLSID CLSID_EmptyControlVolumeCache;
extern TCHAR g_szUnknownData[64];

#ifdef __cplusplus
};
#endif


STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

STDAPI ControlFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv); 
STDAPI EmptyControl_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\init.c ===
#include "init.h"
#include "global.h"
#include <shlwapi.h> // for DllInstall prototype

#define MLUI_INIT
#include <mluisupp.h>

// Downlevel delay load support (we forward to shlwapi)
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;
HANDLE BaseDllHandle;

extern HRESULT CanonicalizeModuleUsage(void);

// {88C6C381-2E85-11d0-94DE-444553540000}
const GUID CLSID_ControlFolder = {0x88c6c381, 0x2e85, 0x11d0, 0x94, 0xde, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0};
#define STRING_CLSID_CONTROLFOLDER TEXT("{88C6C381-2E85-11d0-94DE-444553540000}")

// global variables
HINSTANCE   g_hInst = NULL;
LONG        g_cRefDll = 0;
BOOL        g_fAllAccess = FALSE;   // we'll set to true if we can open our keys with KEY_ALL_ACCESS

#define GUID_STR_LEN    40
#define REG_PATH_IE_SETTINGS  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REG_PATH_IE_CACHE_LIST  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")
#define REG_ACTIVEX_CACHE     TEXT("ActiveXCache")
#define DEFAULT_CACHE_DIRECTORY  TEXT("Occache")

HRESULT CreateShellFolderPath(LPCTSTR pszPath, LPCTSTR pszGUID)
{
    if (!PathFileExists(pszPath))
        CreateDirectory(pszPath, NULL);

    // Mark the folder as a system directory
    if (SetFileAttributes(pszPath, FILE_ATTRIBUTE_SYSTEM))
    {
        TCHAR szDesktopIni[MAX_PATH];
        // Write in the desktop.ini the cache folder class ID
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);

        // (First, flush the cache to make sure the desktop.ini
        // file is really created.)
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), pszGUID, szDesktopIni);
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        // Hide the desktop.ini since the shell does not selectively
        // hide it.
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);

        return NOERROR;
    }
    else
    {
        DebugMsg(DM_TRACE, "Cannot make %s a system folder", pszPath);
        return E_FAIL;
    }
}

void CleanupShellFolder(LPCTSTR pszPath)
{
    if (PathFileExists(pszPath))
    {
        TCHAR szDesktopIni[MAX_PATH];

        // make the history a normal folder
        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
        {
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
            // Get the ini file cache to let go of this file
            WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
            DeleteFile(szDesktopIni);
        }

        // remove the history directory
        // RemoveDirectory(pszPath); // don't do this, we haven't uninstalled all the controls therein! 
    }
}

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);
        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


HRESULT GetControlFolderPath(LPTSTR szCacheDir, DWORD cchBuffer )
{
    /*
    LONG lResult = ERROR_SUCCESS;
    HKEY hKeyIntSetting = NULL;

    Assert(lpszDir != NULL);
    if (lpszDir == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_PATH_IE_SETTINGS,
                        0x0,
                        KEY_READ,
                        &hKeyIntSetting)) == ERROR_SUCCESS)
    {
        ULONG ulSize = ulSizeBuf;
        lResult = RegQueryValueEx(
                            hKeyIntSetting,
                            REG_ACTIVEX_CACHE,
                            NULL,
                            NULL,
                            (unsigned char*)lpszDir,
                            &ulSize);
        RegCloseKey(hKeyIntSetting);
    }

    return (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));
    */
       // Compose the default path.
    int len;

    GetWindowsDirectory(szCacheDir, cchBuffer);
    len = lstrlen(szCacheDir);
    if ( len && (szCacheDir[len-1] != '\\'))
        lstrcat(szCacheDir, "\\");
    lstrcat(szCacheDir, REG_OCX_CACHE_DIR);

    return ((len != 0)? S_OK : E_FAIL);
}


STDAPI AddCacheToRegPathList( HKEY hkeyParent, LPCTSTR szCacheDir, DWORD cchCacheDir )
{
    HRESULT hr = E_FAIL;
    LONG    lResult;

    // Check to see if new path already exists in the list of paths under
    // HKLM\...\Windows\CurrentVersion\Internet Settings\ActiveX Cache\Paths.
    // If not, add it.
    HKEY  hkeyCacheList = NULL;

    lResult = RegCreateKey( hkeyParent, REG_OCX_CACHE_SUBKEY, &hkeyCacheList );
    if (lResult == ERROR_SUCCESS) {
        DWORD dwIndex;
        TCHAR szName[MAX_PATH];
        DWORD cbName;
        TCHAR szValue[MAX_PATH];
        DWORD cbValue;
        LONG  lValueIndex = -1;
        BOOL  fFoundValue = FALSE;

        // iterate through the values of the cache subkey of the internet settings key.
        // The values have names which are simple, positive itegers. The idea here is
        // to have collection of values like so:
        // Name         Value                                   Source
        // "1"          "C:\WINNT\OC Cache"                     IE3 legacy controls
        // "2"          "C:\WINNT\Downloaded ActiveXControls"   IE4 PR-1 legacy controls
        // "3"          "C:\WINNT\Downloaded Components"        IE4 controls.
        for ( dwIndex = 0, cbName = sizeof(szName), cbValue = sizeof(szValue); 
              lResult == ERROR_SUCCESS; 
              dwIndex++, cbName = sizeof(szName), cbValue = sizeof(szValue) )
        {
            lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                    szName, &cbName, 
                                    NULL, NULL,
                                    (LPBYTE)szValue, &cbValue );

            if (lResult == ERROR_SUCCESS)
            {
                // for find new unique value name later.
                lValueIndex = max(lValueIndex, StrToInt(szName));

                if ( !fFoundValue )
                    fFoundValue = (lstrcmpi(szCacheDir, szValue) == 0);
                
                // Make sure that we're registered for all the (existing) old cache directories
                if ( !fFoundValue && PathFileExists(szValue) ) {
                    CreateShellFolderPath( szValue, STRING_CLSID_CONTROLFOLDER );
                }
            }
        }

 
        if (lResult == ERROR_NO_MORE_ITEMS)
        {   // we successfully inspected all the values
            if ( !fFoundValue )
            {
                TCHAR szSubKey[20]; // don't foresee  moure than a few billion caches
                // add new path to list of paths
                wsprintf(szSubKey, "%i", ++lValueIndex);
                lResult = RegSetValueEx( hkeyCacheList, szSubKey, 0, REG_SZ, 
                                         (LPBYTE)szCacheDir, cchCacheDir + 1);
                if ( lResult == ERROR_SUCCESS )
                    hr = S_OK;
                else 
                    hr = HRESULT_FROM_WIN32(lResult);
            } else
                hr = S_OK; // it's already there
        } else
            hr = HRESULT_FROM_WIN32(lResult);

        RegCloseKey( hkeyCacheList );
    } else
        hr = HRESULT_FROM_WIN32(lResult);

    return hr;
}

STDAPI SetCacheRegEntries( LPCTSTR szCacheDir )
{
    HRESULT hr = E_FAIL;
    LONG    lResult;
    HKEY    hkeyIS;    // reg key for internet settings;

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            REG_PATH_IE_SETTINGS,
                            0x0,
                            KEY_ALL_ACCESS,
                            &hkeyIS );
    if ( lResult == ERROR_SUCCESS)
    {
        // now the key is ours, oh, yes... it is ours...
        // set the value of the internet settings key used by Code Download.
        int cchCacheDir = lstrlen(szCacheDir);
        TCHAR szCacheDirOld[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cbOldCache = MAX_PATH;

        // Don't fail if we can't quite hook up with legacy caches
        hr = S_OK;

        // Add our old cache path, if any, to the cache path list if it differs from our new cache.
        lResult = RegQueryValueEx( hkeyIS, REG_OCX_CACHE_VALUE_NAME, 0, &dwType, (LPBYTE)szCacheDirOld, &cbOldCache );
        if ( lResult == ERROR_SUCCESS && dwType == REG_SZ &&
             lstrcmpi( szCacheDirOld, szCacheDir ) != 0 )
            AddCacheToRegPathList( hkeyIS, szCacheDirOld, cbOldCache - 1 );

                // Under NT, IE3 might not have been able to write the old cache path, so we'll cobble one up
                // and add it if that dir is present.
                if ( SUCCEEDED(GetWindowsDirectory( szCacheDirOld, MAX_PATH )) )
                {
            cbOldCache = lstrlen( szCacheDirOld ); 
            if ( cbOldCache && (szCacheDirOld[cbOldCache-1] != '\\'))
                lstrcat(szCacheDirOld, "\\");
                        cbOldCache = lstrlen(lstrcat( szCacheDirOld, REG_OCX_OLD_CACHE_DIR ));         

                        if (PathFileExists(szCacheDirOld))
                        {
                                // Let's not fail if this doesn't work
                                AddCacheToRegPathList( hkeyIS, szCacheDirOld, cbOldCache );
                CreateShellFolderPath( szCacheDirOld, STRING_CLSID_CONTROLFOLDER );
                        }
                }
         
        if ( SUCCEEDED(hr) )
        {
            lResult = RegSetValueEx( hkeyIS, REG_OCX_CACHE_VALUE_NAME, 0, REG_SZ,
                                     (LPBYTE)szCacheDir, cchCacheDir + 1 ); // need '\0'

            if ( lResult == ERROR_SUCCESS )
            {
                // add the new (?) path to the collection of valid paths which are the
                // values for the cache subkey.
                hr = AddCacheToRegPathList( hkeyIS, szCacheDir, cchCacheDir );
            } else
                hr = HRESULT_FROM_WIN32(lResult);
        }

        RegCloseKey( hkeyIS );

    } else
        hr = HRESULT_FROM_WIN32(lResult);
     
    return hr;
}

STDAPI InitCacheFolder(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szCacheDir[MAX_PATH];

    // Compose the default path.
    GetControlFolderPath(szCacheDir, MAX_PATH);
   
    // Okay, now we know where we want to put things.
    // Create the directory, and/or claim it as our own
    hr  = CreateShellFolderPath( szCacheDir, STRING_CLSID_CONTROLFOLDER );
    if ( SUCCEEDED(hr) )
    {
        hr = SetCacheRegEntries( szCacheDir );
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    // Remove a bunch of stuff from the registry.
    //
    CallRegInstall("Unreg");

    return NOERROR;
}

STDAPI DllRegisterServer(void)
{
    //
    // Add a bunch of stuff to the registry.
    //
    if (FAILED(CallRegInstall("Reg")))
    {
        goto CleanUp;
    }

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    DllUnregisterServer();
    return E_FAIL;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;

    if ( bInstall )
    {
        hr =InitCacheFolder();
        
        if ( SUCCEEDED(hr) )
            CanonicalizeModuleUsage();
    } 
    else
    {
        LONG  lResult;
        HKEY  hkeyCacheList;

        // Unhook occache as a shell extension for the cache folders.
        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                REG_PATH_IE_CACHE_LIST,
                                0x0,
                                KEY_ALL_ACCESS,
                                &hkeyCacheList );

        if ( lResult == ERROR_SUCCESS ) {
            DWORD dwIndex;
            TCHAR szName[MAX_PATH];
            DWORD cbName;
            TCHAR szValue[MAX_PATH];
            DWORD cbValue;

            for ( dwIndex = 0, cbName = sizeof(szName), cbValue = sizeof(szValue); 
                  lResult == ERROR_SUCCESS; 
                  dwIndex++, cbName = sizeof(szName), cbValue = sizeof(szValue) )
            {
                lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                        szName, &cbName, 
                                        NULL, NULL,
                                        (LPBYTE)szValue, &cbValue );

                if ( lResult == ERROR_SUCCESS && PathFileExists(szValue) )
                    CleanupShellFolder(szValue);
            }
            // We leave this key in place because it is the only record we have of the
            // cache folders and would be useful to future installations of IE
            RegCloseKey( hkeyCacheList );
        }
    }

    return hr;    
}

// we use shlwapi as our delayload error handler.
// NOTE: this only works if we are statically linked to shlwapi!
void SetupDelayloadErrorHandler()
{
    BaseDllHandle = GetModuleHandleA("shlwapi.dll");
    ASSERTMSG(BaseDllHandle != NULL, "OCCACHE must be statically linked to shlwapi.dll for delayload failure handling to work!");
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress((HMODULE)BaseDllHandle, "DelayLoadFailureHook");
}

STDAPI_(BOOL) DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID dwReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        HKEY hkeyTest;

        g_hInst = hInst;
        DisableThreadLibraryCalls(g_hInst);

        SetupDelayloadErrorHandler();

        MLLoadResources(g_hInst, TEXT("occachlc.dll"));
        
        // Test to see if we have permissions to modify HKLM subkeys.
        // We'll use this as an early test to see if we can remove controls.
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           REG_PATH_IE_SETTINGS,
                           0x0,
                           KEY_ALL_ACCESS,
                           &hkeyTest ) == ERROR_SUCCESS )
        {
            g_fAllAccess = TRUE;
            RegCloseKey( hkeyTest );
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MLFreeResources(g_hInst);
    }
    return TRUE;
}

typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnCreate)(IUnknown *, REFIID, void **);
} OBJ_ENTRY;

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
const OBJ_ENTRY c_clsmap[] = {
    { &c_CFVtbl, &CLSID_ControlFolder,             ControlFolder_CreateInstance },
    { &c_CFVtbl, &CLSID_EmptyControlVolumeCache,   EmptyControl_CreateInstance },
    // add more entries here
    { NULL, NULL, NULL }
};

// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();    // Class Factory keeps dll in memory
                return NOERROR;
            }
        }
    }
    // failure
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    ASSERT( 0 != g_cRefDll );
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\occache.inc ===
CCSHELL_DIR = $(PROJECT_ROOT)
!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\parseinf.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Implementation of class CParseInf
//
// CParseInf is created to deal with parsing of an INF file.

#include <ole2.h>
#include "ParseInf.h"
#include "resource.h"
#include "init.h"
#include "global.h"
#include <shlwapi.h>
#include <initguid.h>
#include <pkgguid.h>
#include <cleanoc.h>        // for STATUS_CTRL values
#include <mluisupp.h>

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

static BOOL FGetCLSIDFile( LPTSTR szFile, LPCTSTR szCLSID )
{
    BOOL fGotIt = FALSE;
    HKEY hkeyClsid;
    TCHAR szT[MAX_PATH];
    TCHAR *szPath = CatPathStrN( szT, HKCR_CLSID, szCLSID, MAX_PATH );

    if ( RegOpenKeyEx( HKEY_CLASSES_ROOT, szPath, 0, KEY_READ, &hkeyClsid ) == ERROR_SUCCESS )
    {
        DWORD dw;
        LRESULT lResult;

        // Look for InprocServer[32] or LocalServer[32] key
        dw = MAX_PATH;
        lResult = RegQueryValue(hkeyClsid, INPROCSERVER32, szT, (PLONG)&dw);
        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, LOCALSERVER32, szT, (PLONG)&dw);
        }

        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, INPROCSERVERX86, szT, (PLONG)&dw);
        }

        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, LOCALSERVERX86, szT, (PLONG)&dw);
        }

        if ( lResult == ERROR_SUCCESS )
        {
            if ( OCCGetLongPathName( szFile, szT, MAX_PATH ) == 0 )
                lstrcpy( szFile, szT );
            fGotIt = TRUE;
        }
        
        RegCloseKey( hkeyClsid );
    }

    return fGotIt;
}

// constructor
CParseInf::CParseInf()
{
    m_pHeadFileList = NULL;
    m_pCurFileNode = NULL;
    m_pFileRetrievalPtr = NULL;
    m_pHeadPackageList = NULL;
    m_pCurPackageNode = NULL;
    m_pPackageRetrievalPtr = NULL;
    m_bIsDistUnit = FALSE;
    m_bHasActiveX = FALSE;
    m_bHasJava = FALSE;
    m_pijpm = NULL;
    m_bCoInit = FALSE;
    m_dwStatus = STATUS_CTRL_UNKNOWN;
    GetDaysBeforeExpireGeneral( &m_cExpireDays );
}

// destructor
CParseInf::~CParseInf()
{
    DestroyFileList();
    DestroyPackageList();

    if ( m_pijpm != NULL )
        m_pijpm->Release();

    if ( m_bCoInit )
        CoUninitialize();
}

// initialization
void CParseInf::Init()
{
    m_dwFileSizeSaved = 0;
    m_dwTotalFileSize = 0;
    m_nTotalFiles = 0;
    m_pHeadFileList = m_pCurFileNode = NULL;
    m_pHeadPackageList = m_pCurPackageNode = NULL;

    lstrcpyn(m_szInf, m_szFileName, ARRAYSIZE(m_szInf));
    TCHAR *pCh = ReverseStrchr(m_szInf, '.');
    if (pCh != NULL)
        *pCh = '\0';
    if ( lstrlen(m_szInf) + lstrlen(INF_EXTENSION) < ARRAYSIZE(m_szInf))
        lstrcat(m_szInf, INF_EXTENSION);
    else
        m_szInf[0] = 0; // if can't hold it, we can't hold it.
 }

// release memory used by a linked list of files
void CParseInf::DestroyFileList()
{
    if (m_pHeadFileList != NULL)
        delete m_pHeadFileList;
    m_pHeadFileList = m_pCurFileNode = NULL;
}

void CParseInf::DestroyPackageList()
{
    if (m_pHeadPackageList != NULL)
        delete m_pHeadPackageList;
    m_pHeadPackageList = m_pCurPackageNode = NULL;
}


// find inf from cache directory if one with the
// same name as the OCX is not found
HRESULT CParseInf::FindInf(LPTSTR szInf)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA dataFile;
    HANDLE h = INVALID_HANDLE_VALUE;
    DWORD dwLen = 0;
    TCHAR szValueBuf[MAX_PATH];        
    TCHAR *szOcxFileName = ReverseStrchr(m_szFileName, '\\');
    int nCachePathLength = 0, i = 0;

    Assert(szOcxFileName != NULL);
    szOcxFileName += 1;
    Assert (szInf != NULL);
    if (szInf == NULL)
        goto ExitFindInf;

    // search for inf file in two directories.  First the dir where the
    // OCX is, then the OC cache dir.
    for (i = 0; dwLen == 0 && i < 2; i++)
    {
        if (i == 0)
            hr = GetDirectory(GD_EXTRACTDIR, szInf, ARRAYSIZE(szInf), m_szFileName);
        else
        {
            TCHAR szTemp[MAX_PATH];
            hr = GetDirectory(GD_CACHEDIR, szTemp, ARRAYSIZE(szTemp));
            if (lstrcmpi(szTemp, szInf) == 0)
                continue;
            lstrcpy(szInf, szTemp);
        }

        if (FAILED(hr))
            goto ExitFindInf;

        lstrcat(szInf, TEXT("\\"));
        nCachePathLength = lstrlen(szInf);
        lstrcat(szInf, TEXT("*"));
        lstrcat(szInf, INF_EXTENSION);
        h = FindFirstFile(szInf, &dataFile);
        if (h == INVALID_HANDLE_VALUE)
        {
            goto ExitFindInf;
        }

        // find an inf file with a section in [Add.Code] dedicated
        // to the OCX file in question
        do {
            szInf[nCachePathLength] = '\0';
            lstrcat(szInf, (LPCTSTR)dataFile.cFileName);
            dwLen = GetPrivateProfileString(
                                    KEY_ADDCODE,
                                    szOcxFileName,
                                    DEFAULT_VALUE,
                                    szValueBuf,
                                    MAX_PATH,
                                    szInf);
        } while(dwLen == 0 && FindNextFile(h, &dataFile));
    }
    
    hr = (dwLen != 0 ? hr : S_FALSE);

ExitFindInf:    

    if (h != INVALID_HANDLE_VALUE)
        FindClose(h);

    if (hr != S_OK)
        szInf[0] = '\0';

    return hr;
}

// initiate parsing of INF file
// szCLSID -- address to a buffer storing CLSID of control
// szOCXFileName -- full path and name (ie. long file name) of OCX file
HRESULT CParseInf::DoParse(
                  LPCTSTR szOCXFileName, 
                  LPCTSTR szCLSID)
{
    Assert(szOCXFileName != NULL);
    Assert(szCLSID != NULL);

    HRESULT hr = S_OK;
    const TCHAR *pszPath = NULL;
    TCHAR szFileName[MAX_PATH];
    DWORD dwFileSize = 0;

    if ( FGetCLSIDFile( szFileName, szCLSID ) &&
         lstrcmpi( szFileName, szOCXFileName ) != 0 )
        m_dwStatus = STATUS_CTRL_UNPLUGGED;


    // If DoParse was called, we are assumed to be a legacy control and not
    // a distribution unit (subsequent call to DoParseDU will change the
    // status). This information is required for control removal purposes.

    m_bIsDistUnit = FALSE;
    m_bHasActiveX = TRUE;  // all legacy controls are ActiveX

    // initialization

    if ( OCCGetLongPathName(m_szFileName, szOCXFileName, MAX_PATH) == 0 )
        lstrcpyn( m_szFileName, szOCXFileName, MAX_PATH );

    lstrcpyn(m_szCLSID, szCLSID, MAX_CLSID_LEN);
    DestroyFileList();
    Init();

    BOOL bOCXRemovable = IsModuleRemovable(m_szFileName);

    // test INF file existance, if not, try to find one in OC cache dir.
    if (!FileExist(m_szInf))
    {
        if (!ReadInfFileNameFromRegistry(m_szCLSID, m_szInf, MAX_PATH))
        {
            FindInf(m_szInf);

            // record inf file name into the registry
            WriteInfFileNameToRegistry(
                               m_szCLSID, 
                               (m_szInf[0] == '\0' ? NULL : m_szInf));
        }
    }

    // enumerate files assocated with a particular OCX
    if (FAILED(hr = EnumSections()))
        goto ExitDoParse;

    // S_FALSE is returned when an ocx has no inf file
    if (hr == S_FALSE)
    {
        m_nTotalFiles = 1;
        if (FAILED(GetSizeOfFile(m_szFileName, &m_dwFileSizeSaved)))
        {
            m_dwFileSizeSaved = 0;
            m_dwTotalFileSize = 0;
        }
        else
        {
            m_dwTotalFileSize = m_dwFileSizeSaved;
        }
        hr = S_OK;
        if ( !PathFileExists( m_szFileName ) )
            m_dwStatus = STATUS_CTRL_DAMAGED;
        else
            m_dwStatus = STATUS_CTRL_INSTALLED;
        goto ExitDoParse;
    }

    // OCX has an corresponding INF file.
    // Loop through the list of assocated files to dig out info for each
    // from their corresponding section in the INF file
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode(), hr = S_OK)
    {
        // if m_pCurFileNode->GetNextFileNode() == NULL => it's the inf file itself,
        // which does not need to be processed.
        if (m_pCurFileNode->GetNextFileNode() != NULL)
        {
            pszPath = m_pCurFileNode->GetPath();
            Assert(pszPath != NULL);
            if (pszPath == NULL)
            {
                hr = E_UNEXPECTED;
                goto ExitDoParse;
            }
            CatPathStrN( szFileName, pszPath, m_pCurFileNode->GetName(), ARRAYSIZE(szFileName));
        }
        else
        {
            lstrcpyn(szFileName, m_szInf, ARRAYSIZE(szFileName));
            pszPath = NULL;
        }

        // hr might either be S_OK or S_FALSE
        // S_OK means file can be removed as it has a SharedDlls count of 1
        // S_FALSE if the count is greater than 1

        // calculate total num of files and their sizes
        if (SUCCEEDED(hr = GetSizeOfFile(szFileName, &dwFileSize)))
        {
            if (pszPath == NULL ||
                IsModuleRemovable(szFileName) ||
                lstrcmpi(szFileName, m_szFileName) == 0)
            {
                m_dwFileSizeSaved += dwFileSize;
            }

            m_dwTotalFileSize += dwFileSize;
        } else
            m_dwStatus = STATUS_CTRL_DAMAGED; // failure to get size indicative of missing file.

        m_nTotalFiles += 1;
    }

    // if we didn't detect a problem, flag the control as installed.
    if ( m_dwStatus == STATUS_CTRL_UNKNOWN )
        m_dwStatus = STATUS_CTRL_INSTALLED;

ExitDoParse:
    return hr;
}

HRESULT CParseInf::BuildDUFileList( HKEY hKeyDU )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    HKEY    hkeyFiles;
    TCHAR   szDUFileName[MAX_PATH + 1];
    DWORD   dwStrSize = MAX_PATH;
    int     cFilesEnum = 0;

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DU_CONTAINS_FILES, 0,
                           KEY_READ, &hkeyFiles);

    if ( lResult != ERROR_SUCCESS ) // if no files, maybe there's Java
        return hr;

    while ((lResult = RegEnumValue(hkeyFiles, cFilesEnum++, szDUFileName,
                                   &dwStrSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
    {
        TCHAR szPath[MAX_PATH + 1];
        CFileNode *pFileNode;

        lstrcpyn(szPath, szDUFileName, MAX_PATH);
        TCHAR *szFName = ReverseStrchr(szPath, '\\');

        Assert(szFName != NULL);
        // long ago and far away, in the IE4, PP1-2 timeframe, there was a horrible
        // bug that corrupted these entries on Memphis and NT5. We suspect that GetLongPathName
        // was doing something wrong for code download, but repro scenarios were not
        // to be found. Anywho, the damaged registries are out there, so we need to
        // cope with them more gracefully than faulting at the *szFName = NULL;
        if ( szFName == NULL )
            continue;

        *szFName = NULL;
        szFName++;

        pFileNode = new CFileNode(szFName, "", szPath);
        if (pFileNode == NULL)
        {
            hr = E_OUTOFMEMORY;
            break; 
        }

        // create and add node to list
        if (m_pHeadFileList == NULL)
        {
            m_pHeadFileList = pFileNode;
            m_pCurFileNode = m_pHeadFileList;
        }
        else
        {
            hr = m_pCurFileNode->Insert(pFileNode);
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
        }
        dwStrSize = MAX_PATH;
    }

    RegCloseKey( hkeyFiles );

    return hr;
}

HRESULT CParseInf::BuildDUPackageList( HKEY hKeyDU )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    HKEY    hkeyJava;
    ICreateJavaPackageMgr *picjpm;


    DestroyPackageList();

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DU_CONTAINS_JAVA, 0,
                           KEY_READ, &hkeyJava);

    if ( lResult != ERROR_SUCCESS ) // it's OK if there's no Java
        return hr;

    if ( !m_bCoInit )
        m_bCoInit = SUCCEEDED(hr = CoInitialize(NULL));

    if ( m_bCoInit )
    {
        hr=CoCreateInstance(CLSID_JavaPackageManager,NULL,CLSCTX_INPROC_SERVER,
            IID_ICreateJavaPackageMgr,(LPVOID *) &picjpm);
        if (SUCCEEDED(hr))
        {
            hr = picjpm->GetPackageManager(&m_pijpm);
            picjpm->Release();
        }
    }

    if (FAILED(hr))
        return S_OK; // hr; // quietly fail until we're sure the JavaVM with package manager support is in the build.

    // list the packages under Contains/Java - these are in the gobal namespace
    hr = BuildNamespacePackageList(hkeyJava, "");

    // add packages for each namespace key under Contains\Java
    if ( SUCCEEDED(hr) )
    {
        DWORD   dwIndex;
        TCHAR   szNamespace[MAX_PATH + 1]; // 
        DWORD   dwStrSize;

        for ( dwIndex = 0, dwStrSize = MAX_PATH;
              RegEnumKey( hkeyJava, dwIndex, szNamespace, dwStrSize ) == ERROR_SUCCESS &&
                  SUCCEEDED(hr);
              dwIndex++, dwStrSize = MAX_PATH )
        {
            HKEY  hkeyNamespace;

            lResult = RegOpenKeyEx(hkeyJava, szNamespace, 0, KEY_READ, &hkeyNamespace);
            if ( lResult == ERROR_SUCCESS )
            {
                hr = BuildNamespacePackageList(hkeyNamespace, szNamespace );
                RegCloseKey( hkeyNamespace );
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lResult);
                break;
            }
        } 
        
    }

    RegCloseKey( hkeyJava );

    m_bHasJava = m_pHeadPackageList != NULL;

    return hr;
}

HRESULT CParseInf::BuildNamespacePackageList( HKEY hKeyNS, LPCTSTR szNamespace )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    int     cPackagesEnum = 0;
    TCHAR   szDUPackageName[MAX_PATH + 1];
    DWORD   dwStrSize = MAX_PATH;
    BOOL    fIsSystemClass = FALSE;

    while ((lResult = RegEnumValue(hKeyNS, cPackagesEnum++, szDUPackageName,
                                   &dwStrSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
    {
        IJavaPackage *pijp;

#ifndef UNICODE
        MAKE_WIDEPTR_FROMANSI(swzPackage, szDUPackageName );
        MAKE_WIDEPTR_FROMANSI(swzNamespace, szNamespace );
#else
        OLESTR swzPackage = szDUPackageName;
        OLESTR swzNamespace = szNamespace;
#endif
        hr = m_pijpm->GetPackage( swzPackage,
                                  ((*szNamespace == '\0')? NULL : swzNamespace),
                                  &pijp );
        if ( SUCCEEDED(hr) )
        {
            BSTR bstrPath;

            hr = pijp->GetFilePath( &bstrPath );
            if ( SUCCEEDED(hr) ) {
                CPackageNode *pPackageNode;

                pPackageNode = new CPackageNode(szDUPackageName, szNamespace);
                if (pPackageNode == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    pijp->Release();
                    break; 
                }
#ifndef UNICODE
                MAKE_ANSIPTR_FROMWIDE(szPath, bstrPath );
#else
                TCHAR *szPath = bstrPath;
#endif
                pPackageNode->SetPath( szPath );

                pijp->IsSystemClass(&fIsSystemClass);
                pPackageNode->SetIsSystemClass(fIsSystemClass);

                if (m_pHeadPackageList == NULL)
                {
                    m_pHeadPackageList = pPackageNode;
                    m_pCurPackageNode = m_pHeadPackageList;
                }
                else
                {
                    hr = m_pCurPackageNode->Insert(pPackageNode);
                    m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode();
                }

                SysFreeString( bstrPath );
                pijp->Release(); // we're done with the package
            }
        }
        else
        {
            m_dwStatus = STATUS_CTRL_DAMAGED;
            hr = S_OK; // don't barf if this doesn't work, some villain might have uninstalled it
        }

        dwStrSize = MAX_PATH;
    }

    return hr;
}


HRESULT CParseInf::DoParseDU(LPCTSTR szOCXFileName, LPCTSTR szCLSID)
{
    HRESULT     hr = S_OK;
    TCHAR       szFileName[MAX_PATH];
    TCHAR       szDUSvrName[MAX_PATH];
    const TCHAR *pszSvrFile = NULL; 
    DWORD       dwFileSize = 0;
    HKEY        hKeyFiles = 0;
    HKEY        hKeyDU = 0;
    HKEY        hKeyDLInfo = 0;
    TCHAR       szDistUnit[MAX_REGPATH_LEN];
    HRESULT     lResult;
    CFileNode   *pFileNode = NULL;
    DWORD       dwExpire;
    DWORD       dw;

    Assert(szCLSID != NULL);

    // Since this function was called, we must be a distribution unit.
    // Set a member flag so that all other member functions realize that
    // we are really part of a DU now.

    m_bIsDistUnit = TRUE;

    // initialization

    if ( szOCXFileName != NULL )
        lstrcpyn(m_szFileName, szOCXFileName, ARRAYSIZE(m_szFileName));
    lstrcpyn(m_szCLSID, szCLSID, ARRAYSIZE(m_szCLSID));
    Init();

    // Add files from ...\Distribution Units\{Name}\Contains\Files
    CatPathStrN( szDistUnit, REGSTR_PATH_DIST_UNITS, szCLSID, ARRAYSIZE(szDistUnit));

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDistUnit, 0, KEY_READ,
                           &hKeyDU);
    if (lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExitDoParseDU;
    }                           

    hr = BuildDUFileList( hKeyDU );
    if (FAILED(hr))
    {
        goto ExitDoParseDU;
    } 

    hr = BuildDUPackageList( hKeyDU );
    if (FAILED(hr))
    {
        goto ExitDoParseDU;
    } 

    // Now add the OSD and INF files

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DOWNLOAD_INFORMATION, 0,
                           KEY_READ, &hKeyDLInfo);
    if (lResult == ERROR_SUCCESS)
    {
        TCHAR                *pFileName = NULL;
        TCHAR                 szBuffer[MAX_PATH + 1];

        dw = MAX_PATH;
        lResult = RegQueryValueEx(hKeyDLInfo, REGSTR_VALUE_INF, NULL, NULL,
                                  (unsigned char*)szBuffer, &dw);
        if (lResult == ERROR_SUCCESS)
        {
            pFileName = ReverseStrchr(szBuffer, '\\');
            if (pFileName != NULL)
            {
                pFileName++;

                // set INF member variable
                lstrcpyn(m_szInf, szBuffer, ARRAYSIZE(m_szInf));

                pFileNode = new CFileNode(szBuffer, "", NULL);
                if (pFileNode == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto ExitDoParseDU; 
                }
        
                // create and add node to list
                if (m_pHeadFileList == NULL)
                {
                    m_pHeadFileList = pFileNode;
                    m_pCurFileNode = m_pHeadFileList;
                }
                else
                {
                    hr = m_pCurFileNode->Insert(pFileNode);
                    m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
                }
            }
        }

        pFileName = NULL;
        dw = MAX_PATH;
        lResult = RegQueryValueEx(hKeyDLInfo, REGSTR_VALUE_OSD, NULL, NULL,
                                  (unsigned char*)szBuffer, &dw);
        if (lResult == ERROR_SUCCESS)
        {
            pFileName = ReverseStrchr(szBuffer, '\\');
            if (pFileName != NULL)
            {
                pFileName++;
                pFileNode = new CFileNode(szBuffer, "", NULL);
                // create and add node to list
                if (m_pHeadFileList == NULL)
                {
                    m_pHeadFileList = pFileNode;
                    m_pCurFileNode = m_pHeadFileList;
                }
                else
                {
                    hr = m_pCurFileNode->Insert(pFileNode);
                    m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
                }
            }
        }
    }

    // See if there's an Expire value, and if so, override the default/general expire.
    dw = sizeof(DWORD);
    dwExpire = 0;
    if ( RegQueryValueEx(hKeyDU, REGSTR_VALUE_EXPIRE, NULL, NULL, (LPBYTE)&dwExpire, &dw) == ERROR_SUCCESS )
    {
        if ( dwExpire )
            m_cExpireDays = dwExpire;
        else
            GetDaysBeforeExpireAuto(&m_cExpireDays);
    }

    // Find out where COM thinks our CLSID is, and what the server name is.
    if ( FGetCLSIDFile( szDUSvrName, szCLSID ) )
    {
        m_bHasActiveX = TRUE;
        pszSvrFile = PathFindFileName(szDUSvrName);
    }
    else
        szDUSvrName[0] = '\0';


    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode(), hr = S_OK)
    {
        const TCHAR *pszPath = m_pCurFileNode->GetPath();

        if (pszPath != NULL)
        {
            CatPathStrN( szFileName, m_pCurFileNode->GetPath(), m_pCurFileNode->GetName(), ARRAYSIZE(szFileName));
        }
        else
        {
            lstrcpyn(szFileName, m_pCurFileNode->GetName(),ARRAYSIZE(szFileName));
        }

        if (SUCCEEDED(hr = GetSizeOfFile(szFileName, &dwFileSize)))
        {
            if (pszPath == NULL ||
                IsModuleRemovable(szFileName) ||
                lstrcmpi(szFileName, m_szFileName) == 0)
            {
                m_dwFileSizeSaved += dwFileSize;
            }

            // only play with the status if we haven't already flagged the installation
            // as damaged and we're looking at the the file that should be the host for
            // our control, if any.
            if ( m_dwStatus != STATUS_CTRL_DAMAGED && pszSvrFile != NULL &&
                 lstrcmpi( pszSvrFile, m_pCurFileNode->GetName() ) == 0 )
            {
                TCHAR    szDUSvrNameSPN[MAX_PATH];
                TCHAR    szFileNameSPN[MAX_PATH];

                GetShortPathName(szDUSvrName, szDUSvrNameSPN, MAX_PATH);
                GetShortPathName(szFileName, szFileNameSPN, MAX_PATH);
                
                if ( lstrcmpi( szDUSvrNameSPN, szFileNameSPN ) == 0 )
                    m_dwStatus = STATUS_CTRL_INSTALLED; // no, we're not unplugged
                else // server and our file are in different directories - unplugged scenario
                    m_dwStatus = STATUS_CTRL_UNPLUGGED;
            }

            m_dwTotalFileSize += dwFileSize;
        } else if ( !PathFileExists( szFileName ) ) // if a DU file is missing, then the installation is damaged.
            m_dwStatus = STATUS_CTRL_DAMAGED;

        m_nTotalFiles += 1;
    }

    // If we're still unsure, and there are packages, then this is a pure Java
    // DU and will say we're installed unless a check of the package files indicates otherwise.
    if ( m_pHeadPackageList != NULL && m_dwStatus == STATUS_CTRL_UNKNOWN )
        m_dwStatus = STATUS_CTRL_INSTALLED;

    // Accumulate package sizes and such into our running total
    for (m_pCurPackageNode = m_pHeadPackageList;
         m_pCurPackageNode != NULL;
         m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode(), hr = S_OK)
    {
        // the files can hold more than one of our packages, so only add a package
        // path file to the totals if we haven't already counted it.
        // N^2 to be sure, but the numbers will be small.
        CPackageNode *ppn;
        LPCTSTR szPackagePath = m_pCurPackageNode->GetPath();
        BOOL bAlreadySeen = FALSE;

        for ( ppn = m_pHeadPackageList;
              ppn != m_pCurPackageNode && !bAlreadySeen;
              ppn = ppn->GetNextPackageNode() )
            bAlreadySeen = lstrcmp( szPackagePath, ppn->GetPath() ) == 0;
        if ( bAlreadySeen )
            continue;

        // Must be a new file, 
       if ( SUCCEEDED(GetSizeOfFile(szPackagePath, &dwFileSize)) )
       {
           m_dwFileSizeSaved += dwFileSize;
           m_dwTotalFileSize += dwFileSize;
       }
       else
           m_dwStatus = STATUS_CTRL_DAMAGED;

       // m_nTotalFiles += 1; don't count these files, or the dependency file list will have a bunch of blank entries
    }

    // Some DUs, like SportsZone or Shockwave, have no Contains subkeys.
    // If status is still unknown here, but the server is in place, consider it
    // installed.
    if ( m_dwStatus == STATUS_CTRL_UNKNOWN && PathFileExists( szDUSvrName ) )
        m_dwStatus = STATUS_CTRL_INSTALLED;

ExitDoParseDU:

    if (hKeyDU)
    {
        RegCloseKey(hKeyDU);
    }

    if (hKeyDLInfo)
    {
        RegCloseKey(hKeyDLInfo);
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CParseInf::IsSectionInINF
// Checks if a section is in the INF
// returns:
//      S_OK: lpCurCode has the satellite binary name
//      S_FALSE: ignore this code and use default resources in main dll
//      E_XXX: any other error
BOOL
CParseInf::IsSectionInINF(
    LPCSTR lpCurCode)
{
    const char *szDefault = "";
    DWORD len;
#define FAKE_BUF_SIZE   3
    char szBuf[FAKE_BUF_SIZE];

    len = GetPrivateProfileString(lpCurCode, NULL, szDefault,
                                                szBuf, FAKE_BUF_SIZE, m_szInf);

    if (len == (FAKE_BUF_SIZE - 2)) {   // returns Out Of Buffer Space?
        // yes, section found
        return TRUE;
    } else {
        return FALSE;
    }
}
    
// loop through the keys in [Add.Code} section and enumerate the
// files and their corresponding sections.
HRESULT CParseInf::HandleSatellites(LPCTSTR pszFileName)
{

    HRESULT hr = S_OK;

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] = {

#define VAR_LANG     0       // expands to 3 letter lang code based on lcid
        "%LANG%",

#define NUM_VARS            1

        ""
    };

    const char *szValues[NUM_VARS + 1];
    szValues[VAR_LANG] = "***"; // unint magic
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order

    // look for and substitute variables like %EXTRACT_DIR%
    // and expand out the command line

    TCHAR szSectionName[MAX_PATH]; 
    TCHAR szSectionNameCopy[MAX_PATH]; 
    hr = ExpandCommandLine(pszFileName, szSectionName, MAX_PATH, szVars, szValues);

    if (hr != S_OK) 
        return hr;      // no vars to expand ignore section

    lstrcpy(szSectionNameCopy, szSectionName); // preserve


    // OK, this is a satellite DLL. Now we need to find the section(s) that
    // got installed.

    // we first enum the registry's Module Usage looking for DLLs that were
    // installed by (or used by) this CLSID. For each of those we need to
    // check if the base filename matches the pattern of the section, 
    // if it does then we process those sections

    DWORD iSubKey = 0;
    TCHAR szModName[MAX_PATH]; 

    while ( SUCCEEDED(hr = FindDLLInModuleUsage( szModName, m_szCLSID, iSubKey))  ) {

        if (PatternMatch(szModName, szSectionName) && 
            IsSectionInINF(szSectionName) ) {

            // create new node

            CFileNode *pFileNode = new CFileNode(szSectionName, szSectionName);
            if (pFileNode == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            // don't insert file into list if it's path cannot be found
            if (FAILED(GetFilePath(pFileNode)))
            {
                delete pFileNode;
                continue;
            }

            // create and add node to list
            if (m_pHeadFileList == NULL)
            {
                m_pHeadFileList = pFileNode;
                m_pCurFileNode = m_pHeadFileList;
            }
            else if (SUCCEEDED(hr = m_pCurFileNode->Insert(pFileNode)))
            {
                m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
            }
            else
            {
                goto Exit;
            }

            lstrcpy(szSectionName, szSectionNameCopy); // restore

        
        }
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        hr = S_OK;
    }

Exit:

    return hr;

}

// loop through the keys in [Add.Code} section and enumerate the
// files and their corresponding sections.
HRESULT CParseInf::EnumSections()
{
    HRESULT hr = S_OK;
    TCHAR szSectionBuffer[MAX_INF_SECTION_SIZE];
    TCHAR szValueBuffer[MAX_PATH];
    TCHAR *pszFileName = NULL;
    CFileNode *pFileNode = NULL;
    DWORD dwLen = GetPrivateProfileString(
                        KEY_ADDCODE,
                        NULL,
                        DEFAULT_VALUE,
                        szSectionBuffer,
                        MAX_INF_SECTION_SIZE,
                        m_szInf);
    if (dwLen == 0)
    {
        // if inf file or [Add.Code] section 
        // does not exist, just delete the OCX

        Assert (m_pHeadFileList == NULL);

        // separate file name from its directory
        Assert( lstrlen(m_szFileName) < ARRAYSIZE(szValueBuffer) );
        lstrcpy(szValueBuffer, m_szFileName);
        TCHAR *szName = ReverseStrchr(szValueBuffer, '\\');
        Assert (szName != NULL); 
        if (szName == NULL)
        {
            hr = E_UNEXPECTED;
            goto ExitEnumSections;
        }

        // create a node of the OCX and put it in a linked list
        m_pHeadFileList = new CFileNode(szName + 1, DEFAULT_VALUE);
        if (m_pHeadFileList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ExitEnumSections;
        }
        m_pCurFileNode = m_pHeadFileList;

        *szName = '\0';
        if (FAILED(hr = m_pHeadFileList->SetPath(szValueBuffer)))
        {
            goto ExitEnumSections;
        }
        hr = S_FALSE;
        goto ExitEnumSections;
    }

    // For OCX's that have an INF file and [Add.Code] section, loop
    // through the section to get filenames and section names.  Store
    // each file and its section in a node and add the node to a
    // linked list

    for (pszFileName = szSectionBuffer; 
         pszFileName[0] != '\0';
         pszFileName += lstrlen(pszFileName) + 1)
    {
        dwLen = GetPrivateProfileString(
                            KEY_ADDCODE,
                            pszFileName,
                            DEFAULT_VALUE,
                            szValueBuffer,
                            MAX_PATH,
                            m_szInf);

        // skip the file if no section is specified for it
        if (dwLen == 0) {
            continue;
        }

        if (StrChr(pszFileName, '%')) {
            // if section not found and it contains a %
            // could be a variable like %LANG% that gets
            // substituted to install satellite DLLs

            // check if it has any vars that we know about
            // and expand them and add filenodes if reqd.

            if (HandleSatellites(pszFileName) == S_OK) {

                // if this expanded to a satellite dll name then
                // we would have already added that
                // as a node in HandleSatellites

                continue;

            }
            
        }


        // create new node
        pFileNode = new CFileNode(pszFileName, szValueBuffer);
        if (pFileNode == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ExitEnumSections;
        }

        // don't insert file into list if it's path cannot be found
        if (FAILED(GetFilePath(pFileNode)))
        {
            delete pFileNode;
            continue;
        }

        // create and add node to list
        if (m_pHeadFileList == NULL)
        {
            m_pHeadFileList = pFileNode;
            m_pCurFileNode = m_pHeadFileList;
        }
        else if (SUCCEEDED(hr = m_pCurFileNode->Insert(pFileNode)))
        {
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
        }
        else
        {
            goto ExitEnumSections;
        }
    }

    // include inf file into file list

    if (m_pHeadFileList && m_pCurFileNode)
    {
        hr = m_pCurFileNode->Insert(new CFileNode(m_szInf, DEFAULT_VALUE));
        if (SUCCEEDED(hr))
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
    }

ExitEnumSections:

    return hr;
}

// Loop through all the sections in [Setup Hooks].  For each
// section, call ParseUninstallSection to find its UNINSTALL section
// and execute it.
HRESULT CParseInf::ParseSetupHook()
{
    HRESULT hr = S_FALSE; // Return S_FALSE if we don't run into any errors, but also don't do any work.
    TCHAR szSectionBuffer[MAX_INF_SECTION_SIZE];
    TCHAR szSection[MAX_PATH];
    TCHAR *pszKey = NULL;

    DWORD dwLen = GetPrivateProfileString(
                        KEY_SETUPHOOK,
                        NULL,
                        DEFAULT_VALUE,
                        szSectionBuffer,
                        MAX_INF_SECTION_SIZE,
                        m_szInf);

    // no Setup Hook section found
    if (dwLen == 0)
        goto EXITPARSESETUPHOOK;

    for (pszKey = szSectionBuffer; 
         pszKey[0] != '\0';
         pszKey += lstrlen(pszKey) + 1)
    {
        // For each key, get the section and run the section with RunSetupCommand

        dwLen = GetPrivateProfileString(
                       KEY_SETUPHOOK,
                       pszKey,
                       DEFAULT_VALUE,
                       szSection,
                       MAX_PATH,
                       m_szInf);

        if (dwLen == 0)
            continue;

        hr = ParseUninstallSection(szSection);
        if (FAILED(hr))
            goto EXITPARSESETUPHOOK;
     }

EXITPARSESETUPHOOK:
    return hr;
}

// Go to each file's section, find its conditional hook section, then
// call ParseUninstallSection to execute the conditional hook section.
HRESULT CParseInf::ParseConditionalHook()
{
    HRESULT hr = S_FALSE; // Return S_FALSE if we don't run into any errors, but also don't do any work.
    TCHAR szHookSection[MAX_PATH];
    const TCHAR *pszSection = NULL;
    CFileNode *pNode = NULL;

    if (m_pHeadFileList == NULL)
    {
        hr = S_FALSE;
        goto EXITPARSECONDITIONALHOOK;
    }

    pNode = m_pHeadFileList;
    for (pNode = m_pHeadFileList; pNode != NULL; pNode = pNode->GetNextFileNode())
    {
        pszSection = pNode->GetSection();
        if (pszSection == NULL)
            continue;

        if (GetPrivateProfileString(
                            pszSection,
                            KEY_HOOK,
                            DEFAULT_VALUE,
                            szHookSection,
                            MAX_PATH,
                            m_szInf) == 0)
            continue;

        hr = ParseUninstallSection(szHookSection);
        if (FAILED(hr))
            goto EXITPARSECONDITIONALHOOK;
    }

EXITPARSECONDITIONALHOOK:
    return hr;
}

// Given a file section, find its UNINSTALL section, go to the
// section and executes the commands there
HRESULT CParseInf::ParseUninstallSection(LPCTSTR lpszSection)
{
    HRESULT hr = S_OK;
    TCHAR szUninstallSection[MAX_PATH];
    TCHAR szBuf[MAX_PATH];
    TCHAR szInfSection[MAX_PATH];
    TCHAR szCacheDir[MAX_PATH];
    HANDLE hExe = INVALID_HANDLE_VALUE;
    HINSTANCE hInst = NULL;

    // check for "UNINSTALL" key
    DWORD dwLen = GetPrivateProfileString(
                        lpszSection,
                        KEY_UNINSTALL,
                        DEFAULT_VALUE,
                        szUninstallSection,
                        ARRAYSIZE(szUninstallSection),
                        m_szInf);

    // UNINSTALL key not found, quit.
    if (dwLen == 0)
    {
        return S_FALSE;
    }

    // There are 4 possible combinations inside the uninstall section
    // 1) Both inffile and infsection are specified -> simply to go those
    // 2) Only inffile is given -> go to inffile and do DefaultInstall
    // 3) Only infsection is given -> do infsection in this inf file
    // 4) Nothing is specified -> simply do this section

    GetDirectory(GD_EXTRACTDIR, szCacheDir, ARRAYSIZE(szCacheDir), m_szFileName);

    lstrcpyn(szBuf, szCacheDir, MAX_PATH - 1);
    lstrcat(szBuf, TEXT("\\"));

    int cch = lstrlen(szBuf);

    dwLen = GetPrivateProfileString(
                        szUninstallSection,
                        KEY_INFFILE,
                        DEFAULT_VALUE,
                        szBuf + cch,
                        MAX_PATH - cch,
                        m_szInf);

    if (dwLen == 0)
    {
        szBuf[0] = '\0';
    }

    // get inf section
    dwLen = GetPrivateProfileString(
                        szUninstallSection,
                        KEY_INFSECTION,
                        DEFAULT_VALUE,
                        szInfSection,
                        ARRAYSIZE(szInfSection),
                        m_szInf);

    if (dwLen == 0)
    {
        if (szBuf[0] != '\0')
            lstrcpyn(szInfSection, KEY_DEFAULTUNINSTALL,ARRAYSIZE(szInfSection));
        else
        {
            lstrcpyn(szBuf, m_szInf,ARRAYSIZE(szBuf));
            lstrcpyn(szInfSection, szUninstallSection,ARRAYSIZE(szInfSection));
        }
    }

    // load advpack.dll and call RunSetupCommand() to process
    // any special uninstall commands

    hr = STG_E_FILENOTFOUND;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        RUNSETUPCOMMAND pfnRunSetup = (RUNSETUPCOMMAND)GetProcAddress(
            hinstAdvPack, achRUNSETUPCOMMANDFUNCTION);
        if (pfnRunSetup)
        {
            hr = pfnRunSetup(NULL, szBuf, szInfSection, 
                            szCacheDir, NULL, &hExe, 1, NULL);
        }
    }

    return hr;
}

// For each file specified in the INF file, find its
// path in this order
// 1) OCX path
// 2) System dir
// 3) Windows dir
// 4) PATH directories
HRESULT CParseInf::GetFilePath(CFileNode *pFileNode)
{
    Assert (pFileNode != NULL);
    HRESULT hr = S_OK;
    TCHAR szValueBuf[MAX_PATH];
    TCHAR *pszPathPtr = NULL;
    TCHAR *pszPathEnv = NULL;
    TCHAR *pchPathEnd = NULL;
    DWORD dwLenPATH = 0;

    // ocx directory
    hr = GetDirectory(GD_EXTRACTDIR, szValueBuf, ARRAYSIZE(szValueBuf), m_szFileName);
    CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf));

    // if file being searched for now is the OCX itself, just leave
    if (lstrcmpi(szValueBuf, m_szFileName) == 0)
    {
        goto EXITGETFILEPATH;
    }

    if (SUCCEEDED(hr) && 
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // system directory
    hr = GetDirectory(GD_SYSTEMDIR, szValueBuf, ARRAYSIZE(szValueBuf));
    if (SUCCEEDED(hr) && CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf)) &&
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // windows directory
    hr = GetDirectory(GD_WINDOWSDIR, szValueBuf, ARRAYSIZE(szValueBuf));
    if (SUCCEEDED(hr) && CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf)) &&
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // get PATH envirnment variable
    dwLenPATH = GetEnvironmentVariable(ENV_PATH, szValueBuf, 0);
    if (dwLenPATH == 0)
    {
        hr = E_FAIL;
        goto EXITGETFILEPATH;
    }

    pszPathEnv = new TCHAR[dwLenPATH];
    if (pszPathEnv == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto EXITGETFILEPATH;
    }
    GetEnvironmentVariable(ENV_PATH, pszPathEnv, dwLenPATH);
    pchPathEnd = pszPathPtr = pszPathEnv;

    // walk all directories in PATH and see if file is found
    // in any of them
    while (pchPathEnd != NULL)
    {
        pchPathEnd = StrChr(pszPathPtr, ';');
        if (pchPathEnd != NULL)
            *pchPathEnd = '\0';

        CatPathStrN( szValueBuf, pszPathPtr, pFileNode->GetName(), ARRAYSIZE(szValueBuf));

        if (SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
            goto EXITGETFILEPATH;

        if (pchPathEnd != NULL)
            *(pchPathEnd++) = ';';

        pszPathPtr = pchPathEnd;
    }

    // file not found anywhere
    hr = E_FAIL;

EXITGETFILEPATH:

    if (pszPathEnv != NULL)
        delete [] pszPathEnv;

    if (SUCCEEDED(hr))
    {
        hr = NullLastSlash(szValueBuf, 0);
        if (SUCCEEDED(hr))
        {
            hr = pFileNode->SetPath(szValueBuf);
        }
    }

    return hr;
}

HRESULT CParseInf::CheckFilesRemovability(void)
{
    HRESULT hr = S_OK;
    TCHAR szFullName[MAX_PATH];
    const TCHAR *pszPath = NULL;
    BOOL bFileExist;

    // Walk through every file and see if it is deletable. If so,
    // then check if for sharing violations on that file.
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL && SUCCEEDED(hr);
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode())
    {
        pszPath = m_pCurFileNode->GetPath();
        if (pszPath == NULL || pszPath[0] == '\0')
            continue;

        CatPathStrN( szFullName, pszPath, m_pCurFileNode->GetName(), ARRAYSIZE(szFullName) );

        if (IsModuleRemovable(szFullName))
        {
            HANDLE h = CreateFile(
                             szFullName,
                             GENERIC_READ|GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                             NULL);
            if (h == INVALID_HANDLE_VALUE)
            {
                bFileExist = (GetLastError() != ERROR_FILE_NOT_FOUND);
                if (bFileExist)
                {
                    hr = STG_E_SHAREVIOLATION;
                    break;
                }
            }
            else
            {
                CloseHandle(h);
                m_pCurFileNode->SetRemovable( TRUE );
            }
        }
    }

    return hr;
}

HRESULT CParseInf::CheckLegacyRemovability(LONG *cOldSharedCount )
{
    HRESULT hr = S_OK;
    BOOL    bFileExist;

    HANDLE h = CreateFile(
                     m_szFileName,
                     GENERIC_READ|GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                     NULL);
    if (h == INVALID_HANDLE_VALUE)
    {
        bFileExist = (GetLastError() != ERROR_FILE_NOT_FOUND);
        if (bFileExist)
        {
            hr = STG_E_SHAREVIOLATION;
        } else
            hr = S_FALSE;
    }
    else
    {
        CloseHandle(h);
    }

    if ( SUCCEEDED(hr) )
        hr = CheckFilesRemovability();

    return hr;
}

HRESULT CParseInf::CheckDURemovability(HKEY hkeyDUDB, BOOL bSilent)
{
    HRESULT hr = S_OK;
    BOOL    bAskSystemClass = TRUE;

    hr = CheckFilesRemovability();
    if (FAILED(hr)) {
        goto CheckDURemovabilityExit;
    }

    hr = CheckDUDependencies(hkeyDUDB, bSilent);
    if (FAILED(hr)) {
        goto CheckDURemovabilityExit;
    }
    
    // Check for package removability.
    // We shouldn't remove a package if another DU also uses it.
    // TODO: Some sort of package-currently-in-use test. Either test the path file, as above,
    //       or use some groovy new IJavaPackage(Manager) method.
    for (m_pCurPackageNode = m_pHeadPackageList;
         m_pCurPackageNode != NULL;
         m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode())
    {
        TCHAR   szT[MAX_PATH];
        LRESULT lResult;
        BOOL    bFoundInOtherDU = FALSE;
        int     cDistUnitEnum = 0;

        if (!bAskSystemClass && m_pCurPackageNode->GetIsSystemClass()) {
            char lpszBuf[MAX_MSGBOX_STRING_LEN];
            char lpszBufTitle[MAX_MSGBOX_TITLE_LEN];

            MLLoadString(IDS_OCCACHE_WARNING_JAVA_SYSTEM_CLASS,
                         lpszBuf, MAX_MSGBOX_STRING_LEN);
            MLLoadString(IDS_REMOVAL_WARNING,
                         lpszBufTitle, MAX_MSGBOX_TITLE_LEN);

            // Attempting to remove system class. Warn user.
            if ( bSilent || 
                MessageBox(NULL, lpszBuf, lpszBufTitle,
                           MB_YESNO | MB_ICONWARNING) != IDYES) {

                hr = E_FAIL;
                goto CheckDURemovabilityExit;
            }
            bAskSystemClass = FALSE;
        }

        // Enumerate distribution units
        while ( (lResult = RegEnumKey(hkeyDUDB, cDistUnitEnum++, szT, MAX_PATH)) == ERROR_SUCCESS &&
                !bFoundInOtherDU )
        {
            if ( lstrcmp(szT, m_szCLSID) != 0 ) // skip the current DU
            {
                HKEY    hkeyDUCJ;
                DWORD   dw = MAX_PATH;
                lstrcat(szT, REGSTR_DU_CONTAINS_JAVA );
                lResult = RegOpenKeyEx( hkeyDUDB, szT, 0, KEY_READ, &hkeyDUCJ );
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = RegQueryValueEx(hkeyDUCJ, REGSTR_VALUE_INF, NULL, NULL,
                                              (unsigned char*)szT, &dw);
                    // To be safe, assume that anything other than value not found means
                    // that the other DU also uses the package.
                    bFoundInOtherDU = lResult != ERROR_FILE_NOT_FOUND;
                    RegCloseKey( hkeyDUCJ );
                } // if we could open other key's Contains\Java subkey
            } // if it's a different DU
        } // while enumerating DUs
        
        // if we found it in another DU, then we shouldn't remove this package with this DU
        m_pCurPackageNode->SetRemovable( !bFoundInOtherDU );
    } // for each package

CheckDURemovabilityExit:

    return hr;
}


HRESULT CParseInf::RemoveLegacyControl( LPCTSTR lpszTypeLibID, BOOL bSilent )
{
    HRESULT     hr = S_FALSE; 
    const TCHAR *pszPath;
    BOOL        bUnplug = m_dwStatus != STATUS_CTRL_UNPLUGGED;
    BOOL        bFileMissing = !PathFileExists( m_szFileName );
    BOOL        bDidRemove = FALSE;
    TCHAR       szFullName[MAX_PATH];

    // loop through the list of assocated files, remove them as
    // well as their registry entries.
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode())
    {
        int cOwners;

        pszPath = m_pCurFileNode->GetPath();

        // Process INF file, which as no path since it's not described in INF
        if (pszPath == NULL || pszPath[0] == '\0')
        {
            if ( DeleteFile(m_pCurFileNode->GetName()) )
                hr = S_OK; // hey, we did _something_ - averts the "not enough info" message
            continue;
        }
 
        // If we're where, we had some other file besides the INF. 
        // Even if we don't remove it, we still knock down its module
        // usage, which has gotta count for having done something.
        hr = S_OK;

        CatPathStrN( szFullName, pszPath, m_pCurFileNode->GetName(), MAX_PATH);

        cOwners = SubtractModuleOwner( szFullName, m_szCLSID );
        if (m_pCurFileNode->GetRemovable() && cOwners == 0)
        {
            if ( bUnplug )
                UnregisterOCX(szFullName);
            DeleteFile(szFullName);
            bDidRemove = bDidRemove || StrCmpI(szFullName,m_szFileName) == 0;
        }
    }

    if (hr == S_OK && bDidRemove && lpszTypeLibID != NULL)
        CleanInterfaceEntries(lpszTypeLibID);
    
    if ( bUnplug && bFileMissing )
    {
        if ( m_szFileName[0] != '\0' ) // only do this if there is an ocx to clean up after
            CleanOrphanedRegistry(m_szFileName, m_szCLSID, lpszTypeLibID);
    }

    return hr;
}


HRESULT CParseInf::RemoveDU( LPTSTR szFullName, LPCTSTR lpszTypeLibID, HKEY hkeyDUDB, BOOL bSilent )
{
    HRESULT     hr = S_FALSE;   // only say S_OK if we actually do something beyond yanking the INF
    const TCHAR *pszPath = NULL;

    hr = RemoveLegacyControl( lpszTypeLibID, bSilent );
    if (SUCCEEDED(hr))
    {

        // Remove the packages that we have determined are safe to remove.
        for (m_pCurPackageNode = m_pHeadPackageList;
            m_pCurPackageNode != NULL;
            m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode())
        {
            if ( m_pCurPackageNode->GetRemovable() )
            {
                Assert(m_pijpm != NULL);
    #ifdef UNICODE
                OLECHAR *swzPkg = m_pCurPackageNode->GetName();
                OLECHAR *swzNamespace = m_pCurPackageNode->GetNamespace();
    #else
                MAKE_WIDEPTR_FROMANSI(swzPkg, m_pCurPackageNode->GetName());
                MAKE_WIDEPTR_FROMANSI(swzNamespace, m_pCurPackageNode->GetNamespace());
    #endif
                hr = m_pijpm->UninstallPackage( swzPkg, 
                                                ((*swzNamespace == 0)? NULL : swzNamespace),
                                                0 );
            }
        }
    }

    DeleteKeyAndSubKeys(hkeyDUDB, m_szCLSID);

    return hr;
}

HRESULT CParseInf::CheckDUDependencies(HKEY hKeyDUDB, BOOL bSilent )
{
    long                    lrDist = 0;
    long                    lResult = 0;
    long                    lr = 0;
    int                     iSubKey = 0;
    HKEY                    hkeyCurrent = 0;
    HKEY                    hkeyCurDU = 0;
    char                    szName[MAX_REGPATH_LEN];
    int                     iValue = 0;
    unsigned long           ulSize;
    char                    szDependency[MAX_REGPATH_LEN];
    HKEY                    hkeyCOM = 0;
    DWORD                   dwType = 0;
    char                    szDepName[MAX_CONTROL_NAME_LEN];
    char                    szDepWarnBuf[MAX_MSGBOX_STRING_LEN];
    char                    szCOMControl[MAX_REGPATH_LEN];
    DWORD                   dwSize = 0;
    HRESULT                 hr = S_OK;

    // Iterate through DUs that have a ...\contains\Distribution Units
    // key in the registry and compare the entries inside with the DU
    // being removed.

    while ((lResult = RegEnumKey(hKeyDUDB, iSubKey++, szName,
                                 MAX_REGPATH_LEN)) == ERROR_SUCCESS)
    {

        if (!lstrcmpi(szName, m_szCLSID))
        {
            // Skip ourselves
            continue;
        }

        if (RegOpenKeyEx(hKeyDUDB, szName, 0, KEY_READ, &hkeyCurrent) ==
                         ERROR_SUCCESS)
        {
            lr = RegOpenKeyEx(hkeyCurrent, REGSTR_DU_CONTAINS_DIST_UNITS,
                              0, KEY_READ, &hkeyCurDU);
            if (lr != ERROR_SUCCESS)
            {
                RegCloseKey(hkeyCurrent);
                continue;
            }

            ulSize = MAX_REGPATH_LEN;
            while ((lResult = RegEnumValue(hkeyCurDU, iValue++, szDependency,
                                           &ulSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
            {
                if (!lstrcmpi(szDependency, m_szCLSID))
                {
                    // dependency found

                    // Try to get a friendly name for the dependency control

                    dwSize = MAX_CONTROL_NAME_LEN;
                    lResult = RegQueryValueEx(hkeyCurrent, NULL, NULL,
                                              &dwType, (unsigned char *)szDepName,
                                              &dwSize);

                    if (lResult != ERROR_SUCCESS || szDepName[0] == '\0') {
                        // Couldn't get a friendly name. Try the COM branch.

                        // Technically, this could overflow because
                        // szName and szCOMControl are the same size, but
                        // this is already at our defined maximum size for reg
                        // entries.

                        wsprintf(szCOMControl, "%s\\%s", REGSTR_COM_BRANCH, szName);
                        
                        lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, szCOMControl,
                                               0, KEY_READ, &hkeyCOM);

                        if (lResult != ERROR_SUCCESS) {                                               
                            MLLoadString(IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN,
                                         szDepWarnBuf, MAX_MSGBOX_STRING_LEN);
                        }
                        else {
                            dwSize = MAX_CONTROL_NAME_LEN;
                            lResult = RegQueryValueEx(hkeyCOM, NULL, NULL,
                                                      &dwType, (unsigned char *)szDepName,
                                                      &dwSize);

                            if (lResult != ERROR_SUCCESS || szDepName[0] == '\0') {
                                MLLoadString(IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN,
                                             szDepWarnBuf, MAX_MSGBOX_STRING_LEN);
                            }
                            else {
                                char                 lpszBuf[MAX_MSGBOX_STRING_LEN];

                                MLLoadString(IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL,
                                             lpszBuf, MAX_MSGBOX_STRING_LEN);
                                wsprintf(szDepWarnBuf, lpszBuf, szDepName);
                            }

                            if (hkeyCOM) {
                                RegCloseKey(hkeyCOM);
                            }
                        }
                    }
                    else {
                        char                 lpszBuf[MAX_MSGBOX_STRING_LEN];

                        MLLoadString(IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL,
                                     lpszBuf, MAX_MSGBOX_STRING_LEN);

                        wsprintf(szDepWarnBuf, lpszBuf, szDepName);
                    }

                    
                    // TODO: Consider using better HWND than desktop
                    char lpszBufTitle[MAX_MSGBOX_TITLE_LEN];
    
                    MLLoadString(IDS_REMOVAL_WARNING,
                                 lpszBufTitle, MAX_MSGBOX_TITLE_LEN);
    
                    if (bSilent ||
                        MessageBox(NULL, szDepWarnBuf, lpszBufTitle,
                                   MB_YESNO | MB_ICONWARNING) != IDYES)
                    {
                        hr = E_FAIL;
                        RegCloseKey(hkeyCurDU);
                        RegCloseKey(hkeyCurrent);
                        RegCloseKey(hKeyDUDB);
                        goto ReturnCheckDUDependencies;
                    }
                }
                ulSize = MAX_REGPATH_LEN;
            }
            RegCloseKey(hkeyCurDU);
            RegCloseKey(hkeyCurrent);
        }
    }


ReturnCheckDUDependencies:
    return hr;
}

// uninstall OCX and its associated files
HRESULT CParseInf::RemoveFiles(
                       LPCTSTR lpszTypeLibID /* = NULL */,
                       BOOL bForceRemove, /* = FALSE */
                       DWORD dwIsDistUnit,
                       BOOL bSilent)
{
    HRESULT hr = S_OK;
    HRESULT hrInf1;
    HRESULT hrInf2;
    TCHAR szFullName[MAX_PATH];
    const TCHAR *pszPath = NULL;
    BOOL bRemovable = (dwIsDistUnit) ? (TRUE) : (IsModuleRemovable(m_szFileName));
    BOOL bIsOCX = FALSE;
    LONG cRefOld = 0;
    HKEY  hKeyDUDB = 0;
    BOOL bUnplug = m_dwStatus == STATUS_CTRL_DAMAGED || m_dwStatus == STATUS_CTRL_INSTALLED;

    if ( !g_fAllAccess || (!bForceRemove && !bRemovable))
    {
        hr = E_ACCESSDENIED;
        goto ExitRemoveFiles;
    }

    // Check sharing violation (if it is a legacy control)
    
    if (!dwIsDistUnit)
    {
        hr = CheckLegacyRemovability( &cRefOld );
        // set SharedDlls count to 1 and save up the old
        // count in case the removal fails
        if (hr == S_OK && !bRemovable && 
            FAILED(hr = SetSharedDllsCount(m_szFileName, 1, &cRefOld)))
        {
            hr = (!PathFileExists( m_szFileName ) ? S_OK : hr);
            goto ExitRemoveFiles;
        }

        if ( FAILED(hr) )
            goto ExitRemoveFiles;
    }
    else
    {
        long lResultDist;

        lResultDist = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0,
                                   KEY_READ, &hKeyDUDB);
        if (lResultDist == ERROR_SUCCESS)
            hr = CheckDURemovability( hKeyDUDB, bSilent );
        else 
            hr = E_FAIL;

        if ( FAILED(hr) )
            goto ReturnRemoveFiles;
    }


    // ** keyword UNINSTALL -- new feature that hasn't been implemented yet **

    // parse [Setup Hook], look for "UNINSTALL" key  
    if (FAILED(hrInf1 = ParseSetupHook()))
    {
        goto ExitRemoveFiles;
    }

    // parse conditional hooks in each of the file sections
    if (FAILED(hrInf2 = ParseConditionalHook()))
    {
        goto ExitRemoveFiles;
    }

    // Okay, if the both didn't do anything, we'll try the DefaultUninstall
    if ( hrInf1 == S_FALSE && hrInf2 == S_FALSE && PathFileExists( m_szInf ) )
    {
        // see if there's anybody home in the default uninstall section
        DWORD dwSize = GetPrivateProfileString( KEY_DEFAULTUNINSTALL,
                                                NULL,
                                                DEFAULT_VALUE,
                                                szFullName,
                                                MAX_PATH,
                                                m_szInf );

        if ( dwSize > 0 )
        {
            HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
            HANDLE hExe = INVALID_HANDLE_VALUE;

            GetDirectory(GD_EXTRACTDIR, szFullName, ARRAYSIZE(szFullName), m_szInf);

            if (hinstAdvPack)
            {
                RUNSETUPCOMMAND pfnRunSetup = (RUNSETUPCOMMAND)GetProcAddress(
                    hinstAdvPack, achRUNSETUPCOMMANDFUNCTION);
                if (pfnRunSetup)
                {
                    // reset hrINf2 to reflect the success of running the default
                    // uninstall section. This will prevent us from pointing to the
                    // Add/Remove control panel in some cases, like Shockwave.
                    hrInf2 = pfnRunSetup(NULL, m_szInf, KEY_DEFAULTUNINSTALL, 
                                    szFullName, NULL, &hExe, RSC_FLAG_INF, NULL);
                }

                FreeLibrary( hinstAdvPack );
            }
        }
    }

    if ( !dwIsDistUnit )
        hr = RemoveLegacyControl( lpszTypeLibID, bSilent );
    else
        hr = RemoveDU( szFullName, lpszTypeLibID, hKeyDUDB, bSilent );
    if ( FAILED(hr) )
        goto ExitRemoveFiles;

    // Return S_FALSE iff none of our uninstall efforts succeeded
    if ( hr == S_FALSE && (hrInf1 == S_OK || hrInf2 == S_OK) )
        hr = S_OK;
        
    // remove conflict directory
    if (SUCCEEDED(GetDirectory(GD_CONFLICTDIR, szFullName, ARRAYSIZE(szFullName))) &&
        LStrNICmp(m_szFileName, szFullName, lstrlen(szFullName)) == 0)
    {
        TCHAR *pCh = ReverseStrchr(m_szFileName, '\\');
        Assert (pCh != NULL);
        TCHAR chTemp = *pCh;
        *pCh = '\0';
        RemoveDirectory(m_szFileName);
        *pCh = chTemp;
    }

    DestroyFileList();

ExitRemoveFiles:

    // set shared dlls count back to where it was if OCX cannot be removed
    if (cRefOld > 0 && FileExist(m_szFileName))
    {
        if (SUCCEEDED(hr))
            hr = SetSharedDllsCount(m_szFileName, cRefOld);
        else
            SetSharedDllsCount(m_szFileName, cRefOld);
    }

    if ( hKeyDUDB )
        RegCloseKey( hKeyDUDB );

ReturnRemoveFiles:

    return hr;
}


void CParseInf::SetIsDistUnit(BOOL bDist)
{
    m_bIsDistUnit = bDist;
}

BOOL CParseInf::GetIsDistUnit() const
{
    return m_bIsDistUnit;
}

// return total size of OCX and its associated files
DWORD CParseInf::GetTotalFileSize() const
{
    return m_dwTotalFileSize;
}

DWORD CParseInf::GetTotalSizeSaved() const
{
    return m_dwFileSizeSaved;
}

DWORD CParseInf::GetStatus() const
{
    return m_dwStatus;
}

// return total number of files which will be removed
// together with the OCX
int CParseInf::GetTotalFiles() const
{
    return m_nTotalFiles;
}

// return first file in the list of associated files
CFileNode* CParseInf::GetFirstFile()
{
    m_pFileRetrievalPtr = m_pHeadFileList;
    return m_pFileRetrievalPtr;
}

// get the next file in the list of associated files
CFileNode* CParseInf::GetNextFile()
{
    m_pFileRetrievalPtr = m_pFileRetrievalPtr->GetNextFileNode();
    return m_pFileRetrievalPtr;
}

// return first file in the list of associated files
CPackageNode* CParseInf::GetFirstPackage()
{
    m_pPackageRetrievalPtr = m_pHeadPackageList;
    return m_pPackageRetrievalPtr;
}

// get the next file in the list of associated files
CPackageNode* CParseInf::GetNextPackage()
{
    m_pPackageRetrievalPtr = (m_pPackageRetrievalPtr != NULL)?
                                m_pPackageRetrievalPtr->GetNextPackageNode() :
                                NULL;
    return m_pPackageRetrievalPtr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\menu.cpp ===
#include "folder.h"
#include "utils.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// IContextMenu methods

HRESULT CControlFolder::QueryContextMenu(
                                     HMENU hmenu, 
                                     UINT indexMenu, 
                                     UINT idCmdFirst,
                                     UINT idCmdLast,
                                     UINT uFlags)
{
    USHORT cItems = 0;

    DebugMsg(DM_TRACE, TEXT("cf - cm - QueryContextMenu() called."));
    if (uFlags == CMF_NORMAL)
    {
        HMENU hCtrlMenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_CONTROLFOLDER));
        if (hmenu)
        {
            MENUITEMINFO mii;
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;
            mii.wID = SFVIDM_MENU_ARRANGE;
            SetMenuItemInfo(hCtrlMenu, 0, TRUE, &mii);
            cItems = (USHORT)MergeMenuHierarchy(hmenu, hCtrlMenu, idCmdFirst, idCmdLast);
            DestroyMenu(hCtrlMenu);
        }
    }
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

HRESULT CControlFolder::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    // We don't deal with the VERBONLY case
    DebugMsg(DM_TRACE, TEXT("cf - cm - InvokeCommand() called."));
    Assert((DWORD_PTR)(pici->lpVerb) <= 0xFFFF);
    
    int idCmd;
    if ((DWORD_PTR)(pici->lpVerb) > 0xFFFF)
        idCmd = -1;
    else
        idCmd = LOWORD(pici->lpVerb);
    
    return ControlFolderView_Command(pici->hwnd, idCmd);
}

HRESULT CControlFolder::GetCommandString(
                                     UINT_PTR idCmd, 
                                     UINT uFlags, 
                                     UINT *pwReserved,
                                     LPTSTR pszName, 
                                     UINT cchMax)
{
    HRESULT hres = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("cf - cm - GetCommandString() called."));

    if (uFlags == GCS_HELPTEXT)
    {
        MLLoadString((UINT) (idCmd + IDS_HELP_SORTBYNAME), pszName, cchMax);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\item.h ===
#ifndef __CONTROL_ITEM__
#define __CONTROL_ITEM__

#include "folder.h"
#include "cdlbsc.hpp"

class CControlItem : public IDataObject,
                     public IExtractIcon,
                     public IContextMenu
{
    // CControlItem interfaces
    friend HRESULT ControlFolderView_DidDragDrop(
                                            HWND hwnd, 
                                            IDataObject *pdo, 
                                            DWORD dwEffect);

public:
    CControlItem();
    HRESULT Initialize(
                   CControlFolder *pCFolder, 
                   UINT cidl, 
                   LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(
                            HMENU hmenu, 
                            UINT indexMenu, 
                            UINT idCmdFirst,
                            UINT idCmdLast, 
                            UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(
                             UINT_PTR idCmd, 
                             UINT uType,
                             UINT *pwReserved,
                             LPTSTR pszName, 
                             UINT cchMax);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);

    // IDataObject helper functions
    HRESULT CreatePrefDropEffect(STGMEDIUM *pSTM);
    HRESULT Remove(HWND hwnd);
/*
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);
    HRESULT _CreateNameMap(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptor(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);
*/

    // IExtractIcon Methods
    STDMETHODIMP GetIconLocation(
                            UINT uFlags,
                            LPSTR szIconFile,
                            UINT cchMax,
                            int *piIndex,
                            UINT *pwFlags);
    STDMETHODIMP Extract(
                    LPCSTR pszFile,
                    UINT nIconIndex,
                    HICON *phiconLarge,
                    HICON *phiconSmall,
                    UINT nIconSize);

    // Support for our progress UI 
    static INT_PTR DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    // Misc helper function

    static BOOL IsGlobalOffline();

protected:

    ~CControlItem();

    HRESULT Update(LPCMINVOKECOMMANDINFO pici, LPCONTROLPIDL pcpidl);

    UINT                 m_cRef;            // reference count
    UINT                 m_cItems;          // number of items we represent
    CControlFolder*  m_pCFolder;    // back pointer to our shell folder
    LPCONTROLPIDL*       m_ppcei;           // variable size array of items
    LPCMINVOKECOMMANDINFO m_piciUpdate;
    LPCONTROLPIDL         m_pcpidlUpdate;
    CodeDownloadBSC      *m_pcdlbsc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\parseinf.h ===
///////////////////////////////////////////////////////////////////////////////
// Declaration of class CParseInf
//
// One instance of this class is created for each OCX being removed.  It stores
// all the files associated with the OCX in a linked list.  It also does the
// jobs of determining if the OCX is uninstallable and of the actual file
// removal.

#ifndef __PARSE_INF__
#define __PARSE_INF__

#include "filenode.h"
#include <pkgmgr.h>

#define REGSTR_COM_BRANCH                       "CLSID"
#define REGSTR_DOWNLOAD_INFORMATION             "DownloadInformation"
#define REGSTR_DLINFO_INF_FILE                  "INF"
#define REGSTR_DLINFO_CODEBASE                  "CODEBASE"
#define REGSTR_PATH_DIST_UNITS                  "Software\\Microsoft\\Code Store Database\\Distribution Units"
#define REGSTR_DU_CONTAINS_FILES                "Contains\\Files"
#define REGSTR_DU_CONTAINS_JAVA                 "Contains\\Java"
#define REGSTR_DU_CONTAINS_DIST_UNITS           "Contains\\Distribution Units"
#define REGSTR_VALUE_INF                        "INF"
#define REGSTR_VALUE_OSD                        "OSD"
#define REGSTR_INSTALLED_VERSION                "InstalledVersion"
#define REGSTR_VALUE_EXPIRE                     "Expire"
#define REGSTR_SHOW_ALL_FILES                   "ShowAllFiles"


#define MAX_REGPATH_LEN                           2048
#define MAX_CONTROL_NAME_LEN                      1024
#define MAX_MSGBOX_STRING_LEN                     2048
#define MAX_MSGBOX_TITLE_LEN                      256

#define BYTES_MAXSIZE                             32

BOOL IsShowAllFilesEnabled();
void ToggleShowAllFiles();

class CParseInf
{
// Construction
public:
    CParseInf();
    ~CParseInf();

// Data members
protected:
    DWORD m_dwTotalFileSize;
    DWORD m_dwFileSizeSaved;
    DWORD m_dwStatus;           // status value from the STATUS_CTRL set in <cleanoc.h>
    int m_nTotalFiles;
    CFileNode *m_pHeadFileList;
    CFileNode *m_pCurFileNode;
    CFileNode *m_pFileRetrievalPtr;
    CPackageNode *m_pHeadPackageList;
    CPackageNode *m_pCurPackageNode;
    CPackageNode *m_pPackageRetrievalPtr;

    TCHAR m_szInf[MAX_PATH];
    TCHAR m_szFileName[MAX_PATH];
    TCHAR m_szCLSID[MAX_CLSID_LEN];
    BOOL m_bIsDistUnit;
    BOOL m_bHasActiveX;
    BOOL m_bHasJava;
    IJavaPackageManager *m_pijpm;
    BOOL m_bCoInit;
    ULONG m_cExpireDays;

// Operations
public:
    virtual HRESULT DoParse(
        LPCTSTR szOCXFileName,
        LPCTSTR szCLSID);
    virtual HRESULT RemoveFiles(
        LPCTSTR lpszTypeLibID = NULL,
        BOOL bForceRemove = FALSE,
        DWORD dwIsDistUnit = FALSE,
        BOOL bSilent=FALSE);
    virtual DWORD GetTotalFileSize() const;
    virtual DWORD GetTotalSizeSaved() const;
    virtual int GetTotalFiles() const;
    virtual CFileNode* GetFirstFile();
    virtual CFileNode* GetNextFile();
    virtual CPackageNode* GetFirstPackage();
    virtual CPackageNode* GetNextPackage();
    virtual HRESULT DoParseDU(LPCTSTR szOCXFileName, LPCTSTR szCLSID);
    virtual void SetIsDistUnit(BOOL bDist);
    virtual BOOL GetIsDistUnit() const;
    virtual DWORD GetStatus() const;
    virtual BOOL GetHasActiveX(void) { return m_bHasActiveX; };
    virtual BOOL GetHasJava(void) { return m_bHasJava; };
    virtual ULONG GetExpireDays(void) { return m_cExpireDays; }

// private helper methods
protected:
    void Init();
    void DestroyFileList();
    void DestroyPackageList();
    HRESULT FindInf(LPTSTR szInf);
    HRESULT EnumSections();
    BOOL IsSectionInINF( LPCSTR lpCurCode);
    HRESULT HandleSatellites(LPCTSTR pszFileName);
    HRESULT GetFilePath(CFileNode* pFileNode);
    HRESULT ParseSetupHook();
    HRESULT ParseConditionalHook();
    HRESULT ParseUninstallSection(LPCTSTR lpszSection);
    HRESULT BuildDUFileList( HKEY hKeyDU );
    HRESULT BuildDUPackageList( HKEY hKeyDU );
    HRESULT BuildNamespacePackageList( HKEY hKeyNS, LPCTSTR szNamespace );
    HRESULT CheckFilesRemovability(void);
    HRESULT CheckLegacyRemovability( LONG *cOldSharedCount);
    HRESULT CheckDURemovability( HKEY hkeyDU, BOOL bSilent=FALSE );
    HRESULT RemoveLegacyControl( LPCTSTR lpszTypeLibID, BOOL bSilent=FALSE );
    HRESULT RemoveDU( LPTSTR szFullName, LPCTSTR lpszTypeLibID, HKEY hkeyDUDB, BOOL bSilent=FALSE );
    HRESULT CheckDUDependencies(HKEY hKeyDUDB, BOOL bSilent=FALSE);
};

///////////////////////////////////////////////////////////////////////////////
// Structure storing information about an ActiveX control.
//
// szName           -- descriptive name of control (eg. "Circle control")
// szFile           -- full filename of the control 
//                     (eg. "C:\WINDOWS\OCCACHE\CIRC3.INF")
// szCLSID          -- CLSID of control, in a string
// szTypeLibID      -- TypeLib ID of the control, in a string
// dwTotalFileSize  -- total size in bytes of all control-related files
// dwTotalSizeSaved -- total size in bytes restored when the control is removed
// cTotalFiles      -- total number of control-related files, including the
//                     control itself
// parseInf         -- pointer to an instance of class CParseInf, which does
//                     all the jobs of parsing the inf file and removing the
//                     control.  Users of this struct should not in anyway
//                     manipulate this pointer.
//
class CCacheItem : public CParseInf
{
public:
    TCHAR     m_szName[LENGTH_NAME];
    TCHAR     m_szFile[MAX_PATH];
    TCHAR     m_szCLSID[MAX_DIST_UNIT_NAME_LEN];
    TCHAR     m_szTypeLibID[MAX_CLSID_LEN];
    TCHAR     m_szCodeBase[INTERNET_MAX_URL_LENGTH];
    TCHAR     m_szVersion[VERSION_MAXSIZE];

    CCacheItem(void) {};
    virtual ~CCacheItem(void) {};

    virtual DWORD ItemType(void) const = 0;
};

class CCacheLegacyControl : public CCacheItem 
{
public:
    CCacheLegacyControl(void) {};
    virtual ~CCacheLegacyControl(void) {};

    static DWORD s_dwType;

    virtual DWORD ItemType(void) const { return s_dwType; };
    virtual HRESULT Init( HKEY hkeyCLSID, LPCTSTR szFile,  LPCTSTR szCLSID );
};

class CCacheDistUnit : public CCacheLegacyControl 
{
public:
    CCacheDistUnit(void) {};
    virtual ~CCacheDistUnit() {};

    static DWORD s_dwType;

    virtual DWORD ItemType(void) const { return s_dwType; };
    virtual HRESULT Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID, HKEY hkeyDist, LPCTSTR szDU );

    // override this - we'll do this work when we DoParseDU
    virtual HRESULT DoParse( LPCTSTR szOCXFileName, LPCTSTR szCLSID ) { return S_OK; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\persist.cpp ===
#include "folder.h"

///////////////////////////////////////////////////////////////////////////////
// IPersistFolder Methods

HRESULT CControlFolder::GetClassID(LPCLSID lpClassID)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - GetClassID() called."));
    
    // NOTE: Need to split cases here.
    *lpClassID = CLSID_ControlFolder;
    return S_OK;
}

HRESULT CControlFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - Initialize() called."));
    
    if (m_pidl)
        ILFree(m_pidl);

    m_pidl = ILClone(pidlInit);

    if (!m_pidl)
        return E_OUTOFMEMORY;

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
// IPersistFolder2 Methods

HRESULT CControlFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - GetCurFolder() called."));

    if (m_pidl)
        return SHILClone(m_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\dll\makefile.inc ===
..\occache.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "packager"
#define SZ_MODULE           "PACKAGER"
#define DECLARE_DEBUG
#include <debug.h>


#undef DebugMsg
#define DebugMsg TraceMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by occache.rc
//
#define IDS_COL_CONTROL                 0
#define IDM_CTRL_VIEWCONTROL            0
#define IDS_COL_STATUS                  1
#define IDM_CTRL_REMOVECONTROL          1
#define IDS_COL_TOTALSIZE               2
#define IDM_CTRL_PROPERTIES             2
#define IDS_COL_CREATION                3
#define IDM_CTRL_UPDATE                 3
#define IDM_CTRL_SEND_NOTIFY            4
#define IDS_COL_LASTACCESS              4
#define IDS_COL_VERSION                 6
#define IDS_UNKNOWNDATA                 8
#define IDS_STATUS_INSTALLED            9
#define IDS_STATUS_SHARED               10
#define IDS_STATUS_DAMAGED              11
#define IDS_STATUS_UNKNOWN              12
#define IDS_MBTITLE_REMOVECONTROL       13
#define IDS_MBTITLE_SHARED              14
#define IDS_MBTITLE_SHAREVIOLATION      15
#define IDS_MBTITLE_REMOVEFAIL          16
#define IDS_WARNING_SINGLEREMOVAL       17
#define IDS_WARNING_MULTIPLEREMOVAL     18
#define IDS_WARNING_SHARED              19
#define IDS_ERROR_SHAREVIOLATION        20
#define IDS_ERROR_REMOVEFAIL            21
#define IDS_MSG_DEPENDENCY              22
#define IDS_LISTTITLE_FILENAME          23
#define IDS_LISTTITLE_FILESIZE          24
#define IDS_EXTENSION_INF               26
#define IDS_HELP_VIEWCONTROL            27
#define IDS_HELP_REMOVECONTROL          28
#define IDS_HELP_PROPERTIES             29
#define IDM_SORTBYNAME                  30
#define IDS_HELP_SORTBYNAME             30
#define IDM_SORTBYSTATUS                31
#define IDS_HELP_SORTBYSTATUS           31
#define IDM_SORTBYTOTALSIZE             32
#define IDS_HELP_SORTBYTOTALSIZE        32
#define IDM_SORTBYCREATION              33
#define IDS_HELP_SORTBYCREATION         33
#define IDM_SORTBYLASTACCESS            34
#define IDS_HELP_SORTBYLASTACCESS       34
#define IDM_SORTBYVERSION               35
#define IDS_HELP_SORTBYVERSION          35
#define IDS_MSG_SCHEDULING              36
#define IDS_VERSION_PAGE_HEADER         37
#define IDS_HELP_UPDATE                 38
#define IDS_CONTROL_INUSE               39
#define IDS_LISTTITLE_PACKAGENAME       40
#define IDS_ERROR_NOUNINSTALLACTION     41
#define IDS_MBTITLE_NOUNINSTALLACTION   42
#define IDS_STATUS_UNPLUGGED            43
#define IDS_UPDATE_CAPTION              44
#define IDS_WARNING_USERNOACCESS        45
#define IDS_LISTTITLE_NAMESPACE         46
#define IDS_PROPERTY_TYPE_ACTX          47
#define IDS_PROPERTY_TYPE_JAVA          48
#define IDS_PROPERTY_TYPE_MIXED         49
#define IDM_CTRL_SHOWALL                50
#define IDI_REMOTEFLD                   100
#define IDI_DEFAULTOCXICON              101
#define IDD_PROP_DEPENDENCY             101
#define IDI_DEPENDENCY                  102
#define IDD_PROP_GENERAL                102
#define IDR_CONTROLFOLDER               103
#define IDR_POPUP_CONTROLCONTEXT        104
#define IDR_FILE_MERGE                  105
#define IDD_PROP_UPDATE                 106
#define IDD_PROP_VERSION                108
#define IDD_PROP_EXPIRE                 109
#define IDI_DEFAULTJAVAICON             110
#define IDI_DEFAULTMIXEDICON            111
#define IDC_DEPENDENCYLIST              1001
#define IDC_STATIC_DESCRIPTION          1002
#define IDC_STATIC_ICON2                1003
#define IDC_PACKAGELIST                 1003
#define IDC_STATIC_SEPARATOR            1004
#define IDC_STATIC_ICON                 1005
#define IDC_STATIC_LABEL_VERSION        1006
#define IDC_STATIC_VERSION              1007
#define IDC_STATIC_LABEL_CREATION       1008
#define IDC_STATIC_VER_LABEL_DESCRIPTION 1008
#define IDC_STATIC_TYPE                 1009
#define IDC_STATIC_VER_LABEL_COMPANY    1009
#define IDC_STATIC_LABEL_LASTACCESS     1010
#define IDC_STATIC_VER_LABEL_LANGUAGE   1010
#define IDC_STATIC_LASTACCESS           1011
#define IDC_STATIC_VER_LABEL_COPYRIGHT  1011
#define IDC_STATIC_LABEL_TOTALSIZE      1012
#define IDC_STATIC_TOTALSIZE            1013
#define IDC_STATIC_VER_COMPANY          1013
#define IDC_STATIC_LABEL_CLSID          1014
#define IDC_STATIC_VER_LANGUAGE         1014
#define IDC_STATIC_LABEL_TYPE           1015
#define IDC_STATIC_VER_COPYRIGHT        1015
#define IDC_STATIC_LABEL_STATUS         1016
#define IDC_STATIC_STATUS               1017
#define IDC_STATIC_CONTROL              1018
#define IDC_STATIC_CLSID                1019
#define IDC_STATIC_CREATION             1020
#define IDC_CHECK_NEVERUPDATE           1020
#define IDC_CHECK_UPDATEPERIODICALLY    1021
#define IDC_EDIT_UPDATEINTERVAL         1022
#define IDC_STATIC_TIMELABEL            1023
#define IDC_BUTTON_UPDATENOW            1024
#define IDC_STATIC_VER_VERSION          1026
#define IDC_STATIC_VER_DESCRIPTION      1027
#define IDC_STATIC_VER_LABEL_VERSION    1028
#define IDC_STATIC_VER_HEADING          1029
#define IDR_POPUP_CONTROLCONTEXT_NO_UPDATE 1030
/*
#define IDC_STATIC_EXPIRE               1041
#define IDC_EDIT_EXPIRE                 1042
#define IDC_SPIN_EXPIRE                 1043
#define IDC_STATIC_EXPIRE_DAYS          1044
*/
#define IDC_STATIC_LABEL_CODEBASE       1050
#define IDC_STATIC_CODEBASE             1051
#define IDC_STATIC_CONTROLNAME          -1

#define IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL        1060
#define IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN  1061
#define IDS_OCCACHE_WARNING_JAVA_SYSTEM_CLASS         1062
#define IDS_REMOVAL_WARNING                           1063
#define IDS_PROPERTY_BYTES                            1064
#define IDS_KILOBYTE_ABBREV                           1065

//
// AVI files
//

#define IDA_DOWNLOAD            0x4800

//
// Dialogs
//

#define IDD_OCUPDATE            0x5000
#define IDC_DOWNLOADPROGRESS    0x0100
#define IDC_DOWNLOADMSG         0x0101
#define IDC_DOWNLOADANIMATE     0x0102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\utils.cpp ===
#include "general.h"
#include "ParseInf.h"
#include "resource.h"
#include "FileNode.h"
#include <shlwapi.h>
#include <shlobj.h>


//#define USE_SHORT_PATH_NAME   1

// also defined in \nt\private\inet\urlmon\download\isctrl.cxx
LPCTSTR g_lpszUpdateInfo = TEXT("UpdateInfo");
LPCTSTR g_lpszCookieValue = TEXT("Cookie");
LPCTSTR g_lpszSavedValue = TEXT("LastSpecifiedInterval");

// This is a 'private' entry point into URLMON that we use
// to convert paths from their current, possibly short-file-name
// form to their canonical long-file-name form.

extern "C" {
#ifdef UNICODE
#define STR_CDLGETLONGPATHNAME "CDLGetLongPathNameW"

typedef DWORD (STDAPICALLTYPE *CDLGetLongPathNamePtr)(LPWSTR lpszLongPath, LPCWSTR  lpszShortPath, DWORD cchBuffer);

#else // not UNICODE

#define STR_CDLGETLONGPATHNAME "CDLGetLongPathNameA"

typedef DWORD (STDAPICALLTYPE *CDLGetLongPathNamePtr)(LPSTR lpszLong, LPCSTR lpszShort, DWORD cchBuffer);
#endif // else not UNICODE
}


// given the typelib id, loop through HKEY_CLASSES_ROOT\Interface section and
// remove those entries with "TypeLib" subkey equal to the given type lib id
HRESULT CleanInterfaceEntries(LPCTSTR lpszTypeLibCLSID)
{
    Assert(lpszTypeLibCLSID != NULL);
    if (lpszTypeLibCLSID == NULL || lpszTypeLibCLSID[0] == '\0')
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr = S_OK;
    HKEY hkey = NULL;
    DWORD cStrings = 0;
    LONG lResult = ERROR_SUCCESS, lSize = 0;
    TCHAR szKeyName[OLEUI_CCHKEYMAX];
    TCHAR szTmpID[MAX_PATH];

    // open key HKEY_CLASS_ROOT\Interface
    if (RegOpenKeyEx(
             HKEY_CLASSES_ROOT, 
             HKCR_INTERFACE,
             0,
             KEY_ALL_ACCESS,
             &hkey) == ERROR_SUCCESS)
    {
        // loop through all entries
        while ((lResult = RegEnumKey(
                                hkey,
                                cStrings,
                                szKeyName,
                                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
        {
            lSize = MAX_PATH;
            lstrcat(szKeyName, TEXT("\\"));
            lstrcat(szKeyName, HKCR_TYPELIB);

            // if typelib id's match, remove the key
            if ((RegQueryValue(
                       hkey, 
                       szKeyName, 
                       szTmpID, 
                       &lSize) == ERROR_SUCCESS) &&
                (lstrcmpi(szTmpID, lpszTypeLibCLSID) == 0))
            {
                hr = NullLastSlash(szKeyName, 0);
                if (SUCCEEDED(hr))
                {
                    DeleteKeyAndSubKeys(hkey, szKeyName);
                }
            }
            else
            {
                cStrings += 1;
            }
        }

        RegCloseKey(hkey);

        if (SUCCEEDED(hr))
        {            
            if (lResult != ERROR_NO_MORE_ITEMS)
                hr = HRESULT_FROM_WIN32(lResult);
        }
    }

    return hr;
}
    
// If the OCX file being removed does not exist, then we cannot prompt the control
// to unregister itself.  In this case, we call this function of clean up as many
// registry entries as we could for the control.
HRESULT CleanOrphanedRegistry(
                LPCTSTR szFileName, 
                LPCTSTR szClientClsId,
                LPCTSTR szTypeLibCLSID)
{
    HRESULT hr = S_OK;
    LONG lResult = 0;
    TCHAR szTmpID[MAX_PATH];
    TCHAR szTmpRev[MAX_PATH];
    TCHAR szKeyName[OLEUI_CCHKEYMAX+50];
    HKEY hkey = NULL, hkeyCLSID = NULL;
    int nKeyLen = 0;
    DWORD cStrings = 0;
    long lSize = MAX_PATH;

    Assert(lstrlen(szFileName) > 0);
    Assert(lstrlen(szClientClsId) > 0);

    // Delete CLSID keys
    CatPathStrN( szTmpID, HKCR_CLSID, szClientClsId, MAX_PATH );

    if (DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmpID) != ERROR_SUCCESS)
        hr = S_FALSE;   // Keep going, but mark that there was a failure

    // Delete TypeLib info
    if (szTypeLibCLSID != NULL && szTypeLibCLSID[0] != '\0')
    {    
        CatPathStrN( szTmpID, HKCR_TYPELIB, szTypeLibCLSID, MAX_PATH);
        if (DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmpID) != ERROR_SUCCESS)
            hr = S_FALSE;
    }

    // Delete ModuleUsage keys
    // The canonicalizer can fail if the target file isn't there, so in that case, fall back
    // on szFileName, which may well have come in canonical form from the DU file list.
    if ( OCCGetLongPathName(szTmpRev, szFileName, MAX_PATH) == 0 )
        lstrcpy( szTmpRev, szFileName );
    ReverseSlashes(szTmpRev);

    // Guard against the subkey name being empty, as this will cause us to nuke
    // the entire Module Usage subtree, which is a bad thing to do.
    if ( szTmpRev[0] != '\0' )
    {
        CatPathStrN(szTmpID, REGSTR_PATH_MODULE_USAGE, szTmpRev, MAX_PATH);
        if (DeleteKeyAndSubKeys(HKEY_LOCAL_MACHINE, szTmpID) != ERROR_SUCCESS)
            hr = S_FALSE;

        // Delete SharedDLL value
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_SHAREDDLLS,
                    0,
                    KEY_ALL_ACCESS,
                    &hkey) == ERROR_SUCCESS)
        {
            hr = (RegDeleteValue(hkey, szFileName) == ERROR_SUCCESS ? hr : S_FALSE);
            RegCloseKey(hkey);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    // loop through entries under HKEY_CLASSES_ROOT to clear entries
    // whose CLSID subsection is equal to the CLSID of the control
    // being removed
    while ((lResult = RegEnumKey(
                HKEY_CLASSES_ROOT,
                cStrings++,
                szKeyName,
                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
    {
        lSize = MAX_PATH;
        nKeyLen = lstrlen(szKeyName);
        lstrcat(szKeyName, "\\");
        lstrcat(szKeyName, HKCR_CLSID);
        if ((RegQueryValue(
                HKEY_CLASSES_ROOT, 
                szKeyName, 
                szTmpID, &lSize) == ERROR_SUCCESS) &&    
            (lstrcmpi(szTmpID, szClientClsId) == 0))
        {
            szKeyName[nKeyLen] = '\0';
            DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szKeyName);
            lResult = ERROR_NO_MORE_ITEMS;
            break;
        }

    }

    Assert(lResult == ERROR_NO_MORE_ITEMS);
    if (lResult != ERROR_NO_MORE_ITEMS)
        hr = S_FALSE;

    // loop through all HKEY_CLASSES_ROOT\CLSID entries and remove
    // those with InprocServer32 subsection equal to the name of
    // the OCX file being removed
    if (RegOpenKeyEx(
             HKEY_CLASSES_ROOT, 
             HKCR_CLSID,
             0,
             KEY_ALL_ACCESS,
             &hkey) == ERROR_SUCCESS)
    {
        cStrings = 0;
        while ((lResult = RegEnumKey(
                                hkey,
                                cStrings,
                                szKeyName,
                                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
        {
            // check InprocServer32
            lSize = MAX_PATH;
            lstrcat(szKeyName, "\\");
            lstrcat(szKeyName, INPROCSERVER32);
            if ((RegQueryValue(
                       hkey, 
                       szKeyName, 
                       szTmpID, 
                       &lSize) == ERROR_SUCCESS) &&
                (lstrcmpi(szTmpID, szFileName) == 0))
            {
                hr = NullLastSlash(szKeyName, 0);
                if (SUCCEEDED(hr))
                {
                    DeleteKeyAndSubKeys(hkey, szKeyName);
                }
                continue;
            }

            // check LocalServer32
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, LOCALSERVER32);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            // check LocalServerX86
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, LOCALSERVERX86);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            // check InProcServerX86
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, INPROCSERVERX86);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            cStrings += 1;
        }

        RegCloseKey(hkey);

        Assert(lResult == ERROR_NO_MORE_ITEMS);
        if (lResult != ERROR_NO_MORE_ITEMS)
            hr = S_FALSE;
    }

    return hr;
}

// Get from a abbreviated filename its full, long name
// eg. from C:\DOC\MyMath~1.txt to C:\DOC\MyMathFile.txt
// lpszShortFileName must has in it both the file name and its full path
// if bToUpper is TRUE, the name returned will be in uppercase
HRESULT ConvertToLongFileName(
                LPTSTR lpszShortFileName,
                BOOL bToUpper /* = FALSE */)
{
    Assert(lpszShortFileName != NULL);
    if (lpszShortFileName == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr = S_OK;
    WIN32_FIND_DATA filedata;
    TCHAR *pEndPath = NULL;
    HANDLE h = FindFirstFile(lpszShortFileName, &filedata);

    if (h != INVALID_HANDLE_VALUE)
    {
        FindClose(h);

        // separate filename from path
        pEndPath = ReverseStrchr(lpszShortFileName, '\\');
        if (pEndPath != NULL)
        {
            *(++pEndPath) = '\0';
            lstrcat(pEndPath, filedata.cFileName);
        }
        else
        {
            lstrcpy(lpszShortFileName, filedata.cFileName);
        }

        // to upper case if requested
        if (bToUpper)
            CharUpper(lpszShortFileName);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    LONG                - ERROR_SUCCESS if successful
//                        - else, a nonzero error code defined in WINERROR.H
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Manually removing subkeys is needed for NT.  Win95 does that 
//      automatically
//
// This code was stolen from the ActiveX framework (util.cpp).
LONG DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    LONG  lResult;

    lResult = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (lResult != ERROR_SUCCESS)
        return lResult;

    // loop through all subkeys, blowing them away.
    for (/* DWORD c = 0 */; lResult == ERROR_SUCCESS; /* c++ */)
    {
        dwTmpSize = MAX_PATH;
        lResult = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;
        lResult = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    dwTmpSize = MAX_PATH;
    Assert(RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS);
    RegCloseKey(hk);

    lResult = RegDeleteKey(hkIn, pszSubKey);

    return lResult;
}

// return TRUE if file szFileName exists, FALSE otherwise
BOOL FileExist(LPCTSTR lpszFileName)
{
   DWORD dwErrMode;
   BOOL fResult;

   dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   fResult = ((UINT)GetFileAttributes(lpszFileName) != (UINT)-1);

   SetErrorMode(dwErrMode);

   return fResult;
}

// given a flag, return the appropriate directory
// possible flags are:
//      GD_WINDOWDIR    : return WINDOWS directory
//      GD_SYSTEMDIR    : return SYSTEM directory
//      GD_CONTAINERDIR : return directory of app used to view control (ie IE)
//      GD_CACHEDIR     : return OCX cache directory, read from registry
//      GD_CONFLICTDIR  : return OCX conflict directory, read from registry
//      GD_EXTRACTDIR   : require an extra parameter szOCXFullName, 
//                        extract and return its path 
HRESULT GetDirectory(
                UINT nDirType, 
                LPTSTR szDirBuffer, 
                int nBufSize,
                LPCTSTR szOCXFullName /* = NULL */)
{
    LONG lResult = 0;
    TCHAR *pCh = NULL, *pszKeyName = NULL;
    HRESULT hr = S_OK;
    HKEY hkeyIntSetting = NULL;
    unsigned long ulSize = nBufSize;

    switch (nDirType)
    {

    case GD_WINDOWSDIR:
        if (GetWindowsDirectory(szDirBuffer, nBufSize) == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    case GD_SYSTEMDIR:
        if (GetSystemDirectory(szDirBuffer, nBufSize) == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    case GD_EXTRACTDIR:
        if (szOCXFullName == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
            break;
        }
        lstrcpy(szDirBuffer, szOCXFullName);
        pCh = ReverseStrchr(szDirBuffer, '\\');
        if (pCh == NULL)
            hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
        else
            pCh[0] = '\0';
        break;

    case GD_CONTAINERDIR:
        pszKeyName = new TCHAR[MAX_PATH];
        if (pszKeyName == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        CatPathStrN(pszKeyName, REGSTR_PATH_IE, CONTAINER_APP, MAX_PATH);
        if ((lResult = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            pszKeyName,
                            0x0,
                            KEY_READ,
                            &hkeyIntSetting)) == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
                                hkeyIntSetting,
                                VALUE_PATH,
                                NULL,
                                NULL,
                                (unsigned char*)szDirBuffer,
                                &ulSize);
        }
        if (lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);
        else
            szDirBuffer[lstrlen(szDirBuffer)-1] = '\0';  // take away the ending ';'
        delete [] pszKeyName;
        break;

    case GD_CACHEDIR:
    case GD_CONFLICTDIR:
        if ((lResult = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_IE_SETTINGS,
                            0x0,
                            KEY_READ,
                            &hkeyIntSetting)) == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
                                hkeyIntSetting,
                                VALUE_ACTIVEXCACHE,
                                NULL,
                                NULL,
                                (unsigned char*)szDirBuffer,
                                &ulSize);
        }

        hr = (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));

        // if looking for cache dir, append "\\CONFLICT"
        if (SUCCEEDED(hr) && nDirType == GD_CONFLICTDIR)
            lstrcat(szDirBuffer, DEFAULT_CONFLICT);

        break;

    default:
        Assert(FALSE);
        hr = E_UNEXPECTED;
    }

    if (hkeyIntSetting != NULL)
        RegCloseKey(hkeyIntSetting);

    if (FAILED(hr))
        szDirBuffer[0] = '\0';

    return hr;
}

// retrieve file size for file szFile.  Size returne in pSize.
HRESULT GetSizeOfFile(LPCTSTR lpszFile, LPDWORD lpSize)
{
    HANDLE hFile = NULL;
    WIN32_FIND_DATA fileData;

    *lpSize = 0;
    Assert(lpszFile != NULL);

    hFile = FindFirstFile(lpszFile, &fileData);
    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    FindClose(hFile);
    *lpSize = fileData.nFileSizeLow;

    // Get cluster size to calculate the real # of bytes
    // taken up by the file

    DWORD dwSectorPerCluster, dwBytePerSector;
    DWORD dwFreeCluster, dwTotalCluster;
    TCHAR szRoot[4];
    lstrcpyn(szRoot, lpszFile, 4);

    if (!GetDiskFreeSpace(
                    szRoot, &dwSectorPerCluster, &dwBytePerSector, 
                    &dwFreeCluster, &dwTotalCluster))
        return HRESULT_FROM_WIN32(GetLastError());

    DWORD dwClusterSize =  dwSectorPerCluster * dwBytePerSector;
    *lpSize = ((*lpSize/dwClusterSize) * dwClusterSize +
                        (*lpSize % dwClusterSize ? dwClusterSize : 0));

    return S_OK;
}

// Return S_OK is lpszCLSID is in ModuleUsage section of lpszFileName.
// Return E_... otherwise.
// lpszCLSID can be NULL, in this case it does not search for the CLSID.
// If lpszOwner is not NULL, it must point to a buffer which will be
// used to store the owner of the ModuleUsage section for lpszFileName
// dwOwnerSize is the size of the buffer pointed to by lpszOwner .
HRESULT LookUpModuleUsage(
                      LPCTSTR lpszFileName,
                      LPCTSTR lpszCLSID,
                      LPTSTR lpszOwner /* = NULL */, 
                      DWORD dwOwnerSize /* = 0 */)
{
    HKEY hkey = NULL, hkeyMod = NULL;
    HRESULT hr = S_OK;
    TCHAR szBuf[MAX_PATH];
    LONG lResult = ERROR_SUCCESS;

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_READ, 
                        &hkeyMod)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto EXITLOOKUPMODULEUSAGE;
    }


    if ( OCCGetLongPathName(szBuf, lpszFileName, MAX_PATH) == 0 )
        lstrcpyn( szBuf, lpszFileName, MAX_PATH );
    szBuf[256] = '\0'; // truncate if longer than 255 ude to win95 registry bug


    lResult = RegOpenKeyEx(
                        hkeyMod, 
                        szBuf,
                        0, 
                        KEY_READ, 
                        &hkey);
    if (lResult != ERROR_SUCCESS)
    {
        ReverseSlashes(szBuf);
        lResult = RegOpenKeyEx(hkeyMod, szBuf, 0, KEY_READ, &hkey);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

    // Get owner if requested
    if (lpszOwner != NULL)
    {
        DWORD dwSize = dwOwnerSize;
        lResult = RegQueryValueEx(
                            hkey,
                            VALUE_OWNER,
                            NULL,
                            NULL,
                            (unsigned char*)lpszOwner,
                            &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            lpszOwner[0] = '\0';
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

    // see if lpszCLSID is a client of this module usage section
    if (lpszCLSID != NULL)
    {
        lResult = RegQueryValueEx(
                            hkey,
                            lpszCLSID,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

EXITLOOKUPMODULEUSAGE:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return hr;
}

// ReverseSlashes() takes a string, that's assumed to be pointing to a
// valid string and is null-terminated, and reverses all forward slashes
// to backslashes and all backslashes to forward slashes.
void ReverseSlashes(LPTSTR pszStr)
{
    while (*pszStr)
    {
        if (*pszStr == '\\')  *pszStr = '/';
        else if (*pszStr == '/')  *pszStr = '\\';
        pszStr++;
    }
}

// find the last occurance of ch in string szString
TCHAR* ReverseStrchr(LPCTSTR szString, TCHAR ch)
{
    if (szString == NULL || szString[0] == '\0')
        return NULL;
    TCHAR *pCh = (TCHAR*)(szString + lstrlen(szString));
    for (;pCh != szString && *pCh != ch; pCh--);
    return (*pCh == ch ? pCh : NULL);
}

// set the last backslash (or the character offset from that by 1) to NULL
// returns S_OK if fine, E_FAIL if last backslash not found
HRESULT NullLastSlash(LPTSTR pszString, UINT uiOffset)
{
    LPTSTR pszLastSlash;
    HRESULT hr;

    ASSERT(pszString);
    ASSERT((uiOffset == 0) || (uiOffset == 1));

    pszLastSlash = ReverseStrchr(pszString, TEXT('\\'));

    if (!pszLastSlash)
    {
        hr = E_FAIL;
    }
    else
    {        
        *(pszLastSlash + uiOffset) = TEXT('\0');
        hr = S_OK;
    }
    return hr;
}

// If lpszGUID is an owner of the module lpszFileName in Module Usage,
// remove it, updating the .Owner as necessary. If we remove an owner,
// then decrement the SharedDlls count. Never drop the SharedDlls count
// below 1 if the owner is 'Unknown Owner'.
// If modules usage drops to zero, remove MU. If SharedDlls count drops
// to zero, remove that value.
// Return the resulting owner count.
 
DWORD SubtractModuleOwner( LPCTSTR lpszFileName, LPCTSTR lpszGUID )
{
    LONG cRef = 0;
    HRESULT hr = S_OK;
    LONG lResult;
    HKEY hkeyMU = NULL;
    HKEY hkeyMod = NULL;
    TCHAR szBuf[MAX_PATH];
    TCHAR szOwner[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    BOOL bHasUnknownOwner;
    BOOL bGUIDIsOwner;

    Assert(lpszFileName != NULL);
    Assert(lpszGUID != NULL);

    // Get the current ref count, passing -1 to set is a get. Go figure.
    hr = SetSharedDllsCount( lpszFileName, -1, &cRef );
    if ( FAILED(hr) )
        return 1; // in event of failure, say something safe

    // check if Usage section is present for this dll
    // open the file's section we are concerned with

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_ALL_ACCESS, 
                        &hkeyMU)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitSubtractModuleOwner;
    }
    

    if ( OCCGetLongPathName(szBuf, lpszFileName, MAX_PATH) == 0 )
        lstrcpyn( szBuf, lpszFileName, MAX_PATH );

    szBuf[256] = '\0'; // truncate if longer than 255 ude to win95 registry bug
    ReverseSlashes(szBuf);

    // open section for szFileName under ModuleUsage
    if ((lResult = RegOpenKeyEx(
                            hkeyMU, 
                            szBuf,
                            0, 
                            KEY_ALL_ACCESS,
                            &hkeyMod)) != ERROR_SUCCESS)
    {
        goto ExitSubtractModuleOwner;
    }

    dwSize = MAX_PATH;
    if ((lResult = RegQueryValueEx(
                            hkeyMod,
                            VALUE_OWNER,
                            NULL,
                            NULL,
                            (unsigned char*)szOwner,
                            &dwSize)) != ERROR_SUCCESS)
    {
        goto ExitSubtractModuleOwner;
    }

    bHasUnknownOwner = lstrcmp( szOwner, MODULE_UNKNOWN_OWNER ) == 0;

    bGUIDIsOwner = lstrcmp( szOwner, lpszGUID ) == 0;

    // remove the owner value entry, if any.
    lResult = RegDeleteValue(hkeyMod, lpszGUID);
    // if this worked, then we'll need to drop the SharedDlls count,
    // being careful not to let it fall below 1 if bHasUnknownOwner
    if ( lResult == ERROR_SUCCESS )
    {
        if ( !bHasUnknownOwner || cRef > 1 )
            SetSharedDllsCount( lpszFileName, --cRef, NULL );

        if ( cRef > 0 && bGUIDIsOwner )
        {
            DWORD dwEnumIndex; 
            // lpszGUID was the .Owner, now that it's gone, replace it
            // with another owner
            for ( dwEnumIndex = 0, dwSize = MAX_PATH;
                  RegEnumValue(hkeyMod, dwEnumIndex, (char *)szOwner,
                               &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
                  dwEnumIndex++, dwSize = MAX_PATH )
            {
                if (szOwner[0] != '.')
                {
                    lResult = RegSetValueEx( hkeyMod,VALUE_OWNER, 0,
                                             REG_SZ, (LPBYTE)szOwner,
                                             (lstrlen( szOwner ) + 1) * sizeof(TCHAR) );
                    break; // we've done our job
                }
            } // for find a new owner
        } // if there are still owners, but we've nuked the owner of record.
        else if ( cRef == 0 )
        {
            // that was the last ref, so nuke the MU entry
            RegCloseKey( hkeyMod );
            hkeyMod = NULL;
            RegDeleteKey( hkeyMU, szBuf ); // note - we assume this key has no subkeys.

            // Take out the shared DLL's value
            HKEY hkey;

            lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                    REGSTR_PATH_SHAREDDLLS, 0, KEY_ALL_ACCESS,
                                    &hkey);
            if ( lResult == ERROR_SUCCESS )
            {
                ReverseSlashes(szBuf); // revert to file sys
                lResult = RegDeleteValue( hkey, szBuf );
                RegCloseKey( hkey );
            } // if opened SharedDlls
        } // else last reference
    } // if removed an owner

ExitSubtractModuleOwner:

    if (hkeyMU)
        RegCloseKey(hkeyMU);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return cRef;
}

// Set manually the count in SharedDlls.
// If dwCount is < 0, nothing is set.
// If pdwOldCount is non-null, the old count is returned
HRESULT SetSharedDllsCount(
                    LPCTSTR lpszFileName, 
                    LONG cRef, 
                    LONG *pcRefOld /* = NULL */)
{
    HRESULT hr = S_OK;
    LONG lResult = ERROR_SUCCESS;
    DWORD dwSize = 0;
    HKEY hkey = NULL;

    Assert(lpszFileName != NULL);
    if (lpszFileName == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
        goto EXITSETSHAREDDLLSCOUNT;
    }

    if (cRef < 0 && pcRefOld == NULL)
    {
        goto EXITSETSHAREDDLLSCOUNT;
    }

    // open HKLM, Microsoft\Windows\CurrentVersion\SharedDlls
    lResult = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, 
                    REGSTR_PATH_SHAREDDLLS, 0, KEY_ALL_ACCESS,
                    &hkey);

    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto EXITSETSHAREDDLLSCOUNT;
    }

    // if pdwOldCount is not NULL, save the old count in it
    if (pcRefOld != NULL)
    {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(
                    hkey,
                    lpszFileName,
                    0,
                    NULL,
                    (unsigned char*)pcRefOld,
                    &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            *pcRefOld = 0;
            hr = S_FALSE;
            goto EXITSETSHAREDDLLSCOUNT;
        }
    }

    // if dwCount >= 0, set it as the new count
    if (cRef >= 0)
    {
        lResult = RegSetValueEx(
                     hkey, 
                     lpszFileName, 
                     0, 
                     REG_DWORD, 
                     (unsigned char*)&cRef, 
                     sizeof(DWORD)); 
        if (lResult != ERROR_SUCCESS)
        {
            hr = S_FALSE;
            goto EXITSETSHAREDDLLSCOUNT;
        }
    }

EXITSETSHAREDDLLSCOUNT:

    if (hkey != NULL)
        RegCloseKey(hkey);

    return hr;
}

// UnregisterOCX() attempts to unregister a DLL or OCX by calling LoadLibrary
// and then DllUnregisterServer if the LoadLibrary succeeds.  This function
// returns TRUE if the DLL or OCX could be unregistered or if the file isn't
// a loadable module.
HRESULT UnregisterOCX(LPCTSTR pszFile)
{
    HINSTANCE hLib;
    HRESULT hr = S_OK;
    HRESULT (FAR STDAPICALLTYPE * pUnregisterEntry)(void);

    hLib = LoadLibrary(pszFile);

    if (hLib == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        (FARPROC &) pUnregisterEntry = GetProcAddress(
            hLib,
            "DllUnregisterServer"
            );

        if (pUnregisterEntry != NULL)
        {
            hr = (*pUnregisterEntry)();
        }

        FreeLibrary(hLib);
    }

    return hr;
}

// Return S_OK if dll can be removed, or S_FALSE if it cannot.
// Return E_... if an error has occured
HRESULT UpdateSharedDlls(LPCTSTR szFileName, BOOL bUpdate)
{
    HKEY hkeySD = NULL;
    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD dwRef = 1;
    DWORD dwSize = sizeof(DWORD);
    LONG lResult;

    // get the main SHAREDDLLS key ready; this is never freed!
    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, REGSTR_PATH_SHAREDDLLS,
                        0, KEY_ALL_ACCESS, &hkeySD)) != ERROR_SUCCESS)
    {
        hkeySD = NULL;
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitUpdateSharedDlls;
    }

    // now look for szFileName
    lResult = RegQueryValueEx(hkeySD, szFileName, NULL, &dwType, 
                        (unsigned char*)&dwRef, &dwSize);

    if (lResult != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto ExitUpdateSharedDlls;
    }

    // decrement reference count by 1.
    //
    // if (count equals to 0) 
    //    if (bUpdate is TRUE)
    //         remove the key from SharedDlls
    //    return S_OK
    // otherwise
    //    if (bUpdate is TRUE)
    //       update the count
    //    return S_FALSE

    if ((--dwRef) > 0)
    {
        hr = S_FALSE;
        if (bUpdate &&
            (lResult = RegSetValueEx(hkeySD, szFileName, 0, REG_DWORD,
                        (unsigned char *)&dwRef, sizeof(DWORD))) != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
         }
        goto ExitUpdateSharedDlls;
    }

    Assert(dwRef == 0);

    // remove entry from SharedDlls
    if (bUpdate &&
        (lResult = RegDeleteValue(hkeySD, szFileName)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitUpdateSharedDlls;
    }
 
ExitUpdateSharedDlls:

    if (hkeySD)
        RegCloseKey(hkeySD);

    return hr;
}

void RemoveList(LPCLSIDLIST_ITEM lpListHead)
{
    LPCLSIDLIST_ITEM lpItemPtr = NULL; 
    while (TRUE)
    {
        lpItemPtr = lpListHead;
        if (lpItemPtr == NULL)
            break;
        lpListHead = lpItemPtr->pNext;
        delete lpItemPtr;
    }
    lpListHead = NULL;
}

BOOL ReadInfFileNameFromRegistry(
                             LPCTSTR lpszCLSID, 
                             LPTSTR lpszInf,
                             LONG nBufLen)
{
    if (lpszCLSID == NULL || lpszInf == NULL)
        return FALSE;

    HKEY hkey = NULL;
    TCHAR szKey[100];
    LONG lResult = ERROR_SUCCESS;

    CatPathStrN( szKey, HKCR_CLSID, lpszCLSID, 100);
    CatPathStrN( szKey, szKey, INFFILE, 100);

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return FALSE;

    lResult = RegQueryValue(hkey, NULL, lpszInf, &nBufLen);
    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS)
    {
        lpszInf[0] = '\0';
    }

    if (lpszInf[0] == '\0')
        return FALSE;

    return TRUE;
}

BOOL WriteInfFileNameToRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf)
{
    if (lpszCLSID == NULL)
        return FALSE;

    HKEY hkey = NULL;
    LONG lResult = ERROR_SUCCESS;
    TCHAR szKey[100];
    
    CatPathStrN(szKey, HKCR_CLSID, lpszCLSID, 100);
    CatPathStrN(szKey, szKey, INFFILE, 100);

    if (RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey) != ERROR_SUCCESS)
        return FALSE;

    lResult = RegSetValue(
                         hkey,
                         NULL,
                         REG_SZ,
                         (lpszInf == NULL ? TEXT("") : lpszInf),
                         (lpszInf == NULL ? 0 : lstrlen(lpszInf)));
    RegCloseKey(hkey);

    return (lResult == ERROR_SUCCESS);
} 

// Define a macro to make life easier
#define QUIT_IF_FAIL if (FAILED(hr)) goto Exit


HRESULT
ExpandVar(
    LPCSTR& pchSrc,          // passed by ref!
    LPSTR& pchOut,          // passed by ref!
    DWORD& cbLen,           // passed by ref!
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    HRESULT hr = S_FALSE;
    int cbvar = 0;

    Assert (*pchSrc == '%');

    for (int i=0; szVars[i] && (cbvar = lstrlen(szVars[i])) ; i++) { // for each variable

        int cbneed = 0;

        if ( (szValues[i] == NULL) || !(cbneed = lstrlen(szValues[i])))
            continue;

        cbneed++;   // add for nul

        if (0 == strncmp(szVars[i], pchSrc, cbvar)) {

            // found something we can expand

                if ((cbLen + cbneed) >= cbBuffer) {
                    // out of buffer space
                    *pchOut = '\0'; // term
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                lstrcpy(pchOut, szValues[i]);
                cbLen += (cbneed -1); //don't count the nul

                pchSrc += cbvar;        // skip past the var in pchSrc
                pchOut += (cbneed -1);  // skip past dir in pchOut

                hr = S_OK;
                goto Exit;

        }
    }

Exit:

    return hr;
    
}

// from urlmon\download\hooks.cxx (ExpandCommandLine and ExpandVars)
// used to expand variables
HRESULT
ExpandCommandLine(
    LPCSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    Assert(cbBuffer);


    HRESULT hr = S_FALSE;

    LPCSTR pchSrc = szSrc;     // start parsing at begining of cmdline

    LPSTR pchOut = szBuf;       // set at begin of out buffer
    DWORD cbLen = 0;

    while (*pchSrc) {

        // look for match of any of our env vars
        if (*pchSrc == '%') {

            HRESULT hr1 = ExpandVar(pchSrc, pchOut, cbLen, // all passed by ref!
                cbBuffer, szVars, szValues);  

            if (FAILED(hr1)) {
                hr = hr1;
                goto Exit;
            }


            if (hr1 == S_OK) {    // expand var expanded this
                hr = hr1;
                continue;
            }
        }
            
        // copy till the next % or nul
        if ((cbLen + 1) < cbBuffer) {

            *pchOut++ = *pchSrc++;
            cbLen++;

        } else {

            // out of buffer space
            *pchOut = '\0'; // term
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;

        }


    }

    *pchOut = '\0'; // term


Exit:

    return hr;
}
// Find dependent DLLs in ModuleUsage
// given the clsid it will enumerate all the DLLs in the ModuleUsage
// that were used by this clsid
HRESULT FindDLLInModuleUsage(
      LPTSTR lpszFileName,
      LPCTSTR lpszCLSID,
      DWORD &iSubKey)
{
    HKEY hkey = NULL, hkeyMod = NULL;
    HRESULT hr = S_OK;
    TCHAR szBuf[MAX_PATH];
    LONG lResult = ERROR_SUCCESS;

    if (lpszCLSID == NULL) {
        hr = E_INVALIDARG;  // req clsid
        goto Exit;
    }

    // get the main MODULEUSAGE key
    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_READ, 
                        &hkeyMod)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    while ( ((lResult = RegEnumKey(
                            hkeyMod, 
                            iSubKey++,
                            szBuf, 
                            MAX_PATH)) == ERROR_SUCCESS) ) {

        lResult = RegOpenKeyEx(
                            hkeyMod, 
                            szBuf,
                            0, 
                            KEY_READ, 
                            &hkey);

        if (lResult != ERROR_SUCCESS)
            break;

        // see if lpszCLSID is a client of this module usage section
        lResult = RegQueryValueEx(
                            hkey,
                            lpszCLSID,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lResult == ERROR_SUCCESS)
        {
            // got the filename, return it
            lstrcpy(lpszFileName, szBuf);
            goto Exit;
        }

        if (hkey) {
            RegCloseKey(hkey);
            hkey = NULL;
        }

    } // while

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
    }

Exit:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return hr;
}

BOOL PatternMatch(LPCTSTR szModName, LPTSTR szSectionName)
{

    LPCTSTR pch = ReverseStrchr(szModName, '/');
    DWORD len = 0;

    if (!pch)
        pch = szModName;
    else
        pch++;

    // pch points at base name of module

    if ((len = lstrlen(pch)) != (DWORD)lstrlen(szSectionName))
        return FALSE;

    LPTSTR pchSecStar = StrChr(szSectionName, '*'); 

    Assert(pchSecStar);

    DWORD cbLen1 = (DWORD) (pchSecStar - szSectionName);

    // compare upto '*'
    if (StrCmpNI(szSectionName, pch, cbLen1) != 0) 
        return FALSE;

    // compare after the 3 stars
    if ( (cbLen1 + 3) < len) // *s not at end
        if (StrCmpNI(pchSecStar+3, pch + (cbLen1+3), len -(cbLen1+3)) != 0) 
            return FALSE;

    // simlar strings but for the stars.

    // modify the szSectionName to hold the value for the stars
    // in-effect this will substitute the original variable with
    // the value that was used when installing the OCX

    lstrcpy(pchSecStar, pch + cbLen1);

    return TRUE;
}

DWORD OCCGetLongPathName( LPTSTR szLong, LPCTSTR szShort, DWORD cchBuffer )
{
    DWORD   dwLen = 0;
    HMODULE hmodUrlMon;
    CDLGetLongPathNamePtr pfnGetLongPathName = NULL;

    hmodUrlMon = LoadLibrary( "URLMON.DLL" );

    // Set up our globals with short and long versions of the base cache path 
    if ( hmodUrlMon != NULL ) {
        pfnGetLongPathName = (CDLGetLongPathNamePtr)GetProcAddress(hmodUrlMon, (LPCSTR)STR_CDLGETLONGPATHNAME );
 
        if ( pfnGetLongPathName != NULL ) {
            dwLen = pfnGetLongPathName( szLong, szShort, cchBuffer );
        }  
        FreeLibrary( hmodUrlMon );
    }

    return dwLen;
}

TCHAR *CatPathStrN( TCHAR *szDst, const TCHAR *szHead, const TCHAR *szTail, int cchDst )
{
    TCHAR *szRet = szDst;
    int cchHead = lstrlen(szHead);
    int cchTail = lstrlen(szTail);

    if ( cchHead + cchTail >= (cchDst - 2) ) {// - 2 for / and null
        Assert(FALSE);
        szRet = NULL;
        *szDst = 0;
    }
    else { // we know the whole thing is safe
        lstrcpy(szDst, szHead);
        lstrcpy(&szDst[cchHead], TEXT("\\"));
        lstrcpy(&szDst[cchHead + 1], szTail);
    }

    return szRet;
}

BOOL IsCanonicalName( LPTSTR szName )
{
    // simple test - if there's a ~ in it, it has a contraction in it
    // and is therefore non-canonical
    for ( ; *szName != '\0' && *szName != '~'; szName++ );
    
    return *szName != '~';
};

struct RegPathName {
    LPTSTR   m_szName;
    LPTSTR   m_szCanonicalName;

    RegPathName(void) : m_szName(NULL), m_szCanonicalName(NULL)
    {};
    ~RegPathName()
    {
         if ( m_szName )
            delete m_szName;

         if ( m_szCanonicalName )
            delete m_szCanonicalName;
    };

    void MakeRegFriendly( LPTSTR szName )
    {
        TCHAR *pch;
        // If szName is going to be a reg key name, we can't have it lookin' like a path
        for ( pch = szName; *pch != '\0'; pch++ )
            if ( *pch == '\\' ) *pch = '/';
    }

    void MakeFileSysFriendly( LPTSTR szName )
    {
        TCHAR *pch;
        // change the slashes back into DOS
        // directory \'s
        for ( pch = szName; *pch != '\0'; pch++ )
            if ( *pch == '/' ) *pch = '\\';
    }

    BOOL FSetCanonicalName(void)
    {
        BOOL fSet = FALSE;
        TCHAR *szT = new TCHAR[MAX_PATH];

        if ( m_szName != NULL && szT != NULL ) {
            LPITEMIDLIST pidl = NULL;
            // WE jump through some hoops to get the all-long
            // name version of szName. First we convert it to
            // an ITEMIDLIST.

            // but first, we must change the slashes back into DOS
            // directory \'s
            MakeFileSysFriendly( m_szName );
            if ( OCCGetLongPathName( szT, m_szName, MAX_PATH ) != 0 ) {
                m_szCanonicalName = szT;
                fSet = TRUE;
            } else
                delete [] szT;

            // restore m_szName to it's registry-friendly form
            MakeRegFriendly( m_szName );
 
        } // if we can get our temp string

        if ( fSet ) { // whatever its source, our canonical form has reversed slashes
           MakeRegFriendly( m_szCanonicalName );
        }
        return fSet;
    };

    BOOL FSetName( LPTSTR szName, int cchName )
    {
        BOOL fSet = FALSE;

        if ( m_szName != NULL ) {
            delete m_szName;
            m_szName = NULL;
        }

        if ( m_szCanonicalName != NULL ) {
            delete m_szCanonicalName;
            m_szCanonicalName = NULL;
        }

        // we got a short name, so szName is the short name
        m_szName = new TCHAR[cchName + 1];
        if ( m_szName != NULL ) {
            lstrcpy( m_szName, szName );
            fSet = FSetCanonicalName();
        }

        return fSet;
    };
}; 

struct ModuleUsageKeys : public RegPathName {
    ModuleUsageKeys   *m_pmukNext;
    HKEY              m_hkeyShort; // key with the short file name name

    ModuleUsageKeys(void) : m_pmukNext(NULL), m_hkeyShort(NULL) {};
    ~ModuleUsageKeys(void)
    {
        if ( m_hkeyShort )
            RegCloseKey( m_hkeyShort );
    };

    HRESULT MergeMU( HKEY hkeyCanon, HKEY hkeyMU )
    {
        HRESULT hr = E_FAIL;
        DWORD   dwIndex = 0;
        DWORD   cchNameMax;
        DWORD   cbValueMax;

        if ( RegQueryInfoKey( m_hkeyShort,
                              NULL, NULL, NULL, NULL, NULL, NULL,
                              &dwIndex, &cchNameMax, &cbValueMax,
                              NULL, NULL ) == ERROR_SUCCESS ) {
            LPTSTR szName = new TCHAR[cchNameMax + 1];

            if (szName != NULL)
            {
                LPBYTE lpbValue = new BYTE[cbValueMax];

                if (lpbValue != NULL)
                {
                    // Examine each value.
                    for ( dwIndex--, hr = S_OK; (LONG)dwIndex >= 0 && SUCCEEDED(hr); dwIndex-- ) {
                        LONG  lResult;
                        DWORD cchName = cchNameMax + 1;
                        DWORD dwType;
                        DWORD dwSize = cbValueMax;
 
                        /