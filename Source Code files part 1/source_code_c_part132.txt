

    if (Status == ERROR_SUCCESS)
    {
        pRootFolder->ReleaseReference();

        Status = ERROR_FILE_EXISTS;

        return Status;
    }


    Status = GetNewStandaloneRegistryKey( MachineName,
                                          TRUE, // write permission required
                                          NULL,
                                          &StdDfsKey );
    if (Status == ERROR_SUCCESS)
    {
         UNICODE_STRING LogicalName;

         RtlInitUnicodeString( &LogicalName, LogicalShare );
         StoreInitializeNameInformation( &NameInfo,
                                         &LogicalName,
                                         NULL,
                                         Comment );
         NameInfo.Type |= 0x80;

         StoreInitializeReplicaInformation( &ReplicaListInfo,
                                            &ReplicaInfo,
                                            (MachineName == NULL) ? L"." : MachineName,
                                            LogicalShare );
    }
    
    if (Status == ERROR_SUCCESS) {
#if defined (DFS_FUTURES)
        //
        // Check if we need to store the root as a guid instead of
        // the root name itself.
        // It is probably not necessary, but for some reason if we need
        // to, we can scavenge this code.
        //
        //
        // get an unique metadata name for the root.
        //

        Status = DfsGenerateUuidString(&UuidString);
#endif

        Status = RegCreateKeyEx( StdDfsKey,
                                 LogicalShare,
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &StdDfsShareKey,
                                 NULL );
            
        if (Status == ERROR_SUCCESS) 
        {
            size_t LogicalShareCchLength = 0;
                
            Status = DfsStringCchLength( LogicalShare, 
                                      MAXUSHORT, 
                                      &LogicalShareCchLength );
            if (Status == ERROR_SUCCESS)
            {
                LogicalShareCchLength++; // NULL Terminator
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsRootShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)LogicalShare,
                                        LogicalShareCchLength * sizeof(WCHAR) );
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsLogicalShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)LogicalShare,
                                        LogicalShareCchLength * sizeof(WCHAR) );
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = CreateNameInformationBlob( &NameInfo,
                                                    &pBlob,
                                                    &BlobSize);
                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( StdDfsShareKey,
                                          NULL,
                                          DfsRegistryNameString,
                                          pBlob,
                                          BlobSize );
                    ReleaseMetadataNameBlob(pBlob, BlobSize );
                }
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = CreateReplicaListInformationBlob( &ReplicaListInfo,
                                                           &pBlob,
                                                           &BlobSize);
                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( StdDfsShareKey,
                                          NULL,
                                          DfsRegistryReplicaString,
                                          pBlob,
                                          BlobSize );
                    ReleaseMetadataNameBlob( pBlob, BlobSize );
                }
            }
                
            if (Status == ERROR_SUCCESS)
            {
                Status = GetRootFolder( MachineName,
                                        LogicalShare,
                                        &DfsShare,
                                        &DfsShare,
                                        &pRootFolder );
                                              
                if (Status == ERROR_SUCCESS)
                {
                    //
                    // Now, acquire the root share directory. If we fail
                    // this, we deny the creation of the root.
                    // acquire root share directory converts the root share
                    // to a physical path, checks if that supports
                    // reparse points, and if so tells the dfs driver
                    // to attach to the drive.
                    // if any of these fail, we cannot proceed.
                    //
                    Status = pRootFolder->AcquireRootShareDirectory();

                    if (Status != ERROR_SUCCESS)
                    {
                        //
                        // make a best effort to remove ourselves
                        // dont care about status return, thoug
                        // we may want to log it. 
                        //dfsdev: add logging.
                        //
                        RemoveRootFolder(pRootFolder,
                                         TRUE ); // permanent removal
                    }
                    
                    //
                    // now mark the root folder as synchronized:
                    // this is true since this root is empty.
                    //
                    if (Status == ERROR_SUCCESS)
                    {
                        pRootFolder->SetRootFolderSynchronized();
                    }

                    pRootFolder->ReleaseReference();
                }

                DFSLOG("Add Standalone Root, adding root folder status %x\n", Status);
            }

            RegCloseKey( StdDfsShareKey );
            if (Status != ERROR_SUCCESS)
            {
                RegDeleteKey( StdDfsKey,
                              LogicalShare );
            }
        }

#if defined (DFS_FUTURES)
        DfsReleaseUuidString(&UuidString);
#endif

        RegCloseKey( StdDfsKey );
    }
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "registry store, create root %ws, status %x\n", LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsRegistryStore::DeleteStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR LogicalShare )

{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY DfsKey = NULL;
    DfsRootFolder *pRootFolder = NULL;
    LPWSTR RootRegistryName = NULL;
    LPWSTR UseChildName = NULL;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Delete Standalone root %ws\n", LogicalShare);

    Status = DfsRtlInitUnicodeStringEx( &DfsMachine, MachineName );
    if(Status != ERROR_SUCCESS)
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "DeleteStandaloneRoot, DfsRtlInitUnicodeStringEx - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsShare, LogicalShare );
    if(Status != ERROR_SUCCESS)
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "DeleteStandaloneRoot, DfsRtlInitUnicodeStringEx - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }

    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "Delete Standalone root, lookup root %p, status %x\n", pRootFolder, Status);

    if (Status == ERROR_SUCCESS)
    {
        Status = pRootFolder->AcquireRootLock();
        if (Status == ERROR_SUCCESS)
        {
            pRootFolder->SetRootFolderDeleteInProgress();
            pRootFolder->ReleaseRootLock();
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        RootRegistryName = pRootFolder->GetRootRegKeyNameString();

        UseChildName = (IsEmptyString(RootRegistryName) == TRUE) ? NULL : RootRegistryName;

        if (UseChildName == NULL)
        {
            Status = GetOldDfsRegistryKey( MachineName,
                                           TRUE,
                                           NULL,
                                           &DfsKey );
            if (Status == ERROR_SUCCESS)
            {
                Status = SHDeleteKey( DfsKey,
                                      DfsOldStandaloneChild);

                RegCloseKey( DfsKey );
            }
        }
        else
        {
            Status = GetNewStandaloneRegistryKey( MachineName,
                                                  TRUE,
                                                  NULL,
                                                  &DfsKey );
            if (Status == ERROR_SUCCESS)
            {
                Status = SHDeleteKey( DfsKey,
                                      UseChildName );
                                      
                RegCloseKey( DfsKey );
            }

        }
    }

    //
    // DfsDev: needs fixing.
    //
    if (Status == ERROR_SUCCESS)
    {
        NTSTATUS DeleteStatus;

        //
        // Release the root folder that we had acquired earlier for
        // this root.
        //

        DeleteStatus = RemoveRootFolder( pRootFolder,
                                         TRUE ); // permanent removal

        DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "remove root folder %p (%ws) status %x\n", pRootFolder, LogicalShare, DeleteStatus);

        
        DeleteStatus = pRootFolder->ReleaseRootShareDirectory();
        DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "release root share for %ws status %x\n", LogicalShare, DeleteStatus);

        pRootFolder->ReleaseReference();
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Delete Standalone root for %ws, done, status %x\n", LogicalShare, Status);
    return Status;
}



DFSSTATUS
DfsRegistryStore::EnumerateApiLinks(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    LPDWORD pEntriesToRead,
    LPDWORD pResumeHandle,
    PLONG pSizeRequired )
{
    HKEY DfsKey = NULL;
    ULONG ChildNum = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN OverFlow = FALSE;
    LONG HeaderSize = 0;
    LONG EntriesRead = 0;
    LONG EntriesToRead = *pEntriesToRead;
    LONG SizeRequired = 0;
    LONG EntryCount = 0;

    LPBYTE pLinkBuffer = NULL;
    LONG LinkBufferSize = 0;

    LPBYTE CurrentBuffer = NULL;
    LPBYTE NewBuffer = NULL;
    LONG SizeRemaining = 0;
    DFSSTATUS PackStatus = ERROR_SUCCESS;
    
    ULONG_PTR SizeDiff;
    DWORD CchMaxName = 0;
    DWORD CchChildName = 0;
    LPWSTR ChildName = NULL;
    
    Status = DfsApiSizeLevelHeader( Level, &HeaderSize );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    DfsKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    OverFlow = FALSE;

    SizeRequired = ROUND_UP_COUNT(EntriesToRead * HeaderSize, ALIGN_QUAD);
    if (EntriesToRead * HeaderSize < BufferSize )
    {
        CurrentBuffer = (LPBYTE)((ULONG_PTR)pBuffer + EntriesToRead * HeaderSize);
        SizeRemaining = BufferSize - EntriesToRead * HeaderSize;
    }
    else 
    {
        CurrentBuffer = pBuffer;
        SizeRemaining = 0;
        OverFlow = TRUE;
    }


    if(pResumeHandle)
    {
        EntryCount = *pResumeHandle;
    }

    if (EntryCount == 0)
    {
        Status = GetStoreApiInformationBuffer ( DfsHandle,
                                                pRootName,
                                                NULL,
                                                Level,
                                                &pLinkBuffer,
                                                &LinkBufferSize );
        if (Status == ERROR_SUCCESS)
        {
            SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);

            if (OverFlow == FALSE)
            {
                PackStatus = PackageEnumerationInfo( Level,
                                                     EntriesRead,
                                                     pLinkBuffer,
                                                     pBuffer,
                                                     &CurrentBuffer,
                                                     &SizeRemaining );
                if (PackStatus == ERROR_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                }
                NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                SizeDiff = (NewBuffer - CurrentBuffer);
                if ((LONG)SizeDiff > SizeRemaining)
                {
                    SizeRemaining = 0;
                }
                else 
                {
                    SizeRemaining -= (LONG)SizeDiff;
                }
                CurrentBuffer = NewBuffer;
            }
            ReleaseStoreApiInformationBuffer( pLinkBuffer );
            EntryCount++;
            EntriesRead++;
        }
    }

    if (Status != ERROR_SUCCESS )
    {
        return Status;
    }
    ChildNum = EntryCount - 1;

    //
    // First find the length of the longest subkey 
    // and allocate a buffer big enough for it.
    //
    Status = RegQueryInfoKey( DfsKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              &CchMaxName,  // max size of subkey name in TCHARs
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              NULL,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        CchMaxName++; // Space for the NULL terminator.
        ChildName = (LPWSTR) new WCHAR [CchMaxName];
        if (ChildName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (Status == ERROR_SUCCESS)
    {           
        do
        {
            //
            // For each child, get the child name.
            //

            if (EntriesToRead && EntriesRead >= EntriesToRead)
            {
                break;
            }

            CchChildName = CchMaxName;
            //
            // Now enumerate the children, starting from the first child.
            //
            Status = RegEnumKeyEx( DfsKey,
                                   ChildNum,
                                   ChildName,
                                   &CchChildName,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL );

            ChildNum++;

            if (Status == ERROR_SUCCESS)
            {
                Status = GetStoreApiInformationBuffer( DfsHandle,
                                                       pRootName,
                                                       ChildName,
                                                       Level,
                                                       &pLinkBuffer,
                                                       &LinkBufferSize );

                if (Status == ERROR_SUCCESS)
                {
                    SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);
                    
                    if (OverFlow == FALSE) 
                    {
                        PackStatus = PackageEnumerationInfo( Level,
                                                             EntriesRead,
                                                             pLinkBuffer,
                                                             pBuffer,
                                                             &CurrentBuffer,
                                                             &SizeRemaining );
                        if (PackStatus == ERROR_BUFFER_OVERFLOW)
                        {
                            OverFlow = TRUE;
                        }
                        NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                        SizeDiff = (NewBuffer - CurrentBuffer);
                        if ((LONG)SizeDiff > SizeRemaining)
                        {
                            SizeRemaining = 0;
                        }
                        else 
                        {
                            SizeRemaining -= (LONG)SizeDiff;
                        }
                        CurrentBuffer = NewBuffer;
                    }

                    ReleaseStoreApiInformationBuffer( pLinkBuffer );
                    EntryCount++;
                    EntriesRead++;
                }
            }
        } while (Status == ERROR_SUCCESS);

        delete [] ChildName;
    }
    
    *pSizeRequired = SizeRequired;

    
    if (Status == ERROR_NO_MORE_ITEMS) 
    {
        if (EntriesRead) 
        {
            if (OverFlow) 
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                Status = ERROR_SUCCESS;
            }
        }

    }
    else if (OverFlow)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        if(pResumeHandle)
        {
            *pResumeHandle = EntryCount;
        }

        *pEntriesToRead = EntriesRead;
    }

    return Status;
}






DFSSTATUS
DfsRegistryStore::GetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID *ppData,
    PULONG pDataSize,
    PFILETIME pLastModifiedTime )
    {
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = GetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryNameString,
                          ppData,
                          pDataSize,
                          pLastModifiedTime );

    return Status;
}


DFSSTATUS
DfsRegistryStore::GetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID *ppData,
    PULONG pDataSize,
    PFILETIME pLastModifiedTime )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = GetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryReplicaString,
                          ppData,
                          pDataSize,
                          pLastModifiedTime );

    return Status;
}



DFSSTATUS
DfsRegistryStore::SetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pData,
    ULONG DataSize )

{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = SetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryNameString,
                          pData,
                          DataSize );
    return Status;
}


DFSSTATUS
DfsRegistryStore::SetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pData,
    ULONG DataSize )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = SetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryReplicaString,
                          pData,
                          DataSize );

    return Status;
}

//
//  This removes the target share from the 
//  Microsoft\Dfs\Roots\Domain registry key.
//
DFSSTATUS
DfsRegistryStore::CleanRegEntry(
    LPWSTR MachineName,
    LPWSTR LogicalShare
    )
{
    HKEY DfsKey;
    DFSSTATUS Status;
    DFSSTATUS RetStatus = ERROR_NOT_FOUND;
    HKEY DfsDriverKey;
    
    //
    // If we can open the old registry key,
    // then we assume we are dealing with an
    // old style single root standalone system.
    //
    Status = GetDfsRegistryKey (MachineName,
                                  DfsRegistryHostLocation, //DfsHost
                                  TRUE,
                                  NULL,
                                  &DfsKey );
    //
    // Delete the \DfsHost\Volumes key and all its values.
    //
    if (Status == ERROR_SUCCESS)
    {
        
        Status = SHDeleteKey( DfsKey,
                             DfsVolumesLocation );

        RegCloseKey( DfsKey );

        if (Status == ERROR_SUCCESS)
        {   
            // Something succeeded. We'll return that.
            RetStatus = Status;
            
            // Delete the DfsDriver\LocalVolumes key as well.
            Status = GetDfsRegistryKey (MachineName,
                                  DfsRegistryDfsDriverLocation, //System\CCS\Services\DfsDriver
                                  TRUE,
                                  NULL,
                                  &DfsDriverKey );
            //
            // Delete the \LocalVolumes key and all its values.
            //
            if (Status == ERROR_SUCCESS)
            {
                Status = SHDeleteKey( DfsDriverKey,
                                     DfsLocalVolumesValue );
                RegCloseKey( DfsDriverKey );

                // We don't bother to recreate the DfsHost\Volumes key on error. For all external
                // purposes the root should have disappeared now.
            }
        }
    }
    
    //
    // BUG 732833: Clean .Net location whether the Win2K location exists or not.
    // We need both locations to co-exist on mix-mode cluster machines.
    //
    Status = GetNewStandaloneRegistryKey( MachineName,
                                          TRUE,
                                          NULL,
                                          &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = SHDeleteKey( DfsKey,
                             LogicalShare );
        if (Status == ERROR_SUCCESS)
        {
            RetStatus = Status;
        }
        RegCloseKey( DfsKey );
    }
    

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, CleanRegistry %ws status=%d\n", MachineName, Status);

    return RetStatus;

    UNREFERENCED_PARAMETER( LogicalShare );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssite.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "dsgetdc.h"
#include "lm.h"
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <winsock2.h>
#include <DfsSiteCache.hxx>
#include <DfsSiteCostCache.hxx>
#include <DfsSiteNameSupport.hxx>
#include <DfsSite.hxx>

//
// logging includes.
//

#include "DfsSite.tmh" 

#define _Dfs_LocalAddress 0x0100007f //localaddress (127.0.0.1)

//
// Given the sitename initialize this site.
// We'll also calculate the corresponding hashvalue
// for future use. The SiteCostCache for this site
// will be allocated also. It'll get populated as we get
// referrals.
//

DFSSTATUS
DfsSite::Initialize( 
    IN PUNICODE_STRING pSiteName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
     
    // 
    // Copy the sitename. It's ok if this is NULL.
    //
    Status = DfsCreateUnicodeString(&_SiteName, pSiteName);
    if (Status != ERROR_SUCCESS)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Pre-calculate that wonderful hash value.
    CalcHash();

    Status = DfsSiteCostSupport::DfsCreateSiteCostSupport( &_pSiteCostSupport );
    return Status;
}

//
//
//
VOID
DfsSite::GetDefaultSiteCost( 
    DfsSite *DestinationSite, 
    PULONG pCost)
{
    //
    // If we are dealing with an empty sitename at either end,
    // we err on the safe side.
    //
    *pCost = DFS_MAX_COST;

    if ((IsEmptyString( DestinationSite->SiteNameString() ) == FALSE) && 
       (IsEmptyString( _SiteName.Buffer ) == FALSE))
    {
        // If the sitenames are the same the cost is zero by definition.
        if (DfsCompareSiteNames( &_SiteName, DestinationSite->SiteName() ) == 0)
        {
            *pCost = DFS_MIN_COST;
        }
    }

    return;
}

//
// Given a target site, return its cost.
// We simply have to get it from the Cache.
// We return ERROR_NOT_FOUND if it's not there.
//
DFSSTATUS
DfsSite::GetRealSiteCost( 
    DfsSite *DestinationSite, 
    PULONG pCost)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ASSERT(DestinationSite);

    DfsSiteCostCache *pCache = NULL;
    ASSERT(_pSiteCostSupport != NULL);
    
    if ((IsEmptyString( DestinationSite->SiteNameString() )) || 
       (IsEmptyString( _SiteName.Buffer )))
    {
        *pCost = DFS_MAX_COST;
        return Status;
    }
       
    Status = _pSiteCostSupport->Acquire( &pCache );
    if (Status == ERROR_SUCCESS)
    {      
        //
        // Get the value from the cache if it's there.
        // Else, it'll return NOT_FOUND.
        //
        Status = pCache->GetCost( DestinationSite, pCost );
        _pSiteCostSupport->Release();
    }

    DFS_TRACE_LOW( REFERRAL, "GetCost Status 0x%x: From %ws to %ws, Cost = 0x%x\n",
                    Status, SiteNameString(), DestinationSite->SiteNameString(), *pCost );
    return Status;
}
    
//
// Given the IpAddress, return a corresponding
// DfsSite. This is meant to always succeed.
//
VOID
DfsIpToDfsSite(
    IN char * IpData, 
    IN ULONG IpLength, 
    IN USHORT IpFamily,
    OUT DfsSite **ppSite)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR *SiteNamesArray = NULL;
    DWORD IpAddress = 0;
    unsigned char *IpAddr = (unsigned char *)IpData;
    PVOID pBufferToFree = NULL;
    LPWSTR FoundSiteName = NULL;    
    DfsSite *pFoundSite = NULL;
    
    CopyMemory(&IpAddress, IpAddr, sizeof(IpAddress));
    
    //
    // If this is local then we have it easy.
    //
    if ((IpAddress == _Dfs_LocalAddress) &&
        (IpLength == 4))
    {       
        Status = DsGetSiteName( NULL, &FoundSiteName );
        if (Status == ERROR_SUCCESS)
        {
            pBufferToFree = (PVOID)FoundSiteName;
            DFS_TRACE_LOW(REFERRAL, "IpToDfsSite: LOCAL IP maps to SiteName %ws\n",
                            FoundSiteName);
        }
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL, "DsGetSiteName fails with Status 0x%x for LOCAL IP\n",
                Status);
    } 
    else 
    {
        //
        // Send in the IP Address to get the site name.
        //
        Status = DfsGetSiteNameFromIpAddress( IpData,
                                            IpLength,
                                            IpFamily,
                                            &SiteNamesArray );
        if ((Status == ERROR_SUCCESS)  &&
           (SiteNamesArray != NULL)) 
        {
            //
            // We found the sitename. We only look at the first entry
            // returned. We'll also create the hash entry for future use.
            //
            if (SiteNamesArray[0] != NULL) 
            {
                FoundSiteName = SiteNamesArray[0];
            }
            pBufferToFree = (PVOID)SiteNamesArray;
        } 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL, "DsGetSiteNameFromIpAddress fails with Status 0x%x for IP\n",
                         Status);
    }

    if (FoundSiteName != NULL)
    {
        //
        // Get the DfsSite corresponding to this site name.
        // If for any reason, including NOT_ENOUGH_MEMORY, this fails,
        // we simply use our default dfssite (see below).
        //
        (VOID) DfsGetSiteBySiteName( FoundSiteName, &pFoundSite );
    } 

    //
    // Default DfsSite has a NULL site name, and knows of no site-cost to anybody.
    // It is pre-created at startup time, so it's guaranteed to exist.
    //
    if (pFoundSite == NULL)
    {
        pFoundSite = DfsGetDefaultSite();
        DFS_TRACE_LOW(REFERRAL, "IpToDfsSite: Using default Empty DfsSite for IP %d:%d:%d:%d\n",
                        IpAddr[0],                  
                        IpAddr[1],
                        IpAddr[2],
                        IpAddr[3]);
    }

    *ppSite = pFoundSite;
    
    //
    // We've made a copy, ok to free this array now.
    //
    if (pBufferToFree != NULL) 
    {
        NetApiBufferFree( pBufferToFree );
    }
}


//
// Given a sitename, return a referenced DfsSite.
//
DFSSTATUS
DfsGetSiteBySiteName(
    LPWSTR SiteNameString,
    DfsSite **ppSite)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsSite *pDfsSite = NULL;
    PDFS_SITE_NAME_DATA pSiteNameData = NULL;
    UNICODE_STRING SiteName;

    
    do {


        Status = DfsRtlInitUnicodeStringEx( &SiteName, SiteNameString );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Empty site names get the default site.
        //
        if (IsEmptyString( SiteNameString ))
        {
            *ppSite = DfsGetDefaultSite();
            DFS_TRACE_LOW(REFERRAL, "SiteBySiteName:Using default Empty DfsSite for Empty sitename\n");
            break;
        }
        
        //
        // Look it up to see if we know about this site already.
        //
        pSiteNameData = (PDFS_SITE_NAME_DATA)DfsServerGlobalData.pSiteNameSupport->LookupIpInHash( 
                                                                            &SiteName );
        if (pSiteNameData != NULL)
        {
            ASSERT( pSiteNameData->pDfsSite != NULL );
            ASSERT( Status == ERROR_SUCCESS );
            
            //
            // take a new reference on this site we found before returning.
            //
            pSiteNameData->pDfsSite->AcquireReference();
            *ppSite = pSiteNameData->pDfsSite;

            //
            // Release the reference we acquired during lookup.
            // We have a reference to the DfsSite inside it anyway.
            //
            DfsServerGlobalData.pSiteNameSupport->ReleaseSiteNameData( pSiteNameData );
            DFS_TRACE_LOW(REFERRAL, "SiteBySiteName: Cachehit for sitename %ws -> DfsSite %p\n",
                           SiteNameString, *ppSite);
            break;
        }

        //
        // We have to create a new DfsSite.
        //
        pDfsSite = new DfsSite;
        if (pDfsSite == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            DFS_TRACE_ERROR_LOW(Status, REFERRAL, "DfsSite->constructor failed with 0x%x for sitename %ws\n", 
                             Status, SiteNameString);
            break;
        }

        //
        // Initialize the site name as well as its site-cost cache.
        // This call will make a copy of the sitename we send.
        //
        Status = pDfsSite->Initialize( &SiteName );
        if (Status != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH(Status, REFERRAL, "DfsSite->Initialize failed with 0x%x for sitename %ws\n", 
                             Status, SiteNameString);
            break;
        }

        //
        // Put this in the SiteName->DfsSite cache.
        // This StoreSiteInCache method will take a reference on the
        // DfsSite. We ignore the return status; we don't need
        // to fail this call just because the hash insertion failed.
        //
        (VOID) DfsServerGlobalData.pSiteNameSupport->StoreSiteInCache( pDfsSite );
        
        //
        // We've already taken a reference on this DfsSite
        // when it was created. So just return the pointer.
        // The caller needs to make sure that it releases this
        // reference when its done.
        //
        *ppSite = pDfsSite;
        DFS_TRACE_LOW(REFERRAL, "SiteBySiteName ->StoreInCache: Created new DfsSite %p for site %ws\n",
                       *ppSite, SiteNameString );
    } while (FALSE);

    // Error path.
    if (Status != ERROR_SUCCESS)
    {
        //
        // We acquired this reference when we instantiated this.
        // This will delete it if we actually created it.
        //
        if (pDfsSite != NULL)
        {
            pDfsSite->ReleaseReference();
        }
        *ppSite = NULL;
    }
    
    return Status;
}



//
// The following are callbacks for the SiteCost hashtable.
//


// The hash value was pre-calculated at the
// time we initialized the site name.
ULONG
DfsHashDfsSite(
    IN PVOID pSite)
{
    DfsSite *Site = (DfsSite *)pSite;

    ASSERT(Site != NULL);
    return Site->Hash();
}

// Compare two sites to see if their names match.
int
DfsCompareDfsSites(
    void*   pvKey1,
    void*   pvKey2)
{
    PUNICODE_STRING Site1 = ((DfsSite *) pvKey1)->SiteName();
    PUNICODE_STRING Site2 = ((DfsSite *) pvKey2)->SiteName();
    
    if (Site1->Length == Site2->Length) 
    {
        return RtlCompareUnicodeString( Site1, Site2, FALSE );
        
    } else {

        return  (signed)Site1->Length - (signed)Site2->Length;
    }
}

// Compare two sites to see if their names match.
int
DfsCompareSiteNames(
    void*   pvKey1,
    void*   pvKey2)
{
    PUNICODE_STRING Site1 = (PUNICODE_STRING) pvKey1;
    PUNICODE_STRING Site2 = (PUNICODE_STRING) pvKey2;
    
    if (Site1->Length == Site2->Length) 
    {
        return RtlCompareUnicodeString( Site1, Site2, FALSE );
        
    } else {

        return  (signed)Site1->Length - (signed)Site2->Length;
    }
}


// Allocate the cache data entry
PVOID
DfsAllocateHashData(ULONG Size )
{
    PVOID RetValue = NULL;

    if (Size)
    {
        RetValue = (PVOID) new BYTE[Size];
        if (RetValue != NULL)
        {
            RtlZeroMemory( RetValue, Size );
        }
    }

    return RetValue;
}

VOID
DfsDeallocateHashData(PVOID pPointer )
{
    PDFS_SITE_COST_DATA pSiteStructure = (PDFS_SITE_COST_DATA)pPointer;

    if (pSiteStructure)
    {
        delete [] (PBYTE)pSiteStructure;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssitecache.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       DfsSiteCache.cxx
//
//  Contents:   implements the base DFS Site hash class
//
//
//  History:    July. 10 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
     
#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "dsgetdc.h"
#include "lm.h"
#include <winsock2.h>
#include "DfsSiteCache.hxx"
#include <DfsSite.hxx>                      
#include "DfsSiteCache.tmh" 


void *
AllocateSitecacheData(ULONG Size )
{
    PVOID RetValue = NULL;

    if (Size)
    {
        RetValue = (PVOID) new BYTE[Size];
        if(RetValue != NULL)        
        {
            RtlZeroMemory( RetValue, Size );
        }
    }

    return RetValue;
}

DFSSTATUS    
DfsSiteNameCache::DfsInitializeSiteCache(void)
{
   DFSSTATUS Status = ERROR_SUCCESS;
   SHASH_FUNCTABLE FunctionTable;

    ZeroMemory(&FunctionTable, sizeof(FunctionTable));
    
    FunctionTable.CompareFunc = CompareSiteIpAddress;
    FunctionTable.HashFunc = DfsHashIpAddress;
    FunctionTable.AllocFunc = AllocateSitecacheData;
    FunctionTable.FreeFunc = DfsDeallocateHashData;
    FunctionTable.AllocHashEntryFunc = AllocateSitecacheData;
    FunctionTable.FreeHashEntryFunc = DeallocateSiteCacheData;

    Status = ShashInitHashTable(&pSiteTable, &FunctionTable);

    Status = RtlNtStatusToDosError(Status);

    return Status;

}

DfsSiteNameCache *
DfsSiteNameCache::CreateSiteHashTable(DFSSTATUS * pStatus)
{
    DfsSiteNameCache * pSiteTable = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    pSiteTable = new DfsSiteNameCache(&Status);
    if(pSiteTable == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        Status = pSiteTable->DfsInitializeSiteCache();
        if(Status != ERROR_SUCCESS)
        {
            delete pSiteTable;
            pSiteTable = NULL;
        }
    }


    *pStatus = Status;
    return pSiteTable;

}

DFSSTATUS
DfsSiteNameCache::CreateSiteData(
    IN DWORD IpAddress,
    IN DfsSite *pNewSite,
    OUT PDFSSITE_DATA *ppSiteData )
{
    PDFSSITE_DATA SiteStructure = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    *ppSiteData = NULL;

    do {
        SiteStructure = (PDFSSITE_DATA) AllocateSitecacheData(sizeof( DFSSITE_DATA ));
        if (SiteStructure == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        RtlZeroMemory(SiteStructure, sizeof(DFSSITE_DATA));
        
        SiteStructure->Header.RefCount = 1;
        SiteStructure->Header.pvKey = (PVOID) (ULONG_PTR)IpAddress;
        SiteStructure->Header.pData = (PVOID)SiteStructure;

        SiteStructure->FirstAccessTime = GetTickCount();
        SiteStructure->InMruList = FALSE;
        SiteStructure->Accessed = SITE_ACCESSED;
        SiteStructure->IpAddress = IpAddress;

        //
        // Now attach a referenced ClientSite.
        //
        pNewSite->AcquireReference();
        SiteStructure->ClientSite = pNewSite;
        *ppSiteData = SiteStructure;
    } while (FALSE);

    //
    // We haven't added this to the table yet.
    // So, just free the whole thing in case of error.
    // This will release the DfsSite as well, if it's initialized.
    //
    if (Status != ERROR_SUCCESS && SiteStructure != NULL)
    {
        DeallocateSiteCacheData( SiteStructure );
        *ppSiteData = NULL;
    }
    
    return Status;

}

DFSSTATUS
DfsSiteNameCache::InsertInMruList(PDFSSITE_DATA SiteStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    EnterCriticalSection(&m_Lock);

    SiteStructure->InMruList = TRUE;

    InsertHeadList( &MruList, &SiteStructure->ListEntry ) ;

    LeaveCriticalSection(&m_Lock);

    return Status;
}


DFSSTATUS
DfsSiteNameCache::RemoveFromMruList(PDFSSITE_DATA pSiteStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    EnterCriticalSection(&m_Lock);

    if(pSiteStructure->InMruList == TRUE)
    {
        RemoveEntryList( &pSiteStructure->ListEntry ) ;
        pSiteStructure->InMruList = FALSE ;
        ReleaseSiteCacheData(pSiteStructure);
    }

    LeaveCriticalSection(&m_Lock);
    return Status;
}

DFSSTATUS
DfsSiteNameCache::MoveToFrontOfMruList(PDFSSITE_DATA pSiteStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    EnterCriticalSection(&m_Lock);

    if(pSiteStructure->InMruList == TRUE)
    {
        RemoveEntryList( &pSiteStructure->ListEntry ) ;

        InsertHeadList( &MruList, &pSiteStructure->ListEntry ) ;

        InterlockedExchange(&pSiteStructure->Accessed, 
                            SITE_ACCESSED);
    }

    LeaveCriticalSection(&m_Lock);

    return Status;
}


DFSSTATUS
DfsSiteNameCache::StoreSiteInCache(
    DWORD IpAddress,
    DfsSite *pSite,
    BOOLEAN IsRefresh)
{
    PDFSSITE_DATA SiteStructure = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    LONG CurrentSiteEntries = 0;

    //assume success first. Also, if an existing entry is inthe cache, and we are
    //just replacing it (IsRefresh == TRUE), then don't bump the count.
    if(IsRefresh == FALSE)
    {
        CurrentSiteEntries = InterlockedIncrement( &DfsServerGlobalData.NumClientDfsSiteEntries );

        if(CurrentSiteEntries > 
           DfsServerGlobalData.NumClientSiteEntriesAllowed)
        {
            InterlockedDecrement( &DfsServerGlobalData.NumClientDfsSiteEntries );
            Status = ERROR_REMOTE_SESSION_LIMIT_EXCEEDED;
            return Status;
        }
    }

    Status = CreateSiteData( IpAddress,
                           pSite,
                           &SiteStructure );

    if (Status == ERROR_SUCCESS)
    {
       if(IsRefresh)
       {
         SiteStructure->Accessed = SITE_NOTACCESSED;
       }

       NtStatus = SHashInsertKey(pSiteTable,
                                 SiteStructure,
                                 (void *) (ULONG_PTR)IpAddress,
                                 SHASH_REPLACE_IFFOUND);
       if(NtStatus == STATUS_SUCCESS)
       {
            if(InsertInMruList(SiteStructure) != ERROR_SUCCESS)
            {
                InterlockedDecrement(&SiteStructure->Header.RefCount);
            }

            // for stats
            DFS_TRACE_LOW( SITE, "Added Site %ws to IPCache (IP %x)\n", 
                pSite->SiteNameString(), IpAddress);
       }
       else
       {
            DeallocateSiteCacheData( SiteStructure );
            Status = RtlNtStatusToDosError(NtStatus);
       }
    }

    if((NtStatus != STATUS_SUCCESS) && (IsRefresh == FALSE))
    {
       InterlockedDecrement( &DfsServerGlobalData.NumClientDfsSiteEntries );
    }

    return Status;
}


PSHASH_HEADER 
DfsSiteNameCache::LookupIpInHash(DWORD IpAddress)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PSHASH_HEADER pHeader = NULL;
    PDFSSITE_DATA pSiteStructure = NULL;

    pHeader = SHashLookupKeyEx(pSiteTable,
                               (void *) (ULONG_PTR) IpAddress);
    if(pHeader != NULL)
    {
      pSiteStructure = (PDFSSITE_DATA) pHeader;

      MoveToFrontOfMruList(pSiteStructure);
    }

    return pHeader;
}

void
DfsSiteNameCache::
ReleaseSiteCacheData(PDFSSITE_DATA pData)
{
    SHashReleaseReference(pSiteTable,
                          (PSHASH_HEADER) pData );
}


BOOLEAN
DfsSiteNameCache::IsTimeToRefresh(PDFSSITE_DATA pSiteData)
{
   DWORD TimeNow = 0;

   TimeNow = GetTickCount();

   if ((TimeNow > pSiteData->FirstAccessTime) &&
            (TimeNow - pSiteData->FirstAccessTime) > DfsServerGlobalData.SiteSupportRefreshInterval)
   {
      return TRUE;
   }

   if ((TimeNow < pSiteData->FirstAccessTime) &&
            ((TimeNow - 0) + (0xFFFFFFFF - pSiteData->FirstAccessTime) > DfsServerGlobalData.SiteSupportRefreshInterval))
   {
      return TRUE;
   }

   return FALSE;
}


DFSSTATUS
DfsSiteNameCache::ResetSiteData(PDFSSITE_DATA pExistingData)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsSite *pClientSite = NULL;
    unsigned char *IpAddr = (unsigned char *) &(pExistingData->IpAddress);


    DFS_TRACE_LOW( SITE, "ResetSiteData: old Site %ws, IP %d:%d:%d:%d\n", 
                pExistingData->ClientSite->SiteNameString(), IpAddr[0],
                IpAddr[1],
                IpAddr[2],
                IpAddr[3]);
    //
    // Find a new DfsSite for it. This will do the DsGetSiteName calls
    // again.
    //
    DfsIpToDfsSite((char *) (ULONG_PTR)&pExistingData->IpAddress,
                         4,
                         AF_INET,
                         &pClientSite);
                         
    ASSERT( pClientSite != NULL );
    Status = StoreSiteInCache( pExistingData->IpAddress,
                             pClientSite,
                             TRUE);

    //
    // Release the reference we got (above in DfsIpToDfsSite).
    // The cache has already taken the reference it needs in CreateSiteData.
    //
    pClientSite->ReleaseReference();
    DFS_TRACE_LOW( SITE, "ResetSiteData: new Site %ws, IP %d:%d:%d:%d\n", 
                pExistingData->ClientSite->SiteNameString(), IpAddr[0],
                IpAddr[1],
                IpAddr[2],
                IpAddr[3]);

    return Status;

}


DFSSTATUS
DfsSiteNameCache::DeleteSiteData(PDFSSITE_DATA pSiteStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    SHashMarkForDeletion(pSiteTable, (PSHASH_HEADER) pSiteStructure);  
            
    return Status;
}


DFSSTATUS
DfsSiteNameCache::RemoveAndDeleteSiteData(PDFSSITE_DATA pExistingData)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    unsigned char *IpAddr = (unsigned char *) &(pExistingData->IpAddress);


    DFS_TRACE_LOW( SITE, "RemoveAndDeleteSiteData: old Site %ws, IP %d:%d:%d:%d\n", 
                pExistingData->ClientSite->SiteNameString(), IpAddr[0],
                IpAddr[1],
                IpAddr[2],
                IpAddr[3]);

    Status = RemoveFromMruList(pExistingData);
    if(Status == STATUS_SUCCESS)
    {
        Status = DeleteSiteData(pExistingData);
    }

    if(Status == ERROR_SUCCESS)
    {
        InterlockedDecrement( &DfsServerGlobalData.NumClientDfsSiteEntries );
    }

    return Status;
}

DFSSTATUS
DfsSiteNameCache::RefreshSiteData(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN TimeToRefresh = FALSE;
    BOOLEAN WasAccessed = FALSE;
    LPWSTR *SiteNamesArray = NULL;
    PDFSSITE_DATA pExistingData = NULL;
    SHASH_ITERATOR Iter;

    pExistingData = (PDFSSITE_DATA) SHashStartEnumerate(&Iter, pSiteTable);

    while ((pExistingData != NULL) && 
           (!DfsIsShuttingDown()))
    {
        WasAccessed = ResetSiteAccessMask(pExistingData);
        if(WasAccessed)
        {
            TimeToRefresh = IsTimeToRefresh(pExistingData);
            if(TimeToRefresh == TRUE)
            {
                Status = RemoveFromMruList(pExistingData);
                if(Status == STATUS_SUCCESS)
                {
                    Status = ResetSiteData(pExistingData);
                    if(Status != STATUS_SUCCESS)
                    {
                        if(InsertInMruList(pExistingData) == ERROR_SUCCESS)
                        {
                            InterlockedIncrement(&pExistingData->Header.RefCount);
                        }
                    }
                }
            }
        }
        else
        {
            RemoveAndDeleteSiteData(pExistingData);
        }
        
        pExistingData = (PDFSSITE_DATA) SHashNextEnumerate(&Iter, pSiteTable);
    }

    SHashFinishEnumerate(&Iter, pSiteTable);
    return Status;
}


ULONG
DfsHashIpAddress(
    void * pDfsAddress)
{
    ULONG BucketNo = 0;
    CHAR *pBuffer = (char *) &pDfsAddress;
    CHAR *pBufferEnd = &pBuffer[4];
    ULONG Ch = 0;

    BucketNo = 0;

    while (pBuffer != pBufferEnd) {

        Ch = *pBuffer & 0xff;
        BucketNo *= 131;
        BucketNo += Ch;
        pBuffer++;

    }

    return BucketNo;
}


int
CompareSiteIpAddress(void*   pvKey1,
                     void*   pvKey2)
{
    int CompVal = 0;
    ULONG_PTR IpAddress1 = (ULONG_PTR) pvKey1;
    ULONG_PTR IpAddress2 = (ULONG_PTR) pvKey2;

    if(IpAddress1 < IpAddress2)
    {
        CompVal = -1;    
    }
    else if (IpAddress1 > IpAddress2) 
    {
        CompVal = 1;
    }

    return CompVal;
}

VOID
DeallocateSiteCacheData(PVOID pPointer )
{
    PDFSSITE_DATA pSiteStructure = (PDFSSITE_DATA)pPointer;

    if(pPointer)
    {
        if (pSiteStructure->ClientSite != NULL)
        {
            pSiteStructure->ClientSite->ReleaseReference();
            pSiteStructure->ClientSite = NULL;
        }
        delete [] (PBYTE)pPointer;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsstatistics.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsStatistics.cxx
//
//  Contents:   the DFS Statistics
//
//  Classes:    DfsStatistics
//
//  History:    Apr. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsStatistics.hxx"
#include "dfsinit.hxx"
//
// following are required for logging: dfsdev cleanup
//

#include "dfsstatistics.tmh" 

VOID
DfsStatistics::DumpStatistics(
    PUNICODE_STRING pLogicalShare )
{
    SYSTEMTIME CurrentTime;


    GetLocalTime( &CurrentTime );

    DFS_TRACE_HIGH( STATISTICS, "Root %wZ\n", pLogicalShare);
    DFS_TRACE_HIGH( STATISTICS, "Statisicts dump at %d\\%d\\%d, %d:%d:%d:%d\n",
                    CurrentTime.wMonth, CurrentTime.wDay, CurrentTime.wYear,
                    CurrentTime.wHour, CurrentTime.wMinute, CurrentTime.wSecond, 
                    CurrentTime.wMilliseconds );

    DFS_TRACE_HIGH( STATISTICS, "Total Referrals %d\n", TotalReferrals );
    DFS_TRACE_HIGH( STATISTICS, "Hits %d Misses %d\n", Hits, Misses );


    DFS_TRACE_HIGH( STATISTICS, "ServerSite cache Hits %d Misses %d\n", ServerSiteCacheHits, ServerSiteCacheMisses );

    DFS_TRACE_HIGH( STATISTICS, "Min Referral Time %d ms\n", MinReferralTime );
    DFS_TRACE_HIGH( STATISTICS, "Max Referral Time %d ms\n", MaxReferralTime );
    DFS_TRACE_HIGH( STATISTICS, "%d Referrals took longer than %d secs\n",
                    VeryLargeTimeReferrals, VERY_LARGE_TIME_REFERRAL/1000 );
    DFS_TRACE_HIGH( STATISTICS, "%d Referrals took longer than %d secs\n",
                    LargeTimeReferrals, LARGE_TIME_REFERRAL/1000 );
    DFS_TRACE_HIGH( STATISTICS, "%d Referrals took less than %d ms\n",
                    SmallTimeReferrals, SMALL_TIME_REFERRAL);

    DFS_TRACE_HIGH( STATISTICS, "Links Added %d Deleted %d Modified %d\n",
                    LinksAdded, LinksDeleted, LinksModified);

    DFS_TRACE_HIGH( STATISTICS, "Cache Flush interval %d ms\n", DfsServerGlobalData.CacheFlushInterval );

    DFS_TRACE_HIGH( STATISTICS, "Forced Cache Flush %d\n", ForcedCacheFlush);
    DFS_TRACE_HIGH( STATISTICS, "Statistics Started on %d\\%d\\%d, %d:%d:%d:%d\n",
                    StartTime.wMonth, StartTime.wDay, StartTime.wYear,
                    StartTime.wHour, StartTime.wMinute, StartTime.wSecond, 
                    StartTime.wMilliseconds );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsstore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsStore.cxx
//
//  Contents:   the base DFS Store class, this contains the common
//              store functionality.
//
//  Classes:    DfsStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsStore.hxx"
#include "DfsServerLibrary.hxx"
#include <dfsmisc.h>

//
// logging stuff
//

#include "dfsstore.tmh" 


extern "C" {
DWORD
I_NetDfsIsThisADomainName(
    IN  LPWSTR                      wszName);
}


// Initialize the common marshalling info for Registry and ADLegacy stores.
//
INIT_FILE_TIME_INFO();
INIT_DFS_REPLICA_INFO_MARSHAL_INFO();

//+-------------------------------------------------------------------------
//
//  Function:   PackGetInfo - unpacks information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              interpret the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
DfsStore::PackGetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackGetInformation(Info + typeInfo->_off,
                                           ppBuffer,
                                           pSizeRemaining,
                                           typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackGetULong( (PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackGetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackGetGuid( (GUID *)(Info + typeInfo->_off),
                                  ppBuffer,
                                  pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
DfsStore::PackSetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackSetInformation( Info + typeInfo->_off,
                                            ppBuffer,
                                            pSizeRemaining,
                                            typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackSetULong( *(PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackSetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackSetGuid( (GUID *)(Info + typeInfo->_off),
                                     ppBuffer,
                                     pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
ULONG
DfsStore::PackSizeInformation(
    ULONG_PTR Info,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    ULONG Size = 0;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Size += PackSizeInformation( Info + typeInfo->_off,
                                              typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Size += PackSizeULong();

            break;

        case MTYPE_PWSTR:
            Size += PackSizeString( (PUNICODE_STRING)(Info + typeInfo->_off) );
            
            break;

        case MTYPE_GUID:

            Size += PackSizeGuid();
            break;

        default:
            break;
        }
    }

    return Size;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackGetReplicaInformation - Unpacks the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete replica
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine expects to find "replicaCount" number of individual
//               binary streams in passed in buffer. Each stream starts with
//               the size of the stream, followed by that size of data.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::PackGetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackGetULong( &pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );


        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because UnpackUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this unpack returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //
        if(pReplicaInfo->DataSize > *pSizeRemaining)
        {
            Status = ERROR_INVALID_DATA;
        }

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackGetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );
            if(Status == ERROR_SUCCESS)
            {
                //
                // We now point the buffer to the next sub-stream, which is the previous
                // stream + the size of the stream. We also set the remaining size
                // appropriately.
                //
                *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
                *pSizeRemaining -= pReplicaInfo->DataSize;
            }

        }
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetReplicaInformation - packs the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the replica info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to be able to
//               hold the information that will be copied from the
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine stores a "replicaCount" number of individual
//               binary streams as the first ulong, and then it packs each
//               stream.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::PackSetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackSetULong( pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );

        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because packUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackSetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );

            //
            // We now point the buffer to the next sub-stream, which is the previos
            // stream + the size of the stream. We also set the remaining size
            // appropriately.
            //  
            *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
            *pSizeRemaining -= pReplicaInfo->DataSize;
        }

        if ( Status != ERROR_SUCCESS )
        {
            break;
        }
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeReplicaInformation - packs the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the replica info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to be able to
//               hold the information that will be copied from the
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine stores a "replicaCount" number of individual
//               binary streams as the first ulong, and then it packs each
//               stream.
//
//--------------------------------------------------------------------------

ULONG
DfsStore::PackSizeReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    ULONG Count;
    ULONG Size = 0;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        Size += PackSizeULong();

        pReplicaInfo->DataSize = PackSizeInformation( (ULONG_PTR)pReplicaInfo,
                                                      &MiDfsReplicaInfo );
        Size += pReplicaInfo->DataSize;
    }
    
    return Size;
}


//+-------------------------------------------------------------------------
//
//  Function:   LookupRoot - Find a root
//
//  Arguments:  pContextName - the Dfs Name Context
//              pLogicalShare - the Logical Share
//              ppRoot - the DfsRootFolder that was found
//
//  Returns:    Status
//               ERROR_SUCCESS if we found a matching root
//               error status otherwise.
//
//
//  Description: This routine takes a Dfs name context and logical share,
//               and returns a Root that matches the passed in name 
//               context and logical share, if one exists.
//               Note that the same DFS NC and logical share may exist 
//               in more than one store (though very unlikely). In this
//               case, the first registered store wins.
//               IF found, the reference root folder will be returned.
//               It is the callers responsibility to release this referencce
//               when the caller is done with this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::LookupRoot(
    PUNICODE_STRING pContextName,
    PUNICODE_STRING pLogicalShare,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;
    DfsRootFolder *pRoot;
    UNICODE_STRING DfsNetbiosNameContext;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Lookup root %wZ %wZ\n", pContextName, pLogicalShare);
    //
    // First, convert the context name to a netbios context name.
    //
    DfsGetNetbiosName( pContextName, &DfsNetbiosNameContext, NULL );

    //
    // Lock the store, so that we dont have new roots coming in while
    // we are taking a look.
    //
    Status = AcquireReadLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // The default return status is ERROR_NOT_FOUND;
    //
    Status = ERROR_NOT_FOUND;

    //
    // Run through our list of DFS roots, and see if any of them match
    // the passed in name context and logical share.
    //

    pRoot = _DfsRootList;

    if (pRoot != NULL)
    {
        do
        {
            DFS_TRACE_LOW( REFERRAL_SERVER, "Lookup root, checking root %wZ \n", pRoot->GetLogicalShare());
            //
            // If the Root indicates that the name context needs to be
            // ignored, just check for logical share name match (aliasing
            // support).
            // Otherwise, compare the namecontext in the cases where
            // the passed in name context is not empty.
            //
            if ( (pRoot->IsIgnoreNameContext() == TRUE) ||
                 (DfsNetbiosNameContext.Length != 0 &&
                  (RtlCompareUnicodeString(&DfsNetbiosNameContext,
                                           pRoot->GetNetbiosNameContext(),
                                           TRUE) == 0 )) )
            {
                if ( RtlCompareUnicodeString( pLogicalShare,
                                              pRoot->GetLogicalShare(),
                                              TRUE) == 0 )
                {
                    Status = ERROR_SUCCESS;
                    break;
                }
            }
            pRoot = pRoot->pNextRoot;
        } while ( pRoot != _DfsRootList );
    }

    //
    // IF we found a matching root, bump up its reference count, and
    // return the pointer to the root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pRoot->AcquireReference();
        *ppRootFolder = pRoot;

    }

    ReleaseLock();

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Done Lookup root for %wZ, root %p status %x\n",
                         pLogicalShare, pRoot, Status);
    return Status;
}



DFSSTATUS
DfsStore::GetRootPhysicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootPhysicalShare )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsGetRegValueString( RootKey,
                                DfsRootShareValueName,
                                pRootPhysicalShare );
    return Status;
}

VOID
DfsStore::ReleaseRootPhysicalShare(
    PUNICODE_STRING pRootPhysicalShare )
{
    DfsReleaseRegValueString( pRootPhysicalShare );
}


DFSSTATUS
DfsStore::GetRootLogicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootLogicalShare )
{
    DFSSTATUS Status;

    Status = DfsGetRegValueString( RootKey,
                                DfsLogicalShareValueName,
                                pRootLogicalShare );

    return Status;
}

VOID
DfsStore::ReleaseRootLogicalShare(
    PUNICODE_STRING pRootLogicalShare )
{
    DfsReleaseRegValueString( pRootLogicalShare );
}


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizeNewDfs -  the recognizer for new style dfs
//
//  Arguments:  Name - the namespace of interest.
//              DfsKey - the key for the DFS registry space.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine looks up all the standalone roots
//               hosted on this machine, and looks up the metadata for
//               the roots and either creates new roots or updates existing
//               ones to reflect the current children of the root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::StoreRecognizeNewDfs(
    LPWSTR MachineName,
    HKEY   DfsKey )
{
    DfsRootFolder *pRootFolder = NULL;
    HKEY DfsRootKey = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG ChildNum = 0;
    DWORD CchMaxName = 0;
    DWORD CchChildName = 0;
    LPWSTR ChildName = NULL;
    DFSSTATUS RetStatus = ERROR_SUCCESS;
    
    DFS_TRACE_LOW(REFERRAL_SERVER, "Attempting to recognize new DFS\n");

    //
    // First find the length of the longest subkey 
    // and allocate a buffer big enough for it.
    //
    
    Status = RegQueryInfoKey( DfsKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              &CchMaxName,  // max size of subkey name in TCHARs
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              NULL,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        CchMaxName++; // Space for the NULL terminator.
        ChildName = (LPWSTR) new WCHAR [CchMaxName];
        if (ChildName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // For each child, get the child name.
        //
        do
        {
            CchChildName = CchMaxName;
            
            //
            // Now enumerate the children, starting from the first child.
            //
            Status = RegEnumKeyEx( DfsKey,
                                   ChildNum,
                                   ChildName,
                                   &CchChildName,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL );

            ChildNum++;

            if (Status == ERROR_SUCCESS)
            {
                DFS_TRACE_LOW(REFERRAL_SERVER, "Recognize New Dfs, found root (#%d) with metaname %ws\n", ChildNum, ChildName );
                //
                // We have the name of a child, so open the key to
                // that root.
                //
                Status = RegOpenKeyEx( DfsKey,
                                       ChildName,
                                       0,
                                       KEY_READ,
                                       &DfsRootKey );

                if (Status == ERROR_SUCCESS)
                {
                    DFSSTATUS RootStatus = ERROR_SUCCESS;

                    //
                    // Now get either an existing root by this name,
                    // or create a new one. The error we get here is
                    // not the original error generated by AD (or the Registry).
                    // xxx We should try to propagate that error in future.
                    //
                    RootStatus = GetRootFolder( MachineName,
                                                ChildName,
                                                DfsRootKey,
                                                &pRootFolder );

                    if (RootStatus == ERROR_SUCCESS)
                    {

                        //
                        // Call the synchronize method on the root to
                        // update it with the latest children.
                        // Again, ignore the error since we need to move
                        // on to the next root.
                        // dfsdev: need eventlog to signal this.
                        //
                        RootStatus = pRootFolder->Synchronize();

                        //
                        // If the Synchronize above had succeeded, then it would've created
                        // all the reparse points that the root needs. Now we need to add
                        // this volume as one that has DFS reparse points so that we know
                        // to perform garbage collection on this volume later on.
                        //                        
                        (VOID)pRootFolder->AddReparseVolumeToList();
                                                
                        // Release our reference on the root folder.

                        pRootFolder->ReleaseReference();

                    }

                    if (RootStatus != ERROR_SUCCESS)
                    {
                        if (!DfsStartupProcessingDone())
                        {
                            const TCHAR * apszSubStrings[4];

                            apszSubStrings[0] = ChildName;
                            DfsLogDfsEvent( DFS_ERROR_ON_ROOT,
                                            1,
                                            apszSubStrings,
                                            RootStatus);
                        }         
                        // Return the bad news.
                        RetStatus = RootStatus;
                    }
                    
                    DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize DFS: Root folder for %ws, Synchronize status %x\n",
                           ChildName, RootStatus );

                    //
                    // Close the root key, we are done with it.
                    //
                    RegCloseKey( DfsRootKey );
                }
            }

        } while (Status == ERROR_SUCCESS);

        delete [] ChildName;
    }

    //
    // If we ran out of children, then return success code.
    //
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Status = ERROR_SUCCESS;
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Done with recognize new dfs, Status 0x%x, RetStatus 0x%x\n", Status, RetStatus);

    // If any of the roots failed to load, convey that to the caller.
    if (Status == ERROR_SUCCESS && RetStatus != ERROR_SUCCESS)
    {
        Status = RetStatus;
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizeNewDfs -  the recognizer for new style dfs
//
//  Arguments:  Name - the namespace of interest.
//              LogicalShare
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine looks up all the domain roots
//               hosted on this machine, and looks up the metadata for
//               the roots and either creates new roots or updates existing
//               ones to reflect the current children of the root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::StoreRecognizeNewDfs (
    LPWSTR DfsNameContext,
    PUNICODE_STRING pLogicalShare )
{
    DfsRootFolder *pRootFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Attempting to recognize new remote DFS\n");

    //
    // Now get either an existing root by this name,
    // or create a new one.
    //
    
    Status = GetRootFolder( DfsNameContext,
                          pLogicalShare,
                          &pRootFolder );

    if (Status == ERROR_SUCCESS)
    {

        //
        // Call the synchronize method on the root to
        // update it with the latest children.
        //
        
        Status = pRootFolder->Synchronize();

        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER,
            "Recognize DFS: Root folder for %wZ, Synchronize status %x\n",
             pLogicalShare, Status );
        
        // Release our reference on the root folder.

        pRootFolder->ReleaseReference();
    }
    
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Done with recognize new remote dfs, Status %x\n", Status);
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder -  Get a root folder if the machine
//                                  hosts a registry based DFS.
//
//  Arguments:  Name - the namespace of interest.
//              Key - the root key
//              ppRootFolder - the created folder.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine reads in the information
//               about the root and creates and adds it to our
//               list of known roots, if this one does not already
//               exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::GetRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    HKEY DfsRootKey,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING LogicalShare;
    UNICODE_STRING PhysicalShare;

    //
    // Get the logical name information of this root.
    //

    Status = GetRootLogicalShare( DfsRootKey,
                                  &LogicalShare );


    //
    // we successfully got the logical share, now get the physical share
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = GetRootPhysicalShare( DfsRootKey,
                                       &PhysicalShare );
        if (Status == ERROR_SUCCESS)
        {
            Status = GetRootFolder ( DfsNameContextString,
                                     RootRegKeyName,
                                     &LogicalShare,
                                     &PhysicalShare,
                                     ppRootFolder );

            ReleaseRootPhysicalShare( &PhysicalShare );
        }

        ReleaseRootLogicalShare( &LogicalShare );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    UNICODE_STRING DfsNameContext;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Get Root Folder for %wZ\n", pLogicalShare);
    //
    // we have both the logical DFS share name, as well as the local machine 
    // physical share that is backing the DFS logical share.
    // now get a root folder for this dfs root.
    //

    Status = DfsRtlInitUnicodeStringEx( &DfsNameContext, DfsNameContextString );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //
    // Check if we already know about this root. If we do, this
    // routine gives us a referenced root folder which we can return.
    // If not, we create a brand new root folder.
    //

    Status = LookupRoot( &DfsNameContext,
                         pLogicalShare,
                         ppRootFolder );
    
    if (Status != STATUS_SUCCESS )
    {
        //
        // We check if we can proceed here. 
        //
        DFSSTATUS RootStatus;

        RootStatus = DfsCheckServerRootHandlingCapability();
        if (RootStatus == ERROR_NOT_SUPPORTED)
        {
            DfsLogDfsEvent(DFS_ERROR_MUTLIPLE_ROOTS_NOT_SUPPORTED, 0, NULL, RootStatus); 
            return RootStatus;
        }

        if (RootStatus != ERROR_SUCCESS)
        {
            return RootStatus;
        }

    }

    //
    // we did not find a root, so create a new one.
    //
    if ( Status != STATUS_SUCCESS )
    {
        Status = CreateNewRootFolder( DfsNameContextString,
                                      RootRegKeyName,
                                      pLogicalShare,
                                      pPhysicalShare,
                                      ppRootFolder );

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Created New Dfs Root %p, Share %wZ, Status %x\n", 
                             *ppRootFolder, pPhysicalShare, Status);
    } 
    else
    {
        //
        // There is an existing root with this name.
        // Validate that the root we looked up matches the 
        // metadata we are currently processing. If not, we
        // have 2 roots with the same logical share name in the
        // registry which is bogus.

        //
        // Dfs dev: rip out the following code.
        // just check for equality of the 2 roots.
        // they will not be null strings
        //
        if (RootRegKeyName != NULL)
        {
            if (_wcsicmp(RootRegKeyName,
                         (*ppRootFolder)->GetRootRegKeyNameString()) != 0)
            {
                (*ppRootFolder)->ReleaseReference();
                *ppRootFolder = NULL;
                Status = ERROR_DUP_NAME;
            }
        }
        else
        {
            if (IsEmptyString((*ppRootFolder)->GetRootRegKeyNameString()) == FALSE) 
            {
                (*ppRootFolder)->ReleaseReference();
                *ppRootFolder = NULL;
                Status = ERROR_DUP_NAME;
            }
        }

        //
        // If the above comparison matched, we found a root for the
        // logical volume, make sure that the physical share names
        // that is exported on the local machine to back the logical share
        // matches.
        //


        if (Status == ERROR_SUCCESS)
        {
            if (RtlCompareUnicodeString( pPhysicalShare,
                                         (*ppRootFolder)->GetRootPhysicalShareName(),
                                         TRUE ) != 0)
            {
                //
                // dfsdev: use appropriate status code.
                //

                (*ppRootFolder)->ReleaseReference();
                *ppRootFolder = NULL;
                Status = ERROR_INVALID_PARAMETER;
            }
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "GetRootFolder: Root %p, Status %x\n",
                        *ppRootFolder, Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder -  Get a root folder given a remote
//  <DfsName,LogicalShare>. 
//  
//
//  Arguments:  Name - the namespace of interest.
//              LogicalShare
//              ppRootFolder - the created folder.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine creates and adds a root folder to our
//               list of known roots, if this one does not already
//               exist in our list. This doesn't care to read any of the information
//               about its physical share, etc. The caller (a 'referral server')
//               is remote.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::GetRootFolder (
    LPWSTR DfsNameContextString,
    PUNICODE_STRING pLogicalShare,
    DfsRootFolder **ppRootFolder )

{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DfsNameContext;
    UNICODE_STRING DfsShare;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Get Root Folder (direct) for %wZ\n", pLogicalShare);
    
    Status = DfsRtlInitUnicodeStringEx( &DfsNameContext, DfsNameContextString );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    // Check if we already know about this root. If we do, this
    // routine gives us a referenced root folder which we can return.
    // If not, we create a brand new root folder.
    //

    Status = DfsCreateUnicodeString( &DfsShare, pLogicalShare);
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    Status = LookupRoot( &DfsNameContext,
                         pLogicalShare,
                         ppRootFolder );

    //
    // we did not find a root, so create a new one.
    //
    
    if ( Status != STATUS_SUCCESS )
    {
        Status = CreateNewRootFolder( DfsNameContextString,
                                      DfsShare.Buffer,
                                      pLogicalShare,
                                      pLogicalShare,
                                      ppRootFolder );

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Created New Dfs Root %p, Share %wZ, Status %x\n", 
                             *ppRootFolder, pLogicalShare, Status);
    } 
    else
    {
        //
        //  There's precious little to check at this point to weed out duplicates.
        //  We don't know what the physical share should be because we didn't
        //  read that information from the (remote) registry.
        // 

        NOTHING;

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "LookupRoot succeeded on folder %p, Share %wZ, Status %x\n", 
                               *ppRootFolder, pLogicalShare, Status);
    }
    
    DfsFreeUnicodeString( &DfsShare);
    return Status;
}


DFSSTATUS
DfsStore::PackageEnumerationInfo( 
    DWORD Level,
    DWORD EntryCount,
    LPBYTE pLinkBuffer,
    LPBYTE pBuffer,
    LPBYTE *ppCurrentBuffer,
    PLONG  pSizeRemaining )
{
    PDFS_API_INFO pInfo = NULL;
    PDFS_API_INFO pCurrent = (PDFS_API_INFO)pLinkBuffer;
    LONG HeaderSize = 0;
    ULONG_PTR NextFreeMemory = NULL;
    PDFS_STORAGE_INFO pNewStorage = NULL;
    PDFS_STORAGE_INFO pOldStorage = NULL;
    LONG TotalStores = 0;
    LONG i = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    LONG NeedLen = 0;


    Status = DfsApiSizeLevelHeader( Level, &HeaderSize );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    NextFreeMemory = (ULONG_PTR)*ppCurrentBuffer;

    pInfo = (PDFS_API_INFO)((ULONG_PTR)pBuffer + HeaderSize * EntryCount);
    
    RtlCopyMemory( pInfo, pLinkBuffer, HeaderSize );

    pNewStorage = NULL;

    switch (Level)
    {
    case 4:
        if (pNewStorage == NULL)
        {
            pNewStorage = pInfo->Info4.Storage = (PDFS_STORAGE_INFO)NextFreeMemory;
            pOldStorage = pCurrent->Info4.Storage;
            TotalStores = pInfo->Info4.NumberOfStorages;
        }

    case 3:
        if (pNewStorage == NULL)
        {
            pNewStorage = pInfo->Info3.Storage = (PDFS_STORAGE_INFO)NextFreeMemory;
            pOldStorage = pCurrent->Info3.Storage;
            TotalStores = pInfo->Info3.NumberOfStorages;
        }

        NeedLen = sizeof(DFS_STORAGE_INFO) * TotalStores;
        if (*pSizeRemaining >= NeedLen) {
            *pSizeRemaining -= NeedLen;
            NextFreeMemory += NeedLen;
        }
        else{
            return ERROR_BUFFER_OVERFLOW;
        }

        for (i = 0; i < TotalStores; i++)
        {
            pNewStorage[i] = pOldStorage[i];

            pNewStorage[i].ServerName = (LPWSTR)NextFreeMemory;
            NeedLen = (wcslen(pOldStorage[i].ServerName) + 1) * sizeof(WCHAR);
            if (*pSizeRemaining >= NeedLen) 
            {
                *pSizeRemaining -= NeedLen;
                wcscpy(pNewStorage[i].ServerName,
                       pOldStorage[i].ServerName);
                NextFreeMemory += NeedLen;
            }
            else {
                return ERROR_BUFFER_OVERFLOW;
            }

            pNewStorage[i].ShareName = (LPWSTR)NextFreeMemory;
            NeedLen = (wcslen(pOldStorage[i].ShareName) + 1) * sizeof(WCHAR);
            if (*pSizeRemaining >= NeedLen) 
            {
                *pSizeRemaining -= NeedLen;
                wcscpy(pNewStorage[i].ShareName, pOldStorage[i].ShareName);
                NextFreeMemory += NeedLen;
            }
            else {
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    
    case 2:
        pInfo->Info2.Comment = (LPWSTR)NextFreeMemory;
        NeedLen = (wcslen(pCurrent->Info2.Comment) + 1) * sizeof(WCHAR);
        if (*pSizeRemaining >= NeedLen) 
        {
            *pSizeRemaining -= NeedLen;
            wcscpy(pInfo->Info2.Comment, pCurrent->Info2.Comment);
            NextFreeMemory += NeedLen;
        }
        else {
            return ERROR_BUFFER_OVERFLOW;
        }
    case 1:

        pInfo->Info1.EntryPath = (LPWSTR)NextFreeMemory;

        NeedLen = (wcslen(pCurrent->Info1.EntryPath) + 1) * sizeof(WCHAR);
        if (*pSizeRemaining >= NeedLen)
        {
            *pSizeRemaining -= NeedLen;
            wcscpy(pInfo->Info1.EntryPath, pCurrent->Info1.EntryPath);
            NextFreeMemory += NeedLen;
        }
        else {
            return ERROR_BUFFER_OVERFLOW;
        }

        *ppCurrentBuffer = (LPBYTE)NextFreeMemory;
        break;

    default:
        Status = ERROR_INVALID_PARAMETER;
    }
    return Status;
}





DFSSTATUS
DfsStore::EnumerateRoots(
    BOOLEAN DomainRoots,
    PULONG_PTR pBuffer,
    PULONG  pBufferSize,
    PULONG pEntriesRead,
    ULONG MaxEntriesToRead,
    PULONG pCurrentNumRoots,
    LPDWORD pResumeHandle,
    PULONG pSizeRequired )
{

    ULONG RootCount = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    PULONG pDfsInfo;
    
    ULONG TotalSize, EntriesRead;
    BOOLEAN OverFlow = FALSE;
    ULONG ResumeRoot;
    
    //
    // We start with total size and entries read with the passed in
    // values, since we expect them to be initialized correctly, and 
    // possibly hold values from enumerations of other dfs flavors.
    //
    TotalSize = *pSizeRequired;
    EntriesRead = *pEntriesRead;
    
    //
    // point the dfsinfo300 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo = (PULONG)*pBuffer;

    //
    // We might not have to start at the beginning
    //
    ResumeRoot = 0;
    if (pResumeHandle && *pResumeHandle > 0)
    {
        ResumeRoot = *pResumeHandle;
    }

    //
    // now enumerate each child, and read its logical share name.
    // update the total size required: if we have sufficient space 
    // in the passed in buffer, copy the information into the buffer.
    //
    
    RootCount = 0;
    while (Status == ERROR_SUCCESS)
    {
        //
        // Cap the total number of roots we can read.
        //
        if (EntriesRead >= MaxEntriesToRead)
        {
            break;
        }
        Status = FindNextRoot(RootCount, &pRoot);

        if (Status == ERROR_SUCCESS)
        {
            RootCount++;
            
            //
            // We need to skip entries unless we get to the root we 
            // plan on resuming with.
            //
            if ((RootCount + *pCurrentNumRoots) > ResumeRoot)
            {
                PUNICODE_STRING pRootName;
                
                pRootName = pRoot->GetLogicalShare();

                if (DomainRoots == TRUE) 
                {
                    Status = AddRootEnumerationInfo200( pRootName,
                                                        (PDFS_INFO_200 *)(&pDfsInfo),
                                                        pBufferSize,
                                                        &EntriesRead,
                                                        &TotalSize );
                
                }
                else
                {
                    UNICODE_STRING Context;

                    Status = pRoot->GetVisibleContext(&Context);

                    if (Status == ERROR_SUCCESS)
                    {
                        Status = AddRootEnumerationInfo( &Context,
                                                         pRootName,
                                                         pRoot->GetRootFlavor(),
                                                         (PDFS_INFO_300 *)(&pDfsInfo),
                                                         pBufferSize,
                                                         &EntriesRead,
                                                         &TotalSize );
                        pRoot->ReleaseVisibleContext(&Context);
                    }
                }
                
                //
                // Continue on even if we get a buffer overflow.
                // We need to calculate the SizeRequired anyway.
                //
                if (Status == ERROR_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                    Status = ERROR_SUCCESS;
                }

                DFS_TRACE_HIGH(API, "enumeratin child %wZ, Status %x\n", pRootName, Status);
            }

            pRoot->ReleaseReference();
        }
        
    }

    //
    // if we broked out of the loop due to lack of children,
    // update the return pointers correctly.
    // if we had detected an overflow condition above, return overflow
    // otherwise return success.
    //
    *pSizeRequired = TotalSize; 
    *pEntriesRead = EntriesRead;
    
    if (Status == ERROR_NOT_FOUND)
    {
        if (OverFlow)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else
        {
            //
            // Don't return NO_MORE_ITEMS here because
            // the caller considers anything other than buffer overflow to be an error.
            // Before we return the final values, we'll adjust that
            // final status depending on the *total* number of
            // entries returned (which includes those returned from other stores).
            //
            Status = ERROR_SUCCESS;
        }
    }
    else if (OverFlow)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }
    
    //
    // We update resume handle only if we are returning success.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // the buffer is now pointing to the next unused pDfsInfo array 
        // entry: this lets the next enumerated flavor continue where
        // we left off.
        //
        
        *pBuffer = (ULONG_PTR)pDfsInfo;
        (*pCurrentNumRoots) += RootCount;
    }
        
    DFS_TRACE_NORM(REFERRAL_SERVER, "done with flavor read %x, Status %x\n", 
                   *pEntriesRead, Status);
    return Status;
}
   


DFSSTATUS
DfsStore::AddRootEnumerationInfo200(
    PUNICODE_STRING pRootName,
    PDFS_INFO_200 *ppDfsInfo200,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    PULONG pTotalSize )
{
    ULONG NeedSize;
    DFSSTATUS Status = ERROR_SUCCESS;

    DFS_TRACE_NORM(REFERRAL_SERVER, "add root enum: Read %d\n", *pEntriesRead);



    //
    // calculate amount of buffer space requirewd.
    //
    NeedSize = sizeof(DFS_INFO_200) + pRootName->MaximumLength;

    //
    // if it fits in the amount of space we have, we
    // can copy the info into the passed in buffer.
    //
    if (NeedSize <= *pBufferSize)
    {
        ULONG_PTR pStringBuffer;
        //
        // position the string buffer to the end of the buffer,
        // leaving enough space to copy the string.
        // This strategy allows us to treat the pDfsInfo200
        // as an array, marching forward from the beginning
        // of the buffer, while the strings are allocated
        // starting from the end of the buffer, since we
        // dont know how many pDfsInfo200 buffers we will
        // be using.
        //
        pStringBuffer = (ULONG_PTR)(*ppDfsInfo200) + *pBufferSize - pRootName->MaximumLength;
        wcscpy( (LPWSTR)pStringBuffer, pRootName->Buffer);
        (*ppDfsInfo200)->FtDfsName = (LPWSTR)pStringBuffer;
        *pBufferSize -= NeedSize;
        (*pEntriesRead)++;
        (*ppDfsInfo200)++;
    }
    else 
    {
        //
        // if the size does not fit, we have overflowed.
        //
        Status = ERROR_BUFFER_OVERFLOW;
    }
    //
    // set the total size under all circumstances.
    //
    *pTotalSize += NeedSize;


    DFS_TRACE_NORM(REFERRAL_SERVER, "add root enum: Read %d, Status %x\n", *pEntriesRead, Status);
    return Status;
}


DFSSTATUS
DfsStore::AddRootEnumerationInfo(
    PUNICODE_STRING pVisibleName,
    PUNICODE_STRING pRootName,
    DWORD Flavor,
    PDFS_INFO_300 *ppDfsInfo300,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    PULONG pTotalSize )
{
    ULONG NeedSize;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG StringLen;

    DFS_TRACE_NORM(REFERRAL_SERVER, "add root enum: Read %d\n", *pEntriesRead);

    //
    // calculate amount of buffer space required.
    //

    StringLen = sizeof(WCHAR) + 
                pVisibleName->Length + 
                sizeof(WCHAR) +
                pRootName->Length +
                sizeof(WCHAR);

    NeedSize = sizeof(DFS_INFO_300) + StringLen;

    //
    // if it fits in the amount of space we have, we
    // can copy the info into the passed in buffer.
    //
    if (NeedSize <= *pBufferSize)
    {
        LPWSTR pStringBuffer;
        //
        // position the string buffer to the end of the buffer,
        // leaving enough space to copy the string.
        // This strategy allows us to treat the pDfsInfo300
        // as an array, marching forward from the beginning
        // of the buffer, while the strings are allocated
        // starting from the end of the buffer, since we
        // dont know how many pDfsInfo300 buffers we will
        // be using.
        //
        pStringBuffer = (LPWSTR)((ULONG_PTR)(*ppDfsInfo300) + *pBufferSize - StringLen);
        RtlZeroMemory(pStringBuffer, StringLen);

        pStringBuffer[wcslen(pStringBuffer)] = UNICODE_PATH_SEP;
        RtlCopyMemory( &pStringBuffer[wcslen(pStringBuffer)],
                       pVisibleName->Buffer,
                       pVisibleName->Length);
        pStringBuffer[wcslen(pStringBuffer)] = UNICODE_PATH_SEP;
        RtlCopyMemory( &pStringBuffer[wcslen(pStringBuffer)],
                       pRootName->Buffer,
                       pRootName->Length);
        pStringBuffer[wcslen(pStringBuffer)] = UNICODE_NULL;

        (*ppDfsInfo300)->DfsName = (LPWSTR)pStringBuffer;
        (*ppDfsInfo300)->Flags = Flavor;
        *pBufferSize -= NeedSize;
        (*pEntriesRead)++;
        (*ppDfsInfo300)++;
    }
    else 
    {
        //
        // if the size does not fit, we have overflowed.
        //
        Status = ERROR_BUFFER_OVERFLOW;
    }
    //
    // set the total size under all circumstances.
    //
    *pTotalSize += NeedSize;


    DFS_TRACE_NORM(REFERRAL_SERVER, "add root enum: Read %d, Status %x\n", *pEntriesRead, Status);
    return Status;
}





DFSSTATUS
DfsStore::SetupADBlobRootKeyInformation(
    HKEY  DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsPhysicalShare )
{

    DWORD Status = ERROR_SUCCESS;
    HKEY FtDfsShareKey = NULL;
    size_t PhysicalShareCchLength = 0;
    size_t LogicalShareCchLength = 0;
    
    Status = RegCreateKeyEx( DfsKey,
                             DfsLogicalShare,
                             0,
                             L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &FtDfsShareKey,
                             NULL );

    //
    // Now set the values for this root key, so that we know 
    // the DN for the root, and the physical share on the machine
    // for the root, etc.
    //
    if (Status == ERROR_SUCCESS) {  
        
        Status = DfsStringCchLength( DfsPhysicalShare, 
                                  MAXUSHORT, 
                                  &PhysicalShareCchLength );
        if (Status == ERROR_SUCCESS)
        {
            PhysicalShareCchLength++; // NULL Terminator
            Status = RegSetValueEx( FtDfsShareKey,
                                DfsRootShareValueName,
                                0,
                                REG_SZ,
                                (PBYTE)DfsPhysicalShare,
                                PhysicalShareCchLength * sizeof(WCHAR) );

        }

        if (Status == ERROR_SUCCESS) {
                
            Status = DfsStringCchLength( DfsLogicalShare, 
                                      MAXUSHORT, 
                                      &LogicalShareCchLength );
            if (Status == ERROR_SUCCESS)
            {
                LogicalShareCchLength++; // NULL Terminator
                Status = RegSetValueEx( FtDfsShareKey,
                                    DfsLogicalShareValueName,
                                    0,
                                    REG_SZ,
                                    (PBYTE)DfsLogicalShare,
                                    LogicalShareCchLength * sizeof(WCHAR) );
            }
        }

        RegCloseKey( FtDfsShareKey );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_NAME_INFORMATION *ppInfo )
{
    PVOID pBlob = NULL;
    PVOID pUseBlob = NULL;
    ULONG BlobSize = 0;
    ULONG UseBlobSize = 0;
    PDFS_NAME_INFORMATION pNewInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    FILETIME BlobModifiedTime;

    Status = GetMetadataNameBlob( RootHandle,
                                  MetadataName,
                                  &pBlob,
                                  &BlobSize,
                                  &BlobModifiedTime );
    if (Status == ERROR_SUCCESS)
    {
        pNewInfo = new DFS_NAME_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_NAME_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = BlobSize;
            Status = PackGetNameInformation( pNewInfo,
                                             &pUseBlob,
                                             &UseBlobSize );
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pBlob;
        pNewInfo->DataSize = BlobSize;
        *ppInfo = pNewInfo;
    }


    return Status;
}
        
VOID
DfsStore::ReleaseMetadataNameInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    UNREFERENCED_PARAMETER(DfsHandle);

    ReleaseMetadataNameBlob( pNameInfo->pData,
                             pNameInfo->DataSize );

    delete [] pNameInfo;
}


DFSSTATUS
DfsStore::SetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    PVOID pBlob = NULL;
    ULONG BlobSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    SYSTEMTIME CurrentTime;
    FILETIME ModifiedTime;

    GetSystemTime( &CurrentTime);

    if (SystemTimeToFileTime( &CurrentTime, &ModifiedTime ))
    {
        pNameInfo->LastModifiedTime = ModifiedTime;
    }

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pBlob,
                                        &BlobSize );
    if (Status == ERROR_SUCCESS)
    {
        Status = SetMetadataNameBlob( RootHandle,
                                      MetadataName,
                                      pBlob,
                                      BlobSize );

        ReleaseMetadataNameBlob( pBlob, BlobSize );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_REPLICA_LIST_INFORMATION *ppInfo )
{
    PVOID pBlob = NULL;
    PVOID pUseBlob = NULL;
    ULONG BlobSize =0;
    ULONG UseBlobSize = 0;
    PDFS_REPLICA_LIST_INFORMATION pNewInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;


    Status = GetMetadataReplicaBlob( RootHandle,
                                     MetadataName,
                                     &pBlob,
                                     &BlobSize,
                                     NULL );

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo = new DFS_REPLICA_LIST_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_REPLICA_LIST_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = BlobSize;

            Status = PackGetULong( &pNewInfo->ReplicaCount,
                                   &pUseBlob,
                                   &UseBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                pNewInfo->pReplicas = new DFS_REPLICA_INFORMATION[ pNewInfo->ReplicaCount];
                if ( pNewInfo->pReplicas != NULL )
                {
                    Status = PackGetReplicaInformation(pNewInfo, 
                                                       &pUseBlob,
                                                       &UseBlobSize );
                }
                else
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                if(pNewInfo->pReplicas != NULL)
                {
                    delete [] pNewInfo->pReplicas;
                }

                delete pNewInfo;
            }
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataReplicaBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pBlob;
        pNewInfo->DataSize = BlobSize;
        *ppInfo = pNewInfo;
    }

    return Status;
}

        
VOID
DfsStore::ReleaseMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    UNREFERENCED_PARAMETER(DfsHandle);
    ReleaseMetadataReplicaBlob( pReplicaListInfo->pData,
                                pReplicaListInfo->DataSize );

    delete [] pReplicaListInfo->pReplicas;
    delete [] pReplicaListInfo;

}

DFSSTATUS
DfsStore::SetMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    PVOID pBlob = NULL;
    ULONG BlobSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                               &pBlob,
                                               &BlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = SetMetadataReplicaBlob( RootHandle,
                                         MetadataName,
                                         pBlob,
                                         BlobSize );

        ReleaseMetadataReplicaBlob( pBlob, BlobSize );
    }

    return Status;
}


DFSSTATUS
DfsStore::CreateNameInformationBlob(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    OUT PVOID *ppBlob,
    OUT PULONG pDataSize )
{
    PVOID pBlob = NULL;
    PVOID pUseBlob = NULL;
    ULONG BlobSize = 0;
    ULONG UseBlobSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    BlobSize = PackSizeNameInformation( pDfsNameInfo );
    
    Status = AllocateMetadataNameBlob( &pBlob,
                                       BlobSize );

    if ( Status == ERROR_SUCCESS )
    {
        pUseBlob = pBlob;
        UseBlobSize = BlobSize;

        // Pack the name information into the binary stream allocated.
        //
        Status = PackSetNameInformation( pDfsNameInfo,
                                         &pUseBlob,
                                         &UseBlobSize );
        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameBlob( pBlob, BlobSize );
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        *ppBlob = pBlob;
        *pDataSize = BlobSize - UseBlobSize;
    }

    return Status;
}


DFSSTATUS
DfsStore::CreateReplicaListInformationBlob(
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    OUT PVOID *ppBlob,
    OUT PULONG pDataSize )
{
    PVOID pBlob = NULL;
    PVOID pUseBlob = NULL;
    ULONG BlobSize = 0;
    ULONG UseBlobSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    BlobSize = PackSizeULong();
    BlobSize += PackSizeReplicaInformation( pReplicaListInfo );
    
    BlobSize += PackSizeULong();
    Status = AllocateMetadataReplicaBlob( &pBlob,
                                          BlobSize );

    if ( Status == ERROR_SUCCESS )
    {
        pUseBlob = pBlob;
        UseBlobSize = BlobSize;


        //
        // The first item in the stream is the number of replicas
        //
        Status = PackSetULong(pReplicaListInfo->ReplicaCount,
                              &pUseBlob,
                              &UseBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            //
            // We than pack the array of replicas into the binary stream
            //
            Status = PackSetReplicaInformation( pReplicaListInfo,
                                                &pUseBlob,
                                                &UseBlobSize );
        }

        if (Status == ERROR_SUCCESS)
        {
            //
            // We than pack the last word with a 0 so that all the
            // old crap still works.
            //
            Status = PackSetULong( 0,
                                   &pUseBlob,
                                   &UseBlobSize );

        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataReplicaBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppBlob = pBlob;
        *pDataSize = BlobSize - UseBlobSize;
    }

    return Status;
}








DFSSTATUS
DfsStore::AddChildReplica (
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath )
{
    PDFS_REPLICA_LIST_INFORMATION pReplicaList = NULL;
    PDFS_REPLICA_INFORMATION pReplicaInfo = NULL;
    ULONG ReplicaIndex = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    WCHAR * NameToCheck = NULL;
    DFS_REPLICA_LIST_INFORMATION NewList;
    UNICODE_STRING DfsSharePath;
    UNICODE_STRING DfsServerName;

    DFS_TRACE_HIGH(API, "AddChildReplica for path %ws, Server=%ws Share=%ws \n", LinkMetadataName, ServerName, SharePath);

    if ( (ServerName == NULL) || (SharePath == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsSharePath, SharePath );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsServerName, ServerName );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = GetMetadataReplicaInformation( DfsHandle,
                                            LinkMetadataName,
                                            &pReplicaList );

    if (Status == ERROR_SUCCESS)
    {
        ReplicaIndex = FindReplicaInReplicaList( pReplicaList, 
                                                 ServerName,
                                                 SharePath );
        if (ReplicaIndex < pReplicaList->ReplicaCount)
        {
            Status = ERROR_FILE_EXISTS;
        }
        else if(pReplicaList->ReplicaCount == 1)
        {
            pReplicaInfo = &pReplicaList->pReplicas[0];

            NameToCheck = new WCHAR[pReplicaInfo->ServerName.Length/sizeof(WCHAR) + 1];
            if(NameToCheck != NULL)
            {
                RtlCopyMemory(NameToCheck, pReplicaInfo->ServerName.Buffer, pReplicaInfo->ServerName.Length);

                NameToCheck[pReplicaInfo->ServerName.Length / sizeof(WCHAR)] = UNICODE_NULL;

                //if this is a domain name, fail the request with not supported.
                //else continue on.
                Status = I_NetDfsIsThisADomainName(NameToCheck);
                if(Status == ERROR_SUCCESS)
                {
                    Status = ERROR_NOT_SUPPORTED;
                }
                else
                {
                    Status = ERROR_SUCCESS;
                }

                delete [] NameToCheck; 
            }
            else
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }

        }

        if (Status == ERROR_SUCCESS)
        {
            RtlZeroMemory( &NewList, sizeof(DFS_REPLICA_LIST_INFORMATION));
            NewList.ReplicaCount = pReplicaList->ReplicaCount + 1;
            NewList.pReplicas = new DFS_REPLICA_INFORMATION [ NewList.ReplicaCount ];
            if (NewList.pReplicas == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else 
            {
                if (pReplicaList->ReplicaCount)
                {
                    RtlCopyMemory( &NewList.pReplicas[0],
                                   &pReplicaList->pReplicas[0],
                                   pReplicaList->ReplicaCount * sizeof(DFS_REPLICA_INFORMATION) );
                }

                pReplicaInfo = &NewList.pReplicas[pReplicaList->ReplicaCount];
                RtlZeroMemory( pReplicaInfo,
                               sizeof(DFS_REPLICA_INFORMATION) );

                DfsRtlInitUnicodeStringEx(&pReplicaInfo->ServerName, DfsServerName.Buffer);
                DfsRtlInitUnicodeStringEx(&pReplicaInfo->ShareName, DfsSharePath.Buffer);

                pReplicaInfo->ReplicaState = DFS_STORAGE_STATE_ONLINE;
                pReplicaInfo->ReplicaType = 2; // hack fro backwards compat.

                Status = SetMetadataReplicaInformation( DfsHandle,
                                                        LinkMetadataName,
                                                        &NewList );
                delete [] NewList.pReplicas;
            }
        }

        ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
    }


    DFS_TRACE_HIGH(API, "AddChildReplica for path %ws, Server=%ws Share=%ws, Status=%d\n", LinkMetadataName, 
                         ServerName, SharePath, Status);
    return Status;
}



DFSSTATUS
DfsStore::RemoveChildReplica (
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath,
    PBOOLEAN pLastReplica,
    BOOLEAN Force)
{

    PDFS_REPLICA_LIST_INFORMATION pReplicaList = NULL;
    ULONG DeleteIndex = 0;
    ULONG NextIndex = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFS_REPLICA_LIST_INFORMATION NewList;

    DFS_TRACE_HIGH(API, "RemoveChildReplica for path %ws, Server=%ws Share=%ws \n", LinkMetadataName, ServerName, SharePath);

    *pLastReplica = FALSE;
    RtlZeroMemory( &NewList,
                   sizeof(DFS_REPLICA_LIST_INFORMATION));


    if ( (ServerName == NULL) || (SharePath == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = GetMetadataReplicaInformation( DfsHandle,
                                            LinkMetadataName,
                                            &pReplicaList );

    if (Status == ERROR_SUCCESS)
    {
        DeleteIndex = FindReplicaInReplicaList( pReplicaList, 
                                                ServerName,
                                                SharePath );

        DFS_TRACE_HIGH(API, "DfsRemove for path %ws, Server=%ws Share=%ws, DeleteIndex=%d,pReplicaList->ReplicaCount=%d \n", LinkMetadataName, 
                             ServerName, SharePath, DeleteIndex, pReplicaList->ReplicaCount);

        if (DeleteIndex < pReplicaList->ReplicaCount)
        {
            NewList.ReplicaCount = pReplicaList->ReplicaCount - 1;

            if (NewList.ReplicaCount)
            {
                NewList.pReplicas = new DFS_REPLICA_INFORMATION [NewList.ReplicaCount];
                if (NewList.pReplicas != NULL)
                {
                    if (DeleteIndex)
                    {
                        RtlCopyMemory( &NewList.pReplicas[0],
                                       &pReplicaList->pReplicas[0],
                                       DeleteIndex * sizeof(DFS_REPLICA_INFORMATION) );
                    }

                    NextIndex = DeleteIndex + 1;

                    if ( NextIndex < pReplicaList->ReplicaCount)
                    {
                        RtlCopyMemory( &NewList.pReplicas[DeleteIndex],
                                       &pReplicaList->pReplicas[NextIndex],
                                       (pReplicaList->ReplicaCount - NextIndex) * sizeof(DFS_REPLICA_INFORMATION) );
                    }
                }
                else {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            //if this is the last target, do not remove it. Return ERROR_LAST_ADMIN
            //to the upper code, so that he can remove the last target and link in one
            //atomic operation. 
            if (Status == ERROR_SUCCESS)
            {
                if(NewList.ReplicaCount == 0)
                {
                    *pLastReplica = TRUE;
                }

                if( (Force == FALSE) && (NewList.ReplicaCount == 0))
                {
                    Status = ERROR_LAST_ADMIN;
                }
                else
                {
                    Status = SetMetadataReplicaInformation( DfsHandle,
                                                            LinkMetadataName,
                                                            &NewList );
                }

            }
            if (NewList.pReplicas != NULL)
            {
                delete [] NewList.pReplicas;
            }
        }
        else {
            Status = ERROR_FILE_NOT_FOUND;
        }

        ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
    }

    DFS_TRACE_HIGH(API, "DfsRemove for path %ws, Server=%ws Share=%ws, LastReplica=%d, Status=%d\n", LinkMetadataName, 
                         ServerName, SharePath, *pLastReplica, Status);
    return Status;
}






DFSSTATUS
DfsStore::GetStoreApiInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    LPWSTR LinkMetadataName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    PLONG pSizeRequired )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_NAME_INFORMATION pNameInformation = NULL;
    PDFS_REPLICA_LIST_INFORMATION pReplicaList = NULL;
    PDFS_REPLICA_INFORMATION pReplica = NULL;
    PDFS_API_INFO pInfo = (PDFS_API_INFO)pBuffer;
    PDFS_STORAGE_INFO pStorage = NULL;
    LONG HeaderSize = 0;
    LONG AdditionalSize = 0;
    ULONG_PTR NextFreeMemory = NULL;
    ULONG i = 0;
    UNICODE_STRING UsePrefixName;
    DFS_API_INFO LocalInfo;




    RtlZeroMemory(&LocalInfo, sizeof(DFS_API_INFO));


    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );

    if (Status == ERROR_SUCCESS)
    {
        Status = GenerateApiLogicalPath( pRootName, 
                                         &pNameInformation->Prefix,
                                         &UsePrefixName );
        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameInformation( DfsHandle, pNameInformation );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadataReplicaInformation( DfsHandle,
                                                LinkMetadataName,
                                                &pReplicaList );

        if (Status == ERROR_SUCCESS)
        {
            switch (Level)
            {
            case 100:
                if (HeaderSize == 0)
                {
                    HeaderSize = sizeof(DFS_INFO_100);
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info100 + 1);
                }
                AdditionalSize += pNameInformation->Comment.Length + sizeof(WCHAR);
                break;

                
            case 4:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_4);
                    LocalInfo.Info4.Timeout = pNameInformation->Timeout;
                    LocalInfo.Info4.State = pNameInformation->State;
                    LocalInfo.Info4.NumberOfStorages = pReplicaList->ReplicaCount;
                    pStorage = LocalInfo.Info4.Storage = (PDFS_STORAGE_INFO)(&pInfo->Info4 + 1);
                    NextFreeMemory = (ULONG_PTR)(LocalInfo.Info4.Storage + LocalInfo.Info4.NumberOfStorages);
                }

            case 3:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_3);
                    LocalInfo.Info3.State = pNameInformation->State;
                    LocalInfo.Info3.NumberOfStorages = pReplicaList->ReplicaCount;
                    pStorage = LocalInfo.Info3.Storage = (PDFS_STORAGE_INFO)(&pInfo->Info3 + 1);
                    NextFreeMemory = (ULONG_PTR)(LocalInfo.Info3.Storage + LocalInfo.Info3.NumberOfStorages);
                }

                for (i = 0; i < pReplicaList->ReplicaCount; i++)
                {

                    UNICODE_STRING ServerName = pReplicaList->pReplicas[i].ServerName;

                    if (IsLocalName(&ServerName))
                    {
                        ServerName = *pRootName;
                    }
                    AdditionalSize += ( sizeof(DFS_STORAGE_INFO) + 
                                        ServerName.Length + sizeof(WCHAR) + 
                                        pReplicaList->pReplicas[i].ShareName.Length + sizeof(WCHAR) );

                }

            case 2:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_2);
                    LocalInfo.Info2.State = pNameInformation->State;
                    LocalInfo.Info2.NumberOfStorages = pReplicaList->ReplicaCount;
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info2 + 1);
                }

                AdditionalSize += pNameInformation->Comment.Length + sizeof(WCHAR);

            case 1:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_1);
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info1 + 1);
                }
                AdditionalSize += UsePrefixName.Length + sizeof(WCHAR);
                break;

            default:
             
                Status = ERROR_INVALID_PARAMETER;
                break;
        
            }
            *pSizeRequired = HeaderSize + AdditionalSize;
            if (*pSizeRequired > BufferSize)
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }

            if (Status == ERROR_SUCCESS)
            {

                RtlZeroMemory( pBuffer, *pSizeRequired);
                RtlCopyMemory( &pInfo->Info4, &LocalInfo.Info4, HeaderSize );

                switch (Level)
                {

                //
                // Extract just the comment for this root/link.
                //
                case 100:

                    pInfo->Info100.Comment = (LPWSTR)NextFreeMemory;
                    NextFreeMemory += pNameInformation->Comment.Length + sizeof(WCHAR);
                    RtlCopyMemory( pInfo->Info100.Comment, 
                                   pNameInformation->Comment.Buffer,
                                   pNameInformation->Comment.Length );
                    break;

                    
                case 4:
                case 3:
                    for (i = 0; i < pReplicaList->ReplicaCount; i++)
                    {
                        UNICODE_STRING ServerName = pReplicaList->pReplicas[i].ServerName;

                        if (IsLocalName(&ServerName))
                        {
                            ServerName = *pRootName;
                        }

                        pReplica = &pReplicaList->pReplicas[i];
                        pStorage[i].State = pReplica->ReplicaState;
                        pStorage[i].ServerName = (LPWSTR)NextFreeMemory;
                        NextFreeMemory += ServerName.Length + sizeof(WCHAR);
                        pStorage[i].ShareName = (LPWSTR)NextFreeMemory;
                        NextFreeMemory += pReplica->ShareName.Length + sizeof(WCHAR);

                        RtlCopyMemory( pStorage[i].ServerName, 
                                       ServerName.Buffer,
                                       ServerName.Length );

                        RtlCopyMemory( pStorage[i].ShareName, 
                                       pReplica->ShareName.Buffer,
                                       pReplica->ShareName.Length );
                    }

                case 2:

                    pInfo->Info2.Comment = (LPWSTR)NextFreeMemory;
                    NextFreeMemory += pNameInformation->Comment.Length + sizeof(WCHAR);
                    RtlCopyMemory( pInfo->Info2.Comment, 
                                   pNameInformation->Comment.Buffer,
                                   pNameInformation->Comment.Length );

                case 1:

                    pInfo->Info1.EntryPath = (LPWSTR)NextFreeMemory;

                    RtlCopyMemory(  pInfo->Info1.EntryPath,
                                    UsePrefixName.Buffer,
                                    UsePrefixName.Length );
                    pInfo->Info1.EntryPath[UsePrefixName.Length/sizeof(WCHAR)]  = UNICODE_NULL;

                    break;
                }
            }
            ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
        }
        ReleaseApiLogicalPath( &UsePrefixName );
        ReleaseMetadataNameInformation( DfsHandle, pNameInformation );
    }

    return Status;
}

   

DFSSTATUS
DfsStore::GetExtendedAttributes(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    PULONG pAttr)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_NAME_INFORMATION pNameInformation = NULL;

    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    *pAttr = (pNameInformation->Type & PKT_ENTRY_TYPE_EXTENDED_ATTRIBUTES);

    ReleaseMetadataNameInformation( DfsHandle, pNameInformation );
    
    return Status;
}

DFSSTATUS
DfsStore::SetExtendedAttributes(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    ULONG Attr)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_NAME_INFORMATION pNameInformation = NULL;
    ULONG UseAttr;
     
    UseAttr = Attr & PKT_ENTRY_TYPE_EXTENDED_ATTRIBUTES;

    if (UseAttr != Attr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pNameInformation->Type &= ~PKT_ENTRY_TYPE_EXTENDED_ATTRIBUTES;
    pNameInformation->Type |= UseAttr;

    Status = SetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         pNameInformation );
    
    ReleaseMetadataNameInformation( DfsHandle, pNameInformation );

    return Status;
}



DFSSTATUS
DfsStore::SetStoreApiInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath,
    DWORD Level,
    LPBYTE pBuffer )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_NAME_INFORMATION pNameInformation = NULL;
    BOOLEAN TypeInfoSet = FALSE;
    
    //
    // The set is a little strange: the pBuffer is pointing to a pointer 
    // that we are interested in. Grab it directly.
    // dfsdev: this is confusing, fix it or document in detail.
    //
    PDFS_API_INFO pApiInfo = (PDFS_API_INFO)(*(PULONG_PTR)pBuffer);
    if(pApiInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // dfsdev: need to do some api work before enabling code
    // below.
    //
#if 0
    if ( (ServerName != NULL) || (SharePath != NULL) )
    {
        if (Level != 101)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
#endif

    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }


    switch (Level)
    {
    case 100:
        Status = DfsRtlInitUnicodeStringEx( &pNameInformation->Comment,
                                            pApiInfo->Info100.Comment );
        if(Status == ERROR_SUCCESS)
        {
            Status = SetMetadataNameInformation( DfsHandle,
                                                 LinkMetadataName,
                                                 pNameInformation );
        }

        break;

    case 102:
        pNameInformation->Timeout = pApiInfo->Info102.Timeout;

        Status = SetMetadataNameInformation( DfsHandle,
                                             LinkMetadataName,
                                             pNameInformation );

        break;

    case 101:

        if ((ServerName == NULL) && (SharePath == NULL))
        {
            pNameInformation->State = pApiInfo->Info101.State;

            Status = SetMetadataNameInformation( DfsHandle,
                                                 LinkMetadataName,
                                                 pNameInformation );
        }
        else {
            PDFS_REPLICA_LIST_INFORMATION pReplicaList;
            ULONG ReplicaIndex;

            Status = GetMetadataReplicaInformation (DfsHandle,
                                                    LinkMetadataName,
                                                    &pReplicaList );
            if (Status == ERROR_SUCCESS)
            {
                ReplicaIndex = FindReplicaInReplicaList( pReplicaList,
                                                         ServerName,
                                                         SharePath );

                if (ReplicaIndex >= pReplicaList->ReplicaCount)
                {
                    Status = ERROR_NOT_FOUND;
                }
                else {
                    DFS_REPLICA_LIST_INFORMATION NewList;

                    RtlZeroMemory( &NewList, sizeof( DFS_REPLICA_LIST_INFORMATION) );
                    NewList.ReplicaCount = pReplicaList->ReplicaCount;
                    NewList.pReplicas = new DFS_REPLICA_INFORMATION [ NewList.ReplicaCount ];
                    if (NewList.pReplicas != NULL)
                    {
                        RtlCopyMemory( &NewList.pReplicas[0],
                                       &pReplicaList->pReplicas[0],
                                       NewList.ReplicaCount * sizeof(DFS_REPLICA_INFORMATION) );
                        NewList.pReplicas[ReplicaIndex].ReplicaState = pApiInfo->Info101.State;
                        NewList.pReplicas[ReplicaIndex].ReplicaType = 2; // hack fro backwards compat.
                        Status = SetMetadataReplicaInformation (DfsHandle,
                                                                LinkMetadataName,
                                                                &NewList );

                        delete [] NewList.pReplicas;
                    }
                    else {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
            }
        }
        break;
        
    default:
        Status = ERROR_INVALID_PARAMETER;
        break;
    }

    ReleaseMetadataNameInformation( DfsHandle, pNameInformation );

    return Status;
}



DFSSTATUS
DfsStore::GetStoreApiInformationBuffer(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    LPWSTR LinkMetadataName,
    DWORD Level,
    LPBYTE *ppBuffer,
    PLONG  pBufferSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LONG RequiredSize = 0;

    LONG BufferSize = 4096;
    LPBYTE pBuffer = new BYTE [ BufferSize ];

    if (pBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = GetStoreApiInformation( DfsHandle,
                                     pRootName,
                                     LinkMetadataName,
                                     Level,
                                     pBuffer,
                                     BufferSize,
                                     &RequiredSize );

    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        delete [] pBuffer;
        BufferSize = RequiredSize;
        pBuffer = new BYTE[ BufferSize ];
        if (pBuffer == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            Status = GetStoreApiInformation( DfsHandle,
                                             pRootName,
                                             LinkMetadataName,
                                             Level,
                                             pBuffer,
                                             BufferSize,
                                             &RequiredSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppBuffer = pBuffer;
        *pBufferSize = RequiredSize;
    }
    else
    {
        if(pBuffer != NULL)
        {
            delete [] pBuffer;
        }
    }
    return Status;
}


DFSSTATUS
DfsStore::FindNextRoot(
    ULONG RootNum,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    ULONG Start = 0;


    DFS_TRACE_LOW( REFERRAL_SERVER, "Store %p, Find next root %d\n",
                   this, RootNum );
    //
    // Lock the store, so that we dont have new roots coming in while
    // we are taking a look.
    //
    Status = AcquireReadLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // The default return status is ERROR_NOT_FOUND;
    //
    Status = ERROR_NOT_FOUND;

    //
    // Run through our list of DFS roots, and see if any of them match
    // the passed in name context and logical share.
    //

    pRoot = _DfsRootList;
    Start = 0;

    if (pRoot != NULL)
    {
        do
        {
            if (Start++ == RootNum)
            {
                Status = ERROR_SUCCESS;
                break;
            }
            pRoot = pRoot->pNextRoot;
        } while ( pRoot != _DfsRootList );
    }

    //
    // IF we found a matching root, bump up its reference count, and
    // return the pointer to the root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pRoot->AcquireReference();
        *ppRootFolder = pRoot;

    }

    ReleaseLock();

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Done find next %d, root %p status %x\n",
                         RootNum, pRoot, Status);
    return Status;
}

//
// the store syncrhonizer: syncrhonizes roots that we already know of.
// Note that we could be racing with a delete: in the worst case we will
// resync the same root more than once.
//

VOID
DfsStore::StoreSynchronizer()
{
    ULONG RootNum = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;

    while (Status != ERROR_NOT_FOUND)
    {
        Status = FindNextRoot(RootNum++, &pRoot);
        if (Status == ERROR_SUCCESS)
        {
            Status = pRoot->Synchronize();

            DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Root %p Synchronize Status %x\n", this, Status);

            pRoot->ReleaseReference();
        }
    }
    return NOTHING;
}

DFSSTATUS
DfsStore::LoadServerSiteDataPerRoot(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;

    Status = AcquireReadLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    pRoot = _DfsRootList;
    if(pRoot != NULL)    
    {

        do
        {

            pRoot->PreloadServerSiteData();

            pRoot = pRoot->pNextRoot;
        } while ( pRoot != _DfsRootList  );
    }


    ReleaseLock();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssitecostcache.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "dsgetdc.h"
#include "lm.h"
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <winsock2.h>
#include <DfsSiteCostCache.hxx>
#include <DfsSite.hxx>

#include "DfsSiteCostCache.tmh"

//
// Create a DFS_SITE_COST_DATA structure that is ready to
// get inserted in to the SiteCost Cache.
//
DFSSTATUS
DfsSiteCostCache::CreateCostData (
    DfsSite *pDestinationSite,
    ULONG Cost, 
    DFSSTATUS ValidityStatus,
    PDFS_SITE_COST_DATA *ppNewData)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_SITE_COST_DATA pData = NULL;
    
    pData = (PDFS_SITE_COST_DATA) DfsAllocateHashData( sizeof( DFS_SITE_COST_DATA ));

    if (pData != NULL)
    {
        RtlZeroMemory(pData, sizeof(DFS_SITE_COST_DATA));
        pData->Header.RefCount = 1;
        pData->Header.pData = (PVOID)pData;
        pData->ValidityStatus = ValidityStatus;
        pData->Cost = Cost;
        pData->AccessTime = GetTickCount();
                
        //
        // Key is the referenced pointer to the destination site itself.
        //
        pDestinationSite->AcquireReference();
        pData->pDestinationSite = pDestinationSite;
        pData->Header.pvKey = (PVOID)pData->pDestinationSite;
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    *ppNewData = pData;

    return Status;
}

DFSSTATUS    
DfsSiteCostCache::Initialize(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SHASH_FUNCTABLE FunctionTable;

    ZeroMemory(&FunctionTable, sizeof(FunctionTable));

    FunctionTable.NumBuckets = DFS_DEFAULT_SITE_COST_NUM_BUCKETS;
    FunctionTable.CompareFunc = DfsCompareDfsSites;
    FunctionTable.HashFunc = DfsHashDfsSite;
    FunctionTable.AllocFunc = DfsAllocateHashData;
    FunctionTable.FreeFunc = DfsDeallocateHashData;
    FunctionTable.AllocHashEntryFunc = DfsAllocateHashData;
    FunctionTable.FreeHashEntryFunc = DfsSiteCostCache::DfsDeallocateSiteCostData;

    NtStatus = ShashInitHashTable(&_pSiteCostTable, &FunctionTable);
    Status = RtlNtStatusToDosError(NtStatus);

    return Status;

}

// Just delete the cache data entry.
VOID
DfsSiteCostCache::DfsDeallocateSiteCostData(PVOID pPointer )
{
    PDFS_SITE_COST_DATA pSiteStructure = (PDFS_SITE_COST_DATA)pPointer;

    if (pSiteStructure)
    {
        if (pSiteStructure->pDestinationSite != NULL)
        {
            pSiteStructure->pDestinationSite->ReleaseReference();
        }
        delete [] (PBYTE)pSiteStructure;
    }
}

//
// Create the hash entry and insert it in the hash table.
//
DFSSTATUS
DfsSiteCostCache::SetCost(
    DfsSite *pDestinationSite,
    ULONG Cost,
    DWORD ValidityStatus)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_SITE_COST_DATA pCostData = NULL;

    Status = CreateCostData( pDestinationSite, 
                           Cost,
                           ValidityStatus,
                           &pCostData );

    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = SetCostData( pDestinationSite,
                        pCostData );

    return Status;
}


//-------------------------------------------------------------------------
// GetCost
//
// Given a target site, return it's cost. We know that the Source and the Destination
// sites are NOT the same at this point.
// 
// This returns ERROR_SUCCESS if it finds a valid cost.
//            ERROR_NOT_FOUND if the caller needs to GenerateCostMatrix.
//            
// 
//-------------------------------------------------------------------------
DFSSTATUS
DfsSiteCostCache::GetCost ( 
    DfsSite *pDestinationSite,
    PULONG pCost) 
{
    DFSSTATUS Status = ERROR_NOT_FOUND;
    PDFS_SITE_COST_DATA pData = NULL;

    *pCost = DFS_MAX_COST;
    pData = (PDFS_SITE_COST_DATA)SHashLookupKeyEx(_pSiteCostTable,
                                                   (PVOID)pDestinationSite);

    if (pData != NULL)
    {  
        // See if the entry has expired.
        if (IsTimeToRefresh( pData ))
        {
            // Ask the caller to retry and replace this entry.
            ASSERT(Status == ERROR_NOT_FOUND);
            NOTHING;                
        }
        // See if DS had returned an errorneous entry.
        else if (pData->ValidityStatus == ERROR_SUCCESS)
        {
            *pCost = pData->Cost; 
            Status = ERROR_SUCCESS;
        } 
        // See if it's time for us to try getting this entry again.
        else if (IsTimeToRetry( pData ))
        {
            //
            // Return ERROR_NOT_FOUND because we'd like the caller to retry.
            //
            ASSERT(Status == ERROR_NOT_FOUND);
            NOTHING;
        } 
        else
        {  
            //
            // We know at this point that we don't want the caller to retry or refresh.
            // We also know that we need to fallback on using the default max cost.
            //
            *pCost = DFS_MAX_COST;
            Status = ERROR_SUCCESS;
        }
    } 
    
    return Status;
}

DFSSTATUS
DfsSiteCostCache::RemoveCost(
    DfsSite *pSite)
{
    NTSTATUS NtStatus;

    NtStatus = SHashRemoveKey(_pSiteCostTable, 
                              pSite,
                              NULL ); 
    return RtlNtStatusToDosError( NtStatus );

}

VOID
DfsSiteCostCache::InvalidateCache(VOID)
{
    SHASH_ITERATOR Iter;
    DfsSite *pSite = NULL;
    
    pSite = StartSiteEnumerate( &Iter );
    while (pSite != NULL)
    {
        //
        // Remove this item. There's nothing we can do if we hit errors
        // except to keep going.
        //    
        (VOID)RemoveCost( pSite );
        pSite = NextSiteEnumerate( &Iter );
    }
    FinishSiteEnumerate( &Iter );
    
    DFS_TRACE_LOW( REFERRAL, "SiteCostCache %p: invalidate cache done\n", this);
}

        
//------------------------------
// DfsSiteCostSupport
//
// Static constructor
//------------------------------

DFSSTATUS 
DfsSiteCostSupport::DfsCreateSiteCostSupport( 
    DfsSiteCostSupport **ppSup )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsSiteCostSupport *pSup = NULL;

    *ppSup = NULL;
    
    do {
        pSup = new DfsSiteCostSupport;
        if (pSup == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        // This doesn't create the hashtable yet. That's done
        // later as needed.
        Status = pSup->Initialize();
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        *ppSup = pSup;
        
    } while (FALSE);

    // Error path
    if (Status != ERROR_SUCCESS)
    {
        if (pSup != NULL) 
        {
            delete pSup;
            pSup = NULL;
        }
    }
    
    return Status;
}

//
// Return a referenced site cache for either lookups or 
// inserts. This guarantees 
DFSSTATUS
DfsSiteCostSupport::Acquire( 
    DfsSiteCostCache **ppCache )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG CachesToTrim = 0;
    *ppCache = NULL;
    
    //
    // Return a referenced SiteCostCache.
    //
    EnterCriticalSection( &_SiteCostLock );
    {
        do {
        
            if (_pCostTable != NULL)
            { 
                // Put this at the head of the table.
                MoveToFrontOfMruList();
                break;
            }
            _pCostTable = new DfsSiteCostCache;
            if (_pCostTable == NULL) 
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            //
            // Initialize the hashtable of sitenames-to-cost mappings.
            // We'll need to populate this later.
            //
            Status = _pCostTable->Initialize();
            if (Status != ERROR_SUCCESS)
            {
                delete _pCostTable;
                _pCostTable = NULL;
                break;
            }
            
            _InUseCount = 1;
    
            //
            // Add ourselves to the MRU list because we are a real table now.
            //
            CachesToTrim = InsertInMruList();
            
        } while (FALSE);

        //
        // We are already in the critical section. 
        // No need to do atomic increments.
        //
        if (Status == ERROR_SUCCESS)
        {
            _InUseCount++;
            *ppCache = _pCostTable;

            // We mark the time at acquire time, as opposed to individual lookups and inserts
            // that happen on the table. This assumes that the current reference taken
            // on this cache is not long lived. That indeed is a
            // primary assumption behind this container class.
            _LastAccessTime = GetTickCount();
        }
        ASSERT( Status == ERROR_SUCCESS || _pCostTable == NULL );
    } 
    LeaveCriticalSection( &_SiteCostLock );

    //
    // In a real degenerate case, the following may even throw out what we've just
    // generated above. We are safe though, because we hold a reference
    // until the referral is done.
    //
    if (CachesToTrim)
    {
        TrimSiteCostCaches( CachesToTrim );
    }
    return Status;
}


//
// Callers are expected to pair all Acquires above with this Release.
// This decrements the in use count, and if it reaches zero, which
// only happens when it's earmarked for deletion, swaps the cost table
// with a NULL. The actual deletion will then proceed unsynchronized.
//
VOID
DfsSiteCostSupport::Release( VOID )
{
    DfsSiteCostCache *pOldTable = NULL;
    
    EnterCriticalSection( &_SiteCostLock );
    {
        //
        // If this is the last reference, get rid of
        // the cache completely. This will only happen
        // if we are actually trying to get rid this to
        // trim the down the total number of caches
        // sitting around. (See TrimSiteCaches)
        //
        if (_pCostTable != NULL)
        {
            _InUseCount--;
            if (_InUseCount == 0)
            {
                // ASSERT( InMruList == FALSE ); //(unsafe)
                pOldTable = _pCostTable;
                _pCostTable = NULL;
                DfsServerGlobalData.NumSiteCostTables--;
                _LastAccessTime = 0;
            }
        }
    }
    LeaveCriticalSection( &_SiteCostLock );

    //
    // Delete the site cost table altogether.
    //
    if (pOldTable != NULL)
    {
        pOldTable->ReleaseReference();
    }   

    return;
}

//
// This starts the deletion proceeding of a SiteCostCache.
// It is safe to call this multiple times, because it'll only
// take the table off the MRU list only once.
// The eventual deletion will happen in Release above
// quite possibly at a later point.
//
// DfsSiteNameSupport calls this.
// 
VOID
DfsSiteCostSupport::MarkForDeletion( VOID )
{
    BOOLEAN Delete = FALSE;
    
    EnterCriticalSection( &_SiteCostLock );
    {
        if (_pCostTable != NULL)
        {
            Delete = RemoveFromMruList();
        }
    }
    LeaveCriticalSection( &_SiteCostLock );
    
    // 
    // We needed to get out of the critical section to call Release
    // which will mark it for deletion                                                                                                                                                                         deletion.
    // 
    if (Delete)
    {
        Release();
    }  
    return;
}

//
// The entry is too old to live. Prescribe euthanasia.
//
BOOLEAN
DfsSiteCostSupport::IsExpired( VOID )
{
    DWORD Interval = DfsServerGlobalData.SiteSupportRefreshInterval;
    BOOLEAN Expired = FALSE;
    
    EnterCriticalSection( &_SiteCostLock );
    {
        //
        // No point in expiring a table that doesnt
        // exist.
        //
        if (_pCostTable != NULL)
        {
            Expired = DfsSiteCostCache::IsTime( _LastAccessTime, Interval );
        }
    }
    LeaveCriticalSection( &_SiteCostLock );
    return Expired;
}

    
/*-------------------------------------------------------
 MRU list handling functions of the SiteCostSupport objects.
 The MRU list is guarded by the GlobalDataLock.
 --------------------------------------------------------*/

ULONG
DfsSiteCostSupport::InsertInMruList(VOID)
{
    ULONG CachesToTrim = 0;

    DfsAcquireGlobalDataLock();
    {
        InsertHeadList( &DfsServerGlobalData.SiteCostTableMruList, &MruListEntry );
        InMruList = TRUE;
        DfsServerGlobalData.NumSiteCostTablesOnMruList++;
        DfsServerGlobalData.NumSiteCostTables++;

        //
        // This is iust a convenient time to check this. 
        //
        if (DfsServerGlobalData.NumSiteCostTables > DFS_MAX_SITE_COST_CACHES)
        {
            CachesToTrim = DfsServerGlobalData.NumSiteCostTables - DFS_MAX_SITE_COST_CACHES;
        }
    }
    DfsReleaseGlobalDataLock();

    return CachesToTrim;
}

            
VOID
DfsSiteCostSupport::MoveToFrontOfMruList( VOID )
{
    DfsAcquireGlobalDataLock();
    {
        if (InMruList == TRUE) 
        {
            RemoveEntryList( &MruListEntry );
            InsertHeadList( &DfsServerGlobalData.SiteCostTableMruList, &MruListEntry );
        }
    }
    DfsReleaseGlobalDataLock();

    return;
}

//
// Returns TRUE if the table was successfully removed
// from the MRU list.
//
BOOLEAN
DfsSiteCostSupport::RemoveFromMruList( VOID )
{
    BOOLEAN Delete = FALSE;
    
    DfsAcquireGlobalDataLock();
    {
        //
        // If the cache is not on the MRU, then there's
        // nothing to delete.
        //
        if (InMruList == TRUE)
        {
            RemoveEntryList( &MruListEntry );
            DfsServerGlobalData.NumSiteCostTablesOnMruList--;
            
            InMruList = FALSE;
            Delete = TRUE;
        }
    }
    DfsReleaseGlobalDataLock();

    return Delete;
}

DFSSTATUS
DfsSiteCostSupport::PopLastTableFromMruList(
    DfsSiteCostSupport **pTableToRemove)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsSiteCostSupport *pTable = NULL;
    PLIST_ENTRY pEntry;
    
    *pTableToRemove = NULL;

    DfsAcquireGlobalDataLock();
    do {
    
        // Nothing to do if the MRU list is empty.
        if (IsListEmpty( &DfsServerGlobalData.SiteCostTableMruList ))
        {
            Status = ERROR_NO_MORE_ITEMS;
            break;
        }
        
        // Pop the LRU entry off the list
        pEntry = RemoveTailList( &DfsServerGlobalData.SiteCostTableMruList );
        DfsServerGlobalData.NumSiteCostTablesOnMruList--;

        pTable = CONTAINING_RECORD( pEntry,
                                     DfsSiteCostSupport,
                                     MruListEntry );
        pTable->InMruList = FALSE;        
        *pTableToRemove = pTable;   
        
    } while (FALSE);
    
    DfsReleaseGlobalDataLock();
    
    return Status;
}


//
// This is called when we detect that the total number of site cost
// tables has exceeded its threshold. Currently we check to see if
// that's the case only when we add a new table (see Acquire).
//
ULONG
DfsSiteCostSupport::TrimSiteCostCaches( 
    ULONG MaxCachesToTrim)
{
    DfsSiteCostSupport *pCacheSup;
    ULONG NumTrims = 0;
    
    while (NumTrims < MaxCachesToTrim)
    {
        pCacheSup = NULL;
        (VOID) PopLastTableFromMruList( &pCacheSup );

        //
        // This just means we have no more items on the MRU list.
        // We must have raced with another because only the tables
        // that are initialized (non-empty) are on the MRU.
        //
        if (pCacheSup == NULL)
        {
            break;
        }
        
        //
        // This will start the deletion process.
        //
        pCacheSup->Release();
        NumTrims++;
        
        // unsafe, but this isn't an exact science
        if (DfsServerGlobalData.NumSiteCostTablesOnMruList <= DFS_MAX_SITE_COST_CACHES)
        {
            break;
        }
        
    }

    return NumTrims;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssitenamesupport.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "dsgetdc.h"
#include "lm.h"
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <winsock2.h>
#include <DfsSiteNameSupport.hxx>
#include <DfsSite.hxx>

#include "DfsSiteNameSupport.tmh"


DFSSTATUS
DfsSiteNameSupport::CreateSiteNameData(
    IN DfsSite *pNewSite,
    OUT PDFS_SITE_NAME_DATA *ppSiteNameData )
{
    PDFS_SITE_NAME_DATA SiteStructure = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    *ppSiteNameData = NULL;

    do {
        SiteStructure = (PDFS_SITE_NAME_DATA) DfsAllocateHashData(sizeof( DFS_SITE_NAME_DATA ));
        if (SiteStructure == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Attach a referenced DfsSite.
        //
        pNewSite->AcquireReference();
        SiteStructure->pDfsSite = pNewSite;         
        SiteStructure->Header.RefCount = 1;

        //
        // Index key is the same as the site name embedded inside DfsSite.
        //
        Status = DfsRtlInitUnicodeStringEx( &SiteStructure->SiteName, pNewSite->SiteNameString() );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        SiteStructure->Header.pvKey = (PVOID)&SiteStructure->SiteName;
        SiteStructure->Header.pData = (PVOID)SiteStructure;

        SiteStructure->FirstAccessTime = GetTickCount();
        *ppSiteNameData = SiteStructure;
    } while (FALSE);

    //
    // We haven't added this to the table yet.
    // So, just free the whole thing in case of error.
    // Release the DfsSite as well if it's initialized.
    //
    if (Status != ERROR_SUCCESS && SiteStructure != NULL)
    {
        DfsDeallocateSiteNameData( SiteStructure );
        *ppSiteNameData = NULL;
    }
    
    return Status;

}

PSHASH_HEADER
DfsSiteNameSupport::LookupIpInHash(PUNICODE_STRING pSiteName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PSHASH_HEADER pHeader = NULL;

    pHeader = SHashLookupKeyEx(_pSiteNameTable,
                               (void *)pSiteName);
    return pHeader;
}

VOID 
DfsSiteNameSupport::ReleaseSiteNameData(PDFS_SITE_NAME_DATA pData)
{
    DFS_TRACE_LOW( REFERRAL, "Removing Site %ws from SiteNameCache", pData->SiteName.Buffer);
    SHashReleaseReference(_pSiteNameTable,
                         (PSHASH_HEADER) pData );

}

DFSSTATUS
DfsSiteNameSupport::StoreSiteInCache(
    DfsSite *pSite)
{
    PDFS_SITE_NAME_DATA SiteStructure = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = CreateSiteNameData( pSite, &SiteStructure );

    if (Status == ERROR_SUCCESS)
    {
        NtStatus = SHashInsertKey(_pSiteNameTable,
                               SiteStructure,
                               (void *)pSite->SiteName(),
                               SHASH_REPLACE_IFFOUND);
        if (NtStatus != STATUS_SUCCESS)
        {
            DfsDeallocateSiteNameData( SiteStructure );
            Status = RtlNtStatusToDosError( NtStatus );
        }
        else 
        {
            // Just for statistical purposes.
            InterlockedIncrement( &DfsServerGlobalData.NumDfsSitesInCache );
            DFS_TRACE_LOW( REFERRAL, "Added Site %ws to SiteNameCache", pSite->SiteNameString());
        }
    }

    return Status;   
}

DFSSTATUS    
DfsSiteNameSupport::Initialize( ULONG NumBuckets )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SHASH_FUNCTABLE FunctionTable;

    ZeroMemory(&FunctionTable, sizeof(FunctionTable));

    FunctionTable.NumBuckets = NumBuckets;
    FunctionTable.CompareFunc = DfsCompareSiteNames;
    FunctionTable.AllocFunc = DfsAllocateHashData;
    FunctionTable.FreeFunc = DfsDeallocateHashData;
    FunctionTable.AllocHashEntryFunc = DfsAllocateHashData;
    FunctionTable.FreeHashEntryFunc = DfsSiteNameSupport::DfsDeallocateSiteNameData;
    // We use the default hash function in shash for site names.
    
    NtStatus = ShashInitHashTable(&_pSiteNameTable, &FunctionTable);
    Status = RtlNtStatusToDosError(NtStatus);

    return Status;
}

//
// Static function meant to differentiate new operator errors
// and Initialization errors.
//
DfsSiteNameSupport *
DfsSiteNameSupport::CreateSiteNameSupport(
    DFSSTATUS * pStatus,
    ULONG HashBuckets)
{
    DfsSiteNameSupport * pSiteTable = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    pSiteTable = new DfsSiteNameSupport();
    if(pSiteTable == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        Status = pSiteTable->Initialize( HashBuckets );
        if(Status != ERROR_SUCCESS)
        {
            delete pSiteTable;
            pSiteTable = NULL;
        }
    }
    *pStatus = Status;
    return pSiteTable;
}

// Just delete the cache data entry.
VOID
DfsSiteNameSupport::DfsDeallocateSiteNameData(PVOID pPointer )
{
    PDFS_SITE_NAME_DATA pSiteStructure = (PDFS_SITE_NAME_DATA)pPointer;

    if (pSiteStructure)
    {
        if (pSiteStructure->pDfsSite != NULL)
        {
            pSiteStructure->pDfsSite->ReleaseReference();
        }
        delete [] (PBYTE)pSiteStructure;
    }
}

DFSSTATUS
DfsSiteNameSupport::RemoveSiteFromCache( 
    PUNICODE_STRING pSiteName)
{
    NTSTATUS NtStatus;
    DFS_TRACE_LOW( REFERRAL, "Removing Site %ws from SiteNameCache", pSiteName->Buffer);
        
    NtStatus = SHashRemoveKey(_pSiteNameTable, 
                              pSiteName,
                              NULL ); 
    // Stats                          
    if (NtStatus == STATUS_SUCCESS) {
    
        InterlockedDecrement( &DfsServerGlobalData.NumDfsSitesInCache );
    }
    
    return RtlNtStatusToDosError( NtStatus );
}

VOID
DfsSiteNameSupport::InvalidateCache(VOID)
{
    SHASH_ITERATOR Iter;
    PDFS_SITE_NAME_DATA pExistingData = NULL;
    ULONG nEntries = 0;
    
    pExistingData = (PDFS_SITE_NAME_DATA) SHashStartEnumerate(&Iter, _pSiteNameTable);
    while (pExistingData != NULL)
    {
        //
        // Remove this item. There's nothing we can do if we hit errors
        // except to keep going.
        //
        
        (VOID)RemoveSiteFromCache( &pExistingData->SiteName );
        nEntries++;
        pExistingData = (PDFS_SITE_NAME_DATA) SHashNextEnumerate(&Iter, _pSiteNameTable);
    }
    SHashFinishEnumerate(&Iter, _pSiteNameTable);
    
    DFS_TRACE_LOW( REFERRAL, "SiteName Table %p: invalidated all %d entries\n", this, nEntries);
}



VOID
DfsSiteNameSupport::InvalidateAgedSites( VOID )
{
    // go over all the DfsSites in the site name support table and
    // throw out their caches if the site has aged (SiteCostSupport->Release()).

    SHASH_ITERATOR Iter;
    DfsSite *pSite = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumEntriesThrownOut = 0;
    
    pSite = StartSiteEnumerate( &Iter );
    while (pSite != NULL)
    {
        if (pSite->IsSiteCostCacheExpired())
        {
            (VOID) pSite->DeleteSiteCostCache();
            NumEntriesThrownOut++;
        }
        pSite = NextSiteEnumerate( &Iter );
    }
    
    FinishSiteEnumerate( &Iter );
 
    DFS_TRACE_LOW( REFERRAL, "SiteNameSupport: Invalidated %d SiteCostTables out of %d\n", 
                    NumEntriesThrownOut, DfsServerGlobalData.NumSiteCostTables);
    return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssynchronizeroots.cxx ===
#include <DfsGeneric.hxx>
#include "DfsInit.hxx"
#include "lm.h"
#include "lmdfs.h"

#include "DfsSynchronizeRoots.tmh"

DWORD
DfsRootSyncThread(LPVOID TData);

typedef struct _DFS_ROOT_SYNCHRONIZE_HEADER
{
    HANDLE hTimer;
    HANDLE SyncEvent;
    CRITICAL_SECTION DataLock;
    LIST_ENTRY Entries;
} DFS_ROOT_SYNCHRONIZE_HEADER, *PDFS_ROOT_SYNCHRONIZE_HEADER;


typedef struct _DFS_ROOT_SYNCRHONIZE_INFO
{
    UNICODE_STRING Target;
    LIST_ENTRY ListEntry;
} DFS_ROOT_SYNCHRONIZE_INFO, *PDFS_ROOT_SYNCHRONIZE_INFO;

DFS_ROOT_SYNCHRONIZE_HEADER DfsRootSyncHeader;

BOOL SyncCritSectionInit = FALSE;

DFSSTATUS
DfsRootSynchronizeInit()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    InitializeListHead(&DfsRootSyncHeader.Entries);

    SyncCritSectionInit = InitializeCriticalSectionAndSpinCount( &DfsRootSyncHeader.DataLock, DFS_CRIT_SPIN_COUNT );
    if(!SyncCritSectionInit)
    {
        Status = GetLastError();
    }

    if (Status == ERROR_SUCCESS)
    {
        DfsRootSyncHeader.SyncEvent = CreateEvent( NULL,
                                               TRUE, // manual reset
                                               FALSE, // initially reset.
                                               NULL );
        if (DfsRootSyncHeader.SyncEvent == NULL)
        {   
            Status = GetLastError();

        }
    }


    if (Status == ERROR_SUCCESS)
    {
        // Create a waitable timer.
        DfsRootSyncHeader.hTimer = CreateWaitableTimer(NULL, 
                                                       FALSE, // not manual reset.
                                                       NULL );
        if (DfsRootSyncHeader.hTimer == NULL)
        {
            Status = GetLastError();
        }
    }

    if (Status == ERROR_SUCCESS) {
        HANDLE THandle;
        DWORD Tid;
        
        THandle = CreateThread (
                     NULL,
                     0,
                     DfsRootSyncThread,
                     0,
                     0,
                     &Tid);
        
        if (THandle != NULL) {
            CloseHandle(THandle);
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Created Scavenge Thread (%d) Tid\n", Tid);
        }
        else {
            Status = GetLastError();
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Failed Scavenge Thread creation, Status %x\n", Status);
        }
    }

    return Status;
}



DFSSTATUS
AddToSyncList (
    PUNICODE_STRING pTarget)
{
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    ULONG TotalSize;
    DFSSTATUS Status = ERROR_SUCCESS;

    TotalSize = sizeof(DFS_ROOT_SYNCHRONIZE_INFO) + pTarget->Length + sizeof(WCHAR);
    pRootSync = (PDFS_ROOT_SYNCHRONIZE_INFO)new BYTE[TotalSize];
    if (pRootSync != NULL)
    {
        pRootSync->Target.Buffer = (LPWSTR)(pRootSync + 1);
        RtlCopyMemory( pRootSync->Target.Buffer, 
                       pTarget->Buffer,
                       pTarget->Length );
        pRootSync->Target.Length = pRootSync->Target.MaximumLength = pTarget->Length;
        pRootSync->Target.Buffer[pRootSync->Target.Length/sizeof(WCHAR)] = UNICODE_NULL;

        InsertTailList( &DfsRootSyncHeader.Entries, &pRootSync->ListEntry); 

        SetEvent(DfsRootSyncHeader.SyncEvent);
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    DFS_TRACE_HIGH(REFERRAL_SERVER, "Adding %wZ to sync list, Status %x\n",
                   pTarget, Status);
    return Status;
}

VOID
DeleteSyncRoot(
    PDFS_ROOT_SYNCHRONIZE_INFO pDeleteEntry )
{
    delete [] (PBYTE)pDeleteEntry;
}


DFSSTATUS
AddRootToSyncrhonize(
    PUNICODE_STRING pName )
{
    DFSSTATUS Status;
    PLIST_ENTRY pNext;
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    BOOLEAN Found = FALSE;

    Status = DfsAcquireWriteLock(&DfsRootSyncHeader.DataLock);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pNext = DfsRootSyncHeader.Entries.Flink;
    while (pNext != &DfsRootSyncHeader.Entries)
    {
        pRootSync = CONTAINING_RECORD( pNext, 
                                       DFS_ROOT_SYNCHRONIZE_INFO,
                                       ListEntry );
        if (RtlCompareUnicodeString(&pRootSync->Target,
                                    pName,
                                    TRUE) == 0)
        {
            Found = TRUE;
            break;
        }
        pNext = pNext->Flink;
    }

    if (!Found)
    {
        Status = AddToSyncList( pName );
    }
    
    DfsReleaseLock(&DfsRootSyncHeader.DataLock);

    DFS_TRACE_HIGH(REFERRAL_SERVER, "AddRootToSync %wZ, Found? %d,  Status %x\n",
                   pName, Found, Status);

    return Status;
}


DFSSTATUS
SynchronizeRoots()
{
    BOOLEAN RootSync = TRUE;
    PLIST_ENTRY pNext;
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    BOOLEAN WorkToDo = TRUE;
    DFSSTATUS Status;

    while (WorkToDo)
    {
        Status = DfsAcquireWriteLock(&DfsRootSyncHeader.DataLock);
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        WorkToDo = FALSE;
        pRootSync = NULL;

        if (!IsListEmpty( &DfsRootSyncHeader.Entries ))
        {
            pNext = RemoveHeadList( &DfsRootSyncHeader.Entries );
            pRootSync = CONTAINING_RECORD( pNext, 
                                           DFS_ROOT_SYNCHRONIZE_INFO,
                                           ListEntry );
            WorkToDo = TRUE;
        }
        
        DfsReleaseLock(&DfsRootSyncHeader.DataLock);

        if (pRootSync != NULL)
        {
            DFS_INFO_101 DfsState;
            DFSSTATUS ApiStatus;

            DfsState.State = DFS_VOLUME_STATE_RESYNCHRONIZE;
            //
            // Ignore the api status.
            //

            ApiStatus = NetDfsSetInfo( pRootSync->Target.Buffer,
                                       NULL,
                                       NULL, 
                                       101,
                                       (LPBYTE)&DfsState);

            DFS_TRACE_NORM(REFERRAL_SERVER, "Syncrhonized %wZ, Status %x\n",
                           &pRootSync->Target, ApiStatus);

            DeleteSyncRoot( pRootSync );
        }
    }

    return Status;
}


DWORD
DfsRootSyncThread(LPVOID TData)
{
    UNREFERENCED_PARAMETER(TData);

    HANDLE WaitHandles[2];
    LARGE_INTEGER liDueTime;
    DFSSTATUS Status;

    liDueTime.QuadPart=-1000000000;

    WaitHandles[0] = DfsRootSyncHeader.SyncEvent;
    WaitHandles[1] = DfsRootSyncHeader.hTimer;

    while (TRUE)
    {
        DFSSTATUS WaitStatus;

        if (!ResetEvent(DfsRootSyncHeader.SyncEvent))
        {
            // Log this error.
            Status = GetLastError();
        }
        if (!SetWaitableTimer( DfsRootSyncHeader.hTimer, 
                               &liDueTime, 
                               0, NULL, NULL, 0))
        {
            //
            // log this error.
            // 
            Status = GetLastError();
        }

        // dfsdev: use status here.

        WaitStatus = WaitForMultipleObjects( 2,
                                             WaitHandles,
                                             TRUE,
                                             INFINITE );

        DFS_TRACE_LOW(REFERRAL_SERVER, "Sync thread, waking up %x\n", WaitStatus);


        if (DfsIsShuttingDown())
        {
            break;
        }

        SynchronizeRoots();
    }

    return 0;
}

DFSSTATUS
ClearSynchronizeRootsQueue(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PLIST_ENTRY pNext =NULL;
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync = NULL;

    Status = DfsAcquireWriteLock(&DfsRootSyncHeader.DataLock);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    while (TRUE)
    {
        if (!IsListEmpty( &DfsRootSyncHeader.Entries ))
        {
            pNext = RemoveHeadList( &DfsRootSyncHeader.Entries );
            pRootSync = CONTAINING_RECORD( pNext,
                                           DFS_ROOT_SYNCHRONIZE_INFO,
                                           ListEntry );
            DeleteSyncRoot( pRootSync );
        }
        else
        {
            break;
        }
    }

    DfsReleaseLock(&DfsRootSyncHeader.DataLock);
    return Status;
}

void
DfsRootSynchronizeShutdown(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LARGE_INTEGER liDueTime;

    liDueTime.QuadPart=0000000000;

    if(DfsRootSyncHeader.hTimer != NULL)
    {
        if (!SetWaitableTimer( DfsRootSyncHeader.hTimer,
                               &liDueTime,
                               0, NULL, NULL, 0))
        {
            //
            // log this error.
            //
            Status = GetLastError();
        }
    }

    if(DfsRootSyncHeader.SyncEvent != NULL)
    {
        SetEvent(DfsRootSyncHeader.SyncEvent);
    }

    ClearSynchronizeRootsQueue();

    if(SyncCritSectionInit == TRUE)
    {
        DeleteCriticalSection( &DfsRootSyncHeader.DataLock );
        SyncCritSectionInit = FALSE;
    }


    if(DfsRootSyncHeader.hTimer != NULL)
    {
        CloseHandle(DfsRootSyncHeader.hTimer);
        DfsRootSyncHeader.hTimer = NULL;
    }

    if(DfsRootSyncHeader.SyncEvent != NULL)
    {
        CloseHandle(DfsRootSyncHeader.SyncEvent);
        DfsRootSyncHeader.SyncEvent = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfstrusteddomain.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsTrustedDomain.cxx
//
//  Contents:   implements the trusted domain 
//
//  Classes:    DfsTrustedDomain
//
//  History:    Apr. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <ntdsapi.h>


#include "DfsReferralData.hxx"
#include "DfsTrustedDomain.hxx"
#include "DfsReplica.hxx"
//
// logging specific includes
//
#include "DfsTrustedDomain.tmh" 

//+-------------------------------------------------------------------------
//
//  Function:   GetDcReferralData - get the referral data
//
//  Arguments:  ppReferralData - the referral data for this instance
//              pCacheHit - did we find it already loaded?
//
//  Returns:    Status
//               ERROR_SUCCESS if we could get the referral data
//               error status otherwise.
//
//
//  Description: This routine returns a reference DfsReferralDAta
//               If one does not already exist in this class instance,
//               we create a new one. If someone is in the process
//               of loading the referral, we wait on the event in 
//               the referral data which gets signalled when the thread
//               responsible for loading is done with the load.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsTrustedDomain::GetDcReferralData(
    OUT DfsReferralData **ppReferralData,
    OUT BOOLEAN   *pCacheHit )
{
    DfsReferralData *pRefData = NULL;
    DFSSTATUS Status = STATUS_SUCCESS;
    

    if (_DomainName.Length == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pCacheHit = FALSE;

    Status = AcquireLock();
    if ( Status != STATUS_SUCCESS )
    {
        return Status;
    }

    // First see if we may need to do a reload.
    if (_LoadState == DfsTrustedDomainDcLoadFailed && 
       IsTimeToRetry())
    {
        ASSERT(_pDcReferralData == NULL);
        _LoadState = DfsTrustedDomainDcNotLoaded;
    }  
    
    //
    // WE take difference action depending on the load state.
    //
    switch ( _LoadState )
    {
    case DfsTrustedDomainDcLoaded:

        DFS_TRACE_LOW(REFERRAL_SERVER, " Get Referral Data: Cache hit\n");
        //
        // we are dealing with a loaded instance. Just acquire a reference
        // and return the loaded referral data.
        //
        ASSERT (_pDcReferralData != NULL);

        pRefData = _pDcReferralData;
        pRefData->AcquireReference();
        
        ReleaseLock();
        
        *pCacheHit = TRUE;        
        *ppReferralData = pRefData;

        break;

    case DfsTrustedDomainDcNotLoaded:

        //
        // The dc info is not loaded. Make sure that the referral data is
        // indeed empty. Create a new instance of the referral data
        // and set the state to load in progress.

        ASSERT(_pDcReferralData == NULL);
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: not loaded\n");

        _pDcReferralData = new DfsReferralData( &Status );

        if ( _pDcReferralData != NULL )
        {
            if(Status == ERROR_SUCCESS)
            {

                _LoadState = DfsTrustedDomainDcLoadInProgress;

                //
                // Acquire a reference on the new referral data, since we 
                // have to return a referenced referral data to the caller.
                //
                pRefData = _pDcReferralData;
                pRefData->AcquireReference();
            }
            else
            {
                _pDcReferralData->ReleaseReference();
                _pDcReferralData = NULL;
            }
        } else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // We no longer need the lock. We have allocate the referral
        // data and marked the state accordingly. No other thread can
        // interfere with our load now.
        //
        ReleaseLock();

        //
        // Now we load the referral data, and save the status of the
        // load in both our load status as well as the load status
        // in the referral data.
        // If the load was successful, we add this to the loaded list
        // of referral data that can be scavenged later. We set the load
        // state to loaded, and signal the event so that all waiting
        // threads can now be woken up.
        //

        if ( Status == ERROR_SUCCESS )
        {
            _pDcReferralData->DoSiteCosting = (BOOLEAN)DfsCheckSiteCostingEnabled();

            Status = LoadDcReferralData( _pDcReferralData );

            _LoadStatus = Status;
            _RetryFailedLoadTimeout = 0;
            _pDcReferralData->LoadStatus = Status;


            if ( Status == ERROR_SUCCESS )
            {
                _LoadState = DfsTrustedDomainDcLoaded;
                *ppReferralData = pRefData;
                pRefData->Signal();
            } else
            {
                _LoadState = DfsTrustedDomainDcLoadFailed;
                _RetryFailedLoadTimeout = GetTickCount();
                pRefData->Signal();
                (VOID)RemoveDcReferralData( pRefData, NULL );
                
                DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, 
                    "DomainDC load failed for %wZ, LoadStatus %x, Status %x\n",
                     GetDomainName(),
                     _LoadStatus,
                     Status );
            }
        }

        break;


    case DfsTrustedDomainDcLoadInProgress:

        //
        // The load is in progress. We acquire a reference on the
        // referral data being loaded and wait for the event in the
        // referral data to be signalled. The return status of the wait
        // indicates if we can return the referral data or we fail
        // this request with an error.
        //
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: load in progress\n");
        ASSERT(_pDcReferralData != NULL);
        pRefData = _pDcReferralData;
        pRefData->AcquireReference();

        ReleaseLock();

        DFS_TRACE_NORM(REFERRAL_SERVER, "Thread: Waiting for referral load\n");

        Status = pRefData->Wait();

        if ( Status == ERROR_SUCCESS )
        {
            *ppReferralData = pRefData;
        } else
        {
            pRefData->ReleaseReference();
        }
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: load in progress done\n");
        break;

    case DfsTrustedDomainDcLoadFailed:
        //
        // The Load failed. REturn error. We need to setup a time
        // after which we need to reattempt the load.
        //
        Status = _LoadStatus;
        ReleaseLock();
        *ppReferralData = NULL;
        break;

    default:
        //
        // We should never get here. Its an invalid state.
        //
        ASSERT(TRUE);
        Status = ERROR_INVALID_STATE;
        ReleaseLock();

        break;
    }

    ASSERT((Status != ERROR_SUCCESS) || (*ppReferralData != NULL));

    return Status;
}




DFSSTATUS
DfsTrustedDomain::RemoveDcReferralData(
    DfsReferralData *pRemoveReferralData,
    PBOOLEAN pRemoved )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pRefData = NULL;

    //
    // Get the exclusive lock on this instance
    //
    if (pRemoved != NULL)
    {
        *pRemoved = FALSE;
    }

    AcquireLock();

    //
    // make sure _LoadState indicates that it is loaded.
    // Set the referralData to null, and state to NotLoaded.
    //
    if (_LoadState == DfsTrustedDomainDcLoaded || _LoadState == DfsTrustedDomainDcLoadFailed)
    {

        pRefData = _pDcReferralData;
        if ( (pRemoveReferralData == NULL) || 
             (pRemoveReferralData == pRefData) )
        {
            _pDcReferralData = NULL;
            _LoadState = (_LoadState == DfsTrustedDomainDcLoaded) ? 
                        DfsTrustedDomainDcNotLoaded : DfsTrustedDomainDcLoadFailed;
        }
        else {
            pRefData = NULL;
        }
    }

    ReleaseLock();

    //
    // Release reference on the referral data. This is the reference
    // we had taken when we had cached the referral data here.
    //
    if (pRefData != NULL)
    {
        pRefData->ReleaseReference();
        if (pRemoved != NULL)
        {
            *pRemoved = TRUE;
        }
    }

    return Status;
}

DFSSTATUS
DfsTrustedDomain::LoadDcReferralData(
    IN DfsReferralData *pReferralData )
{

    DFSSTATUS Status;
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDomainControllerInfo1 = NULL;
    HANDLE HandleToDs = NULL;
    ULONG NameCount = 0, Index;
    ULONG DsDcCount = 0;
    ULONG UseIndex = 0;
    BOOLEAN CacheHit = FALSE;
    LPWSTR DomainController = NULL;

    //
    // we have a problem that DsBind fails when going across forests
    // for netbios domains as local system.
    // So we bind to the DNS domain name only for cross forest domains,
    // this information is stored by UseBindDomain boolean.
    //
    Status = DsBind(DomainController, 
                    _UseBindDomain ? _BindDomainName.Buffer : _DomainName.Buffer, 
                    &HandleToDs);

    DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsTrustedDomain DsBind Status %d\n",
                         Status);
    if (Status == ERROR_SUCCESS)
    {

        Status = DsGetDomainControllerInfo( HandleToDs,
                                            _DomainName.Buffer,
                                            1,
                                            &NameCount,
                                            (PVOID *)(&pDsDomainControllerInfo1));

        
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsTrustedDomain DsGetDomainControllerInfo Status %d\n",
                             Status);
        DsUnBind( &HandleToDs);
    }

    if (Status == ERROR_SUCCESS)
    {
        for (Index = 0; Index < NameCount; Index++)
        {
            if (pDsDomainControllerInfo1[Index].fDsEnabled == TRUE) 
            {
                DsDcCount++;
            }
        }
        if (DsDcCount > 0)
        {
            pReferralData->pReplicas = new DfsReplica[ DsDcCount ];

            if (pReferralData->pReplicas == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else 
            {
                pReferralData->ReplicaCount = DsDcCount;
            }
        }

        for (Index = 0; ((Index < NameCount) && (Status == ERROR_SUCCESS)); Index++)
        {

            LPWSTR UseName;

            CacheHit = FALSE;

            if (pDsDomainControllerInfo1[Index].fDsEnabled != TRUE) 
            {
                continue;
            }

            if (_Netbios == TRUE)
            {
                UseName = pDsDomainControllerInfo1[Index].NetbiosName;
            }
            else
            {
                UseName = pDsDomainControllerInfo1[Index].DnsHostName;
                if (UseName == NULL) 
                {
                    UseName = pDsDomainControllerInfo1[Index].NetbiosName;

                    DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsDomainInformation DNS Name is NULL. Using Netbios =%ws Status %d\n",
                                         UseName, Status);
                }
            }

            if (UseName != NULL)
            {
                UNICODE_STRING TargetName;

                Status = DfsRtlInitUnicodeStringEx(&TargetName, UseName);
                if(Status == ERROR_SUCCESS)
                {
                    Status = (&pReferralData->pReplicas[ UseIndex ])->SetTargetServer( &TargetName, &CacheHit );

                    DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsDomainInformation SetTargetServer=%wZ Status %d\n",
                                         &TargetName, Status);
                }

                UseIndex++;
            }
        }
        
        DsFreeDomainControllerInfo( 1,
                                    NameCount,
                                    pDsDomainControllerInfo1);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsadsi.h ===
typedef struct _DFS_LINKROOT_ENUM_INFO {
    LPWSTR GuidString;
    UNICODE_STRING Name;
} DFS_LINKROOT_ENUM_INFO, *PDFS_LINKROOT_ENUM_INFO;

typedef struct _DFS_LINK_ENUMERATION {
    int NumberOfLinks;
    DFS_LINKROOT_ENUM_INFO Info[];
} DFS_LINK_ENUMERATION, *PDFS_LINK_ENUMERATION;

typedef struct _DFS_ROOT_ENUMERATION {
    int NumberOfRoots;
    DFS_LINKROOT_ENUM_INFO Info[];
} DFS_ROOT_ENUMERATION, *PDFS_ROOT_ENUMERATION;




typedef struct _DFS_ADSI_REPLICA_LIST {
    PUNICODE_STRING pServerName;
    PUNICODE_STRING pShareName;
    struct _DFS_ADSI_REPLICA_LIST *pNext;
} DFS_ADSI_REPLICA_LIST, *PDFS_ADSI_REPLICA_LIST;


typedef struct _DFS_ADSI_ROOT {
    LPWSTR GuidString;
    PDFS_ADSI_REPLICA_LIST Replicas;
} DFS_ADSI_ROOT, *PDFS_ADSI_ROOT;

typedef struct _DFS_ADSI_LINK {
    LPWSTR GuidString;
    PDFS_ADSI_REPLICA_LIST Replicas;
} DFS_ADSI_LINK, *PDFS_ADSI_LINK;


DFSSTATUS
DfsAdsiGetRoot(
    LPWSTR Namespace, 
    PDFS_ADSI_ROOT *ppAdRootObject
    );

DFSSTATUS
DfsAdsiGetLink(
    LPWSTR Namespace, 
    PDFS_ADSI_LINK *ppAdLinkObject
    );


DFSSTATUS
DfsAdsiFreeRoot(
    PDFS_ADSI_ROOT pAdRootObject
    );

DFSSTATUS
DfsAdsiEnumerateLinks(
    LPWSTR Namespace,
    PDFS_LINK_ENUMERATION *ppLinks
    );

DFSSTATUS
DfsAdsiFreeLinkEnumeration(
    PDFS_LINK_ENUMERATION pLinks
    );

DFSSTATUS
DfsAdsiEnumerateRoots(
    LPWSTR Namespace,
    PDFS_ROOT_ENUMERATION *ppRoots
    );

DFSSTATUS
DfsAdsiFreeRootEnumeration(
    PDFS_ROOT_ENUMERATION pRoots
    );


//
// Macros for accessing ADSI structures
//

#define GET_GUID(Object) Object.DfsAdsiHeader.Guid

#define GET_REPLICAS(Object) Object.Replicas

#define GET_ROOT_NAME(Object) Object.RootName

#define GET_LINK_NAME(LinkObject) LinkObject.LinkName

#define GET_POLICY(Object) Object.Policy

#define NUMBER_OF_LINKS(pLinkEnumeration) pLinkEnumeration->NumberOfLinks

#define NUMBER_OF_ROOTS(pRootEnumeration) pRootEnumeration->NumberOfRoots

#define LINK_GUID_STRING(pLink, index) pLink->Info[index].GuidString

#define LINK_NAME(pLink, index) pLink->Info[index].Name

#define ROOT_NAME(pLink, index) pLink->Info[index].Name.Buffer

#define GET_ROOT_REPLICAS(pRoot) pRoot->Replicas

#define GET_LINK_REPLICAS(pLink) pLink->Replicas
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsxforest.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       DfsXForest.cxx
//
//  Contents:   the Dfs xforest info class
//
//  Classes:    DfsXForest, DfsDomainNameTable
//
//  History:    Nov, 15 2002,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "dfsxforest.hxx"
#include "lm.h"

#include "dfsxforest.tmh"

//
// This file implements DfsXForest class. This class enumerates all
// local domains and cross forest domains, and builds a table of uniqye
// domain names.
//
// Ideally this should be an API such as DsEnumerateDomainTrusts, but
// lacking that we are putting this support here.
//
// Since this is happening so close to RTM, there is minimal code change
// in the original path, and all functionality has been implemented in
// this new class. This is called from DfsDomainInformation, where
// instead of enumerating domains by calling DsEnumerateDomainTrusts we
// enumerate domains by building the DfsXForest instance.
//
// DfsDomainInformation gets the DfsXForest instance, reads all the domains
// from the DfsXForest and destroys the DfsXForest.
//
//
// In future, we may either want to get an API for this. If that does
// not happen, it may be worthwhile changing the DfsDomainInformation 
// code to use the DfsXForest instance all the time instead of
// building an array of domain names enumerated using this class.
// That would be a more performance optimal solution.
//
//



DFSSTATUS 
DfsXForest::Initialize( DFSSTATUS *pXforestInitStatus )
{
    DFSSTATUS Status;

    Status = _DomainTable.Initialize();

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsAddLocalDomainsToDomainTable();
    }

    if (Status == ERROR_SUCCESS)
    {
        DFSSTATUS DfsCrossForestDomainStatus;

        DfsCrossForestDomainStatus = InitializeForestRootName();
        DFS_TRACE_ERROR_NORM(DfsCrossForestDomainStatus, REFERRAL_SERVER, 
            "DfsXForest::InitializeForestRootName, Status 0x%x\n",
                                 DfsCrossForestDomainStatus);
        //
        // If we cannot get cross forest domain information,
        // we continue with just the local information.
        //
        if (DfsCrossForestDomainStatus == ERROR_SUCCESS)
        {
            DfsCrossForestDomainStatus = DfsAddCrossForestDomainsToDomainTable();
            DFS_TRACE_ERROR_NORM(DfsCrossForestDomainStatus, REFERRAL_SERVER, 
                "DfsXForest::DfsAddCrossForestDomainsToDomainTable, Status 0x%x\n",
                                     DfsCrossForestDomainStatus);
        }
        
        *pXforestInitStatus = DfsCrossForestDomainStatus;
    }

    return Status;
}

//
// InitializeForestRootName: Get the Root Forest name and store it
// in our private member _ForestRootName.
//
//
DFSSTATUS
DfsXForest::InitializeForestRootName()
{

    LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
    NTSTATUS                  NtStatus = 0;
    DFSSTATUS                 Status = ERROR_SUCCESS;
    LSA_HANDLE                hPolicy;

    //attempt to open the policy.
    RtlInitUnicodeString(&_ForestRootName, NULL);
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));//object attributes are reserved, so initalize to zeroes.

    NtStatus = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hPolicy);  //recieves the policy handle

    DFS_TRACE_ERROR_HIGH( NtStatus, REFERRAL_SERVER, "LsaOpenPolicy, NtStatus 0x%x\n", NtStatus );
    
    if (NT_SUCCESS(NtStatus))
    {
        //ask for audit event policy information
        PPOLICY_DNS_DOMAIN_INFO   info;
        NtStatus = LsaQueryInformationPolicy(hPolicy, 
                                           PolicyDnsDomainInformation,
                                           (PVOID *)&info);
        DFS_TRACE_ERROR_HIGH( NtStatus, REFERRAL_SERVER, "LsaQueryInformationPolicy, NtStatus 0x%x\n", NtStatus );
        
        if (NT_SUCCESS(NtStatus))
        {
            //
            // convert LSA_UNICODE_STRING to normal UNICODE_STRING.
            // not that it matters now, but if things should change,
            // we will be in trouble.
            // Save the forest name and we are done.
            //
            UNICODE_STRING TempForestName;

            TempForestName.Buffer = info->DnsForestName.Buffer;
            TempForestName.Length = info->DnsForestName.Length;
            TempForestName.MaximumLength = info->DnsForestName.MaximumLength;

            Status = DfsCreateUnicodeString( &_ForestRootName,
                                             &TempForestName);


            //free policy info structure
            LsaFreeMemory((PVOID) info); 
        }

        //Freeing the policy object handle
        LsaClose(hPolicy); 
    }

    if (!NT_SUCCESS(NtStatus))
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


//
// DfsAddLocalDomainsToDomainTable: enumerate all the local domain
// trusts and add this to the domain table.
//

DFSSTATUS
DfsXForest::DfsAddLocalDomainsToDomainTable()
{
    DFSSTATUS Status;
    ULONG DsDomainCount = 0;
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
    ULONG Index;

    Status = DsEnumerateDomainTrusts( NULL,
                                      DS_DOMAIN_VALID_FLAGS,
                                      &pDsDomainTrusts,
                                      &DsDomainCount );

    DFS_TRACE_ERROR_NORM( Status, REFERRAL_SERVER, "DsEnumerateDomainTrusts, Status 0x%x\n", Status );
    
    if (Status == ERROR_SUCCESS)
    {
        for (Index = 0; (Status == ERROR_SUCCESS) && (Index < DsDomainCount); Index++)
        {
            if (pDsDomainTrusts[Index].TrustType == TRUST_TYPE_DOWNLEVEL)
                continue;

            if (Status == ERROR_SUCCESS)
            {
                if (IsEmptyString(pDsDomainTrusts[Index].NetbiosDomainName) == FALSE)
                {
                    Status = AddDomainToDomainTable(pDsDomainTrusts[Index].NetbiosDomainName, NULL, TRUE);
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                if (IsEmptyString(pDsDomainTrusts[Index].DnsDomainName) == FALSE)
                {
                    Status = AddDomainToDomainTable(pDsDomainTrusts[Index].DnsDomainName, NULL, FALSE);
                }
            }
        }
        NetApiBufferFree(pDsDomainTrusts);
    }

    return Status;
}


//
// DfsAddForestDomainsToDomainTable: enumerate all the domains in a forest
// and add that to our table.
//
//
DFSSTATUS
DfsXForest::DfsAddForestDomainsToDomainTable( LSA_HANDLE hPolicy,
                                              LPWSTR RootNameString)
{
    DFSSTATUS Status;
    NTSTATUS NtStatus;
    ULONG j;

    LSA_UNICODE_STRING LsaRootName;
    UNICODE_STRING RootName;

    PLSA_FOREST_TRUST_INFORMATION           pForestTrustInfo = NULL;



    RtlInitUnicodeString(&RootName, RootNameString);
    LsaRootName.Length = RootName.Length;
    LsaRootName.MaximumLength = RootName.MaximumLength;
    LsaRootName.Buffer = RootName.Buffer;

    NtStatus = LsaQueryForestTrustInformation( hPolicy,
                                               &LsaRootName,
                                               &pForestTrustInfo);

    Status = RtlNtStatusToDosError(NtStatus);
    
    if (Status == ERROR_SUCCESS)
    {

        for (j = 0; (Status == ERROR_SUCCESS) && (j < pForestTrustInfo->RecordCount); j++ )
        {
            PLSA_FOREST_TRUST_DOMAIN_INFO pDomainInfo;

            if (pForestTrustInfo->Entries[j]->ForestTrustType == ForestTrustDomainInfo)
            {
                pDomainInfo = &pForestTrustInfo->Entries[j]->ForestTrustData.DomainInfo;


                //
                // If only the DnsDomainName is empty, add both the dns and
                // netbios domain names.
                // The reason is: we cannot resolve netbios domain names
                // to DCs. We bind to the DNS domain name to resolve netbios
                // domains, so we add both netbios and dns names in 
                // the add domain to table for netbios names.
                //
                if (IsEmptyUnicodeString((PUNICODE_STRING)&pDomainInfo->DnsName) == FALSE)
                {

                    Status = AddDomainToDomainTable((PUNICODE_STRING)&pDomainInfo->DnsName, NULL, FALSE);

                    if ((Status == ERROR_SUCCESS) && (IsEmptyUnicodeString((PUNICODE_STRING)&pDomainInfo->NetbiosName) == FALSE))
                    {
                        Status = AddDomainToDomainTable((PUNICODE_STRING)&pDomainInfo->NetbiosName,
                                                        (PUNICODE_STRING)&pDomainInfo->DnsName,
                                                         TRUE);
                    }

                }
            }
        }
        LsaFreeMemory(pForestTrustInfo);
    }

    return Status;
}


//
// Magic trust flags: KahrenT indicates this is what we need.
//
#define DOMAIN_TRUST_FLAGS      DS_DOMAIN_DIRECT_INBOUND

//
// DfsAddCrossForestDomainsToDomainTable: Enumerate each forest that we have
// a trust to, and add that to our table.
//
//
DFSSTATUS
DfsXForest::DfsAddCrossForestDomainsToDomainTable()
{
    DFSSTATUS Status;
    NTSTATUS NtStatus;

    ULONG DsDomainCount = 0;
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;

    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
    LSA_HANDLE                hPolicy;

    ULONG Index;

    //object attributes are reserved, so initalize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    Status = DsGetDcName( NULL,    //computer name
                          _ForestRootName.Buffer,
                          NULL,    // domain guid
                          NULL,    // site name
                          DS_DIRECTORY_SERVICE_REQUIRED | DS_FORCE_REDISCOVERY,
                          &pDomainControllerInfo );

    if (Status == ERROR_SUCCESS)
    {
        Status = DsEnumerateDomainTrusts( pDomainControllerInfo->DomainControllerName,
                                          DOMAIN_TRUST_FLAGS,
                                          &pDsDomainTrusts,
                                          &DsDomainCount );


        if (Status == ERROR_SUCCESS)
        {
            LSA_UNICODE_STRING LsaDCName;

            RtlInitUnicodeString(&LsaDCName,
                                 pDomainControllerInfo->DomainControllerName);

            NtStatus = LsaOpenPolicy(&LsaDCName,
                                     &ObjectAttributes,
                                     POLICY_VIEW_LOCAL_INFORMATION,
                                     &hPolicy);

            Status = RtlNtStatusToDosError(NtStatus);
            
            if (Status == ERROR_SUCCESS)
            {
                for (Index = 0; Index < DsDomainCount; Index++)
                {
                    PDS_DOMAIN_TRUSTS pDomainTrust;
                    DFSSTATUS ForestTrustStatus;

                    pDomainTrust = &pDsDomainTrusts[Index];

                    //
                    // If the domain is not in our forest, and it is 
                    // not MIT kerberos and it has transitive trust,
                    // we have found a match. Add that forest and its
                    // domains to our list.
                    //
                    if (!(pDomainTrust->Flags & DS_DOMAIN_IN_FOREST) &&
                        (pDomainTrust->TrustType != TRUST_TYPE_MIT)   &&
                        (pDomainTrust->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))
                    {

                        //
                        // Ignore status return.
                        // 
                        // If any one of the domain enumeration fails,
                        // we dont want to fail the entire domain
                        // table creation.
                        //
                        ForestTrustStatus = DfsAddForestDomainsToDomainTable( hPolicy,
                                                                   pDomainTrust->DnsDomainName);
                    }

                }
                LsaClose(hPolicy);                
            }

           NetApiBufferFree(pDsDomainTrusts);
        }

        NetApiBufferFree(pDomainControllerInfo);
    }

    return Status;
}
                        
                        
                        
                        
//
//AddDomainToDomainTable: given a domain name add it to our table
//
DFSSTATUS
DfsXForest::AddDomainToDomainTable(LPWSTR DomainName,
                                   LPWSTR BindDomainName,
                                   BOOLEAN Netbios)
{
    UNICODE_STRING DomainNameUnicode;
    UNICODE_STRING BindDomainNameUnicode;
    DFSSTATUS Status;

    RtlInitUnicodeString(&DomainNameUnicode, DomainName);
    if (BindDomainName != NULL)
    {
        RtlInitUnicodeString(&BindDomainNameUnicode, BindDomainName);
    }

    Status = AddDomainToDomainTable( &DomainNameUnicode,
                                     BindDomainName ? &BindDomainNameUnicode : NULL,
                                     Netbios);

    return Status;
}


//
//AddDomainToDomainTable: given a domain name add it to our table
//

DFSSTATUS
DfsXForest::AddDomainToDomainTable(PUNICODE_STRING DomainName,
                                   PUNICODE_STRING BindDomainName,
                                   BOOLEAN Netbios)
{
    DFSSTATUS Status;

    Status = _DomainTable.AddDomain(DomainName, BindDomainName, Netbios);

    //
    // Buffer overflow indicates that we went over the hash table limit.
    // However, we keep adding so that we have a count of how many we
    // missed.
    //
    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}


//
// AddDomain: Insert the domain name in our hash table.
//
DFSSTATUS
DfsDomainNameTable::AddDomain(PUNICODE_STRING DomainName, 
                              PUNICODE_STRING BindDomainName,
                              BOOLEAN Netbios)
{
    PDFS_DOMAIN_NAME_DATA pDomainData = NULL;
    ULONG DomainDataLength;

    DFSSTATUS Status = ERROR_SUCCESS;
    USHORT DomainNameLength = DomainName->Length;
    USHORT MaxDomainNameLength = DomainNameLength + sizeof(WCHAR);

    USHORT BindDomainNameLength = 0;
    USHORT MaxBindDomainNameLength = 0;

    NTSTATUS NtStatus;
    ULONG  CurrentSize = 0;

    if (_DomainReferralSize > MAX_REFERRAL_SIZE)
    {
        _DomainsSkipped++;
        return ERROR_BUFFER_OVERFLOW;
    }


    CurrentSize = sizeof(DFS_REFERRAL_V3) + sizeof(UNICODE_PATH_SEP)
                  + DomainName->Length + sizeof(UNICODE_NULL);

    if (BindDomainName != NULL)
    {
        BindDomainNameLength = BindDomainName->Length;
        MaxBindDomainNameLength = BindDomainNameLength + sizeof(WCHAR);
    }

    DomainDataLength = sizeof(DFS_DOMAIN_NAME_DATA) + MaxDomainNameLength + MaxBindDomainNameLength;
    pDomainData = (PDFS_DOMAIN_NAME_DATA) DfsAllocateForDomainTable(DomainDataLength);

    if (pDomainData != NULL)
    {
        RtlZeroMemory(pDomainData, DomainDataLength);

        pDomainData->Header.RefCount = 1;
        pDomainData->Header.pvKey = (PVOID)&pDomainData->DomainInfo.DomainName;
        pDomainData->Header.pData = (PVOID)pDomainData;

        pDomainData->DomainInfo.Netbios = Netbios;
        RtlInitUnicodeString(&pDomainData->DomainInfo.DomainName, NULL);

        pDomainData->DomainInfo.DomainName.Buffer = (LPWSTR)(pDomainData + 1);
        pDomainData->DomainInfo.DomainName.MaximumLength = MaxDomainNameLength;
        pDomainData->DomainInfo.DomainName.Length = DomainNameLength;
        
        RtlCopyMemory(pDomainData->DomainInfo.DomainName.Buffer,
                      DomainName->Buffer,
                      DomainNameLength);
        pDomainData->DomainInfo.DomainName.Buffer[DomainNameLength/sizeof(WCHAR)] = 0;

        if (BindDomainName)
        {
            pDomainData->DomainInfo.BindDomainName.Buffer = (LPWSTR)(((ULONG_PTR)(pDomainData + 1)) + MaxDomainNameLength);
            pDomainData->DomainInfo.BindDomainName.MaximumLength = MaxBindDomainNameLength;
            pDomainData->DomainInfo.BindDomainName.Length = BindDomainNameLength;

            RtlCopyMemory(pDomainData->DomainInfo.BindDomainName.Buffer,
                          BindDomainName->Buffer,
                          BindDomainNameLength);
            pDomainData->DomainInfo.BindDomainName.Buffer[BindDomainNameLength/sizeof(WCHAR)] = 0;

            pDomainData->DomainInfo.UseBindDomain = TRUE;

        }

    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        NtStatus = SHashInsertKey(_pDomainNameTable,
                                  pDomainData,
                                  &pDomainData->DomainInfo.DomainName,
                                  SHASH_FAIL_IFFOUND);

        if (NtStatus != STATUS_SUCCESS)
        {
            DfsDeallocateForDomainTable( pDomainData );
            //
            // if we have collision, we already know this name and
            // we can ignore this error.
            //
            if (NtStatus != STATUS_OBJECT_NAME_COLLISION)
            {
                Status = RtlNtStatusToDosError( NtStatus );
            }
        }
        else
        {
            //
            // we successfully added to the table, bump up our
            // DomainReferralSize.
            //
            InterlockedDecrement(&pDomainData->Header.RefCount);
            _DomainReferralSize += CurrentSize;
        }
    }

    return Status;
}


//
// InvalidateDomainTable: Run through the hash and throw out all our
// entries.
//
//
VOID
DfsDomainNameTable::InvalidateDomainTable(VOID)
{
    SHASH_ITERATOR Iter;
    PDFS_DOMAIN_NAME_DATA pExistingData = NULL;
    NTSTATUS NtStatus;

    pExistingData = (PDFS_DOMAIN_NAME_DATA) SHashStartEnumerate(&Iter, _pDomainNameTable);
    while (pExistingData != NULL)
    {
        //
        // Remove this item. There's nothing we can do if we hit errors
        // except to keep going.
        //

        NtStatus = SHashRemoveKey(_pDomainNameTable, 
                                  &pExistingData->DomainInfo.DomainName,
                                  NULL ); 

        //
        // ignore status here, since we want to keep going.
        //
        pExistingData = (PDFS_DOMAIN_NAME_DATA) SHashNextEnumerate(&Iter, _pDomainNameTable);
    }
    SHashFinishEnumerate(&Iter, _pDomainNameTable);
}


//
// GetCount: Run through our hash and get a count of the number of
// items. I wish we could ask the hash table for the count.
//

ULONG
DfsDomainNameTable::GetCount(VOID)
{
    SHASH_ITERATOR Iter;
    PDFS_DOMAIN_NAME_DATA pExistingData = NULL;
    ULONG nEntries = 0;

    pExistingData = (PDFS_DOMAIN_NAME_DATA) SHashStartEnumerate(&Iter, _pDomainNameTable);
    while (pExistingData != NULL)
    {
        nEntries++;
        pExistingData = (PDFS_DOMAIN_NAME_DATA) SHashNextEnumerate(&Iter, _pDomainNameTable);
    }
    SHashFinishEnumerate(&Iter, _pDomainNameTable);

    return nEntries;
}

//
// FinishDomainNameEnumerate
//
VOID
DfsDomainNameTable::FinishDomainNameEnumerate(  SHASH_ITERATOR *pIter )
{
    SHashFinishEnumerate( pIter, _pDomainNameTable);
}


// Allocate and deallocate the cache data entry
PVOID
DfsAllocateForDomainTable(ULONG Size )
{
    PVOID RetValue = NULL;

    if (Size)
    {
        RetValue = (PVOID) new BYTE[Size];
        if (RetValue != NULL)
        {
            RtlZeroMemory( RetValue, Size );
        }
    }

    return RetValue;
}

VOID
DfsDeallocateForDomainTable(PVOID pPointer )
{

    if (pPointer)
    {
        delete [] (PBYTE)pPointer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\domaincontrollersupport.cxx ===
#include "DfsGeneric.hxx"
#include "dsgetdc.h"
#include "dsrole.h"
#include "DfsDomainInformation.hxx"
#include "DfsTrustedDomain.hxx"
#include "DfsReferralData.hxx"
#include "DomainControllerSupport.hxx"
#include "DfsReplica.hxx"
#include "dfsadsiapi.hxx"
#include "lmdfs.h"
#include "dfserror.hxx"
#include "dfsfilterapi.hxx"


#include "DomainControllerSupport.tmh"

#define RemoteServerNameString L"remoteServerName"


extern 
DFS_SERVER_GLOBAL_DATA DfsServerGlobalData;

#define HRESULT_TO_DFSSTATUS(_x) (_x)
DFSSTATUS
DfsDcInit( 
    PBOOLEAN pIsDc )
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hThread;
    DWORD idThread;

    Status = DsRoleGetPrimaryDomainInformation( NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&pPrimaryDomainInfo);

    if (Status == ERROR_SUCCESS)
    {
#if defined (DC_TESTING)
        pPrimaryDomainInfo->MachineRole = DsRole_RoleBackupDomainController;
#endif

        if(pPrimaryDomainInfo->MachineRole == DsRole_RoleStandaloneServer)
        {
            DfsServerGlobalData.IsWorkGroup = TRUE;
        }
        else
        {
            DfsServerGlobalData.IsWorkGroup = FALSE;
        }


        if ( (pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController) || 
             (pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController) )
        {
            *pIsDc = TRUE;

            hThread = CreateThread( NULL,     //Security attributes
                                    0,        //Use default stack size
                                    DcUpdateLoop, // Thread entry procedure
                                    0,        // Thread context parameter
                                    0,        // Start immediately
                                    &idThread);   // Thread ID
            if (hThread == NULL) 
            {
                //
                // log this
                //
                Status = GetLastError();
            }
            else
            {
                CloseHandle(hThread);
            }
        }

        DfsSetDomainNameFlat( pPrimaryDomainInfo->DomainNameFlat);
        DfsSetDomainNameDns( pPrimaryDomainInfo->DomainNameDns);

        DsRoleFreeMemory(pPrimaryDomainInfo);

    }

    return Status;
}


#define DC_PERIODIC_UPDATE_INTERVAL (1000 * 60 * 10) // 10 minutes

DWORD
DcUpdateLoop(
    LPVOID lpThreadParams)
{

    UNREFERENCED_PARAMETER(lpThreadParams);

    DFSSTATUS Status;
    DfsDomainInformation *pDomainInfo;
    LONG InitialRetry = 10;
    ULONG SleepTime = 1000 * 15; // 15 seconds.
    static ULONG DomainRefreshFixedInterval;
    static ULONG DomainRefreshIntervalOnError;
    
    ULONG DomainRefreshTime;

    // Default is 72 update intervals -> 12 hrs
    DomainRefreshFixedInterval = (DfsServerGlobalData.DomainNameRefreshInterval / (DC_PERIODIC_UPDATE_INTERVAL / 1000));

    // On enumeration errors, one hour (1/12th the time of domain-name-refresh-interval) is a better time to wait.
    DomainRefreshIntervalOnError = DomainRefreshFixedInterval/12;
    if (DomainRefreshFixedInterval == 0)
    {
        DomainRefreshFixedInterval = 1;
    }
    
    if (DomainRefreshIntervalOnError == 0)
    {
        DomainRefreshIntervalOnError = 1;
    }
    
    pDomainInfo = NULL;
    Status = GetDomainInformation(&pDomainInfo);
    
    //
    // It's possible to get only a part of the domain information because of an error
    // (typically because the DC discovery failed). In that case we have a Status != ERROR_SUCCESS here,
    // but still have a valid DomainInfo.
    //
    if (pDomainInfo != NULL) 
    {
        DfsSetGlobalDomainInfo(pDomainInfo);
        pDomainInfo->ReleaseReference();
        pDomainInfo = NULL;
    }
    
    while ( (Status != ERROR_SUCCESS) &&
            (InitialRetry-- > 0) ) 
    {
        WaitForSingleObject(DfsServerGlobalData.ShutdownHandle, SleepTime);

        if (DfsIsShuttingDown())
        {
            goto Exit;
        }

        Status = GetDomainInformation(&pDomainInfo);
        if (pDomainInfo != NULL) 
        {
            DfsSetGlobalDomainInfo(pDomainInfo);
            pDomainInfo->ReleaseReference();
            pDomainInfo = NULL;
        }
        DFS_TRACE_LOW(REFERRAL_SERVER, "startup Updating Domain info...%p, %x\n", pDomainInfo,Status);
    }

    SleepTime = DC_PERIODIC_UPDATE_INTERVAL;
    DomainRefreshTime = DomainRefreshFixedInterval;

    do {
        WaitForSingleObject(DfsServerGlobalData.ShutdownHandle, SleepTime);

        if (DfsIsShuttingDown())
        {
            break;
        }

        //
        // every so often, throw away our entire domain information
        // and rebuild.
        // Every 10 minutes, purge our DC information.
        //
        //
        if (--DomainRefreshTime == 0)
        {
            Status = GetDomainInformation(&pDomainInfo);
            DFS_TRACE_LOW(REFERRAL_SERVER, "DcUpdateLoop: Updating Domain info...%p, %x\n", pDomainInfo,Status);

            // It'll be 12 * 6 more update-intervals for the next enumeration if everythings working well.
            // Otherwise it's 6.
            if (Status == ERROR_SUCCESS)
            {            
                DomainRefreshTime = DomainRefreshFixedInterval; // 72 update intervals = 12 hrs by default.
            }
            else
            {
                DomainRefreshTime = DomainRefreshIntervalOnError; // 6 update intervals = 1 hr
                DFS_TRACE_HIGH(REFERRAL_SERVER, "DcUpdateLoop: Status 0x%x enumerating domains (info=%p), Resetting refresh time to %d mins\n", 
                               Status, pDomainInfo, DomainRefreshTime * SleepTime / 60000);
            }
            
            if (pDomainInfo != NULL) 
            {
                DfsSetGlobalDomainInfo(pDomainInfo);
                pDomainInfo->ReleaseReference();
                pDomainInfo = NULL;
            }
        }
        else
        {
            Status = DfsAcquireDomainInfo(&pDomainInfo);
            DFS_TRACE_LOW(REFERRAL_SERVER, "DcUpdateLoop: Purging DC info...%p, %x\n", pDomainInfo,Status);
            
            if (Status == ERROR_SUCCESS)
            {
                pDomainInfo->PurgeDCReferrals();
                pDomainInfo->ReleaseReference();
                pDomainInfo = NULL;
            }

        }

    } while ( TRUE );


Exit:

    return 0;
}


DFSSTATUS
GetDomainInformation(
    DfsDomainInformation **ppDomainInfo )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS XforestStatus = ERROR_SUCCESS;
    
    *ppDomainInfo = NULL;

    DfsDomainInformation *pNewDomainInfo = new DfsDomainInformation( &Status, &XforestStatus );
    if (pNewDomainInfo == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if (Status != ERROR_SUCCESS)
    {
        pNewDomainInfo->ReleaseReference();
    }
        
    if (Status == ERROR_SUCCESS)
    {
        *ppDomainInfo = pNewDomainInfo;

        //
        // Although we have a DomainInfo, our x-forest enumerations
        // may have failed. We go ahead, but we still let the caller know 
        // that it needs to retry by sending the error status.
        //
        Status = XforestStatus;
    }

    return Status;
}

#if 0
//+-------------------------------------------------------------------------
//
//  Function:   DfsGenerateReferralDataFromRemoteServerNames
//    IADs *pObject    - the object
//    DfsfolderReferralData *pReferralData - the referral data
//
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the remote server name 
//               attribute and creates a referral data structure
//               so that we can pass a referral based on these names.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGenerateReferralDataFromRemoteServerNames(
    LPWSTR RootName,
    DfsReferralData **ppReferralData )
{
    HRESULT HResult = S_OK;
    BOOLEAN CacheHit = FALSE;
    DfsReplica *pReplicas = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    IADs *pObject = NULL;
    VARIANT Variant;

    LPWSTR pszAttrs[] = { RemoteServerNameString };
    DWORD  Number = sizeof(pszAttrs) / sizeof(LPWSTR);

    DFS_TRACE_HIGH( REFERRAL_SERVER, "Entering DfsGenerateReferralDataFromRemoteServerNames for RootName %ws\n",
                RootName);

    Status = DfsGetDfsRootADObject(NULL,
                                   RootName,
                                   &pObject );

    if (Status == ERROR_SUCCESS)
    {
        pReferralData = new DfsReferralData (&Status );
        if (pReferralData == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (Status != ERROR_SUCCESS)
        {
            pReferralData->ReleaseReference();
        }

        VariantInit( &Variant );

        //
        // Try to cache the RemoteServerNameString attribute locally,
        // if this fails, we dont care since we will be using the
        // GetEx call anyway.
        //
        if (Status == ERROR_SUCCESS)
        {
            HResult = ADsBuildVarArrayStr( pszAttrs, Number, &Variant);
            if ( SUCCEEDED(HResult)) 
            {
                HResult = pObject->GetInfoEx( Variant, 0);
            }

            VariantClear( &Variant);
        }

        if (Status == ERROR_SUCCESS)
        {
            LONG StartNdx, LastNdx;
            SAFEARRAY *PropertyArray;



            HResult = pObject->GetEx( RemoteServerNameString, &Variant );
            if ( SUCCEEDED(HResult) )
            {
                PropertyArray = V_ARRAY( &Variant );
                HResult = SafeArrayGetLBound( PropertyArray, 1, &StartNdx );
                if ( SUCCEEDED(HResult) )
                {
                    HResult = SafeArrayGetUBound( PropertyArray, 1, &LastNdx );
                }
            }
            else
            {
                DFS_TRACE_HIGH(REFERRAL_SERVER, "DfsGenerateReferralDataFromRemoteServerNames-GetEx failed for RootName %ws with Status %x\n",
                                      RootName, HResult);
            }

            if ( SUCCEEDED(HResult) &&
                 (LastNdx > StartNdx) )
            {
                VARIANT VariantItem;
            
                pReplicas = new DfsReplica [ LastNdx - StartNdx ];

                if (pReplicas != NULL)
                {

                    for ( LONG Index = StartNdx; Index < LastNdx; Index++ )
                    {

                        VariantInit( &VariantItem );

                        CacheHit = FALSE;

                        HResult = SafeArrayGetElement( PropertyArray, 
                                                       &Index,
                                                       &VariantItem );

                        if ( SUCCEEDED(HResult) )
                        {
                            UNICODE_STRING ServerName, Remaining, Replica;
                            LPWSTR ReplicaString = V_BSTR( &VariantItem );

                            Status = DfsRtlInitUnicodeStringEx( &Replica, ReplicaString );
                            if(Status == ERROR_SUCCESS)
                            {
                                DfsGetFirstComponent( &Replica,
                                                      &ServerName,
                                                      &Remaining );

                                Status = (&pReplicas[ Index - StartNdx])->SetTargetServer( &ServerName, &CacheHit );
                                if (Status == ERROR_SUCCESS)
                                {
                                    Status = (&pReplicas[ Index - StartNdx])->SetTargetFolder( &Remaining );
                                }
                            }
                        }
                        else {
                            Status = DfsGetErrorFromHr( HResult );

                            DFS_TRACE_HIGH(REFERRAL_SERVER, "Leaving DfsGenerateReferralDataFromRemoteServerNames- SafeArrayGetElement for RootName %ws with Status %x\n",
                                                  RootName, HResult);
                        }

                        VariantClear( &VariantItem );

                        if (Status != ERROR_SUCCESS)
                        {
                            delete [] pReplicas;
                            pReplicas = NULL;
                            break;
                        }
                    }
                }
                else
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else
            {
                DFS_TRACE_HIGH(REFERRAL_SERVER, "DfsGenerateReferralDataFromRemoteServerNames- DfsGetDfsRootADObjectfailed for RootName %ws with Status %x\n",
                                      RootName, HResult);
                Status = DfsGetErrorFromHr( HResult );
            }

            VariantClear( &Variant );

            if (Status == ERROR_SUCCESS)
            {
                pReferralData->Timeout = DFS_DEFAULT_REFERRAL_TIMEOUT;
                pReferralData->ReplicaCount = LastNdx - StartNdx;
                pReferralData->pReplicas = pReplicas;
                *ppReferralData = pReferralData;
            }

            if (Status != ERROR_SUCCESS)
            {
                pReferralData->ReleaseReference();
            }
        }
        pObject->Release();
    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Leaving DfsGenerateReferralDataFromRemoteServerNames for RootName %ws and Status %x\n",
                          RootName, HResult);

    return Status;
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsUpdateRemoteServerName
//
//  Arguments:    
//    IADs *pObject        - the ds object of interest.
//    LPWSTR ServerName    - the server name to add or delete
//    LPWSTR RemainingName - the rest of the name
//    BOOLEAN Add          - true for add, false for delete.
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine updates the RemoteServerName attribute
//               in the DS object, either adding a \\servername\remaining
//               to the existing DS attribute or removing it, depending
//               on add/delete.
//               The caller must make sure this parameter does not 
//               already exist in the add case, or that the parameter
//               to be deleted does exist in the delete case.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsUpdateRemoteServerName(
    IADs *pObject,
    LPWSTR ServerName,
    LPWSTR RemainingName,
    BOOLEAN Add )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    VARIANT Variant;
    UNICODE_STRING UpdateName;
    LPWSTR pServers[1];
    BSTR RemoteServerNameBstr;

    RemoteServerNameBstr = SysAllocString(RemoteServerNameString);
    if (RemoteServerNameBstr == NULL) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DFS_TRACE_HIGH( REFERRAL_SERVER, "Entering DfsUpdateRemoteServerName for ServerName %ws, remaining name %ws, add %d\n",
                ServerName, RemainingName, Add);
    //
    // create a unc path using the server and remaining name
    // to get a path of type \\servername\remainingname
    //
    Status = DfsCreateUnicodePathString( &UpdateName,
                                         2, // unc path: 2 leading seperators,
                                         ServerName,
                                         RemainingName);

    pServers[0] = UpdateName.Buffer;

    if (Status == ERROR_SUCCESS)
    {
        //
        // initialize the variant.
        //
        VariantInit( &Variant );

        //
        // Create the variant array with a single entry in it.
        //
        HResult = ADsBuildVarArrayStr( pServers,
                                       1,
                                       &Variant );

        if ( SUCCEEDED(HResult) )
        {
            //
            // either append or delete this string from the remote server 
            // name attribute
            //
            HResult = pObject->PutEx( (Add ? ADS_PROPERTY_APPEND : ADS_PROPERTY_DELETE),
                                      RemoteServerNameBstr,
                                      Variant );
            if ( SUCCEEDED(HResult) )
            {
                //
                // now update the object in the DS with this info.
                //
                HResult = pObject->SetInfo();
            }

            //
            // clear the variant
            //
            VariantClear( &Variant );
        }


        if ( SUCCEEDED(HResult) == FALSE)
        {
            Status = DfsGetErrorFromHr( HResult );
        }

        //
        // free the unicode string we created earlier on.
        //
        DfsFreeUnicodeString( &UpdateName );
    }

    SysFreeString(RemoteServerNameBstr);

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Leaving DfsUpdateRemoteServerName ServerName %ws, RemainingName %ws, Add %d, and Status %x\n",
                          ServerName, RemainingName, Add, HResult);
    return Status;
}

                                

DFSSTATUS
DfsDcEnumerateRoots(
    LPWSTR DfsName,
    LPBYTE pBuffer,
    ULONG BufferSize,
    PULONG pEntriesRead,
    DWORD MaxEntriesToRead,
    LPDWORD pResumeHandle,
    PULONG pSizeRequired )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS PDCStatus;
    ULONG_PTR CurrentBuffer = (ULONG_PTR)pBuffer;
    ULONG CurrentSize = BufferSize;
    DfsString *pPDCName = NULL;
    LPWSTR UseDC = NULL;

    UNREFERENCED_PARAMETER(DfsName);

    PDCStatus = DfsGetBlobPDCName( &pPDCName, 0 );
    if (PDCStatus == ERROR_SUCCESS) 
    {
        UseDC = pPDCName->GetString();
        //
        // At this point we dont care: if we got a dc name use it,
        // otherwise, just keep going, we will go to the local dc.
        //

        Status = DfsEnumerateDfsADRoots( UseDC,
                                         &CurrentBuffer,
                                         &CurrentSize,
                                         pEntriesRead,
                                         MaxEntriesToRead,
                                         pResumeHandle,
                                         pSizeRequired );

        DfsReleaseBlobPDCName(pPDCName);
    }

    return Status;
}

DFSSTATUS
DfsUpdateRootRemoteServerName(
    LPWSTR Root,
    LPWSTR DCName,
    LPWSTR ServerName,
    LPWSTR RemainingName,
    BOOLEAN Add )

{
    IADs *pRootObject = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsGetDfsRootADObject( DCName,
                                    Root,
                                    &pRootObject );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsUpdateRemoteServerName( pRootObject,
                                            ServerName,
                                            RemainingName,
                                            Add );
        pRootObject->Release();
    }
    return Status;
}

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING DfsSpecialDCShares[] = {
    UNICODE_STRING_STRUCT(L"SYSVOL"),
    UNICODE_STRING_STRUCT(L"NETLOGON"),
};

//+-------------------------------------------------------------------------
//
//  Function:   DfsIsRemoteServerNameEqual
//
//
//  Returns:    Status: Success or Error status code. pIsEqual = TRUE if
//             the remoteServerName contains the passed in pServerName in its entirety.
//
//  Description: This routine reads the remote server name 
//             attribute and does a string match on its components.
//--------------------------------------------------------------------------

DFSSTATUS
DfsIsRemoteServerNameEqual(
    LPWSTR RootName,
    PUNICODE_STRING pServerName,
    PBOOLEAN pIsEqual)
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    IADs *pObject = NULL;
    VARIANT Variant;

    LPWSTR pszAttrs[] = { RemoteServerNameString };
    DWORD  Number = sizeof(pszAttrs) / sizeof(LPWSTR);

    DFS_TRACE_NORM( REFERRAL_SERVER, "Entering DfsIsRemoteServerNameEqual for RootName %ws, ServerName %wZ\n",
                RootName, pServerName);

    *pIsEqual = FALSE;
    Status = DfsGetDfsRootADObject(NULL,
                                   RootName,
                                   &pObject );

    if (Status == ERROR_SUCCESS)
    {
        VariantInit( &Variant );

        HResult = ADsBuildVarArrayStr( pszAttrs, Number, &Variant);
        if ( SUCCEEDED(HResult)) 
        {
            LONG StartNdx, LastNdx;
            SAFEARRAY *PropertyArray;
            BSTR RemoteServerNameBstr = SysAllocString(RemoteServerNameString);
            if (RemoteServerNameBstr == NULL) 
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (Status == ERROR_SUCCESS)
            {
                HResult = pObject->GetEx( RemoteServerNameBstr, &Variant );
                if ( SUCCEEDED(HResult) )
                {
                    PropertyArray = V_ARRAY( &Variant );
                    HResult = SafeArrayGetLBound( PropertyArray, 1, &StartNdx );
                    if ( SUCCEEDED(HResult) )
                    {
                        HResult = SafeArrayGetUBound( PropertyArray, 1, &LastNdx );
                    }
                }
                else
                {
                    DFS_TRACE_HIGH(REFERRAL_SERVER, 
                        "DfsIsRemoteServerNameEqual -GetEx failed for RootName %ws with Status %x\n",
                                          RootName, HResult);
                }

                if ( SUCCEEDED(HResult) &&
                     (LastNdx > StartNdx) )
                {
                    VARIANT VariantItem;

                    for ( LONG Index = StartNdx; Index < LastNdx; Index++ )
                    {
                        VariantInit( &VariantItem );
                        HResult = SafeArrayGetElement( PropertyArray, 
                                                       &Index,
                                                       &VariantItem );

                        if ( SUCCEEDED(HResult) )
                        {
                            UNICODE_STRING FirstComp, Replica;
                            LPWSTR ReplicaString = V_BSTR( &VariantItem );

                            Status = DfsRtlInitUnicodeStringEx( &Replica, ReplicaString );
                            if(Status == ERROR_SUCCESS)
                            {
                                Status = DfsGetFirstComponent( &Replica, &FirstComp, NULL );
                                if (Status == ERROR_SUCCESS)
                                {
                                    //
                                    // See if this component matches our servername in its entirety.
                                    //
                                    if (RtlEqualDomainName( pServerName, &FirstComp ))
                                    {
                                        *pIsEqual = TRUE;
                                    }
                                }
                            }
                        }
                        else {
                            Status = DfsGetErrorFromHr( HResult );

                            DFS_TRACE_HIGH(REFERRAL_SERVER, "Leaving DfsGenerateReferralDataFromRemoteServerNames- SafeArrayGetElement for RootName %ws with Status %x\n",
                                                  RootName, HResult);
                        }

                        VariantClear( &VariantItem );

                        if (Status != ERROR_SUCCESS || *pIsEqual == TRUE)
                        {
                            break;
                        }
                    }
                }
                if (RemoteServerNameBstr != NULL)
                {
                    SysFreeString( RemoteServerNameBstr );
                }
            }

            VariantClear( &Variant );

        }
        pObject->Release();
    }
    else
    {
        DFS_TRACE_HIGH(REFERRAL_SERVER, "DfsIsRemoteServerNameEqual- DfsGetDfsRootADObjectfailed for RootName %ws with Status %x\n",
                              RootName, HResult);
        Status = DfsGetErrorFromHr( HResult );
    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, 
        "Leaving DfsIsRemoteServerNameEqual for RootName %ws, Server %wZ, Status %x, IsEqual? 0x%x\n",
        RootName, pServerName, HResult, *pIsEqual);

    return Status;
}


BOOLEAN
DfsIsSpecialDomainShare(
    PUNICODE_STRING pShareName )
{
    ULONG Index;
    ULONG TotalShares;
    BOOLEAN SpecialShare = FALSE;

    TotalShares = sizeof(DfsSpecialDCShares) / sizeof(DfsSpecialDCShares[0]);
    for (Index = 0; Index < TotalShares; Index++ )
    {
        if (DfsSpecialDCShares[Index].Length == pShareName->Length) {
            if (_wcsnicmp(DfsSpecialDCShares[Index].Buffer,
                          pShareName->Buffer,
                          pShareName->Length/sizeof(WCHAR)) == 0)
            {
                SpecialShare = TRUE;
                break;
            }
        }
    }

    return SpecialShare;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsassert.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DfsAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:

    Rohan Phillips     [Rohanp]    18-Jan-2001

Revision History:


Notes:


--*/

#ifndef _DFSASSERT_INCLUDED_
#define _DFSASSERT_INCLUDED_

VOID DfsDbgBreakPoint(PCHAR FileName, ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef DFS_ASSERTS

#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        DfsDbgBreakPoint(__FILE__,__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        DfsDbgBreakPoint(__FILE__,__LINE__)

#endif //!DBG


//this will make asserts go to our routine

#define RtlAssert DfsAssert
VOID
DfsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef DFS_ASSERTS


#if DBG
ULONG DfsDebugVector = 0;
#define DFS_TRACE_ERROR      0x00000001
#define DFS_TRACE_DEBUG      0x00000002
#define DFS_TRACE_CONTEXT    0x00000004
#define DFS_TRACE_DETAIL     0x00000008
#define DFS_TRACE_ENTRYEXIT  0x00000010
#define DFS_TRACE_WARNING    0x00000020
#define DFS_TRACE_ALL        0xffffffff
#define DfsDbgTrace(_x_, _y_) {         \
        if (_x_ & DfsDebugVector) {     \
            DbgPrint _y_;                \
        }                                \
}
#else
#define DfsDbgTrace(_x_, _y_)
#endif

#define DfsTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        DfsDbgTrace(DFS_TRACE_ENTRYEXIT,("Entering %s\n",__pszFunction));
        
#define DfsTraceLeave(status)                                                \
        DfsDbgTrace(DFS_TRACE_ENTRYEXIT,("Leaving %s Status -> %08lx\n",__pszFunction,status))
        


#define RxDbgTrace(x, y, z)
#define CHECK_STATUS( status )  if( (status) == g_CheckStatus) \
                                   { DbgBreakPoint() ; }

#endif // _DFSASSERT_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsheader.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    header.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   11\10\1999
    
NOTES:

*/

#ifndef __DFS_HEADER_H
#define __DFS_HEADER_H

#define DFS_OBJECT_MAJOR 0x81

typedef enum _DFS_OBJECT_TYPES {
    DFS_OT_UNDEFINED = 0x8100,
    DFS_OT_PREFIX_TABLE,
    DFS_OT_NAME_TABLE,
    DFS_OT_SERVER_INFO,
    DFS_OT_ROOT_OBJECT,
    DFS_OT_LINK_OBJECT,
    DFS_OT_REPLICA_OBJECT,
    DFS_OT_METADATA_STORAGE,
    DFS_OT_REGISTRY_MACHINE,
    DFS_OT_REFERRAL_STRUCT,
    DFS_OT_REGISTRY_STORE,
    DFS_OT_AD_STORE,
    DFS_OT_POLICY_OBJECT,
    DFS_OT_REFERRAL_LOAD_CONTEXT,
    DFS_OT_AD_DOMAIN,
    DFS_OT_ENTERPRISE_STORE
} DFS_OBJECT_TYPES;


typedef struct _DFS_OBJECT_HEADER {
    union {
        struct {
            UCHAR   ObjectType;          
            UCHAR   ObjectMajor;        // Only used for debugging.
        }Ob;
        USHORT NodeType;                // Mainly for debugging.
    }Node;
    SHORT  NodeSize;
    LONG    ReferenceCount;             // count of people referencing this.
} DFS_OBJECT_HEADER, *PDFS_OBJECT_HEADER;

#define DfsInitializeHeader(_hdr, _type, _size) \
        (_hdr)->Node.NodeType    = (USHORT)(_type),   \
        (_hdr)->NodeSize    = (USHORT)(_size),  \
        (_hdr)->ReferenceCount = 1

#define DfsIncrementReference(_hdr)   \
        InterlockedIncrement(&((PDFS_OBJECT_HEADER)(_hdr))->ReferenceCount)
#define DfsDecrementReference(_hdr)   \
        InterlockedDecrement(&((PDFS_OBJECT_HEADER)(_hdr))->ReferenceCount)


#define DfsGetHeaderType(_x)  (((PDFS_OBJECT_HEADER)(_x))->Node.NodeType)
#define DfsGetHeaderSize(_x)  (((PDFS_OBJECT_HEADER)(_x))->NodeSize)
#define DfsGetHeaderCount(_x)  (((PDFS_OBJECT_HEADER)(_x))->ReferenceCount)


#define DFS_FILTER_NAME               L"\\DfsServer"


typedef DWORD DFSSTATUS;


#endif /* __DFS_HEADER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsnametable.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.h
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------


#ifndef __DFSNAMETABLE_H__
#define __DFSNAMETABLE_H__

#include <dfsheader.h>

#ifdef __cplusplus
extern "C" {
#endif

struct _DFS_NAME_TABLE;

NTSTATUS
DfsInitializeNameTable(
    IN ULONG NumBuckets,
    OUT struct _DFS_NAME_TABLE **ppNameTable);


NTSTATUS
DfsInsertInNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pName,
    IN PVOID pData );


NTSTATUS
DfsLookupNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName, 
    OUT PVOID *ppData );

NTSTATUS
DfsGetEntryNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    OUT PVOID *ppData );

NTSTATUS
DfsRemoveFromNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN PVOID pData );


NTSTATUS
DfsReplaceInNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN OUT PVOID *ppData );


NTSTATUS
DfsDereferenceNameTable(
    IN struct _DFS_NAME_TABLE *pNameTable );


NTSTATUS
DfsReferenceNameTable(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableAcquireReadLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableAcquireWriteLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableReleaseLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsEnumerateNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN OUT PVOID *ppEnumerator,
    OUT PVOID *ppData );

#ifdef __cplusplus
}
#endif


#endif // __DFSNAMETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsmisc.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    header.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   11\10\1999
    
NOTES:

*/

#ifndef __DFS_MISC_H__
#define __DFS_MISC_H__

#ifdef __cplusplus
extern "C" {
#endif

VOID
DfsGetNetbiosName(
   PUNICODE_STRING pName,
   PUNICODE_STRING pNetbiosName,
   PUNICODE_STRING pRemaining );


DFSSTATUS
DfsGetPathComponents(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining);


DFSSTATUS
DfsGetFirstComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pFirstName,
   PUNICODE_STRING pRemaining);

DFSSTATUS
DfsGetNextComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pFirstName,
   PUNICODE_STRING pRemaining);


DFSSTATUS
DfsIsThisAMachineName(LPWSTR MachineName);


DFSSTATUS
DfsIsThisAStandAloneDfsName(
             LPWSTR ServerName,
             LPWSTR ShareName );


DFSSTATUS
DfsIsThisARealDfsName(
    LPWSTR ServerName,
    LPWSTR ShareName,
    BOOLEAN * IsDomainDfs );

DFSSTATUS
DfsIsThisADomainName(LPWSTR DomainName);

DFSSTATUS
DfsGenerateUuidString(LPWSTR *UuidString );

VOID
DfsReleaseUuidString(LPWSTR *UuidString );

DFSSTATUS
DfsCreateUnicodeString( 
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc );

DFSSTATUS
DfsCreateUnicodeStringFromString( 
    PUNICODE_STRING pDest,
    LPWSTR pSrcString );


DFSSTATUS
DfsCreateUnicodePathString(
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    LPWSTR pFirstComponent,
    LPWSTR pRemaining );

DFSSTATUS
DfsCreateUnicodePathStringFromUnicode(
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    PUNICODE_STRING pFirst,
    PUNICODE_STRING pRemaining );

VOID
DfsFreeUnicodeString( 
    PUNICODE_STRING pDfsString );

DFSSTATUS
DfsGetSharePath( 
    IN  LPWSTR ServerName,
    IN  LPWSTR ShareName,
    OUT PUNICODE_STRING pPathName );

ULONG
DfsSizeUncPath( 
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent );

VOID
DfsCopyUncPath( 
    LPWSTR NewPath,
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent );

DFSSTATUS
DfsApiSizeLevelHeader(
    ULONG Level,
    LONG * ReturnedSize );

NTSTATUS
AddNextPathComponent( 
    PUNICODE_STRING pPath );

NTSTATUS 
StripLastPathComponent( 
    PUNICODE_STRING pPath );



DFSSTATUS
PackGetULong(
        PULONG pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetULong(
        ULONG Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeULong();


DFSSTATUS
PackGetUShort(
        PUSHORT pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetUShort(
        USHORT Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeUShort();


DFSSTATUS
PackGetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeString(
        PUNICODE_STRING pString);


DFSSTATUS
PackGetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeGuid();

void
StripTrailingSpacesFromPath( 
    LPWSTR pPath );

LPWSTR
StripLeadingSpacesFromPath( 
    LPWSTR pPath );

LPWSTR
StripSpacesFromPath( 
    LPWSTR pPath );


DFSSTATUS
DfsRtlInitUnicodeStringEx(PUNICODE_STRING DestinationString, 
                          PCWSTR SourceString);

DFSSTATUS
DfsStringCchLength(
    LPWSTR pStr, 
    size_t CchMax, 
    size_t *pCch);

DFSSTATUS
DfsGetRegValueString(
    HKEY Key,
    LPWSTR pKeyName,
    PUNICODE_STRING pValue );

VOID
DfsReleaseRegValueString(
    PUNICODE_STRING pValue );

#define UNICODE_PATH_SEP  L'\\'

#define IsEmptyString(_str) \
        ( ((_str) == NULL) || ((_str)[0] == UNICODE_NULL) )
        
#define IsEmptyUnicodeString(_unistr) \
        ( ((_unistr) == NULL) || ((_unistr)->Length == 0) || IsEmptyString((_unistr)->Buffer) )

#define IsLocalName(_pUnicode) \
        ( (((_pUnicode)->Length == sizeof(WCHAR)) && ((_pUnicode)->Buffer[0] == L'.')) ||    \
          (((_pUnicode)->Length == 2 * sizeof(WCHAR)) && ((_pUnicode)->Buffer[0] == L'.') && ((_pUnicode)->Buffer[1] == UNICODE_NULL)) )
          


#ifdef __cplusplus
}

#endif
#endif /* __DFS_MISC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsreferraldata.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    DfsReferalData.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   01\16\2001
    Copied from structures setup by RohanP.
    
NOTES:

*/


#ifndef __DFS_REFERRAL_DATA_H__
#define __DFS_REFERRAL_DATA_H__

#ifdef __cplusplus
extern "C" {
#endif


#define CURRENT_DFS_REPLICA_HEADER_VERSION 1

#define DFS_REFERRAL_DATA_ROOT_REFERRAL        0x0001
#define DFS_REFERRAL_DATA_OUT_OF_DOMAIN        0x0002
#define DFS_REFERRAL_DATA_DOMAIN_REFERRAL      0x0010
#define DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL   0x0020

#define DFS_DEFAULT_REFERRAL_TIMEOUT           300


typedef struct _REFFERAL_HEADER_
{
	ULONG VersionNumber;
    ULONG ReferralFlags;
    ULONG TotalSize;
	ULONG ReplicaCount;
    ULONG Timeout;
	ULONG OffsetToReplicas;
	ULONG LinkNameLength;
	WCHAR LinkName[1];	
}REFERRAL_HEADER, *PREFERRAL_HEADER;



typedef struct _REPLICA_INFORMATION_
{
	ULONG NextEntryOffset;
	ULONG ReplicaFlags;
	ULONG ReplicaCost;
	ULONG ReplicaNameLength;
	WCHAR ReplicaName[1];
}REPLICA_INFORMATION, *PREPLICA_INFORMATION;


#define DFS_OLDDFS_SERVER      0x00000001 //for flags field below
typedef struct _REPLICA_DATA_INFO_
{
    ULONG  Flags;
    ULONG  ClientBufferSize;
    ULONG  MaxReferralLevel;
    ULONG  CostLimit;
    ULONG  NumReplicasToReturn;
    ULONG  IpLength;
    ULONG  LinkNameLength;
    USHORT IpFamily;
    char   IpData[14];
    WCHAR  LinkName[1];
}REPLICA_DATA_INFO, *PREPLICA_DATA_INFO;

#ifdef __cplusplus
}
#endif


#endif // __DFS_REFERRAL_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfssecurity.h ===
#ifndef __DFS_SECURITY_SUPPORT__
#define __DFS_SECURITY_SUPPORT__
#ifdef __cplusplus
extern "C" {
#endif
  
DFSSTATUS 
AccessImpersonateCheckRpcClientEx(PSECURITY_DESCRIPTOR DfsAdminSecurityDesc,
                                  GENERIC_MAPPING * DfsAdminGenericMapping,
                                  DWORD DesiredAccess);
  

DFSSTATUS
DfsDoesUserHaveDesiredAccessToAd(DWORD DesiredAccess, 
                                 PSECURITY_DESCRIPTOR pSD);

PVOID
DfsAllocateSecurityData(ULONG Size );


VOID
DfsDeallocateSecurityData(PVOID pPointer );


DFSSTATUS
DfsReadDSObjSecDesc(
    LDAP * pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize);


DFSSTATUS
DfsGetObjSecurity(LDAP *pldap,
                  LPWSTR pwszObjectName,
                  PSECURITY_DESCRIPTOR * pSDRet);


DWORD
DfsGetFileSecurityByHandle(IN  HANDLE  hFile,
                           OUT PSECURITY_DESCRIPTOR    *ppSD);


DWORD
DfsGetFileSecurityByName(PUNICODE_STRING DirectoryName, 
                         PSECURITY_DESCRIPTOR  *pSD2);


DWORD 
DfsIsAccessGrantedBySid(DWORD dwDesiredAccess,
                        PSECURITY_DESCRIPTOR pSD, 
                        PSID TheSID,
                        GENERIC_MAPPING * DfsGenericMapping);


DWORD 
DfsIsAccessGrantedByToken(DWORD dwDesiredAccess,
                          PSECURITY_DESCRIPTOR pSD, 
                          HANDLE TheToken,
                          GENERIC_MAPPING * DfsGenericMapping);


DFSSTATUS
DfsRemoveDisabledPrivileges (void);



DFSSTATUS
DfsAdjustPrivilege(ULONG Privilege, 
                   BOOLEAN bEnable);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsnetevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    netevent.h

Abstract:

    Definitions for network events.

Author:

    Portable Systems Group 6-May-1992

Revision History:

Notes:

    This file is generated by the MC tool from the netevent.mc file.

--*/

#ifndef _NETEVENT_
#define _NETEVENT_


/////////////////////////////////////////////////////////////////////////
//
// Lanman Server Events (2000 - 2999)
//     2000-2499 are generated by the server driver (kernel mode)
//     2500-2999 are generated by the server service (user mode)
//
/////////////////////////////////////////////////////////////////////////


// Server driver events, issued from kernel mode.  Don't use %1 for
// server-supplied insertion strings -- the I/O system provides the
// first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_SRV_SERVICE_FAILED
//
// MessageText:
//
//  The server's call to a system service failed unexpectedly.
//
#define EVENT_SRV_SERVICE_FAILED         0xC00007D0L

//
// MessageId: EVENT_SRV_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The server was unable to perform an operation due to a shortage of available resources.
//
#define EVENT_SRV_RESOURCE_SHORTAGE      0xC00007D1L

//
// MessageId: EVENT_SRV_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The server could not create its device.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_DEVICE     0xC00007D2L

//
// MessageId: EVENT_SRV_CANT_CREATE_PROCESS
//
// MessageText:
//
//  The server could not create a process.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_PROCESS    0xC00007D3L

//
// MessageId: EVENT_SRV_CANT_CREATE_THREAD
//
// MessageText:
//
//  The server could not create a startup thread.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_THREAD     0xC00007D4L

//
// MessageId: EVENT_SRV_UNEXPECTED_DISC
//
// MessageText:
//
//  The server received an unexpected disconnection from a client.
//
#define EVENT_SRV_UNEXPECTED_DISC        0xC00007D5L

//
// MessageId: EVENT_SRV_INVALID_REQUEST
//
// MessageText:
//
//  The server received an incorrectly formatted request from %2.
//
#define EVENT_SRV_INVALID_REQUEST        0xC00007D6L

//
// MessageId: EVENT_SRV_CANT_OPEN_NPFS
//
// MessageText:
//
//  The server could not open the named pipe file system.  Remote named pipes are disabled.
//
#define EVENT_SRV_CANT_OPEN_NPFS         0xC00007D7L

//
// MessageId: EVENT_SRV_CANT_GROW_TABLE
//
// MessageText:
//
//  The server could not expand a table because the table reached the maximum size.
//
#define EVENT_SRV_CANT_GROW_TABLE        0x800007D9L

//
// MessageId: EVENT_SRV_CANT_START_SCAVENGER
//
// MessageText:
//
//  The server could not start the scavenger thread.  The server could not be started.
//
#define EVENT_SRV_CANT_START_SCAVENGER   0xC00007DAL

//
// MessageId: EVENT_SRV_IRP_STACK_SIZE
//
// MessageText:
//
//  The server's configuration parameter "irpstacksize" is too small for the server to use a local device.  Please increase the value of this parameter.
//
#define EVENT_SRV_IRP_STACK_SIZE         0xC00007DBL

//
// MessageId: EVENT_SRV_NETWORK_ERROR
//
// MessageText:
//
//  While transmitting or receiving data, the server encountered a network error.
//  Occassional errors are expected, but large amounts of these indicate a possible
//  error in your network configuration.  The error status code is contained within
//  the returned data (formatted as Words) and may point you towards the problem.
//
#define EVENT_SRV_NETWORK_ERROR          0x800007DCL

//
// MessageId: EVENT_SRV_DISK_FULL
//
// MessageText:
//
//  The %2 disk is at or near capacity.  You may need to delete some files.
//
#define EVENT_SRV_DISK_FULL              0x800007DDL

//
// MessageId: EVENT_SRV_NO_VIRTUAL_MEMORY
//
// MessageText:
//
//  The server was unable to allocate virtual memory.
//
#define EVENT_SRV_NO_VIRTUAL_MEMORY      0xC00007E0L

//
// MessageId: EVENT_SRV_NONPAGED_POOL_LIMIT
//
// MessageText:
//
//  The server was unable to allocate from the system nonpaged pool because the server reached the configured limit for nonpaged pool allocations.
//
#define EVENT_SRV_NONPAGED_POOL_LIMIT    0xC00007E1L

//
// MessageId: EVENT_SRV_PAGED_POOL_LIMIT
//
// MessageText:
//
//  The server was unable to allocate from the system paged pool because the server reached the configured limit for paged pool allocations.
//
#define EVENT_SRV_PAGED_POOL_LIMIT       0xC00007E2L

//
// MessageId: EVENT_SRV_NO_NONPAGED_POOL
//
// MessageText:
//
//  The server was unable to allocate from the system nonpaged pool because the pool was empty.
//
#define EVENT_SRV_NO_NONPAGED_POOL       0xC00007E3L

//
// MessageId: EVENT_SRV_NO_PAGED_POOL
//
// MessageText:
//
//  The server was unable to allocate from the system paged pool because the pool was empty.
//
#define EVENT_SRV_NO_PAGED_POOL          0xC00007E4L

//
// MessageId: EVENT_SRV_NO_WORK_ITEM
//
// MessageText:
//
//  The server was unable to allocate a work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_WORK_ITEM           0x800007E5L

//
// MessageId: EVENT_SRV_NO_FREE_CONNECTIONS
//
// MessageText:
//
//  The server was unable to find a free connection %2 times in the last %3 seconds.  This indicates a spike in
//  network traffic.  If this is happening frequently, you should consider increasing the minimum number of free
//  connections to add headroom.  To do that, modify the MinFreeConnections and MaxFreeConnections for the LanmanServer
//  in the registry.
//
#define EVENT_SRV_NO_FREE_CONNECTIONS    0x800007E6L

//
// MessageId: EVENT_SRV_NO_FREE_RAW_WORK_ITEM
//
// MessageText:
//
//  The server was unable to find a free raw work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_FREE_RAW_WORK_ITEM  0x800007E7L

//
// MessageId: EVENT_SRV_NO_BLOCKING_IO
//
// MessageText:
//
//  The server was unable to allocate resources for blocking I/O %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_BLOCKING_IO         0x800007E8L

//
// MessageId: EVENT_SRV_DOS_ATTACK_DETECTED
//
// MessageText:
//
//  The server has detected an attempted Denial-Of-Service attack from client %2, and has disconnected the connection.
//
#define EVENT_SRV_DOS_ATTACK_DETECTED    0x800007E9L

//
// MessageId: EVENT_SRV_TOO_MANY_DOS
//
// MessageText:
//
//  The server has detected too many Denial-Of-Service attacks and will stop logging
//  events for any more of them.  Be advised it is likely someone is actively attacking
//  your machine.
//
#define EVENT_SRV_TOO_MANY_DOS           0x800007EAL

//
// MessageId: EVENT_SRV_OUT_OF_WORK_ITEM_DOS
//
// MessageText:
//
//  The server has detected a potential Denial-of-Service attack caused by consuming all the work-items.  Some connections
//  were disconnected to protect against this.  If this is not the case, please raise the MaxWorkItems for the server or
//  disable DoS detection.  This event will not be logged again for 24 hours.
//
#define EVENT_SRV_OUT_OF_WORK_ITEM_DOS   0x800007EBL


// Server service events, issued from user mode.  %1 is the first
// service-supplied insertion string.

//
// MessageId: EVENT_SRV_KEY_NOT_FOUND
//
// MessageText:
//
//  The server's Registry key %1 was not present.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_FOUND          0xC00009C5L

//
// MessageId: EVENT_SRV_KEY_NOT_CREATED
//
// MessageText:
//
//  The server's Registry key %1 was not present and could not be created.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_CREATED        0xC00009C6L

//
// MessageId: EVENT_SRV_NO_TRANSPORTS_BOUND
//
// MessageText:
//
//  The server did not bind to any transports.  The server could not start.
//
#define EVENT_SRV_NO_TRANSPORTS_BOUND    0xC00009C7L

//
// MessageId: EVENT_SRV_CANT_BIND_TO_TRANSPORT
//
// MessageText:
//
//  The server could not bind to the transport %1.
//
#define EVENT_SRV_CANT_BIND_TO_TRANSPORT 0x800009C8L

//
// MessageId: EVENT_SRV_CANT_BIND_DUP_NAME
//
// MessageText:
//
//  The server could not bind to the transport %1 because another computer on the network has the same name.  The server could not start.
//
#define EVENT_SRV_CANT_BIND_DUP_NAME     0xC00009C9L

//
// MessageId: EVENT_SRV_INVALID_REGISTRY_VALUE
//
// MessageText:
//
//  The value named %1 in the server's registry key %2 was not valid, and was ignored.
//  If you want to change the value, change it to one that is the correct type and is
//  within the acceptable range, or delete the value to use the default. This value
//  might have been set up by an older program that did not use the correct boundaries.
//
#define EVENT_SRV_INVALID_REGISTRY_VALUE 0x800009CAL

//
// MessageId: EVENT_SRV_INVALID_SD
//
// MessageText:
//
//  The security descriptor stored in the Registry for the share %1 was invalid.  The share was not automatically recreated.
//
#define EVENT_SRV_INVALID_SD             0x800009CBL

//
// MessageId: EVENT_SRV_CANT_LOAD_DRIVER
//
// MessageText:
//
//  The server service was unable to load the server driver.
//
#define EVENT_SRV_CANT_LOAD_DRIVER       0x800009CCL

//
// MessageId: EVENT_SRV_CANT_UNLOAD_DRIVER
//
// MessageText:
//
//  The server service was unable to unload the server driver.
//
#define EVENT_SRV_CANT_UNLOAD_DRIVER     0x800009CDL

//
// MessageId: EVENT_SRV_CANT_MAP_ERROR
//
// MessageText:
//
//  The server service was unable to map error code %1.
//
#define EVENT_SRV_CANT_MAP_ERROR         0x800009CEL

//
// MessageId: EVENT_SRV_CANT_RECREATE_SHARE
//
// MessageText:
//
//  The server service was unable to recreate the share %1 because the directory %2 no longer exists.  Please run "net share %1 /delete" to delete the share, or recreate the directory %2.
//
#define EVENT_SRV_CANT_RECREATE_SHARE    0x800009CFL

//
// MessageId: EVENT_SRV_CANT_CHANGE_DOMAIN_NAME
//
// MessageText:
//
//  The server service was unable to change the domain name from %1 to %2.
//
#define EVENT_SRV_CANT_CHANGE_DOMAIN_NAME 0x800009D0L


/////////////////////////////////////////////////////////////////////////
//
// Lanman Redirector Events
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RDR_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The redirector was unable to allocate memory.
//
#define EVENT_RDR_RESOURCE_SHORTAGE      0x80000BB9L

//
// MessageId: EVENT_RDR_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The redirector could not create its device.  The redirector could not be started.
//
#define EVENT_RDR_CANT_CREATE_DEVICE     0x80000BBAL

//
// MessageId: EVENT_RDR_CANT_CREATE_THREAD
//
// MessageText:
//
//  The redirector could not create a system thread.
//
#define EVENT_RDR_CANT_CREATE_THREAD     0x80000BBBL

//
// MessageId: EVENT_RDR_CANT_SET_THREAD
//
// MessageText:
//
//  The redirector could not set the priority for a system thread.
//
#define EVENT_RDR_CANT_SET_THREAD        0x80000BBCL

//
// MessageId: EVENT_RDR_INVALID_REPLY
//
// MessageText:
//
//  The redirector received an incorrectly formatted response from %2.
//
#define EVENT_RDR_INVALID_REPLY          0x80000BBDL

//
// MessageId: EVENT_RDR_INVALID_SMB
//
// MessageText:
//
//  The redirector received an SMB that was too short.
//
#define EVENT_RDR_INVALID_SMB            0x80000BBEL

//
// MessageId: EVENT_RDR_INVALID_LOCK_REPLY
//
// MessageText:
//
//  The redirector received an incorrect response from %2 to a lock request.
//
#define EVENT_RDR_INVALID_LOCK_REPLY     0x80000BBFL

//
// MessageId: EVENT_RDR_FAILED_UNLOCK
//
// MessageText:
//
//  The redirector failed to unlock part of a file on server %2.
//
#define EVENT_RDR_FAILED_UNLOCK          0x80000BC1L

//
// MessageId: EVENT_RDR_CLOSE_BEHIND
//
// MessageText:
//
//  The redirector failed to write data to server %2 after the file was closed.
//
#define EVENT_RDR_CLOSE_BEHIND           0x80000BC3L

//
// MessageId: EVENT_RDR_UNEXPECTED_ERROR
//
// MessageText:
//
//  An unexpected network error has occurred on the virtual circuit to %2.
//
#define EVENT_RDR_UNEXPECTED_ERROR       0x80000BC4L

//
// MessageId: EVENT_RDR_TIMEOUT
//
// MessageText:
//
//  The redirector has timed out a request to %2.
//
#define EVENT_RDR_TIMEOUT                0x80000BC5L

//
// MessageId: EVENT_RDR_INVALID_OPLOCK
//
// MessageText:
//
//  The redirector received an invalid oplock level from %2.
//
#define EVENT_RDR_INVALID_OPLOCK         0x80000BC6L

//
// MessageId: EVENT_RDR_CONNECTION_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced a connection through zero.
//
#define EVENT_RDR_CONNECTION_REFERENCE   0x80000BC7L

//
// MessageId: EVENT_RDR_SERVER_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced a server through zero.
//
#define EVENT_RDR_SERVER_REFERENCE       0x80000BC8L

//
// MessageId: EVENT_RDR_SMB_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced the allocated SMB count through zero.
//
#define EVENT_RDR_SMB_REFERENCE          0x80000BC9L

//
// MessageId: EVENT_RDR_ENCRYPT
//
// MessageText:
//
//  The redirector accessed a share-level server that indicates it encrypts passwords.
//  This combination is not supported.
//
#define EVENT_RDR_ENCRYPT                0x80000BCAL

//
// MessageId: EVENT_RDR_CONNECTION
//
// MessageText:
//
//  The redirector failed to determine the connection type.
//
#define EVENT_RDR_CONNECTION             0x80000BCBL

//
// MessageId: EVENT_RDR_MAXCMDS
//
// MessageText:
//
//  The redirector failed to allocate a multiplex table entry.  This indicates that
//  the MAXCMDS parameter to the redirector is insufficient for the users needs.
//
#define EVENT_RDR_MAXCMDS                0x80000BCDL

//
// MessageId: EVENT_RDR_OPLOCK_SMB
//
// MessageText:
//
//  The redirector failed to allocate a buffer for an oplock break.
//
#define EVENT_RDR_OPLOCK_SMB             0x80000BCEL

//
// MessageId: EVENT_RDR_DISPOSITION
//
// MessageText:
//
//  The redirector failed to map the requested file disposition (for NtCreateFile).
//
#define EVENT_RDR_DISPOSITION            0x80000BCFL

//
// MessageId: EVENT_RDR_CONTEXTS
//
// MessageText:
//
//  The redirector is allocating additional resources for input/output request packet contexts.  This is
//  probably caused by a resource leak in the redirector.
//
#define EVENT_RDR_CONTEXTS               0x80000BD0L

//
// MessageId: EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED
//
// MessageText:
//
//  A write-behind operation has failed to the remote server %2.  The data contains the amount requested to write and the amount actually written.
//
#define EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED 0x80000BD1L

//
// MessageId: EVENT_RDR_AT_THREAD_MAX
//
// MessageText:
//
//  The redirector was unable to create a worker thread because it has already created the maximum number of configured work threads.
//
#define EVENT_RDR_AT_THREAD_MAX          0x80000BD2L

//
// MessageId: EVENT_RDR_CANT_READ_REGISTRY
//
// MessageText:
//
//  The redirector was unable to initialize variables from the Registry.
//
#define EVENT_RDR_CANT_READ_REGISTRY     0x80000BD3L

//
// MessageId: EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE
//
// MessageText:
//
//  The time zone bias calculated between %2 and the current workstation is too
//  large.  The data specifies the number of 100ns units between the workstation
//  and server.  Make sure that the time of day on the workstation and server are
//  correct.
//
#define EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE 0x80000BD4L

//
// MessageId: EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
//  The redirector has failed to connect to the server %2 on the primary transport.  The data contains the error.
//
#define EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED 0x80000BD5L

//
// MessageId: EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED
//
// MessageText:
//
//  The redirector was unable to update the file attributes on a file located on server %2.
//  The data contains the name of the file.
//
#define EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED 0x80000BD6L

//
// MessageId: EVENT_RDR_DELETEONCLOSE_FAILED
//
// MessageText:
//
//  The redirector was unable to delete the file specified on server %2 when it was closed by the application.
//  The data contains the name of the file.
//
#define EVENT_RDR_DELETEONCLOSE_FAILED   0x80000BD7L

//
// MessageId: EVENT_RDR_CANT_BIND_TRANSPORT
//
// MessageText:
//
//  The redirector was unable to register the domain %2 on to transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_BIND_TRANSPORT    0x80000BD8L

//
// MessageId: EVENT_RDR_CANT_REGISTER_ADDRESS
//
// MessageText:
//
//  The redirector was unable to register the address for transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_REGISTER_ADDRESS  0x80000BD9L

//
// MessageId: EVENT_RDR_CANT_GET_SECURITY_CONTEXT
//
// MessageText:
//
//  The redirector was unable to initialize security context or query context attributes.
//
#define EVENT_RDR_CANT_GET_SECURITY_CONTEXT 0x80000BDAL

//
// MessageId: EVENT_RDR_CANT_BUILD_SMB_HEADER
//
// MessageText:
//
//  The redirector was unable to build SMB header.
//
#define EVENT_RDR_CANT_BUILD_SMB_HEADER  0x80000BDBL

//
// MessageId: EVENT_RDR_SECURITY_SIGNATURE_MISMATCH
//
// MessageText:
//
//  The redirector detected a security signature mismatch. The connection has been disconnected.
//
#define EVENT_RDR_SECURITY_SIGNATURE_MISMATCH 0x80000BDCL



/////////////////////////////////////////////////////////////////////////
//
// IPv6 Events
//
// Codes 3100 - 3199
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TCPIP6_STARTED
//
// MessageText:
//
//  The Microsoft TCP/IP version 6 driver was started.
//
#define EVENT_TCPIP6_STARTED             0x40000C1CL



/////////////////////////////////////////////////////////////////////////
//
// STREAMS Environment Events
//
// Codes 4000 - 4099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_STREAMS_STRLOG
//
// MessageText:
//
//  %2.
//
#define EVENT_STREAMS_STRLOG             0xC0000FA0L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE
//
// MessageText:
//
//  Unable to allocate a %2 byte message.
//
#define EVENT_STREAMS_ALLOCB_FAILURE     0x80000FA1L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE_CNT
//
// MessageText:
//
//  %2 message allocations have failed since initialization.
//
#define EVENT_STREAMS_ALLOCB_FAILURE_CNT 0x80000FA2L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE
//
// MessageText:
//
//  Unable to allocate a %2 byte external message.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE   0x80000FA3L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE_CNT
//
// MessageText:
//
//  %2 external message allocations have failed since initialization.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE_CNT 0x80000FA4L



/////////////////////////////////////////////////////////////////////////
//
// TCP/IP Events
//
// Codes 4100 - 4299
//
/////////////////////////////////////////////////////////////////////////


//
// Common TCP/IP messages
//
// Codes 4100 - 4149
//
//

//
// MessageId: EVENT_TCPIP_CREATE_DEVICE_FAILED
//
// MessageText:
//
//  Unable to create device object %2. Initialization failed.
//
#define EVENT_TCPIP_CREATE_DEVICE_FAILED 0xC0001004L

//
// MessageId: EVENT_TCPIP_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  Unable to allocate required resources. Initialization failed.
//
#define EVENT_TCPIP_NO_RESOURCES_FOR_INIT 0xC0001005L


//
// ARP messages
//
// Codes 4150-4174


//
// IP Loopback messages
//
// Codes 4175-4184
//


//
// IP/ICMP messages
//
// Codes 4185 - 4224

//
// MessageId: EVENT_TCPIP_TOO_MANY_NETS
//
// MessageText:
//
//  IP has been bound to more than the maximum number of supported interfaces.
//  Some interfaces on adapter %2 will not be initialized.
//
#define EVENT_TCPIP_TOO_MANY_NETS        0xC0001059L

//
// MessageId: EVENT_TCPIP_NO_MASK
//
// MessageText:
//
//  No subnet mask was specified for interface %2. This interface and
//  all subsequent interfaces on adapter %3 cannot be initialized.
//
#define EVENT_TCPIP_NO_MASK              0xC000105AL

//
// MessageId: EVENT_TCPIP_INVALID_ADDRESS
//
// MessageText:
//
//  Invalid address %2 was specified for adapter %3. This interface
//  cannot be initialized.
//
#define EVENT_TCPIP_INVALID_ADDRESS      0xC000105BL

//
// MessageId: EVENT_TCPIP_INVALID_MASK
//
// MessageText:
//
//  Invalid subnet mask %2 was specified for address %3 on adapter %4.
//  This interface cannot be initialized.
//
#define EVENT_TCPIP_INVALID_MASK         0xC000105CL

//
// MessageId: EVENT_TCPIP_NO_ADAPTER_RESOURCES
//
// MessageText:
//
//  IP could not allocate some resources required to configure adapter %2.
//  Some interfaces on this adapter will not be initialized.
//
#define EVENT_TCPIP_NO_ADAPTER_RESOURCES 0xC000105DL

//
// MessageId: EVENT_TCPIP_DHCP_INIT_FAILED
//
// MessageText:
//
//  IP was unable to initialize adapter %2 for configuration by DHCP.
//  If DHCP is enabled on this adapter, the primary interface may not be
//  configured properly. Interfaces on this adapter not configured by
//  DHCP will be unaffected.
//
#define EVENT_TCPIP_DHCP_INIT_FAILED     0x8000105EL

//
// MessageId: EVENT_TCPIP_ADAPTER_REG_FAILURE
//
// MessageText:
//
//  IP could not open the registry key for adapter %2.
//  Interfaces on this adapter will not be initialized.
//
#define EVENT_TCPIP_ADAPTER_REG_FAILURE  0xC000105FL

//
// MessageId: EVENT_TCPIP_INVALID_DEFAULT_GATEWAY
//
// MessageText:
//
//  Invalid default gateway address %2 was specified for adapter %3.
//  Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_INVALID_DEFAULT_GATEWAY 0x80001060L

//
// MessageId: EVENT_TCPIP_NO_ADDRESS_LIST
//
// MessageText:
//
//  Unable to read the configured IP addresses for adapter %2.
//  IP interfaces will not be initialized on this adapter.
//
#define EVENT_TCPIP_NO_ADDRESS_LIST      0xC0001061L

//
// MessageId: EVENT_TCPIP_NO_MASK_LIST
//
// MessageText:
//
//  Unable to read the configured subnet masks for adapter %2.
//  IP interfaces will not be initialized on this adapter.
//
#define EVENT_TCPIP_NO_MASK_LIST         0xC0001062L

//
// MessageId: EVENT_TCPIP_NO_BINDINGS
//
// MessageText:
//
//  IP was unable to read its bindings from the registry. No network interfaces
//  were configured.
//
#define EVENT_TCPIP_NO_BINDINGS          0xC0001063L

//
// MessageId: EVENT_TCPIP_IP_INIT_FAILED
//
// MessageText:
//
//  Initialization of IP failed.
//
#define EVENT_TCPIP_IP_INIT_FAILED       0xC0001064L

//
// MessageId: EVENT_TCPIP_TOO_MANY_GATEWAYS
//
// MessageText:
//
//  More than the maximum number of default gateways were specified for
//  adapter %2. Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_TOO_MANY_GATEWAYS    0x80001065L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT1
//
// MessageText:
//
//  The system detected an address conflict for IP address %2 with the system
//  having network hardware address %3. The local interface has been disabled.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT1    0xC0001066L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT2
//
// MessageText:
//
//  The system detected an address conflict for IP address %2 with the system
//  having network hardware address %3. Network operations on this system may
//  be disrupted as a result.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT2    0xC0001067L

//
// MessageId: EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE
//
// MessageText:
//
//  Unable to read or write the NTE Context list for adapter %2.
//  IP interfaces on this adapter may not be initialized completely.
//
#define EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE 0xC0001068L

//
// MessageId: EVENT_TCPIP_MEDIA_CONNECT
//
// MessageText:
//
//  The system detected that network adapter %2 was connected to the network,
//  and has initiated normal operation over the network adapter.
//
#define EVENT_TCPIP_MEDIA_CONNECT        0x40001069L

//
// MessageId: EVENT_TCPIP_MEDIA_DISCONNECT
//
// MessageText:
//
//  The system detected that network adapter %2 was disconnected from the network,
//  and the adapter's network configuration has been released. If the network
//  adapter was not disconnected, this may indicate that it has malfunctioned.
//  Please contact your vendor for updated drivers.
//
#define EVENT_TCPIP_MEDIA_DISCONNECT     0x4000106AL


//
// TCP messages
//
// Codes 4225 - 4264
//

//
// MessageId: EVENT_TCPIP_TCP_INIT_FAILED
//
// MessageText:
//
//  Initialization of TCP/UDP failed.
//
#define EVENT_TCPIP_TCP_INIT_FAILED      0xC0001081L


//
// UDP messages
//
// Codes 4265 - 4280
//

//
// MessageId: EVENT_TCPIP_UDP_LIMIT_REACHED
//
// MessageText:
//
//  Backlog of pending datagram sends reached. Please increase the value of Tcpip\Parameters\DGMaxSendFree in the registry.
//
#define EVENT_TCPIP_UDP_LIMIT_REACHED    0x800010A9L

//
// IPSEC messages
//
// Codes 4281 - 4299
//

//
// MessageId: EVENT_IPSEC_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  Unable to allocate required resources. Initialization failed.
//
#define EVENT_IPSEC_NO_RESOURCES_FOR_INIT 0xC00010B9L

//
// MessageId: EVENT_IPSEC_CREATE_DEVICE_FAILED
//
// MessageText:
//
//  Unable to create device object %2. Initialization failed.
//
#define EVENT_IPSEC_CREATE_DEVICE_FAILED 0xC00010BAL

//
// MessageId: EVENT_IPSEC_BAD_SPI_RECEIVED
//
// MessageText:
//
//  Received %2 packet(s) with a bad Security Parameters Index from %3.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_SPI_RECEIVED     0xC00010BBL

//
// MessageId: EVENT_IPSEC_UNEXPECTED_CLEARTEXT
//
// MessageText:
//
//  Received %2 packet(s) in the clear from %3 which should have been secured.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_UNEXPECTED_CLEARTEXT 0xC00010BCL

//
// MessageId: EVENT_IPSEC_AUTH_FAILURE
//
// MessageText:
//
//  Failed to authenticate the hash for %2 packet(s) received from %3.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_AUTH_FAILURE         0xC00010BDL

//
// MessageId: EVENT_IPSEC_BAD_PACKET_SYNTAX
//
// MessageText:
//
//  Received %2 packet(s) from %3 with invalid packet syntax.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_PACKET_SYNTAX    0xC00010BEL

//
// MessageId: EVENT_IPSEC_BAD_PROTOCOL_RECEIVED
//
// MessageText:
//
//  Received %2 packet(s) from %3 with inproper protocol identifier.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_PROTOCOL_RECEIVED 0xC00010BFL

//
// MessageId: EVENT_IPSEC_GENERIC_FAILURE
//
// MessageText:
//
//  Received %2 packet(s) from %3 that failed the IPSec processing for an unknown reason.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine..
//
#define EVENT_IPSEC_GENERIC_FAILURE      0xC00010C0L

//
// MessageId: EVENT_IPSEC_NEG_FAILURE
//
// MessageText:
//
//  The IPSec driver failed the oakley negotiation with %2 since no filter
//  exists to protect packets to that destination.
//  Please check the configuration on this machine to ensure at least one
//  filter matches the destination.
//
#define EVENT_IPSEC_NEG_FAILURE          0xC00010C1L

//
// MessageId: EVENT_IPSEC_DROP_PACKET_INBOUND
//
// MessageText:
//
//  The IPSec driver has dropped the following inbound packet:
//  %nSource IP Address: %2
//  %nDestination IP Address: %3
//  %nProtocol: %4
//  %nSource Port:  %5
//  %nDestination Port: %6
//  %nOffset for IPSec status code:                  0x14
//  %nOffset for Offload status code:                0x10
//  %nOffset for Offload flags(0=no offload):        0x20
//  %nOffset for packet start:                       0x28
//
#define EVENT_IPSEC_DROP_PACKET_INBOUND  0x400010C2L

//
// MessageId: EVENT_IPSEC_DROP_PACKET_OUTBOUND
//
// MessageText:
//
//  The IPSec driver has dropped the following outbound packet:
//  %nSource IP Address: %2
//  %nDestination IP Address: %3
//  %nProtocol: %4
//  %nSource Port:  %5
//  %nDestination Port: %6
//  %nOffset for IPSec status code:    0x14
//  %nOffset for Offload status code:  0x10
//  %nOffset for Offload flags:        0x20
//  %nOffset for packet start:         0x28
//
#define EVENT_IPSEC_DROP_PACKET_OUTBOUND 0x400010C3L



/////////////////////////////////////////////////////////////////////////
//
// NBT Events
//
// Codes 4300 - 4399
//
/////////////////////////////////////////////////////////////////////////



// Don't use %1 for driver supplied insertion strings.  The IO subsystem
// supplies the first string!!

//
// MessageId: EVENT_NBT_CREATE_DRIVER
//
// MessageText:
//
//  The driver could not be created.
//
#define EVENT_NBT_CREATE_DRIVER          0xC00010CCL

//
// MessageId: EVENT_NBT_OPEN_REG_PARAMS
//
// MessageText:
//
//  Unable to open the Registry Parameters to read configuration information.
//
#define EVENT_NBT_OPEN_REG_PARAMS        0xC00010CDL

//
// MessageId: EVENT_NBT_NO_BACKUP_WINS
//
// MessageText:
//
//  The backup WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_BACKUP_WINS         0x800010CEL

//
// MessageId: EVENT_NBT_NO_WINS
//
// MessageText:
//
//  The primary WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_WINS                0x800010CFL

//
// MessageId: EVENT_NBT_BAD_BACKUP_WINS_ADDR
//
// MessageText:
//
//  The backup WINS server address is not formated correctly in the registry.
//
#define EVENT_NBT_BAD_BACKUP_WINS_ADDR   0x800010D0L

//
// MessageId: EVENT_NBT_BAD_PRIMARY_WINS_ADDR
//
// MessageText:
//
//  The primary WINS server address is not formated correctly in the registry.
//
#define EVENT_NBT_BAD_PRIMARY_WINS_ADDR  0x800010D1L

//
// MessageId: EVENT_NBT_NAME_SERVER_ADDRS
//
// MessageText:
//
//  Unable to configure the addresses of the WINS servers.
//
#define EVENT_NBT_NAME_SERVER_ADDRS      0xC00010D2L

//
// MessageId: EVENT_NBT_CREATE_ADDRESS
//
// MessageText:
//
//  Initialization failed because the transport refused to open initial Addresses.
//
#define EVENT_NBT_CREATE_ADDRESS         0xC00010D3L

//
// MessageId: EVENT_NBT_CREATE_CONNECTION
//
// MessageText:
//
//  Initialization failed because the transport refused to open initial Connections.
//
#define EVENT_NBT_CREATE_CONNECTION      0xC00010D4L

//
// MessageId: EVENT_NBT_NON_OS_INIT
//
// MessageText:
//
//  Data structure initialization failed.
//
#define EVENT_NBT_NON_OS_INIT            0xC00010D5L

//
// MessageId: EVENT_NBT_TIMERS
//
// MessageText:
//
//  Initialization failed because the timers could not be started.
//
#define EVENT_NBT_TIMERS                 0xC00010D6L

//
// MessageId: EVENT_NBT_CREATE_DEVICE
//
// MessageText:
//
//  Initialization failed because the driver device could not be created.
//
#define EVENT_NBT_CREATE_DEVICE          0xC00010D7L

//
// MessageId: EVENT_NBT_NO_DEVICES
//
// MessageText:
//
//  There are no adapters configured for this protocol stack.
//
#define EVENT_NBT_NO_DEVICES             0x800010D8L

//
// MessageId: EVENT_NBT_OPEN_REG_LINKAGE
//
// MessageText:
//
//  Unable to open the Registry Linkage to read configuration information.
//
#define EVENT_NBT_OPEN_REG_LINKAGE       0xC00010D9L

//
// MessageId: EVENT_NBT_READ_BIND
//
// MessageText:
//
//  Unable to read the driver's bindings to the transport from the registry.
//
#define EVENT_NBT_READ_BIND              0xC00010DAL

//
// MessageId: EVENT_NBT_READ_EXPORT
//
// MessageText:
//
//  Unable to read the driver's exported linkage configuration information.
//
#define EVENT_NBT_READ_EXPORT            0xC00010DBL

//
// MessageId: EVENT_NBT_OPEN_REG_NAMESERVER
//
// MessageText:
//
//  Unable to open the Registry to read the WINS server addresses.
//
#define EVENT_NBT_OPEN_REG_NAMESERVER    0x800010DCL

//
// MessageId: EVENT_SCOPE_LABEL_TOO_LONG
//
// MessageText:
//
//  The Netbios Name Scope has a component longer than 63 characters. Each label
//  in the Scope cannot be longer than 63 bytes.  Use the Control Panel, Network
//  applet to change the scope.
//
#define EVENT_SCOPE_LABEL_TOO_LONG       0x800010DDL

//
// MessageId: EVENT_SCOPE_TOO_LONG
//
// MessageText:
//
//  The Netbios Name Scope is too long. The scope cannot be longer than
//  255 bytes. Use the Control Panel, Network applet to change the scope.
//
#define EVENT_SCOPE_TOO_LONG             0x800010DEL

//
// MessageId: EVENT_NBT_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name has been detected on the TCP network.  The IP address of
//  the machine that sent the message is in the data. Use nbtstat -n in a
//  command window to see which name is in the Conflict state.
//
#define EVENT_NBT_DUPLICATE_NAME         0xC00010DFL

//
// MessageId: EVENT_NBT_NAME_RELEASE
//
// MessageText:
//
//  Another machine has sent a name release message to this machine probably
//  because a duplicate name has been detected on the TCP network.  The IP address
//  of the node that sent the message is in the data. Use nbtstat -n in a
//  command window to see which name is in the Conflict state.
//
#define EVENT_NBT_NAME_RELEASE           0xC00010E0L

//
// MessageId: EVENT_NBT_DUPLICATE_NAME_ERROR
//
// MessageText:
//
//  The name "%2" could not be registered on the Interface with IP address %3.
//  The machine with the IP address %4 did not allow the name to be claimed by
//  this machine.
//
#define EVENT_NBT_DUPLICATE_NAME_ERROR   0xC00010E1L

//
// MessageId: EVENT_NBT_NO_RESOURCES
//
// MessageText:
//
//  NetBT failed to process a request because it encountered OutOfResources
//  exception(s) in the last 1 hour.
//
#define EVENT_NBT_NO_RESOURCES           0xC00010E2L


/////////////////////////////////////////////////////////////////////////
//
// NDIS Environment Events
//
// Codes 5000 - 5099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
//  %2 : Has encountered a conflict in resources and could not load.
//
#define EVENT_NDIS_RESOURCE_CONFLICT     0xC0001388L

//
// MessageId: EVENT_NDIS_OUT_OF_RESOURCE
//
// MessageText:
//
//  %2 : Could not allocate the resources necessary for operation.
//
#define EVENT_NDIS_OUT_OF_RESOURCE       0xC0001389L

//
// MessageId: EVENT_NDIS_HARDWARE_FAILURE
//
// MessageText:
//
//  %2 : Has determined that the adapter is not functioning properly.
//
#define EVENT_NDIS_HARDWARE_FAILURE      0xC000138AL

//
// MessageId: EVENT_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  %2 : Could not find an adapter.
//
#define EVENT_NDIS_ADAPTER_NOT_FOUND     0xC000138BL

//
// MessageId: EVENT_NDIS_INTERRUPT_CONNECT
//
// MessageText:
//
//  %2 : Could not connect to the interrupt number supplied.
//
#define EVENT_NDIS_INTERRUPT_CONNECT     0xC000138CL

//
// MessageId: EVENT_NDIS_DRIVER_FAILURE
//
// MessageText:
//
//  %2 : Has encountered an internal error and has failed.
//
#define EVENT_NDIS_DRIVER_FAILURE        0xC000138DL

//
// MessageId: EVENT_NDIS_BAD_VERSION
//
// MessageText:
//
//  %2 : The version number is incorrect for this driver.
//
#define EVENT_NDIS_BAD_VERSION           0xC000138EL

//
// MessageId: EVENT_NDIS_TIMEOUT
//
// MessageText:
//
//  %2 : Timed out during an operation.
//
#define EVENT_NDIS_TIMEOUT               0x8000138FL

//
// MessageId: EVENT_NDIS_NETWORK_ADDRESS
//
// MessageText:
//
//  %2 : Has encountered an invalid network address.
//
#define EVENT_NDIS_NETWORK_ADDRESS       0xC0001390L

//
// MessageId: EVENT_NDIS_UNSUPPORTED_CONFIGURATION
//
// MessageText:
//
//  %2 : Does not support the configuration supplied.
//
#define EVENT_NDIS_UNSUPPORTED_CONFIGURATION 0xC0001391L

//
// MessageId: EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
//
// MessageText:
//
//  %2 : The adapter has returned an invalid value to the driver.
//
#define EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER 0xC0001392L

//
// MessageId: EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
//
// MessageText:
//
//  %2 : A required parameter is missing from the Registry.
//
#define EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER 0xC0001393L

//
// MessageId: EVENT_NDIS_BAD_IO_BASE_ADDRESS
//
// MessageText:
//
//  %2 : The I/O base address supplied does not match the jumpers on the adapter.
//
#define EVENT_NDIS_BAD_IO_BASE_ADDRESS   0xC0001394L

//
// MessageId: EVENT_NDIS_RECEIVE_SPACE_SMALL
//
// MessageText:
//
//  %2 : The adapter is configured such that the receive space is smaller than
//  the maximum packet size.  Some packets may be lost.
//
#define EVENT_NDIS_RECEIVE_SPACE_SMALL   0x40001395L

//
// MessageId: EVENT_NDIS_ADAPTER_DISABLED
//
// MessageText:
//
//  %2 : The adapter is disabled.  The driver cannot open the adapter.
//
#define EVENT_NDIS_ADAPTER_DISABLED      0x80001396L

//
// MessageId: EVENT_NDIS_IO_PORT_CONFLICT
//
// MessageText:
//
//  %2 : There is an I/O port conflict.
//
#define EVENT_NDIS_IO_PORT_CONFLICT      0x80001397L

//
// MessageId: EVENT_NDIS_PORT_OR_DMA_CONFLICT
//
// MessageText:
//
//  %2 : There is an I/O port or DMA channel conflict.
//
#define EVENT_NDIS_PORT_OR_DMA_CONFLICT  0x80001398L

//
// MessageId: EVENT_NDIS_MEMORY_CONFLICT
//
// MessageText:
//
//  %2 : There is a memory conflict at address 0x%3.
//
#define EVENT_NDIS_MEMORY_CONFLICT       0x80001399L

//
// MessageId: EVENT_NDIS_INTERRUPT_CONFLICT
//
// MessageText:
//
//  %2 : There is a interrupt conflict at interrupt number %3.
//
#define EVENT_NDIS_INTERRUPT_CONFLICT    0x8000139AL

//
// MessageId: EVENT_NDIS_DMA_CONFLICT
//
// MessageText:
//
//  %2 : There is a resource conflict at DMA channel %3.
//
#define EVENT_NDIS_DMA_CONFLICT          0x8000139BL

//
// MessageId: EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR
//
// MessageText:
//
//  %2 : The download file is invalid.  The driver is unable to load.
//
#define EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR 0xC000139CL

//
// MessageId: EVENT_NDIS_MAXRECEIVES_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxReceives is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXRECEIVES_ERROR     0x8000139DL

//
// MessageId: EVENT_NDIS_MAXTRANSMITS_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxTransmits is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXTRANSMITS_ERROR    0x8000139EL

//
// MessageId: EVENT_NDIS_MAXFRAMESIZE_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxFrameSize is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXFRAMESIZE_ERROR    0x8000139FL

//
// MessageId: EVENT_NDIS_MAXINTERNALBUFS_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxInternalBufs is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXINTERNALBUFS_ERROR 0x800013A0L

//
// MessageId: EVENT_NDIS_MAXMULTICAST_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxMulticast is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXMULTICAST_ERROR    0x800013A1L

//
// MessageId: EVENT_NDIS_PRODUCTID_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry ProductId is out of range.  Using
//  default value.
//
#define EVENT_NDIS_PRODUCTID_ERROR       0x800013A2L

//
// MessageId: EVENT_NDIS_LOBE_FAILUE_ERROR
//
// MessageText:
//
//  %2 : A Token Ring Lobe Wire Fault has occurred.  Verify cable
//  connections.  The adapter will continue to try to reinsert back
//  into the ring.
//
#define EVENT_NDIS_LOBE_FAILUE_ERROR     0x800013A3L

//
// MessageId: EVENT_NDIS_SIGNAL_LOSS_ERROR
//
// MessageText:
//
//  %2 : The adapter had detected a loss of signal on the ring.  The adapter
//  will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_SIGNAL_LOSS_ERROR     0x800013A4L

//
// MessageId: EVENT_NDIS_REMOVE_RECEIVED_ERROR
//
// MessageText:
//
//  %2 : The adapter has received a request to deinsert from the
//  ring.  The adapter will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_REMOVE_RECEIVED_ERROR 0x800013A5L

//
// MessageId: EVENT_NDIS_TOKEN_RING_CORRECTION
//
// MessageText:
//
//  %2 : The adapter has successfully reinserted back into the ring.
//
#define EVENT_NDIS_TOKEN_RING_CORRECTION 0x400013A6L

//
// MessageId: EVENT_NDIS_ADAPTER_CHECK_ERROR
//
// MessageText:
//
//  %2 : The adapter has detected an Adapter Check as a result of some
//  unrecoverable hardware of software error.  Please contact your service provider.
//
#define EVENT_NDIS_ADAPTER_CHECK_ERROR   0xC00013A7L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_ERROR
//
// MessageText:
//
//  %2 : The adapter failed to reset within a specified time.  The adapter will
//  continue to try to reset.  This could be the result of a hardware failure.
//
#define EVENT_NDIS_RESET_FAILURE_ERROR   0x800013A8L

//
// MessageId: EVENT_NDIS_CABLE_DISCONNECTED_ERROR
//
// MessageText:
//
//  %2 : The adapter has detected that the Token Ring cable is disconnected from
//  the adapter.  Please reconnect the Token Ring cable.  The adapter will continue
//  to try to reset until the connection is repaired.
//
#define EVENT_NDIS_CABLE_DISCONNECTED_ERROR 0x800013A9L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_CORRECTION
//
// MessageText:
//
//  %2 : The adapter has successfully completed a previously failed reset.
//
#define EVENT_NDIS_RESET_FAILURE_CORRECTION 0x800013AAL


/////////////////////////////////////////////////////////////////////////
//
// General NT System Events
//
/////////////////////////////////////////////////////////////////////////

//
// Eventlog Events 6000 - 6099
//
//
// MessageId: EVENT_LOG_FULL
//
// MessageText:
//
//  The %1 log file is full.
//
#define EVENT_LOG_FULL                   0x80001770L

//
// MessageId: EVENT_LogFileNotOpened
//
// MessageText:
//
//  The %1 log file cannot be opened.
//
#define EVENT_LogFileNotOpened           0x80001771L

//
// MessageId: EVENT_LogFileCorrupt
//
// MessageText:
//
//  The %1 log file is corrupted and will be cleared.
//
#define EVENT_LogFileCorrupt             0x80001772L

//
// MessageId: EVENT_DefaultLogCorrupt
//
// MessageText:
//
//  The Application log file could not be opened.  %1 will be used as the default
//  log file.
//
#define EVENT_DefaultLogCorrupt          0x80001773L

//
// MessageId: EVENT_BadDriverPacket
//
// MessageText:
//
//  A driver packet received from the I/O subsystem was invalid.  The data is the
//  packet.
//
#define EVENT_BadDriverPacket            0x80001774L

//
// MessageId: EVENT_EventlogStarted
//
// MessageText:
//
//  The Event log service was started.
//
#define EVENT_EventlogStarted            0x80001775L

//
// MessageId: EVENT_EventlogStopped
//
// MessageText:
//
//  The Event log service was stopped.
//
#define EVENT_EventlogStopped            0x80001776L

//
// MessageId: TITLE_EventlogMessageBox
//
// MessageText:
//
//  Eventlog Service %0
//
#define TITLE_EventlogMessageBox         0x80001777L

//
// MessageId: EVENT_EventlogAbnormalShutdown
//
// MessageText:
//
//  The previous system shutdown at %1 on %2 was unexpected.
//
#define EVENT_EventlogAbnormalShutdown   0x80001778L

//
// MessageId: EVENT_EventLogProductInfo
//
// MessageText:
//
//  Microsoft (R) Windows (R) %1 %2 %3 %4.
//
#define EVENT_EventLogProductInfo        0x80001779L

//
// MessageId: EVENT_ServiceNoEventLog
//
// MessageText:
//
//  The %1 service was unable to set up an event source.
//
#define EVENT_ServiceNoEventLog          0xC000177AL

//
// MessageId: EVENT_ComputerNameChange
//
// MessageText:
//
//  The NetBIOS name and DNS host name of this machine have been changed from %1 to %2.
//
#define EVENT_ComputerNameChange         0xC000177BL

//
// MessageId: EVENT_DNSDomainNameChange
//
// MessageText:
//
//  The DNS domain assigned to this computer has been changed from %1 to %2.
//
#define EVENT_DNSDomainNameChange        0xC000177CL

//
// MessageId: EVENT_EventlogUptime
//
// MessageText:
//
//  The system uptime is %5 seconds.
//
#define EVENT_EventlogUptime             0xC000177DL

//
// System Events 6100 - 6199
//
//
// MessageId: EVENT_UP_DRIVER_ON_MP
//
// MessageText:
//
//  A uniprocessor-specific driver was loaded on a multiprocessor system.  The driver could not load.
//
#define EVENT_UP_DRIVER_ON_MP            0xC00017D4L

//
// Service Controller Events 7000 - 7899
//
//
// MessageId: EVENT_SERVICE_START_FAILED
//
// MessageText:
//
//  The %1 service failed to start due to the following error: %n%2
//
#define EVENT_SERVICE_START_FAILED       0xC0001B58L

//
// MessageId: EVENT_SERVICE_START_FAILED_II
//
// MessageText:
//
//  The %1 service depends on the %2 service which failed to start because of the following error: %n%3
//
#define EVENT_SERVICE_START_FAILED_II    0xC0001B59L

//
// MessageId: EVENT_SERVICE_START_FAILED_GROUP
//
// MessageText:
//
//  The %1 service depends on the %2 group and no member of this group started.
//
#define EVENT_SERVICE_START_FAILED_GROUP 0xC0001B5AL

//
// MessageId: EVENT_SERVICE_START_FAILED_NONE
//
// MessageText:
//
//  The %1 service depends on the following nonexistent service: %2
//
#define EVENT_SERVICE_START_FAILED_NONE  0xC0001B5BL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED
//
// MessageText:
//
//  The %1 call failed with the following error: %n%2
//
#define EVENT_CALL_TO_FUNCTION_FAILED    0xC0001B5DL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED_II
//
// MessageText:
//
//  The %1 call failed for %2 with the following error: %n%3
//
#define EVENT_CALL_TO_FUNCTION_FAILED_II 0xC0001B5EL

//
// MessageId: EVENT_REVERTED_TO_LASTKNOWNGOOD
//
// MessageText:
//
//  The system reverted to its last known good configuration.  The system is restarting....
//
#define EVENT_REVERTED_TO_LASTKNOWNGOOD  0xC0001B5FL

//
// MessageId: EVENT_BAD_ACCOUNT_NAME
//
// MessageText:
//
//  No backslash is in the account name.
//
#define EVENT_BAD_ACCOUNT_NAME           0xC0001B60L

//
// MessageId: EVENT_CONNECTION_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for the %2 service to connect.
//
#define EVENT_CONNECTION_TIMEOUT         0xC0001B61L

//
// MessageId: EVENT_READFILE_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for ReadFile.
//
#define EVENT_READFILE_TIMEOUT           0xC0001B62L

//
// MessageId: EVENT_TRANSACT_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for a transaction response from the %2 service.
//
#define EVENT_TRANSACT_TIMEOUT           0xC0001B63L

//
// MessageId: EVENT_TRANSACT_INVALID
//
// MessageText:
//
//  Message returned in transaction has incorrect size.
//
#define EVENT_TRANSACT_INVALID           0xC0001B64L

//
// MessageId: EVENT_FIRST_LOGON_FAILED
//
// MessageText:
//
//  Logon attempt with current password failed with the following error: %n%1
//
#define EVENT_FIRST_LOGON_FAILED         0xC0001B65L

//
// MessageId: EVENT_SECOND_LOGON_FAILED
//
// MessageText:
//
//  Second logon attempt with old password also failed with the following error: %n%1
//
#define EVENT_SECOND_LOGON_FAILED        0xC0001B66L

//
// MessageId: EVENT_INVALID_DRIVER_DEPENDENCY
//
// MessageText:
//
//  Boot-start or system-start driver (%1) must not depend on a service.
//
#define EVENT_INVALID_DRIVER_DEPENDENCY  0xC0001B67L

//
// MessageId: EVENT_BAD_SERVICE_STATE
//
// MessageText:
//
//  The %1 service has reported an invalid current state %2.
//
#define EVENT_BAD_SERVICE_STATE          0xC0001B68L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_DEMAND
//
// MessageText:
//
//  Detected circular dependencies demand starting %1.
//
#define EVENT_CIRCULAR_DEPENDENCY_DEMAND 0xC0001B69L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_AUTO
//
// MessageText:
//
//  Detected circular dependencies auto-starting services.
//
#define EVENT_CIRCULAR_DEPENDENCY_AUTO   0xC0001B6AL

//
// MessageId: EVENT_DEPEND_ON_LATER_SERVICE
//
// MessageText:
//
//  Circular dependency: The %1 service depends on a service in a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_SERVICE    0xC0001B6BL

//
// MessageId: EVENT_DEPEND_ON_LATER_GROUP
//
// MessageText:
//
//  Circular dependency: The %1 service depends on a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_GROUP      0xC0001B6CL

//
// MessageId: EVENT_SEVERE_SERVICE_FAILED
//
// MessageText:
//
//  About to revert to the last known good configuration because the %1 service failed to start.
//
#define EVENT_SEVERE_SERVICE_FAILED      0xC0001B6DL

//
// MessageId: EVENT_SERVICE_START_HUNG
//
// MessageText:
//
//  The %1 service hung on starting.
//
#define EVENT_SERVICE_START_HUNG         0xC0001B6EL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED
//
// MessageText:
//
//  The %1 service terminated with the following error: %n%2
//
#define EVENT_SERVICE_EXIT_FAILED        0xC0001B6FL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED_SPECIFIC
//
// MessageText:
//
//  The %1 service terminated with service-specific error %2.
//
#define EVENT_SERVICE_EXIT_FAILED_SPECIFIC 0xC0001B70L

//
// MessageId: EVENT_SERVICE_START_AT_BOOT_FAILED
//
// MessageText:
//
//  At least one service or driver failed during system startup.  Use Event Viewer to examine the event log for details.
//
#define EVENT_SERVICE_START_AT_BOOT_FAILED 0xC0001B71L

//
// MessageId: EVENT_BOOT_SYSTEM_DRIVERS_FAILED
//
// MessageText:
//
//  The following boot-start or system-start driver(s) failed to load: %1
//
#define EVENT_BOOT_SYSTEM_DRIVERS_FAILED 0xC0001B72L

//
// MessageId: EVENT_RUNNING_LASTKNOWNGOOD
//
// MessageText:
//
//  Windows 2000 could not be started as configured.  A previous working configuration was used instead.
//
#define EVENT_RUNNING_LASTKNOWNGOOD      0xC0001B73L

//
// MessageId: EVENT_TAKE_OWNERSHIP
//
// MessageText:
//
//  The %1 Registry key denied access to SYSTEM account programs so the Service Control Manager took ownership of the Registry key.
//
#define EVENT_TAKE_OWNERSHIP             0xC0001B74L

//
// This Text is used as a title for the message box used to display
// MessageId 7027.  It is not an event or error message.
//
//
// MessageId: TITLE_SC_MESSAGE_BOX
//
// MessageText:
//
//  Service Control Manager %0
//
#define TITLE_SC_MESSAGE_BOX             0xC0001B75L

//
// MessageId: EVENT_SERVICE_NOT_INTERACTIVE
//
// MessageText:
//
//  The %1 service is marked as an interactive service.  However, the system is configured to not allow interactive services.  This service may not function properly.
//
#define EVENT_SERVICE_NOT_INTERACTIVE    0xC0001B76L

//
// Parameter %4 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %5.
//
//
// MessageId: EVENT_SERVICE_CRASH
//
// MessageText:
//
//  The %1 service terminated unexpectedly.  It has done this %2 time(s).  The following corrective action will be taken in %3 milliseconds: %5.
//
#define EVENT_SERVICE_CRASH              0xC0001B77L

//
// Parameter %1 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %2.
//
//
// MessageId: EVENT_SERVICE_RECOVERY_FAILED
//
// MessageText:
//
//  The Service Control Manager tried to take a corrective action (%2) after the unexpected termination of the %3 service, but this action failed with the following error: %n%4
//
#define EVENT_SERVICE_RECOVERY_FAILED    0xC0001B78L

//
// MessageId: EVENT_SERVICE_SCESRV_FAILED
//
// MessageText:
//
//  The Service Control Manager did not initialize successfully. The security
//  configuration server (scesrv.dll) failed to initialize with error %1.  The
//  system is restarting...
//
#define EVENT_SERVICE_SCESRV_FAILED      0xC0001B79L

//
// MessageId: EVENT_SERVICE_CRASH_NO_ACTION
//
// MessageText:
//
//  The %1 service terminated unexpectedly.  It has done this %2 time(s).
//
#define EVENT_SERVICE_CRASH_NO_ACTION    0xC0001B7AL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_CONTROL_SUCCESS
//
// MessageText:
//
//  The %1 service was successfully sent a %2 control.
//
#define EVENT_SERVICE_CONTROL_SUCCESS    0x40001B7BL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_STATUS_SUCCESS
//
// MessageText:
//
//  The %1 service entered the %2 state.
//
#define EVENT_SERVICE_STATUS_SUCCESS     0x40001B7CL

//
// MessageId: EVENT_SERVICE_CONFIG_BACKOUT_FAILED
//
// MessageText:
//
//  The Service Control Manager encountered an error undoing a configuration change
//  to the %1 service.  The service's %2 is currently in an unpredictable state.
//  
//  If you do not correct this configuration, you may not be able to restart the %1
//  service or may encounter other errors.  To ensure that the service is configured
//  properly, use the Services snap-in in Microsoft Management Console (MMC).
//
#define EVENT_SERVICE_CONFIG_BACKOUT_FAILED 0xC0001B7DL

//
// MessageId: EVENT_FIRST_LOGON_FAILED_II
//
// MessageText:
//
//  The %1 service was unable to log on as %2 with the currently configured
//  password due to the following error: %n%3%n%nTo ensure that the service is
//  configured properly, use the Services snap-in in Microsoft Management
//  Console (MMC).
//
#define EVENT_FIRST_LOGON_FAILED_II      0xC0001B7EL

//
// Schedule (AT command) Service Events 7900 - 7999
//
//
// MessageId: EVENT_COMMAND_NOT_INTERACTIVE
//
// MessageText:
//
//  The %1 command is marked as an interactive command.  However, the system is
//  configured to not allow interactive command execution.  This command may not
//  function properly.
//
#define EVENT_COMMAND_NOT_INTERACTIVE    0xC0001EDCL

//
// MessageId: EVENT_COMMAND_START_FAILED
//
// MessageText:
//
//  The %1 command failed to start due to the following error: %n%2
//
#define EVENT_COMMAND_START_FAILED       0xC0001EDDL


/////////////////////////////////////////////////////////////////////////
//
// Lanman Bowser/Browser Events (8000-8499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_BOWSER_OTHER_MASTER_ON_NET
//
// MessageText:
//
//  The master browser has received a server announcement from the computer %2
//  that believes that it is the master browser for the domain on transport %3.
//  The master browser is stopping or an election is being forced.
//
#define EVENT_BOWSER_OTHER_MASTER_ON_NET 0xC0001F43L

//
// MessageId: EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER
//
// MessageText:
//
//  A request has been submitted to promote the computer to backup when it is already a
//  master browser.
//
#define EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER 0x80001F44L

//
// MessageId: EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE
//
// MessageText:
//
//  The browser has received a server announcement indicating that the computer %2
//  is a master browser, but this computer is not a master browser.
//
#define EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE 0x80001F45L

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM
//
// MessageText:
//
//  The browser has received an illegal datagram from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM    0x80001F46L

//
// MessageId: EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED
//
// MessageText:
//
//  The browser was unable to update the service status bits.  The data is the error.
//
#define EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED 0xC0001F47L

//
// MessageId: EVENT_BROWSER_ROLE_CHANGE_FAILED
//
// MessageText:
//
//  The browser was unable to update its role.  The data is the error.
//
#define EVENT_BROWSER_ROLE_CHANGE_FAILED 0xC0001F48L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The computer that currently
//  believes it is the master browser is %1.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED 0xC0001F49L

//
// MessageId: EVENT_BOWSER_NAME_CONVERSION_FAILED
//
// MessageText:
//
//  The browser driver was unable to convert a character string to a unicode string.
//
#define EVENT_BOWSER_NAME_CONVERSION_FAILED 0xC0001F4AL

//
// MessageId: EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED
//
// MessageText:
//
//  The browser was unable to add the configuration parameter %1.
//
#define EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED 0xC0001F4BL

//
// MessageId: EVENT_BOWSER_ELECTION_RECEIVED
//
// MessageText:
//
//  The browser driver has received an election packet from computer %2 on network %3.  The data is the packet received.
//
#define EVENT_BOWSER_ELECTION_RECEIVED   0x00001F4CL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED
//
// MessageText:
//
//  The browser driver has forced an election on network %2 because it was unable to find a master browser to retrieve a backup list on that network.
//
#define EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED 0x40001F4DL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED
//
// MessageText:
//
//  The browser driver has forced an election on network %2 because it was unable to find a master browser for that network.
//
#define EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED 0x40001F4EL

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED
//
// MessageText:
//
//  The browser has forced an election on network %1 because a Windows 2000 Server (or domain master) browser is started.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED 0x40001F4FL

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD
//
// MessageText:
//
//  The browser driver has received too many illegal datagrams from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
//  No more events will be generated until the reset frequency has expired.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD 0xC0001F50L

//
// MessageId: EVENT_BROWSER_DEPENDANT_SERVICE_FAILED
//
// MessageText:
//
//  The browser has failed to start because the dependent service %1 had invalid service status %2.
//  Status             Meaning
//    1              Service Stopped%n
//    2              Start Pending%n
//    3              Stop Pending%n
//    4              Running%n
//    5              Continue Pending%n
//    6              Pause Pending%n
//    7              Paused%n
//
#define EVENT_BROWSER_DEPENDANT_SERVICE_FAILED 0xC0001F51L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The browser will continue
//  to attempt to promote itself to the master browser, but will no longer log any events in the event log in Event Viewer.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING 0xC0001F53L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The computer that currently
//  believes it is the master browser is unknown.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER 0xC0001F54L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_FAILED
//
// MessageText:
//
//  The browser service was unable to retrieve a list of servers from the browser master %1 on the network %2.%n
//  %n
//  Browser master: %1%n
//  Network: %2%n
//  %n
//  This event may be caused by a temporary loss of network connectivity. If this message appears again, verify that the server is still connected to the network. The return code is in the Data text box. 
//
#define EVENT_BROWSER_SERVER_LIST_FAILED 0x80001F55L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_FAILED
//
// MessageText:
//
//  The browser service was unable to retrieve a list of domains from the browser master %1 on the network %2.%n
//  %n
//  Browser master: %1%n
//  Network: %2%n
//  %n
//  This event may be caused by a temporary loss of network connectivity. If this message appears again, verify that the server is still connected to the network. The return code is in the Data text box. 
//
#define EVENT_BROWSER_DOMAIN_LIST_FAILED 0x80001F56L

//
// MessageId: EVENT_BROWSER_ILLEGAL_CONFIG
//
// MessageText:
//
//  The value for the parameter %1 to the browser service was illegal.
//
#define EVENT_BROWSER_ILLEGAL_CONFIG     0x80001F57L

//
// MessageId: EVENT_BOWSER_OLD_BACKUP_FOUND
//
// MessageText:
//
//  The backup browser server %2 is out-of-date.  Consider upgrading this computer.
//
#define EVENT_BOWSER_OLD_BACKUP_FOUND    0x40001F58L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_RETRIEVED
//
// MessageText:
//
//  The browser has retrieved a list of servers from remote computer %1 on transport %2.%n
//  There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_SERVER_LIST_RETRIEVED 0x00001F59L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_RETRIEVED
//
// MessageText:
//
//  The browser has retrieved a list of domains from remote computer %1 on transport %2.%n
//  There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_DOMAIN_LIST_RETRIEVED 0x00001F5AL

//
// MessageId: EVENT_BOWSER_PDC_LOST_ELECTION
//
// MessageText:
//
//  The browser running on the Domain Controller has lost an election.  The computer that won the election is %2, on the transport %3.%n
//  The data contains the election version, election criteria, and remote computer time up, and the same information for
//  the current computer.
//
#define EVENT_BOWSER_PDC_LOST_ELECTION   0x40001F5BL

//
// MessageId: EVENT_BOWSER_NON_PDC_WON_ELECTION
//
// MessageText:
//
//  The browser running on this computer has won a browser election on network %2.
//  This computer is a member of a domain, so the Domain Controller should become the master
//  browser.
//
#define EVENT_BOWSER_NON_PDC_WON_ELECTION 0x40001F5CL

//
// MessageId: EVENT_BOWSER_CANT_READ_REGISTRY
//
// MessageText:
//
//  The browser driver was unable to initialize variables from the Registry.
//
#define EVENT_BOWSER_CANT_READ_REGISTRY  0x40001F5DL

//
// MessageId: EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED
//
// MessageText:
//
//  The browser driver has discarded too many mailslot messages.
//
#define EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED 0x40001F5EL

//
// MessageId: EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED
//
// MessageText:
//
//  The browser driver has discarded too many GetBrowserServerList requests.
//
#define EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED 0x40001F5FL

//
// MessageId: EVENT_BROWSER_BACKUP_STOPPED
//
// MessageText:
//
//  The browser service has failed to retrieve the backup list too many times on transport %1.
//  The backup browser is stopping.
//
#define EVENT_BROWSER_BACKUP_STOPPED     0xC0001F60L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED
//
// MessageText:
//
//  The browser has forced an election on network %1 because a master browser was stopped.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED 0x40001F61L

//
// MessageId: EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER
//
// MessageText:
//
//  The browser has received a GetBrowserServerList request when it is not the master browser.
//
#define EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER 0xC0001F62L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED
//
// MessageText:
//
//  The browser has forced an election on network %1 because the Domain Controller (or Server) has changed its role.
//
#define EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED 0x40001F63L

//
// MessageId: EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH
//
// MessageText:
//
//  The browser has failed to start because of an error in the DirectHostBinding parameter to the browser.
//
#define EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH 0xC0001F64L


/////////////////////////////////////////////////////////////////////////
//
// Sap Agent Events (8500-8999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: NWSAP_EVENT_KEY_NOT_FOUND
//
// MessageText:
//
//  The Registry Key %1 was not present.  The Sap Agent could not start.
//
#define NWSAP_EVENT_KEY_NOT_FOUND        0xC0002134L

//
// MessageId: NWSAP_EVENT_WSASTARTUP_FAILED
//
// MessageText:
//
//  Winsock startup routine failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WSASTARTUP_FAILED    0xC0002135L

//
// MessageId: NWSAP_EVENT_SOCKET_FAILED
//
// MessageText:
//
//  Socket create call failed for main socket. The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SOCKET_FAILED        0xC0002136L

//
// MessageId: NWSAP_EVENT_SETOPTBCAST_FAILED
//
// MessageText:
//
//  Setting broadcast option on socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SETOPTBCAST_FAILED   0xC0002137L

//
// MessageId: NWSAP_EVENT_BIND_FAILED
//
// MessageText:
//
//  Binding to SAP Socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BIND_FAILED          0xC0002138L

//
// MessageId: NWSAP_EVENT_GETSOCKNAME_FAILED
//
// MessageText:
//
//  Getting bound address of socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_GETSOCKNAME_FAILED   0xC0002139L

//
// MessageId: NWSAP_EVENT_OPTEXTENDEDADDR_FAILED
//
// MessageText:
//
//  Setting option EXTENDED_ADDRESS failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTEXTENDEDADDR_FAILED 0xC000213AL

//
// MessageId: NWSAP_EVENT_OPTBCASTINADDR_FAILED
//
// MessageText:
//
//  Setting NWLink option BCASTINTADDR failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTBCASTINADDR_FAILED 0xC000213BL

//
// MessageId: NWSAP_EVENT_CARDMALLOC_FAILED
//
// MessageText:
//
//  Error allocating memory to hold a card structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDMALLOC_FAILED    0xC000213CL

//
// MessageId: NWSAP_EVENT_NOCARDS
//
// MessageText:
//
//  Enumeration of cards returned 0 cards.
//
#define NWSAP_EVENT_NOCARDS              0xC000213DL

//
// MessageId: NWSAP_EVENT_THREADEVENT_FAIL
//
// MessageText:
//
//  Error creating thread counting event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_THREADEVENT_FAIL     0xC000213EL

//
// MessageId: NWSAP_EVENT_RECVSEM_FAIL
//
// MessageText:
//
//  Error creating receive semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_RECVSEM_FAIL         0xC000213FL

//
// MessageId: NWSAP_EVENT_SENDEVENT_FAIL
//
// MessageText:
//
//  Error creating send event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SENDEVENT_FAIL       0xC0002140L

//
// MessageId: NWSAP_EVENT_STARTRECEIVE_ERROR
//
// MessageText:
//
//  Error starting receive thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTRECEIVE_ERROR   0xC0002141L

//
// MessageId: NWSAP_EVENT_STARTWORKER_ERROR
//
// MessageText:
//
//  Error starting worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWORKER_ERROR    0xC0002142L

//
// MessageId: NWSAP_EVENT_TABLE_MALLOC_FAILED
//
// MessageText:
//
//  Error allocating database array.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_TABLE_MALLOC_FAILED  0xC0002143L

//
// MessageId: NWSAP_EVENT_HASHTABLE_MALLOC_FAILED
//
// MessageText:
//
//  Error allocating hash table.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_HASHTABLE_MALLOC_FAILED 0xC0002144L

//
// MessageId: NWSAP_EVENT_STARTLPCWORKER_ERROR
//
// MessageText:
//
//  Error starting LPC worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTLPCWORKER_ERROR 0xC0002145L

//
// MessageId: NWSAP_EVENT_CREATELPCPORT_ERROR
//
// MessageText:
//
//  Error creating the LPC port.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCPORT_ERROR  0xC0002146L

//
// MessageId: NWSAP_EVENT_CREATELPCEVENT_ERROR
//
// MessageText:
//
//  Error creating the LPC thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCEVENT_ERROR 0xC0002147L

//
// MessageId: NWSAP_EVENT_LPCLISTENMEMORY_ERROR
//
// MessageText:
//
//  Error allocating memory for an LPC Client structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCLISTENMEMORY_ERROR 0xC0002148L

//
// MessageId: NWSAP_EVENT_LPCHANDLEMEMORY_ERROR
//
// MessageText:
//
//  Error allocating buffer to hold LPC worker thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCHANDLEMEMORY_ERROR 0xC0002149L

//
// MessageId: NWSAP_EVENT_BADWANFILTER_VALUE
//
// MessageText:
//
//  The value for WANFilter in the registry must be 0-2.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BADWANFILTER_VALUE   0xC000214AL

//
// MessageId: NWSAP_EVENT_CARDLISTEVENT_FAIL
//
// MessageText:
//
//  Error creating event for card list access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDLISTEVENT_FAIL   0xC000214BL

//
// MessageId: NWSAP_EVENT_SDMDEVENT_FAIL
//
// MessageText:
//
//  Error creating event for database access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SDMDEVENT_FAIL       0xC000214CL

//
// MessageId: NWSAP_EVENT_INVALID_FILTERNAME
//
// MessageText:
//
//  Name too long in key %1: Name = %s.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_INVALID_FILTERNAME   0x8000214DL

//
// MessageId: NWSAP_EVENT_WANSEM_FAIL
//
// MessageText:
//
//  Error creating WAN control semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSEM_FAIL          0xC000214EL

//
// MessageId: NWSAP_EVENT_WANSOCKET_FAILED
//
// MessageText:
//
//  Socket create call failed for WAN socket.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSOCKET_FAILED     0xC000214FL

//
// MessageId: NWSAP_EVENT_WANBIND_FAILED
//
// MessageText:
//
//  Binding to WAN socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANBIND_FAILED       0xC0002150L

//
// MessageId: NWSAP_EVENT_STARTWANWORKER_ERROR
//
// MessageText:
//
//  Error starting WAN worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANWORKER_ERROR 0xC0002151L

//
// MessageId: NWSAP_EVENT_STARTWANCHECK_ERROR
//
// MessageText:
//
//  Error starting WAN check thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANCHECK_ERROR  0xC0002152L

//
// MessageId: NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR
//
// MessageText:
//
//  Error on getsockopt IPX_MAX_ADAPTER_NUM.  Data is the error code.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR 0xC0002153L

//
// MessageId: NWSAP_EVENT_WANHANDLEMEMORY_ERROR
//
// MessageText:
//
//  Error allocating buffer to hold WAN notify thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANHANDLEMEMORY_ERROR 0xC0002154L

//
// MessageId: NWSAP_EVENT_WANEVENT_ERROR
//
// MessageText:
//
//  Error creating the WAN thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANEVENT_ERROR       0xC0002155L


/////////////////////////////////////////////////////////////////////////
//
// Transport Events (9000-9499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TRANSPORT_RESOURCE_POOL
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to system resource problems.
//
#define EVENT_TRANSPORT_RESOURCE_POOL    0x80002329L

//
// MessageId: EVENT_TRANSPORT_RESOURCE_LIMIT
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to its configured size of %4.
//
#define EVENT_TRANSPORT_RESOURCE_LIMIT   0x8000232AL

//
// MessageId: EVENT_TRANSPORT_RESOURCE_SPECIFIC
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to a specifically configured limit of %4.
//
#define EVENT_TRANSPORT_RESOURCE_SPECIFIC 0x8000232BL

//
// MessageId: EVENT_TRANSPORT_REGISTER_FAILED
//
// MessageText:
//
//  %2 failed to register itself with the NDIS wrapper.
//
#define EVENT_TRANSPORT_REGISTER_FAILED  0xC000232CL

//
// MessageId: EVENT_TRANSPORT_BINDING_FAILED
//
// MessageText:
//
//  %2 failed to bind to adapter %3.
//
#define EVENT_TRANSPORT_BINDING_FAILED   0xC000232DL

//
// MessageId: EVENT_TRANSPORT_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  %2 could not find adapter %3.
//
#define EVENT_TRANSPORT_ADAPTER_NOT_FOUND 0xC000232EL

//
// MessageId: EVENT_TRANSPORT_SET_OID_FAILED
//
// MessageText:
//
//  %2 failed while setting OID %3 on adapter %4.
//
#define EVENT_TRANSPORT_SET_OID_FAILED   0xC000232FL

//
// MessageId: EVENT_TRANSPORT_QUERY_OID_FAILED
//
// MessageText:
//
//  %2 failed while querying OID %3 on adapter %4.
//
#define EVENT_TRANSPORT_QUERY_OID_FAILED 0xC0002330L

//
// MessageId: EVENT_TRANSPORT_TRANSFER_DATA
//
// MessageText:
//
//  %2 could not transfer a packet from the adapter.  The packet was dropped.
//
#define EVENT_TRANSPORT_TRANSFER_DATA    0x40002331L

//
// MessageId: EVENT_TRANSPORT_TOO_MANY_LINKS
//
// MessageText:
//
//  %2 could not create a link to a remote computer.  Your computer has exceeded the number of connections it can make to that remote computer.
//
#define EVENT_TRANSPORT_TOO_MANY_LINKS   0x40002332L

//
// MessageId: EVENT_TRANSPORT_BAD_PROTOCOL
//
// MessageText:
//
//  %2 received an unexpected %3 packet from a remote computer.
//
#define EVENT_TRANSPORT_BAD_PROTOCOL     0x40002333L


/////////////////////////////////////////////////////////////////////////
//
// IPX/SPX Events (9500-9999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_IPX_NEW_DEFAULT_TYPE
//
// MessageText:
//
//  The default frame type for auto-detection on %2 was changed to %3.
//  This type is now the default if no frame type can be detected.
//
#define EVENT_IPX_NEW_DEFAULT_TYPE       0x4000251DL

//
// MessageId: EVENT_IPX_SAP_ANNOUNCE
//
// MessageText:
//
//  A SAP announcement was sent over %2 which is configured for multiple
//  networks, but no internal network is configured. This may prevent
//  machines on some networks from locating the advertised service.
//
#define EVENT_IPX_SAP_ANNOUNCE           0x8000251EL

//
// MessageId: EVENT_IPX_ILLEGAL_CONFIG
//
// MessageText:
//
//  The value for the %2 parameter %3 was illegal.
//
#define EVENT_IPX_ILLEGAL_CONFIG         0x8000251FL

//
// MessageId: EVENT_IPX_INTERNAL_NET_INVALID
//
// MessageText:
//
//  %2 was configured with an internal network number of %3. This network
//  number conflicts with one of the attached networks. The configured
//  internal network number will be ignored.
//
#define EVENT_IPX_INTERNAL_NET_INVALID   0xC0002520L

//
// MessageId: EVENT_IPX_NO_FRAME_TYPES
//
// MessageText:
//
//  %2 had no frame types configured for the binding to adapter %3.
//
#define EVENT_IPX_NO_FRAME_TYPES         0xC0002521L

//
// MessageId: EVENT_IPX_CREATE_DEVICE
//
// MessageText:
//
//  %2 failed to initialize because the driver device could not be created.
//
#define EVENT_IPX_CREATE_DEVICE          0xC0002522L

//
// MessageId: EVENT_IPX_NO_ADAPTERS
//
// MessageText:
//
//  %2 could not bind to any adapters. The transport could not start.
//
#define EVENT_IPX_NO_ADAPTERS            0xC0002523L


/////////////////////////////////////////////////////////////////////////
//
// DCOM Events (10000-10999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RPCSS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  Unable to start a DCOM Server: %3.
//  The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_CREATEPROCESS_FAILURE 0xC0002710L

//
// MessageId: EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  Unable to start a DCOM Server: %3 as %4/%5.
//  The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE 0xC0002711L

//
// MessageId: EVENT_RPCSS_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
//  Access denied attempting to launch a DCOM Server.
//  The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_LAUNCH_ACCESS_DENIED 0xC0002712L

//
// MessageId: EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
//  Access denied attempting to launch a DCOM Server using DefaultLaunchPermssion.
//  The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED 0xC0002713L

//
// MessageId: EVENT_RPCSS_RUNAS_CANT_LOGIN
//
// MessageText:
//
//  DCOM got error "%%%1" and was unable to logon %2\%3
//  in order to run the server:%n%4
//
#define EVENT_RPCSS_RUNAS_CANT_LOGIN     0xC0002714L

//
// MessageId: EVENT_RPCSS_START_SERVICE_FAILURE
//
// MessageText:
//
//  DCOM got error "%%%1" attempting to start the service %2 with arguments "%3"
//  in order to run the server:%n%4
//
#define EVENT_RPCSS_START_SERVICE_FAILURE 0xC0002715L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR
//
// MessageText:
//
//  DCOM got error "%%%1" from the computer %2 when attempting to
//  activate the server:%n%3
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR    0xC0002716L

//
// MessageId: EVENT_RPCSS_ACTIVATION_ERROR
//
// MessageText:
//
//  DCOM got error "%%%1" when attempting to
//  activate the server:%n%2
//
#define EVENT_RPCSS_ACTIVATION_ERROR     0xC0002717L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE
//
// MessageText:
//
//  DCOM got error "%%%1" from the computer %2 when attempting to
//  the server:%n%3 with file %4.
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE 0xC0002718L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE
//
// MessageText:
//
//  DCOM was unable to communicate with the computer %1 using any of the configured
//  protocols.
//
#define EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE 0xC0002719L

//
// MessageId: EVENT_RPCSS_SERVER_START_TIMEOUT
//
// MessageText:
//
//  The server %1 did not register with DCOM within the required timeout.
//
#define EVENT_RPCSS_SERVER_START_TIMEOUT 0xC000271AL

//
// MessageId: EVENT_RPCSS_SERVER_NOT_RESPONDING
//
// MessageText:
//
//  The server %1 could not be contacted to establish the connection to the client
//
#define EVENT_RPCSS_SERVER_NOT_RESPONDING 0xC000271BL

//
// MessageId: EVENT_DCOM_ASSERTION_FAILURE
//
// MessageText:
//
//  There is an assertion failure in DCOM.  Context follows:
//  %1
//  %2
//  %3
//
#define EVENT_DCOM_ASSERTION_FAILURE     0xC000271CL

//
// MessageId: EVENT_DCOM_INVALID_ENDPOINT_DATA
//
// MessageText:
//
//  DCOM server attempted to listen on an invalid endpoint.
//  Protseq:  %1
//  Endpoint: %2
//  Flags:    %3
//
#define EVENT_DCOM_INVALID_ENDPOINT_DATA 0xC000271DL


/////////////////////////////////////////////////////////////////////////
//
// DNS Caching Resolvers Service and DNS API Events (11000-11999)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DLL
//
// MessageText:
//
//  Unable to start DNS Client Service.
//  Failed to load DLL %2, Error: %1.
//  Please reinstall this DLL from installation CD.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DLL 0xC0002AF8L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY
//
// MessageText:
//
//  Unable to start DNS Client service. Can not find entry %3 in DLL %2.
//  Please reinstall this DLL from installation CD. For specific error
//  code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY 0xC0002AF9L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL
//
// MessageText:
//
//  Unable to start the DNS Client service. The system could not register a
//  service control handler and could be out of resources. Close any
//  applications not in use or reboot the computer. For specific error
//  code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL 0xC0002AFAL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT
//
// MessageText:
//
//  Unable to start DNS Client service. The system could
//  not create a termination event for this service and
//  could be out of resources. Close any applications not
//  in use or reboot the computer. For specific error code,
//  see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT 0xC0002AFBL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_RPC
//
// MessageText:
//
//  Unable to start DNS Client service. Could not start the
//  Remote Procedure Call (RPC) interface for this service.
//  To correct the problem, you may restart the RPC and DNS
//  Client services. To do so, use the following commands at a command
//  prompt: (1) type "net start rpc" to start the RPC service, and (2)
//  type "net start dnscache" to start the DNS Client service. For
//  specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_RPC 0xC0002AFCL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY
//
// MessageText:
//
//  Unable to start DNS Client service. The system could not register
//  shutdown notification for this service and could be out of resources.
//  Try closing any applications not in use or reboot the computer.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY 0xC0002AFDL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE
//
// MessageText:
//
//  Unable to start DNS Client service. Could not update status with
//  Service Control Manager. To correct the problem, you may restart
//  the RPC and DNS Client services. To do so, use the following commands
//  at a command prompt: (1) type "net start rpc" to start the RPC service,
//  and (2) type "net start dnscache" to start the DNS Client service. For
//  specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE 0xC0002AFEL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY
//
// MessageText:
//
//  Unable to start DNS Client service because the system failed to allocate
//  memory and may be out of available memory. Try closing any applications not
//  in use or reboot the computer. For specific error code, see the record data
//  displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY 0xC0002AFFL


//
// Warnings
//

//
// MessageId: EVENT_DNS_CACHE_NETWORK_PERF_WARNING
//
// MessageText:
//
//  The DNS Client service could not contact any DNS servers for
//  a repeated number of attempts. For the next %3 seconds the
//  DNS Client service will not use the network to avoid further
//  network performance problems. It will resume its normal behavior
//  after that. If this problem persists, verify your TCP/IP
//  configuration, specifically check that you have a preferred
//  (and possibly an alternate) DNS server configured. If the problem
//  continues, verify network conditions to these DNS servers or contact
//  your network administrator.
//
#define EVENT_DNS_CACHE_NETWORK_PERF_WARNING 0x80002B2AL

//
// MessageId: EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING
//
// MessageText:
//
//  The DNS Client service failed to reach DNS server at address %1. It will
//  not use this DNS server for %2 seconds.
//
#define EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING 0x80002B2BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS Server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The cause of this DNS registration failure was because the DNS update
//  request timed out after being sent to the specified DNS Server. This is
//  probably because the authoritative DNS server for the name being updated
//  is not running.%n%n You can manually retry registration of the network
//  adapter and its settings by typing "ipconfig /registerdns" at the command
//  prompt. If problems still  persist, contact your network systems
//  administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT 0x80002B8EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The cause of this DNS registration failure was because of DNS server failure.
//  This may be due to a zone transfer that has locked the DNS server for the
//  applicable zone that your computer needs to register itself with.%n%n
//  (The applicable zone should typically correspond to the Adapter-specific
//  Domain Suffix that was indicated above.) You can manually retry registration
//  of the network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your network
//  systems administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL 0x80002B8FL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason it could not register was because either: (a) the DNS server
//  does not support the DNS dynamic update protocol, or (b) the primary zone
//  authoritative for the registering names does not currently accept dynamic
//  updates.%n%n To add or register a DNS host (A) resource record using the
//  specific DNS name for this adapter, contact your DNS server or network
//  systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP 0x80002B90L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason it could not register was because the DNS server refused the
//  dynamic update request. This could happen for the following reasons:
//  (a) current DNS update policies do not allow this computer to update
//  the DNS domain name configured for this adapter, or (b) the authoritative
//  DNS server for this DNS domain name does not support the DNS dynamic update
//  protocol.%n%n
//  To register a DNS host (A) resource record using the specific DNS domain
//  name for this adapter, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED 0x80002B91L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not register the DNS update request because of a
//  security related problem. This could happen for the following reasons:
//  (a) the DNS domain name that your computer is trying to register could
//  not be updated because your computer does not have the right permissions,
//  or (b) there might have been a problem negotiating valid credentials
//  with the DNS server to update.%n%n
//  You can manually retry DNS registration of the network adapter and its
//  settings by typing "ipconfig /registerdns" at the command prompt. If
//  problems still persist, contact your DNS server or network systems
//  administrator. For specific error code information, see the record data
//  displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY 0x80002B92L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the DNS update request could not be completed was because
//  of a system problem. You can manually retry DNS registration of the
//  network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your DNS
//  server or network systems administrator. For specific error code
//  information, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER 0x80002B93L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because the
//  update request that was sent to the specified DNS server timed out. This
//  is probably because the authoritative DNS server for the name being
//  registered is not running.%n%n You can manually retry DNS registration
//  of the network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your DNS
//  server or network systems administrator. For specific error code
//  information, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT 0x80002B94L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  of DNS server failure. This may be due to a zone transfer lock on
//  the DNS server for the zone that your computer needs to update.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator. For specific error code information, see the record data
//  displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL 0x80002B95L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  (a) either the DNS server does not support the DNS dynamic update
//  protocol, or (b) the authoritative zone where these records are to
//  be registered does not allow dynamic updates.%n%n
//  To register DNS pointer (PTR) resource records using the specific
//  DNS domain name and IP addresses for this adapter, contact your
//  DNS server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP 0x80002B96L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  the DNS server refused the update request. The cause of this could
//  be (a) your computer is not allowed to update the adapter-specified DNS
//  domain name, or (b) because the DNS server authoritative for the specified
//  name does not support the DNS dynamic update protocol.%n%n
//  To register the DNS pointer (PTR) resource records using the specific
//  DNS domain name and IP addresses for this adapter, contact your DNS
//  server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED 0x80002B97L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  of a security related problem. The cause of this could be (a) your
//  computer does not have permissions to register and update the specific
//  DNS domain name set for this adapter, or (b) there might have been a
//  problem negotiating valid credentials with the DNS server during the
//  processing of the update request.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY 0x80002B98L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason the system could not register these RRs during the
//  update request was because of a system problem. You can manually
//  retry DNS registration of the network adapter and its settings by
//  typing "ipconfig /registerdns" at the command prompt. If problems
//  still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER 0x80002B99L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  update request it sent to the DNS server timed out. The most likely
//  cause of this is that the DNS server authoritative for the name it
//  was attempting to register or update is not running at this time.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002B9AL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  DNS server failed the update request. The most likely cause of this
//  is that the authoritative DNS server required to process this update
//  request has a lock in place on the zone, probably because a zone
//  transfer is in progress.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002B9BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because either
//  (a) the DNS server does not support the DNS dynamic update protocol, or
//  (b) the authoritative zone for the specified DNS domain name does not
//  accept dynamic updates.%n%n
//  To register the DNS host (A) resource records using the specific DNS
//  domain name and IP addresses for this adapter, contact your DNS server
//  or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002B9CL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  DNS server contacted refused the update request. The reasons for this
//  might be (a) you are not allowed to update the specified DNS domain name,
//  or (b) because the DNS server authoritative for this name does not support
//  the DNS dynamic update protocol.%n%n
//  To register the DNS host (A) resource records using the specific DNS
//  domain name and IP addresses for this adapter, contact your DNS server
//  or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002B9DL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because of a
//  security related problem. The cause of this could be (a) your computer
//  does not have permissions to register and update the specific DNS domain
//  name set for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002B9EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs during the
//  update request was because of a system problem. You can manually
//  retry DNS registration of the network adapter and its settings by
//  typing "ipconfig /registerdns" at the command prompt. If problems
//  still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002B9FL


//
// Deregistration update errors
//

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to update and remove registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server it sent the update
//  request to timed out. The most likely cause of this failure is that the
//  DNS server authoritative for the zone where the registration was originally
//  made is either not running or unreachable through the network at this time.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT 0x80002BACL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to update and remove registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server it sent the update
//  to failed the update request. A possible cause of this failure is that
//  the DNS server required to process this update request has a lock in place
//  on the zone, probably because a zone transfer is in progress.%n%n
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BADL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server sent the update
//  either (a) does not support the DNS dynamic update protocol, or (b) the
//  authoritative zone for the specified DNS domain name does not currently
//  accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP 0x80002BAEL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not perform the update request was the
//  DNS server contacted refused update request. The cause of this is
//  (a) this computer is not allowed to update the specified DNS domain
//  name, or (b) because the DNS server authoritative for the zone that
//  requires updating does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED 0x80002BAFL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not perform the update request was because
//  of a security related problem. The cause of this could be (a) your computer
//  does not have permissions to register and update the specific DNS domain
//  name set for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request.%n%n
//  For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY 0x80002BB0L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to update and remove the DNS registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not update to remove this DNS registration because of
//  a system problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER 0x80002BB1L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the update request
//  timed out while awaiting a response from the DNS server. This is probably
//  because the DNS server authoritative for the zone that requires update
//  is not running.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT 0x80002BB2L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the DNS server failed the
//  update request. A possible cause is that a zone transfer is in progress,
//  causing a lock for the zone at the DNS server authorized to perform the
//  updates for these RRs.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BB3L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because either the DNS server
//  does not support the DNS dynamic update protocol or the authoritative zone
//  that contains these RRs does not accept dynamic updates.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP 0x80002BB4L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the DNS server refused the
//  update request. The cause of this might be (a) this computer is not allowed
//  to update the specified DNS domain name specified by these settings, or
//  (b) because the DNS server authorized to perform updates for the zone that
//  contains these RRs does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED 0x80002BB5L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because of a security related
//  problem. The cause of this could be that (a) your computer does not have
//  permissions to remove and update the specific DNS domain name or IP addresses
//  configured for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY 0x80002BB6L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because because of a system
//  problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER 0x80002BB7L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not remove these A RRs because the update request timed
//  out while awaiting a response from the DNS server. This is probably because
//  the DNS server authoritative for the zone where these RRs need to be updated
//  is either not currently running or reachable on the network.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002BB8L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not remove these A RRs because the DNS server failed the
//  update request. A possible cause is that a zone transfer is in progress,
//  causing a lock for the zone at the DNS server authorized to perform the
//  updates for these RRs.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002BB9L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server sent the update
//  either (a) does not support the DNS dynamic update protocol, or (b) the
//  authoritative zone for the DNS domain name specified in these A RRs does
//  not currently accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002BBAL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The request to remove these records failed because the DNS server refused
//  the update request. The cause of this might be that either (a) this
//  computer is not allowed to update the DNS domain name specified by these
//  settings, or (b) because the DNS server authorized to perform updates for
//  the zone that contains these RRs does not support the DNS dynamic update
//  protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002BBBL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure was because of a security related problem.
//  The cause of this could be that (a) your computer does not have permissions
//  to remove and update the specific DNS domain name or IP addresses
//  configured for this adapter, or (b) there might have been a problem
//  negotiating valid credentials with the DNS server during the processing of
//  the update request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002BBCL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the update request failed was because of a system problem.
//  For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002BBDL


//
// Information
//

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER
//
// MessageText:
//
//  The system registered network adapter with settings :%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER  0x40002BC0L

//
// MessageId: EVENT_DNSAPI_REGISTERED_PTR
//
// MessageText:
//
//  The system registered pointer (PTR) resource records (RRs) for network
//  adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    Primary Domain Suffix : %4%n
//    DNS server list :%n
//      %5%n
//    Sent update to server : %6%n
//    IP Address : %7
//
#define EVENT_DNSAPI_REGISTERED_PTR      0x40002BC1L

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN
//
// MessageText:
//
//  The system registered host (A) resource records (RRs) for network
//  adapter%nwith settings :%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN 0x40002BC2L


/////////////////////////////////////////////////////////////////////////
//
// WMI Service Events (12000-12499)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_WMI_CANT_OPEN_DEVICE
//
// MessageText:
//
//  The WMI service was unable to open the WMI service device. The status code is in the additional data.
//
#define EVENT_WMI_CANT_OPEN_DEVICE       0xC0002EE0L


//
// Warnings
//

//
// MessageId: EVENT_WMI_INVALID_MOF
//
// MessageText:
//
//  The binary MOF in the resource named %1 in the image file %2 is not valid.
//
#define EVENT_WMI_INVALID_MOF            0x80002F44L

//
// MessageId: EVENT_WMI_MOF_LOAD_FAILURE
//
// MessageText:
//
//  The binary MOF in the resource named %1 in the image file %2 could not be loaded.
//
#define EVENT_WMI_MOF_LOAD_FAILURE       0x80002F45L

//
// MessageId: EVENT_WMI_INVALID_REGINFO
//
// MessageText:
//
//  The registration information for the image file %1 is not valid.
//
#define EVENT_WMI_INVALID_REGINFO        0x80002F46L

//
// MessageId: EVENT_WMI_INVALID_REGPATH
//
// MessageText:
//
//  The registry path (%1) passed by a kernel mode driver is invalid. The driver device object is in the additional data.
//
#define EVENT_WMI_INVALID_REGPATH        0x80002F47L

//
// MessageId: EVENT_WMI_CANT_RESOLVE_INSTANCE
//
// MessageText:
//
//  An event was fired specifying a static instance name that could not be resolved.
//
#define EVENT_WMI_CANT_RESOLVE_INSTANCE  0x80002F48L

//
// MessageId: EVENT_WMI_CANT_GET_EVENT_DATA
//
// MessageText:
//
//  An error occured while attempting to query for the event data referenced by a fired event.
//
#define EVENT_WMI_CANT_GET_EVENT_DATA    0x80002F49L


/////////////////////////////////////////////////////////////////////////
//
// Trk Services Events (12500-12999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_TRK_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occured in Distributed Link Tracking.  The error code was %1.
//
#define EVENT_TRK_INTERNAL_ERROR         0xC00030D4L

//
// MessageId: EVENT_TRK_SERVICE_START_SUCCESS
//
// MessageText:
//
//  Service started successfully
//
#define EVENT_TRK_SERVICE_START_SUCCESS  0x400030D5L

//
// MessageId: EVENT_TRK_SERVICE_START_FAILURE
//
// MessageText:
//
//  Service failed to start.  Error = %1
//
#define EVENT_TRK_SERVICE_START_FAILURE  0xC00030D6L

//
// MessageId: EVENT_TRK_SERVICE_CORRUPT_LOG
//
// MessageText:
//
//  The Distributed Link Tracking log was corrupt on volume %1: and has been re-created.  This log is used to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_CORRUPT_LOG    0xC00030D7L

//
// MessageId: EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED
//
// MessageText:
//
//  The Distributed Link Tracking volume ID quota on this machine has been exceeded.  As a result, it is not possible to create new volume IDs.  Distributed Link Tracking normally uses these volume IDs to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED 0x800030D8L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CREATE
//
// MessageText:
//
//  A new volume ID has been assigned for %1:%n%2%n%n
//  This ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  If there previously were links to files on this volume that are broken, they might not be automatically repairable.
//
#define EVENT_TRK_SERVICE_VOLUME_CREATE  0x400030D9L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CLAIM
//
// MessageText:
//
//  Ownership of the volume ID for %1: has been successfully claimed.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOLUME_CLAIM   0x400030DAL

//
// MessageId: EVENT_TRK_SERVICE_DUPLICATE_VOLIDS
//
// MessageText:
//
//  The volume ID for %1: has been reset, since it was a duplicate of that on %2:.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_DUPLICATE_VOLIDS 0x400030DBL

//
// MessageId: EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The move table quota for Distributed Link Tracking in this domain has been exceeded.  This table is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  While this quota is exceeded, it may not be possible to automatically repair some such broken links.
//
#define EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED 0x800030DCL


/////////////////////////////////////////////////////////////////////////
//
// ATM Protocol Events (13000-13499)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service does not support the version (1.0) supported by this LAN Emulation Client.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP 0xC000332CL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service does not support the version (1.0) supported by this LAN Emulation Client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP 0xC000332DL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The configuration parameters are incompatible with the desired Emulated LAN.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL 0xC000332EL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The join parameters are incompatible with the desired Emulated LAN.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL 0xC000332FL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. This LAN Emulation client attempted to register a MAC address (%3) that is already in use by another client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST 0xC0003330L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. This LAN Emulation client attempted to register an ATM address (%3) that is already in use by another client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR 0xC0003331L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service does not have sufficient resources to process the request.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES 0xC0003332L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service does not have sufficient resources to process the request.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES 0xC0003333L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service disallowed this request for security reasons.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS 0xC0003334L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service disallowed this request for security reasons.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS 0xC0003335L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied LAN Emulation Client ID is invalid.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL 0xC0003336L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied LAN Emulation Client ID is invalid.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL 0xC0003337L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied MAC Address (%3) cannot be a multicast address or, on an Ethernet/802.3 Emulated LAN, a Route Descriptor.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL 0xC0003338L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied MAC Address (%3) cannot be a multicast address or, on an Ethernet/802.3 Emulated LAN, a Route Descriptor.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL 0xC0003339L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied ATM Address (%3) is not in a recognizable format.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL 0xC000333AL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied ATM Address (%3) is not in a recognizable format.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL 0xC000333BL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_NOCONF
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation client is not recognized.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_NOCONF 0xC000333CL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. No other information is available.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR 0xC000333DL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation client has not provided sufficient information to allow assignment to an Emulated LAN.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO 0xC000333EL

//
// MessageId: EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
//  The Local ATM address (%2) can not be used because it is already registered by another node in the network.
//
#define EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS 0xC0003390L


/////////////////////////////////////////////////////////////////////////
//
// File Replication Service (NtFrs) Events (13500-13999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_FRS_ERROR
//
// MessageText:
//
//  File Replication Service
//
#define EVENT_FRS_ERROR                  0xC00034BCL

//
// MessageId: EVENT_FRS_STARTING
//
// MessageText:
//
//  The File Replication Service is starting.
//
#define EVENT_FRS_STARTING               0x400034BDL

//
// MessageId: EVENT_FRS_STOPPING
//
// MessageText:
//
//  The File Replication Service is stopping.
//
#define EVENT_FRS_STOPPING               0x400034BEL

//
// MessageId: EVENT_FRS_STOPPED
//
// MessageText:
//
//  The File Replication Service has stopped.
//
#define EVENT_FRS_STOPPED                0x400034BFL

//
// MessageId: EVENT_FRS_STOPPED_FORCE
//
// MessageText:
//
//  The File Replication Service stopped without cleaning up.
//
#define EVENT_FRS_STOPPED_FORCE          0xC00034C0L

//
// MessageId: EVENT_FRS_STOPPED_ASSERT
//
// MessageText:
//
//  The File Replication Service has stopped after taking an assertion failure.
//
#define EVENT_FRS_STOPPED_ASSERT         0xC00034C1L

//
// MessageId: EVENT_FRS_ASSERT
//
// MessageText:
//
//  The File Replication Service failed a consistency check
//  %n  (%3)
//  %nin "%1" at line %2.
//  %n
//  %nThe File Replication Service will restart automatically at a later time.
//  If this problem persists a subsequent entry in this event log describes the
//  recovery procedure.
//  %n
//  For more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services,
//  File Replication Service, and Recovery.
//
#define EVENT_FRS_ASSERT                 0xC00034C2L

//
// MessageId: EVENT_FRS_VOLUME_NOT_SUPPORTED
//
// MessageText:
//
//  The File Replication Service cannot start replica set %1 on computer %2
//  for directory %3 because the type of volume %4 is not NTFS 5.0 or later.
//  %n
//  %nThe volume's type can be found by typing "chkdsk %4".
//  %n
//  %nThe volume can be upgraded to NTFS 5.0 or later by typing "chkntfs /E %4".
//
#define EVENT_FRS_VOLUME_NOT_SUPPORTED   0xC00034C3L

//
// MessageId: EVENT_FRS_LONG_JOIN
//
// MessageText:
//
//  The File Replication Service is having trouble enabling replication
//  from %1 to %2 for %3 using the DNS name %4. FRS will keep retrying.
//  %n Following are some of the reasons you would see this warning.
//  %n
//  %n [1] FRS can not correctly resolve the DNS name %4 from this computer.
//  %n [2] FRS is not running on %4.
//  %n [3] The topology information in the Active Directory for this replica has not
//  yet replicated to all the Domain Controllers.
//  %n
//  %n This event log message will appear once per connection, After the problem
//  is fixed you will see another event log message indicating that the connection
//  has been established.
//
#define EVENT_FRS_LONG_JOIN              0x800034C4L

//
// MessageId: EVENT_FRS_LONG_JOIN_DONE
//
// MessageText:
//
//  The File Replication Service has enabled replication from %1 to %2 for %3
//  after repeated retries.
//
#define EVENT_FRS_LONG_JOIN_DONE         0x800034C5L

//
// MessageId: EVENT_FRS_CANNOT_COMMUNICATE
//
// MessageText:
//
//  The File Replication Service on the computer %1 cannot communicate with
//  the File Replication Service on the computer %2.
//  %n
//  %nVerify that the computer %2 is up and running.
//  %n
//  %nVerify that the File Replication Service is running on %2 by
//  typing "net start ntfrs" on %2.
//  %n
//  %nVerify that the network is functioning between %1 and %2 by
//  typing "ping %1" on %2 and "ping %2" on %1.
//  If the pings succeed then retry the failed operation.
//  If the pings fail then there may be problems with the DNS server.
//  %n
//  %nThe DNS server is responsible for mapping computer names to IP addresses.
//  The commands "ipconfig" and "nslookup" help diagnose problems with the
//  DNS server.
//  %n
//  %nTyping "ipconfig /all" will list the computer's IP address and the IP
//  address of the computer's DNS servers. Type "ping <DNS server's IP address>"
//  to verify that a DNS server is available. The DNS mapping for %2 or %1
//  can be verified by typing "nslookup" and then typing "%2" and then "%1"
//  on %1 and %2. Be sure to check out the DNS server on both %1 and %2;
//  a DNS problem on either computer will prevent proper communication.
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by flushing
//  the DNS Resolver Cache. Type "ipconfig /flushdns".
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by renewing
//  the IP address. Type "ipconfig /release" followed by "ipconfig /renew".
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by resetting
//  the computer's DNS entry. Type "net stop NetLogon" followed by
//  "net start NetLogon".
//  %n
//  %nSome problems between %1 and %2 can be cleared up by restarting
//  the File Replication Service. Type "net stop ntfrs" followed by
//  "net start ntfrs".
//  %n
//  %nSome problems between %1 and %2 can be cleared up by restarting
//  the computers %1 and %2 AFTER CLOSING RUNNING APPLIATIONS,
//  especially dcpromo. Click on Start, Shutdown, select Restart, and
//  click on OK.
//  %n
//  %nOther network and computer problems are beyond the scope of
//  this event log message.
//
#define EVENT_FRS_CANNOT_COMMUNICATE     0xC00034C6L

//
// MessageId: EVENT_FRS_DATABASE_SPACE
//
// MessageText:
//
//  The File Replication Service is stopping on computer %1 because there is no free
//  space on the volume containing %2.
//  %n
//  %nThe available space on the volume can be found by typing
//  "dir %2".
//  %n
//  %nOnce free space is made available on the volume containing %2,
//  the File Replication Service can be restarted immediately by typing
//  "net start ntfrs". Otherwise, the File Replication Service will
//  restart automatically at a later time.
//  %n
//  %nFor more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services, File
//  Replication Service, and Recovery.
//  %n
//  %nFor more information about managing space on a volume type "copy /?",
//  "rename /?", "del /?", "rmdir /?", and "dir /?".
//
#define EVENT_FRS_DATABASE_SPACE         0xC00034C7L

//
// MessageId: EVENT_FRS_DISK_WRITE_CACHE_ENABLED
//
// MessageText:
//
//  The File Replication Service has detected an enabled disk write cache
//  on the drive containing the directory %2 on the computer %1.
//  The File Replication Service might not recover when power to the
//  drive is interrupted and critical updates are lost.
//
#define EVENT_FRS_DISK_WRITE_CACHE_ENABLED 0x800034C8L

//
// MessageId: EVENT_FRS_JET_1414
//
// MessageText:
//
//  The File Replication Service on computer %1 is stopping because the
//  database %2 is corrupted.
//  %n
//  %nThe database can be recovered by typing "esentutl /d %2 /l%3 /s%4".
//  %n
//  %nOnce the database has been successfully recovered the
//  File Replication Service can be restarted by typing "net start ntfrs".
//
#define EVENT_FRS_JET_1414               0xC00034C9L

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY
//
// MessageText:
//
//  The File Replication Service may be preventing the computer %1 from becoming a
//  domain controller while the system volume is being initialized with data
//  from another domain controller and then shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share. The File Replication
//  Service has stopped preventing the computer from becoming a domain
//  controller once the SYSVOL share appears.
//  %n
//  %nThe initialization of the system volume can take some time.
//  The time is dependent on the amount of data in the system volume,
//  the availability of other domain controllers, and the replication
//  interval between domain controllers.
//
#define EVENT_FRS_SYSVOL_NOT_READY       0x800034CAL

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY_PRIMARY
//
// MessageText:
//
//  The File Replication Service may be preventing the computer %1 from becoming a
//  domain controller while the system volume is being initialized and then
//  shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share. The File Replication
//  Service has stopped preventing the computer from becoming a domain
//  controller once the SYSVOL share appears.
//  %n
//  %nThe initialization of the system volume can take some time.
//  The time is dependent on the amount of data in the system volume.
//  %n
//  %nThe initialization of the system volume can be bypassed by first typing
//  regedt32 and setting the value of SysvolReady to 1 and then restarting
//  the Netlogon service.
//  %n
//  %nWARNING - BYPASSING THE SYSTEM VOLUME INITIALIZATION IS NOT RECOMMENDED.
//  Applications may fail in unexpected ways.
//  %n
//  %nThe value SysvolReady is located by clicking on HKEY_LOCAL_MACHINE
//  and then clicking on System, CurrentControlSet, Services, Netlogon,
//  and Parameters.
//  %n
//  %nThe Netlogon service can be restarted by typing "net stop netlogon"
//  followed by "net start netlogon".
//
#define EVENT_FRS_SYSVOL_NOT_READY_PRIMARY 0x800034CBL

//
// MessageId: EVENT_FRS_SYSVOL_READY
//
// MessageText:
//
//  The File Replication Service is no longer preventing the computer %1 from
//  becoming a domain controller. The system volume has been successfully
//  initialized and the Netlogon service has been notified that the system
//  volume is now ready to be shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share.
//
#define EVENT_FRS_SYSVOL_READY           0x400034CCL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_DISABLED
//
// MessageText:
//
//  The File Replication Service will not check access to the API "%1".
//  %n
//  %nAccess checks can be enabled for "%1" by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
//  Change the string to Enabled.
//  %n
//  %nPermissions can be changed by highlighting "%1" and then clicking on the
//  toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_DISABLED 0x800034CDL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_USER
//
// MessageText:
//
//  The File Replication Service did not grant the user "%3" access to the
//  API "%1".
//  %n
//  %nPermissions for "%1" can be changed by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, and highlight "%1".
//  Click on the toolbar option Security and then Permissions...
//  %n
//  %nAccess checks can be disabled for "%1". Double click on "%2" and
//  change the string to Disabled.
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_USER 0x800034CEL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN
//
// MessageText:
//
//  The File Replication Service could not grant an unknown user access to the
//  API "%1".
//  %n
//  %nAccess checks can be disabled for "%1" by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
//  Change the string to Disabled.
//  %n
//  %nPermissions can be changed by highlighting "%1" and then clicking on the
//  toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN 0xC00034CFL

//
// MessageId: EVENT_FRS_MOVED_PREEXISTING
//
// MessageText:
//
//  The File Replication Service moved the preexisting files in %1 to %2.
//  %n
//  %nThe File Replication Service may delete the files in %2 at any time.
//  Files can be saved from deletion by copying them out of %2. Copying
//  the files into %1 may lead to name conflicts if the files already exist
//  on some other replicating partner.
//  %n
//  %nIn some cases, the File Replication Service may copy a file
//  from %2 into %1 instead of replicating the file from some other
//  replicating partner.
//  %n
//  %nSpace can be recovered at any time by deleting the files in %2.
//
#define EVENT_FRS_MOVED_PREEXISTING      0x800034D0L

//
// MessageId: EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS
//
// MessageText:
//
//  The File Replication Service cannot enable replication on the comptuer %1
//  until a backup/restore application completes.
//  %n
//  %nA backup/restore application has set a registry key that
//  prevents the File Replication Service from starting until the registry
//  key is deleted or the system is rebooted.
//  %n
//  %nThe backup/restore application may still be running. Check with your
//  local administrator before proceeding further.
//  %n
//  %nThe computer can be rebooted by clicking on Start, Shutdown, and
//  selecting Restart.
//  %n
//  %nWARNING - DELETING THE REGISTRY KEY IS NOT RECOMMENDED!
//  Applications may fail in unexpected ways.
//  %n
//  %nThe registry key can be deleted by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Backup/Restore,
//  "Stop NtFrs from Starting". On the toolbar, click on Edit and select
//  Delete. Be careful! Deleting a key other than "Stop NtFrs From Starting"
//  can have unexpected sideeffects.
//
#define EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS 0xC00034D1L

//
// MessageId: EVENT_FRS_STAGING_AREA_FULL
//
// MessageText:
//
//  The File Replication Service paused because the staging area is full.
//  Replication will resume if staging space becomes available or if the
//  staging space limit is increased.
//  %n
//  %nThe current value of the staging space limit is %1 KB.
//  %n
//  %nTo change the staging space limit, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, and the value
//  "Staging Space Limit in KB".
//
#define EVENT_FRS_STAGING_AREA_FULL      0x800034D2L

//
// MessageId: EVENT_FRS_HUGE_FILE
//
// MessageText:
//
//  The File Replication Service paused because the size of a file exceeds the
//  staging space limit. Replication will resume only if the staging space limit
//  is increased.
//  %n
//  %nThe staging space limit is %1 KB and the file size is %2 KB.
//  %n
//  %nTo change the staging space limit, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, and the value
//  "Staging Space Limit in KB".
//
#define EVENT_FRS_HUGE_FILE              0x800034D3L

//
// MessageId: EVENT_FRS_CANNOT_CREATE_UUID
//
// MessageText:
//
//  The File Replication Service is stopping on the computer %1 because
//  a universally unique ID (UUID) cannot be created.
//  %n
//  %nThe SDK function UuidCreate() returned the error "%2".
//  %n
//  %nThe problem may be the lack of an Ethernet address,
//  token ring address, or network address. The lack of a network
//  address implies an unsupported netcard.
//  %n
//  %nThe File Replication Service will restart automatically at a later time.
//  For more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services,
//  File Replication Service, and Recovery.
//
#define EVENT_FRS_CANNOT_CREATE_UUID     0xC00034D4L

//
// MessageId: EVENT_FRS_NO_DNS_ATTRIBUTE
//
// MessageText:
//
//  The File Replication Service cannot find the DNS name for the computer %1
//  because the "%2" attribute could not be read from the distinguished
//  name "%3".
//  %n
//  %nThe File Replication Service will try using the name "%1" until the
//  computer's DNS name appears.
//
#define EVENT_FRS_NO_DNS_ATTRIBUTE       0x800034D5L

//
// MessageId: EVENT_FRS_NO_SID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 with the computer
//  %2 because the computer's SID cannot be determined from the distinguished
//  name "%3".
//  %n
//  %nThe File Replication Service will retry later.
//
#define EVENT_FRS_NO_SID                 0xC00034D6L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET
//
// MessageText:
//
//  The RPC binding failed in the Open function of the FileReplicaSet Object. The
//  counter data for this object will not be available. The FileReplicaSet object
//  contains the performance counters of the Replica sets whose files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET 0xC00034D7L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
//  The RPC binding failed in the Open function of the FileReplicaConn Object. The
//  counter data for this object will not be available. The FileReplicaConn object
//  contains the performance counters of the connections over which files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN 0xC00034D8L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_SET
//
// MessageText:
//
//  The RPC call failed in the Open function of the FileReplicaSet Object. The
//  counter data for this object will not be available. The FileReplicaSet object
//  contains the performance counters of the Replica sets whose files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_SET 0xC00034D9L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN
//
// MessageText:
//
//  The RPC call failed in the Open function of the FileReplicaConn Object. The
//  counter data for this object will not be available. The FileReplicaConn object
//  contains the performance counters of the connections over which files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN 0xC00034DAL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET
//
// MessageText:
//
//  The RPC binding failed in the Collect function of the FileReplicaSet Object. The
//  counter data for this object will not be available till the binding succeeds.
//  The FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET 0xC00034DBL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
//  The RPC binding failed in the Collect function of the FileReplicaConn Object.
//  The counter data for this object will not be available till the binding
//  succeeds. The FileReplicaConn object contains the performance counters of the
//  connections over which files are being replicated by the File Replication
//  Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN 0xC00034DCL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET
//
// MessageText:
//
//  The RPC call failed in the Collect function of the FileReplicaSet Object. The
//  counter data for this object will not be available till the call succeeds. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET 0xC00034DDL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN
//
// MessageText:
//
//  The RPC call failed in the Collect function of the FileReplicaConn Object. The
//  counter data for this object will not be available till the call succeeds. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN 0xC00034DEL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_SET
//
// MessageText:
//
//  The call to VirtualAlloc failed in the Open function of the FileReplicaSet
//  Object. The counter data for this object will not be available. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_SET  0xC00034DFL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_CONN
//
// MessageText:
//
//  The call to VirtualAlloc failed in the Open function of the FileReplicaConn
//  Object. The counter data for this object will not be available. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_CONN 0xC00034E0L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_SET
//
// MessageText:
//
//  The call to the Registry failed in the Open function of the FileReplicaSet
//  Object. The counter data for this object will not be available. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_SET      0xC00034E1L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_CONN
//
// MessageText:
//
//  The call to the Registry failed in the Open function of the FileReplicaConn
//  Object. The counter data for this object will not be available. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_CONN     0xC00034E2L

//
// MessageId: EVENT_FRS_ROOT_NOT_VALID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because the
//  pathname of the replicated directory is not the fully qualified
//  pathname of an existing, accessible local directory.
//
#define EVENT_FRS_ROOT_NOT_VALID         0xC00034E3L

//
// MessageId: EVENT_FRS_STAGE_NOT_VALID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because the pathname
//  of the customer designated staging directory:
//  %n    %2
//  %n is not the fully qualified pathname of an existing, accessible local directory.
//
#define EVENT_FRS_STAGE_NOT_VALID        0xC00034E4L

//
// MessageId: EVENT_FRS_OVERLAPS_LOGGING
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the File Replication Service's logging pathname %2.
//
#define EVENT_FRS_OVERLAPS_LOGGING       0xC00034E5L

//
// MessageId: EVENT_FRS_OVERLAPS_WORKING
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the File Replication Service's working directory %2.
//
#define EVENT_FRS_OVERLAPS_WORKING       0xC00034E6L

//
// MessageId: EVENT_FRS_OVERLAPS_STAGE
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the staging directory %2.
//
#define EVENT_FRS_OVERLAPS_STAGE         0xC00034E7L

//
// MessageId: EVENT_FRS_OVERLAPS_ROOT
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the replicating directory %2.
//
#define EVENT_FRS_OVERLAPS_ROOT          0xC00034E8L

//
// MessageId: EVENT_FRS_OVERLAPS_OTHER_STAGE
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the staging directory %2 of the replicating directory %3.
//
#define EVENT_FRS_OVERLAPS_OTHER_STAGE   0xC00034E9L

//
// MessageId: EVENT_FRS_PREPARE_ROOT_FAILED
//
// MessageText:
//
//  The File Replication Service could not prepare the root directory
//  %1 for replication.  This is likely due to a problem creating the
//  root directory or a problem removing preexisting files in the root
//  directory.
//  %n
//  %nCheck that the path leading up to the root directory exists and is
//  accessible.
//
#define EVENT_FRS_PREPARE_ROOT_FAILED    0xC00034EAL

//
// MessageId: EVENT_FRS_BAD_REG_DATA
//
// MessageText:
//
//  The File Replication Service detected an invalid parameter value in the
//  registry.  %1.
//  %n
//  %nThe expected registry key name is "%2".
//  %nThe expected value name is "%3".
//  %nThe expected registry data type is %4.
//  %nThe allowed range for this parameter is %5
//  %nThe data units for this parameter value are %6.
//  %nThe File Replication Service is using a default value of "%7".
//  %n
//  %nTo change this parameter, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE.
//  %nClick down the key path: "%8"
//  %nDouble click on the value name -
//  %n    "%9"
//  %nand update the value.
//  %nIf the value name is not present you may add it with the Add Value function
//  under the Edit Menu item. Type the value name exactly as shown above using the
//  above registry data type.  Make sure you observe the data units and allowed range
//  when entering the value.
//
#define EVENT_FRS_BAD_REG_DATA           0x800034EBL

//
// MessageId: EVENT_FRS_JOIN_FAIL_TIME_SKEW
//
// MessageText:
//
//  The File Replication Service is unable to replicate with its partner computer
//  because the difference in clock times is outside the range of plus or minus
//  %1 minutes.
//  %n
//  %nThe connection to the partner computer is:
//  %n  "%2"
//  %nThe detected time difference is:  %3 minutes.
//  %n
//  %nNote: If this time difference is close to a multiple of 60 minutes then it
//  is likely that either this computer or its partner computer was set to the
//  incorrect time zone when the computer time was initially set.  Check that
//  the time zone and the system time are correctly set on both computers.
//  %n
//  %nIf necessary, the default value used to test for computer time consistency
//  may be changed in the registry on this computer.  (Note: This is not recommended.)
//  %n
//  %nTo change this parameter, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE.
//  %nClick down the key path:
//  %n   "System\CurrentControlSet\Services\NtFrs\Parameters"
//  %nDouble click on the value name
//  %n   "Partner Clock Skew In Minutes"
//  %nand update the value.
//  %n
//  %nIf the value name is not present you may add it with the Add Value function
//  under the Edit Menu item. Type the value name exactly as shown above using the
//  the registry data type REG_DWORD.
//
#define EVENT_FRS_JOIN_FAIL_TIME_SKEW    0xC00034ECL

//
// MessageId: EVENT_FRS_RMTCO_TIME_SKEW
//
// MessageText:
//
//  The File Replication Service is unable to replicate from a partner computer
//  because the event time associated with the file to be replicated is too far
//  into the future.  It is %1 minutes greater than the current time.  This can
//  happen if the system time on the partner computer was set incorrectly when
//  the file was created or updated.  To preserve the integrity of the replica
//  set this file update will not be performed or propagated further.
//  %n
//  %nThe file name is: "%2"
//  %nThe connection to the partner computer is:
//  %n  "%3"
//  %n
//  %nNote: If this time difference is close to a multiple of 60 minutes then it
//  is likely that this file may have been created or updated on the partner
//  computer while the computer was set to the incorrect time zone when its
//  computer time was initially set.  Check that the timezone and time are
//  correctly set on the partner computer.
//
#define EVENT_FRS_RMTCO_TIME_SKEW        0xC00034EDL

//
// MessageId: EVENT_FRS_CANT_OPEN_STAGE
//
// MessageText:
//
//  The File Replication Service is unable to open the customer designated
//  staging directory for replica set %1.  The path used for the staging
//  directory is,
//  %n    "%2"
//  %nThe customer designated root path for this replica set is:
//  %n    "%3"
//  %n
//  The service is unable to start replication on this replica set.  Among the
//  possible errors to check are:
//  %n  --  an invalid staging path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support ACLs,
//  %n  --  a sharing conflict on the staging directory with some other application.
//  %n
//  %nCorrect the problem and the service will attempt to restart replication
//  automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_STAGE        0xC00034EEL

//
// MessageId: EVENT_FRS_CANT_OPEN_PREINSTALL
//
// MessageText:
//
//  The File Replication Service is unable to open (or create) the pre-install
//  directory under the customer designated replica tree directory for
//  replica set %1.  The path used for the pre-install
//  directory is,
//  %n    "%2"
//  %nThe customer designated root path for this replica set is:
//  %n    "%3"
//  %n
//  The service is unable to start replication on this replica set.  Among the
//  possible errors to check are:
//  %n  --  an invalid root path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support NTFS 5.0
//  %n  --  a sharing conflict on the pre-install directory with some other application.
//  %n
//  %nCorrect the problem and the service will attempt to restart replication
//  automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_PREINSTALL   0xC00034EFL

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_FAIL
//
// MessageText:
//
//  The File Replication Service is unable to add this computer to the following
//  replica set:
//  %n    "%1"
//  %n
//  %nThis could be caused by a number of problems such as:
//  %n  --  an invalid root path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support NTFS 5.0
//  %n
//  %nThe information below may help to resolve the problem:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nReplica set root path is "%4"
//  %nReplica staging directory path is "%5"
//  %nReplica working directory path is "%6"
//  %nWindows error status code is %7
//  %nFRS error status code is %8
//  %n
//  %nOther event log messages may also help determine the problem.  Correct the
//  problem and the service will attempt to restart replication automatically at
//  a later time.
//
#define EVENT_FRS_REPLICA_SET_CREATE_FAIL 0xC00034F0L

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_OK
//
// MessageText:
//
//  The File Replication Service successfully added this computer to the following
//  replica set:
//  %n    "%1"
//  %n
//  %nInformation related to this event is shown below:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nReplica set root path is "%4"
//  %nReplica staging directory path is "%5"
//  %nReplica working directory path is "%6"
//
#define EVENT_FRS_REPLICA_SET_CREATE_OK  0x400034F1L

//
// MessageId: EVENT_FRS_REPLICA_SET_CXTIONS
//
// MessageText:
//
//  The File Replication Service successfully added the connections shown below
//  to the replica set:
//  %n    "%1"
//  %n
//  %n    %2
//  %n    %3
//  %n    %4
//  %n    %5
//  %n    %6
//  %n    %7
//  %n    %8
//  %n    %9
//  %n
//  %nMore information may appear in subsequent event log messages.
//
#define EVENT_FRS_REPLICA_SET_CXTIONS    0x400034F2L

//
// MessageId: EVENT_FRS_IN_ERROR_STATE
//
// MessageText:
//
//  The File Replication Service is in an error state. Files will not replicate
//  to or from one or all of the replica sets on his computer until the
//  following recovery steps are performed:
//  %n
//  %n Recovery Steps:
//  %n
//  %n [1] The error state may clear itself if you stop and restart the FRS service.
//  This can be done by performing the following in a command window:
//  %n
//  %n    net stop ntfrs
//  %n    net start ntfrs
//  %n
//  %nIf this fails to clear up the problem then proceed as follows.
//  %n
//  %n [2] For Active Directory Domain Controllers that DO NOT host any DFS
//  alternates or other replica sets with replication enabled:
//  %n
//  %nIf there is at least one other Domain Controller in this domain then
//  restore the "system state" of this DC from backup (using ntbackup or other
//  backup-restore utility) and make it non-authoritative.
//  %n
//  %nIf there are NO other Domain Controllers in this domain then restore
//  the "system state" of this DC from backup (using ntbackup or other
//  backup-restore utility) and choose the Advanced option which marks
//  the sysvols as primary.
//  %n
//  %nIf there are other Domain Controllers in this domain but ALL of
//  them have this event log message then restore one of them as primary
//  (data files from primary will replicate everywhere) and the others as
//  non-authoritative.
//  %n
//  %n
//  %n [3] For Active Directory Domain Controllers that host DFS alternates
//  or other replica sets with replication enabled:
//  %n
//  %n (3-a) If the Dfs alternates on this DC do not have any other replication
//  partners then copy the data under that Dfs share to a safe location.
//  %n (3-b) If this server is the only Active Directory Domain Controller for this
//  domain then, before going to (3-c),  make sure this server does not have any
//  inbound or outbound connections to other servers that were formerly Domain
//  Controllers for this domain but are now off the net (and will never be
//  coming back online) or have been fresh installed without being demoted.
//  To delete connections use the Sites and Services snapin and look for
//  %nSites->NAME_OF_SITE->Servers->NAME_OF_SERVER->NTDS Settings->CONNECTIONS.
//  %n (3-c) Restore the "system state" of this DC from backup (using ntbackup
//  or other backup-restore utility) and make it non-authoritative.
//  %n (3-d) Copy the data from step (3-a) above to the original location
//  after the sysvol share is published.
//  %n
//  %n
//  %n [4] For other Windows 2000 servers:
//  %n
//  %n (4-a)  If any of the DFS alternates or other replica sets hosted by
//  this server do not have any other replication partners then copy the
//  data under its share or replica tree root to a safe location.
//  %n (4-b)  net stop ntfrs
//  %n (4-c)  rd /s /q  %1
//  %n (4-d)  net start ntfrs
//  %n (4-e)  Copy the data from step (4-a) above to the original location after
//  the service has initialized (5 minutes is a safe waiting time).
//  %n
//  %nNote: If this error message is in the eventlog of all the members of a
//  particular replica set then perform steps (4-a) and (4-e) above on only
//  one of the members.
//
#define EVENT_FRS_IN_ERROR_STATE         0xC00034F3L

//
// MessageId: EVENT_FRS_REPLICA_NO_ROOT_CHANGE
//
// MessageText:
//
//  The File Replication Service has detected what appears to be an attempt
//  to change the root path for the following replica set:
//  %n    "%1"
//  %n
//  %nThis is not allowed.  To perform this operation you must remove this member
//  from the replica set and add the member back with the new root path.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must delete and re-add this member to the replica set.
//  %n
//  %nInformation related to this event is shown below:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nThe current Replica set root path is "%4"
//  %nThe desired new Replica set root path is "%5"
//  %nReplica staging directory path is "%6"
//
#define EVENT_FRS_REPLICA_NO_ROOT_CHANGE 0xC00034F4L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL
//
// MessageText:
//
//  The File Replication Service has detected a duplicate connection object between
//  this computer "%6" and a computer named "%1".
//  %nThis was detected for the following replica set:
//  %n    "%2"
//  %n
//  %nThis is not allowed and replication will not occur between these two
//  computers until the duplicate connection objects are removed.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must manually delete the duplicate connection objects by
//  following the steps below:
//  %n
//  %n [1] Start the Active Directory Sites and Services Snapin.
//  %n [2] Click on "%3, %4, %5, %6, %7".
//  %n [3] Look for duplicate connections from "%1" in site "%8".
//  %n [4] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL 0xC00034F5L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION
//
// MessageText:
//
//  The File Replication Service has detected a duplicate connection object between
//  this computer "%7" and a computer named "%1".
//  %nThis was detected for the following replica set:
//  %n    "%2"
//  %n
//  %nThis is not allowed and replication will not occur between these two
//  computers until the duplicate connection objects are removed.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must manually delete the duplicate connection objects by
//  following the steps below:
//  %n
//  %n [1] Start the Active Directory Users and Computers Snapin.
//  %n [2] Click the view button and advanced features to display the system node.
//  %n [3] Click on "%3, %4, %5".
//  %n [4] Under "%5" you will see one or more DFS related replica set objects.
//  Look for the FRS member object "%6" under the subtree for replica set "%2".
//  %n [5] Under "%6" look for duplicate connections from "%1".
//  %n [6] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION    0xC00034F6L

//
// MessageId: EVENT_FRS_ROOT_HAS_MOVED
//
// MessageText:
//
//  The File Replication Service has detected that the replica root path has changed
//  from "%2" to "%3". If this is an intentional move then a file with the name
//  NTFRS_CMD_FILE_MOVE_ROOT needs to be created under the new root path.
//  %nThis was detected for the following replica set:
//  %n    "%1"
//  %n
//  %nChanging the replica root path is a two step process which is triggered by
//  the creation of the NTFRS_CMD_FILE_MOVE_ROOT file.
//  %n
//  %n [1] At the first poll which will occur in %4 minutes this computer will be
//  deleted from the replica set.
//  %n [2] At the poll following the deletion this computer will be re-added to the
//  replica set with the new root path. This re-addition will trigger a full tree
//  sync for the replica set. At the end of the sync all the files will be at the new
//  location. The files may or may not be deleted from the old location depending on whether
//  they are needed or not.
//
#define EVENT_FRS_ROOT_HAS_MOVED         0xC00034F7L

//
// MessageId: EVENT_FRS_ERROR_REPLICA_SET_DELETED
//
// MessageText:
//
//  The File Replication Service is deleting this computer from the replica set "%1" as an attempt to
//  recover from the error state,
//  %n Error status = %2
//  %n At the next poll, which will occur in %3 minutes, this computer will be re-added to the
//  replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_ERROR_REPLICA_SET_DELETED 0x800034F8L

//
// MessageId: EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR
//
// MessageText:
//
//  The File Replication Service has detected that the replica set "%1" is in JRNL_WRAP_ERROR.
//  %n
//  %n Replica set name is    : "%1"
//  %n Replica root path is   : "%2"
//  %n Replica root volume is : "%3"
//  %n
//  
//  A Replica set hits JRNL_WRAP_ERROR when the record that it is trying to read from the NTFS USN journal is not found.
//  This can occur because of one of the following reasons.
//  %n
//  %n [1] Volume "%3" has been formatted.
//  %n [2] The NTFS USN journal on volume "%3" has been deleted.
//  %n [3] The NTFS USN journal on volume "%3" has been truncated. Chkdsk can truncate
//  the journal if it finds corrupt entries at the end of the journal.
//  %n [4] File Replication Service was not running on this computer for a long time.
//  %n [5] File Replication Service could not keep up with the rate of Disk IO activity on "%3".
//  %n
//  %n Following recovery steps will be taken to automatically recover from this error state.
//  %n [1] At the first poll which will occur in %4 minutes this computer will be
//  deleted from the replica set.
//  %n [2] At the poll following the deletion this computer will be re-added to the
//  replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR 0xC00034F9L

//
// MessageId: EVENT_FRS_DS_POLL_ERROR_SUMMARY
//
// MessageText:
//
//  Following is the summary of warnings and errors encountered by File Replication Service
//  while polling the Domain Controller %1 for FRS replica set configuration information.
//  %n
//  %n %2
//  %n
//
#define EVENT_FRS_DS_POLL_ERROR_SUMMARY  0x800034FAL

/////////////////////////////////////////////////////////////////////////
//
// PSCHED Events
//
// Codes 14000 - 14299
//
/////////////////////////////////////////////////////////////////////////
//
// Driver wide events (14000 - 14099)
//
//
// MessageId: EVENT_PS_GPC_REGISTER_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register with the Generic Packet Classifier (msgpc.sys).
//
#define EVENT_PS_GPC_REGISTER_FAILED     0xC00036B0L

//
// MessageId: EVENT_PS_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  QoS: The Packet Scheduler was unable to allocate required resources for initialization.
//
#define EVENT_PS_NO_RESOURCES_FOR_INIT   0xC00036B1L

//
// MessageId: EVENT_PS_REGISTER_PROTOCOL_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register as a protocol with NDIS.
//
#define EVENT_PS_REGISTER_PROTOCOL_FAILED 0xC00036B2L

//
// MessageId: EVENT_PS_REGISTER_MINIPORT_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register as a miniport with NDIS.
//
#define EVENT_PS_REGISTER_MINIPORT_FAILED 0xC00036B3L

//
// Adapter events (14100 - 14199)
//
//
// MessageId: EVENT_PS_BAD_BESTEFFORT_LIMIT
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe BestEffortLimit value set in the registry exceeds the LinkSpeed. Defaulting to Unlimited BestEffort.
//
#define EVENT_PS_BAD_BESTEFFORT_LIMIT    0x80003714L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_MAXIMUM_FRAME_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE 0xC0003715L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_MAXIMUM_TOTAL_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE 0xC0003716L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_LINK_SPEED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_LINK_SPEED.
//
#define EVENT_PS_QUERY_OID_GEN_LINK_SPEED 0xC0003717L

//
// MessageId: EVENT_PS_BINDING_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler failed to bind to the netcard's miniport driver.
//
#define EVENT_PS_BINDING_FAILED          0xC0003718L

//
// MessageId: EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe UpperBindings key is missing from the registry.
//
#define EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA 0xC0003719L

//
// MessageId: EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler was unable to register with the NDISWAN Call Manager.
//
#define EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED 0xC000371AL

//
// MessageId: EVENT_PS_INIT_DEVICE_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler could not initialize the virtual miniport with NDIS.
//
#define EVENT_PS_INIT_DEVICE_FAILED      0xC000371BL

//
// MessageId: EVENT_PS_WMI_INSTANCE_NAME_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler could not obtain the adapter's friendly name from NDIS.
//
#define EVENT_PS_WMI_INSTANCE_NAME_FAILED 0xC000371CL

//
// MessageId: EVENT_PS_WAN_LIMITED_BESTEFFORT
//
// MessageText:
//
//  Qos [Adapter %2]:%nThe registry entry for BestEffortLimit is not supported over WAN links. Defaulting to Unlimited BestEffort mode.
//
#define EVENT_PS_WAN_LIMITED_BESTEFFORT  0x8000371DL

//
// MessageId: EVENT_PS_RESOURCE_POOL
//
// MessageText:
//
//  QoS [Adapter %2]:%nCould not initialize due to insufficient nonpaged pool memory.
//
#define EVENT_PS_RESOURCE_POOL           0xC000371EL

//
// MessageId: EVENT_PS_ADMISSIONCONTROL_OVERFLOW
//
// MessageText:
//
//  QoS [Adapter %2]:%nTotal bandwidth allocated to flows exceeds the NonBestEffortLimit. This is because of a reduction in the LinkSpeed or because of a change to the NonBestEffortLimit registry key.
//
#define EVENT_PS_ADMISSIONCONTROL_OVERFLOW 0x8000371FL

//
// MessageId: EVENT_PS_NETWORK_ADDRESS_FAIL
//
// MessageText:
//
//  QoS [Adapter %2]:%nCould not allocate non paged pool memory for storing Network Addresses.
//
#define EVENT_PS_NETWORK_ADDRESS_FAIL    0xC0003720L


/////////////////////////////////////////////////////////////////////////
//
// Distributed File System (Dfs) Events (14300-14599)
//
/////////////////////////////////////////////////////////////////////////

//
// Server-side (dfs.sys) errors (14300-14399)
//
//
// MessageId: EXTRA_EXIT_POINT
//
// MessageText:
//
//  An extra ExitPoint %2 was found at server %3
//
#define EXTRA_EXIT_POINT                 0xC00037DCL

//
// MessageId: MISSING_EXIT_POINT
//
// MessageText:
//
//  The ExitPoint %2 was missing at server %3
//
#define MISSING_EXIT_POINT               0xC00037DDL

//
// MessageId: MISSING_VOLUME
//
// MessageText:
//
//  The Volume %2 was missing at server %3
//
#define MISSING_VOLUME                   0xC00037DEL

//
// MessageId: EXTRA_VOLUME
//
// MessageText:
//
//  The extra Volume %2 was found at server %3
//
#define EXTRA_VOLUME                     0xC00037DFL

//
// MessageId: EXTRA_EXIT_POINT_DELETED
//
// MessageText:
//
//  The extra ExitPoint %2 was deleted successfully from the server %3
//
#define EXTRA_EXIT_POINT_DELETED         0xC00037E0L

//
// MessageId: EXTRA_EXIT_POINT_NOT_DELETED
//
// MessageText:
//
//  Unable to delete the extra ExitPoint %2 at the server %3
//
#define EXTRA_EXIT_POINT_NOT_DELETED     0xC00037E1L

//
// MessageId: MISSING_EXIT_POINT_CREATED
//
// MessageText:
//
//  The missing ExitPoint %2 was created at the server %3 successfully
//
#define MISSING_EXIT_POINT_CREATED       0xC00037E2L

//
// MessageId: MISSING_EXIT_POINT_NOT_CREATED
//
// MessageText:
//
//  Unable to create the missing Exit Point %2 at the server %3
//
#define MISSING_EXIT_POINT_NOT_CREATED   0xC00037E3L

//
// MessageId: MISSING_VOLUME_CREATED
//
// MessageText:
//
//  Successfully created the missing volume %2 knowledge at the server %3
//
#define MISSING_VOLUME_CREATED           0xC00037E4L

//
// MessageId: MISSING_VOLUME_NOT_CREATED
//
// MessageText:
//
//  Unable to create the missing Volume %2 info at server %3
//
#define MISSING_VOLUME_NOT_CREATED       0xC00037E5L

//
// MessageId: EXTRA_VOLUME_DELETED
//
// MessageText:
//
//  The extra Volume %2 info was deleted at server %3
//
#define EXTRA_VOLUME_DELETED             0xC00037E6L

//
// MessageId: EXTRA_VOLUME_NOT_DELETED
//
// MessageText:
//
//  The extra Volume %2 info was not deleted at server %3
//
#define EXTRA_VOLUME_NOT_DELETED         0xC00037E7L

//
// MessageId: COULD_NOT_VERIFY_VOLUMES
//
// MessageText:
//
//  Since the DC %2 was unavailable could not verify volumes knowledge.
//
#define COULD_NOT_VERIFY_VOLUMES         0xC00037E8L

//
// MessageId: KNOWLEDGE_INCONSISTENCY_DETECTED
//
// MessageText:
//
//  Detected Knowledge inconsistency with the volume %2 at server %3
//
#define KNOWLEDGE_INCONSISTENCY_DETECTED 0xC00037E9L

//
// MessageId: PREFIX_MISMATCH
//
// MessageText:
//
//  The local Prefix %2 was represented as %3 at remote server %4
//
#define PREFIX_MISMATCH                  0xC00037EAL

//
// MessageId: PREFIX_MISMATCH_FIXED
//
// MessageText:
//
//  The remote Prefix %3 was corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_FIXED            0xC00037EBL

//
// MessageId: PREFIX_MISMATCH_NOT_FIXED
//
// MessageText:
//
//  The remote Prefix %3 was NOT corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_NOT_FIXED        0xC00037ECL

//
// MessageId: MACHINE_UNJOINED
//
// MessageText:
//
//  The machine %2 has become unlinked from the domain. Re-join the machine the machine to this domain.
//
#define MACHINE_UNJOINED                 0xC00037EDL

//
// MessageId: DFS_REFERRAL_REQUEST
//
// MessageText:
//
//  Dfs received a referral request for "%2".  The return code is in the data.
//
#define DFS_REFERRAL_REQUEST             0x400037EEL

//
// Client-side Dfs (mup.sys) errors (14400-14499)
//
//
// MessageId: NOT_A_DFS_PATH
//
// MessageText:
//
//  The path "%2" is not a dfs path
//
#define NOT_A_DFS_PATH                   0x40003840L

//
// MessageId: LM_REDIR_FAILURE
//
// MessageText:
//
//  Dfs was unable to open the Lan Redir
//
#define LM_REDIR_FAILURE                 0x40003841L

//
// MessageId: DFS_CONNECTION_FAILURE
//
// MessageText:
//
//  Dfs was unable to open a connection to server %2.  The error returned is in the record data.
//
#define DFS_CONNECTION_FAILURE           0x40003842L

//
// MessageId: DFS_REFERRAL_FAILURE
//
// MessageText:
//
//  Dfs was unable to obtain a referral for "%2" from %3.  The error returned is in the record data.
//
#define DFS_REFERRAL_FAILURE             0x40003843L

//
// MessageId: DFS_REFERRAL_SUCCESS
//
// MessageText:
//
//  Dfs obtained a referral for "%2" from %3
//
#define DFS_REFERRAL_SUCCESS             0x40003844L

//
// MessageId: DFS_MAX_DNR_ATTEMPTS
//
// MessageText:
//
//  Dfs reached its limit of attempts of resolution of "%2".
//
#define DFS_MAX_DNR_ATTEMPTS             0x40003845L

//
// MessageId: DFS_SPECIAL_REFERRAL_FAILURE
//
// MessageText:
//
//  Dfs was unable to obtain the special referral table from %2.  The error returned is in the record data.
//
#define DFS_SPECIAL_REFERRAL_FAILURE     0x40003846L

//
// MessageId: DFS_OPEN_FAILURE
//
// MessageText:
//
//  Dfs failed on open of %2 directed to %3.  The error returned is in the record data.
//
#define DFS_OPEN_FAILURE                 0x40003847L

//
// Dfs service (dfssvc) errors (14500-14599)
//
//
// MessageId: NET_DFS_ENUM
//
// MessageText:
//
//  NetrDfsEnum received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUM                     0x400038A4L

//
// MessageId: NET_DFS_ENUMEX
//
// MessageText:
//
//  NetrDfsEnumEx received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUMEX                   0x400038A5L

//
// MessageId: DFS_ERROR_CREATE_DIRECTORY_FAILURE
//
// MessageText:
//
//  Dfs could not create directory %1.  The return code is in the record data.
//
#define DFS_ERROR_CREATE_DIRECTORY_FAILURE 0xC00038A6L

//
// MessageId: DFS_ERROR_CREATE_REPARSEPOINT_FAILURE
//
// MessageText:
//
//  Dfs could not create reparse point for directory %1 under directory %2. The return code is in the record data.
//
#define DFS_ERROR_CREATE_REPARSEPOINT_FAILURE 0xC00038A7L

//
// MessageId: DFS_ERROR_UNSUPPORTED_FILESYSTEM
//
// MessageText:
//
//  Share %1 mapped to %2 does not support reparse points. Upgrade Filesystem and retry.
//
#define DFS_ERROR_UNSUPPORTED_FILESYSTEM 0xC00038A8L

//
// MessageId: DFS_ERROR_OVERLAPPING_DIRECTORIES
//
// MessageText:
//
//  Share %1 mapped to %2 directory overlaps an existing root. The DFS Root will not be created. The return code is in the record data.
//
#define DFS_ERROR_OVERLAPPING_DIRECTORIES 0xC00038A9L

//
// MessageId: DFS_ERROR_AD_WRITE_ERROR
//
// MessageText:
//
//  DFS could not write to the Active Directory on Root %1. The return code is in the record data.
//
#define DFS_ERROR_AD_WRITE_ERROR         0xC00038AAL

//
// MessageId: DFS_ERROR_AD_READ_ERROR
//
// MessageText:
//
//  DFS could not read from the Active Directory on Root %1. The return code is in the record data.
//
#define DFS_ERROR_AD_READ_ERROR          0xC00038ABL

//
// MessageId: DFS_INFO_ACTIVEDIRECTORY_ONLINE
//
// MessageText:
//
//  DFS restablished a connection to the PDC to initiate Domain DFS operations.
//
#define DFS_INFO_ACTIVEDIRECTORY_ONLINE  0x400038ACL

//
// MessageId: DFS_ERROR_TOO_MANY_ERRORS
//
// MessageText:
//
//  Root %1 has too many errors. No further eventlogs will be logged on this root.
//
#define DFS_ERROR_TOO_MANY_ERRORS        0xC00038ADL

//
// MessageId: DFS_ERROR_WINSOCKINIT_FAILED
//
// MessageText:
//
//  DFS could not initialize winsock library. The return code is in the record data.
//
#define DFS_ERROR_WINSOCKINIT_FAILED     0xC00038AEL

//
// MessageId: DFS_ERROR_SECURITYINIT_FAILED
//
// MessageText:
//
//  DFS could not initialize security library. The return code is in the record data.
//
#define DFS_ERROR_SECURITYINIT_FAILED    0xC00038AFL

//
// MessageId: DFS_ERROR_THREADINIT_FAILED
//
// MessageText:
//
//  DFS could not create DFS support thread. The return code is in the record data.
//
#define DFS_ERROR_THREADINIT_FAILED      0xC00038B0L

//
// MessageId: DFS_ERROR_SITECACHEINIT_FAILED
//
// MessageText:
//
//  DFS could initialize IP site cache.The return code is in the record data.
//
#define DFS_ERROR_SITECACHEINIT_FAILED   0xC00038B1L

//
// MessageId: DFS_ERROR_ROOTSYNCINIT_FAILED
//
// MessageText:
//
//  DFS could synchronize all DFS roots.The return code is in the record data.
//
#define DFS_ERROR_ROOTSYNCINIT_FAILED    0xC00038B2L

//
// MessageId: DFS_ERROR_CREATEEVENT_FAILED
//
// MessageText:
//
//  DFS could not create event handle. The return code is in the record data.
//
#define DFS_ERROR_CREATEEVENT_FAILED     0xC00038B3L

//
// MessageId: DFS_ERROR_COMPUTERINFO_FAILED
//
// MessageText:
//
//  DFS could not get required computer information. The return code is in the record data.
//
#define DFS_ERROR_COMPUTERINFO_FAILED    0xC00038B4L

//
// MessageId: DFS_ERROR_CLUSTERINFO_FAILED
//
// MessageText:
//
//  DFS could not get required cluster information. The return code is in the record data.
//
#define DFS_ERROR_CLUSTERINFO_FAILED     0xC00038B5L

//
// MessageId: DFS_ERROR_DCINFO_FAILED
//
// MessageText:
//
//  DFS could not get required DC information. The return code is in the record data.
//
#define DFS_ERROR_DCINFO_FAILED          0xC00038B6L

//
// MessageId: DFS_ERROR_PREFIXTABLE_FAILED
//
// MessageText:
//
//  DFS could not initialize prefix table. The return code is in the record data.
//
#define DFS_ERROR_PREFIXTABLE_FAILED     0xC00038B7L

//
// MessageId: DFS_ERROR_HANDLENAMESPACE_FAILED
//
// MessageText:
//
//  DFS could not initialize DFS namespace.The return code is in the record data.
//
#define DFS_ERROR_HANDLENAMESPACE_FAILED 0xC00038B8L

//
// MessageId: DFS_ERROR_REGISTERSTORE_FAILED
//
// MessageText:
//
//  DFS could not Register DFS Namespaces. The return code is in the record data.
//
#define DFS_ERROR_REGISTERSTORE_FAILED   0xC00038B9L

//
// MessageId: DFS_ERROR_REFLECTIONENGINE_FAILED
//
// MessageText:
//
//  DFS could not initialize User/kernel communication package. The return code is in the record data.
//
#define DFS_ERROR_REFLECTIONENGINE_FAILED 0xC00038BAL

//
// MessageId: DFS_ERROR_ACTIVEDIRECTORY_OFFLINE
//
// MessageText:
//
//  DFS could not contact any DC for Domain DFS operations. This operation will be retried periodically.
//
#define DFS_ERROR_ACTIVEDIRECTORY_OFFLINE 0xC00038BBL

//
// MessageId: DFS_ERROR_SITESUPPOR_FAILED
//
// MessageText:
//
//  DFS could not initialize site support table. The return code is in the record data.
//
#define DFS_ERROR_SITESUPPOR_FAILED      0xC00038BCL

//
// MessageId: DFS_ERROR_DSINITIALCONNECT_FAILED
//
// MessageText:
//
//  DFS could not contact the %1 Active Directory. The return code is in the record data.
//
#define DFS_ERROR_DSINITIALCONNECT_FAILED 0xC00038BDL

//
// MessageId: DFS_ERROR_DSCONNECT_FAILED
//
// MessageText:
//
//  DFS could not contact the %1 Active Directory. DFS will be using cached data. The return code is in the record data.
//
#define DFS_ERROR_DSCONNECT_FAILED       0x800038BEL

//
// MessageId: DFS_ERROR_ROOT_TURNED_OFF
//
// MessageText:
//
//  Root %1 will be turned off because of too many errors on that root. 
//
#define DFS_ERROR_ROOT_TURNED_OFF        0xC00038BFL

//
// MessageId: DFS_INFO_ROOT_TURNED_ON
//
// MessageText:
//
//  Root %1 will be turned back on. 
//
#define DFS_INFO_ROOT_TURNED_ON          0x400038C0L

//
// MessageId: DFS_INFO_DS_RECONNECTED
//
// MessageText:
//
//  DFS has connected to the %1 Active Directory.
//
#define DFS_INFO_DS_RECONNECTED          0x400038C1L

//
// MessageId: DFS_ERROR_NO_DFS_DATA
//
// MessageText:
//
//  DFS could not access it's private data from the DS. Please manually check
//  network connectivity, security access, and/or consistency of DFS information
//  in the Active Directory. This error occured on root %1.  
//
#define DFS_ERROR_NO_DFS_DATA            0xC00038C2L

//
// MessageId: DFS_INFO_FINISH_INIT
//
// MessageText:
//
//  DFS server has finished initializating.
//  
//
#define DFS_INFO_FINISH_INIT             0x400038C3L

//
// MessageId: DFS_INFO_RECONNECT_DATA
//
// MessageText:
//
//  DFS server has recovered from an error and is able to read it's private data from 
//  the DS. Root %1 is now able to read information from the DS.
//  
//
#define DFS_INFO_RECONNECT_DATA          0x400038C4L

/////////////////////////////////////////////////////////////////////////
//
// BRIDGE Events
//
// Codes 14600 - 14899
//
/////////////////////////////////////////////////////////////////////////
//
// Driver-wide events (14600 - 14699)
//
//
// MessageId: EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to register as a protocol with NDIS.
//
#define EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED 0xC0003908L

//
// MessageId: EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge's miniport device name is missing from the registry.
//
#define EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING 0xC0003909L

//
// MessageId: EVENT_BRIDGE_MINIPORT_REGISTER_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to register as a miniport with NDIS.
//
#define EVENT_BRIDGE_MINIPORT_REGISTER_FAILED 0xC000390AL

//
// MessageId: EVENT_BRIDGE_DEVICE_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to create a device object.
//
#define EVENT_BRIDGE_DEVICE_CREATION_FAILED 0xC000390BL

//
// MessageId: EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to determine a MAC address for itself.
//
#define EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR  0xC000390CL

//
// MessageId: EVENT_BRIDGE_MINIPORT_INIT_FAILED
//
// MessageText:
//
//  Bridge: The bridge's attempt to create its virtual miniport failed.
//
#define EVENT_BRIDGE_MINIPORT_INIT_FAILED 0xC000390DL

//
// MessageId: EVENT_BRIDGE_ETHERNET_NOT_OFFERED
//
// MessageText:
//
//  Bridge: The bridge could not initialize its miniport because Ethernet was not offered as a supported medium.
//
#define EVENT_BRIDGE_ETHERNET_NOT_OFFERED 0xC000390EL

//
// MessageId: EVENT_BRIDGE_THREAD_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a system thread.
//
#define EVENT_BRIDGE_THREAD_CREATION_FAILED 0xC000390FL

//
// MessageId: EVENT_BRIDGE_THREAD_REF_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to reference its system thread.
//
#define EVENT_BRIDGE_THREAD_REF_FAILED   0xC0003910L

//
// MessageId: EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a packet pool.
//
#define EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED 0xC0003911L

//
// MessageId: EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a buffer pool.
//
#define EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED 0xC0003912L

//
// MessageId: EVENT_BRIDGE_INIT_MALLOC_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to allocate memory.
//
#define EVENT_BRIDGE_INIT_MALLOC_FAILED  0xC0003913L

//
// Adapter-specific events (14700 - 14799)
//
//
// MessageId: EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not determine the adapter's link speed. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED 0xC000396CL

//
// MessageId: EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not determine the adapter's MAC address. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED 0xC000396DL

//
// MessageId: EVENT_BRIDGE_ADAPTER_FILTER_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not modify the adapter's packet filter. The adapter will not function correctly.
//
#define EVENT_BRIDGE_ADAPTER_FILTER_FAILED 0xC000396EL

//
// MessageId: EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not retrieve the adapter's description string. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED 0xC000396FL

//
// MessageId: EVENT_BRIDGE_ADAPTER_BIND_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge's attempt to bind to the adapter failed. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_BIND_FAILED 0xC0003970L

//
// DAV Redir Events (14800 - 14899)
//
//
// MessageId: EVENT_DAV_REDIR_DELAYED_WRITE_FAILED
//
// MessageText:
//
//  Windows was unable to save data for file %2. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define EVENT_DAV_REDIR_DELAYED_WRITE_FAILED 0x800039D0L

//
// WebClient Service Events (14900 - 14999)
//
//
// MessageId: EVENT_WEBCLIENT_CLOSE_PUT_FAILED
//
// MessageText:
//
//  PUT failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PUT_FAILED 0x80003A35L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_DELETE_FAILED
//
// MessageText:
//
//  DELETE failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_DELETE_FAILED 0x80003A36L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED
//
// MessageText:
//
//  PROPPATCH failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED 0x80003A37L

//
// MessageId: EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED
//
// MessageText:
//
//  PROPPATCH failed for file %1 on SetFileInfo. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED 0x80003A38L


#endif // _NETEVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsprefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//--------------------------------------------------------------------------

#ifndef __PREFIX_HXX__
#define __PREFIX_HXX__
#ifdef __cplusplus
extern "C" {
#endif


//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE API.
//
// History:
//
// Notes:   The following API's are provided for manipulating the
//          DFS_PREFIX_TABLE.
//
//----------------------------------------------------------------------
struct _DFS_PREFIX_TABLE;

extern
NTSTATUS DfsInitializePrefixTable(struct _DFS_PREFIX_TABLE **ppTable,
                                  BOOLEAN           fCaseSensitive,
                                  PVOID Lock);
                            

extern
NTSTATUS DfsInsertInPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                PUNICODE_STRING   pPath,
                                PVOID             pData);

extern
NTSTATUS DfsRemoveFromPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                  PUNICODE_STRING pPath,
                                  PVOID pMatchingData );


extern
NTSTATUS DfsReplaceInPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                 PUNICODE_STRING pPath,
                                 PVOID pReplaceData,
                                 PVOID pMatchingData );

extern 
NTSTATUS DfsFreePrefixTable(struct _DFS_PREFIX_TABLE *pTable);

extern
NTSTATUS DfsFindUnicodePrefixLocked(
    IN  struct _DFS_PREFIX_TABLE *pTable,
    IN  PUNICODE_STRING     pPath,
    OUT PUNICODE_STRING     pSuffix,
    OUT PVOID *ppData,
    OUT PBOOLEAN pSubStringMatch );


extern
NTSTATUS
DfsPrefixTableAcquireWriteLock(
    struct _DFS_PREFIX_TABLE *pTable );

extern
NTSTATUS
DfsPrefixTableAcquireReadLock(
    struct _DFS_PREFIX_TABLE *pTable );


extern
NTSTATUS
DfsPrefixTableReleaseLock(
    struct _DFS_PREFIX_TABLE *pTable );

extern NTSTATUS
DfsPrefixTableInit(VOID);

extern
void
DfsPrefixTableShutdown(void);

VOID
DfsDumpPrefixTable(
   struct _DFS_PREFIX_TABLE *pPrefixTable,
   IN VOID (*DumpFunction)(PVOID pEntry));

VOID
DfsProcessPrefixTable(
   struct _DFS_PREFIX_TABLE *pPrefixTable,
   IN VOID (*DumpFunction)(PVOID pEntry));


NTSTATUS
DfsDismantlePrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN VOID (*ProcessFunction)(PVOID pEntry));

NTSTATUS
DfsInsertInPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData);

NTSTATUS
DfsFindUnicodePrefix(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PUNICODE_STRING pSuffix,
    IN PVOID *ppData);

NTSTATUS 
DfsRemoveFromPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData);

NTSTATUS
DfsReplaceInPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID pMatchingData);


NTSTATUS 
DfsRemoveFromPrefixTableEx(
    IN struct _DFS_PREFIX_TABLE * pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData);


NTSTATUS DfsRemoveFromPrefixTableLockedEx(
    IN struct _DFS_PREFIX_TABLE * pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData);


#ifdef WPP_CB_TYPE
// only define this if we are doing tracing
VOID
PrefixSetTraceControl(WPP_CB_TYPE *Control);

#endif

#define DfsReferencePrefixTable(_pTable) \
         DfsIncrementReference((PDFS_OBJECT_HEADER)(_pTable))
         
NTSTATUS
DfsDereferencePrefixTable(struct _DFS_PREFIX_TABLE *pTable );


NTSTATUS
DfsEnumeratePrefixTableLocked(
    IN struct _DFS_PREFIX_TABLE *pNameTable,
    IN VOID (*pfnCallback)(LPVOID pEntry, LPVOID pContext),
    LPVOID lpvClientContext);

#ifdef __cplusplus
}
#endif

#endif // __PREFIX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\midatlsp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the private data structures used in mapping MIDS
    to the corresponding requests/contexts associated with them. it's
    separated from the .c portion so the debugger extension can see it.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/


#ifndef _MIDATLAS_PRIVATE_H_
#define _MIDATLAS_PRIVATE_H_

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;

#endif //_MIDATLAX_PRIVATE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsumrctrl.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrCtrl.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/
     
#ifndef _DFSUMRCTRL_H_
#define _DFSUMRCTRL_H_

LONG 
AddUmrRef(void);

LONG 
ReleaseUmrRef(void);

BOOL 
IsUmrEnabled(void);

BOOLEAN 

LockUmrShared(void);

void 
UnLockUmrShared(void);

NTSTATUS 
DfsInitializeUmrResources(void);


void 
DfsDeInitializeUmrResources(void);


NTSTATUS
DfsStartupUMRx(void);


NTSTATUS
DfsTeardownUMRx(void);



NTSTATUS
DfsProcessUMRxPacket(
        IN PVOID InputBuffer,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer,
        IN ULONG OutputBufferLength,
        IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


PUMRX_ENGINE 
GetUMRxEngineFromRxContext(void);


NTSTATUS
DfsWaitForPendingClients(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfswarnings.h ===
#ifndef __DFS_WARNING_H__
#define __DFS_WARNING_H__

#include "warning.h"

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4702)   // Unreachable code
#pragma warning(error:4705)   // Statement has no effect
#pragma warning(error:4706)   // assignment w/i conditional expression
#pragma warning(error:4709)   // command operator w/o index expression
#pragma warning(error:4101)   // Unreferenced local variable
#pragma warning(error:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(error:4242)   // convertion possible loss of data
#pragma warning(error:4532)   // jump out of __finally block

#endif // defined __DFS_WARNING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfsumr.h ===
/*=========================================================================*\

    Module:      Dfsumr.h

    Copyright Microsoft Corporation 2001, All Rights Reserved.

    Author:      Rohan Phillips - Rohanp

    Description: User mode reflector header file

\*=========================================================================*/

#ifndef __DFSUMRSTRCT_H__
#define __DFSUMRSTRCT_H__

// This should be bumped whenever there are changes made to these structures
//
#define UMR_VERSION 1


#define MAX_USERMODE_REFLECTION_BUFFER 16384

#define UMRX_USERMODE_WORKITEM_CORRELATOR_SIZE 4

#define UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE  0x00000001
#define UMR_WORKITEM_HEADER_ASYNC_COMPLETE         0x00000002

#define DFSUMRSIGNATURE       'DFSU'    

//
//  enum definitions.
//
typedef enum _USERMODE_WORKITEMS_TYPES {
    opUmrIsDfsLink = 1,    // 0 is an invalid type
    opUmrGetDfsReplicas,
    opUmrMax
} USERMODE_WORKITEMS_TYPES;


//
// DFSFILTER_ATTACH/DETACH support
// VOlume and share file names are passed in the PathNameBuffer.
// Both strings are not null terminated, with the source name starting at
// the beginning of FileNameBuffer, and the destination name immediately
// following.
//

typedef struct _DFS_ATTACH_PATH_BUFFER_ {
    ULONG VolumeNameLength;
    ULONG ShareNameLength;
    ULONG Flags;
    WCHAR PathNameBuffer[1];
} DFS_ATTACH_PATH_BUFFER, *PDFS_ATTACH_PATH_BUFFER;


#define UMRX_STATIC_REQUEST_LENGTH(__requesttypefield,__lastfieldofrequest) \
    (FIELD_OFFSET(UMRX_USERMODE_WORKITEM,__requesttypefield.__lastfieldofrequest) \
    + sizeof(((PUMRX_USERMODE_WORKITEM)NULL)->__requesttypefield.__lastfieldofrequest))

#define UMR_ALIGN(x) ( ((x) % sizeof(double) == 0) ? \
                     ( (x) ) : \
                     ( (x) + sizeof(double) - (x) % sizeof(double) ) )

typedef struct _VarData
{
    ULONG cbData;
    ULONG cbOffset;     // offset from location of this structure
} VAR_DATA, *PVAR_DATA;

// opUmrIsDfsLink
//
typedef struct _UmrIsDfsLinkReq_
{
    ULONG       Length;
    BYTE        Buffer[1];  // start of vardata   
} UMR_ISDFSLINK_REQ, *PUMR_ISDFSLINK_REQ;

typedef struct _UmrIsDfsLinkResp_
{    
    BOOL        IsADfsLink;
} UMR_ISDFSLINK_RESP, *PUMR_ISDFSLINK_RESP;


// opUmrGetDfsreplicas
//
typedef struct _UmrGetDfsReplicasReq_
{
    REPLICA_DATA_INFO RepInfo;
} UMR_GETDFSREPLICAS_REQ, *PUMR_GETDFSREPLICAS_REQ;

typedef struct _UmrGetDfsReplicasResp
{
    ULONG      Length;
    BYTE       Buffer[1];  // start of vardata
} UMR_GETDFSREPLICAS_RESP, *PUMR_GETDFSREPLICAS_RESP;


// union for all request structs
//
typedef union _UMRX_USERMODE_WORK_REQUEST
{
    UMR_ISDFSLINK_REQ           IsDfsLinkRequest;
    UMR_GETDFSREPLICAS_REQ      GetDfsReplicasRequest;
} UMRX_USERMODE_WORK_REQUEST, *PUMRX_USERMODE_WORK_REQUEST;


// union for all response structs
//
typedef union _UMRX_USERMODE_WORK_RESPONSE
{
    UMR_ISDFSLINK_RESP           IsDfsLinkResponse;
    UMR_GETDFSREPLICAS_RESP      GetDfsReplicasResponse;
} UMRX_USERMODE_WORK_RESPONSE, *PUMRX_USERMODE_WORK_RESPONSE;


// header that's common to all requests and responses
//
typedef struct _UMRX_USERMODE_WORKITEM_HEADER {
    union {
        ULONG_PTR CorrelatorAsUInt[UMRX_USERMODE_WORKITEM_CORRELATOR_SIZE];
        double forcealignment;
    };
    IO_STATUS_BLOCK IoStatus;
    USERMODE_WORKITEMS_TYPES WorkItemType;
    DWORD       dwDebugSig;
    ULONG       ulHeaderVersion;
    ULONG       ulFlags;
} UMRX_USERMODE_WORKITEM_HEADER, *PUMRX_USERMODE_WORKITEM_HEADER;

// The top level structure.
//
typedef struct _UMRX_USERMODE_WORKITEM {
    UMRX_USERMODE_WORKITEM_HEADER Header;
    union {
        UMRX_USERMODE_WORK_REQUEST WorkRequest;
        UMRX_USERMODE_WORK_RESPONSE WorkResponse;
    };
    CHAR Pad[1];
} UMRX_USERMODE_WORKITEM, *PUMRX_USERMODE_WORKITEM;

typedef struct _DFS_FILTER_STARTUP_INFO {
    BOOLEAN IsDC;
    DWORD   Flags;
} DFS_FILTER_STARTUP_INFO, *PDFS_FILTER_STARTUP_INFO;

#define DFSFILTER_PROCESS_TERMINATION_FILEPATH L"\\ProcessTermination\\FilePath"

#define DFSFILTER_W32_DEVICE_NAME   L"\\\\.\\DfsFilter"
#define DFSFILTER_DEVICE_TYPE       0x1235

//
// 545483: ioctls need to have write access
//

#define DFSFILTER_START_UMRX          (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 100, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_STOP_UMRX           (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 101, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_PROCESS_UMRXPACKET  (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 102, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_GETREPLICA_INFO     (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 103, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_ATTACH_FILESYSTEM   (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 104, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_DETACH_FILESYSTEM   (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 105, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define DFSFILTER_PURGE_SHARELIST     (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 106, METHOD_BUFFERED, FILE_WRITE_ACCESS )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfswmi.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    dfswmi.h

Abstract:

    DFS specific wmi tracing declarations

Authors:

    Rohanp     28-Feb-2001

Environment:

    User/Kernel

Notes:

Revision History:


--*/

//
// this will let us use null strings in the wmi macros.
//
#define WPP_CHECK_FOR_NULL_STRING 1

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(DfsFilter,(27246e9d,b4df,4f20,b969,736fa49ff6ff), \
      WPP_DEFINE_BIT(KUMR_EVENT)     \
      WPP_DEFINE_BIT(KUMR_ERROR)     \
      WPP_DEFINE_BIT(KUMR_DETAIL)    \
                                      \
      WPP_DEFINE_BIT(PREFIX) \
      WPP_DEFINE_BIT(USER_AGENT)\
                                      \
      WPP_DEFINE_BIT(REFERRAL_SERVER)\
                                      \
      WPP_DEFINE_BIT(API)\
      WPP_DEFINE_BIT(REFERRAL)\
      WPP_DEFINE_BIT(STATISTICS) \
                                      \
      WPP_DEFINE_BIT(ADBLOB) \
      WPP_DEFINE_BIT(STANDALONE) \
      WPP_DEFINE_BIT(ALL_ERRORS)     \
      WPP_DEFINE_BIT(SITE)     \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\dfswpp.inc ===
# Define functions used for logging
#   TraceLog(,,ID,GRP,MSG,ARG)
#     ID - indicates where we should look for ID (required)
#     GRP - indicates what group this message belongs to (optional. Default 1)
#     MSG - what message needs to be used (optional. Default="ID(args)")
#     ARG - list of arguments (optional. Default = "no args")

DFS_TRACE_HIGH(,MSG,ARG);
DFS_TRACE_NORM(,MSG,ARG);
DFS_TRACE_LOW(,MSG,ARG);
DFS_TRACE_ERROR_HIGH(,,MSG,ARG);
DFS_TRACE_ERROR_NORM(,,MSG,ARG);
DFS_TRACE_ERROR_LOW(,,MSG,ARG);


DEFINE_CPLX_TYPE(WSTR_CHK, LOGWSTR_CHK, LPCWSTR, ItemWString,  "s", s, 0);
DEFINE_CPLX_TYPE(ASTR_CHK, LOGASTR_CHK, LPCSTR, ItemAString,  "s", s, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\midatlax.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAX_H_
#define _MIDATLAX_H_

typedef struct _RX_MID_ATLAS {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      NumberOfMidsDiscarded;
   USHORT      MaximumMidFieldWidth;
   USHORT      Reserved;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} RX_MID_ATLAS, *PRX_MID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

typedef
VOID (*PCONTEXT_ITERATOR)(
	PVOID pContext);

#define RxGetMaximumNumberOfMids(pMidAtlas) \
        ((pMidAtlas)->MaximumNumberOfMids)

#define RxGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

PRX_MID_ATLAS
RxCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

VOID
RxDestroyMidAtlas(
         PRX_MID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

void
RxIterateMidAtlasAndRemove(
		PRX_MID_ATLAS pMidAtlas,
		PCONTEXT_ITERATOR pContextIterator);

PVOID
RxMapMidToContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid);

NTSTATUS
RxAssociateContextWithMid(
         PRX_MID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

NTSTATUS
RxMapAndDissociateMidFromContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

NTSTATUS
RxReassociateMid(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\rxcontx.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rxcontx.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _DFSRXCONTX_H_
#define _DFSRXCONTX_H_

typedef
NTSTATUS
(NTAPI *DFS_CALLDOWN_ROUTINE) (
    IN OUT PVOID pCalldownParameter);

#define MRX_CONTEXT_FIELD_COUNT    4

typedef struct _RX_CONTEXT {

    ULONG                   Signature;

    ULONG                   ReferenceCount;

    ULONG                   Flags;

    NTSTATUS                Status;

    ULONG                   OutputBufferLength;

    ULONG                   InputBufferLength;

    ULONG                   ReturnedLength;

    PDEVICE_OBJECT          RealDevice;

    PVOID                   OutputBuffer;

    PVOID                   InputBuffer;

    DFS_CALLDOWN_ROUTINE    CancelRoutine;

    PVOID                   UMRScratchSpace[MRX_CONTEXT_FIELD_COUNT] ;

    // The original thread in which the request was initiated and the last
    // thread in which some processing associated with the context was done

    PETHREAD                 OriginalThread;
    PETHREAD                 LastExecutionThread;

    //  ptr to the originating Irp
    PIRP                    CurrentIrp;

    //event
    KEVENT                  SyncEvent;


    // the list entry to wire the context to the list of active contexts

    LIST_ENTRY              ContextListEntry;
}RX_CONTEXT, *PRX_CONTEXT;

#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        }
        
#define DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS 0x00000001
#define DFS_CONTEXT_FLAG_CANCELLED          0x00000002
#define DFS_CONTEXT_FLAG_ASYNC_OPERATION    0x00000004
#define DFS_CONTEXT_FLAG_FILTER_INITIATED   0x00000008

#define  RxWaitSync(RxContext)                                                   \
         (RxContext)->Flags |= DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             

#define  RxWaitSyncWithTimeout(RxContext,pliTimeout)                             \
         (RxContext)->Flags |= DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         Status = KeWaitForSingleObject( &(RxContext)->SyncEvent,                \
                               Executive, KernelMode, FALSE, pliTimeout );       
                               

#define RxSignalSynchronousWaiter(RxContext)                       \
        (RxContext)->Flags &= ~DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )
        

NTSTATUS 
DfsInitializeContextResources(void);

NTSTATUS 
DfsDeInitializeContextResources(void);

VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
RxInitializeContext(
    IN PIRP            Irp,
    IN OUT PRX_CONTEXT RxContext);


PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

NTSTATUS
RxSetMinirdrCancelRoutine(
    IN  OUT PRX_CONTEXT   RxContext,    
    IN      DFS_CALLDOWN_ROUTINE MRxCancelRoutine);

#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
                                                   }
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\shash.h ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shash.h
//
//  Contents:   Generic hashtable
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifndef __SHASHTABLE_H__
#define __SHASHTABLE_H__

#pragma warning(disable: 4200)

#ifdef __cplusplus
extern "C" {
#endif

//forward declaration
struct _SHASH_TABLE;

struct _SHASH_HEADER;

// This function computes the hash value
//
typedef ULONG (*PFNHASH)( void*      pvKey ) ;

//
// This function compares the keys
//
typedef int (*PFNMATCHKEY)( void*  key1, void*     key2 ) ;


//
// This function gets called when the keys get removed
//
typedef int (*PFNREMOVEKEY)(struct _SHASH_HEADER * pHeader) ;


//
// This function gets called when the keys get removed
//
typedef DWORD (*PFNENUMERATEKEY)(struct _SHASH_HEADER * pHeader, void * pContext ) ;


// memory allocations function
typedef void*   (*PFNALLOC)(    ULONG   cb ) ;


// memory free function
typedef void    (*PFNFREE)(     void*   lpv ) ;

//
//      This function allocs memory for the tables lock
//
typedef void *      (*PFNALLOCLOCK)( void ) ;

//
//      This function releases the lock  memory
//
typedef void        (*PFNFREELOCK)( void * ) ;


typedef BOOLEAN            (*PFNAQUIREWRITELOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNAQUIREREADLOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNRELEASEWRITELOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNRELEASEREADLOCK)( struct _SHASH_TABLE * pTable ) ;


#define SHASH_DEFAULT_HASH_SIZE 512
#define SHASH_CRIT_SPIN_COUNT   4000

//
// There are flags that are not used by shash, they can be used by
// the caller.
//
#define SHASH_USER_FLAGS        0xFFFF0000

typedef struct _SHASH_HEADER
{
    ULONG Signature;
    ULONG Flags;
    PVOID pvKey;
    PVOID pData;
    LONG  RefCount;
    ULONG dwHash;
    FILETIME Time;
    LIST_ENTRY ListEntry;
}SHASH_HEADER, *PSHASH_HEADER;

#define SHASH_FLAG_DELETE_PENDING    0x00000001

typedef struct _SHASHFUNCTABLE 
{
    PFNHASH HashFunc;
    PFNMATCHKEY CompareFunc;
    PFNALLOC AllocFunc;
    PFNFREE  FreeFunc;
    PFNALLOC AllocHashEntryFunc;
    PFNFREE  FreeHashEntryFunc;
    PFNALLOCLOCK AllocLockFunc;
    PFNFREELOCK  FreeLockFunc;
    PFNAQUIREWRITELOCK WriteLockFunc;
    PFNAQUIREREADLOCK ReadLockFunc;
    PFNRELEASEWRITELOCK ReleaseWriteLockFunc;
    PFNRELEASEREADLOCK ReleaseReadLockFunc;
    ULONG   Flags;
    ULONG   NumBuckets;
} SHASH_FUNCTABLE, *PSHASH_FUNCTABLE;

typedef struct _SHASH_BUCKET 
{
    ULONG Count;
    LIST_ENTRY ListHead;
} SHASH_BUCKET, *PHASH_SBUCKET;

typedef struct _SHASH_ENTRY 
{
    PVOID pvKey;
    LONG  RefCount;
    ULONG Flags;
    PVOID pData;
    LARGE_INTEGER EntryTime;
    LARGE_INTEGER ExpireTime;
    LIST_ENTRY ListEntry;
} SHASH_ENTRY, *PSHASH_ENTRY;

typedef struct _SHASH_TABLE 
{
    PFNHASH HashFunc;
    PFNMATCHKEY CompareFunc;
    PFNALLOC AllocFunc;
    PFNFREE  FreeFunc;
    PFNALLOC AllocHashEntryFunc;
    PFNFREE FreeHashEntryFunc;
    PFNALLOCLOCK AllocLockFunc;
    PFNFREELOCK  FreeLockFunc;
    PFNAQUIREWRITELOCK WriteLockFunc;
    PFNAQUIREREADLOCK ReadLockFunc;
    PFNRELEASEWRITELOCK ReleaseWriteLockFunc;
    PFNRELEASEREADLOCK ReleaseReadLockFunc;
    LONG    Version;
    ULONG   Flags;
    ULONG   NumBuckets;
    ULONG   TotalItems;
    PVOID   pLock;
    SHASH_BUCKET HashBuckets[0];
} SHASH_TABLE, *PSHASH_TABLE;

#define SHASH_CAP_POWER_OF2         0x000001
#define SHASH_CAP_TABLE_LOCKED      0x000002
#define SHASH_CAP_NOSEARCH_INSERT   0x000004

#define SHASH_DEFAULT_HASHTIMEOUT   (15 * 60) //timeout entries in 15 minutes

#define SHASH_REPLACE_IFFOUND   1
#define SHASH_FAIL_IFFOUND      2

#ifdef KERNEL_MODE
#define SHASH_GET_TIME(Time) KeQuerySystemTime(Time)
#else
#define SHASH_GET_TIME(Time) NtQuerySystemTime(Time)
#endif


typedef struct _SHASH_ITERATOR {
    //
    //  index
    //
    ULONG           index;

    LIST_ENTRY*     pListHead;

    //
    //
    LIST_ENTRY*     ple;

    PSHASH_HEADER   pEntry;

} SHASH_ITERATOR,*PSHASH_ITERATOR;

NTSTATUS 
ShashInitHashTable(
    PSHASH_TABLE *ppHashTable,
    PSHASH_FUNCTABLE pFuncTable);


void 
ShashTerminateHashTable(
    PSHASH_TABLE pHashTable
    );


NTSTATUS
SHashInsertKey(IN   PSHASH_TABLE    pTable, 
               IN   void *  pData,
               IN   void *  pvKeyIn,
               IN   DWORD   InsertFlag
               );



NTSTATUS    
SHashRemoveKey( IN  PSHASH_TABLE    pTable, 
                IN  void *      pvKeyIn,
                IN  PFNREMOVEKEY pRemoveFunc
                );


PSHASH_HEADER   
SHashLookupKeyEx(   IN  PSHASH_TABLE pTable, 
                IN  void*       pvKeyIn
                );


NTSTATUS    
SHashIsKeyInTable(  IN  PSHASH_TABLE pTable, 
                    IN  void*       pvKeyIn
                 );


NTSTATUS    
SHashGetDataFromTable(  IN  PSHASH_TABLE pTable, 
                        IN  void*       pvKeyIn,
                        IN  void ** ppData
                     );

NTSTATUS
ShashEnumerateItems(IN  PSHASH_TABLE pTable, 
                    IN  PFNENUMERATEKEY     pfnCallback, 
                    IN  LPVOID              lpvClientContext
                    );  


NTSTATUS    
SHashReleaseReference(  IN  PSHASH_TABLE pTable, 
                        IN  PSHASH_HEADER pData
                     );


PSHASH_HEADER
SHashStartEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        );

PSHASH_HEADER
SHashNextEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable);


VOID
SHashFinishEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        );


NTSTATUS    
SHashMarkForDeletion(  IN  PSHASH_TABLE pTable, 
                       IN  PSHASH_HEADER pData
                     );

#ifdef __cplusplus
}
#endif

#pragma warning(default: 4200)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\umrx.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    umrx.h

Abstract:

    This header defines the UMRxEngine object and associated functions.
    The UMRxEngine provides a set of services for dispatch function
    writers so they can reflect requests to user-mode components.

Notes:

    Code / Ideas have been adopted from Joe Linn's user-mode reflector

Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _UMRX_H_
#define _UMRX_H_

//
//  defines and tags
//
#define UMRX_ENGINE_TAG                  (ULONG) 'xrmU'
#define UMRX_CONTEXT_TAG                 (ULONG) 'xtcU'

#define REASSIGN_MID        1
#define DONT_REASSIGN_MID   0

#define TICKS_PER_SECOND (10 * 1000 * 1000)

typedef USHORT          NODE_TYPE_CODE;
typedef CSHORT          NODE_BYTE_SIZE;

typedef struct _MRX_NORMAL_NODE_HEADER {
   NODE_TYPE_CODE           NodeTypeCode;
   NODE_BYTE_SIZE           NodeByteSize;
   ULONG                    NodeReferenceCount;
} MRX_NORMAL_NODE_HEADER;


enum {
    UMRX_ENGINE_STATE_STOPPED = 0,
    UMRX_ENGINE_STATE_STARTING,
    UMRX_ENGINE_STATE_STARTED,
    UMRX_ENGINE_STATE_STOPPING
};

//
//  Define the UMRxEngine object. There is one such object for
//  every NET_ROOT. This object contains all the data str needed
//  for routing kernel-mode requests to user-mode.
//
typedef struct _UMRX_ENGINE {
    // MID to UMRxContext mapping table
    struct {
        PRX_MID_ATLAS MidAtlas;
        FAST_MUTEX MidManagementMutex;
        LIST_ENTRY WaitingForMidListhead;
    };
    struct {
        KQUEUE Queue;
        LARGE_INTEGER TimeOut;
        LIST_ENTRY PoisonEntry;
        ULONG NumberOfWorkerThreads;
        ULONG NumberOfWorkItems;
        ERESOURCE Lock;
        ULONG State;
        ULONG ThreadAborted;
    } Q;    
    ULONG NextSerialNumber;
    ULONG cUserModeReflectionsInProgress;
    LIST_ENTRY ActiveLinkHead;
} UMRX_ENGINE, *PUMRX_ENGINE;


void
UMRxAbortPendingRequests(IN PUMRX_ENGINE pUMRxEngine);

//
//  Forwards
//
struct _UMRX_CONTEXT;
typedef struct _UMRX_CONTEXT    *PUMRX_CONTEXT;

//
//  Signatures for function pointers
//

//
//  Continue routine is called by InitiateRequest -
//  This turns around and submits the request to the
//  UMR engine with callbacks for FORMAT and COMPLETION.
//
typedef
NTSTATUS
(*PUMRX_CONTINUE_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext
    );

//
//  Format routine - called before user-mode worker thread completes.
//  Each dispatch routine will interpret the WORK_ITEM union based on opcode.
//  eg: for Create, WorkItem is a CREATE_REQUEST.
//
typedef
NTSTATUS
(*PUMRX_USERMODE_FORMAT_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength,
    PULONG ReturnedLength
    );

//
//  Completion routine - called when user-mode response is received.
//  Each dispatch routine will interpret the WORK_ITEM union based on opcode.
//  eg: for Create, WorkItem is a CREATE_RESPONSE.
//
typedef
VOID
(*PUMRX_USERMODE_COMPLETION_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength
    );

//
//  Type of operation reflected to user-mode
//
typedef enum _UMRX_CONTEXT_TYPE {
    UMRX_CTXTYPE_IFSDFSLINK = 0,
    UMRX_CTXTYPE_GETDFSREPLICAS,
    UMRX_CTXTYPE_MAXIMUM
} UMRX_CONTEXT_TYPE;

//
//  Define the UMRxContext. This context is sent as part of
//  the REQUEST to user-mode. The user-mode handler will
//  send the context back in a RESPONSE. The context will be
//  used to do the rendezvous with blocked requests.
//

#define UMRX_NTC_CONTEXT    ((USHORT)0xedd0)

typedef struct _UMRX_CONTEXT{
    MRX_NORMAL_NODE_HEADER;
    PUMRX_ENGINE pUMRxEngine;   // owning engine object
    PRX_CONTEXT RxContext;
    PVOID SavedMinirdrContextPtr;
    union {
        IO_STATUS_BLOCK;
        IO_STATUS_BLOCK IoStatusBlock;
    };
    UMRX_CONTEXT_TYPE CTXType;
    PUMRX_CONTINUE_ROUTINE Continuation;
    struct {
        LIST_ENTRY WorkQueueLinks;
        PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine;
        PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine;
        KEVENT WaitForMidEvent;
        ULONG CallUpSerialNumber;
        USHORT CallUpMid;
    } UserMode;
    LIST_ENTRY ActiveLink;
} UMRX_CONTEXT, *PUMRX_CONTEXT;

#define UMRxReferenceContext(pUMRxContext) {\
        ULONG result = InterlockedIncrement(&(pUMRxContext)->NodeReferenceCount); \
        RxDbgTrace(0, (DEBUG_TRACE_UMRX), \
                    ("ReferenceContext result=%08lx\n", result )); \
        }
    
typedef struct _UMRX_WORKITEM_HEADER_PRIVATE {
    PUMRX_CONTEXT pUMRxContext;
    ULONG SerialNumber;
    USHORT Mid;
} UMRX_WORKITEM_HEADER_PRIVATE, *PUMRX_WORKITEM_HEADER_PRIVATE;

//
//  Create a UMRX_ENGINE object
//
PUMRX_ENGINE
CreateUMRxEngine();

//
//  Close a UMRX_ENGINE object -
//  Owner of object ensures that all usage of this object
//  is within the Create/Finalize span.
//
VOID
FinalizeUMRxEngine(
    IN PUMRX_ENGINE pUMRxEngine
    );

//
//  Complete queued requests and optional cleanup when the store has exited
//
NTSTATUS
UMRxEngineCompleteQueuedRequests(
                  IN PUMRX_ENGINE pUMRxEngine,
                  IN NTSTATUS     CompletionStatus,
                  IN BOOLEAN      fCleanup
                 );
//
//  Used to allow an engine to be used again after it's been shutdown.
//
//
NTSTATUS
UMRxEngineRestart(
                  IN PUMRX_ENGINE pUMRxEngine
                 );

//
//  Initiate a request to the UMR engine -
//  This creates a UMRxContext that is used for response rendezvous.
//  All IFS dispatch routines will start a user-mode reflection by
//  calling this routine. Steps in routine:
//
//  1. Allocate a UMRxContext and set RxContext
//     (NOTE: need to have ASSERTs that validate this linkage)
//  2. Set Continue routine ptr and call Continue routine
//  3. If Continue routine is done ie not PENDING, Finalize UMRxContext
//
NTSTATUS
UMRxEngineInitiateRequest (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_CONTINUE_ROUTINE Continuation
    );

//
//  Create/Finalize UMRX_CONTEXTs
//  These are pool allocs/frees
//
PUMRX_CONTEXT
UMRxCreateAndReferenceContext (
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType
    );


BOOLEAN
UMRxDereferenceAndFinalizeContext (
    IN OUT PUMRX_CONTEXT pUMRxContext
    );

//
//  Submit a request to the UMR engine -
//  This adds the request to the engine KQUEUE for processing by
//  a user-mode thread. Steps:
//  
//  1. set the FORMAT and COMPLETION callbacks in the UMRxContext
//  2. initialize the RxContext sync event
//  3. insert the UMRxContext into the engine KQUEUE
//  4. block on RxContext sync event (for SYNC operations)
//  5. after unblock (ie umode response is back), call Resume routine
//



NTSTATUS
UMRxEngineSubmitRequest(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   pRxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine
    );

//
//  Resume is called after I/O thread is unblocked by umode RESPONSE.
//  This routine calls any Finish callbacks and then Finalizes the 
//  UMRxContext.
//
NTSTATUS
UMRxResumeEngineContext(
    IN OUT PRX_CONTEXT RxContext
    );

//
//  The following functions run in the context of user-mode
//  worker threads that issue WORK IOCTLs. The IOCTL calls the
//  following functions in order:
//  1. UMRxCompleteUserModeRequest() - process a response if needed
//  2. UMRxEngineProcessRequest()  - process a request if one is
//     available on the UMRxEngine KQUEUE. Since these IOCTLs are
//     made on a NET_ROOT, the corresponding UMRxEngine is readily
//     available in the NET_ROOT extension.
//

//
//  Every IOCTL pended is potentially a Response. If so, process it.
//  The first IOCTL pended is usually a NULL Response or 'listen'.
//  Steps:
//  1. Get MID from response buffer. Map MID to UMRxContext.
//  2. Call UMRxContext COMPLETION routine.
//  3. Unblock the I/O thread waiting in UMRxEngineSubmitRequest()
//
NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    IN BOOLEAN fReleaseUmrRef,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT BOOLEAN * pfReturnImmediately
    );

//
//  NOTE: if no requests are available, the user-mode thread will
//  block till a request is available (It is trivial to make this
//  a more async model).
//  
//  If a request is available, get the corresponding UMRxContext and
//  call ProcessRequest.
//  Steps:
//  1. Call KeRemoveQueue() to remove a request from the UMRxEngine KQUEUE.
//  2. Get a MID for this UMRxContext and fill it in the WORK_ITEM header.
//  3. Call the UMRxContext FORMAT routine - this fills in the Request params.
//  4. return STATUS_SUCCESS - this causes the IOCTL to complete which
//     triggers the user-mode completion and processing of the REQUEST.
//
NTSTATUS
UMRxEngineProcessRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    OUT PULONG FormattedWorkItemLength
    );

//
//  This is called in response to a WORK_CLEANUP IOCTL.
//  This routine will insert a dummy item in the engine KQUEUE.
//  Each such dummy item inserted will release one thread.
//
NTSTATUS
UMRxEngineReleaseThreads(
    IN PUMRX_ENGINE pUMRxEngine
    );

//
//  Cancel I/O infrastructure
//
typedef
NTSTATUS
(NTAPI *PUMRX_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

// The RX_CONTEXT instance has four fields ( ULONG's ) provided by the wrapper
// which can be used by the mini rdr to store its context. This is used by
// the reflector to identify the parameters for request cancellation

typedef struct _UMRX_RX_CONTEXT {
    PUMRX_CANCEL_ROUTINE      pCancelRoutine;
    PVOID                     pCancelContext;
    union {
        struct {
            PUMRX_CONTEXT     pUMRxContext;
            ULONG             RxSyncTimeout;
        };
        IO_STATUS_BLOCK SyncCallDownIoStatus;
    };
} UMRX_RX_CONTEXT, *PUMRX_RX_CONTEXT;

#define UMRxGetMinirdrContext(pRxContext)     \
        ((PUMRX_RX_CONTEXT)(&(pRxContext)->UMRScratchSpace[0]))

#endif // _UMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\prefix\name_table.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.c
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------
#define NAME_TABLE_C
#ifdef KERNEL_MODE

#include <ntifs.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <wmlkm.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#include "name_table.h"




//+-------------------------------------------------------------------------
//
//  Function:   DfsInitNameTable - Creates and initializes the DFS Name table.
//
//  Synopsis:   DfsInitNameTable allocates space for the space table. It then 
//              initializes the lock and the hash buckets in the table and 
//              returns the allocated name table.
//
//  Arguments:  NumBuckets - Number of Buckets in the name table hash.
//              ppNameTable - Pointer to name table pointer.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could allocate the table.
//               STATUS_INSUFFICIENT_RESOURCES otherwise.
//
//
//  Description: The DFS NameTable is the starting point for all DFS namespace
//               lookups. The NameTable hash buckets hold the root objects of
//               all DFS's known to this server. The hash is based on the
//               netbios DFS Naming context (which is the netbios 
//               domain/forest/machine name and the DFS Share name of the form
//              \NetbiosName\\Sharename.)
//
//--------------------------------------------------------------------------


NTSTATUS
DfsInitializeNameTable(
                IN ULONG NumBuckets,
                OUT PDFS_NAME_TABLE *ppNameTable)
{
    PDFS_NAME_TABLE pNameTable = NULL;
    PDFS_NAME_TABLE_BUCKET pBucket = NULL;
    ULONG HashTableSize;
    PCRITICAL_SECTION pLock = NULL;
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;


    if ( NumBuckets == 0 ) {
        NumBuckets = DEFAULT_NAME_TABLE_SIZE;
    }

    HashTableSize = sizeof(DFS_NAME_TABLE) + 
                    NumBuckets * sizeof(DFS_NAME_TABLE_BUCKET);

    do { 
        pNameTable = ALLOCATE_MEMORY(HashTableSize + sizeof(CRITICAL_SECTION));

        if ( pNameTable == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(pNameTable, HashTableSize + sizeof(CRITICAL_SECTION));

        DfsInitializeHeader( &(pNameTable->DfsHeader),
                             DFS_OT_NAME_TABLE,
                             HashTableSize + sizeof(CRITICAL_SECTION));

        pLock = (PCRITICAL_SECTION)((ULONG_PTR)pNameTable + HashTableSize);
        if (InitializeCriticalSectionAndSpinCount(pLock, DFS_NAMETABLE_CRIT_SPIN_COUNT) != TRUE)
        {
            Status = GetLastError();  
            break;
        }

        pNameTable->NumBuckets = NumBuckets;
        pNameTable->pLock = (PVOID)pLock;
        pNameTable->Flags = 0;
        for ( i = 0; i < NumBuckets; i++ ) {
            pBucket = &(pNameTable->HashBuckets[i]);

            InitializeListHead(&pBucket->ListHead);
            pBucket->Count = 0;

        }
    } while (FALSE);

    if ( Status == STATUS_SUCCESS ) {

        *ppNameTable = pNameTable;
        
    } else {

        if (pNameTable != NULL) {
            FREE_MEMORY( pNameTable );
        }
    }

    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsInsertInNameTable - Inserts the passed in Entry into table
//
//  Synopsis:   DfsInsertInNameTable checks and makes sure that another entry
//              with matching name does not already exist in the table.
//              It Inserts the passed in Entry in the appropriate hash bucket,
//              The callers needs to take a reference on the object and this
//              reference is passed on to the name table. The name table does
//              not explicitly take a reference on the Entry object.
//
//
//  Arguments:  pEntry - The Entry to be inserted
//
//  Returns:    Status
//               STATUS_OBJECT_NAME_COLLISION if name already exists in table
//               STATUS_SUCCESS otherwise
//
//
//  Description: The object representing the entry is assumed to be completely
//               setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               find the entry.
//               This call checks the name table to see if the Named Entry in 
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appro<priate
//               bucket, and we are done.
//               A reference is held on the Entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               Entry or destro<y it.)
//               This reference is released when the Entry is removed from the
//                name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInsertInNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pName,
    IN PVOID pData )
{
    ULONG BucketNum;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_NAME_TABLE_ENTRY  pEntry;
    PDFS_NAME_TABLE_ENTRY  pMatchingEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;

    GET_NAME_TABLE_BUCKET(pName, pNameTable, BucketNum);

    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];


    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access it
    // after the bucket lock is released)

    Status = DfsCheckNameTable( pName,
                                pBucket,
                                &pMatchingEntry);

    // If the name already exists, then we fail the request. For all other
    // error conditions except OBJECT_NOT_FOUND, return failure status intact.
    // In case the object is not found, it is safe to insert this in the bucket,
    // and return success.
    if ( Status == STATUS_SUCCESS ) {
        Status = STATUS_OBJECT_NAME_COLLISION;
    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        pEntry = ALLOCATE_MEMORY(sizeof(DFS_NAME_TABLE_ENTRY));
        if (pEntry != NULL) {
            pEntry->pName = pName;
            pEntry->pData = pData;
            InsertHeadList(&pBucket->ListHead, &pEntry->NameTableLink);
            pBucket->Count++;
            Status = STATUS_SUCCESS;
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupNameTable - Looks for a name in the name table
//
//  Arguments:  lookupName - Unicode string of Entry
//              lookupNC   - The Naming Context of interest
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: The Entry is assumed to be completely setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               lookup the entry.
//               This call checks the name table to see if the Named entry in the
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appropriate
//               bucket, and we are done.
//               A reference is held on the entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               entry or destroy it.)
//               This reference is released when the entry is removed from the
//               name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsLookupNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pLookupName, 
    OUT PVOID *ppData )
{

    ULONG BucketNum;
    NTSTATUS Status;
    PDFS_NAME_TABLE_BUCKET pBucket;
    PDFS_NAME_TABLE_ENTRY pMatchEntry;
    
    GET_NAME_TABLE_BUCKET( pLookupName, pNameTable, BucketNum );

    pBucket = &pNameTable->HashBuckets[BucketNum];

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pMatchEntry );
    if (Status == STATUS_SUCCESS) {
        *ppData = pMatchEntry->pData;
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsGetEntryNameTableLocked - Looks for a name in the name table
//
//  Arguments:  lookupName - Unicode string of Entry
//              lookupNC   - The Naming Context of interest
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: The Entry is assumed to be completely setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               lookup the entry.
//               This call checks the name table to see if the Named entry in the
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appropriate
//               bucket, and we are done.
//               A reference is held on the entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               entry or destroy it.)
//               This reference is released when the entry is removed from the
//               name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsGetEntryNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    OUT PVOID *ppData )
{

    ULONG BucketNum;
    NTSTATUS Status = STATUS_NOT_FOUND;

    PDFS_NAME_TABLE_BUCKET pBucket;
    PDFS_NAME_TABLE_ENTRY pEntry;
    PLIST_ENTRY pListHead, pLink;

    for (BucketNum = 0; BucketNum < pNameTable->NumBuckets; BucketNum++)
    {
        pBucket = &pNameTable->HashBuckets[BucketNum];
        if (pBucket->Count == 0)
        {
            continue;
        }
        pListHead = &pBucket->ListHead;
        pLink = pListHead->Flink;
        if (pLink == pListHead)
        {
            continue;
        }

        pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

        *ppData = pEntry->pData;
        Status = STATUS_SUCCESS;
        break;
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCheckNameTable - Check for a name in the name table
//
//  Arguments:  lookupName - Unicode string of name
//              lookupNC   - The DFS Naming Context of interest
//              pBucket    - The bucket of interest.
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: It is assumed that appropriate locks are taken to traverse
//               the links in the bucket.
//               If an entry is found, it is returned without taking any
//               references on the found object.
//--------------------------------------------------------------------------


NTSTATUS
DfsCheckNameTable(
    IN PUNICODE_STRING pLookupName, 
    IN PDFS_NAME_TABLE_BUCKET pBucket,
    OUT PDFS_NAME_TABLE_ENTRY *ppMatchEntry )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PLIST_ENTRY pListHead, pLink;
    PDFS_NAME_TABLE_ENTRY pEntry;

    pListHead = &pBucket->ListHead;

    for ( pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink ) {

        pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

        // If we find a matching Name, check if we are interested in a 
        // specific Naming context. If no naming context is specified, or the 
        // specified naming context matches, we have found our entry. Get a 
        // reference on the entry while the bucket is locked so the entry does 
        // not go away, and we can return avalid pointer to the caller.
        // The caller is responsible for releasing this reference.
        if (RtlCompareUnicodeString(pEntry->pName, pLookupName, TRUE) == 0) {
            Status = STATUS_SUCCESS;
            break;
        }

    }

    // If we did find an entry, return it
    if ( Status == STATUS_SUCCESS ) {
        *ppMatchEntry = pEntry;
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromNameTable - Removes the specified entry
//                                       from the name table
//
//  Arguments:  pEntry - The entry to be removed.
//
//  Returns:    Status
//               STATUS_SUCCESS if the specified entry was successfully removed.
//               STATUS_NOT_FOUND if the specifed entry is not the entry in the 
//                       table for that entry name.
//               STATUS_OBJECT_NAME_NOT_FOUND  if the entry name does not exist 
//                       in the table
//
//  Description: The passed in entry is expected to a valid pointer that will 
//               not be freed up while we are referencing it.
//               We check for an object in the name table for a matching name.
//               If the object in the name table matches the passed in object,
//               we can safely remove it from the name table. When we do so,
//               we also release the reference on the object that was held
//               when the object was inserted into the table.
//               If the object is not found or the object does not match the
//               one in the table, error status is returned.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRemoveFromNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN PVOID pData )

{
    NTSTATUS Status;
    PDFS_NAME_TABLE_ENTRY pMatchingEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;
    ULONG BucketNum;


    GET_NAME_TABLE_BUCKET(pLookupName, pNameTable, BucketNum );
    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];

    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access 
    // it after the bucket lock is released)

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pMatchingEntry);


    // If we found an entry for the specified Name and NC, and the entry
    //  matches the pointer passed in, we remove the entry from the bucket. 
    // If the object does not match, we set the status to STATUS_NOT_FOUND,
    //  to indicate that the name of the object exists in the table, but 
    // the object in the table is different.

    if ( Status == STATUS_SUCCESS ) {
        if ( (pData == NULL) || (pMatchingEntry->pData == pData) ) {
            RemoveEntryList(&pMatchingEntry->NameTableLink);
            FREE_MEMORY( pMatchingEntry );
            pBucket->Count--;
        } else {
            Status = STATUS_NOT_FOUND;
        }
    }

    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsReplaceInNameTable - Removes an entry by the specified name, 
//                                      if one exists. The passed in entry is 
//                                      inserted into the table.
//
//  Arguments:  pNewEntry - The entry to be inserted in the table
//
//  Returns:    Status
//               STATUS_SUCCESS if the passed in entry was inserted in the table
//
//  Description: The caller needs to hold a reference to the passed in entry, 
//               and this reference is transferred to the name table.
//               If the name exists in the name table, the object is removed
//               from the nametable and its reference is discarded.
//               The passed in object is inserted in the same bucket.
//               This call allows an atomic replace of the entry object, 
//               avoiding a window during which a valid name may not be found
//               in the name table.
//
//               Note that the newentry being passed in may already be
//               in the table (due to multiple threads doing this work) so
//               that special situation should work.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsReplaceInNameTableLocked (
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN OUT PVOID *ppData )
{
    PDFS_NAME_TABLE_ENTRY pEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;
    ULONG BucketNum;
    PVOID pOldData = NULL;
    NTSTATUS Status;

    GET_NAME_TABLE_BUCKET(pLookupName, pNameTable, BucketNum );
    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];

    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access
    // it after the bucket lock is released)

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pEntry );

    // If we found a matching name, we remove it from the name table.
    if ( Status == STATUS_SUCCESS ) {
        pOldData = pEntry->pData;
        pEntry->pName = pLookupName;
        pEntry->pData = *ppData;
    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        pEntry = ALLOCATE_MEMORY(sizeof(DFS_NAME_TABLE_ENTRY));
        if (pEntry != NULL) {
            pEntry->pName = pLookupName;
            pEntry->pData = *ppData;
            InsertHeadList(&pBucket->ListHead, &pEntry->NameTableLink);
            pBucket->Count++;

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        *ppData = pOldData;
    }

    return Status;
}



VOID
DumpNameTable(
    PDFS_NAME_TABLE pNameTable )
{
    PDFS_NAME_TABLE_BUCKET pBucket;
    PLIST_ENTRY pListHead, pLink;
    PDFS_NAME_TABLE_ENTRY pEntry;
    ULONG i;

    printf("Table %p type %x size %d RefCnt %d\n",
           pNameTable, 
           DfsGetHeaderType(&pNameTable->DfsHeader),
           DfsGetHeaderSize(&pNameTable->DfsHeader),
           DfsGetHeaderCount(&pNameTable->DfsHeader));

    printf("Number of buckets %d\n", pNameTable->NumBuckets);

    for ( i = 0; i < pNameTable->NumBuckets; i++ ) {
        pBucket = &pNameTable->HashBuckets[i];
        if ( pBucket->Count == 0 )
            continue;

        printf("Bucket %d Count in bucket %d\n",
               i,
               pBucket->Count);

        pListHead = &pBucket->ListHead;
        for ( pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink ) {
            pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

            printf("Found entry %p Name %wZ\n",
                   pEntry, pEntry->pName);
        }
    }
    return;
}



NTSTATUS
DfsDismantleNameTable(
    PDFS_NAME_TABLE pNameTable )

{
    PDFS_NAME_TABLE_BUCKET pBucket;
    PLIST_ENTRY pListHead, pLink, pCurrent;
    PDFS_NAME_TABLE_ENTRY pEntry;
    ULONG i;

    for ( i = 0; i < pNameTable->NumBuckets; i++ ) {
        pBucket = &pNameTable->HashBuckets[i];

        pListHead = &pBucket->ListHead;
        for ( pLink = pListHead->Flink; pLink != pListHead; ) {
            pCurrent = pLink;
            pLink = pLink->Flink;
            pEntry = CONTAINING_RECORD(pCurrent, DFS_NAME_TABLE_ENTRY, NameTableLink);
            RemoveEntryList( pCurrent );
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DfsReferenceNameTable(
    IN PDFS_NAME_TABLE pNameTable)
{

    PDFS_OBJECT_HEADER pHeader = &pNameTable->DfsHeader;
    USHORT headerType = DfsGetHeaderType( pHeader );

    if ( headerType != DFS_OT_NAME_TABLE ) {
        return STATUS_UNSUCCESSFUL;
    }

    DfsIncrementReference( pHeader );

    return STATUS_SUCCESS;

}

NTSTATUS
DfsDereferenceNameTable(
    IN PDFS_NAME_TABLE pNameTable)

{

    PDFS_OBJECT_HEADER pHeader = &pNameTable->DfsHeader;
    USHORT headerType = DfsGetHeaderType( pHeader );
    LONG Ref;

    if ( headerType != DFS_OT_NAME_TABLE ) {
        return STATUS_UNSUCCESSFUL;
    }

    Ref = DfsDecrementReference( pHeader );
    if (Ref == 0) {
        DeleteCriticalSection(pNameTable->pLock);

        FREE_MEMORY(pNameTable);
    }

    return STATUS_SUCCESS;


}


NTSTATUS
DfsNameTableAcquireWriteLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DFS_LOCK_NAME_TABLE(pNameTable, Status);

    return Status;

}


NTSTATUS
DfsNameTableAcquireReadLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    DFS_LOCK_NAME_TABLE(pNameTable, Status);

    return Status;

}

NTSTATUS
DfsNameTableReleaseLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DFS_UNLOCK_NAME_TABLE(pNameTable);

    return Status;

}


NTSTATUS
DfsEnumerateNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    IN OUT PVOID *ppEnumerator,
    OUT PVOID *ppData )
{
    PDFS_NAME_TABLE_ENTRY  pEntry = (PDFS_NAME_TABLE_ENTRY)*ppEnumerator;
    ULONG BucketNum = 0;
    NTSTATUS NtStatus = STATUS_NO_MORE_MATCHES;
    PDFS_NAME_TABLE_BUCKET pBucket = NULL;
    PLIST_ENTRY pListHead, pLink;

    *ppEnumerator = NULL;
    *ppData = NULL;


    if (pEntry != NULL) 
    {
        GET_NAME_TABLE_BUCKET(pEntry->pName, pNameTable, BucketNum);
    }

    for ( ; BucketNum < pNameTable->NumBuckets; BucketNum++)
    {
        pBucket = &pNameTable->HashBuckets[BucketNum];
        if (pBucket->Count == 0)
        {
            continue;
        }
        pListHead = &pBucket->ListHead;
        if (pEntry != NULL) 
        {
            pLink = pEntry->NameTableLink.Flink;
            pEntry = NULL;
        }
        else
        {
            pLink = pListHead->Flink;
        }
        if (pLink == pListHead)
        {
            continue;
        }

        pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

        *ppEnumerator = (PVOID)pEntry;
        *ppData = pEntry->pData;
        NtStatus = STATUS_SUCCESS;
        break;
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\misc\packmisc.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       PackMisc.c
//
//  Contents:   packing routines used by DFS
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "dfsheader.h"
#include "dfsmisc.h"

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

    //+-------------------------------------------------------------------------
    //
    //  Function PackGetULong
    //
    //  Arguments:  pValue - pointer to return info
    //              ppBuffer - pointer to buffer that holds the binary 
    //              stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one ulong value from the binary
    //               stream, and returns that value. It adjusts the buffer
    //               pointer and remaining size appropriately to point
    //               to the next value in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackGetULong(
        PULONG pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(ULONG);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            *pValue = (ULONG) ( (ULONG) pBinaryStream[0]       |
                                (ULONG) pBinaryStream[1] << 8  |
                                (ULONG) pBinaryStream[2] << 16 |
                                (ULONG) pBinaryStream[3] << 24);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //  
    //  Function:   PackSetULong - store one Ulong in the binary stream
    //
    //  Arguments:  Value - Ulong to add
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size remaining in buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine stores one ulong value in the binary stream,
    //               It adjusts the buffer pointer and remaining size 
    //               appropriately to point to the next value
    //               in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetULong(
        ULONG Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS  Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(ULONG);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pBinaryStream[0] = BYTE_0( Value );
            pBinaryStream[1] = BYTE_1( Value );
            pBinaryStream[2] = BYTE_2( Value );
            pBinaryStream[3] = BYTE_3( Value );
        
            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //
    // Function: PackSizeULong, return size of ulong
    //
    ULONG
    PackSizeULong()
    {
        return sizeof(ULONG);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetUShort - get one UShort from the binary stream
    //
    //  Arguments:  pValue - pointer to return info
    //              ppBuffer - pointer to buffer that holds the binary 
    //              stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one uShort value from the binary 
    //               stream, and returns that value. It adjusts the 
    //               buffer pointer and remaining size appropriately to 
    //               point to the next value in the binary stream.
    //
    //--------------------------------------------------------------------------    
    DFSSTATUS
    PackGetUShort(
        PUSHORT pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(USHORT);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            *pValue = (USHORT)( (USHORT) pBinaryStream[0] |
                                (USHORT) pBinaryStream[1] << 8 );

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);


            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetUShort - puts one UShort in the binary stream
    //
    //  Arguments:  Value - Ushort value
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack 
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine puts one uShort value in the binary stream,
    //               It adjusts the buffer pointer and
    //               remaining size appropriately to point to the next value
    //               in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetUShort(
        USHORT Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS  Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(USHORT);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pBinaryStream[0] = BYTE_0(Value);
            pBinaryStream[1] = BYTE_1(Value);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);

            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }
        return Status;
    }

    //
    // Function: PackSizeUShort, return size of ushort
    //
    ULONG
    PackSizeUShort()
    {
        return sizeof(USHORT);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetString - gets a string from a binary stream.
    //
    //  Arguments:  pString - pointer to returned unicode string
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one ulong value from the binary stream,
    //               and determines that to be the length of the string.
    //               It then sets up a unicode string, whose buffer points
    //               to the appropriate place within the binary stream, and 
    //               whose length is set to the ulong value that was read.
    //               It returns the buffer and size remaining adjusted appropriately.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackGetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS ReturnStatus = ERROR_INVALID_DATA;
        DFSSTATUS Status;

        //
        // We first get the length of the string.
        //
        Status = PackGetUShort(&pString->Length,
                                  ppBuffer,
                                  pSizeRemaining );

        if ( Status == ERROR_SUCCESS )
        {
            //
            // If the length exceeds the remaining binary stream or the length
            // is odd, we dont have a valid string.
            // Otherwise, set the pointer in the unicode string to the binary
            // stream representing the string, and update the buffer to point
            // to beyond the string.
            //
            if ( *pSizeRemaining >= pString->Length &&
                 (pString->Length & 0x1) == 0 )
            {

                pString->Buffer = (LPWSTR)(*ppBuffer);
                *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + pString->Length);
                *pSizeRemaining -= pString->Length;
                pString->MaximumLength = pString->Length;

                ReturnStatus = ERROR_SUCCESS;
            }
        }

        return ReturnStatus;
    }



    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetString - puts a string in the binary stream.
    //
    //  Arguments:  pString - pointer to unicode string to pack
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine puts one ulong value in the binary stream
    //               to represent length of string. It then copies the string
    //               itself into the buffer.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS ReturnStatus = ERROR_INVALID_DATA;
        DFSSTATUS Status;

        //
        // We first set the length of the string.
        //

        Status = PackSetUShort( pString->Length,
                                   ppBuffer,
                                   pSizeRemaining );

        if ( Status == ERROR_SUCCESS )
        {
            //
            // If the length exceeds the remaining binary stream 
            // we dont have a valid string.
            // Otherwise, we copy the unicode string to the binary
            // stream representing the string, and update the buffer to point
            // to beyond the string.
            //
            if ( *pSizeRemaining >= pString->Length )
            {
                memcpy((LPWSTR)(*ppBuffer), pString->Buffer, pString->Length);

                *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + pString->Length);
                *pSizeRemaining -= pString->Length;

                ReturnStatus = ERROR_SUCCESS;
            }
        }

        return ReturnStatus;
    }

    //
    // Function: PackSizeString - return size of string
    //
    ULONG
    PackSizeString(
        PUNICODE_STRING pString)
    {
        return (ULONG)(sizeof(USHORT) + pString->Length);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetGuid - Unpacks the guid from a binary stream
    //
    //  Arguments:  pGuid - pointer to a guid structure
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine expects the binary stream to hold a guid.
    //               It reads the guid information into the guid structure in
    //               the format prescribed for guids.
    //               The ppbuffer and size are adjusted to point to the next
    //               information in the binary stream.
    //
    //--------------------------------------------------------------------------

    DFSSTATUS
    PackGetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(GUID);
        PUCHAR pGuidInfo = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pGuid->Data1 = (ULONG) ((ULONG) pGuidInfo[0]       | 
                                    (ULONG) pGuidInfo[1] << 8  |
                                    (ULONG) pGuidInfo[2] << 16 |
                                    (ULONG) pGuidInfo[3] << 24  );

            pGuid->Data2 = (USHORT) ((USHORT) pGuidInfo[4]       | 
                                     (USHORT) pGuidInfo[5] << 8   );

            pGuid->Data3 = (USHORT) ((USHORT) pGuidInfo[6]       | 
                                     (USHORT) pGuidInfo[7] << 8   );

            memcpy(pGuid->Data4, &pGuidInfo[8], 8);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining   -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetGuid - Packs the guid from a binary stream
    //
    //  Arguments:  pGuid - pointer to a guid structure
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack the info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine stores the guid into the binary stream.
    //               The ppbuffer and size are adjusted to point to the next
    //               information in the binary stream.
    //
    //--------------------------------------------------------------------------

    DFSSTATUS
    PackSetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(GUID);
        PUCHAR pGuidInfo = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pGuidInfo[0] = BYTE_0(pGuid->Data1);
            pGuidInfo[1] = BYTE_1(pGuid->Data1);
            pGuidInfo[2] = BYTE_2(pGuid->Data1);
            pGuidInfo[3] = BYTE_3(pGuid->Data1);

            pGuidInfo[4] = BYTE_0(pGuid->Data2);
            pGuidInfo[5] = BYTE_1(pGuid->Data2);
            
            pGuidInfo[6] = BYTE_0(pGuid->Data3);
            pGuidInfo[7] = BYTE_1(pGuid->Data3);

            memcpy(&pGuidInfo[8], pGuid->Data4, 8);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining   -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }
        return Status;
    }


    //
    // Function: PackSizeGuid - return size of Guid
    //
    ULONG
    PackSizeGuid()
    {
        return sizeof(GUID);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\misc\dfsmisc.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsMisc.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <malloc.h>
#include "rpc.h"
#include "rpcdce.h"
#include <dfsheader.h>
#include "lm.h"
#include "lmdfs.h"
#include <strsafe.h>
#include <dfsmisc.h>

DFSSTATUS
DfsGenerateUuidString(
    LPWSTR *UuidString )
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    DFSSTATUS Status = ERROR_GEN_FAILURE;
    UUID NewUid;

    RpcStatus = UuidCreate(&NewUid);
    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = UuidToString( &NewUid,
                                  UuidString );
        if (RpcStatus == RPC_S_OK)
        {
            Status = ERROR_SUCCESS;
        }
    }

    return Status;
}

VOID
DfsReleaseUuidString(
    LPWSTR *UuidString )
{
    RpcStringFree(UuidString);
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodeString
//
//  Arguments:    pDest - the destination unicode string
//                pSrc - the source unicode string
//
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a new unicode string that is a copy
//               of the original. The copied unicode string has a buffer
//               that is null terminated, so the buffer can be used as a
//               normal string if necessary.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodeString( 
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc ) 
{
    LPWSTR NewString = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    NewString = malloc(pSrc->Length + sizeof(WCHAR));
    if ( NewString == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory( NewString, pSrc->Buffer, pSrc->Length);
    NewString[ pSrc->Length / sizeof(WCHAR)] = UNICODE_NULL;

    Status = DfsRtlInitUnicodeStringEx( pDest, NewString );
    if(Status != ERROR_SUCCESS)
    {
        free (NewString);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodeStringFromString
//
//  Arguments:    pDest - the destination unicode string
//                pSrcString - the source string
//
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a new unicode string that has a copy
//               of the passed in source string. The unicode string has
//               a buffer that is null terminated, so the buffer can be
//               used as a normal string if necessary.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodeStringFromString( 
    PUNICODE_STRING pDest,
    LPWSTR pSrcString ) 
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING Source;

    Status = DfsRtlInitUnicodeStringEx( &Source, pSrcString );
    if(Status == ERROR_SUCCESS)
    {
       Status = DfsCreateUnicodeString( pDest, &Source );
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodePathString
//
//  Arguments:  pDest - the destination unicode string
//              Number of leading seperators.
//              pFirstComponent - the first componet of the name.
//              pRemaining - the rest of the name.
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a pathname given two components.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//               it just creates a name that is formed by
//               combining the first component, followed by a \ followed
//               by the rest of the name.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodePathStringFromUnicode( 
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    PUNICODE_STRING pFirst,
    PUNICODE_STRING pRemaining )
{
    ULONG NameLen = 0;
    LPWSTR NewString = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NewOffset = 0;
    ULONG Index = 0;
    
    if (NumberOfLeadingSeperators > 2)
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (Index = 0; (Index < pFirst->Length) && (NumberOfLeadingSeperators != 0); Index++)
    {
        if (pFirst->Buffer[Index] != UNICODE_PATH_SEP)
        {
            break;
        }
        NumberOfLeadingSeperators--;
    }

    NameLen += NumberOfLeadingSeperators * sizeof(WCHAR);

    NameLen += pFirst->Length;

    if (pRemaining && (IsEmptyString(pRemaining->Buffer) == FALSE))
    {
        NameLen += sizeof(UNICODE_PATH_SEP);
        NameLen += pRemaining->Length;
    }
        
    NameLen += sizeof(UNICODE_NULL);

    if (NameLen > MAXUSHORT)
    {
        return ERROR_INVALID_PARAMETER;
    }
    NewString = malloc( NameLen );

    if (NewString != NULL)
    {
        RtlZeroMemory( NewString, NameLen );
        for (NewOffset = 0; NewOffset < NumberOfLeadingSeperators; NewOffset++)
        {
            NewString[NewOffset] = UNICODE_PATH_SEP;
        }
        RtlCopyMemory( &NewString[NewOffset], pFirst->Buffer, pFirst->Length);
        NewOffset += (pFirst->Length / sizeof(WCHAR));
        if (pRemaining && (IsEmptyString(pRemaining->Buffer) == FALSE))
        {
            NewString[NewOffset++] = UNICODE_PATH_SEP;
            RtlCopyMemory( &NewString[NewOffset], pRemaining->Buffer, pRemaining->Length);
            NewOffset += (pRemaining->Length / sizeof(WCHAR));
        }

        NewString[NewOffset] = UNICODE_NULL;

        Status = DfsRtlInitUnicodeStringEx(pDest, NewString);
        if(Status != ERROR_SUCCESS)
        {
            free(NewString);
        }
    }
    else 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodePathString
//
//  Arguments:  pDest - the destination unicode string
//              DosUncName - Do we want to create a unc path name?
//              pFirstComponent - the first componet of the name.
//              pRemaining - the rest of the name.
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a pathname given two components.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//               it just creates a name that is formed by
//               combining the first component, followed by a \ followed
//               by the rest of the name.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodePathString( 
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    LPWSTR pFirstComponent,
    LPWSTR pRemaining )
{
    ULONG NameLen = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING FirstComponent;
    UNICODE_STRING Remaining;

    Status = DfsRtlInitUnicodeStringEx( &FirstComponent, pFirstComponent);
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &Remaining, pRemaining);
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsCreateUnicodePathStringFromUnicode( pDest,
                                                    NumberOfLeadingSeperators,
                                                    &FirstComponent,
                                                    &Remaining );
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFreeUnicodeString
//
//  Arguments:  pString - the unicode string,
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine frees up a unicode string that was 
//               previously created by calling one of the above 
//               routines.
//               Only the unicode strings created by the above functions
//               are valid arguments. Passing any other unicode string
//               will result in fatal component errors.
//--------------------------------------------------------------------------
VOID
DfsFreeUnicodeString( 
    PUNICODE_STRING pDfsString )
{
    if (pDfsString->Buffer != NULL)
    {
        free (pDfsString->Buffer);
    }
}


DFSSTATUS
DfsApiSizeLevelHeader(
    ULONG Level,
    LONG * NewSize )
{
    ULONG ReturnSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    if(NewSize == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (Level)
    {

    case 4: 
        ReturnSize = sizeof(DFS_INFO_4);
        break;

    case 3:
        ReturnSize = sizeof(DFS_INFO_3);
        break;

    case 2:
        ReturnSize = sizeof(DFS_INFO_2);
        break;

    case 1:
        ReturnSize = sizeof(DFS_INFO_1);
        break;
        
    case 200:
        ReturnSize = sizeof(DFS_INFO_200);
        break;

    case 300:
        ReturnSize = sizeof(DFS_INFO_300);
        break;
        
    default:
        Status = ERROR_INVALID_PARAMETER;
        break;

    }

    *NewSize = ReturnSize;

    return Status;
}

//
// Wrapper around StringCchLength to return DFSSTATUS.
//
DFSSTATUS
DfsStringCchLength(
    LPWSTR pStr, 
    size_t CchMax, 
    size_t *pCch)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HRESULT Hr = S_OK;

    Hr = StringCchLengthW( pStr, CchMax, pCch );
    if (!SUCCEEDED(Hr))
    {
        Status = HRESULT_CODE(Hr);
    }

    return Status;
}

//
// Retrieve a string value from the registry.
// The unicode-string will be allocated on successful return.
//
DFSSTATUS
DfsGetRegValueString(
    HKEY Key,
    LPWSTR pKeyName,
    PUNICODE_STRING pValue )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG DataSize = 0;
    ULONG DataType = 0;
    LPWSTR pRegString = NULL;

    Status = RegQueryInfoKey( Key,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        DataSize += sizeof(WCHAR); // NULL Terminator
        pRegString = (LPWSTR) malloc( DataSize );
        if ( pRegString == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx(  Key,
                                      pKeyName,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)pRegString,
                                      &DataSize );
        }
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (DataType == REG_SZ)
        {
            Status = DfsRtlInitUnicodeStringEx( pValue, pRegString );
        }
        else {
            Status = ERROR_INVALID_DATA;
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        if (pRegString != NULL)
        {
            free( pRegString );
            pValue->Buffer = NULL;
        }
    }
    return Status;
}

VOID
DfsReleaseRegValueString(
    PUNICODE_STRING pValue )
{
    if (pValue != NULL)
    {
        free( pValue->Buffer );
        pValue->Buffer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\misc\dominfo.c ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       DomInfo.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>


extern
DWORD
I_NetDfsIsThisADomainName(
    IN  LPWSTR                      wszName);

DFSSTATUS
DfsIsThisAMachineName(
    LPWSTR MachineName )
{
    DFSSTATUS Status;

    Status = DfsIsThisADomainName(MachineName);

    if (Status != NO_ERROR) {
        Status = ERROR_SUCCESS;
    }
    else {
        Status = ERROR_NO_MATCH;
    }

    return Status;
}


DFSSTATUS
DfsIsThisAStandAloneDfsName(
             LPWSTR ServerName,
             LPWSTR ShareName )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD shareType = 0;
    PSHARE_INFO_1005 pshi1005 = NULL;
    LPWSTR CharHolder = NULL;
    BOOLEAN ShareModified = FALSE;
    

    CharHolder = wcschr(ShareName, UNICODE_PATH_SEP);

    if (CharHolder != NULL) 
    {
        *CharHolder = UNICODE_NULL;
        ShareModified = TRUE;
    }

    Status = NetShareGetInfo(
                ServerName,
                ShareName,
                1005,
                (PBYTE *) &pshi1005);


    if (ShareModified)
    {
        *CharHolder = UNICODE_PATH_SEP;
    }

    if (Status == NERR_Success) 
    {

        shareType = pshi1005->shi1005_flags;

        NetApiBufferFree( pshi1005 );


        if(shareType & SHI1005_FLAGS_DFS_ROOT)
        {
            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = NERR_NetNameNotFound;
        }
    }

    return Status;
}


DFSSTATUS
DfsIsThisADomainName(
    LPWSTR DomainName )
{
    ULONG               Flags = 0;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo;
    DFSSTATUS Status;

    Status = DsGetDcName(
                 NULL,   // Computername
                 DomainName,   // DomainName
                 NULL,   // DomainGuid
                 NULL,   // SiteGuid
                 Flags,
                 &pDomainControllerInfo);


    if (Status == NO_ERROR) {
        NetApiBufferFree(pDomainControllerInfo);
    }

    return Status;
}



DFSSTATUS
DfsIsThisARealDfsName(
    LPWSTR ServerName,
    LPWSTR ShareName,
    BOOLEAN * IsDomainDfs )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    *IsDomainDfs = FALSE;

    Status = I_NetDfsIsThisADomainName(ServerName);
    if(Status != ERROR_SUCCESS)
    {
        Status =  DfsIsThisAStandAloneDfsName(ServerName, ShareName);
    }
    else
    {
        *IsDomainDfs = TRUE;
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\prefix\name_table.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.h
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------


#ifndef __NAME_TABLE_H__
#define __NAME_TABLE_H__

#include <dfsheader.h>
#include <dfsnametable.h>

typedef struct _DFS_NAME_TABLE_BUCKET {
    ULONG Count;
    LIST_ENTRY ListHead;
} DFS_NAME_TABLE_BUCKET, *PDFS_NAME_TABLE_BUCKET;

typedef struct _DFS_NAME_TABLE_ENTRY {
    PUNICODE_STRING pName;
    LIST_ENTRY NameTableLink;
    PVOID pData;
} DFS_NAME_TABLE_ENTRY, *PDFS_NAME_TABLE_ENTRY;

typedef struct _DFS_NAME_TABLE {
    DFS_OBJECT_HEADER DfsHeader;
    ULONG Flags;
    ULONG NumBuckets;
    PVOID pLock;
    DFS_NAME_TABLE_BUCKET HashBuckets[0];
} DFS_NAME_TABLE, *PDFS_NAME_TABLE;

#define NAME_TABLE_LOCKED 1
#define DFS_NAMETABLE_CRIT_SPIN_COUNT         4000

NTSTATUS
DfsCheckNameTable(
    IN PUNICODE_STRING lookupName, 
    IN PDFS_NAME_TABLE_BUCKET pBucket,
    OUT PVOID *ppData );

#define DEFAULT_NAME_TABLE_SIZE  47

#define DFS_LOCK_NAME_TABLE(_pTable, _sts)\
        { EnterCriticalSection((_pTable)->pLock); (_pTable)->Flags |= NAME_TABLE_LOCKED; (_sts) = STATUS_SUCCESS; }

#define DFS_UNLOCK_NAME_TABLE(_pTable)\
        {(_pTable)->Flags &= ~NAME_TABLE_LOCKED; LeaveCriticalSection((_pTable)->pLock); }


#define GET_NAME_TABLE_BUCKET(_name, _table, BucketNo) \
{                                                                            \
    WCHAR *pPathBuffer   = (_name)->Buffer;                                  \
    WCHAR pCurrent;                                                          \
    WCHAR *pPathBufferEnd = &(pPathBuffer[(_name)->Length / sizeof(WCHAR)]); \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer)  &&                               \
          (*pPathBuffer))                                                    \
    {                                                                        \
        pCurrent = *pPathBuffer++;                                           \
        pCurrent = (pCurrent < L'a')                                         \
                       ? pCurrent                                            \
                       : ((pCurrent < L'z')                                  \
                          ? (pCurrent - L'a' + L'A')                         \
                          : RtlUpcaseUnicodeChar(pCurrent));                 \
        BucketNo *= 131;                                                     \
        BucketNo += pCurrent;                                                \
    }                                                                        \
    BucketNo = BucketNo % ((_table)->NumBuckets);                            \
}

#if defined (PREFIX_TABLE_HEAP_MEMORY)

extern HANDLE PrefixTableHeapHandle;

#define ALLOCATE_MEMORY(_sz) \
        HeapAlloc(PrefixTableHeapHandle, 0, _sz)

#define FREE_MEMORY(_addr) \
        HeapFree(PrefixTableHeapHandle, 0, _addr)

#else

#define ALLOCATE_MEMORY(_sz)\
        malloc(_sz)


#define FREE_MEMORY(_addr) \
        free(_addr)

#endif
        
#endif // __NAME_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\misc\pathmisc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PathMisc.c
//
//  Contents:   methods to read information from the registry.
//
//  History:    udayh: created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetNetbiosName - Gets the netbios name of a machine
//
//  Synopsis:   DfsGetNetbiosName takes the name and returns 2 components
//              of the name: the first is the name without the leading \\
//              and upto the next "." or "\". The rest of the path (if any)
//              is returned in the pRemaining argument.
//
//  Arguments:  pName - Input name
//              pNetbiosName -  the netbios name for the passed in name
//              pRemaining   - The rest of the name beyond the netbios name
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

VOID
DfsGetNetbiosName(
    PUNICODE_STRING pName,
    PUNICODE_STRING pNetbiosName,
    PUNICODE_STRING pRemaining )
{

    USHORT i = 0, j;

    RtlInitUnicodeString(pNetbiosName, NULL);
    if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

    for (; i < pName->Length/sizeof(WCHAR); i++) {
        if (pName->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
        if ((pName->Buffer[j] == UNICODE_PATH_SEP) ||
            (pName->Buffer[j] == L'.')) {
            break;
        }
    }
   
    if (j != i) {
        pNetbiosName->Buffer = &pName->Buffer[i];
        pNetbiosName->Length = (USHORT)((j - i) * sizeof(WCHAR));
        pNetbiosName->MaximumLength = pNetbiosName->Length;
    }
   

    for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
        if ((pName->Buffer[i] != UNICODE_PATH_SEP) &&
            (pName->Buffer[i] != L'.')) {
            break;
        }
    }
    
    j = pName->Length/sizeof(WCHAR);

    if ((pRemaining) && (j != i)) {
        pRemaining->Buffer = &pName->Buffer[i];
        pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
        pRemaining->MaximumLength = pRemaining->Length;
    }

    return NOTHING;

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsGetPathComponents - Breaks pathname into server, share,rest
//
//  Synopsis:   DfsGetPathComponents takes the name and returns 3 components
//              of the name: the first (ServerName), the next (ShareName) and the//              last (Remaining Name)
//
//  Arguments:  pName - Input name
//              pServerName - The first path component
//              pShareName - The second path component
//              pRemaining   - The rest of the path component
//
//  Returns:    STATUS: STATUS_INVALID_PARAMETER or Success
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsGetPathComponents(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = ERROR_INVALID_PARAMETER;

   RtlInitUnicodeString(pServerName, NULL);
   if (pShareName)    RtlInitUnicodeString(pShareName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if ((pName->Buffer[i] != UNICODE_PATH_SEP) ||
         (i >= 2))  
     {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) 
     {
       break;
     }
   }

   if (j > i) {
     pServerName->Buffer = &pName->Buffer[i];
     pServerName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pServerName->MaximumLength = pServerName->Length;
     
     Status = ERROR_SUCCESS;
   }
   
   i = j + 1;

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if ((pShareName) && (j > i)) {
     pShareName->Buffer = &pName->Buffer[i];
     pShareName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pShareName->MaximumLength = pShareName->Length;
   }


   i = j + 1;

   j = pName->Length/sizeof(WCHAR);

   if ((pRemaining) && (j > i)) {
     pRemaining->Buffer = &pName->Buffer[i];
     pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetFirstComponent - Gets the first part of the pathname
//
//  Synopsis:   DfsGetFirstComponent takes the name and returns 2 components
//              of the name: the first is the first part of the pathname.
//              The rest of the path is returned in the pRemaining argument.
//
//  Arguments:  pName - Input name
//              pFirstName -  First part of the name
//              pRemaining   - The rest of the name beyond the netbios name
//
//  Returns:    STATUS_INVALID_PARAMETER or SUCCESS
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetFirstComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pFirstName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = ERROR_INVALID_PARAMETER;

   RtlInitUnicodeString(pFirstName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if ((pName->Buffer[i] != UNICODE_PATH_SEP) ||
         (i >= 2))
     {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if (j > i) {
     pFirstName->Buffer = &pName->Buffer[i];
     pFirstName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pFirstName->MaximumLength = pFirstName->Length;
     
     Status = ERROR_SUCCESS;
   }


   i = (j + 1);

   j = pName->Length/sizeof(WCHAR);

   if ((pRemaining) && (j > i)) {
       pRemaining->Buffer = &pName->Buffer[i];
       pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
       pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetFirstComponent - Gets the first part of the pathname
//
//  Synopsis:   DfsGetFirstComponent takes the name and returns 2 components
//              of the name: the first is the first part of the pathname.
//              The rest of the path is returned in the pRemaining argument.
//
//  Arguments:  pName - Input name
//              pFirstName -  First part of the name
//              pRemaining   - The rest of the name beyond the netbios name
//
//  Returns:    STATUS_INVALID_PARAMETER or SUCCESS
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetNextComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pNextName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = ERROR_SUCCESS;

   RtlInitUnicodeString(pNextName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) 
     {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }


   pNextName->Buffer = &pName->Buffer[0];
   pNextName->Length = (USHORT)((j) * sizeof(WCHAR));
   pNextName->MaximumLength = pNextName->Length;
     
   i = (j + 1);

   j = pName->Length/sizeof(WCHAR);

   if ((pRemaining) && (j > i)) {
       pRemaining->Buffer = &pName->Buffer[i];
       pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
       pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetSharePath
//
//  Arguments:  ServerName - the name of the server
//              ShareName - the name of the share
//              pPathName - the unicode string representing the NT name
//                          of the local path representing the share
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a servername and a sharename, and
//               returns an NT pathname to the physical resource that is
//               backing the share name.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetSharePath( 
    IN  LPWSTR ServerName,
    IN  LPWSTR ShareName,
    OUT PUNICODE_STRING pPathName )
{
    LPWSTR UseServerName = NULL;
    ULONG InfoLevel = 2;
    PSHARE_INFO_2 pShareInfo;
    NET_API_STATUS NetStatus;
    DFSSTATUS Status;
    UNICODE_STRING NtSharePath;

    if (IsEmptyString(ServerName) == FALSE)
    {
        UseServerName = ServerName;
    }

    NetStatus = NetShareGetInfo( UseServerName,
                                 ShareName,
                                 InfoLevel,
                                 (LPBYTE *)&pShareInfo );
    if (NetStatus != ERROR_SUCCESS)
    {
        Status = (DFSSTATUS)NetStatus;
        return Status;
    }

    if( RtlDosPathNameToNtPathName_U(pShareInfo->shi2_path,
                                     &NtSharePath,
                                     NULL,
                                     NULL ) == TRUE )
    {
        Status = DfsCreateUnicodeString( pPathName,
                                         &NtSharePath );

        RtlFreeUnicodeString( &NtSharePath );
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    NetApiBufferFree( pShareInfo );
    
    return Status;
}


ULONG
DfsSizeUncPath( 
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent )
{
    ULONG SizeRequired = 0;

    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += FirstComponent->Length;
    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += SecondComponent->Length;
    SizeRequired += sizeof(UNICODE_NULL);

    return SizeRequired;
}

VOID
DfsCopyUncPath( 
    LPWSTR NewPath,
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent )
{
    ULONG CurrentIndex = 0;

    NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    RtlCopyMemory(&NewPath[CurrentIndex],
                  FirstComponent->Buffer,
                  FirstComponent->Length );
    CurrentIndex += (FirstComponent->Length / sizeof(WCHAR));

    if (NewPath[CurrentIndex] != UNICODE_PATH_SEP &&
        SecondComponent->Buffer[0] != UNICODE_PATH_SEP )
    {
        NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    }
    RtlCopyMemory(&NewPath[CurrentIndex],
                  SecondComponent->Buffer,
                  SecondComponent->Length );
    CurrentIndex += (SecondComponent->Length / sizeof(WCHAR));

    NewPath[CurrentIndex] = UNICODE_NULL;
}


//
// dfsdev: validate the next two functions. They appear to work,
// but we need to look into the boundary cases.
//

NTSTATUS
StripLastPathComponent( 
    PUNICODE_STRING pPath )
{
    USHORT i = 0, j;
    NTSTATUS Status = STATUS_SUCCESS;

    
    if (pPath->Length == 0)
    {
        return Status;
    }
    for( i = (pPath->Length - 1)/ sizeof(WCHAR); i != 0; i--) {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j != 0; j--){
        if (pPath->Buffer[j] == UNICODE_PATH_SEP) {
            break;
        }
    }

    pPath->Length = (j) * sizeof(WCHAR);
    return Status;
}

NTSTATUS
AddNextPathComponent( 
    PUNICODE_STRING pPath )
{
    USHORT i = 0, j;
    NTSTATUS Status = STATUS_SUCCESS;


    for( i = pPath->Length / sizeof(WCHAR); i < pPath->MaximumLength/sizeof(WCHAR); i++) {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j < (pPath->MaximumLength -1)/sizeof(WCHAR); j++) {
        if (pPath->Buffer[j] == UNICODE_PATH_SEP) {
            break;
        }
    }

    pPath->Length = j * sizeof(WCHAR);
    return Status;
}

void
StripTrailingSpacesFromPath( 
    LPWSTR pPath )
{
    LPWSTR NewPath = NULL;

    if(pPath)
    {

        NewPath = pPath + wcslen(pPath);
        while (NewPath != pPath) 
        {
            if( (NewPath[-1] != L' ' ) && (NewPath[-1] != L'\t' ))
            {
                break;
            }

          NewPath--;
        }

        *NewPath = L'\0' ;
    }
}

LPWSTR
StripLeadingSpacesFromPath( 
    LPWSTR pPath )
{
    LPWSTR NewPath = NULL;

    NewPath = pPath + wcsspn( pPath, L" \t");

    return NewPath;
}

LPWSTR
StripSpacesFromPath( 
    LPWSTR pPath )
{
    LPWSTR NewPath = NULL;

    NewPath = StripLeadingSpacesFromPath( pPath);

    StripTrailingSpacesFromPath(NewPath );

    return NewPath;
}


//
// This is a copy of the RtlInitUnicodeStringEx from rtl\string.c
// This is here because older systems (win2k) dont have this
// in their ntdll and causes us grief when our binaries are run
// on win2k.
//
NTSTATUS
DfsCopyOfRtlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL)
{
    if (SourceString != NULL) {
        SIZE_T Length = wcslen(SourceString);

        // We are actually limited to 32765 characters since we want to store a meaningful
        // MaximumLength also.
        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) {
            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + sizeof(WCHAR));
        DestinationString->Buffer = (PWSTR) SourceString;
    } else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return STATUS_SUCCESS;
}


DFSSTATUS
DfsRtlInitUnicodeStringEx(PUNICODE_STRING DestinationString, 
                          PCWSTR SourceString)
{
    DFSSTATUS DfsStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = DfsCopyOfRtlInitUnicodeStringEx(DestinationString, SourceString);
    if(NtStatus != STATUS_SUCCESS)
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DfsStatus = RtlNtStatusToDosError(NtStatus);
    }

    return DfsStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\authzsecurity.cxx ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       Authzsecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April 16 2002,   Author: Rohanp
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>
#include <shellapi.h>
#include <Aclapi.h>
#include <authz.h>
#include "securitylogmacros.hxx"
                          
AUTHZ_RESOURCE_MANAGER_HANDLE g_DfsAuthzResourceManager = NULL;

BOOL 
DfsInitializeAuthz(void)
{
    BOOL RetVal = FALSE;

    RetVal = AuthzInitializeResourceManager(AUTHZ_RM_FLAG_NO_AUDIT, NULL, NULL, 
                                            NULL, L"DFSSECURITY", 
                                            &g_DfsAuthzResourceManager);

    return RetVal;

}


BOOL 
DfsTerminateAuthz(void)
{
    BOOL RetVal = FALSE;

    if(g_DfsAuthzResourceManager)
    {
        RetVal = AuthzFreeResourceManager(g_DfsAuthzResourceManager);
        g_DfsAuthzResourceManager = NULL;
    }

    return RetVal;

}

DWORD 
DfsIsAccessGrantedBySid(DWORD dwDesiredAccess,
                        PSECURITY_DESCRIPTOR pSD, 
                        PSID TheSID,
                        GENERIC_MAPPING * DfsGenericMapping)
{

    DWORD Status = 0;
    DWORD dwError = 0;
    BOOL RetVal = FALSE;
    ACCESS_MASK GrantedMask = 0;;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzCC = NULL;
    LUID Luid = {0, 0};
    AUTHZ_ACCESS_REQUEST AuthzRequest;
    AUTHZ_ACCESS_REPLY AuthzReply;

    if(g_DfsAuthzResourceManager == NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    RetVal = AuthzInitializeContextFromSid(AUTHZ_SKIP_TOKEN_GROUPS, 
                                           TheSID, g_DfsAuthzResourceManager,
                                           NULL, Luid, NULL, &AuthzCC);
    if(RetVal == FALSE)
    {
        Status = GetLastError();
        goto Exit;
    }

    MapGenericMask(&dwDesiredAccess, DfsGenericMapping);

    ZeroMemory((void *) &AuthzRequest, sizeof(AuthzRequest));
    AuthzRequest.DesiredAccess = dwDesiredAccess;

    ZeroMemory((void *) &AuthzReply, sizeof(AuthzReply));
    AuthzReply.ResultListLength = 1;
    AuthzReply.GrantedAccessMask = &GrantedMask;
    AuthzReply.Error = &dwError;

    RetVal = AuthzAccessCheck (0, AuthzCC, &AuthzRequest, NULL,
                               pSD, NULL, 0, &AuthzReply, 0);
    if(RetVal == FALSE)
    {
        Status = GetLastError();
        goto Exit;
    }

    Status = dwError;

Exit:

    if(AuthzCC)
    {
        AuthzFreeContext(AuthzCC);
    }

    return Status;

}


DWORD 
DfsIsAccessGrantedByToken(DWORD dwDesiredAccess,
                          PSECURITY_DESCRIPTOR pSD, 
                          HANDLE TheToken,
                          GENERIC_MAPPING * DfsGenericMapping)
{

    DWORD Status = 0;
    DWORD dwError = 0;
    BOOL RetVal = FALSE;
    ACCESS_MASK GrantedMask = 0;;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzCC = NULL;
    LUID Luid = {0, 0};
    AUTHZ_ACCESS_REQUEST AuthzRequest;
    AUTHZ_ACCESS_REPLY AuthzReply;

    if(g_DfsAuthzResourceManager == NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    RetVal = AuthzInitializeContextFromToken(AUTHZ_SKIP_TOKEN_GROUPS, 
                                             TheToken, g_DfsAuthzResourceManager,
                                             NULL, Luid, NULL, &AuthzCC);
    if(RetVal == FALSE)
    {
        Status = GetLastError();
        goto Exit;
    }

    MapGenericMask(&dwDesiredAccess, DfsGenericMapping);

    ZeroMemory((void *) &AuthzRequest, sizeof(AuthzRequest));
    AuthzRequest.DesiredAccess = dwDesiredAccess;

    ZeroMemory((void *) &AuthzReply, sizeof(AuthzReply));
    AuthzReply.ResultListLength = 1;
    AuthzReply.GrantedAccessMask = &GrantedMask;
    AuthzReply.Error = &dwError;

    RetVal = AuthzAccessCheck (0, AuthzCC, &AuthzRequest, NULL,
                               pSD, NULL, 0, &AuthzReply, 0);
    if(RetVal == FALSE)
    {
        Status = GetLastError();
        goto Exit;
    }

    Status = dwError;

Exit:

    if(AuthzCC)
    {
        AuthzFreeContext(AuthzCC);
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\prefix\prefix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE


#include <ntifs.h>
#include <ntddser.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#include <prefix.h>
#include <dfsprefix.h>

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
                         IN PDFS_PREFIX_TABLE_ENTRY pEntry);
VOID
DfsDeletePrefixTable(
    IN PDFS_PREFIX_TABLE pTable);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFreePrefixTable )
#pragma alloc_text( PAGE, DfsInitializePrefixTable )
#pragma alloc_text( PAGE, DfsDeletePrefixTable )
#pragma alloc_text( PAGE, DfsInsertInPrefixTable )
#pragma alloc_text( PAGE, DfsFindUnicodePrefix )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTable )
#pragma alloc_text( PAGE, _LookupPrefixTable )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTableEx )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTableLockedEx )
#endif  // ALLOC_PRAGMA

#if defined (PREFIX_TABLE_HEAP_MEMORY)
HANDLE PrefixTableHeapHandle = NULL;
#endif

NTSTATUS
DfsPrefixTableInit()
{

#if defined (PREFIX_TABLE_HEAP_MEMORY)

    PrefixTableHeapHandle = HeapCreate(0, 0, 0);
    if ( PrefixTableHeapHandle == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    /* printf("Prefix table using memory heap\n"); */
#endif
    return STATUS_SUCCESS;
}


void
DfsPrefixTableShutdown(void)
{

#if defined (PREFIX_TABLE_HEAP_MEMORY)
    if ( PrefixTableHeapHandle != NULL ) 
    {
        HeapDestroy(PrefixTableHeapHandle);
        PrefixTableHeapHandle = NULL;
    }
    /* printf("Prefix table using memory heap\n"); */
#endif
}
//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsInitializePrefixTable(
    IN OUT PDFS_PREFIX_TABLE *ppTable, 
    IN BOOLEAN fCaseSensitive,
    IN PVOID Lock)

{
    PDFS_PREFIX_TABLE pTable = *ppTable;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Flags = fCaseSensitive ? PREFIX_TABLE_CASE_SENSITIVE : 0;
    int i;

    if ( pTable == NULL ) {
        Flags |= PREFIX_TABLE_TABLE_ALLOCATED;
        pTable = ALLOCATE_PREFIX_TABLE();
        if ( pTable == NULL )
            Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( NT_SUCCESS(Status) ) {
        RtlZeroMemory(pTable, sizeof(DFS_PREFIX_TABLE));

        DfsInitializeHeader(&pTable->DfsHeader, 
                            DFS_OT_PREFIX_TABLE,
                            sizeof(DFS_PREFIX_TABLE));

        pTable->Flags = Flags;
        pTable->LockCount = 0;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for ( i = 0;i < NO_OF_HASH_BUCKETS;i++ ) {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        pTable->pPrefixTableLock = Lock;

        if ( pTable->pPrefixTableLock == NULL ) {
            pTable->pPrefixTableLock = ALLOCATE_PREFIX_TABLE_LOCK();
            
            if ( pTable->pPrefixTableLock != NULL ) {
                
                pTable->Flags |= PREFIX_TABLE_LOCK_ALLOCATED;

                Status = INITIALIZE_PREFIX_TABLE_LOCK(pTable->pPrefixTableLock);
                if (NT_SUCCESS( Status )) {
                    pTable->Flags |= PREFIX_TABLE_LOCK_INITIALIZED;
                } 
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (!NT_SUCCESS( Status )) {
        
        if (pTable) {
            DfsDeletePrefixTable( pTable );
            pTable = NULL;
        }
    }
    
    *ppTable = pTable;

    return  Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTableLocked
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInsertInPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    ULONG                   BucketNo = 0;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pLastInsertedEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;
    UNICODE_STRING          Path,Name;
    BOOLEAN NewParent = FALSE;
    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the >processing upfront.

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];
    pParentEntry = &pTable->RootEntry;

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            pTable->RootEntry.pData = pData;
            return STATUS_SUCCESS;
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    if ( Path.Length >= MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = PREFIX_TABLE_ALLOCATE_MEMORY(Path.Length + sizeof(WCHAR));
        if ( NameBuffer == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while ( Path.Length > 0 ) {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if ( pTable->Flags & PREFIX_TABLE_CASE_SENSITIVE ) {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        } else {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if ( Name.Length > 0 ) {
            // Lookup the table to see if the name segment already exists.

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);


            if ( pEntry == NULL ) {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if ( pEntry != NULL ) {
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_BUFFER((Name.Length/sizeof(WCHAR)));

                        if ( pBuffer != NULL ) {
                            RtlZeroMemory(pBuffer,Name.Length);
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        } else {
                            FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pEntry);
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                    }

                    // thread the entry to point to the parent.
                    // Increment the no. of children associated with  this entry
                    if (NewParent == FALSE) {
                        pParentEntry->Reference++;   
                        NewParent = TRUE;
                    }

                    pEntry->pParentEntry = pParentEntry;
                    pLastInsertedEntry = pEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            }

            pParentEntry = pEntry;
        } else {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (NT_SUCCESS(status) &&
    	pEntry != NULL /* to keep PREFAST happy */) {
    	
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        pEntry->pData = pData;
        pTable->TotalEntries += 1;
    } else {
        pParentEntry = pLastInsertedEntry;
        while ( pParentEntry != NULL ) {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if ( --pMaybeTempEntry->Reference == 0 ) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if ( pParentEntry != NULL ) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
                    FREE_NAME_BUFFER( pMaybeTempEntry->PathSegment.Buffer );
                    FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pMaybeTempEntry);
                }
            }
            else
            {
                break;
            }
        }
    }

    if ( NameBuffer != Buffer ) {
        PREFIX_TABLE_FREE_MEMORY( NameBuffer );
    }

    return status;
}


//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefixLocked
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsFindUnicodePrefixLocked(
    IN PDFS_PREFIX_TABLE   pTable,
    IN PUNICODE_STRING     pPath,
    IN PUNICODE_STRING     pSuffix,
    IN PVOID *ppData,
    OUT PBOOLEAN pSubStringMatch)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    *ppData = NULL;


    if ( pPath->Length == 0 ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry, pSubStringMatch);

        // Update the BLOB placeholder with the results of the lookup.
        if ( status == STATUS_SUCCESS ) {
            *ppData = pEntry->pData;
        }

    }
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsRemoveFromPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) {
        if ( (pMatchingData == NULL) || (pMatchingData == pEntry->pData) ) 
        {
            DfsRemovePrefixTableEntry(pTable, pEntry);
            pTable->TotalEntries -= 1;
        } 
        else 
        {
            status = STATUS_NOT_FOUND;
        }
    }

    return status;
}


NTSTATUS DfsReplaceInPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID *ppMatchingData)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }


    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) {
        if ( (*ppMatchingData == NULL) || (*ppMatchingData == pEntry->pData) ) {
            *ppMatchingData = pEntry->pData;
            pEntry->pData = pReplaceData;
        } else {
            status = STATUS_NOT_FOUND;
        }
    }

    if ( (status != STATUS_SUCCESS) && (*ppMatchingData == NULL) ) {
        status = DfsInsertInPrefixTableLocked( pTable,
                                               pPath,
                                               pReplaceData );
    }

    return status;
}

VOID
DfsRemovePrefixTableEntry(
    IN PDFS_PREFIX_TABLE pTable,
    IN PDFS_PREFIX_TABLE_ENTRY pEntry )
{
    UNREFERENCED_PARAMETER(pTable);

    // Destroy the association between the data associated with
    // this prefix.
    pEntry->pData = NULL;

    // found an exact match for the given path name in the table.
    // traverse the list of parent pointers and delete them if
    // required.

    while ( pEntry != NULL ) {
        if ( (--pEntry->Reference) == 0 ) {
            PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
            pEntry = pEntry->pParentEntry;

            //
            // pEntry == NULL means pTempEntry is pTable->RootEntry.
            // Do not try to remove it.
            //
            if ( pEntry != NULL ) {
                REMOVE_FROM_CHILD_LIST(pTempEntry);
                REMOVE_FROM_BUCKET(pTempEntry);
                FREE_NAME_BUFFER( pTempEntry->PathSegment.Buffer );
                FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pTempEntry);
            }
        } 
        else
        {
            break;
        }

    }
    return;
}



//+---------------------------------------------------------------------------
//
//  Function:   DfsFreePrefixTable
//
//  Synopsis:   API for freeing a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    08-01-99 JHarper Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsDismantlePrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN VOID (*ProcessFunction)(PVOID pEntry))

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pSentinelEntry = NULL;
    ULONG i = 0;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    for ( i = 0; i < NO_OF_HASH_BUCKETS; i++ ) {
        pSentinelEntry = &pTable->Buckets[i].SentinelEntry;
        while ( pSentinelEntry->pNextEntry != pSentinelEntry ) {
            pEntry = pSentinelEntry->pNextEntry;
            REMOVE_FROM_BUCKET(pEntry);
            if ( (ProcessFunction) && (pEntry->pData) ) {
                ProcessFunction(pEntry->pData);
            }
            FREE_NAME_BUFFER( pEntry->PathSegment.Buffer );
            FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pEntry);
        }
        pTable->Buckets[i].NoOfEntries = 0;
    }
    if ( pTable->RootEntry.PathSegment.Buffer != NULL )
        FREE_NAME_BUFFER(pTable->RootEntry.PathSegment.Buffer);

    UNLOCK_PREFIX_TABLE(pTable);

done:
    return Status;
}
    
NTSTATUS
DfsDereferencePrefixTable( 
    IN PDFS_PREFIX_TABLE pTable)
{
    PDFS_OBJECT_HEADER pHeader = NULL;
    USHORT headerType = 0;
    LONG Ref = 0;

    if(pTable == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pHeader = &pTable->DfsHeader;

    headerType = DfsGetHeaderType( pHeader );

    if (headerType != DFS_OT_PREFIX_TABLE) {
        return STATUS_UNSUCCESSFUL;
    }

    Ref = DfsDecrementReference( pHeader );
    if (Ref == 0) {
        DfsDeletePrefixTable( pTable );
        pTable = NULL;
    }
    return  STATUS_SUCCESS;
}

VOID
DfsDeletePrefixTable(
    IN PDFS_PREFIX_TABLE pTable)
{
    if (pTable != NULL) {
        if (pTable->Flags & PREFIX_TABLE_LOCK_INITIALIZED) {
            UNINITIALIZE_PREFIX_TABLE_LOCK( pTable->pPrefixTableLock );
            pTable->Flags &= ~(PREFIX_TABLE_LOCK_INITIALIZED);
        }
        
        if (pTable->Flags & PREFIX_TABLE_LOCK_ALLOCATED) {
            FREE_PREFIX_TABLE_LOCK( pTable->pPrefixTableLock );
            pTable->pPrefixTableLock = NULL;
            pTable->Flags &= ~(PREFIX_TABLE_LOCK_ALLOCATED);
        }
        
        if (pTable->Flags & PREFIX_TABLE_TABLE_ALLOCATED) {
            FREE_PREFIX_TABLE( pTable );                
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppEntry] -- placeholder for the matching entry for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _LookupPrefixTable(
    PDFS_PREFIX_TABLE        pTable,
    UNICODE_STRING           *pPath,
    UNICODE_STRING           *pSuffix,
    PDFS_PREFIX_TABLE_ENTRY  *ppEntry,
    OUT PBOOLEAN             pSubStringMatch )
{
    NTSTATUS                status = STATUS_SUCCESS;
    UNICODE_STRING          Path = *pPath;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Name;
    ULONG                   BucketNo;
    BOOLEAN                 fPrefixFound = FALSE;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = &pTable->RootEntry;
    BOOLEAN                 fNameFound = FALSE;
    BOOLEAN SubStringMatch = TRUE;



    // The \ is treated as a special case. The test for all names starting with
    // a delimiter is done before we initiate the complete search process.

    if ( Path.Buffer[0] == PATH_DELIMITER ) {
        Path.Length = Path.Length - sizeof(WCHAR);
        Path.Buffer += 1; // Skip the path delimiter at the beginning.

        if ( pTable->RootEntry.pData != NULL ) {
            fPrefixFound = TRUE;
            *pSuffix     = Path;
            *ppEntry     = &pTable->RootEntry;
        }
    }

    if ( Path.Length >= MAX_PATH_SEGMENT_SIZE ) {
        NameBuffer = PREFIX_TABLE_ALLOCATE_MEMORY(Path.Length + sizeof(WCHAR));
        if ( NameBuffer == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while ( Path.Length > 0 ) {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        if ( pTable->Flags & PREFIX_TABLE_CASE_SENSITIVE ) {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        } else {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if ( Name.Length > 0 ) {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);


            if ( pEntry != NULL ) {
                // Cache the data available for this prefix if any.
                if ( pEntry->pData != NULL ) {
                    *pSuffix      = Path;
                    *ppEntry      = pEntry;
                    fPrefixFound  = TRUE;
                }
            } else {
                SubStringMatch = FALSE;
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    if ( !fPrefixFound ) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    if ( NameBuffer != Buffer ) {
        PREFIX_TABLE_FREE_MEMORY( NameBuffer );
    }

    if (pSubStringMatch != NULL)
    {
        *pSubStringMatch = SubStringMatch;
    }
    return status;
}


NTSTATUS
DfsInsertInPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData)
{
    NTSTATUS status;

    WRITE_LOCK_PREFIX_TABLE(pTable, status);
    if ( status != STATUS_SUCCESS )
        goto done;

    status  = DfsInsertInPrefixTableLocked(pTable, pPath, pData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return status;
}


NTSTATUS
DfsFindUnicodePrefix(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PUNICODE_STRING pSuffix,
    IN PVOID *ppData)
{
    NTSTATUS  Status;

    READ_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsFindUnicodePrefixLocked(pTable, pPath, pSuffix, ppData,NULL);

    UNLOCK_PREFIX_TABLE(pTable);
done:
    return Status;
}

NTSTATUS 
DfsRemoveFromPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData)
{
    NTSTATUS  Status;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsRemoveFromPrefixTableLocked(pTable, pPath, pMatchingData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return Status;
}



NTSTATUS 
DfsRemoveFromPrefixTableLockedEx(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData)
{


    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    
    UNREFERENCED_PARAMETER(pMatchingData);

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) 
    {
        *pReturnedData = pEntry->pData;
         DfsRemovePrefixTableEntry(pTable, pEntry);
    }

    return status;
}

NTSTATUS 
DfsRemoveFromPrefixTableEx(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData)
{
    NTSTATUS  Status;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsRemoveFromPrefixTableLockedEx(pTable, pPath, pMatchingData, pReturnedData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return Status;
}

NTSTATUS
DfsReplaceInPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID pMatchingData)
{
    NTSTATUS  Status;
    IN PVOID pGotData = pMatchingData;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsReplaceInPrefixTableLocked(pTable, 
                                           pPath, 
                                           pReplaceData, 
                                           &pGotData);

    UNLOCK_PREFIX_TABLE(pTable);

done:
    return Status;
}

#if !defined (KERNEL_MODE)
VOID
DumpParentName(
              IN PDFS_PREFIX_TABLE_ENTRY pEntry)
{

    if ( pEntry->pParentEntry != NULL ) {
        DumpParentName(pEntry->pParentEntry);
        if ( pEntry->pParentEntry->PathSegment.Buffer != NULL )
            printf("\\%wZ", &pEntry->pParentEntry->PathSegment);
    }

    return;
}

VOID
DfsDumpPrefixTable(
                  PDFS_PREFIX_TABLE pPrefixTable,
                  IN VOID (*DumpFunction)(PVOID pEntry))
{
    PPREFIX_TABLE_BUCKET pBucket;
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = NULL;
    ULONG i, NumEntries;
    NTSTATUS Status;

    printf("Prefix table  %p\n", pPrefixTable);
    printf("Prefix table flags %x\n", pPrefixTable->Flags);
    printf("Prefix table Lock  %p\n", pPrefixTable->pPrefixTableLock);

    READ_LOCK_PREFIX_TABLE(pPrefixTable, Status);
    if (Status != STATUS_SUCCESS) 
        return NOTHING;

    for ( i = 0; i < NO_OF_HASH_BUCKETS; i++ ) {
        pBucket = &pPrefixTable->Buckets[i];

        pCurEntry = pBucket->SentinelEntry.pNextEntry;
        NumEntries = 0;
        while ( pCurEntry != &pBucket->SentinelEntry ) {
            NumEntries++;
            if ( pCurEntry->pData != NULL ) {
                printf("Found Prefix data %p in Bucket %d\n", pCurEntry->pData, i);
                DumpParentName(pCurEntry);
                printf("\\%wZ\n", &pCurEntry->PathSegment);
                if ( DumpFunction ) {
                    DumpFunction(pCurEntry->pData);
                }
            }
            pCurEntry = pCurEntry->pNextEntry;
        }

        printf("Number of entries in Bucket %d is %d\n", i, NumEntries);
    }
    UNLOCK_PREFIX_TABLE(pPrefixTable);
}


#endif

NTSTATUS
DfsPrefixTableAcquireWriteLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    NTSTATUS Status;

    WRITE_LOCK_PREFIX_TABLE(pPrefixTable, Status);

    return Status;

}

NTSTATUS
DfsPrefixTableAcquireReadLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    NTSTATUS Status;

    READ_LOCK_PREFIX_TABLE(pPrefixTable, Status);

    return Status;

}

NTSTATUS
DfsPrefixTableReleaseLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    UNLOCK_PREFIX_TABLE(pPrefixTable);

    return STATUS_SUCCESS;

}


NTSTATUS
DfsEnumeratePrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN VOID (*ProcessFunction)(PVOID pEntry, PVOID pContext),
    LPVOID lpvClientContext)

{
    NTSTATUS Status = STATUS_SUCCESS;
    PPREFIX_TABLE_BUCKET pBucket = NULL;
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = NULL;
    ULONG i = 0;

    if(pTable->TotalEntries == 0)
    {
        return Status;
    }

    for ( i = 0; i < NO_OF_HASH_BUCKETS; i++ ) 
    {
        pBucket = &pTable->Buckets[i];

        pCurEntry = pBucket->SentinelEntry.pNextEntry;
        while ( pCurEntry != &pBucket->SentinelEntry ) 
         {
            if ( pCurEntry->pData != NULL ) 
            {
               ProcessFunction(pCurEntry->pData, lpvClientContext);
            }

            pCurEntry = pCurEntry->pNextEntry;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\prefix\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIX_H__
#define __PREFIX_H__

#include <dfsheader.h>

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_ENTRY
//
// History:
//
// Notes:   Each DFS_PREFIX_TABLE entry is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DFS_PREFIX_TABLE_ENTRY_
{
   struct _DFS_PREFIX_TABLE_ENTRY_  *pParentEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pNextEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DFS_PREFIX_TABLE_ENTRY_  *pFirstChildEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pSiblingEntry;

   ULONG                             Reference;

   UNICODE_STRING                    PathSegment;
   PVOID                             pData;
} DFS_PREFIX_TABLE_ENTRY, *PDFS_PREFIX_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_BUCKET
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE_BUCKET is a doubly linked list of
//          DFS_PREFIX_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _PREFIX_TABLE_BUCKET_
{
   ULONG                  NoOfEntries;   // High water mark for entries hashing to the bkt.
   DFS_PREFIX_TABLE_ENTRY SentinelEntry;
} PREFIX_TABLE_BUCKET, *PPREFIX_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE is a hashed collection of DFS_PREFIX_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two pathnames \foo\bar and \bar\foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 57

typedef struct _DFS_PREFIX_TABLE
{
   DFS_OBJECT_HEADER   DfsHeader;
   ULONG               Flags;
   ULONG               TotalEntries;
   LONG                LockCount;
   PVOID               pPrefixTableLock;
   //
   // NextEntry is used purely for enumeration
   //
   PDFS_PREFIX_TABLE_ENTRY NextEntry;
   DFS_PREFIX_TABLE_ENTRY RootEntry;
   PREFIX_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];
} DFS_PREFIX_TABLE, *PDFS_PREFIX_TABLE;

#define PREFIX_TABLE_CASE_SENSITIVE  0x1
#define PREFIX_TABLE_TABLE_ALLOCATED  0x2
#define PREFIX_TABLE_LOCK_ALLOCATED   0x4
#define PREFIX_TABLE_LOCK_INITIALIZED 0x8

//--------------------------------------------------------------------------
//
// PREFIX TABLE UTILITIES
//
// A Path is a sequence of one or more name segments alternated with a
// distinguished concatenation character ( typically \ in FAT,NTFS,HPFS and
// / in UNIX file systems). These utilities are used to split a given path
// into the first path segment followed by the remainder of the path.
//
// SPLIT_PATH("foo\bar\bar1",Name,RemainingPath) binds Name to foo and
// RemainingPath to bar\bar1
//
// Similarly PROCESS_CASE_SENSITIVE_NAME and PROCESS_CASE_INSENSITIVE_NAME
// compute the hash signatures ( bucket no. ) for a given string.
//
//--------------------------------------------------------------------------


//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER L'\\'

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_INSENSITIVE_PATH
//
//  Synopsis:   Split the path name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are
//               modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_INSENSITIVE_PATH(pPath,pName,BucketNo)                    \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        *pNameBuffer = (*pNameBuffer < L'a')                                 \
                       ? *pNameBuffer                                        \
                       : ((*pNameBuffer < L'z')                              \
                          ? (*pNameBuffer - L'a' + L'A')                     \
                          : RtlUpcaseUnicodeChar(*pNameBuffer));             \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_SENSITIVE_PATH
//
//  Synopsis:   Split the patah name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_SENSITIVE_PATH(pPath,pName,BucketNo)                      \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
}                                                                            \


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_BUCKET(Bucket)                                           \
{                                                                           \
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;             \
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;             \
   (Bucket).NoOfEntries = 0;                                                \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   LOOKUP_BUCKET
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  [Bucket] -- the bucket to be used (DFS_PREFIX_TABLE_BUCKET)
//
//              [Name]   -- the name to be looked up (UNICODE_STRING)
//
//              [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              [pEntry] -- placeholder for the desired entry.
//
//              [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo\bar and foo1\bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------

#define LOOKUP_BUCKET(Bucket,Name,pParentEntry,pEntry,fNameFound)           \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = Bucket.SentinelEntry.pNextEntry;    \
                                                                            \
    fNameFound = FALSE;                                                     \
    pEntry = NULL;                                                          \
                                                                            \
    while (pCurEntry != &Bucket.SentinelEntry)                              \
    {                                                                       \
        if (pCurEntry->PathSegment.Length == Name.Length)                   \
        {                                                                   \
            if (fNameFound &&                                               \
               (pCurEntry->PathSegment.Buffer == Name.Buffer))              \
            {                                                               \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else if (!memcmp(pCurEntry->PathSegment.Buffer,                 \
                             Name.Buffer,                                   \
                             Name.Length))                                  \
            {                                                               \
                fNameFound = TRUE;                                          \
                Name.Buffer = pCurEntry->PathSegment.Buffer;                \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
        pCurEntry = pCurEntry->pNextEntry;                                  \
    }                                                                       \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_BUCKET(Bucket,pEntry)                                     \
{                                                                           \
    (Bucket).NoOfEntries++;                                                 \
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;               \
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);                       \
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);             \
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);                           \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define REMOVE_FROM_BUCKET(pEntry)                                          \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;              \
    PDFS_PREFIX_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;              \
                                                                            \
    pPrevEntry->pNextEntry = pNextEntry;                                    \
    pNextEntry->pPrevEntry = pPrevEntry;                                    \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_CHILD_LIST(pEntry, pParentEntry)                           \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pLastChild;                                      \
                                                                             \
    if (pParentEntry->pFirstChildEntry == NULL) {                            \
        pParentEntry->pFirstChildEntry = pEntry;                             \
    } else {                                                                 \
        for (pLastChild = pParentEntry->pFirstChildEntry;                    \
                pLastChild->pSiblingEntry != NULL;                           \
                    pLastChild = pLastChild->pSiblingEntry) {                \
             NOTHING;                                                        \
        }                                                                    \
        pLastChild->pSiblingEntry = pEntry;                                  \
    }                                                                        \
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      Defined as a macro for inlining.
//
//              This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

#define REMOVE_FROM_CHILD_LIST(pEntry)                                       \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;             \
    PDFS_PREFIX_TABLE_ENTRY pPrevSibling;                                    \
                                                                             \
    if (pParentEntry->pFirstChildEntry == pEntry) {                          \
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;              \
    } else {                                                                 \
        for (pPrevSibling = pParentEntry->pFirstChildEntry;                  \
                pPrevSibling->pSiblingEntry != pEntry;                       \
                    pPrevSibling = pPrevSibling->pSiblingEntry) {            \
             ASSERT(pPrevSibling->pSiblingEntry != NULL);                    \
        }                                                                    \
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;                 \
    }                                                                        \
}


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_PREFIX_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_PREFIX_TABLE_ENTRY(pEntry)                                \
{                                                                            \
    RtlZeroMemory( pEntry, sizeof( DFS_PREFIX_TABLE_ENTRY ) );               \
    (pEntry)->Reference = 1;                                                 \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   private fns. extern declarations
//
//----------------------------------------------------------------------------

extern
NTSTATUS _LookupPrefixTable( 
    IN PDFS_PREFIX_TABLE        pTable,
    IN UNICODE_STRING           *pPath,
    OUT UNICODE_STRING           *pSuffix,
    OUT PDFS_PREFIX_TABLE_ENTRY  *ppEntry,
    OUT PBOOLEAN                 pSubStringMatch );


VOID
DfsRemovePrefixTableEntry(
    PDFS_PREFIX_TABLE pTable,
    PDFS_PREFIX_TABLE_ENTRY pEntry );





//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   all the allocation routines are defined to be used in the KERNEL as
//              well as user mode. The KERNEL mode is turned on by defining KERNEL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

//
// We may be holding the PrefixLock shared. However, we won't need interlocks to
// just read the value.
//
#define IS_PREFIX_TABLE_LOCKED(_pTable) \
        ((_pTable)->LockCount > 0)
        
#define ALLOCATE_PREFIX_TABLE() \
        PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(DFS_PREFIX_TABLE))

#define FREE_PREFIX_TABLE(_ptable)  \
        PREFIX_TABLE_FREE_MEMORY(_ptable)


#ifdef KERNEL_MODE

#define ALLOCATE_NAME_BUFFER(cLength)                           \
    ExAllocatePoolWithTag(PagedPool, cLength * sizeof(WCHAR), 'PsfD');       \

#define FREE_NAME_BUFFER(pName) ExFreePool(pName);

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                             \
 (PDFS_PREFIX_TABLE_ENTRY) ExAllocatePoolWithTag(PagedPool,sizeof(DFS_PREFIX_TABLE_ENTRY), 'PsfD')


#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry) ExFreePool(pEntry);

#define COMPARE_MEMORY(s,d,l)   (!RtlEqualMemory(s,d,l))

#define PREFIX_TABLE_ALLOCATE_MEMORY(size) ExAllocatePoolWithTag(PagedPool, size, 'PsfD')
#define PREFIX_TABLE_ALLOCATE_NONPAGED_MEMORY(size) ExAllocatePoolWithTag(NonPagedPool, size, 'PsfD')

#define PREFIX_TABLE_FREE_MEMORY(_p) ExFreePool(_p)

#define ALLOCATE_PREFIX_TABLE_LOCK() \
        PREFIX_TABLE_ALLOCATE_NONPAGED_MEMORY(sizeof(ERESOURCE))
        

#define FREE_PREFIX_TABLE_LOCK(_plock) PREFIX_TABLE_FREE_MEMORY(_plock)

// We may be holding the PrefixLock shared. Use Interlocks to change the LockCount.
#define UNLOCK_PREFIX_TABLE(_ptable) {InterlockedDecrement( (ULONG volatile *)&(_ptable)->LockCount ); ExReleaseResourceLite((_ptable)->pPrefixTableLock);}                 

#define WRITE_LOCK_PREFIX_TABLE(_ptable,_sts) {(_sts) = STATUS_UNSUCCESSFUL;if((ExAcquireResourceExclusiveLite((_ptable)->pPrefixTableLock, TRUE) == TRUE)){InterlockedIncrement((ULONG volatile *)&(_ptable)->LockCount);(_sts) = STATUS_SUCCESS;}}


#define READ_LOCK_PREFIX_TABLE(_ptable,_sts) {(_sts) = STATUS_UNSUCCESSFUL;if((ExAcquireResourceSharedLite((_ptable)->pPrefixTableLock, TRUE) == TRUE)){InterlockedIncrement((ULONG volatile *)&(_ptable)->LockCount);(_sts) = STATUS_SUCCESS;}}

#define INITIALIZE_PREFIX_TABLE_LOCK(_plock)  ExInitializeResourceLite(_plock)
#define UNINITIALIZE_PREFIX_TABLE_LOCK(_plock) ExDeleteResourceLite(_plock)

#else


#define ALLOCATE_PREFIX_TABLE_LOCK() \
        PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(CRITICAL_SECTION))
        
#define FREE_PREFIX_TABLE_LOCK(_plock) \
        PREFIX_TABLE_FREE_MEMORY(_plock)

#define PREFIX_TABLE_SPIN_COUNT 4000
#define INITIALIZE_PREFIX_TABLE_LOCK(_plock)    ((InitializeCriticalSectionAndSpinCount(_plock, PREFIX_TABLE_SPIN_COUNT) == FALSE) ? GetLastError() : STATUS_SUCCESS)
#define UNINITIALIZE_PREFIX_TABLE_LOCK(_plock)    DeleteCriticalSection(_plock)

#define UNLOCK_PREFIX_TABLE(_pTable) {(_pTable)->LockCount--; LeaveCriticalSection((_pTable)->pPrefixTableLock); }

#define READ_LOCK_PREFIX_TABLE(_ptable, _sts)   \
        WRITE_LOCK_PREFIX_TABLE(_ptable, _sts)
        
#define WRITE_LOCK_PREFIX_TABLE(_pTable, _sts ) \
        { EnterCriticalSection((_pTable)->pPrefixTableLock); (_pTable)->LockCount++; (_sts) = STATUS_SUCCESS; }


#define ALLOCATE_NAME_BUFFER(cLength) \
        PREFIX_TABLE_ALLOCATE_MEMORY(cLength * sizeof(WCHAR))
#define FREE_NAME_BUFFER(_pName)  \
        PREFIX_TABLE_FREE_MEMORY(_pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(_pTable) \
    (PDFS_PREFIX_TABLE_ENTRY)PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(DFS_PREFIX_TABLE_ENTRY))
#define FREE_DFS_PREFIX_TABLE_ENTRY(_pTable,_pEntry) \
    PREFIX_TABLE_FREE_MEMORY(_pEntry)

#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)


#if defined (PREFIX_TABLE_HEAP_MEMORY)

#define PREFIX_TABLE_ALLOCATE_MEMORY(_sz) \
        HeapAlloc(PrefixTableHeapHandle, 0, _sz)

#define PREFIX_TABLE_FREE_MEMORY(_addr) \
        HeapFree(PrefixTableHeapHandle, 0, _addr)

#else

#define PREFIX_TABLE_ALLOCATE_MEMORY(_sz) malloc(_sz)
#define PREFIX_TABLE_FREE_MEMORY(_addr) free(_addr)
#endif


#endif /*!Kernel mode */

#endif // __PREFIX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\prefix\wpp.h ===
//0c2c06fa Generated File. Do not edit.
// File created by WPP compiler version 0.01-Sat Apr  1 17:27:32 2000
// on 07/22/2000 at 04:41:51 UTC
//   
//   Source files: name_table.c prefix.c.

#ifndef _WPP_H_
#define _WPP_H_

#define _DFS_ENABLE_USER_AGENT        0x0001
#define _DFS_ENABLE_ERRORS            0x0002
#define _DFS_ENABLE_PREFIX            0x0004
#define _DFS_ENABLE_RPC               0x0008
#define _DFS_ENABLE_REFERRAL_SERVER   0x0010
#define _DFS_ENABLE_UNUSED11          0x0020
#define _DFS_ENABLE_UNUSED10          0x0040
#define _DFS_ENABLE_UNUSED9           0x0080
#define _DFS_ENABLE_UNUSED8           0x0100
#define _DFS_ENABLE_UNUSED7           0x0200
#define _DFS_ENABLE_UNUSED6           0x0400
#define _DFS_ENABLE_UNUSED5           0x0800
#define _DFS_ENABLE_UNUSED4           0x1000
#define _DFS_ENABLE_UNUSED3           0x2000
#define _DFS_ENABLE_UNUSED2           0x4000
#define _DFS_ENABLE_UNUSED1           0x8000


#define _LEVEL_HIGH                    0x1
#define _LEVEL_NORM                    0x2
#define _LEVEL_LOW                     0x4
#define LOG_FLAGS(_flag)      _DFS_ENABLE_ ## _flag


#define LOG_ENABLED( _level, _flags) \
            (( DfsRtlWmiReg.EnableLevel >= (_level) ) &&   \
             ( DfsRtlWmiReg.EnableFlags & _flags ))
            
#define DFS_LOG_ENABLED(_ArrayPrefix_, _Id_, _level, _flags) \
	((_ArrayPrefix_ ## ControlGuids[0].EnableFlags & _flags ) && \
        (_ArrayPrefix_ ## ControlGuids[0].EnableLevel >= (_level)))
            
#define DFS_LOG(_level, _flags, _id, _arg) \
    { \
        if ( DFS_LOG_ENABLED(PrefixLib_, _id, _level, _flags) ) { \
            WmlData.Trace( WPP_MSG_NO(_id), \
                     &WPP_TRACE_GUID(PrefixLib_,_id) , \
                     PrefixLib_ ## ControlGuids[0].LoggerHandle, _arg 0); \
        } \
    }            

#define SET_LIB_TRACE(_prefix) \
                _prefix ## ControlGuids = PrefixLib_ ## ControlGuids;

#define DFS_TRACE_NORM(_flags, _msg, _args) \
                DFS_LOG(_LEVEL_NORM, LOG_FLAGS(_flags), MSG_ID_WPP_AUTO_ID, _args)
#define DFS_TRACE_LOW(_flags, _msg, _args) \
                DFS_LOG(_LEVEL_LOW, LOG_FLAGS(_flags), MSG_ID_WPP_AUTO_ID, _args)
#define DFS_TRACE_HIGH( _flag, _msg, _arg)    \
                DFS_LOG(_LEVEL_HIGH, LOG_FLAGS(_flag), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_NORM(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_NORM, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_HIGH(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_HIGH, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_LOW(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_LOW, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

            


enum WPP_FILES {WPP_FILE_name_table_c,WPP_FILE_prefix_c,};

//
// Unless disabled, WPP selects one of the source
// files as a "guid store". That file will have definitions
// of trace and control arrays
//
#if defined(NAME_TABLE_C)
#define WPP_DEFINE_ARRAYS
#endif
 

#  define WPP_CONTROL_GUID_ARRAY PrefixLib_ControlGuids

//
// Define default flavors of the trace macro
//

#if defined(WMLUM_H) 
extern WML_DATA WmlData;
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) (*WmlData.Trace)(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#elif defined(WMLKM_H)
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WmlTrace(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#else
#  define WPP_PTRLEN
#  define WPP_USE_WmiTraceMessage
#  if defined(WPP_KERNEL_MODE)
#     define WPP_WMI_TRACE_MESSAGE WmiTraceMessage
#  else
#     define WPP_WMI_TRACE_MESSAGE TraceMessage
#  endif
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WPP_WMI_TRACE_MESSAGE(_lh,_fl,_guid,_id,_arg)
#endif


#if defined(WPP_DEFINE_ARRAYS)
#  define WPP_DEFINE_TRACE_GUIDS
#  define WPP_DEFINE_CONTROL_GUIDS
#endif


#define NOARGS // Yep. No args, alright.
#define LOGNOTHING 0,

#  define WPP_DEFINE_GRP_ID(_a,_b) ( ((_a) << 16) | ( _b) )
#  define WPP_CTRL_FLAGS(_id)      (1 << ((_id) & 0xFFFF) )
#  define WPP_CTRL_GUID_NO(_id)    ((_id) >> 16)


#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )
#  define WPP_MSG_NO(_id)            ((_id) & 0xFFFF)
#  define WPP_TRACE_GUID_NO(_id)     ((_id) >> 16)


#define WPP_TRACE_GUID(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## TraceGuids[ WPP_TRACE_GUID_NO(_Id_) ] )

#define WPP_LOGGER_HANDLE(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].LoggerHandle )
#define WPP_ENABLED(_ArrayPrefix_,_Id_) \
	(_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].EnableFlags & WPP_CTRL_FLAGS(_Id_) )

#define LOGARSTR(_Value_)	WPP_LOGASTR( _Value_ )
#define LOGBOOLEAN(_Value_)	WPP_LOGTYPEVAL(signed char, _Value_ )
#define LOGPTR(_Value_)	WPP_LOGTYPEVAL(void*, _Value_ )
#define LOGSTATUS(_Value_)	WPP_LOGTYPEVAL(signed int, _Value_ )
 
#  define MSG_ID_prefix_c114	WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_prefix_c163	WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_prefix_c69	WPP_DEFINE_MSG_ID(0,10)
 
extern GUID                         PrefixLib_TraceGuids[]; 
#define PrefixLib_TraceGuids_len    1      // I don't think we need this [BUGBUG]

#if defined(WPP_DECLARE_CONTROL_GUIDS)
extern WML_CONTROL_GUID_REG         WPP_CONTROL_GUID_ARRAY[]; 
#endif


#ifdef WPP_DEFINE_TRACE_GUIDS
#if 1  // if # traceguids > 0 
GUID PrefixLib_TraceGuids[] = {
 // 0da06be7-a84a-4d9b-be44-70a2e7917f35 prefix.c
 {0x0da06be7,0xa84a,0x4d9b,{0xbe,0x44,0x70,0xa2,0xe7,0x91,0x7f,0x35}}, // prefix.c
};
#endif
#endif // WPP_DEFINE_TRACE_GUIDS

#if defined(WMLUM_H)
# define WPP_INIT_TRACING_SIMPLE_EX(AppName, PrintFunc) \
    do { \
        DWORD status; \
	LOADWML(status, WmlData); \
        SetupReg( \
            AppName, \
            L"%SystemRoot%\\PrefixLib_.log",\
            ); \
	if (status == ERROR_SUCCESS) { \
		status = (*WmlData.Initialize)( \
			   AppName, \
			   PrintFunc, \
                           &WPP_CONTROL_GUID_ARRAY[0]); \
	} \
    } while(0)
# define WPP_INIT_TRACING_SIMPLE(AppName) WPP_INIT_TRACING_SIMPLE_EX(AppName, NULL)
#endif

#ifdef WPP_DEFINE_CONTROL_GUIDS
  #if defined(WMLUM_H) 
     WML_DATA WmlData;
  #endif

# if 0 == 0  // if # CtrlGuids == 0
    WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[1];
# else
WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[] = {
};
#endif
#endif // WPP_DEFINE_CONTROL_GUIDS


#define WPP_DEFAULT_GROUP_ID WPP_DEFINE_GRP_ID(0,0)

#if !defined(DFS_TRACE_ERROR_HIGH)
#define DFS_TRACE_ERROR_HIGH(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_ERROR_LOW)
#define DFS_TRACE_ERROR_LOW(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_ERROR_NORM)
#define DFS_TRACE_ERROR_NORM(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_HIGH)
#define DFS_TRACE_HIGH(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_LOW)
#define DFS_TRACE_LOW(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_NORM)
#define DFS_TRACE_NORM(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTrace)
#define SimpleTrace(MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTraceEx)
#define SimpleTraceEx(GRP, MSG, ARG) WPP_LOG(PrefixLib_, GRP, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if 0 // Real check is done in elif
#elif defined(NAME_TABLE_C) // name_table.c
#	define WPP_THIS_FILE name_table_c
#elif defined(PREFIX_C) // prefix.c
#	define WPP_THIS_FILE prefix_c
#endif 

#define WPP_EVAL(_value_) _value_
#define MSG_ID_WPP_AUTO_ID WPP_EVAL(MSG_ID_) ## WPP_EVAL(WPP_THIS_FILE) ## WPP_EVAL(__LINE__)

//
// WPP_CHECKED_ZERO will be expanded to 0, if 
// expression _value has the same size as the type _Type,
// or to division by 0, if the sizes are different
//
// This is poor man compile time argument checking. So don't be surprised
// if a compiler will tell you suddenly that you have a division by 0
// in line such and such
//

#define WPP_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WPP_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WPP_CHECKED_ZERO( _Value, _Type) )


#if defined(WPP_PTRLEN)
#  define WPP_LOGPAIR(_Size, _Addr) (_Addr),(_Size),
#else
#  define WPP_LOGPAIR(_Size, _Addr) (_Size),(_Addr),
#endif

# define WPP_LOGTYPEVAL(_Type, _Value) \
    WPP_LOGPAIR(WPP_CHECKED_SIZEOF(_Value, _Type), &(_Value))

# define WPP_LOGASTR(_value) \
    WPP_LOGPAIR( strlen(_value) + WPP_CHECKED_SIZEOF((_value)[0],CHAR), _value )

# define WPP_LOGWSTR(_value) \
    WPP_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WPP_CHECKED_SIZEOF((_value)[0],WCHAR), _value)

# define WPP_LOGCSTR(_x) \
    WPP_LOGPAIR( sizeof((_x).Length) + WPP_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

# define WPP_LOGUSTR(_x)                                                            \
    WPP_LOGPAIR( WPP_CHECKED_SIZEOF((_x).Length, short)                        \
                    + WPP_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

#  define WPP_LOG(_ArrayPrefix_, _Group_, _Id_, _Msg_, _Args_) \
       if (!WPP_ENABLED(_ArrayPrefix_, _Group_)) {;} else \
           WPP_TRACE_MESSAGE(WPP_LOGGER_HANDLE(_ArrayPrefix_, _Group_), \
                             WPP_TRACE_FLAGS, \
                             WPP_TRACE_GUID(_ArrayPrefix_,_Id_), \
                             WPP_MSG_NO(_Id_), _Msg_, _Args_)


#endif // _WPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\gensecurity.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       gensecurity.c
//
//  Contents:   
//
//  History:    
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "rpc.h"
#include "rpcdce.h"
#include <ole2.h>
#include <activeds.h>
#include <WinLdap.h>
#include <NtLdap.h>
#include <ntdsapi.h>
#include "dfsheader.h"
#include "dfsmisc.h"

PVOID
DfsAllocateSecurityData(ULONG Size )
{
    PVOID   pBuff = NULL;

    pBuff  = (PVOID) malloc (Size);

    return pBuff;
}


VOID
DfsDeallocateSecurityData(PVOID pPointer )
{
    if(pPointer)
    {
        free (pPointer);
    }
}


DFSSTATUS 
AccessImpersonateCheckRpcClientEx(PSECURITY_DESCRIPTOR DfsAdminSecurityDesc,
                                  GENERIC_MAPPING * DfsAdminGenericMapping,
                                  DWORD DesiredAccess)
{
    BOOL accessGranted = FALSE;
    DWORD grantedAccess = 0;
    HANDLE clientToken = NULL;
    DWORD privilegeSetSize = 0;
    DFSSTATUS dwErr = 0;
    DFSSTATUS RevertStatus = 0;
    BYTE privilegeSet[500];                      // Large buffer

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
    {
       return ERROR_ACCESS_DENIED;
    }

    privilegeSetSize = sizeof(privilegeSet);

    if (OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY, 
                        TRUE, &clientToken)) 
    {
        if (AccessCheck(
                DfsAdminSecurityDesc,
                clientToken,
                DesiredAccess,
                DfsAdminGenericMapping,
                (PPRIVILEGE_SET) privilegeSet,
                &privilegeSetSize,
                &grantedAccess,
                &accessGranted) != TRUE) 
        {           
            accessGranted = FALSE; // paranoia
            //
            // No need to call GetLastError since we intend to return
            // ACCESS_DENIED regardless.
            //                                       

            dwErr = GetLastError();


        }


    }

    RevertStatus = RpcRevertToSelf();

    if (clientToken != NULL)
    {
       CloseHandle( clientToken );
    }

    if( !accessGranted )
    {
       dwErr = ERROR_ACCESS_DENIED;
    }

    return dwErr;
}


VOID    DumpSID(
    CHAR        *pad,
    PSID        sid_to_dump,
    ULONG       Flag
    )
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      us;
 
    Flag;

    if (sid_to_dump)
    {
  WCHAR rgchName[256];
  DWORD cbName = sizeof(rgchName);
  WCHAR rgchDomain[256];
  DWORD cbDomain = sizeof(rgchDomain);
  SID_NAME_USE snu;
  
        ntstatus = RtlConvertSidToUnicodeString(&us, sid_to_dump, TRUE);
 
        if (NT_SUCCESS(ntstatus))
        {
            printf("%s%wZ", pad, &us);
            RtlFreeUnicodeString(&us);
        }
        else
        {
            printf("0x%08lx: Can't Convert SID to UnicodeString\n", ntstatus);
        }
 
  if (LookupAccountSid(NULL, sid_to_dump, rgchName, &cbName, rgchDomain, &cbDomain, &snu))
  {
   printf(" %ws\\%ws:", rgchDomain, rgchName);
   switch (snu)
   {
    case SidTypeUser:
     printf("User");
     break;
    case SidTypeGroup:
     printf("Group");
     break;
    case SidTypeDomain:
     printf("Domain");
     break;
    case SidTypeAlias:
     printf("Alias");
     break;
    case SidTypeWellKnownGroup:
     printf("Well Known Group");
     break;
    case SidTypeDeletedAccount:
     printf("Deleted Account");
     break;
    case SidTypeInvalid:
     printf("Invalid");
     break;
    case SidTypeUnknown:
     printf("Unknown");
     break;
    case SidTypeComputer:
     printf("Computer");
     break;
    default:
     printf("Unknown use: %d\n", snu);
    
   }
  }
  printf("\n");
    }
    else
    {
        printf("%s is NULL\n", pad);
    }
}

 
/*
 - DumpToken
 -
 * Purpose:
 *  to dump a token
 *
 * Parameters:
 * 
 *  pad  IN  the string the prepend
 *  htoken IN  the token to dump
 */
BOOL
DumpToken(
 IN char *pad,
 IN HANDLE htoken)
{
 BOOL fRet;
 DWORD dwError;
 DWORD dwLenNeeded;
 BYTE rgb[128];
 PTOKEN_USER ptu = (PTOKEN_USER) rgb;
 PTOKEN_USER ptuToFree = NULL;
 TOKEN_PRIMARY_GROUP *ptpg = (TOKEN_PRIMARY_GROUP*) rgb;
 TOKEN_PRIMARY_GROUP *ptpgToFree = NULL;
 TOKEN_GROUPS *ptg = (TOKEN_GROUPS*) rgb;
 TOKEN_GROUPS *ptgToFree = NULL;
 
 // dump token user
 fRet = GetTokenInformation(htoken, TokenUser, (void*) ptu, sizeof(rgb), &dwLenNeeded);
 if (!fRet)
 {
  dwError = GetLastError();
  if (dwError == ERROR_INSUFFICIENT_BUFFER)
  {
   ptuToFree = (PTOKEN_USER) malloc(dwLenNeeded);
   if (!ptuToFree)
   {
    printf("OOM\n");
    goto Error;
   }
   ptu = ptuToFree;
   fRet = GetTokenInformation(htoken, TokenUser, (void*) ptu, dwLenNeeded, &dwLenNeeded);
   if (!fRet)
   {
    dwError = GetLastError();
   }
  }
 }
 
 if (fRet)
 {
  printf("%s Token user is:\n", pad);
  DumpSID("", ptu->User.Sid, 0);
 }
 else
 {
  printf("%s 0x%08lx: Failed to get TokenUser\n", pad, dwError);
 }
 
 // dump token primary group
 fRet = GetTokenInformation(htoken, TokenPrimaryGroup, (void*) ptpg, sizeof(rgb), &dwLenNeeded);
 if (!fRet)
 {
  dwError = GetLastError();
  if (dwError == ERROR_INSUFFICIENT_BUFFER)
  {
   ptpgToFree = (TOKEN_PRIMARY_GROUP*) malloc(dwLenNeeded);
   if (!ptpgToFree)
   {
    printf("OOM\n");
    goto Error;
   }
   ptpg = ptpgToFree;
   fRet = GetTokenInformation(htoken, TokenPrimaryGroup, (void*) ptpg, dwLenNeeded, &dwLenNeeded);
   if (!fRet)
   {
    dwError = GetLastError();
   }
  }
 }
 
 if (fRet)
 {
  printf("%s Token's primary group is: \n", pad);
  DumpSID("", ptpg->PrimaryGroup, 0);
 }
 else
 {
  printf("%s 0x%08lx: Failed to get TokenPrimaryGroup\n", pad, dwError);
 }
 
 // dump token groups
 // TODO: add code to dump group attributes (in Text format)
 fRet = GetTokenInformation(htoken, TokenGroups, (void*) ptg, sizeof(rgb), &dwLenNeeded);
 if (!fRet)
 {
  dwError = GetLastError();
  if (dwError == ERROR_INSUFFICIENT_BUFFER)
  {
   ptgToFree = (TOKEN_GROUPS*) malloc(dwLenNeeded);
   if (!ptgToFree)
   {
    printf("OOM\n");
    goto Error;
   }
   ptg = ptgToFree;
   fRet = GetTokenInformation(htoken, TokenGroups, (void*) ptg, dwLenNeeded, &dwLenNeeded);
   if (!fRet)
   {
    dwError = GetLastError();
   }
  }
 }
 
 if (fRet)
 {
  UINT i;
  
  printf("%s token's groups are:\n", pad);
  for (i = 0; i < ptg->GroupCount; i++)
  {
   DumpSID("", ptg->Groups[i].Sid, 0);
  }
 }
 else
 {
  printf("%s 0x%08lx: Failed to get TokenGroups\n", pad, dwError);
 }
 
 // TODO: add code to dump other stuff later
 
 
Cleanup:
 if (ptuToFree)
 {
  free(ptuToFree);
 }
 if (ptpgToFree)
 {
  free(ptpgToFree);
 }
 if (ptgToFree)
 {
  free(ptgToFree);
 }
 return fRet;
 
Error:
 fRet = FALSE;
 goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\adsecurity.c ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       Adsecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April 16 2002,   Author: Rohanp
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>
#include <shellapi.h>
#include <ole2.h>
#include <activeds.h>
#include <sddl.h>
#include <WinLdap.h>
#include <NtLdap.h>
#include <ntdsapi.h>
#include <dfssecurity.h>
#include "securitylogmacros.hxx"


#include "adsecurity.tmh"

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"


#define DFS_DS_GENERIC_READ         ( DS_GENERIC_READ & ~ACTRL_DS_LIST_OBJECT )
#define DFS_DS_GENERIC_WRITE        ( DS_GENERIC_WRITE )
#define DFS_DS_GENERIC_EXECUTE      ( DS_GENERIC_EXECUTE )
#define DFS_DS_GENERIC_ALL          ( DS_GENERIC_ALL & ~ACTRL_DS_LIST_OBJECT )
     

GENERIC_MAPPING DfsAdAdminGenericMapping = {

        DFS_DS_GENERIC_READ,                    // Generic read

        DFS_DS_GENERIC_WRITE,                   // Generic write

        DFS_DS_GENERIC_EXECUTE,
        DFS_DS_GENERIC_ALL
    };


DFSSTATUS
DfsReadDSObjSecDesc(
    LDAP * pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PLDAPMessage pMsg = NULL;
    LDAPMessage *pEntry = NULL;
    PWSTR *ppwszValues = NULL;
    PLDAP_BERVAL *pSize = NULL;
    PWSTR rgAttribs[2];
    BYTE berValue[8];

    LDAPControl SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);


    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;

    Status = ldap_search_ext_s(
                    pLDAP,
                    pwszObject,
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    rgAttribs,
                    0,
                    (PLDAPControl *)ServerControls,
                    NULL,
                    NULL,
                    10000,
                    &pMsg);

    Status = LdapMapErrorToWin32( Status );
    if(Status == ERROR_SUCCESS) 
     {
        pEntry = ldap_first_entry(pLDAP, pMsg);
        if(pEntry == NULL) 
        {
            Status = LdapMapErrorToWin32( pLDAP->ld_errno );
        }
        else 
        {
            //
            // Now, we'll have to get the values
            //
            ppwszValues = ldap_get_values(pLDAP, pEntry, rgAttribs[0]);
            if(ppwszValues != NULL) 
             {
                pSize = ldap_get_values_len(pLDAP, pMsg, rgAttribs[0]);
                if(pSize != NULL)                     
                {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)DfsAllocateSecurityData((*pSize)->bv_len);
                    if(*ppSD != NULL) 
                    {
                        memcpy(*ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
                        *pcSDSize = (*pSize)->bv_len;
                    } 
                    else 
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    ldap_value_free_len(pSize);
                } 
                else 
                {
                    Status = LdapMapErrorToWin32( pLDAP->ld_errno );
                }

                ldap_value_free(ppwszValues);
            } 
            else 
            {
                Status = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
        } 
    }

    if (pMsg != NULL)
    {
        ldap_msgfree(pMsg);
    }
    
    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsGetObjSecurity
//
//  Synopsis:   Gets the ACL list of an object in sddl stringized form
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [pwszStringSD]  --  Pointer to pointer to SD in string form (sddl)
//
//  Returns:    ERROR_SUCCESS   --  The object is reachable
//
//----------------------------------------------------------------------------
DFSSTATUS
DfsGetObjSecurity(LDAP *pldap,
                  LPWSTR pwszObjectName,
                  PSECURITY_DESCRIPTOR * pSDRet)
{

    DFSSTATUS Status = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG cSDSize = 0;
    SECURITY_INFORMATION si;

    //get everything we can think of
   // si = ( DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | 
         //  GROUP_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION |
         //  PROTECTED_SACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION |
         //  UNPROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION);


    si = ( DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | 
           GROUP_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION);
    Status = DfsReadDSObjSecDesc(
            pldap,
            pwszObjectName,
            si,
            &pSD,
            &cSDSize);

    if(Status == ERROR_SUCCESS)
    {
      *pSDRet = pSD;
    }

    return Status;
}


DFSSTATUS
DfsChangeDSObjSecDesc(LDAP * pLDAP,
                      PWSTR ObjectName,
                      PSECURITY_DESCRIPTOR pSecurityDescriptor,
                      SECURITY_INFORMATION SeInfo)
{
    DFSSTATUS       Status = 0;
    PLDAPMod        rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPMod         Mod;
    LDAP_BERVAL     BVal;
    BYTE            berValue[8];

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };


    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    if ( pSecurityDescriptor == NULL )
        BVal.bv_len = 0;
    else 
    {
        BVal.bv_len = RtlLengthSecurityDescriptor(pSecurityDescriptor);
    }

    BVal.bv_val = (PCHAR)(pSecurityDescriptor);

    Status = ldap_modify_ext_s(pLDAP,
                           ObjectName,
                           rgMods,
                           (PLDAPControl *)ServerControls,
                           NULL);

    return Status;
}


DFSSTATUS
DfsDoesUserHaveDesiredAccessToAd(DWORD DesiredAccess, 
                                 PSECURITY_DESCRIPTOR pSD)
{
    DFSSTATUS Status = 0;
    DWORD dwDesiredAccess = DesiredAccess;


    MapGenericMask(&dwDesiredAccess, &DfsAdAdminGenericMapping);

    Status = AccessImpersonateCheckRpcClientEx(pSD, 
                                               &DfsAdAdminGenericMapping,
                                               dwDesiredAccess);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\filesecurity.cxx ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       filesecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April 16 2002,   Author: Rohanp
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>
#include <shellapi.h>
#include <Aclapi.h>
#include <authz.h>
#include <lm.h>
             

extern             
DWORD 
DfsIsAccessGrantedBySid(DWORD dwDesiredAccess,
                        PSECURITY_DESCRIPTOR pSD, 
                        PSID TheSID,
                        GENERIC_MAPPING * DfsGenericMapping);

GENERIC_MAPPING DfsFileGenericMapping = {

        FILE_GENERIC_READ,                    // Generic read

        FILE_GENERIC_WRITE,                   // Generic write

        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
    };









DWORD
DfsGetFileSecurityByHandle(IN  HANDLE  hFile,
                           OUT PSECURITY_DESCRIPTOR    *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;
    NTSTATUS Status = 0;
    ULONG   cNeeded = 0;
    SECURITY_INFORMATION  SeInfo;

    SeInfo = DACL_SECURITY_INFORMATION |GROUP_SECURITY_INFORMATION |OWNER_SECURITY_INFORMATION;

    Status = NtQuerySecurityObject(hFile,
                                       SeInfo,
                                       *ppSD,
                                       0,
                                       &cNeeded);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL)
         {
            Status = STATUS_SUCCESS;
         }
    }

    dwErr = RtlNtStatusToDosError(Status);

    //
    // Now, the actual read
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppSD = (PISECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cNeeded);
        if(*ppSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = NtQuerySecurityObject(hFile,
                                           SeInfo,
                                           *ppSD,
                                           cNeeded,
                                           &cNeeded);
        }
    }

    return(dwErr);
}


DWORD
DfsGetFileSecurityByName(PUNICODE_STRING DirectoryName, 
                         PSECURITY_DESCRIPTOR  *pSD2)
{
    DWORD Status = 0;
    ULONG cpsd = 0;
    PSECURITY_DESCRIPTOR  pSD = NULL;
    LPCTSTR   pDir = NULL;

    pDir = &DirectoryName->Buffer[4];
    if (!GetFileSecurity((LPCTSTR)pDir,
         DACL_SECURITY_INFORMATION |
         GROUP_SECURITY_INFORMATION |
         OWNER_SECURITY_INFORMATION,
         NULL,
         0,
         &cpsd) )
    {
        Status = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == Status)
        {
            if ( NULL == ( pSD = (PSECURITY_DESCRIPTOR )LocalAlloc(LMEM_FIXED, cpsd)))
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            Status = 0;

            if (!GetFileSecurity((LPCTSTR)pDir,
                 DACL_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 OWNER_SECURITY_INFORMATION,
                 pSD,
                 cpsd,
                 &cpsd) )
            {

                Status = GetLastError();
            }
        }

    }

    *pSD2 = pSD;

    return Status;
}



DWORD
DoesLocalSystemHaveWriteAccess(PSECURITY_DESCRIPTOR pSD)
{
    DWORD SidSize = 0;
    DWORD Status = 0;
    DWORD dwError = 0;
    DWORD dwDesiredAccess = 0;
    BOOL RetVal = FALSE;
    PSID TheSID = NULL;

    SidSize = SECURITY_MAX_SID_SIZE;

    // Allocate enough memory for the largest possible SID
    TheSID = LocalAlloc(LMEM_FIXED, SidSize);
    if(!TheSID)
    {
        Status = GetLastError(); 
        goto Exit;
    }

    if(!CreateWellKnownSid(WinLocalSystemSid, NULL, TheSID, &SidSize))
    {
        Status = GetLastError(); 
        goto Exit;
    }


    Status = DfsIsAccessGrantedBySid(GENERIC_WRITE,
                                     pSD, 
                                     TheSID,
                                     &DfsFileGenericMapping);


Exit:

    if(TheSID)
    {
        LocalFree (TheSID);
    }

    return Status;
}

DWORD
CheckDirectoryForLocalSystemAccess(PUNICODE_STRING DirectoryName)
{
    DWORD Status = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    Status = DfsGetFileSecurityByName(DirectoryName, 
                                      &pSD);
    if(Status == ERROR_SUCCESS)
    {
        Status = DoesLocalSystemHaveWriteAccess(pSD);
    }

    if(pSD)
    {
        LocalFree(pSD);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\processsecurity.c ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       Processsecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April 16 2002,   Author: Rohanp
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>
#include <shellapi.h>
#include <Aclapi.h>
#include <authz.h>
#include <lm.h>
#include "securitylogmacros.hxx"

DFSSTATUS
DfsRemoveDisabledPrivileges (void)
{
 
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD BufferSize = 0;
    BOOL ProcessOpened = FALSE;
    HANDLE   hProcessToken = INVALID_HANDLE_VALUE;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    DWORD i = 0;

    #define PRIVILEGE_NAME_LENGTH MAX_PATH
    WCHAR PrivilegeName[PRIVILEGE_NAME_LENGTH];
    DWORD PrivilegeNameLength = PRIVILEGE_NAME_LENGTH;

    //
    // Open the token.
    //

    ProcessOpened = OpenProcessToken(GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hProcessToken);

    if (Status != ERROR_SUCCESS)

    {
        Status =  GetLastError();
        goto Cleanup;
    }

    //
    // First find out the buffer size we need.
    //

    GetTokenInformation(hProcessToken,
                        TokenPrivileges,
                        NULL,
                        0,
                        &BufferSize
                        );

 
    //
    // Allocate the buffer and get the info
    //


    pTokenPrivs = (PTOKEN_PRIVILEGES) LocalAlloc(LMEM_FIXED, BufferSize);
    if(pTokenPrivs == NULL)
    {
        Status = GetLastError();
        goto Cleanup;
    }

    if(!GetTokenInformation(hProcessToken,
                            TokenPrivileges,
                            pTokenPrivs,
                            BufferSize,
                            &BufferSize)) 
    {
            Status = GetLastError();
            goto Cleanup;
    }
 
    //
    // Find all non-enabled privileges and mark them for removal
    //

 

    for(i=0; i < pTokenPrivs->PrivilegeCount; i++) 
    {
            if(!(pTokenPrivs->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED)) 
                {
                    pTokenPrivs->Privileges[i].Attributes = SE_PRIVILEGE_REMOVED;    

                    if(!LookupPrivilegeName(NULL,
                                            &(pTokenPrivs->Privileges[i].Luid),
                                            PrivilegeName,
                                            &PrivilegeNameLength))
                    {


                    } 
                    else 
                    {

                    }
            }
    }

    //
    // Now, actually remove the privileges
    //

    if(!AdjustTokenPrivileges(hProcessToken,
                              FALSE,
                              pTokenPrivs,
                              BufferSize,
                              NULL,
                              NULL)) 
    {
            Status = GetLastError();
            goto Cleanup;
    }

    Status = GetLastError();
    if(Status == ERROR_NOT_ALL_ASSIGNED)
    {
      goto Cleanup;
    }
    


Cleanup:

    if(hProcessToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hProcessToken);
    }

    if(pTokenPrivs)
    {
        LocalFree (pTokenPrivs);
    }

    return Status;
}


DFSSTATUS
DfsAdjustPrivilege(ULONG Privilege, 
                   BOOLEAN bEnable)
{
    NTSTATUS NtStatus = 0;
    DFSSTATUS Status = 0;
    BOOLEAN WasEnabled = FALSE;

    NtStatus = RtlAdjustPrivilege(Privilege, bEnable, FALSE, &WasEnabled);
    if(!NT_SUCCESS(NtStatus))
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\processsecurity.cxx ===
//
//  Copyright (C) 2000-2002, Microsoft Corporation
//
//  File:       Processsecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April 16 2002,   Author: Rohanp
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>
#include <shellapi.h>
#include <Aclapi.h>
#include <authz.h>
#include <lm.h>

DFSSTATUS
DfsRemoveDisabledPrivileges (void)
{
 
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD BufferSize = 0;
    BOOL ProcessOpened = FALSE;
    HANDLE   hProcessToken = INVALID_HANDLE_VALUE;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    DWORD i = 0;

    #define PRIVILEGE_NAME_LENGTH MAX_PATH
    WCHAR PrivilegeName[PRIVILEGE_NAME_LENGTH];
    DWORD PrivilegeNameLength = PRIVILEGE_NAME_LENGTH;

    //
    // Open the token.
    //

    ProcessOpened = OpenProcessToken(GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hProcessToken);

    if (Status != ERROR_SUCCESS)

    {
        Status =  GetLastError();
        goto Cleanup;
    }

    //
    // First find out the buffer size we need.
    //

    GetTokenInformation(hProcessToken,
                        TokenPrivileges,
                        NULL,
                        0,
                        &BufferSize
                        );

 
    //
    // Allocate the buffer and get the info
    //


    pTokenPrivs = (PTOKEN_PRIVILEGES) LocalAlloc(LMEM_FIXED, BufferSize);
    if(pTokenPrivs == NULL)
    {
        Status = GetLastError();
        goto Cleanup;
    }

    if(!GetTokenInformation(hProcessToken,
                            TokenPrivileges,
                            pTokenPrivs,
                            BufferSize,
                            &BufferSize)) 
    {
            Status = GetLastError();
            goto Cleanup;
    }
 
    //
    // Find all non-enabled privileges and mark them for removal
    //

 

    for(i=0; i < pTokenPrivs->PrivilegeCount; i++) 
    {
            if(!(pTokenPrivs->Privileges[i].Attributes & 

               (SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT))) 
                {
                    pTokenPrivs->Privileges[i].Attributes = SE_PRIVILEGE_REMOVED;    

                    if(!LookupPrivilegeName(NULL,
                                            &(pTokenPrivs->Privileges[i].Luid),
                                            PrivilegeName,
                                            &PrivilegeNameLength))
                    {


                    } 
                    else 
                    {

                    }
            }
    }

    //
    // Now, actually remove the privileges
    //

    if(!AdjustTokenPrivileges(hProcessToken,
                              FALSE,
                              pTokenPrivs,
                              BufferSize,
                              NULL,
                              NULL)) 
    {
            Status = GetLastError();
            goto Cleanup;
    }


Cleanup:

    if(hProcessToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hProcessToken);
    }

    if(pTokenPrivs)
    {
        LocalFree (pTokenPrivs);
    }

    return Status;
}


DFSSTATUS
DfsEnablePrivilege(ULONG Privilege, LPCTSTR PrivName)
{
    NTSTATUS NtStatus = 0;
    DFSSTATUS Status = 0;
    BOOLEAN WasEnabled = FALSE;

    UNREFERENCED_PARAMETER(PrivName);

    NtStatus = RtlAdjustPrivilege(Privilege, TRUE, FALSE, &WasEnabled);
    if(!NT_SUCCESS(NtStatus))
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\securitylogmacros.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsLogMacros.cxx
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    Marc 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------
       
#include <windows.h>
#include "dfswmi.h"
#include "securityLogMacros.hxx"
#include "securityLogMacros.tmh"

PVOID pSecurityControl = NULL;

void SetSecurityControl(WPP_CB_TYPE * Control)
{
    pSecurityControl = (PVOID)Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\shash\shash.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shash.c
//
//  Contents:   Generic hashtable
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifdef KERNEL_MODE


#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif
    

#include <shash.h>

extern
ULONG
SHashComputeHashValue(
    IN  void*   lpv 
    );

extern
int
SHashMatchNameKeysCaseInsensitive(  void*   pvKey1, 
                                    void*   pvKey2
                                    );

extern
void*
SHashAllocate(   ULONG   cbAlloc  );

extern
void
SHashFree( void*   lpv );

extern
BOOLEAN 
SHashReadLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashWriteLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashReadUnLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashWriteUnLockTable(PSHASH_TABLE pTable);

void * 
SHashAllocLock(void);

void 
SHashFreeLock(void * pMem);

DWORD g_ExpireSeconds = SHASH_DEFAULT_HASHTIMEOUT;

DWORD
ShashInitializeFunctionTable(PSHASH_TABLE pHashTable,
                             PSHASH_FUNCTABLE pFuncTable)
{

    pHashTable->HashFunc = SHashComputeHashValue;
    pHashTable->CompareFunc = SHashMatchNameKeysCaseInsensitive;

    pHashTable->AllocFunc = SHashAllocate;
    pHashTable->FreeFunc = SHashFree;
    pHashTable->AllocHashEntryFunc = SHashAllocate;
    pHashTable->FreeHashEntryFunc = SHashFree;
    
    pHashTable->AllocLockFunc = SHashAllocLock;    
    pHashTable->FreeLockFunc = SHashFreeLock;
    

    pHashTable->WriteLockFunc = SHashWriteLockTable;
    pHashTable->ReadLockFunc = SHashReadLockTable;
    pHashTable->ReleaseWriteLockFunc = SHashWriteUnLockTable;
    pHashTable->ReleaseReadLockFunc = SHashReadUnLockTable;


    if(pFuncTable->HashFunc)
    {
        pHashTable->HashFunc = pFuncTable->HashFunc;
    }


    if(pFuncTable->CompareFunc)
    {
        pHashTable->CompareFunc = pFuncTable->CompareFunc;
    }


    if ((pFuncTable->AllocFunc) || (pFuncTable->FreeFunc))
    {
        if ((pFuncTable->AllocFunc == NULL) ||
            (pFuncTable->FreeFunc == NULL))
        {
            return STATUS_INVALID_PARAMETER;
        }
        pHashTable->AllocFunc = pFuncTable->AllocFunc;
        pHashTable->FreeFunc = pFuncTable->FreeFunc;
        //
        // If Alloc/Free functions are user-defined, then AllocHashEntry and FreeHashEntry
        // will also default to those same AllocFunc and FreeFunc calls. These can of course,
        // be overridden with their own user-defined functions (see below).
        //
        pHashTable->AllocHashEntryFunc = pFuncTable->AllocFunc;
        pHashTable->FreeHashEntryFunc = pFuncTable->FreeFunc;
    }

    // separate alloc/free functions for individual hash data.
    if ((pFuncTable->AllocHashEntryFunc) || (pFuncTable->FreeHashEntryFunc))
    {
        if ((pFuncTable->AllocHashEntryFunc == NULL) ||
            (pFuncTable->FreeHashEntryFunc == NULL))
        {
            return STATUS_INVALID_PARAMETER;
        }
        pHashTable->AllocHashEntryFunc = pFuncTable->AllocHashEntryFunc;
        pHashTable->FreeHashEntryFunc = pFuncTable->FreeHashEntryFunc;
    }

    if ((pFuncTable->AllocLockFunc) || (pFuncTable->FreeLockFunc))
    {
        if ((pFuncTable->AllocLockFunc == NULL) || 
            (pFuncTable->FreeLockFunc == NULL))
        {
            return STATUS_INVALID_PARAMETER;
        }
        pHashTable->AllocLockFunc = pFuncTable->AllocLockFunc;    
        pHashTable->FreeLockFunc = pFuncTable->FreeLockFunc;
    }

    if ((pFuncTable->WriteLockFunc) || (pFuncTable->ReadLockFunc) ||
        (pFuncTable->ReleaseWriteLockFunc) || (pFuncTable->ReleaseReadLockFunc))
    {
        pHashTable->WriteLockFunc = pFuncTable->WriteLockFunc;
        pHashTable->ReadLockFunc = pFuncTable->ReadLockFunc;
        pHashTable->ReleaseWriteLockFunc = pFuncTable->ReleaseWriteLockFunc;
        pHashTable->ReleaseReadLockFunc = pFuncTable->ReleaseReadLockFunc;
    }

    if(pFuncTable->NumBuckets)
    {
        pHashTable->NumBuckets = pFuncTable->NumBuckets;
    }
    else
    {
        pHashTable->NumBuckets = SHASH_DEFAULT_HASH_SIZE;

    }

    //test to see if buckets is a power of 2
    if((pHashTable->NumBuckets & (pHashTable->NumBuckets - 1)) == 0)
    {
        pHashTable->Flags = SHASH_CAP_POWER_OF2;
    }

    pHashTable->Flags |= pFuncTable->Flags;

    return STATUS_SUCCESS;
}

ULONG
ShashComputeNearestPowerOfTwo(ULONG Value)
{
    ULONG PowerOf2 = Value;

    while( PowerOf2 & (PowerOf2 - 1) )
    {
        PowerOf2 = PowerOf2 & (PowerOf2 - 1) ;
    }

    PowerOf2 <<= 1 ;

    return PowerOf2;
}

NTSTATUS 
ShashInitHashTable(
    PSHASH_TABLE *ppHashTable,
    PSHASH_FUNCTABLE pFuncTable)
{
    PSHASH_TABLE pHashTable = NULL;
    ULONG cbHashTable = 0;
    DWORD LoopVar = 0;
    ULONG NumBuckets = SHASH_DEFAULT_HASH_SIZE;
    NTSTATUS Status = STATUS_SUCCESS;
    PFNALLOC lAllocFunc = SHashAllocate;
    PFNFREE  lFreeFunc = SHashFree;

    if(pFuncTable && pFuncTable->NumBuckets)
    {
      NumBuckets = pFuncTable->NumBuckets;
    }


    if(pFuncTable)
    {
        if ((pFuncTable->AllocFunc != NULL) &&
            (pFuncTable->FreeFunc != NULL))
        {
            lAllocFunc = pFuncTable->AllocFunc;
            lFreeFunc =  pFuncTable->FreeFunc;
        }
    }

    cbHashTable = sizeof(SHASH_TABLE) + NumBuckets * sizeof(SHASH_ENTRY);
    pHashTable = lAllocFunc (cbHashTable);
    if (pHashTable == NULL) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }


    Status = ShashInitializeFunctionTable(pHashTable,
                                          pFuncTable);
    if (Status != STATUS_SUCCESS)
    {
        lFreeFunc(pHashTable);
        goto Exit;
    }

    pHashTable->pLock = pHashTable->AllocLockFunc();
    if(pHashTable->pLock == NULL)
    {
      lFreeFunc (pHashTable);
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
    }

    RtlZeroMemory(&pHashTable->HashBuckets[0], NumBuckets * sizeof(SHASH_ENTRY));

    *ppHashTable = pHashTable; 
        
    for(LoopVar = 0; LoopVar < NumBuckets; LoopVar++)
    {
        InitializeListHead(&pHashTable->HashBuckets[LoopVar].ListHead);
    }

Exit:

    return Status;
}

void 
ShashTerminateHashTable(
    PSHASH_TABLE pHashTable
    )
{
    PFNFREE  FreeFunc = NULL;
    if(pHashTable != NULL)
    {
        pHashTable->FreeLockFunc( pHashTable->pLock);
        FreeFunc = pHashTable->FreeFunc;

        FreeFunc (pHashTable);
    }
}

NTSTATUS
SHashInsertKey(IN   PSHASH_TABLE    pTable, 
               IN   void *  pData,
               IN   void *  pvKeyIn,
               IN   DWORD   InsertFlag)
{
    ULONG dwHash = 0;    
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ple = NULL;
    PLIST_ENTRY pleRemove = NULL;
    PLIST_ENTRY pleStart = NULL;
    PSHASH_HEADER pEntry = NULL;
    PSHASH_HEADER pHeader = NULL;
    int iSign = 0;
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;

    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
        dwHash = dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
        dwHash = dwHash % pTable->NumBuckets;
    }

    LockAquired = pTable->WriteLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    pHeader = (PSHASH_HEADER) pData;
    pHeader->dwHash = dwHash;

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart )
    {
        pEntry = CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc(pEntry->pvKey, pvKeyIn ) ;
        if( iSign > 0 )
        {
            break ;
        }
        else if((InsertFlag == SHASH_FAIL_IFFOUND) && (iSign == 0))
        {
            Status = STATUS_OBJECT_NAME_COLLISION;
            goto Exit;
        }
        else if((InsertFlag == SHASH_REPLACE_IFFOUND) && (iSign == 0))
        {
            pEntry->Flags |= SHASH_FLAG_DELETE_PENDING;
            if(InterlockedDecrement(&pEntry->RefCount) == 0)
            {
                pleRemove = ple;
                ple = ple->Flink;
                RemoveEntryList( pleRemove ) ;
                
                InterlockedDecrement(&pTable->HashBuckets[dwHash].Count);
                InterlockedDecrement(&pTable->TotalItems);
                pTable->FreeHashEntryFunc(pEntry);
            }
            break;
        }

        ple = ple->Flink ;
    }


    InterlockedIncrement(&pHeader->RefCount);
               
    InsertTailList( ple, &pHeader->ListEntry ) ;
    InterlockedIncrement(&pTable->HashBuckets[dwHash].Count);
    InterlockedIncrement(&pTable->TotalItems);


Exit:

    if(LockAquired)
    {
        pTable->ReleaseWriteLockFunc(pTable);
    }

    return  Status;
}


//
//  Remove an item from the hash table 
//
NTSTATUS    
SHashRemoveKey( IN  PSHASH_TABLE    pTable, 
                IN  void *      pvKeyIn,
                IN  PFNREMOVEKEY pRemoveFunc
                )   
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY pleStart = NULL ;
    PLIST_ENTRY ple= NULL ;
    PSHASH_HEADER pEntry = NULL;
    int iSign = 0; 
    DWORD   dwHash = 0; 
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;
    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
         dwHash= dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
         dwHash = dwHash % pTable->NumBuckets;
    }

    LockAquired = pTable->WriteLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart ) 
    {
        pEntry = (PSHASH_HEADER) CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc( pEntry->pvKey, pvKeyIn ) ;
        if( iSign == 0 ) 
         {
            if(pRemoveFunc)
            {
                pRemoveFunc(pEntry);
            }

            pEntry->Flags |= SHASH_FLAG_DELETE_PENDING;

            if(InterlockedDecrement(&pEntry->RefCount) == 0)
            {
                RemoveEntryList( ple ) ;

                InterlockedDecrement(&pTable->HashBuckets[dwHash].Count);
                InterlockedDecrement(&pTable->TotalItems);
                pTable->FreeHashEntryFunc(pEntry);
            }

            break;
        }
        else if( iSign > 0 ) 
        {
            break ;
        }

        ple = ple->Flink ;
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseWriteLockFunc(pTable);
    }

    return  Status;
}

PSHASH_HEADER   
SHashLookupKeyEx(   IN  PSHASH_TABLE pTable, 
                    IN  void*       pvKeyIn
                )   
{
    PSHASH_HEADER pEntry = NULL;
    PLIST_ENTRY pleStart = NULL ;
    PLIST_ENTRY ple= NULL ;
    int iSign = 0; 
    DWORD   dwHash = 0; 
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;

    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
         dwHash= dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
         dwHash = dwHash % pTable->NumBuckets;
    }


    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        goto Exit;
    }

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart ) 
    {
        pEntry = (PSHASH_HEADER)CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc( pEntry->pvKey, pvKeyIn ) ;
        if( iSign == 0 ) 
        {
            InterlockedIncrement(&pEntry->RefCount);
            pTable->ReleaseReadLockFunc(pTable);
            return pEntry;
        }
        else if( iSign > 0 ) 
        {
            break ;
        }

        ple = ple->Flink ;
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseReadLockFunc(pTable);
    }

    return  NULL;
}


NTSTATUS    
SHashIsKeyInTable(  IN  PSHASH_TABLE pTable, 
                    IN  void*       pvKeyIn
                 )
{
    NTSTATUS Status = STATUS_OBJECT_PATH_NOT_FOUND; 
    PSHASH_HEADER pEntry = NULL;

    pEntry = SHashLookupKeyEx(pTable, pvKeyIn);
    if(pEntry != NULL)
    {

        SHashReleaseReference(pTable, pEntry); 
        Status = STATUS_SUCCESS;
    }


    return Status;
}


NTSTATUS    
SHashGetDataFromTable(  IN  PSHASH_TABLE pTable, 
                        IN  void*       pvKeyIn,
                        IN  void        ** ppData
                     )
{
    NTSTATUS Status = STATUS_OBJECT_PATH_NOT_FOUND;
    PSHASH_HEADER pEntry = NULL;
    
    pEntry = SHashLookupKeyEx(pTable, pvKeyIn);
    if(pEntry != NULL)
    {
        *ppData = (void *)pEntry;
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS    
SHashReleaseReference(  IN  PSHASH_TABLE pTable, 
                        IN  PSHASH_HEADER pData
                     )
{
    if(InterlockedDecrement(&pData->RefCount) == 0)
    {
       pTable->WriteLockFunc(pTable);
       InterlockedDecrement(&pTable->TotalItems);
       RemoveEntryList( &pData->ListEntry ) ;
       InterlockedDecrement(&pTable->HashBuckets[pData->dwHash].Count);
       pTable->FreeHashEntryFunc(pData);
       pTable->ReleaseWriteLockFunc(pTable);
    }

    return STATUS_SUCCESS;
}


NTSTATUS    
SHashMarkForDeletion(  IN  PSHASH_TABLE pTable, 
                        IN  PSHASH_HEADER pData
                     )
{
    NTSTATUS Status = STATUS_LOCK_NOT_GRANTED;
    BOOLEAN LockAquired = TRUE;

    LockAquired = pTable->WriteLockFunc(pTable);
    if(LockAquired)
    {
        pData->Flags |= SHASH_FLAG_DELETE_PENDING;

        if(InterlockedDecrement(&pData->RefCount) == 0)
        {
            InterlockedDecrement(&pTable->TotalItems);
            RemoveEntryList( &pData->ListEntry ) ;
            InterlockedDecrement(&pTable->HashBuckets[pData->dwHash].Count);
            pTable->FreeHashEntryFunc(pData);
        }

        pTable->ReleaseWriteLockFunc(pTable);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

#if 0
NTSTATUS    
SHashReplaceInTable(IN  PSHASH_TABLE pTable, 
                    IN  void*       pvKeyIn,
                    IN OUT PVOID *ppData
                 )
{

    NTSTATUS Status = STATUS_SUCCESS;

    Status = STATUS_OBJECT_PATH_NOT_FOUND;

    return Status;
}
#endif

NTSTATUS
ShashEnumerateItems(IN  PSHASH_TABLE pTable, 
                    IN  PFNENUMERATEKEY     pfnCallback, 
                    IN  LPVOID              lpvClientContext
                    )   
{

    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY pCur = NULL ;
    PLIST_ENTRY pNext = NULL;
    PLIST_ENTRY ListHead = NULL;
    PSHASH_HEADER   pEntry = NULL;
    DWORD   i = 0;
    BOOLEAN LockAquired = TRUE;

    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    for( i = 0; i < pTable->NumBuckets && Status == STATUS_SUCCESS; i++ ) 
    {
        ListHead = &pTable->HashBuckets[i].ListHead ;
        pCur = ListHead->Flink ;
        while( pCur != ListHead && Status == STATUS_SUCCESS ) 
        {
            //
            //  save the next pointer now,          
            //
            pNext = pCur->Flink ;
            pEntry = CONTAINING_RECORD( pCur, SHASH_HEADER, ListEntry ) ;
    
            if ((pEntry->Flags & SHASH_FLAG_DELETE_PENDING) == 0)
            {
                Status = pfnCallback( pEntry,
                                      lpvClientContext );
            }
            //
            //  move to the next item
            //
            pCur = pNext ;
        }
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseReadLockFunc(pTable);
    }

    return  Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\shash\shashdata.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "shash.h"
         

//
//  The following table is generated from this code : 
//  
//  #define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */
//    INT i, j;
//    DWORD sum;
//
//    for (i = 0; i < 128; ++i) {
//        sum = 0;
//        for (j = 7 - 1; j >= 0; --j) {
//            if (i & (1 << j)) {
//                sum ^= POLY >> j;
//            }
//        }
//        CrcTable[i] = sum;
//
//  These values are used when computing hash values, 
//  and the result is a very good hash function with good distribution !
//
static  long CrcTable[128] = 
{
    0,         1207959552, 603979776,  1811939328,
    301989888, 1509949440, 905969664,  2113929216,
    150994944, 1090519040, 754974720,  1694498816,
    452984832, 1392508928, 1056964608, 1996488704,
    75497472,  1283457024, 545259520,  1753219072,
    377487360, 1585446912, 847249408,  2055208960,
    226492416, 1166016512, 696254464,  1635778560,
    528482304, 1468006400, 998244352,  1937768448,
    37748736,  1245708288, 641728512,  1849688064,
    272629760, 1480589312, 876609536,  2084569088,
    188743680, 1128267776, 792723456,  1732247552,
    423624704, 1363148800, 1027604480, 1967128576,
    113246208, 1321205760, 583008256,  1790967808,
    348127232, 1556086784, 817889280,  2025848832,
    264241152, 1203765248, 734003200,  1673527296,
    499122176, 1438646272, 968884224,  1908408320,
    18874368,  1226833920, 622854144,  1830813696,
    320864256, 1528823808, 924844032,  2132803584,
    136314880, 1075838976, 740294656,  1679818752,
    438304768, 1377828864, 1042284544, 1981808640,
    94371840,  1302331392, 564133888,  1772093440,
    396361728, 1604321280, 866123776,  2074083328,
    211812352, 1151336448, 681574400,  1621098496,
    513802240, 1453326336, 983564288,  1923088384,
    56623104,  1264582656, 660602880,  1868562432,
    291504128, 1499463680, 895483904,  2103443456,
    174063616, 1113587712, 778043392,  1717567488,
    408944640, 1348468736, 1012924416, 1952448512,
    132120576, 1340080128, 601882624,  1809842176,
    367001600, 1574961152, 836763648,  2044723200,
    249561088, 1189085184, 719323136,  1658847232,
    484442112, 1423966208, 954204160,  1893728256,
} ;

ULONG
SHashComputeHashValue(
    IN  void*   lpv 
    )   
{
    PUNICODE_STRING  Name = (PUNICODE_STRING) lpv ;
    DWORD sum = 0;
    LONG Length = 0; 
    PWCHAR  Key = NULL;
    WCHAR  ch ;
    
    Length = Name->Length/sizeof(WCHAR);
    Key = Name->Buffer;

    while ( Length-- ) 
    {
        ch = RtlUpcaseUnicodeChar(*Key++) ;
        sum = (sum >> 7) ^ CrcTable[(sum ^ (ch)) & 0x7f];
    }

    return(sum);
}



/*++

Routine Description : 

    This function is provided to the hash tables to compare two keys.

    NOTE : we compare in a case insensitive fashion !

Arguments : 

    pvKey1, pvKey2 - two keys,

Return Value : 

    -1 iff pvKey1 < pvKey2
    0 iff pvKey1 == pvKey2
    1 iff pvKey1 > pvKey2 

--*/
int
SHashMatchNameKeysCaseInsensitive(  void*   pvKey1, 
                                    void*   pvKey2
                                    )   
{
    PUNICODE_STRING pKey1 = (PUNICODE_STRING)pvKey1 ;
    PUNICODE_STRING pKey2 = (PUNICODE_STRING)pvKey2 ;

    if( pKey1->Length == pKey2->Length )    
    {
        return  RtlCompareUnicodeString(
                         pKey1,
                         pKey2,
                         TRUE
                         ) ;
    }   
    else    
    {
        return  (signed)pKey1->Length - (signed)pKey2->Length ;
    }
}


void*
SHashAllocate(   ULONG   cbAlloc  )   
{
    void * pMem = NULL;


    pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbAlloc);
    return pMem;
}

void
SHashFree( void*   lpv ) 
{

    HeapFree( GetProcessHeap(), 0, lpv );
}

BOOLEAN SHashReadLockTable(PSHASH_TABLE pTable)
{
    BOOLEAN fRet = TRUE;
        
    EnterCriticalSection(pTable->pLock); 
    pTable->Flags |= SHASH_CAP_TABLE_LOCKED;

    return fRet;
}


BOOLEAN SHashWriteLockTable(PSHASH_TABLE pTable)
{
    BOOLEAN fRet = TRUE;

    EnterCriticalSection(pTable->pLock); 
    pTable->Flags |= SHASH_CAP_TABLE_LOCKED;

    return fRet;
}


BOOLEAN SHashReadUnLockTable(PSHASH_TABLE pTable)
{
    pTable->Flags &= ~SHASH_CAP_TABLE_LOCKED; 
    LeaveCriticalSection(pTable->pLock); 

    return TRUE;
}


BOOLEAN SHashWriteUnLockTable(PSHASH_TABLE pTable)
{
    pTable->Flags &= ~SHASH_CAP_TABLE_LOCKED; 
    LeaveCriticalSection(pTable->pLock); 

    return TRUE;
}


void * SHashAllocLock(void)
{  
    void * pMem = NULL;
    BOOL fCritInit = FALSE;
    DWORD Status = 0;

    pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(CRITICAL_SECTION));
    if(pMem)
    {
        fCritInit = InitializeCriticalSectionAndSpinCount(pMem, SHASH_CRIT_SPIN_COUNT);
        if(!fCritInit)
        {
            Status = GetLastError();
            HeapFree( GetProcessHeap(), 0, pMem );
            pMem = NULL;
            SetLastError(Status);
        }
    }

    return pMem;
}


void SHashFreeLock(void * pMem)
{
    DeleteCriticalSection(pMem);
    HeapFree( GetProcessHeap(), 0, pMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\regsecurity.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       regsecurity.c
//
//  Contents:   miscellaneous dfs functions.
//
//  History:    April. 17 2002,   Author: rohanp
//
//-----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <malloc.h>
#include "rpc.h"
#include "rpcdce.h"
#include <dfsheader.h>
#include "lm.h"
#include "lmdfs.h"
#include <strsafe.h>
#include <dfsmisc.h>
#include <seopaque.h>
#include <sertlp.h>

#define FLAG_ON(x, y)  ((y)==((x)&(y)))  

//
// Registry generic mapping
//
GENERIC_MAPPING         DfsRegGenMapping = {STANDARD_RIGHTS_READ   | 0x1,
                                            STANDARD_RIGHTS_WRITE    | 0x2,
                                            STANDARD_RIGHTS_EXECUTE  | 0x4,
                                            STANDARD_RIGHTS_REQUIRED | 0x3F};

//
// Security open type (used to help determine permissions to use on open)
//
typedef enum _DFS_SECURITY_OPEN_TYPE
{
    READ_ACCESS_RIGHTS = 0,
    WRITE_ACCESS_RIGHTS,
    MODIFY_ACCESS_RIGHTS,
    NO_ACCESS_RIGHTS,
    RESET_ACCESS_RIGHTS
}  DFS_SECURITY_OPEN_TYPE, *PDFS_SECURITY_OPEN_TYPE;


ACCESS_MASK 
DfsRegGetDesiredAccess(IN DFS_SECURITY_OPEN_TYPE   OpenType,
                       IN SECURITY_INFORMATION SecurityInfo)
{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    return DesiredAccess;
}


 
DFSSTATUS
MakeSDAbsolute(IN  PSECURITY_DESCRIPTOR     pOriginalSD,
               IN  SECURITY_INFORMATION     SeInfo,
               OUT PSECURITY_DESCRIPTOR    *ppNewSD,
               IN  PSID                     pOwnerToAdd,
               IN  PSID                     pGroupToAdd)
{
    DFSSTATUS   dwErr = ERROR_SUCCESS;

    BOOL    fDAclPresent = FALSE;
    BOOL    fSAclPresent = FALSE;
    BOOL    fDAclDef = FALSE, fSAclDef = FALSE;
    BOOL    fOwnerDef = FALSE, fGroupDef = FALSE;
    PACL    pDAcl = NULL, pSAcl = NULL;
    PSID    pOwner = NULL, pGroup = NULL;
    ULONG   cSize = 0;
    PBYTE   pbEndOBuf = NULL;
    DWORD   cLen = 0;

    //
    // First, get the info out of the current SD
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorDacl(pOriginalSD, &fDAclPresent, &pDAcl, &fDAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDAcl != NULL)
            {
                cSize += pDAcl->AclSize;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorSacl(pOriginalSD, &fSAclPresent, &pSAcl, &fSAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSAcl != NULL)
            {
                cSize += pSAcl->AclSize;
            }
        }
    }

    if(pOwnerToAdd != NULL)
    {
        pOwner = pOwnerToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorOwner(pOriginalSD, &pOwner, &fOwnerDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pGroupToAdd != NULL)
    {
        pGroup = pGroupToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorGroup(pOriginalSD, &pGroup, &fGroupDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pOwner != NULL)
    {
        cSize += RtlLengthSid(pOwner);
    }

    if(pGroup != NULL)
    {
        cSize += RtlLengthSid(pGroup);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Allocate the buffer...
        //
        PBYTE   pBuff = (PBYTE)HeapAlloc(GetProcessHeap(), 0 ,(cSize + sizeof(SECURITY_DESCRIPTOR)));
        if(pBuff == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Start copying in the existing items...
            //
            pbEndOBuf = pBuff + cSize + sizeof(SECURITY_DESCRIPTOR);

            if(pOwner != NULL)
            {
                cLen = RtlLengthSid(pOwner);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pOwner, cLen);
                pOwner = (PSID)pbEndOBuf;
            }

            if(pGroup != NULL)
            {
                cLen = RtlLengthSid(pGroup);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pGroup, cLen);
                pGroup = (PSID)pbEndOBuf;
            }

            if(pDAcl != NULL)
            {
                pbEndOBuf -= pDAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pDAcl, pDAcl->AclSize);
                pDAcl = (PACL)pbEndOBuf;
            }

            if(pSAcl != NULL)
            {
                pbEndOBuf -= pSAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pSAcl, pSAcl->AclSize);
                pSAcl = (PACL)pbEndOBuf;
            }

            //
            // Ok, now build it...
            //
            *ppNewSD = (PSECURITY_DESCRIPTOR)pBuff;
            if(InitializeSecurityDescriptor(*ppNewSD, SECURITY_DESCRIPTOR_REVISION) == FALSE)
            {
                dwErr = GetLastError();
            }

            if(dwErr == ERROR_SUCCESS && fDAclPresent == TRUE)
            {
                if(SetSecurityDescriptorDacl(*ppNewSD, TRUE, pDAcl, fDAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && fSAclPresent == TRUE)
            {
                if(SetSecurityDescriptorSacl(*ppNewSD, TRUE, pSAcl, fSAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pOwner != NULL)

            {
                if(SetSecurityDescriptorOwner(*ppNewSD, pOwner, fOwnerDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pGroup != NULL)

            {
                if(SetSecurityDescriptorGroup(*ppNewSD, pGroup, fGroupDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Set the new control bits to look like the old ones (minus the selfrel flag, of
            // course...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                RtlpPropagateControlBits((PISECURITY_DESCRIPTOR)*ppNewSD,
                                         (PISECURITY_DESCRIPTOR)pOriginalSD,
                                         ~SE_SELF_RELATIVE );
            }

            if(dwErr != ERROR_SUCCESS)
            {
                HeapFree(GetProcessHeap, 0,(*ppNewSD));
                *ppNewSD = NULL;
            }

        }

    }

    return(dwErr);
}

DFSSTATUS
DfsReadRegistrySecurityInfo(IN  HKEY  hRegistry,
                            IN  SECURITY_INFORMATION   SeInfo,
                            OUT PSECURITY_DESCRIPTOR  *ppSD)
{

    ULONG   cSize = 0;
    DWORD   Status = 0;
    PSECURITY_DESCRIPTOR pAbs = NULL;

    //
    // First, get the size we need
    //
    Status = RegGetKeySecurity(hRegistry,
                              SeInfo,
                              *ppSD,
                              &cSize);
    if(Status == ERROR_INSUFFICIENT_BUFFER)
    {
        Status = ERROR_SUCCESS;
        *ppSD = (PISECURITY_DESCRIPTOR)HeapAlloc(GetProcessHeap(), 0, cSize);
        if(*ppSD == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = RegGetKeySecurity((HKEY)hRegistry,
                                      SeInfo,
                                      *ppSD,
                                      &cSize);

        }
    }


    return Status;
}

DFSSTATUS
DfsSetRegistrySecurityInfo(IN  HKEY                    hRegistry,
                           IN  SECURITY_INFORMATION      SeInfo,
                           IN  PSECURITY_DESCRIPTOR      pSD)
{
    DFSSTATUS Status = 0;

    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) 
    {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) 
    {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }

    Status = RegSetKeySecurity(hRegistry,
                               SeInfo,
                               pSD);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\shash\shashiter.c ===
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shashiter.c
//
//  Contents:   Generic hashtable iterator
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifdef KERNEL_MODE


#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
    
#include <windows.h>
#include <shash.h>



PSHASH_HEADER
SHashNextEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable)
{
    DWORD dwHashVar = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    void * pData = NULL;
    LIST_ENTRY * ple = NULL;
    LIST_ENTRY * pListHead = NULL;
    PSHASH_HEADER   pEntry = NULL;
    PSHASH_HEADER   pOldEntry = NULL;
    BOOLEAN  LockAquired = TRUE;
    BOOLEAN  Found = FALSE;

    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        // dfsdev: why are we not returning status??
        Status = STATUS_LOCK_NOT_GRANTED;
        return NULL;
    }

    pOldEntry = pIterator->pEntry;

    ple = pIterator->ple->Flink;

    for (dwHashVar = pIterator->index; (dwHashVar < pTable->NumBuckets) && (!Found); dwHashVar++) 
    {
        pListHead = &pTable->HashBuckets[dwHashVar].ListHead;

        ple = (dwHashVar == pIterator->index) ? pIterator->ple->Flink : pListHead->Flink;

        while (ple != pListHead) 
        {
            pEntry = CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
            if((pEntry->Flags & SHASH_FLAG_DELETE_PENDING) == 0)
            {
                InterlockedIncrement(&pEntry->RefCount);

                pIterator->index = dwHashVar;
                pIterator->ple = ple;
                pIterator->pEntry = pEntry;
                pIterator->pListHead = pListHead;
                Found = TRUE;
                break;
            }
            pEntry = NULL;
            ple = ple->Flink;
        }
    }

    pTable->ReleaseReadLockFunc(pTable);

    if(pOldEntry)
    {
        Status = SHashReleaseReference( pTable, pOldEntry); 
    }

    if(pEntry == NULL)
    {
        pIterator->index = 0;
        pIterator->ple = NULL;
        pIterator->pListHead = NULL;
        pIterator->pEntry = NULL;
    }

    return pEntry;
}


PSHASH_HEADER
SHashStartEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        )
{
    PSHASH_HEADER   pEntry = NULL;

    pIterator->index = 0;
    pIterator->pListHead = &pTable->HashBuckets[0].ListHead;
    pIterator->ple = pIterator->pListHead;
    pIterator->pEntry = NULL;

    pEntry = SHashNextEnumerate( pIterator, pTable);

    return pEntry;
}

VOID
SHashFinishEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(pIterator->pEntry)
    {
        Status = SHashReleaseReference( pTable, pIterator->pEntry); 
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\setup\dfssetup.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfssetup.cxx
//
//  Contents:   Code to setup Dfs on a machine.
//
//              Note that this code can be built as an exe or as a DLL. To
//              switch between the two, simply edit the following fields in
//              the sources file:
//                      TARGETTYPE=[PROGRAM | DYNLINK]
//                      UMTYPE=[console | windows]
//              Delete the following two lines from sources to build an exe.
//                      DLLDEF=obj\*\dfssetup.def
//                      DLLENTRY=_DllMainCRTStartup
//                      DLLBASE=@$(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt,dfssetup
//
//  Classes:    None
//
//  Functions:
//
//  History:    12-28-95        Milans  Created
//
//-----------------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
}

#include <windows.h>
#include <rpc.h>                                 // For UuidCreate

#include <winldap.h>
#include <dsgetdc.h>

#include <lm.h>

#include "registry.hxx"                          // Helper functions...
#include "setupsvc.hxx"

#include "config.hxx"                            // Config UI functions

//
// Until we get the schema right in the DS, we have to set our own SD on
// certain objects
//

#include <aclapi.h>

HINSTANCE g_hInstance;

extern "C" BOOL
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hDll;
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;

}


#define dprintf(x)

#define MAX_NETBIOS_NAME_LEN    16+1

extern DWORD
RemoveDfs(void);

BOOLEAN
DfsCheckForOldDfsService();


DWORD
GetSharePath(
    IN LPWSTR wszShareName,
    OUT LPWSTR wszSharePath);


//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point in case you want to build this as an exe.
//              Configures all Dfs components on a machine.
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void _cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRootLen;
    BOOL fRootSetup = FALSE;
    BOOLEAN OldDfsService = FALSE;
    WCHAR wszDfsRootShare[ MAX_PATH ];


    //
    // Figure out the type of machine we are installing on - client or root
    //


    if (argc != 1) {
        return;
    }

    //
    // Configure the Dfs Driver
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = ConfigDfs();

        if (dwErr == ERROR_SUCCESS) {

            dwErr = ConfigDfsService();

            if (dwErr != ERROR_SUCCESS) {

                dprintf((
                    DEB_ERROR, "Win32 error configuring Dfs Service %d\n",
                    dwErr));

                (void)RemoveDfs();

            } else {

                dprintf((DEB_ERROR,"Successfully configured Dfs...\n") );

            }

        } else {

            dprintf((DEB_ERROR,"Error %d configuring Dfs driver!\n", dwErr));

        }
    }
}
//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupDfs
//
//  Synopsis:   Entry point in case you want to build this as a DLL. This
//              function is suitable for being called from a setup .inf
//              file.
//
//  Arguments:  [cArgs] -- Count of args
//              [lpszArgs] -- Array of args
//              [lpszTextOut] -- On return, points to a global buffer
//                      containing the null string. This is required by the
//                      .inf file
//
//  Returns:    TRUE.
//
//-----------------------------------------------------------------------------

LPSTR szReturn = "";

extern "C" BOOL
DfsSetupDfs(
    DWORD cArgs,
    LPSTR lpszArgs[],
    LPSTR *lpszTextOut)
{
    int argc;
    LPSTR *argv;

    argv = (LPSTR *) malloc( (cArgs+1) * sizeof(LPSTR) );

    if (argv == NULL) {
        return( FALSE );
    }

    argv[0] = "DfsSetup";
    for (argc = 1; argc <= (int) cArgs; argc++) {
        argv[ argc ] = lpszArgs[ argc-1 ];
    }

    main( argc, argv );

    free( argv );

    *lpszTextOut = szReturn;

    return( TRUE );

}



//+------------------------------------------------------------------
//
// Function: CheckForOldDfsService
//
// Synopsis:
//
// Effects: -none-
//
// Arguments: -none-
//
// Returns: TRUE if the old (pre -ds build) dfs service is installed
//
//
// History: 10-09-96        JimMcN       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


BOOLEAN DfsCheckForOldDfsService( )
{
    DWORD dwErr = 0;
    DWORD DfsVersion;

    // Open Service Controller
    CService cSvc;

    if (!(dwErr = cSvc.Init()))
    {

        dwErr = cSvc._OpenService(L"Dfs", SERVICE_QUERY_STATUS);
        cSvc._CloseService();

        if (dwErr != 0) {
            return(FALSE);
        }

        CRegKey cregDfsService( HKEY_LOCAL_MACHINE,
                                &dwErr,
                                L"System\\CurrentControlSet\\Services\\Dfs"
                               );

        if (dwErr == ERROR_SUCCESS) {
            CRegDWORD DfsNewService((const CRegKey &)cregDfsService,
                                     L"DfsVersion", &DfsVersion);

            dwErr = DfsNewService.QueryErrorStatus();

            if (dwErr != 0) {
                dprintf((DEB_ERROR,"CheckForOldDfsService Failed Newserv\n"));
                return(TRUE);
            }

            if (DfsVersion < DFS_VERSION_NUMBER) {
                return(TRUE);
            }

            return(FALSE);

        }

        return(FALSE);
    }
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\lib\security\systemsecurity.cxx ===
//
//  systemsecurity.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for logging as Local System
//
//  History:
//
//  Todds       8/15/98     Created
//  Modified by Rohanp 4/26/2002
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...


DWORD 
GetSystemProcessId(LPWSTR ProcessNameToFind, 
                   DWORD * ProcessId);



//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
    BYTE AceFlags,
    BOOL bAddSid
    )
{
    DWORD dwNewAclSize = 0, dwErr = 0;
    LPVOID pAce = NULL;
    DWORD AceCounter = 0;
    BOOL bSuccess = FALSE; // assume this function will fail
    ACL_SIZE_INFORMATION AclInfo;

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) 
    {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) 
    {
        return FALSE;
    }

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        ))
    {
        return FALSE;
    }

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) 
    {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else 
    {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);
    if(*pAclDestination == NULL) 
    {
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            ))
   {
        dwErr = GetLastError();
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) 
    {
        PACCESS_ALLOWED_ACE pNewAce = NULL;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) 
        {
            dwErr = GetLastError();
            goto ret;
        }

        //
        // get pointer to ace we just added, so we can change the AceFlags
        //
        if(!GetAce(
            *pAclDestination,
            0, // this is the first ace in the Acl
            (void**) &pNewAce
            ))
        {
        
            dwErr = GetLastError();
            goto ret;
        }

        pNewAce->Header.AceFlags = AceFlags;    
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) 
    {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce))
        {
            dwErr = GetLastError();
            goto ret;
        }
        
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) 
        {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) 
            {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            0xFFFF,  // maintain Ace order //MAXDWORD
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) 
        {
         
            dwErr = GetLastError();
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) 
    {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    
    return bSuccess;
}

//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent = FALSE, fDaclDefaulted = FALSE, fRet = FALSE;
    SECURITY_DESCRIPTOR     sdNew;
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) 
    {
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) 
    {

        dwErr = GetLastError();
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) 
    {
        
        dwErr = GetLastError();
        if((cbNeeded > MAX_SD) && (dwErr == ERROR_MORE_DATA)) 
        { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) 
            {
                dwErr = GetLastError();
                goto ret;
            }
            
            dwErr = ERROR_SUCCESS;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) 
            {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != ERROR_SUCCESS) 
        {
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) 
    {
        dwErr = GetLastError();
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) 
    {
        dwErr = GetLastError();
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) 
    {
        dwErr = GetLastError();
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) 
    {
        
        dwErr = GetLastError();
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) 
    {
        MyFree(pNewDacl);
    }

    if (!fRet) 
    {
        if (NULL != pSD) 
        {
            MyFree(pSD);
            *ppSDOld = NULL;
        }
    }
       
    return fRet;
}



BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) 
    {
        return FALSE;
    }

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) 
    {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else 
    {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken = NULL;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken))
    {       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
        {
            return FALSE;
        }
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) 
    {
        bSuccess=TRUE;
    }

    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) 
    {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) 
        { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) 
            {

                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) 
    {
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) 
    {
        
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) 
    {
        goto ret;
    }

    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) 
    {
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) 
    {
        
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:

    if (NULL == hClientToken && NULL != hToken) 
    { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) 
    {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) 
    {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) 
    {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) 
    {

        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) 
    {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) 
    {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) 
    {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
//  RevertToSelf() must be called to restore original token  
//
//
DWORD
GetLocalSystemToken(
    IN ULONG ProcessId,
    OUT HANDLE *hPDupToken
    )
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD   cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  

//
//  Enable debug privilege
//
    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) 
     {
        return GetLastError();
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) 
    {
        return GetLastError();
    }

    if(ProcessId == 0)
    {
        GetSystemProcessId(L"System", 
                            &ProcessId);
    }


    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) 
    {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    do {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    ProcessId
                    );
        
        if (NULL == hProcess) 
        {
            dwErr = GetLastError();
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) 
        {

            dwErr = GetLastError();
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) 
        {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) 
        {
            
            dwErr = GetLastError();
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    hPDupToken
                    )) 
        {

            dwErr = GetLastError();
            goto ret;
        }

        if (IsLocalSystem(*hPDupToken)) 
        {
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
                hPToken,
                DACL_SECURITY_INFORMATION,
                pSD
                )) 
        {

            dwErr = GetLastError();
            goto ret;
        } 
        
        fSet = FALSE;


        if (NULL != pSD) 
        { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) 
        {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) 
        {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } while(FALSE);


    if (!ImpersonateLoggedOnUser(*hPDupToken))  
    {
        dwErr = GetLastError();
        goto ret;
    }   

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) 
    {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) 
        {
            
            dwErr = GetLastError();
        } 
    }

    if (NULL != pSid) 
    {
        MyFree(pSid);
    }

    if (NULL != hPToken) 
    {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) 
    {
        MyFree(pSD);
    }

    if (NULL != hProcess) 
    {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}



                    


//
//  LogoffAndRevert()
//
//  This function simply RevertsToSelf(), and then closes the logon token
//
//  Params:
//
//  hToken      -   Logon token from LogonUserW
//
//  Returns:
//  
//  dwErr from last failure, S_OK otherwise.
//
DWORD
LogoffAndRevert(void)
{
    
    HANDLE  hThread = INVALID_HANDLE_VALUE;
    DWORD   dwErr = 0;

    //
    //  Verify impersonation, and revert
    //
    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hThread
            )) 
    {

        CloseHandle(hThread);
        RevertToSelf();
    }

    return dwErr;
}




 







#if 0

extern "C"
int __cdecl wmain(
    int argc,
    WCHAR* argv[]
    )
{

    LPWSTR          wszUPN = NULL;
    LPWSTR          wszOldPwd = NULL;
    LPWSTR          wszNewPwd = NULL;

    DATA_BLOB*      arCipherData = NULL;

    INT             i = 1;
    DWORD           dwErr = S_OK;
    DWORD           dwCleanupErrors = S_OK;
    HANDLE          hToken = INVALID_HANDLE_VALUE;
    HANDLE          hLocalSystem = NULL;
    HANDLE          hProfile = INVALID_HANDLE_VALUE;
    BOOL            fTest = TRUE;

    PSECURITY_DESCRIPTOR    pSD = NULL;

    ULONG ProcessId = 8;

#if 0
    while (i < carg)  {

        if (!_wcsicmp(rgwszarg[i], L"-?")) {

            Usage();
            return 0;
        }

        if (!_wcsicmp(rgwszarg[i], L"-reset")) {

            ResetTestUser();
            return 0;

        }

        if (!_wcsicmp(rgwszarg[i], L"-create")) {

            CreateTestUser();
            return 0;

        }


        if (!_wcsicmp(rgwszarg[i], L"-user")) {

            if (carg < 4) {
                Usage();
            }

            fTest = TRUE;
        }

       
        i++;

    }

#endif


    if( argc == 2 )
    {
        ProcessId = _wtoi( argv[1] );
    }
 
    //
    //  Enable debug privilege
    //
    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (TCB) failed!");
        return E_FAIL;
    }


    //
    //  Run as local system
    //
    dwErr = GetLocalSystemToken(ProcessId, &hLocalSystem);
    if (NULL == hLocalSystem || dwErr != S_OK) {
        goto Ret;
    }

  
//    dwErr = LogoffAndRevert(hToken, pSD);

    {
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        ZeroMemory( &si, sizeof(si) );
        ZeroMemory( &pi, sizeof(pi) );

        si.cb = sizeof(si);
        si.lpTitle = "NT AUTHORITY\\SYSTEM";


        if(!CreateProcessAsUserA(
                hLocalSystem,
                NULL,
                "cmd.exe",
                NULL,
                NULL,
                FALSE,
                CREATE_NEW_CONSOLE,
                NULL,
                NULL,
                &si,
                &pi
                ))
        {
            TERRORVAL(L"CreateProcessAsUser", GetLastError());
        }

    }




    if (NULL != pSD) {
        MyFree(pSD);
        pSD = NULL;
    }
    
    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
        hToken = INVALID_HANDLE_VALUE;
    }


Ret:

    

    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }

    if (NULL != hLocalSystem) {
        RevertToSelf();
        CloseHandle(hLocalSystem);
    }

       return dwErr;

}
#endif


DWORD 
GetSystemProcessId(LPWSTR ProcessNameToFind, 
                   DWORD * ProcessId)
{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo =NULL;
    NTSTATUS                     NtStatus = 0;
    DWORD                        WinError = 0;
    ULONG                        TotalOffset = 0;
    ULONG                        NumRetry = 0;
    ULONG                        totalTasks = 0;
    LONG                         TheSame = 0;
    PUCHAR                       LargeBuffer = NULL;
    ULONG                        LargeBufferSize = 64*1024;
    UNICODE_STRING               ProcessName;

retry:

    if(NumRetry == 5)
    {
        WinError = RtlNtStatusToDosError(NtStatus);
        return WinError;
    }

    if (LargeBuffer == NULL) 
    {
        LargeBuffer = (PUCHAR)MyAlloc (LargeBufferSize);
        if (LargeBuffer == NULL) 
        {
            return GetLastError ();
        }
    }

    NtStatus = NtQuerySystemInformation(
                SystemProcessInformation,
                LargeBuffer,
                LargeBufferSize,
                NULL
                );

    if (NtStatus == STATUS_INFO_LENGTH_MISMATCH) 
    {
        LargeBufferSize += 8192;
        MyFree(LargeBuffer);
        LargeBuffer = NULL;
        NumRetry++;
        goto retry;
    }

    if(NtStatus != STATUS_SUCCESS)
    {
        WinError = RtlNtStatusToDosError(NtStatus);
        return WinError;
    }

    NtStatus = RtlInitUnicodeStringEx( &ProcessName, ProcessNameToFind);
    if(NtStatus != STATUS_SUCCESS)
    {
        WinError = RtlNtStatusToDosError(NtStatus);
        return WinError;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) LargeBuffer;
    TotalOffset = 0;
    while (TRUE) 
    {
        if ( ProcessInfo->ImageName.Buffer ) 
        {
            TheSame = RtlCompareUnicodeString((PUNICODE_STRING)&ProcessInfo->ImageName, &ProcessName, TRUE );
            if(TheSame == 0)
            {
              *ProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
              break;
            }
        }

        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer[TotalOffset];
    }

    if(LargeBuffer)
    {
        MyFree (LargeBuffer);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_MSGTITLE                    2
#define IDC_NEWSHARE                    3
#define IDC_BROWSE                      3
#define IDS_DFSHOSTING                  3
#define IDD_CONFIGDFS                   101
#define IDD_DFSSHARE                    101
#define IDD_NEWSHARE                    102
#define IDD_CREATEDFS                   104
#define IDC_HOSTDFS                     1000
#define IDC_DFSROOT                     1001
#define IDC_DIRECTORY_TEXT              1003
#define IDC_CREATESHARE                 1006
#define IDC_DIRECTORY                   1007
#define IDC_MAKEFTDFS                   1008
#define IDC_FTDFS                       1009
#define IDC_CREATE_FTDFS                1010
#define IDC_JOIN_FTDFS                  1011
#define IDC_CREATE_DFS                  1012
#define IDC_CREATE_FTDFS_TX             1013
#define IDC_JOIN_FTDFS_CB               1014
#define IDC_CREATE_DOMAIN_TX            1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tests\referral\referraltest.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "ReferralTest.hxx"
#include "DfsReferralData.h"
#include <DfsServerLibrary.hxx>
#include "dfswmi.h"

#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)
  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)

#include "referraltest.tmh"
extern
void 
SetReferralControl(WPP_CB_TYPE * Control);

DWORD
RpcInit();

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

VOID
ReferralServerUsage();


VOID
TestLinks();

DWORD
DfsTestThread(LPVOID TData );

#define UNICODE_PATH_SEP L'\\'

ULONG MaxLinks = sizeof(DfsTestLinks) /sizeof(struct _DFS_TEST_LINK);



INT64 TotalRef = 0;

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;


//
// The arguments we accept at commandline.
//
MAKEARG(Name);
SWITCH(L);
SWITCH(D);
SWITCH(M);
SWITCH(Trace);

ULONG Flags;

_cdecl
main(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw,i;
    

    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];

    WPP_INIT_TRACING(L"referralTest");
    SetReferralControl(pLogger);

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            printf("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    
    if (Status == ERROR_SUCCESS)
    {
        //
        // Initialize the server.
        //  
        Status = DfsServerInitialize( Flags );
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server init error %d\n", Status);
            exit(-1);
        }
    }

    Sleep(200);

    for (i = 0; i < 10; i++) {
        if (Status == ERROR_SUCCESS) {
            HANDLE THandle;
            DWORD Tid;

            THandle = CreateThread (
                        NULL,
                        0,
                        DfsTestThread,
                        0,
                        0,
                        &Tid);

            if (THandle != NULL) {
                CloseHandle(THandle);
                printf("Created Test thread tid %d\n", Tid);
            }
            else {
                printf("Unable to create test thread\n");
                Status = GetLastError();
            }
        }
    }
    while (1) {
        Sleep(300000000);
    }

    WPP_CLEANUP();

}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NameSpace;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            }
            else {
                Status = DfsAddHandledNamespace( NameSpace, TRUE );
            }
        }
        else if (_wcsicmp(Arg, SwitchTrace) == 0)
        {
            fSwitchTrace = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchL) == 0)
        {
            fSwitchL = TRUE;
            Flags |= DFS_LOCAL_NAMESPACE;
        }
        else if (_wcsicmp(Arg, SwitchD) == 0)
        {
            Flags |= DFS_CREATE_DIRECTORIES;
        }
        else if (_wcsicmp(Arg, SwitchM) == 0)
        {
            Flags |= DFS_MIGRATE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ReferralServerUsage()
{
    printf("Usage:\n");
    printf("/D - Create directories\n");
    printf("/L - Run on the local root server\n");
    printf("/M - Migrate existing DFS to allow multiple roots\n");
    printf("/Name:<Namespace> - Handle referrals to the specified namespace\n");

    return;
}


DWORD
DfsTestThread(LPVOID TData )
{
    srand( (unsigned)GetCurrentThreadId());
    INT64 TotalThreadRef = 0;
    INT64 y;
    
    UNREFERENCED_PARAMETER(TData);

    while (1) {
        TestLinks();
        Sleep(20);
        TotalThreadRef += 5;
        TotalRef += 5;
        y = TotalRef;
        if ((TotalThreadRef % 1000)  == 0) {
            printf("Thread %d, Ref %I64d\n", GetCurrentThreadId(), TotalThreadRef);
        }
        if ((y % 10000) == 0) {
            printf("Total Referals %I64d\n", TotalRef);

        }
    }
    return 0;
}





DFSSTATUS 
DfsGenerateReferralBySitenameForTesting(
    LPWSTR LinkName, 
    LPWSTR SiteName,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader);

VOID
DfsReleaseReferral(
    REFERRAL_HEADER *pReferralHeader);


LPWSTR MySite=L"Red-Bldg40";
VOID
TestLinks()
{

    UNICODE_STRING Name, Remaining;
    UNICODE_STRING LinkName, LinkRemains;
    REFERRAL_HEADER *pReferral;
    ULONG i,j;
    DFSSTATUS Status;
    BOOLEAN LinkMatches, RemainsMatches, ReplicaMatches;

    for (j = 0; j < 5; j++) {

        i = (unsigned)(GetCurrentThreadId());
        i += rand();
        i = i % MaxLinks;


        Status = DfsGenerateReferralBySitenameForTesting( DfsTestLinks[i].Name,
                                      MySite,
                                      1000,
                                      1000,
                                      &pReferral );

        if (Status == ERROR_SUCCESS) {
            if (pReferral == NULL)
            {
                DbgBreakPoint();
            }

            RtlInitUnicodeString(&Name, &DfsTestLinks[i].Name[0]);
            RtlInitUnicodeString(&Remaining, &DfsTestLinks[i].RemainingName[0]);
            RtlInitUnicodeString(&LinkRemains, NULL);

            LinkName.Buffer = pReferral->LinkName;
            LinkName.Length = LinkName.MaximumLength = (USHORT)pReferral->LinkNameLength;

            LinkMatches = FALSE;
            RemainsMatches = FALSE;
            ReplicaMatches = FALSE;

            if (RtlPrefixUnicodeString(&LinkName, &Name, TRUE) == TRUE)
            {
                LinkMatches = TRUE;
                LinkRemains.Buffer = &Name.Buffer[(LinkName.Length / sizeof(WCHAR))];
                LinkRemains.MaximumLength = LinkRemains.Length = Name.Length - LinkName.Length;
                if (LinkRemains.Length && LinkRemains.Buffer[0] == UNICODE_PATH_SEP)
                {
                    LinkRemains.Buffer++;
                    LinkRemains.Length -= sizeof(WCHAR);
                }
                if (RtlCompareUnicodeString(&Remaining, &LinkRemains, TRUE) == 0)
                {
                        RemainsMatches = TRUE;
                }
                if (DfsTestLinks[i].NumberReplicas == pReferral->ReplicaCount)
                {
                    ReplicaMatches = TRUE;
                }

            }

            if (!LinkMatches || !RemainsMatches || !ReplicaMatches)
            {
                printf("Link Matches %x Rem %x Rep %x\n",
                       LinkMatches, RemainsMatches, ReplicaMatches );

                printf("Number of replicas %d, number got %d\n",
                       DfsTestLinks[i].NumberReplicas, pReferral->ReplicaCount);
                printf("LinkRem buffer %p. Name buf %p Linkn len %x name len %x Linkrem len %x remain len %x\n",
                       LinkRemains.Buffer, Name.Buffer, LinkName.Length, Name.Length, LinkRemains.Length, Remaining.Length);

                printf("Name %wZ Link %wZ Remains %wZ LinkRemains %wZ\n",
                       &Name, &LinkName, &Remaining, &LinkRemains);
            
            }

            DfsReleaseReferral(pReferral);
        }
        else{
            printf("Load for %wS Failde with %x\n", DfsTestLinks[i].Name, Status);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\dfsadmin.c ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsprefix.h>
#include <dfsadmin.h>


DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

ULONG AddLinks, RemoveLinks, AddTargets, RemoveTargets, ApiCalls;
VOID
ScriptUsage();




VOID
ProcessDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace,
    BOOLEAN Update);

VOID
VerifyDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace );

VOID
SetDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace );


#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;

MAKEARG(Import);
MAKEARG(Export);
MAKEARG(Name);
MAKEARG(DebugFile);

SWITCH(Debug);
SWITCH(Verify);
SWITCH(Update);
SWITCH(Set);

LPWSTR ImportFile = NULL;
LPWSTR NameSpace = NULL;
LPWSTR ExportFile = NULL;
LPWSTR DebugFile = NULL;

FILE *ExportOut;
FILE *DebugOut = NULL;

extern int DumpRoots(PROOT_DEF pRoot,
                     FILE *DebugOut );


VOID
DumpCurrentTime()
{

    SYSTEMTIME CurrentTime;

    GetLocalTime( &CurrentTime );
    printf("Current Time: %d\\%d\\%d, %d:%d:%d:%d\n",
           CurrentTime.wMonth, CurrentTime.wDay, CurrentTime.wYear,
           CurrentTime.wHour, CurrentTime.wMinute, CurrentTime.wSecond, 
           CurrentTime.wMilliseconds );


}
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw = 0;
    int i;
    PROOT_DEF pRoot = NULL;

    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    ExportOut = stdout;

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);

        if (Status != ERROR_SUCCESS)
        {
            ScriptUsage();
            exit(-1);
        }

    }

    if (DfsPrefixTableInit() != STATUS_SUCCESS)
    {
        printf("Prefix table init failed \n");
        exit(-1);

    }

    DumpCurrentTime();

    if (Status == ERROR_SUCCESS && fArgImport)
    {
        printf("input file is %wS\n", ImportFile );
        pRoot = GetDfsTrees( ImportFile );

        if ((pRoot != NULL) && (fSwitchDebug == TRUE)) 
        {
            DumpRoots( pRoot, DebugOut);
        }

        if (fSwitchVerify)
        {
            VerifyDfsRoots(pRoot, NameSpace);
        }
        else if (fSwitchSet)
        {
            SetDfsRoots(pRoot, NameSpace);

        }
        else if (fSwitchUpdate)
        {
            ProcessDfsRoots( pRoot, NameSpace, TRUE );
        }
        else {
            ProcessDfsRoots( pRoot, NameSpace, FALSE);
        }
    }
    else if (Status == ERROR_SUCCESS && fArgName)
    {
        DfsView(NameSpace, ExportOut);
    }
    else {
        ScriptUsage();
    }
    DumpCurrentTime();
    printf("DfsServer is exiting with status %x\n", Status);
    exit(0);

}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgImport, ArgLenImport) == 0)
        {
            fArgImport = TRUE;
            ImportFile = &Arg[ArgLenImport];
            if (wcslen(ImportFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                ImportFile = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgExport, ArgLenExport) == 0)
        {
            fArgExport = TRUE;
            ExportFile = &Arg[ArgLenExport];
            if (wcslen(ExportFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                ExportFile = NULL;
            }
            else 
            {
                ExportOut = _wfopen(ExportFile, L"w");
            }
        }
        else if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            printf("Namespace is %wS\n",NameSpace);
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                NameSpace = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgDebugFile, ArgLenDebugFile) == 0)
        {
            fArgDebugFile = TRUE;
            DebugFile = &Arg[ArgLenDebugFile];
            if (wcslen(DebugFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                DebugFile = NULL;
            }
            else {
                DebugOut = _wfopen(DebugFile, L"w");
                fSwitchDebug = TRUE;
            }
        }

        else if (_wcsicmp(Arg, SwitchDebug) == 0)
        {
            fSwitchDebug = TRUE;
            if (DebugOut == NULL)
            {
                DebugOut = stdout;
            }
        }
        else if (_wcsicmp(Arg, SwitchVerify) == 0)
        {
            fSwitchVerify = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchUpdate) == 0)
        {
            fSwitchUpdate = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchSet) == 0)
        {
            fSwitchSet = TRUE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ScriptUsage()
{
    printf("Usage:\n");
    printf("/Debug - Enable debug settings\n");
    printf("/DebugFile:<File> - name of file to send debug output\n");
    printf("/Name:<NameSpace> - namespace of interest\n");
    printf("/Verify - Verify the namespace with import file dfs information\n");
    printf("/Update - update the namespace with import file dfs information\n");
    printf("/Set - Set the import file dfs information in the namespace\n");    
    printf("/Import:<File> - name of file to import\n");
    printf("/Export:<File> - name of file for export data\n");
    
    return;
}

VOID
ProcessDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace,
    BOOLEAN Update )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status;
    LPWSTR UseRootName;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {

        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = AddNewRoot(pRoot, UseRootName, Update);
        if (Status != ERROR_SUCCESS)
        {
            printf("AddRoot failed for %wS, status %d\n", UseRootName, Status);
        }
    }
}

VOID
VerifyDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status, VerifyStatus;
    PLINK_DEF pLink;
    DWORD ErrorLinks = 0;
    LPWSTR UseRootName;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {
        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = DfsMerge(pRoot, UseRootName);
        if (Status != ERROR_SUCCESS)
        {
            printf("Verify failed for %wS, status %d\n", UseRootName, Status);
        }
        else {
            for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
            {
                VerifyStatus = VerifyLink( pLink );
                if (VerifyStatus != ERROR_SUCCESS)
                {
                    Status = VerifyStatus;
                    ErrorLinks++;
                }
            }
            printf("Found %d links not verified (Status %x)\n", ErrorLinks, VerifyStatus);
        }
    }
}


VOID
SetDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status;
    PLINK_DEF pLink;
    DFSSTATUS SetStatus;
    LPWSTR UseRootName;
    DWORD ErrorLinks = 0;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {
        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = DfsMerge(pRoot, UseRootName);
        if (Status != ERROR_SUCCESS)
        {
            printf("Set failed for %wS, status %d\n", UseRootName, Status);
        }
        else {
            AddLinks = 0;
            RemoveLinks = 0;
            AddTargets = 0;
            RemoveTargets = 0;

            for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
            {

                SetStatus = SetLink( UseRootName, pLink );
                if (SetStatus != ERROR_SUCCESS)
                {
                    Status = SetStatus;
                    ErrorLinks++;
                }
            }
            printf("Added %d links, Removed %d\n", AddLinks, RemoveLinks);
            printf("Added %d targets, Removed %d\n", AddTargets, RemoveTargets);
            printf("%d links failed\n", ErrorLinks);


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tests\apitest\apitest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       Main.CXX
//
//  Contents:   Main file for DfsApi
//
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include <DfsReferralData.h>
#include <DfsServerLibrary.hxx>
#include <time.h>
#include "lm.h"
#include "lmdfs.h"
#include "tchar.h"
#include "dfswmi.h"
#define RETURN return
#undef ASSERT
#define ASSERT(x)

#define APINetDfsAdd    DfsAdd
#define APINetDfsRemove DfsRemove

#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)
  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)

#include "apitest.tmh"
extern
void 
SetReferralControl(WPP_CB_TYPE * Control);

DWORD
APINetDfsAddStdRoot(
    LPWSTR machine,
    LPWSTR Share,
    LPWSTR comment,
    DWORD Options)
{
    UNREFERENCED_PARAMETER(machine);

    return DfsAddStandaloneRoot(machine, Share, comment, Options);
}

DWORD
APINetDfsRemoveStdRoot(
    LPWSTR machine,
    LPWSTR Share,
    DWORD Options)
{
    UNREFERENCED_PARAMETER(Options);
    return DfsDeleteStandaloneRoot(machine, Share);
}

DWORD
APINetDfsEnum(
    LPWSTR DfsPath,
    DWORD Level,
    DWORD PrefMaxLen,
    LPBYTE *pBuffer,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle )
{
    LONG SizeRequired = 0;
    ULONG StartingLen = PrefMaxLen;
    LPBYTE Buffer;
    DFSSTATUS Status;

    if (StartingLen == ~0)
    {
        StartingLen = 4096;
    }

    Status = NetApiBufferAllocate(StartingLen, (LPVOID *)&Buffer );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsEnumerate( DfsPath,
                           Level,
                           PrefMaxLen,
                           Buffer,
                           StartingLen,
                           pEntriesRead,
                           pResumeHandle,
                           &SizeRequired );
    
    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        NetApiBufferFree(Buffer);
        Status = NetApiBufferAllocate( SizeRequired, (LPVOID *)&Buffer);
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
            
        Status = DfsEnumerate( DfsPath,
                               Level,
                               PrefMaxLen,
                               Buffer,
                               SizeRequired,
                               pEntriesRead,
                               pResumeHandle,
                               &SizeRequired );
    }
    if (Status != ERROR_SUCCESS)
    {
        NetApiBufferFree( Buffer );
    }
    else {
        *pBuffer = Buffer;
    }
    return Status;
}

DWORD
APINetDfsGetInfo(
    LPWSTR DfsPath,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE *pBuffer )
{
    LONG SizeRequired = 0;
    ULONG StartingLen = 4096;
    LPBYTE Buffer;
    DFSSTATUS Status;

    UNREFERENCED_PARAMETER(Share);
    UNREFERENCED_PARAMETER(Server);

    Status = NetApiBufferAllocate(StartingLen, (LPVOID *)&Buffer );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    Status = DfsGetInfo( DfsPath,
                         Level,
                         Buffer,
                         StartingLen,
                         &SizeRequired );
    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        NetApiBufferFree(Buffer);
        Status = NetApiBufferAllocate(SizeRequired, (LPVOID *)&Buffer );
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
        Status = DfsGetInfo( DfsPath,
                             Level,
                             Buffer,
                             SizeRequired,
                             &SizeRequired );
    }
    if (Status != ERROR_SUCCESS)
    {
        NetApiBufferFree( Buffer );
    }
    else {
        *pBuffer = Buffer;
    }
    return Status;
}


DFSSTATUS
APINetDfsSetInfo(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD Level,
    LPBYTE pBuffer )
{

    return DfsSetInfo( DfsPathName,
                         ServerName,
                         ShareName,
                         Level,
                         pBuffer );

}


#if !defined(UNICODE) || !defined(_UNICODE)
#error For UNICODE only
#endif

#define	NOREBOOT		1
#define CHECK_ERR(x)
#define	ASSERT(x)

BOOL	bDebug = FALSE;
FILE*	fDebug = NULL;
#define	MSG	\
		if (bDebug) fprintf(fDebug, "File %s, %lu\n", __FILE__, __LINE__); \
		if (bDebug) fprintf

ULONG	Usage(LPSTR ptszAppNane);
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
#if 0
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg);
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider);
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv);
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv);
#endif
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer);
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer);
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer);
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer);
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer);
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer);
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pStorage);
LPTSTR	GetStringParam(LPTSTR ptszParam);

DFSSTATUS
DfsAddHandledNamespace(
    LPWSTR Name, 
    BOOLEAN Migrate );


DFSSTATUS
DfsServerInitialize(ULONG Flags);

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Core function for the application.
//
//  Arguments:  [argc]    			--      The number of arguments
//				[argv]				--		The arguments
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG __cdecl main(int argc, char* argv[])
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwArgc = 0;
	LPTSTR*	pptszArgv = NULL;
	INT		i = 0;
	INT		nArgNdx = 0;
        DWORD Status;


        WPP_CB_TYPE *pLogger = NULL;

        pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];

        WPP_INIT_TRACING(L"ApiTest");
        SetReferralControl(pLogger);

        Status = DfsServerInitialize(0);
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server init error %d\n", Status);
            exit(-1);
        }

        Status = DfsAddHandledNamespace(L".", TRUE);
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server add namespace error %d\n", Status);
            exit(-1);
        }

        Sleep(2000);

        printf("\n\nContinuing\n");

	if (argc < 2 ||
		argv[1][1]=='?' && (
		argv[1][0]=='-' ||
		argv[1][0]=='/'))
	{
		ulErr = Usage(argv[0]);
		RETURN(ulErr);
	}

	if (NULL == (pptszArgv =
		(LPTSTR*)malloc(sizeof(LPTSTR)*max(argc,32))))
	{
		_ftprintf(stderr,
				  _T("Not enough memory\n"));

		ulErr = ERROR_NOT_ENOUGH_MEMORY;

        CHECK_ERR(ulErr);
		goto Error;
	}
	memset(pptszArgv, 0, sizeof(LPTSTR)*max(argc,32));

	for (i=0; i<argc; i++)
	{
#ifdef UNICODE
		if (NULL == (pptszArgv[i] = (LPTSTR)malloc(
			sizeof(_TCHAR)*(1+strlen(argv[i])))))
		{
			_ftprintf(stderr,
					  _T("Not enough memory\n"));
	
			ulErr = ERROR_NOT_ENOUGH_MEMORY;

            CHECK_ERR(ulErr);
			goto Error;
		}

		memset(pptszArgv[i],
			   0,
			   sizeof(TCHAR)*(1+strlen(argv[i])));
		mbstowcs(pptszArgv[i], argv[i], strlen(argv[i]));
#else
		pptszArgv[i]=argv[i];
#endif
		++dwArgc;
	} //for i

	if (pptszArgv[1] == _tcsstr(pptszArgv[1], _T("/debug")))
	{
		bDebug = TRUE;
		if (_T(':') == pptszArgv[1][strlen("/debug")])
		{
			if (NULL == (fDebug =
				_tfopen(pptszArgv[1]+strlen("/debug")+1, _T("wt+"))))
			{
				fprintf(stderr, "Opening %ws failed with %lu",
						pptszArgv[1]+strlen("/debug")+1,
						errno);
			}
		} //if

		if (NULL == fDebug)
		{
			fDebug = stderr;
		} //if

		MSG(fDebug,
			"\n\nDebug report for %ws\n",
			pptszArgv[0]);
		nArgNdx++;
	} //if

    for (i=0; i<argc; i++)
    {
        MSG(fDebug,
            "\tpptszArgv[%d]==\"%ws\"\n",
            i,
            pptszArgv[i]);
    }
    MSG(fDebug,
        "\tnArgNdx==%d\n",
        nArgNdx);

	if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("add")))
	{
		ulErr = Add(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("remove")))
	{
		ulErr = Remove(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("enum")))
	{
		ulErr = Enum(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getinfo")))
	{
		ulErr = GetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdroot")))
	{
		ulErr = AddStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removestdroot")))
	{
		ulErr = RemoveStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}


	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setinfo")))
	{
		ulErr = SetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
#if 0
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getclientinfo")))
	{
		ulErr = GetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setclientinfo")))
	{
		ulErr = SetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addftroot")))
	{
		ulErr = AddFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftroot")))
	{
		ulErr = RemoveFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftrootforced")))
	{
		ulErr = RemoveFtRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdrootforced")))
	{
		ulErr = AddStdRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getdcaddress")))
	{
		ulErr = GetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setdcaddress")))
	{
		ulErr = SetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetaddconnection")))
	{
		ulErr = AddConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetcancelconnection")))
	{
		ulErr = CancelConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addresstosite")))
	{
		ulErr = AddressToSite(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else
	{
		ulErr = ERROR_INVALID_PARAMETER;

        CHECK_ERR(ulErr);
		goto Error;
	}

	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	fprintf(stdout, "%ws completed successfully\n", pptszArgv[0]);
	goto Cleanup;

Error:;
	fprintf(stderr, "%ws failed: %lu\n", pptszArgv[0], ulErr);
	goto Cleanup;

Cleanup:;
	if (NULL != pptszArgv)
	{
		DWORD	dwI = 0;

		for (dwI=0; dwI < dwArgc; dwI++)
		{
#ifdef UNICODE
			if (NULL != pptszArgv[dwI])
			{
				free(pptszArgv[dwI]);
				pptszArgv[dwI] = NULL;
			} //if
#endif
		} //for

		free(pptszArgv);
		pptszArgv = NULL;
	} //if

	if (fDebug != NULL && fDebug != stderr)
	{
		fclose(fDebug);
	}
        WPP_CLEANUP();

	RETURN(ulErr);


}; //main



	
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   This function prints a help message to stderr
//
//  Arguments:  None.
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Usage(LPSTR ptszAppName)
{
	fprintf(stderr,
			"Usage: %s [/debug:[<filename>]] <command> <options>\n\n"
			"commands:\n"
			"\tadd <dfsentrypath> <server> <share> [<comment> [<options>]]\n"
			"\t    [/range:<lo>-<hi>]\n"
			"\t\toptions=add|restore\n"
			"\t\t/range works with options=add only. When /range is present\n"
			"\t\tthe command adds multiple links\n"
			"\tremove <dfsentrypath> [<server> <share>]\n"
			"\tenum <dfsname> <level> [<prefmaxlen>]\n"
			"\t\tprefmaxlen=integer greater than 0 (resume only)\n"
			"\t\tlevel=1,2,3,4,200\n"
			"\tgetinfo <dfsentrypath> <server> <share> <level>\n"
			"\t\tlevel=1,2,3,4,100\n"
			"\tsetinfo <dfsentrypath> <server> <share> <level> <options>\n"
			"\t\tlevel=100, options=<comment>, no <server>, <share>\n"
			"\t\tlevel=101, options=[active] [offline] [online] when <server> is not null\n"
			"\t\tlevel=101, options=ok|inconsistent|offline|online when <server> is null\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
			"\tgetclientinfo <dfsentrypath> [<server> <share>] <level>\n"
			"\t\tlevel=1,2,3,4\n"
			"\tsetclientinfo <dfsentrypath> [<server> <share>] <level> <options>\n"
			"\t\tlevel=101, options=[active] [offline] [online]\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
                        "\taddstdroot <servername> <rootshare> [<comment> [<options>]]\n"
                        "\tremovestdroot <servername> <rootshare> [<options>]\n"
#if 0
			"\taddftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftrootforced <domainname> <servername> <rootshare> "
			"<ftdfsname> [<options>]\n"
			"\taddstdrootforced <servername> <rootshare> [<comment>] <store>\n"
			"\tgetdcaddress <servername>\n"
			"\tsetdcaddress <servername> <dcipaddress> <timeout> [<flags>]\n"
                        "\twnetaddconnection <level> <remotename> <password> [<localname>] [<level2params>]\n"
#endif
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, *, LPT1, etc.\n"
			"\t\tlevel2params=<type> [<provider>] [<username>] [<flags>]\n"
			"\t\ttype=disk|print|any\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\twnetcancelconnection <level> <localname> [<flags>] [force]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, etc\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\t\tforce=if present, the deletion of the connection is forced\n"
			"\n"
			"\taddresstosite <dcname> <ipaddress>\n\n"
			"To specify a NULL string in the middle of the command, use "
			"\"\".\n"
			"Example: setinfo \\\\myserver\\myentrypath \"\" \"\" "
			"100 \"My comment\".\n",
			ptszAppName);
	RETURN(ERROR_INVALID_PARAMETER);
};//Usage



	
//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   This function performs NetDfsAdd.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	ULONG	ulLo = 0;
	ULONG	ulHi = 0;
	LPTSTR	ptszVolName = NULL;
	LPTSTR	ptszRange = NULL;
	LPTSTR	ptszMinus = NULL;

	MSG(fDebug, "Entering Add(%lu,...)\n", dwArgc);
	if (dwArgc < 3 || NULL == pptszArgv || dwArgc > 6)
	{
		MSG(fDebug, "%lu < 3 || NULL == pptszArgv || %lu > 6",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (4 < dwArgc)
	{
		if (0 == _tcsicmp(pptszArgv[4], _T("add")))
		{
			dwFlags = DFS_ADD_VOLUME;
		}
		else if (0 == _tcsicmp(pptszArgv[4], _T("restore")))
		{
			dwFlags = DFS_RESTORE_VOLUME;
		}
		else
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	if (5 < dwArgc)
	{
		if (0 != _tcsnicmp(pptszArgv[5],
						   _T("/range:"),
						   _tcslen(_T("/range:"))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		ptszRange = pptszArgv[5]+_tcslen(_T("/range:"));
		if (NULL == (ptszMinus = _tcschr(ptszRange, _T('-'))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		*ptszMinus = _T('\0');
		ulLo = _ttol(ptszRange);

		*ptszMinus = _T('-');
		ulHi = _ttol(ptszMinus+1);

		if (ulLo > ulHi)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	MSG(fDebug,
		"Calling NetDfsAdd(%ws, %ws, %ws, %ws, %lu)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]), 
		GetStringParam(pptszArgv[3]),
		dwFlags);
	if (0 == ulLo && 0 == ulHi)
	{
		ulErr = APINetDfsAdd(GetStringParam(pptszArgv[0]),
						  GetStringParam(pptszArgv[1]),
						  GetStringParam(pptszArgv[2]),
						  GetStringParam(pptszArgv[3]),
						  dwFlags);
	}
	else
	{
		ULONG	ulLen = 0;

		if (NULL != GetStringParam(pptszArgv[0]))
		{
			ulLen += _tcslen(GetStringParam(pptszArgv[0]));
		}

		ptszVolName = new TCHAR[ulLen+11];
		if (NULL != ptszVolName)
		{
			memset(ptszVolName, 0, (11+ulLen) * sizeof(TCHAR));
			if (NULL != GetStringParam(pptszArgv[0]))
			{
				_tcscpy(ptszVolName, GetStringParam(pptszArgv[0]));
			}

			for (ULONG i=ulLo;
				 i <= ulHi && ERROR_SUCCESS == ulErr;
				 i++)
			{
				memset(ptszVolName+ulLen, 0, sizeof(TCHAR)*11);
				_ltot(i, ptszVolName+ulLen, 10);

				ulErr = APINetDfsAdd(ptszVolName,
								  GetStringParam(pptszArgv[1]),
								  GetStringParam(pptszArgv[2]),
								  GetStringParam(pptszArgv[3]),
								  dwFlags);
				MSG(fDebug,
					"NetDfsAdd(%ws, %ws, %ws, %ws, %lu) %s\n",
					ptszVolName,
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					GetStringParam(pptszArgv[3]),
					dwFlags,
					((ERROR_SUCCESS == ulErr) ? "succeded" : "failed"));
			} //for

			delete [] ptszVolName;
		}
		else
		{
			MSG(fDebug,
				"Error %lu: not enough memory\n",
				ulErr = ERROR_NOT_ENOUGH_MEMORY);
		} //else
	} //else

	MSG(fDebug, "Exiting Add(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Add



	
//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   This function performs NetDfsRemove.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug, "Entering Remove(%lu,..)\n", dwArgc);
	if (dwArgc < 1 || dwArgc > 3 || NULL == pptszArgv ||
		dwArgc > 1 && NULL == pptszArgv[1] ||
		dwArgc > 2 && NULL == pptszArgv[2] ||
		2 == dwArgc)
	{
		MSG(fDebug,
			"%lu < 1 || %lu > 3 || NULL == pptszArgv ||"
			" %lu > 1 && NULL == %ws ||"
			" %lu > 2 && NULL == %ws ||"
			" 2 == %lu",
			dwArgc, dwArgc, dwArgc, pptszArgv[1], dwArgc,
			pptszArgv[2], dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug, "Calling NetDfsRemove(%ws, %ws, %ws)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]));
	ulErr = APINetDfsRemove(GetStringParam(pptszArgv[0]),
						 GetStringParam(pptszArgv[1]),
						 GetStringParam(pptszArgv[2]));

	MSG(fDebug, "Exiting Remove(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Remove



	
//+---------------------------------------------------------------------------
//
//  Function:   Enum
//
//  Synopsis:   This function performs NetDfsEnum.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	DWORD	dwPrefMaxLen = (DWORD)-1;
	LPBYTE	pBuffer = NULL;
	DWORD	dwEntriesRead = 0;
	DWORD	dwResumeHandle = 0;

	MSG(fDebug, "Entering Enum(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 ||
		NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[1], _T("1")))
	{
		dwLevel = 1;
		dwPrefMaxLen = sizeof(DFS_INFO_1);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("2")))
	{
		dwLevel = 2;
		dwPrefMaxLen = sizeof(DFS_INFO_2);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("3")))
	{
		dwLevel = 3;
		dwPrefMaxLen = sizeof(DFS_INFO_3);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("4")))
	{
		dwLevel = 4;
		dwPrefMaxLen = sizeof(DFS_INFO_4);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("200")))
	{
		dwLevel = 200;
		dwPrefMaxLen = sizeof(DFS_INFO_200);
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc)
	{
		dwPrefMaxLen = (DWORD)-1;
	}
	else
	{
		if (3 != dwArgc || NULL == pptszArgv[2] ||
			0 >= _ttoi(pptszArgv[2]))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		dwPrefMaxLen *= _ttoi(pptszArgv[2]);
	}

	MSG(fDebug, "Calling NetDfsEnum(%ws,%lu,%lu,..,..,%lu)\n",
		pptszArgv[0], dwLevel, dwPrefMaxLen, dwResumeHandle);
	ulErr = APINetDfsEnum(GetStringParam(pptszArgv[0]),
                       dwLevel,
					   dwPrefMaxLen,
					   &pBuffer,
					   &dwEntriesRead,
					   &dwResumeHandle);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	if ((DWORD)-1 == dwPrefMaxLen)
	{
		LPBYTE	pCurBuffer = pBuffer;
		for (DWORD i=0; i<dwEntriesRead; i++)
		{
			ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}

			switch (dwLevel)
			{
				case 1:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
					break;
				case 2:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
					break;
				case 3:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
					break;
				case 4:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
					break;
				case 200:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
					break;
				default:
					ulErr = ERROR_INVALID_PARAMETER;
					goto Error;
			} //switch
		} //for
	}
	else
	{
		do
		{
			LPBYTE	pCurBuffer = pBuffer;
			for (DWORD i=0; i<dwEntriesRead; i++)
			{
				ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
				if (ERROR_SUCCESS != ulErr)
				{
					goto Error;
				}
	
				switch (dwLevel)
				{
					case 1:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
						break;
					case 2:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
						break;
					case 3:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
						break;
					case 4:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
						break;
					case 200:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
						break;
					default:
						ulErr = ERROR_INVALID_PARAMETER;
						goto Error;
				} //switch
			} //for

			if (NULL != pBuffer)
			{
				NetApiBufferFree(pBuffer);
				pBuffer = NULL;
			}

			MSG(fDebug,
				"Calling NetDfsEnum(%ws, %lu, %lu,..,..,%lu)\n",
				GetStringParam(pptszArgv[0]),
				dwLevel,
				dwPrefMaxLen,
				dwResumeHandle);
			ulErr = APINetDfsEnum(
						GetStringParam(pptszArgv[0]),
						dwLevel,
						dwPrefMaxLen,
						&pBuffer,
						&dwEntriesRead,
						&dwResumeHandle);
			if (ERROR_NO_MORE_ITEMS == ulErr)
			{
				if (0 != dwEntriesRead)
				{
					continue;
				}
				else
				{
					ulErr = ERROR_SUCCESS;
					break;
				}
			} //if

			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}
		}
		while(TRUE);
	} //else

Error:;
	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug,
		"Exiting Enum with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //Enum




	
//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   This function performs NetDfsGetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug, "4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		dwLevel = 100;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Calling NetDfsGetInfo(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = APINetDfsGetInfo(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[2]),
				dwLevel,
				&pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetInfo





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRoot
//
//  Synopsis:   This function performs NetDfsAddStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	MSG(fDebug,
		"Calling NetDfsAddStdRoot(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = APINetDfsAddStdRoot(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
                GetStringParam(pptszArgv[2]),
				dwOptions);

	MSG(fDebug, "Exiting AddStdRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   RemoveStdRoot
//
//  Synopsis:   This function performs NetDfsRemoveStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 3 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || %lu > 3 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (3 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[2]);
	}

	MSG(fDebug,
		"Calling NetDfsRemoveStdRoot"
		"(%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		dwOptions);
	ulErr = APINetDfsRemoveStdRoot(
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            dwOptions);

	MSG(fDebug,
		"Exiting RemoveStdRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   This function performs NetDfsSetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug,
		"Calling SetInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		DFS_INFO_100 info;

		if (4 < dwArgc)
		{
			if (5 != dwArgc)
			{
				MSG(fDebug,
					"%ws == \"100\" && 5 != %dwArgc\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			}

			info.Comment = pptszArgv[4];
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            GetStringParam(pptszArgv[2]),
			100);
		ulErr = APINetDfsSetInfo(
					GetStringParam(pptszArgv[0]),
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					100,
					(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws==\"101\" && "
					"4 < %lu && "
					"8 < %lu",
					pptszArgv[3], dwArgc, dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			if (NULL != GetStringParam(pptszArgv[1]))
			{
				if (NULL == GetStringParam(pptszArgv[2]))
				{
					MSG(fDebug,
						"4 < %lu && "
						"NULL != %ws && "
						"NULL == %ws\n",
						dwArgc, GetStringParam(pptszArgv[1]),
						GetStringParam(pptszArgv[2]));
					RETURN(ERROR_INVALID_PARAMETER);
				}

				for (i = 4; i<dwArgc; i++)
				{
					if (0 == _tcsicmp(pptszArgv[i], _T("active")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ACTIVE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_OFFLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ONLINE;
					}
					else
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
				} //for i
			}
			else
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("ok")))
				{
					info.State = DFS_VOLUME_STATE_OK;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("inconsistent")))
				{
					info.State = DFS_VOLUME_STATE_INCONSISTENT;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					info.State = DFS_VOLUME_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					info.State = DFS_VOLUME_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //else
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = APINetDfsSetInfo(GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  101,
							  (LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[4],
					dwTimeout);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = APINetDfsSetInfo(
							  GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  102,
							  (LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Exiting SetInfo(..) with %lu", ulErr);
	RETURN(ulErr);
}; //SetInfo



#if 0
	
//+---------------------------------------------------------------------------
//
//  Function:   GetClientInfo
//
//  Synopsis:   This function performs NetDfsGetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetClientInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Calling NetDfsGetClientInfo"
		"(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetClientInfo(
			  GetStringParam(pptszArgv[0]),
			  GetStringParam(pptszArgv[1]),
			  GetStringParam(pptszArgv[2]),
			  dwLevel,
			  &pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetClientInfo





//+---------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Synopsis:   This function performs NetDfsSetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug, "Entering SetClientInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws == \"101\" && "
					"4 < %lu && "
					"8 < %lu\n",
					pptszArgv[3],
					dwArgc,
					dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			for (i = 4; i<dwArgc; i++)
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("active")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ACTIVE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //for i
		} //if

		MSG(fDebug,
			"Calling NetDfsSetClientInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									101,
									(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		}

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;


		MSG(fDebug,
			"Calling NetDfsSetClientInfo"
			"(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									102,
									(LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Exiting SetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //SetClientInfo






//+---------------------------------------------------------------------------
//
//  Function:   AddFtRoot
//
//  Synopsis:   This function performs NetDfsAddFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[4]);
	}

	MSG(fDebug,
		"Calling NetDfsAddFtRoot(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
        GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsAddFtRoot(GetStringParam(pptszArgv[0]),
							GetStringParam(pptszArgv[1]),
							GetStringParam(pptszArgv[2]),
							GetStringParam(pptszArgv[3]),
							dwOptions);

	MSG(fDebug, "Exiting AddFtRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRoot
//
//  Synopsis:   This function performs NetDfsRemoveFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || %lu > 4 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRoot"
		"(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsRemoveFtRoot(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[2]),
							   dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRootForced
//
//  Synopsis:   This function performs NetDfsRemoveFtRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || %lu > 5 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRootForced"
		"(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsRemoveFtRootForced(GetStringParam(pptszArgv[0]),
									 GetStringParam(pptszArgv[1]),
									 GetStringParam(pptszArgv[2]),
									 GetStringParam(pptszArgv[3]),
									 dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRootForced(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRootForced





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRootForced
//
//  Synopsis:   This function performs NetDfsAddStdRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsAddStdRootForced(%ws,%ws,%ws,%ws)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]));
	ulErr = NetDfsAddStdRootForced(GetStringParam(pptszArgv[0]),
								   GetStringParam(pptszArgv[1]),
								   GetStringParam(pptszArgv[2]),
								   GetStringParam(pptszArgv[3]));

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot





//+---------------------------------------------------------------------------
//
//  Function:   GetDcAddress
//
//  Synopsis:   This function performs NetDfsGetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;
	LPTSTR	ptszIpAddress = NULL;
	BOOLEAN	bIsRoot = FALSE;
	ULONG	ulTimeout = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (1 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu != 1 || NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsGetDcAddress(%ws,...)\n",
		GetStringParam(pptszArgv[0]));
	ulErr = NetDfsGetDcAddress(GetStringParam(pptszArgv[0]),
							   &ptszIpAddress,
							   &bIsRoot,
							   &ulTimeout);

	if (ERROR_SUCCESS == ulErr)
	{
		LPTSTR	ptszIs = bIsRoot?_T("is"):_T("is not");

		fprintf(stdout,
				"%ws %ws a Dfs server and it will be "
				"sticking to the DC having the %ws "
				"address for %lu seconds\n",
				GetStringParam(pptszArgv[0]),
				ptszIs,
				ptszIpAddress,
				ulTimeout);
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve DC address "
				"for %ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]));
	}

	if (NULL != ptszIpAddress)
	{
		NetApiBufferFree(ptszIpAddress);
	}

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetDcAddress





//+---------------------------------------------------------------------------
//
//  Function:   SetDcAddress
//
//  Synopsis:   This function performs NetDfsSetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	ULONG	ulTimeout = 0;
	ULONG	ulFlags = 0;

	MSG(fDebug,
		"Entering SetDcAddress(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	ulTimeout = (ULONG)_ttol(GetStringParam(pptszArgv[2]));
	ulFlags = 0;

	MSG(fDebug,
		"Calling NetDfsSetDcAddress(%ws,%ws,%lu,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		ulTimeout,
		ulFlags);
	ulErr = NetDfsSetDcAddress(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   ulTimeout,
							   ulFlags);

	MSG(fDebug, "Exiting NetDfsSetDcAddress(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot







//+---------------------------------------------------------------------------
//
//  Function:   AddConnection
//
//  Synopsis:   This function performs WNetAddConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = AddConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = AddConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //AddConnection





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection1
//
//  Synopsis:   This function performs WNetAddConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //AddConnection1





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection2
//
//  Synopsis:   This function performs WNetAddConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG		ulErr = ERROR_SUCCESS;
	NETRESOURCE	NetResource;
	DWORD		dwFlags = 0;
	TCHAR		tszLocalName[128+1];
	ULONG		ulLocalNameLen = 128;

	MSG(fDebug,
		 "Entering AddConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 5)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}
	
	memset(tszLocalName, 0, sizeof(tszLocalName));
	ulErr = GetLocalName(tszLocalName,
						 ulLocalNameLen,
						 GetStringParam(pptszArgv[2]));
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	ulErr = GetNetResource(&NetResource,
						   GetStringParam(pptszArgv[3]),	// type
						   tszLocalName,					// localname
						   GetStringParam(pptszArgv[0]),	// remotename
						   GetStringParam(pptszArgv[4]));	// provider
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-6,
								   pptszArgv+6);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		 "Calling WNetAddConnection2(.., %ws, %ws, %lu)\n",
		 GetStringParam(pptszArgv[1]),
		 GetStringParam(pptszArgv[5]),
		 dwFlags);
	ulErr = WNetAddConnection2(&NetResource,
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[5]),
							   dwFlags);
Error:;	
	
	MSG(fDebug,
		 "Exiting AddConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //AddConnection2





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection
//
//  Synopsis:   This function performs WNetCancelConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = CancelConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = CancelConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //CancelConnection





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection1
//
//  Synopsis:   This function performs WNetCancelConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //CancelConnection1





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection2
//
//  Synopsis:   This function performs WNetCancelConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	BOOL	bForce = FALSE;

	MSG(fDebug,
		 "Entering CancelConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 0)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc	&&
		0 == _tcsicmp(_T("force"), pptszArgv[dwArgc-1]))
	{
		bForce = TRUE;
		--dwArgc;
	}
	
	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-1,
								   pptszArgv+1);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		"Calling WNetCancelConnection2(%ws, %lu, %ws)\n",
		GetStringParam(pptszArgv[0]),
		dwFlags,
		bForce ? _T("TRUE") : _T("FALSE"));
	ulErr = WNetCancelConnection2(GetStringParam(pptszArgv[0]),
								  dwFlags,
								  bForce);
	
Error:;	
	
	MSG(fDebug,
		 "Exiting CancelConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //CancelConnection2





//+---------------------------------------------------------------------------
//
//  Function:   GetLocalName
//
//  Synopsis:   This function returns the first available letter for net 
//				use
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg)
{
	ULONG	ulErr = ERROR_SUCCESS;
	CHAR	szDrive[4];
	BOOL	bFound = FALSE;

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws)\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg);
	if (NULL != ptszArg	&&
		0 != _tcsicmp(ptszArg, _T("available")) &&
		0 != _tcsicmp(ptszArg, _T("*")))
	{
		if (ulLocalNameLen < _tcslen(ptszArg))
		{
			RETURN(ERROR_NO_SYSTEM_RESOURCES);
		}

		_tcscpy(ptszLocalName, ptszArg);
	}
	else
	{
		if (ulLocalNameLen < 2)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	szDrive[1] = ':';
	szDrive[2] = '\\';
	szDrive[3] = '\0';
	for (CHAR C='C'; !bFound && C<='Z'; C++)
	{
		ULONG	ulType = 0;

		szDrive[0] = C;
		switch (ulType = GetDriveTypeA(szDrive))
		{
			case	0:
			case	DRIVE_REMOVABLE:
			case	DRIVE_FIXED:
			case	DRIVE_REMOTE:
			case	DRIVE_CDROM:
			case	DRIVE_RAMDISK:
				MSG(fDebug,
					"%s is of type %lu\n",
					szDrive,
					ulType);
				continue;

			case	1:
				bFound = TRUE;
				break;

			default:
				ASSERT(FALSE);
		}// switch
	} //for

	if (!bFound)
	{
		ulErr = ERROR_NO_SYSTEM_RESOURCES;
	}
	else
	{
		szDrive[2] = '\0';
#ifdef	UNICODE
		mbstowcs(ptszLocalName, szDrive, ulLocalNameLen);
#else
		_strcpy(ptszLocalName, szDrive);
#endif
	}

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws) with %lu\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg,
		ulErr);
	RETURN(ulErr);
}; //GetLocalName




//+---------------------------------------------------------------------------
//
//  Function:   GetNetResource
//
//  Synopsis:   This function fils a NETRESOURCE structure out
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwType = 0;
	
	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws)\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider);
	if (NULL == pNetResource	||
		NULL == ptszType)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	memset(pNetResource, 0, sizeof(NETRESOURCE));
	if (0 == _tcsicmp(ptszType, _T("disk")))
	{
		dwType = RESOURCETYPE_DISK;
	}
	else if (0 == _tcsicmp(ptszType, _T("print")))
	{
		dwType = RESOURCETYPE_PRINT;
	}
	else if (0 == _tcsicmp(ptszType, _T("any")))
	{
		dwType = RESOURCETYPE_ANY;
	}
	else
	{
		MSG(fDebug,
			 "%ws is an invalid type\n",
			 ptszType);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	pNetResource->dwType = dwType;
	pNetResource->lpLocalName = ptszLocalName;
	pNetResource->lpRemoteName = ptszRemoteName;
	pNetResource->lpProvider = ptszProvider;

	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws) with %lu\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider,
		 ulErr);
	RETURN(ulErr);
}; //GetNetResource





//+---------------------------------------------------------------------------
//
//  Function:   GetWNetConnectionFlags
//
//  Synopsis:   This function returns flags for WNetAddConnection2
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug,
		 "Entering CWNetAddConnection2Flags(.., %lu, ..)\n",
		 dwArgc);
	if (NULL == pdwFlags	||
		NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	*pdwFlags = 0;
	for (ULONG i=0; i<dwArgc; i++)
	{
		if (0 == _tcsicmp(_T("update_profile"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_PROFILE;
		}
		else if (0 == _tcsicmp(_T("update_recent"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_RECENT;
		}
		else if (0 == _tcsicmp(_T("temporary"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_TEMPORARY;
		}
		else if (0 == _tcsicmp(_T("interactive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_INTERACTIVE;
		}
		else if (0 == _tcsicmp(_T("prompt"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_PROMPT;
		}
		else if (0 == _tcsicmp(_T("need_drive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_NEED_DRIVE;
		}
		else if (0 == _tcsicmp(_T("refcount"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REFCOUNT;
		}
		else if (0 == _tcsicmp(_T("redirect"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REDIRECT;
		}
		else if (0 == _tcsicmp(_T("localdrive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_LOCALDRIVE;
		}
		else if (0 == _tcsicmp(_T("current_media"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_CURRENT_MEDIA;
		}
		else if (0 == _tcsicmp(_T("deferred"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_DEFERRED;
		}
		else
		{
			MSG(fDebug,
				 "Error %lu: %ws is an invalid flag\n",
				 ulErr = ERROR_INVALID_PARAMETER,
				 pptszArgv[i]);
		}
	} //for

	MSG(fDebug,
		 "Exiting CWNetAddConnection2Flags(.., %lu, ..) with %lu\n",
		 dwArgc,
		 ulErr);
	RETURN(ulErr);
}; //GetWNetAddconnection2Flags




//+---------------------------------------------------------------------------
//
//  Function:   AddressToSite
//
//  Synopsis:   This function performs DsAddressToSiteNames
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv)
{
	ULONG			ulErr = ERROR_SUCCESS;
	CString			sIp;
	CStringA		sIpA;
	ULONG			ulIP = 0;
	WSADATA			wsaData;
	PHOSTENT		pHost = NULL;
	SOCKET_ADDRESS	SocketAddress;
	SOCKADDR_IN		SockAddrIn;
	LPTSTR*			pptszSites = NULL;

	MSG(fDebug,
		"Entering AddressToSite(%lu, ...)\n",
		dwArgc);

	if (2 != dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (NULL == GetStringParam(pptszArgv[1]))
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	ulErr = sIp.Set(GetStringParam(pptszArgv[1]));
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}

	ulErr = sIpA.Set(sIp);
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}
	
	ulIP = inet_addr(sIpA.GetStringA());
	if (INADDR_NONE == ulIP)
	{
		fprintf(stderr,
				"Error %lu: invalid address %s\n",
				ulErr = ERROR_INVALID_PARAMETER,
				sIpA.GetStringA());
		RETURN(ulErr);
	}

	ulErr = WSAStartup(MAKEWORD(2,2),
					   &wsaData);
	if (ERROR_SUCCESS != ulErr)
	{
		fprintf(stderr,
				"Error %lu: cannot startup sockets",
				ulErr);
		RETURN(ulErr);
	}

	pHost = gethostbyaddr((LPCSTR)&ulIP,
						  sizeof(ulIP),
						  AF_INET);
	if (NULL == pHost)
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve host address "
				"for %ws",
				ulErr = WSAGetLastError(),
				GetStringParam(pptszArgv[1]));

		WSACleanup();
		RETURN(ulErr);
	}

	
	SockAddrIn.sin_family = pHost->h_addrtype;
	SockAddrIn.sin_port = 0;
	memcpy(&SockAddrIn.sin_addr,
		   pHost->h_addr,
		   pHost->h_length);

	SocketAddress.iSockaddrLength = sizeof(SockAddrIn);
	SocketAddress.lpSockaddr = (LPSOCKADDR)&SockAddrIn;

	ulErr = DsAddressToSiteNames(GetStringParam(pptszArgv[0]),
								 1,
								 &SocketAddress,
								 &pptszSites);
	if (ERROR_SUCCESS == ulErr && NULL != pptszSites[0])
	{
		fprintf(stdout,
				"The site of %ws on DC \\\\%ws is %ws\n",
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[0]),
				pptszSites[0]);
		NetApiBufferFree(pptszSites);
	}
	else if (ERROR_SUCCESS == ulErr && NULL == pptszSites[0])
	{
		fprintf(stdout,
				"Error %lu: address %ws is not associated "
				"to a site or it has an invalid format\n",
				ulErr = ERROR_INVALID_PARAMETER,
				GetStringParam(pptszArgv[1]));
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve site of "
				"%ws from DC \\\\%ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]));
	}

	WSACleanup();

	MSG(fDebug,
		"Exiting AddressToSite(%lu, ...) with %lu\n",
		dwArgc,
		ulErr);
	RETURN(ulErr);
};	// AddressToSite




#endif

//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo
//
//  Synopsis:   This function prints a DFS_INFO_XXX buffer out.
//
//  Arguments:  [dwLevel]	the info level
//				[pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo(%lu,..)\n",
		dwLevel);
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	switch (dwLevel)
	{
		case 1:
			ulErr = PrintDfsInfo1((PDFS_INFO_1)pBuffer);
			break;
		case 2:
			ulErr = PrintDfsInfo2((PDFS_INFO_2)pBuffer);
			break;
		case 3:
			ulErr = PrintDfsInfo3((PDFS_INFO_3)pBuffer);
			break;
		case 4:
			ulErr = PrintDfsInfo4((PDFS_INFO_4)pBuffer);
			break;
		case 200:
			ulErr = PrintDfsInfo200((PDFS_INFO_200)pBuffer);
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);		
	} //switch

	MSG(fDebug,
		"Exiting PrintDfsInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo1
//
//  Synopsis:   This function prints a DFS_INFO_1 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo1(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->EntryPath);

	MSG(fDebug,
		"Exiting PrintDfsInfo1(..) witb %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo1





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo2
//
//  Synopsis:   This function prints a DFS_INFO_2 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo2(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);

	MSG(fDebug,
		"Exiting PrintDfsInfo2(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo2





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo3
//
//  Synopsis:   This function prints a DFS_INFO_3 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo3(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);
	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo3(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo3





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo4
//
//  Synopsis:   This function prints a DFS_INFO_4 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo4(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	fprintf(stdout, "%lus   ", pBuffer->Timeout);
	fprintf(stdout, "%lu storage(s)\n", pBuffer->NumberOfStorages);

	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo4(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo200
//
//  Synopsis:   This function prints a DFS_INFO_200 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo200(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->FtDfsName);

	MSG(fDebug,
		"Exiting PrintDfsInfo200(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintStgInfo
//
//  Synopsis:   This function prints a DFS_STORAGE_INFO buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintStgInfo(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "\t\\\\%ws\\%ws\t",
			pBuffer->ServerName, pBuffer->ShareName);

	if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
	{
		fprintf(stdout, "online  ");

		if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
	{
		fprintf(stdout, "offline ");

		if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_ACTIVE)
	{
		fprintf(stdout, "active  ");
	}

	fprintf(stdout, "\n");

	MSG(fDebug,
		"Exiting PrintStgInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintStgInfo





//+---------------------------------------------------------------------------
//
//  Function:   GetStringParam
//
//  Synopsis:   This function receives a string and it returns the 
//				string itself if it is a "good" one (not null, not 
//				empty, etc).
//
//  Arguments:  [ptszParam]	the string to evaluate
//
//  Returns:    the string itself or NULL.
//
//	Notes:
//
//----------------------------------------------------------------------------
LPTSTR	GetStringParam(LPTSTR ptszParam)
{
	if (NULL == ptszParam ||
		_T('\0') == ptszParam[0] ||
		0 == _tcscmp(_T("\"\""), ptszParam))
	{
		return(NULL);
	}

	return(ptszParam);
}; //GetStringParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\setup\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//  Notes:      see notes in registry.hxx
//
//----------------------------------------------------------------------------

#include    <stdlib.h>
#include    <windows.h>
#include    <registry.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pwszPath,
                     samDesiredAccess,
                     pwszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pwszPath,
                      samDesiredAccess,
                      pwszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        const LPWSTR  pwszPath,
        REGSAM  samDesiredAccess,
        const LPWSTR  pwszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           pwszPath,           //  path to key
                           0,                  //  title index
                           pwszClass,          //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        const  LPWSTR  pwszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pwszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}
//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPWSTR)_cwszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPWSTR)_cwszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\debug\debug.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

//////////////////////////////////////////////////////////////////////////////
// global variables. These could be local, but we want debuggers to be able
// to get at them. Use extern "C" to make them easier to find.

extern "C"
{
unsigned long DebugInfoLevel = DEF_INFOLEVEL;
unsigned long DebugInfoMask = 0xffffffff;
unsigned long DebugAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
}

//////////////////////////////////////////////////////////////////////////////
// local variables

static BOOL s_fCritSecInit = FALSE;
static BOOL s_fInfoLevelInit = FALSE;
static CRITICAL_SECTION s_csDebugPrint;
static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[2000];        // this is the message buffer

//////////////////////////////////////////////////////////////////////////////
// local functions

static int DebugInternalvprintf(const char *format, va_list arglist);
static int DebugInternalprintf(const char *format, ...);
static void DebugAssertInternalprintf(char const *pszfmt, ...);
static int PopUpError(char const* pszMsg, int iLine, char const* pszFile);

//////////////////////////////////////////////////////////////////////////////

static int DebugInternalvprintf(const char* format, va_list arglist)
{
    int ret;
    EnterCriticalSection(&s_csMessageBuf);
    ret = vsprintf(g_szMessageBuf, format, arglist);
    OutputDebugStringA(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return ret;
}

static int DebugInternalprintf(const char* format, ...)
{
    int ret;
    va_list va;
    va_start(va, format);
    ret = DebugInternalvprintf(format, va);
    va_end(va);
    return ret;
}

static void DebugAssertInternalprintf(char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    Debugvprintf(DEB_FORCE, "Assert", pszfmt, va);
    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void DEBUGAPI
DebugAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (DebugAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();
        DebugAssertInternalprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (DebugAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);
        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (DebugAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    DebugSetInfoLevel
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugInfoLevel;
    DebugInfoLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetInfoMask
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul = DebugInfoMask;
    DebugInfoMask = ulNewMask;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetAssertLevel
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugAssertLevel;
    DebugAssertLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

static int PopUpError(char const* szMsg, int iLine, char const* szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char* pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
                                | MB_SERVICE_NOTIFICATION
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    Debugvprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *  pszComp,
    char const *  ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | DebugInfoLevel) & DebugInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((DebugInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                DebugInternalprintf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            DebugInternalvprintf(ppszfmt, pargs);
        }

        if (DebugInfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                printf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define DEBUGKEY "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Debug"

//+----------------------------------------------------------------------------
// Function:    DebugCheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void DEBUGAPI
DebugCheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    if (s_fInfoLevelInit) return;
    if (!s_fCritSecInit) DebugInitialize();
    HKEY hKey;
    LONG lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
    s_fInfoLevelInit = TRUE;
}

//+----------------------------------------------------------------------------
// Function:    DebugInitialize
//
// Synopsis:    Performs debugging library initialization
//
//-----------------------------------------------------------------------------

void DebugInitialize(void)
{
    if (s_fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    s_fCritSecInit = TRUE;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\setup\setupsvc.cxx ===
//+------------------------------------------------------------------
//
// File:        SETUPSVC.CXX
//
// Contents:
//
// Synoposis:
//
// Classes:     CService
//
// Functions:
//
// History:     May 19, 1993        AlokS       Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <windowsx.h>
#include <shlobj.h>
#include <registry.hxx>
#include <setupsvc.hxx>

#include "resource.h"

#include "messages.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
extern HINSTANCE g_hInstance;

//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}

VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}
//+------------------------------------------------------------------
//
// Class: CService
//
// Purpose: Helper class for dealing with Service Controller
//
// Interface: CService::CService()          = Constructor
//            CService::~CService()         = Destructor
//            CService::Init()              = Initializes the class
//            CService::_CreateService()    = Install a Win32 Service
//            CService::_OpenService()      = Open an existing service
//            CService::_QueryServiceStatus() = Query servcie status.
//            CService::_CloseService()     = Close all resources associated with
//                       the service
//            CService::_DeleteService()    = Remove a Win32 Service
//            CService::_DisableService()   = Disables a Win32 Service
//            CService::_StartService()     = Start an existing service
//            CService::_StopService()      = Stop an existing, running service
//            CService::_ConfigService()    = Combo operation. Create if
//                                         not present else reconfigure it
//
// History: May 20, 1993         AlokS       Created
//
// Notes: This is a smart wrapper class for Service APIs. But it is not
//        multi-thread safe.
//
//-------------------------------------------------------------------

//+------------------------------------------------------------------
//
// Member: CService::CService
//
// Synopsis: Create an instance
//
// Effects: Instantiates the class
//
// Arguments: -none-
//
// Returns  : None.
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------

CService::CService():
       _schSCManager(NULL),
       _scHandle(NULL)
{
    ;
}
//+------------------------------------------------------------------
//
// Member: CService::Init
//
// Synopsis: Open handle to Service Controller
//
// Effects: -do-
//
// Arguments: -none-
//
// Returns  : 0 on success else error from opening SC.
//
// History: Nov 4, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------
DWORD   CService::Init()
{
    DWORD dwStatus = 0;
    // Open the local SC database
    _schSCManager =  OpenSCManager(NULL, // Machine Name
                                   NULL, // Database Name
                                   SC_MANAGER_CREATE_SERVICE|
                                   SC_MANAGER_LOCK
                                  );
    if (_schSCManager == NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR, "Error: %lx in opening SCManager", dwStatus));
    }
    return(dwStatus);
}
//+------------------------------------------------------------------
//
// Member: CService::~CService
//
// Synopsis: Release all resources
//
// Effects: Closes SC database handle as well as any  service handle
//
// Arguments: none
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Remember that we have only 1 service handle per instance.
//
//-------------------------------------------------------------------

CService::~CService()
{

    if (_schSCManager != NULL)
        CloseServiceHandle (_schSCManager);

    if (_scHandle != NULL)
        CloseServiceHandle (_scHandle);
}
//+------------------------------------------------------------------
//
// Member: CService::_CreateService
//
// Synopsis: This method is used to install a new Win32 Service or driver
//
// Effects: Creates a service.
//
// Arguments: all [in] parameters. See CreateService() API documentation
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of newly created service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_CreateService(const LPWSTR  lpwszServiceName,
                            const LPWSTR  lpwszDisplayName,
                                  DWORD   fdwDesiredAccess,
                                  DWORD   fdwServiceType,
                                  DWORD   fdwStartType,
                                  DWORD   fdwErrorControl,
                            const LPWSTR  lpwszBinaryPathName,
                            const LPWSTR  lpwszLoadOrderGroup,
                            const LPDWORD lpdwTagID,
                            const LPWSTR  lpwszDependencies,
                            const LPWSTR  lpwszServiceStartName,
                            const LPWSTR  lpwszPassword)
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;

    _scHandle  = CreateService(_schSCManager,
                                lpwszServiceName,
                                lpwszDisplayName,
                                fdwDesiredAccess,
                                fdwServiceType,
                                fdwStartType,
                                fdwErrorControl,
                                lpwszBinaryPathName,
                                lpwszLoadOrderGroup,
                                lpdwTagID,
                                lpwszDependencies,
                                lpwszServiceStartName,
                                lpwszPassword
                               );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                   "Error: %lx in CreateService: %ws\n",
                   dwStatus,
                   lpwszServiceName));
    }

    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_OpenService
//
// Synopsis: Opens the service if caller has specified proper access
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service
//            [in] fdwDesiredAccess = Open Access mode bits
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_OpenService( const LPWSTR lpwszServiceName,
                                 DWORD fdwDesiredAccess
                        )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              fdwDesiredAccess
                            );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in OpeningService: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    return dwStatus;

}

//+------------------------------------------------------------------
//
// Member: CService::_StartService
//
// Synopsis: Start the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to start
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StartService( const LPWSTR lpwszServiceName
                          )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_START|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!StartService(_scHandle, NULL, NULL))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Starting Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;

}
//+------------------------------------------------------------------
//
// Member: CService::_StopService
//
// Synopsis: Stop the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to stop
//
// Returns: 0 on success
//
// History: May 9, 1994         DaveStr       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StopService( const LPWSTR lpwszServiceName
                          )
{
    SERVICE_STATUS ss;

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_STOP|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!ControlService(_scHandle, SERVICE_CONTROL_STOP, &ss))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Controlling (stopping) Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_DeleteService
//
// Synopsis: Remove the named service
//
// Effects: Deletes a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to remove
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DeleteService( const LPWSTR lpwszServiceName )

{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG|
                             DELETE
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!DeleteService ( _scHandle))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in DeleteService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Member: CService::_DisableService
//
// Synopsis: Disable the named service
//
// Effects: Disables a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to disable
//
// Returns: 0 on success
//
// History: Dec 8, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DisableService( const LPWSTR lpwszServiceName )
{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!ChangeServiceConfig ( _scHandle,           // Handle
                                   SERVICE_NO_CHANGE,   // Type
                                   SERVICE_DISABLED,    // Start
                                   SERVICE_NO_CHANGE,   // Error
                                   NULL,                // Path
                                   NULL,                // Load order
                                   NULL,                // Tag
                                   NULL,                // Depend
                                   NULL,                // Start name
                                   NULL,                // Password
                                   NULL                 // Display Name
                                  ))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in ChangeService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_CloseService
//
// Synopsis:  Close a service for which we have an open handle
//
// Effects: Close service handle, if opened previously
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
void CService::_CloseService( )
{
    if (_scHandle != NULL)
        CloseServiceHandle ( _scHandle);
    _scHandle = NULL;
}

//+------------------------------------------------------------------
//
// Member: CService::_QueryServiceStatus
//
// Synopsis:  query current service status
//
// Effects: none
//
// Arguments: service_status - service status structure.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_QueryServiceStatus(LPSERVICE_STATUS ss)
{
    if (_scHandle != NULL) {

        if (!QueryServiceStatus(_scHandle, ss))
            return(GetLastError());

        return(0);
    }

    return(ERROR_INVALID_HANDLE);
}

//+------------------------------------------------------------------
//
// Member: CService::ConfigService
//
// Synopsis: Create else Open/Change the named Service
//
// Effects: It first tries to create a service. If one exists already,
//          it changes the configuration to new configuration.
//
// Arguments: Lots of them. See documentation on CreateService() API.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Most people should use this method only for setting up services
//
// MAJOR NOTE: It is essential that all the keys being asked to change
//             be actually present before they can be changed
//
//
//
//-------------------------------------------------------------------
WCHAR MsgBuf[0x1000];

DWORD CService::_ConfigService(   DWORD fdwServiceType,
                                  DWORD fdwStartType,
                                  DWORD fdwErrorControl,
                            const LPWSTR lpwszBinaryPathName,
                            const LPWSTR lpwszLoadOrderGroup,
                            const LPWSTR lpwszDependencies,
                            const LPWSTR lpwszServiceStartName,
                            const LPWSTR lpwszPassword,
                            const LPWSTR lpwszDisplayName,
                            const LPWSTR lpwszServiceName
                          )
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }

    DWORD dwStatus = ERROR_SERVICE_DATABASE_LOCKED;
    SC_LOCK scLock;

    //
    // Let us lock the database.  There could be a problem here
    // because the service controller also locks the database when
    // starting a service so it reads the startup parameters properly.
    // If this is the case, and the database is locked, we just try
    // up to 5 times to lock it ourselves before we fail. 
    //
    for ( ULONG tries = 0;
          (tries < 5) && (dwStatus == ERROR_SERVICE_DATABASE_LOCKED);
          tries++ )
    {
        scLock = LockServiceDatabase (_schSCManager);

        if ( scLock == NULL )
        {
            dwStatus = GetLastError();

            DSSCDebugOut((DEB_ERROR, "LockServiceDatabase(try %d) == %#0x\n",
                         tries, dwStatus));

            if ( dwStatus == ERROR_SERVICE_DATABASE_LOCKED )
            {
                Sleep ( 2 * 1000 );
            }
        }
        else
        {
            dwStatus = 0;
        }
    }

    if ( dwStatus != 0 )
    {
        return dwStatus;
    }

    // First, we try to create the service.
    dwStatus   =  _CreateService(
                                  lpwszServiceName,
                                  lpwszDisplayName,
                                  GENERIC_WRITE,         // Access
                                  fdwServiceType,
                                  fdwStartType,
                                  fdwErrorControl,
                                  lpwszBinaryPathName,
                                  lpwszLoadOrderGroup,
                                  NULL,                  // Tag ID
                                  lpwszDependencies,
                                  lpwszServiceStartName,
                                  lpwszPassword
                                 );
    // It is possible that service exists
    if ((dwStatus == ERROR_SERVICE_EXISTS) ||
        (dwStatus == ERROR_DUP_NAME))
    {
        // Open the service
        dwStatus =  _OpenService(lpwszServiceName,
                                 SERVICE_CHANGE_CONFIG|DELETE);

        if (!dwStatus) {

            if (!ChangeServiceConfig(_scHandle,
                                 fdwServiceType,
                                 fdwStartType,
                                 fdwErrorControl,
                                 lpwszBinaryPathName,
                                 lpwszLoadOrderGroup,
                                 NULL,
                                 lpwszDependencies,
                                 lpwszServiceStartName,
                                 lpwszPassword,
                                 lpwszDisplayName
                                 )) {

                //
                // Change didn't work, lets try to delete and recreate this
                // service.
                //

                dwStatus = 0;

                if (!DeleteService ( _scHandle)) {
                    // This is hopeless. Let us give up now
                    dwStatus = GetLastError();
                    DSSCDebugOut(( DEB_IERROR,
                                   "Error: %lx in DeleteService: %ws\n",
                                   dwStatus,
                                   lpwszServiceName));

                }

                _CloseService();

                if (!dwStatus) {
                    // last attempt to create
                    dwStatus   =  _CreateService(
                                                 lpwszServiceName,
                                                 lpwszDisplayName,
                                                 GENERIC_WRITE,         // Access
                                                 fdwServiceType,
                                                 fdwStartType,
                                                 fdwErrorControl,
                                                 lpwszBinaryPathName,
                                                 lpwszLoadOrderGroup,
                                                 NULL,                  // Tag ID
                                                 lpwszDependencies,
                                                 lpwszServiceStartName,
                                                 lpwszPassword
                                                );
                    DSSCDebugOut(( DEB_IERROR,
                                   "This is hopeless. Recreating failed!!\n"));

                }

            }

        } // OpenService

    } // CreateService

    //
    // Set description
    //

    if (dwStatus == ERROR_SUCCESS) {

        SERVICE_DESCRIPTION ServiceDescription;

        // Open the service if the above did not
        if (_scHandle == NULL) {
            dwStatus =  _OpenService(
                                lpwszServiceName,
                                SERVICE_CHANGE_CONFIG);
        }

        if (dwStatus == ERROR_SUCCESS) {
            ULONG i;
            MyFormatMessage(MSG_DFS_DESCRIPTION, MsgBuf, sizeof(MsgBuf)/sizeof(WCHAR));
            for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
                if (MsgBuf[i] == L'\r')
                    MsgBuf[i] = UNICODE_NULL;
                else if (MsgBuf[i] == L'\n')
                    MsgBuf[i] = UNICODE_NULL;
            }
            ServiceDescription.lpDescription = MsgBuf;

            dwStatus = ChangeServiceConfig2(
                           _scHandle,
                           SERVICE_CONFIG_DESCRIPTION, // InfoLevel
                           &ServiceDescription);

            dwStatus = (dwStatus != 0) ? ERROR_SUCCESS : GetLastError();

        }

   }

    _CloseService();
    UnlockServiceDatabase ( scLock);
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Function: _StartService
//
// Synopsis:
//
// Effects: Starts the Service and any other
//          service dependent on it. It also ensures that the
//          service has started befor returning.
//
// Arguments: [pwsz] -- name of the service to be started
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:   This code was borrowed from the original StartDfs code
//          written by Aloks and parameterized  to allow other
//          services to be started. An interesting question is
//          whether this should be made a method of CDSSvc class.
//          (TBD by AlokS)
//
//-------------------------------------------------------------------
DWORD _SynchStartService(WCHAR *pwszServiceName)
{
    DWORD dwRc;
    // Open Service Controller
    CService cSvc;
    if ((dwRc = cSvc.Init())== ERROR_SUCCESS)
    {
        // Start the Service
        dwRc = cSvc._StartService(pwszServiceName);
        if (dwRc == ERROR_SERVICE_ALREADY_RUNNING)
        {
            // We are done!
            return ( ERROR_SUCCESS );
        }
    }
    if (dwRc)
    {
        DSSCDebugOut((DEB_IERROR, "Error starting:  %ws\n",pwszServiceName));
        return(dwRc);
    }

    // Wait for the service to start running
    SERVICE_STATUS scStatus;
    DWORD          MaxTries = 0;
    do
    {
        if (!QueryServiceStatus(cSvc.QueryService(),
                                &scStatus
                               ))
        {
            dwRc = GetLastError();
            DSSCDebugOut((DEB_IERROR, "Error Querying service\n"));
            break;
        }
        else if (scStatus.dwCurrentState != SERVICE_RUNNING)
        {
            Sleep(SERVICE_WAIT_TIME);
            MaxTries++;
        }

    } while ( scStatus.dwCurrentState != SERVICE_RUNNING && MaxTries < MAX_SERVICE_WAIT_RETRIES);
    if (MaxTries == MAX_SERVICE_WAIT_RETRIES)
    {
        dwRc = ERROR_SERVICE_REQUEST_TIMEOUT;
    }
    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: ConfigDfs
//
// Synopsis:
//
// Effects: Configures DFS File System Driver
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------

DWORD ConfigDfs()
{
    DWORD    dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    // Create DFS (Driver)
    dwErr = cSvc._ConfigService(
                    SERVICE_FILE_SYSTEM_DRIVER, // Service Type
                    SERVICE_BOOT_START,         // Start Type
                    SERVICE_ERROR_NORMAL,       // Error Control
                                                // service file
                    L"\\SystemRoot\\system32\\drivers\\Dfs.sys",
                    L"filter",                  // Load order group
                    NULL,                       // Dependency
                    NULL,                       // Service start name
                    NULL,                       // password
                    L"DfsDriver",               // display name
                    L"DfsDriver"                // Service Name
                    );

    if (dwErr)
        return dwErr;

    //
    // Registry Changes
    //

    //
    // Fix up the NetworkProvider order level - delete the Dfs provider
    // if one has been inserted there
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                PWCHAR pwszDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its not already there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");

                    if (pwszDfs != NULL) {
                        *pwszDfs = UNICODE_NULL;
                        wcscat( pwszProviders, pwszDfs + 4);
                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }
            }
        }
    }

    return dwErr;
}

//+------------------------------------------------------------------
//
// Function: StartDfs
//
// Synopsis:
//
// Effects: Starts out the DFS Service.
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------
DWORD StartDfs (
    GUID *pguidDomain,
    PWSTR pwszDomain
    )
{
    DWORD dwRc;

    //
    // We load the dfs driver and then call FindDomainController. This
    // call to FindDomainController is expected to seed the Dfs driver
    // with domain info.
    //

    dwRc = _SynchStartService(L"Dfs");

    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: RemoveDfs
//
// Synopsis:
//
// Effects: Remove DFS driver
//
//-------------------------------------------------------------------

DWORD
RemoveDfs(void)
{
    //DbgCommonApiTrace(RemoveDfs);

    DWORD dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Disable DFS driver
        dwErr = cSvc._DisableService(L"Dfs");
    }
    if (dwErr)
    {
        return(dwErr);
    }
    /*
     * Registry Changes
     */
    // Now, we remove entries under DFS entry in registry

    //
    // Remove Dfs from the NetworkProvider list
    //
    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                WCHAR *pwszDfs, *pwszAfterDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");
                    if (pwszDfs != NULL) {

                        pwszAfterDfs = pwszDfs + wcslen(L"Dfs,");

                        memmove(
                            (PVOID) pwszDfs,
                            (PVOID) pwszAfterDfs,
                            (wcslen( pwszAfterDfs ) + 1) * sizeof(WCHAR));

                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }

            }

        }

    }

    return dwErr ;
}

//+------------------------------------------------------------------
//
// Function: ConfigDfsService
//
// Synopsis:
//
// Effects: Configures Dfs Service
//
//-------------------------------------------------------------------

DWORD
ConfigDfsService()
{
    DWORD dwErr = 0;
    ULONG i;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    //
    // Get localizable name of service
    //
    MyFormatMessage(MSG_DFS_COMPONENT_NAME, MsgBuf, sizeof(MsgBuf)/sizeof(WCHAR));
    for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
        if (MsgBuf[i] == L'\r')
            MsgBuf[i] = UNICODE_NULL;
        else if (MsgBuf[i] == L'\n')
            MsgBuf[i] = UNICODE_NULL;
    }

    // Create entry for Dfs Manager
    dwErr = cSvc._ConfigService(

               SERVICE_WIN32_OWN_PROCESS,  // Service Type
               SERVICE_AUTO_START,         // Start Type
               SERVICE_ERROR_NORMAL,       // Error Control
               L"%SystemRoot%\\system32\\Dfssvc.exe",  // service binary
               L"Dfs",                     // Load order group
               L"LanmanWorkstation\0LanmanServer\0DfsDriver\0Mup\0SamSS\0",   // Dependency
               NULL,                       // Logon Name
               NULL,                       // Logon Password
               MsgBuf,                     // display name
               L"Dfs"                      // Service Name
               );

    if (dwErr == ERROR_SUCCESS) {
        CRegKey cregDfs( HKEY_LOCAL_MACHINE,
                          &dwErr,
                          L"System\\CurrentControlSet\\Services\\Dfs"
                       );

        if (dwErr == ERROR_SUCCESS)  {

            CRegDWORD DfsVer ((const CRegKey &)cregDfs, L"DfsVersion",
                               DFS_VERSION_NUMBER);

            dwErr = DfsVer.QueryErrorStatus();

        }
    }
    return dwErr ;
}


//+------------------------------------------------------------------
//
// Function: RemoveDfsService
//
// Synopsis:
//
// Effects: Remove Dfs Service
//
// Arguments: -none-
//
// Returns: 0 on success
//
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


DWORD RemoveDfsService( )
{
    DWORD dwErr = 0;

        // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Delete  DFSManager Service
        dwErr = cSvc._DeleteService(L"DfsService");
    }

    return dwErr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\debug\debug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//  NOTE: you must call the DebugInitialize() API before calling any other
//  APIs!
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>      // for vsprintf
#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)
#define UNREFERENCED_PARM(x)    (x)

#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#ifndef DEBUGAPI
    #define DEBUGAPI __stdcall
#endif

//
// The following APIs are public and may be called
//

void DEBUGAPI
DebugInitialize(
    void);

unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel);

unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask);

unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel);

//
// The following APIs should never be called directly. They will be called
// via macros defined herein.
//

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list ArgList);

void DEBUGAPI
DebugAssertEx(
    char const *pszFile,
    int iLine,
    char const *pszMsg);

void DEBUGAPI
DebugCheckInit(
    char* pInfoLevelString,
    unsigned long* InfoLevel);

//
// Public assertion macros
//

#define DebugAssert(x) (void)((x) || (DebugAssertEx(__FILE__, __LINE__, #x),0))
#define DebugVerify(x) DebugAssert(x)

//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
    #define DEF_INFOLEVEL 0
#endif

#ifdef __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern "C" unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern "C" char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern "C" unsigned long comp##InfoLevel;\
        extern "C" char* comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }\
        class comp##CDbgTrace\
        {\
        private:\
            unsigned long _ulFlags;\
            char const * const _pszName;\
        public:\
            comp##CDbgTrace(unsigned long ulFlags, char const * const pszName)\
            : _ulFlags(ulFlags), _pszName(pszName)\
            {\
                comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
            }\
            ~comp##CDbgTrace()\
            {\
                comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
            }\
        };

#else  // ! __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern unsigned long comp##InfoLevel;\
        extern char *comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }

#endif // ! __cplusplus

#else // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define DebugInitialize()

#define DebugAssert(x)  NULL
#define DebugVerify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\dfsadmin.h ===
#ifndef __DFS_SCRIPT_H__
#define __DFS_SCRIPT_H__

#include "lm.h"
#include "lmdfs.h"
#include <dfsheader.h>
#include <dfsprefix.h>
#include <dfsmisc.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include "objects.h"



DFSSTATUS
DfsView (
    LPWSTR RootName,
    FILE *Out );

DumpDfsInfo(
    DWORD Entry,
    DWORD Level,
    PDFS_INFO_4 pBuf,
    FILE *Out);

DFSSTATUS
SetTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget);

DFSSTATUS
SetLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink);


DFSSTATUS
DfsMerge (
    PROOT_DEF pRoot,
    LPWSTR NameSpace );


DFSSTATUS
VerifyLink(
    PLINK_DEF pLink);

DFSSTATUS
VerifyTarget(
    PLINK_DEF pLink,
    PTARGET_DEF pTarget);

VOID
DumpCurrentTime();

DWORD
UpdateLinkMetaInformation(
    PUNICODE_STRING pLinkName,
    PLINK_DEF pLink);

extern ULONG AddLinks, RemoveLinks, AddTargets, RemoveTargets, ApiCalls;

extern FILE *DebugOut;

#endif // __DFS_SCRIPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\objects.h ===
#ifndef __DFS_SCRIPT_OBJECTS_H__
#define __DFS_SCRIPT_OBJECTS_H__


DFSSTATUS
AddNewLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink,
    BOOLEAN Update );

DFSSTATUS
AddNewTarget( 
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget);

DFSSTATUS
AddNewRoot(
    PROOT_DEF pRoot,
    LPWSTR NameSpace,
    BOOLEAN Update );

DeleteRoot(
    PROOT_DEF pRoot );


DeleteLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink );

DeleteTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget );

DFSSTATUS
DfsCreateWideString(
    PUNICODE_STRING pName,
    LPWSTR *pString );


#endif // __DFS_SCRIPT_OBJECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\merge.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsadmin.h"

DFSSTATUS
AddRootToPrefixTable(
    struct _DFS_PREFIX_TABLE **ppTable,
    PROOT_DEF pRoot );

PLINK_DEF
CreateNewLinkEntry(
    LPWSTR LinkName );

PTARGET_DEF
CreateNewTargetEntry(
    LPWSTR ServerName,
    LPWSTR ShareName,
    ULONG State );

PLINK_DEF
GetLinkEntry( 
    struct _DFS_PREFIX_TABLE *pTable,
    LPWSTR NameString );

PTARGET_DEF
GetTargetEntry(
    PLINK_DEF pLink,
    LPWSTR ServerName,
    LPWSTR ShareName );

PLINK_DEF
MergeLinkInfo(
    PDFS_INFO_4 pBuf,
    struct _DFS_PREFIX_TABLE *pPrefixTable );




DFSSTATUS
DfsMerge (
    PROOT_DEF pRoot,
    LPWSTR NameSpace )
{
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = -1;
    DWORD Level = 4;
    DFSSTATUS Status;
    NTSTATUS NtStatus;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i;

    PLINK_DEF pGrownLinks = NULL, pLink;
    struct _DFS_PREFIX_TABLE *pPrefixTable;


    Status = AddRootToPrefixTable( &pPrefixTable,
                                   pRoot );
    if (Status != ERROR_SUCCESS)
    {
        printf("DfsVerify: create prefix table failed %x\n", Status);
        return Status;
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Contacting %wS for enumeration \n", NameSpace);
    }

    Status = NetDfsEnum( NameSpace,
                         Level, 
                         PrefMaxLen, 
                         &pBuffer, 
                         &EntriesRead, 
                         &ResumeHandle);

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Enumeration for %wS is complete %d entries\n", 
                 NameSpace,
                 EntriesRead);
    }
    
    if (Status != ERROR_SUCCESS)
    {
        printf("Export: cannot enum %wS: error %x\n", NameSpace, Status);
        return Status;
    }

    pCurrentBuffer = (PDFS_INFO_4)pBuffer;

    NtStatus = DfsPrefixTableAcquireWriteLock( pPrefixTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }



    for (i = 0; i < EntriesRead; i++)
    {
        pLink = MergeLinkInfo( pCurrentBuffer,
                               pPrefixTable);
        if (pLink != NULL)
        {
            if (pGrownLinks == NULL)
            {
                pGrownLinks = pRoot->pLinks;
            }
            NEXT_LINK_OBJECT(pLink) = pGrownLinks;
            pGrownLinks = pLink;
        }

        pCurrentBuffer++;
    }
    DfsPrefixTableReleaseLock(pPrefixTable);
    if (pGrownLinks != NULL)
    {
        pRoot->pLinks = pGrownLinks;
    }
    return Status;
}


PTARGET_DEF
CreateNewTargetEntry(
    LPWSTR ServerName,
    LPWSTR ShareName,
    ULONG  State )
{
    DFSSTATUS Status;
    UNICODE_STRING TargetName;
    PTARGET_DEF pTarget = NULL;

    Status = DfsCreateUnicodePathString( &TargetName,
                                         2, // unc path: 2 leading sep.
                                         ServerName,
                                         ShareName );
    if (Status == ERROR_SUCCESS)
    {
        pTarget = CreateTargetDef(IN_NAMESPACE, TargetName.Buffer, State);

        DfsFreeUnicodeString(&TargetName);
    }

    return pTarget;
}

PLINK_DEF
CreateNewLinkEntry(
    LPWSTR LinkName )
{
    PLINK_DEF pLink;

    pLink = CreateLinkDef(IN_NAMESPACE, LinkName, NULL);

    return pLink;
}


VOID
UpdateLinkEntry( 
    PLINK_DEF pLink,
    ULONG State,
    ULONG Timeout,
    LPWSTR Comment )
{
    if (State != 0)
    {
        AddObjectStateValue(&pLink->BaseObject, State);
    }
    if (Timeout != 0)
    {
        AddObjectTimeoutValue(&pLink->BaseObject, Timeout);
    }
    if (Comment != NULL)
    {
        AddObjectComment(&pLink->BaseObject, Comment);
    }
}

DFSSTATUS
AddRootToPrefixTable(
    struct _DFS_PREFIX_TABLE **ppTable,
    PROOT_DEF pRoot )
{
    struct _DFS_PREFIX_TABLE *pTable = NULL;
    NTSTATUS NtStatus;
    PLINK_DEF pLink;
    UNICODE_STRING LinkName;
    ULONG Links = 0;

    NtStatus = DfsInitializePrefixTable( &pTable,
                                         FALSE, 
                                         NULL );

    if (NtStatus != STATUS_SUCCESS)
    {
        return NtStatus;
    }

    NtStatus = DfsPrefixTableAcquireWriteLock( pTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }
    for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
    {
        RtlInitUnicodeString(&LinkName, pLink->LinkObjectName);
        NtStatus = DfsInsertInPrefixTableLocked( pTable,
                                                 &LinkName,
                                                 (PVOID)(pLink) );
        if (NtStatus == STATUS_SUCCESS)
        {
            pLink->LinkObjectFlags |= IN_TABLE;
        }
        else {
            printf(" AddRootToPrefixTable: Link %wZ, Status 0x%x\n, Links %d", 
                   &LinkName, NtStatus, Links);

            break;
        }
        Links++;
    }
    DfsPrefixTableReleaseLock(pTable);
    *ppTable = pTable;
    return NtStatus;
}


DFSSTATUS
DeletePrefixTable(
    struct _DFS_PREFIX_TABLE *pTable,
    PROOT_DEF pRoot )
{
    PLINK_DEF pLink;
    NTSTATUS NtStatus;
    UNICODE_STRING LinkName;

    
    NtStatus = DfsPrefixTableAcquireWriteLock( pTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }
    for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
    {
        if ((pLink->LinkObjectFlags & IN_TABLE) == TRUE)
        {
            RtlInitUnicodeString(&LinkName, pLink->LinkObjectName);
            NtStatus = DfsRemoveFromPrefixTableLocked( pTable,
                                                       &LinkName,
                                                       (PVOID)(pLink) );
            if (NtStatus == STATUS_SUCCESS)
            {
                pLink->LinkObjectFlags &= ~IN_TABLE;
            }
            else {
                break;
            }
        }
    }
    DfsPrefixTableReleaseLock(pTable);
    DfsDereferencePrefixTable( pTable );

    return NtStatus;



}




PLINK_DEF
GetLinkEntry( 
    struct _DFS_PREFIX_TABLE *pTable,
    LPWSTR NameString )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Suffix;
    PLINK_DEF pLink;

    RtlInitUnicodeString( &Name, NameString );
    
    Status = DfsFindUnicodePrefixLocked( pTable,
                                         &Name,
                                         &Suffix,
                                         &pLink,
                                         NULL );

    if (Status == STATUS_SUCCESS)
    {
        return pLink;
    }
    
    if (Status != STATUS_OBJECT_PATH_NOT_FOUND)
    {
        printf("GetLinkEntry: unexpected status %x\n", Status);
    }
    return NULL;
}



PTARGET_DEF
GetTargetEntry(
    PLINK_DEF pLink,
    LPWSTR ServerName,
    LPWSTR ShareName )
{
    PTARGET_DEF pTarget, pReturn = NULL;
    UNICODE_STRING TargetName;
    DFSSTATUS Status;

    Status = DfsCreateUnicodePathString( &TargetName,
                                         2, // unc path: 2 leading sep.
                                         ServerName,
                                         ShareName );
    if (Status != ERROR_SUCCESS)
    {
        printf("GetTargetEntry: failed to create string\n");
        return NULL;
    }

    for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
    {
        if (_wcsicmp(TargetName.Buffer, pTarget->Name) == 0)
        {
            pReturn = pTarget;
            break;

        }
    }

    DfsFreeUnicodeString(&TargetName);

    return pReturn;
}


PLINK_DEF
MergeLinkInfo(
    PDFS_INFO_4 pBuf,
    struct _DFS_PREFIX_TABLE *pPrefixTable )
{
    PLINK_DEF pLink, pReturn = NULL;
    DWORD i;
    PDFS_STORAGE_INFO pStorage;
    UNICODE_STRING LinkName, ServerName, ShareName, Remains;
    DFSSTATUS Status;
    PTARGET_DEF pTargetList = NULL, pTarget;

    RtlInitUnicodeString( &LinkName, pBuf->EntryPath);

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Link %ws in namespace, with %d targets.Merging\n",

                 pBuf->EntryPath, pBuf->NumberOfStorages);

    }
    Status = DfsGetPathComponents(&LinkName,
                                  &ServerName,
                                  &ShareName,
                                  &Remains);

    if (Remains.Length == 0)
    {
        return NULL;
    }
    if ((pLink = GetLinkEntry(pPrefixTable,
                              Remains.Buffer)) == NULL)
    {
        pLink = CreateNewLinkEntry(Remains.Buffer);
        UpdateLinkEntry( pLink, pBuf->State, pBuf->Timeout, pBuf->Comment);
        pReturn = pLink;
    }

    SetObjectInNameSpace(pLink);
    for(i = 0, pStorage = pBuf->Storage;
        i < pBuf->NumberOfStorages;
        i++, pStorage = pBuf->Storage+i) {

        if ((pTarget = GetTargetEntry(pLink,
                                      pStorage->ServerName,
                                      pStorage->ShareName)) == NULL)
        {
            pTarget = CreateNewTargetEntry(pStorage->ServerName,
                                           pStorage->ShareName,
                                           pStorage->State);
            if (pTargetList == NULL)
            {
                pTargetList = pLink->LinkObjectTargets;
            }
                
            if (pTarget != NULL) {
                pTarget->NextTarget = pTargetList;
            }
            pTargetList = pTarget;
        }
        SetInNameSpace(pTarget);
    }
    if (pTargetList != NULL)
    {
        pLink->LinkObjectTargets = pTargetList;
    }

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\set.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsadmin.h>


DFSSTATUS
SetTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget)
{
    DFSSTATUS Status;

    if (IsInScript(pTarget) && IsInNameSpace(pTarget))
    {
        Status = ERROR_SUCCESS;
    }
    else if (IsInScript(pTarget))
    {
        Status = AddNewTarget( LinkOrRoot, pTarget, FirstTarget);
    }
    else if (IsInNameSpace(pTarget))
    {
        Status = DeleteTarget( LinkOrRoot, pTarget );
        // printf("Delete Target Status for %wS, %wS %x\n", LinkOrRoot, pTarget->Name, Status);
    }
    else 
    {
        printf("SetTarget: Target %wS has error!\n", pTarget->Name);
        Status = ERROR_GEN_FAILURE;
    }
    return Status;
}

DFSSTATUS
SetLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS TargetStatus = ERROR_SUCCESS;
    PTARGET_DEF pTarget;
    UNICODE_STRING LinkName;
    BOOLEAN FirstTarget = FALSE;

    if (!IsObjectInScript(pLink))
    {
        if (IsObjectInNameSpace(pLink))
        {
            Status = DeleteLink( RootNameString, pLink);
        }
        else 
        {
            printf("Set Link error! \n");
            Status = ERROR_GEN_FAILURE;
        }
    }
    else {
        if (!IsObjectInNameSpace(pLink))
        {
            AddLinks++;
            FirstTarget = TRUE;
        }
        Status = DfsCreateUnicodePathString(&LinkName, FALSE, RootNameString, pLink->LinkObjectName);
    
        if (Status == ERROR_SUCCESS)
        {
            for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
            {
                TargetStatus = SetTarget(LinkName.Buffer, pTarget, FirstTarget);
                if (TargetStatus != ERROR_SUCCESS)
                {
                    Status = ERROR_GEN_FAILURE;
                }
                FirstTarget = FALSE;
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = UpdateLinkMetaInformation( &LinkName, pLink );
            }

            DfsFreeUnicodeString(&LinkName);
        }

    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\view.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsheader.h"
#include "dfsmisc.h"
#include "dfsprefix.h"
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include "DfsAdmin.h"

DFSSTATUS
DfsView (
    LPWSTR RootName,
    FILE *Out )
{
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = -1;
    DWORD Level = 4;
    DFSSTATUS Status;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i;

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Contacting %wS for enumeration \n", RootName);
    }
    Status = NetDfsEnum( RootName, 
                         Level, 
                         PrefMaxLen, 
                         &pBuffer, 
                         &EntriesRead, 
                         &ResumeHandle);

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Enumeration for %wS is complete %d entries\n", 
               RootName, 
               EntriesRead);
    }


    if (Status != ERROR_SUCCESS)
    {
        printf("Export: cannot enum %wS: error %x\n", RootName, Status);
    }
    else {
        pCurrentBuffer = (PDFS_INFO_4)pBuffer;

        for (i = 0; i < EntriesRead; i++)
        {
            DumpDfsInfo(i, Level, pCurrentBuffer, Out);
            pCurrentBuffer++;
        }
        fwprintf(Out, L"END ROOT\n");
    }

    return Status;
}



DumpDfsInfo(
    DWORD Entry,
    DWORD Level,
    PDFS_INFO_4 pBuf,
    FILE *Out)
{
    DWORD i;
    PDFS_STORAGE_INFO pStorage;
    UNICODE_STRING LinkName, ServerName, ShareName, Remains;
    DFSSTATUS Status;

    if (Level != 4) {
        printf("Fix Dump DfsInfo for different levels\n");
        return 0;
    }

    if (Entry == 0)
    {
        fwprintf(Out, L"ROOT %ws \n", pBuf->EntryPath);

        for(i = 0, pStorage = pBuf->Storage;
            i < pBuf->NumberOfStorages;
            i++, pStorage = pBuf->Storage+i)
        {
            fwprintf(Out, L"\tTARGET \\\\%ws\\%ws\n", 
                     pStorage->ServerName, pStorage->ShareName);
        }
        fwprintf(Out, L"\n");
    }
    else 
    {
        RtlInitUnicodeString( &LinkName, pBuf->EntryPath);
        Status = DfsGetPathComponents(&LinkName,
                                      &ServerName,
                                      &ShareName,
                                      &Remains);

        fwprintf(Out, L"\tLINK \"%ws\" ", Remains.Buffer);
        if (pBuf->Comment && (pBuf->Comment[0] != 0))
        {
            printf("Comment is %ws\n", pBuf->Comment);
            fwprintf(Out, L"\tCOMMENT \"%ws\" ", pBuf->Comment);
        }
        fwprintf(Out, L"\tSTATE %x ", pBuf->State);
        if (pBuf->Timeout != 0)
        {
            fwprintf(Out, L"\tTIMEOUT %d ", pBuf->Timeout);
        }
        fwprintf(Out, L"\n");
        for(i = 0, pStorage = pBuf->Storage;
            i < pBuf->NumberOfStorages;
            i++, pStorage = pBuf->Storage+i)
        {
            fwprintf(Out, L"\t\tTARGET \\\\%ws\\%ws", 
                   pStorage->ServerName, pStorage->ShareName);
            fwprintf(Out, L"\tSTATE %x \n", pStorage->State);
        }
    }
    fwprintf(Out, L"\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\verify.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsadmin.h>


VOID
DumpLink(
    PLINK_DEF pLink )
{
    PTARGET_DEF pTarget;
    printf("Link %wS\n", pLink->LinkObjectName);

    for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
    {
        printf("\tTarget %wS\n", pTarget->Name);
    }
}


DFSSTATUS
VerifyTarget(
    PLINK_DEF pLink,
    PTARGET_DEF pTarget)
{
    if (IsInScript(pTarget) && IsInNameSpace(pTarget))
    {
        return ERROR_SUCCESS;
    }
    else if (IsInScript(pTarget))
    {
        printf("/t Target %wS for link %wS is not in the namespace\n", 
               pTarget->Name,
               pLink->LinkObjectName);
    }
    else if (IsObjectInNameSpace(pLink))
    {
        printf("/t Target %wS for link %wS is additional in the namespace\n", 
               pTarget->Name,
               pLink->LinkObjectName);
    }
    else 
    {
        printf("Script error for target %wS link %wS!\n", pTarget->Name, pLink->LinkObjectName);
    }
    return ERROR_GEN_FAILURE;
}


DFSSTATUS
VerifyLink(
    PLINK_DEF pLink)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS TargetStatus = ERROR_SUCCESS;
    PTARGET_DEF pTarget;

    if (IsObjectInScript(pLink) && IsObjectInNameSpace(pLink))
    {
        for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
        {
            TargetStatus = VerifyTarget(pLink, pTarget);
            if (TargetStatus != ERROR_SUCCESS)
            {
                Status = ERROR_GEN_FAILURE;
            }
        }

    }
    else if (IsObjectInScript(pLink))
    {
        printf("Link %wS is not in the namespace, %wS\n", pLink->LinkObjectName);
        
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    else if (IsObjectInNameSpace(pLink))
    {
        printf("Link %wS is additional in namespace %wS \n",pLink->LinkObjectName);
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    else 
    {
        printf("Script error for Link %wS \n", pLink->LinkObjectName);
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsadmin\objects.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsadmin.h"



UpdateApiCalls()
{
    if ((++ApiCalls % 500) == 0)
    {
        printf("Api calls completed: %d\n", ApiCalls);
        DumpCurrentTime();
    }
}

DFSSTATUS
AddNewRoot(
    PROOT_DEF pRoot,
    LPWSTR NameSpace,
    BOOLEAN Update )
{
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RootName;

    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;

    LPWSTR UseRootName;

    PLINK_DEF pLink;

    UseRootName = NameSpace;
    if (UseRootName == NULL)
    {
        UseRootName = pRoot->RootObjectName;
    }
    RtlInitUnicodeString(&RootName, UseRootName);

    Status = DfsGetPathComponents(&RootName,
                                  &ServerName,
                                  &ShareName,
                                  NULL );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCreateWideString(&ServerName, &ServerNameString);
    }

    if (Status == ERROR_SUCCESS) 
    {
        Status = DfsCreateWideString(&ShareName, &ShareNameString);
    }

    if (Status == ERROR_SUCCESS) 
    {
       Status = NetDfsAddStdRoot( ServerNameString, ShareNameString, NULL, 0);
       if (Status != ERROR_SUCCESS)
       {
           printf("NetDfsAddStdRoot failed: Status 0x%x, Server %wS Share %wS\n",
                  Status, ServerNameString, ShareNameString);
       }

       UpdateApiCalls();
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }

    if ((Status == ERROR_SUCCESS) ||
        ((Status == ERROR_FILE_EXISTS) && (Update == TRUE)))
    {
        for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
        {
            Status = AddNewLink( UseRootName, pLink, Update);
            if ((Status != ERROR_SUCCESS) &&
                ((Status != ERROR_FILE_EXISTS) || (Update != TRUE)))
            {
                if (DebugOut)
                {
                    fwprintf(DebugOut, L"Add link failed: Root %wS Link %wS\n", UseRootName,
                           pLink->LinkObjectName);
                }
                break;
            }
        }
    }

    return Status;
}


DFSSTATUS
AddNewLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink,
    BOOLEAN Update )
{
    UNICODE_STRING LinkName;
    DFSSTATUS Status;
    PTARGET_DEF pTarget;

    Status = DfsCreateUnicodePathString(&LinkName,
                                        0, // not unc path: no leading seperators.
                                        RootNameString,
                                        pLink->LinkObjectName);

    if (Status == ERROR_SUCCESS)
    {
//        Status = NetDfsAdd( LinkName.Buffer, NULL, NULL, NULL, DFS_ADD_VOLUME);

        UpdateApiCalls();
        if ((++AddLinks % 400) == 0)
        {
            printf("Done with %d Links %d Targets %d Api calls\n", 
                   AddLinks, AddTargets, ApiCalls );
        }
        if (Status == ERROR_SUCCESS)
        {
            for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
            {
                Status = AddNewTarget( LinkName.Buffer, pTarget, pTarget == pLink->LinkObjectTargets);
                if ((Status != ERROR_SUCCESS) &&
                ((Status != ERROR_FILE_EXISTS) || (Update != TRUE)))
                {
                    if (DebugOut)
                    {
                        fwprintf(DebugOut, L"Add target failed: Root %wS Link %wS Target %wS\n", RootNameString,
                                 pLink->LinkObjectName, 
                                 pTarget->Name);
                    }
                    break;
                }
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            Status = UpdateLinkMetaInformation(&LinkName, 
                                               pLink);
        }
        DfsFreeUnicodeString(&LinkName);
    }

    //printf("Add new link status %x\n", Status);
    return Status;
}

DWORD
UpdateLinkMetaInformation(
    PUNICODE_STRING pLinkName,
    PLINK_DEF pLink)
{
    UNREFERENCED_PARAMETER(pLinkName);
    UNREFERENCED_PARAMETER(pLink);

    return ERROR_SUCCESS;
#if 0

    DWORD Status = ERROR_SUCCESS;

    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectCommentSet(pLink))
        {
            DFS_INFO_100 Info100;

            Info100.Comment = pLink->BaseObject.Comment;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 100, (LPBYTE)&Info100);
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectStateSet(pLink))
        {
            DFS_INFO_101 Info101;

            Info101.State = pLink->BaseObject.State;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 101, (LPBYTE)&Info101);
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectTimeoutSet(pLink))
        {
            DFS_INFO_102 Info102;

            Info102.Timeout = pLink->BaseObject.Timeout;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 102, (LPBYTE)&Info102);
        }
    }
    return Status;
#endif
}

DFSSTATUS
AddNewTarget( 
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget)
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;
    ULONG Flags = 0;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING TargetName;

    if (FirstTarget)
    {
        Flags = DFS_ADD_VOLUME;
    }

    RtlInitUnicodeString(&TargetName, pTarget->Name );
    Status = DfsGetFirstComponent(&TargetName,
                                  &ServerName,
                                  &ShareName );
    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);


    if (Status == ERROR_SUCCESS) {
        Status = NetDfsAdd( LinkOrRoot, ServerNameString, ShareNameString, NULL, Flags);
        if ((Status != ERROR_SUCCESS) && (Status != ERROR_NOT_FOUND))
        {
            printf("NetDfsAdd failed: Status 0x%x, Link %wS Server %wS Share %wS Flags 0x%x\n",
                   Status, LinkOrRoot, ServerNameString, ShareNameString, Flags);
        }
        if (Status == ERROR_NOT_FOUND)
        {
            Status = NetDfsAdd( LinkOrRoot, ServerNameString, ShareNameString, NULL, DFS_ADD_VOLUME);
            if (Status != ERROR_SUCCESS)
            {
                printf("NetDfsAdd failed again!: Status 0x%x, Link %wS Server %wS Share %wS Flags 0x%x\n",
                       Status, LinkOrRoot, ServerNameString, ShareNameString, Flags);
            }
        }

        UpdateApiCalls();
    }

        

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Add new target %wS %wS %wS status %x\n", 
                 LinkOrRoot, 
                 ServerNameString, 
                 ShareNameString, 
                 Status);
    }


    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }
    AddTargets++;
    return Status;
}



DeleteRoot(
    PROOT_DEF pRoot )
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;
    
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RootName;

    RtlInitUnicodeString(&RootName, pRoot->RootObjectName);

    Status = DfsGetPathComponents(&RootName,
                                  &ServerName,
                                  &ShareName,
                                  NULL );

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);

    if (Status == ERROR_SUCCESS) 
    {
        Status = NetDfsRemoveStdRoot( ServerNameString, ShareNameString, 0);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsremovedStdRoot failed: Status 0x%x, Server %wS Share %wS\n",
                   Status, ServerNameString, ShareNameString);
        }
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Remove root %wS, Status %x\n", RootName.Buffer, Status);
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }

    return Status;
}


DeleteLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink )
{
    UNICODE_STRING LinkName;
    DFSSTATUS Status;

    Status = DfsCreateUnicodePathString(&LinkName, FALSE, RootNameString, pLink->LinkObjectName);

    if (Status == ERROR_SUCCESS)
    {
        Status = NetDfsRemove( LinkName.Buffer, NULL, NULL);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsRemove Failed 0x%x, for link %wS\n",
                   Status, LinkName.Buffer);
        }
        UpdateApiCalls();
        if (DebugOut)
        {
            fwprintf(DebugOut, L"Removed Link %wS, Status %x\n", LinkName.Buffer, Status);
        }
        DfsFreeUnicodeString(&LinkName);
    }
    RemoveLinks++;
    return Status;

}

DeleteTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget )
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING TargetName;

    RtlInitUnicodeString( &TargetName, pTarget->Name);

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetFirstComponent(&TargetName,
                                      &ServerName,
                                      &ShareName );
    }

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);
    
    if (Status == ERROR_SUCCESS) {
        Status = NetDfsRemove( LinkOrRoot, ServerNameString, ShareNameString);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsRemove Failed 0x%x, for link %wS, Server %wS Share %wS\n",
                   Status, LinkOrRoot, ServerNameString, ShareNameString);
        }

        UpdateApiCalls();
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Removed Link %wS target %wS, Status %x\n", 
                 LinkOrRoot, 
                 pTarget->Name, 
                 Status);
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }
    RemoveTargets++;
    return Status;
}



DFSSTATUS
DfsCreateWideString(
    PUNICODE_STRING pName,
    LPWSTR *pString )
{

    DFSSTATUS Status = ERROR_SUCCESS;

    *pString = malloc(pName->Length + sizeof(WCHAR));

    if (*pString != NULL)
    {
        RtlCopyMemory(*pString, pName->Buffer, pName->Length);
        (*pString)[pName->Length/sizeof(WCHAR)] = 0;
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsapi\dfsapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       Main.CXX
//
//  Contents:   Main file for DfsApi
//
//  History:    11-Mar-98	MariusB		Created
//				10-Dec-98	MariusB		Minor fixes
//				20-Nov-00	MariusB		
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "lm.h"
#include "lmdfs.h"
#include "winsock2.h"
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <excpt.h>
#include <dsgetdc.h>
#include <windef.h>
#include <winbase.h>
#include <basetsd.h>

#if !defined(DFS_STORAGE_STATE_MASTER)
#define DFS_STORAGE_STATE_MASTER   0x0010
#define DFS_STORAGE_STATE_STANDBY  0x0020
#endif

#define RETURN return

#if !defined(UNICODE) || !defined(_UNICODE)
#error For UNICODE only
#endif

#define	NOREBOOT		1
#define CHECK_ERR(x)


BOOL	bDebug = FALSE;
FILE*	fDebug = NULL;
#define	MSG	\
		if (bDebug) fprintf(fDebug, "File %s, %lu\n", __FILE__, __LINE__); \
		if (bDebug) fprintf

ULONG	Usage(LPSTR ptszAppNane);
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
#if NOREBOOT
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
#endif
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
#if 0
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
#endif
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg);
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider);
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv);
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv);
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer);
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer);
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer);
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer);
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer);
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer);
ULONG	PrintDfsInfo300(PDFS_INFO_300 pBuffer);
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pStorage);
LPTSTR	GetStringParam(LPTSTR ptszParam);

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Core function for the application.
//
//  Arguments:  [argc]    			--      The number of arguments
//				[argv]				--		The arguments
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG __cdecl main(int argc, char* argv[])
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwArgc = 0;
	LPTSTR*	pptszArgv = NULL;
	INT		i = 0;
	INT		nArgNdx = 0;

	if (argc < 2 ||
		argv[1][1]=='?' && (
		argv[1][0]=='-' ||
		argv[1][0]=='/'))
	{
		ulErr = Usage(argv[0]);
		RETURN(ulErr);
	}

	if (NULL == (pptszArgv =
		(LPTSTR*)malloc(sizeof(LPTSTR)*max(argc,32))))
	{
		_ftprintf(stderr,
				  _T("Not enough memory\n"));

		ulErr = ERROR_NOT_ENOUGH_MEMORY;

        CHECK_ERR(ulErr);
		goto Error;
	}
	memset(pptszArgv, 0, sizeof(LPTSTR)*max(argc,32));

	for (i=0; i<argc; i++)
	{
#ifdef UNICODE
		if (NULL == (pptszArgv[i] = (LPTSTR)malloc(
			sizeof(_TCHAR)*(1+strlen(argv[i])))))
		{
			_ftprintf(stderr,
					  _T("Not enough memory\n"));
	
			ulErr = ERROR_NOT_ENOUGH_MEMORY;

            CHECK_ERR(ulErr);
			goto Error;
		}

		memset(pptszArgv[i],
			   0,
			   sizeof(TCHAR)*(1+strlen(argv[i])));
		mbstowcs(pptszArgv[i], argv[i], strlen(argv[i]));
#else
		pptszArgv[i]=argv[i];
#endif
		++dwArgc;
	} //for i

	if (pptszArgv[1] == _tcsstr(pptszArgv[1], _T("/debug")))
	{
		bDebug = TRUE;
		if (_T(':') == pptszArgv[1][strlen("/debug")])
		{
			if (NULL == (fDebug =
				_tfopen(pptszArgv[1]+strlen("/debug")+1, _T("wt+"))))
			{
				fprintf(stderr, "Opening %ws failed with %lu",
						pptszArgv[1]+strlen("/debug")+1,
						errno);
			}
		} //if

		if (NULL == fDebug)
		{
			fDebug = stderr;
		} //if

		MSG(fDebug,
			"\n\nDebug report for %ws\n",
			pptszArgv[0]);
		nArgNdx++;
	} //if

    for (i=0; i<argc; i++)
    {
        MSG(fDebug,
            "\tpptszArgv[%d]==\"%ws\"\n",
            i,
            pptszArgv[i]);
    }
    MSG(fDebug,
        "\tnArgNdx==%d\n",
        nArgNdx);

	if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("add")))
	{
		ulErr = Add(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("remove")))
	{
		ulErr = Remove(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("enum")))
	{
		ulErr = Enum(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getinfo")))
	{
		ulErr = GetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setinfo")))
	{
		ulErr = SetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getclientinfo")))
	{
		ulErr = GetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setclientinfo")))
	{
		ulErr = SetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
#if NOREBOOT
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdroot")))
	{
		ulErr = AddStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removestdroot")))
	{
		ulErr = RemoveStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addftroot")))
	{
		ulErr = AddFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftroot")))
	{
		ulErr = RemoveFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftrootforced")))
	{
		ulErr = RemoveFtRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdrootforced")))
	{
		ulErr = AddStdRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getdcaddress")))
	{
		ulErr = GetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#if 0
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setdcaddress")))
	{
		ulErr = SetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetaddconnection")))
	{
		ulErr = AddConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetcancelconnection")))
	{
		ulErr = CancelConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addresstosite")))
	{
		ulErr = AddressToSite(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else
	{
		ulErr = ERROR_INVALID_PARAMETER;

        CHECK_ERR(ulErr);
		goto Error;
	}

	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	fprintf(stdout, "%ws completed successfully\n", pptszArgv[0]);
	goto Cleanup;

Error:;
	if (NULL != pptszArgv)
        {
            fprintf(stderr, "%ws failed: %lu\n", pptszArgv[0], ulErr);
        }
	goto Cleanup;

Cleanup:;
	if (NULL != pptszArgv)
	{
		DWORD	dwI = 0;

		for (dwI=0; dwI < dwArgc; dwI++)
		{
#ifdef UNICODE
			if (NULL != pptszArgv[dwI])
			{
				free(pptszArgv[dwI]);
				pptszArgv[dwI] = NULL;
			} //if
#endif
		} //for

		free(pptszArgv);
		pptszArgv = NULL;
	} //if

	if (fDebug != NULL && fDebug != stderr)
	{
		fclose(fDebug);
	}

	RETURN(ulErr);
}; //main



	
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   This function prints a help message to stderr
//
//  Arguments:  None.
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Usage(LPSTR ptszAppName)
{
	fprintf(stderr,
			"Usage: %s [/debug:[<filename>]] <command> <options>\n\n"
			"commands:\n"
			"\tadd <dfsentrypath> <server> <share> [<comment> [<options>]]\n"
			"\t    [/range:<lo>-<hi>]\n"
			"\t\toptions=add|restore\n"
			"\t\t/range works with options=add only. When /range is present\n"
			"\t\tthe command adds multiple links\n"
			"\tremove <dfsentrypath> [<server> <share>]\n"
			"\tenum <dfsname> <level> [<prefmaxlen>]\n"
			"\t\tprefmaxlen=integer greater than 0 (resume only)\n"
			"\t\tlevel=1,2,3,4,200,300\n"
			"\tgetinfo <dfsentrypath> <server> <share> <level>\n"
			"\t\tlevel=1,2,3,4,100\n"
			"\tsetinfo <dfsentrypath> <server> <share> <level> <options>\n"
			"\t\tlevel=100, options=<comment>, no <server>, <share>\n"
			"\t\tlevel=101, options=[active] [offline] [online] when <server> is not null\n"
			"\t\tlevel=101, options=ok|inconsistent|offline|online when <server> is null\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
			"\tgetclientinfo <dfsentrypath> [<server> <share>] <level>\n"
			"\t\tlevel=1,2,3,4\n"
			"\tsetclientinfo <dfsentrypath> [<server> <share>] <level> <options>\n"
			"\t\tlevel=101, options=[active] [offline] [online]\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
#if NOREBOOT
			"\taddstdroot <servername> <rootshare> [<comment> [<options>]]\n"
			"\tremovestdroot <servername> <rootshare> [<options>]\n"
			"\taddftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftrootforced <domainname> <servername> <rootshare> "
			"<ftdfsname> [<options>]\n"
			"\taddstdrootforced <servername> <rootshare> [<comment>] <store>\n"
#endif
			"\tgetdcaddress <servername>\n"
#if 0
			"\tsetdcaddress <servername> <dcipaddress> <timeout> [<flags>]\n"
#endif
			"\twnetaddconnection <level> <remotename> <password> [<localname>] [<level2params>]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, *, LPT1, etc.\n"
			"\t\tlevel2params=<type> [<provider>] [<username>] [<flags>]\n"
			"\t\ttype=disk|print|any\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\twnetcancelconnection <level> <localname> [<flags>] [force]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, etc\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\t\tforce=if present, the deletion of the connection is forced\n"
			"\n"
			"\taddresstosite <dcname> <ipaddress>\n\n"
			"To specify a NULL string in the middle of the command, use "
			"\"\".\n"
			"Example: setinfo \\\\myserver\\myentrypath \"\" \"\" "
			"100 \"My comment\".\n",
			ptszAppName);
	RETURN(ERROR_INVALID_PARAMETER);
};//Usage



	
//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   This function performs NetDfsAdd.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	ULONG	ulLo = 0;
	ULONG	ulHi = 0;
	LPTSTR	ptszVolName = NULL;
	LPTSTR	ptszRange = NULL;
	LPTSTR	ptszMinus = NULL;

	MSG(fDebug, "Entering Add(%lu,...)\n", dwArgc);
	if (dwArgc < 3 || NULL == pptszArgv || dwArgc > 6)
	{
		MSG(fDebug, "%lu < 3 || NULL == pptszArgv || %lu > 6",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (4 < dwArgc)
	{
		if (0 == _tcsicmp(pptszArgv[4], _T("add")))
		{
			dwFlags = DFS_ADD_VOLUME;
		}
		else if (0 == _tcsicmp(pptszArgv[4], _T("restore")))
		{
			dwFlags = DFS_RESTORE_VOLUME;
		}
		else
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	if (5 < dwArgc)
	{
		if (0 != _tcsnicmp(pptszArgv[5],
						   _T("/range:"),
						   _tcslen(_T("/range:"))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		ptszRange = pptszArgv[5]+_tcslen(_T("/range:"));
		if (NULL == (ptszMinus = _tcschr(ptszRange, _T('-'))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		*ptszMinus = _T('\0');
		ulLo = _ttol(ptszRange);

		*ptszMinus = _T('-');
		ulHi = _ttol(ptszMinus+1);

		if (ulLo > ulHi)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	MSG(fDebug,
		"Calling NetDfsAdd(%ws, %ws, %ws, %ws, %lu)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]), 
		GetStringParam(pptszArgv[3]),
		dwFlags);
	if (0 == ulLo && 0 == ulHi)
	{
		ulErr = NetDfsAdd(GetStringParam(pptszArgv[0]),
						  GetStringParam(pptszArgv[1]),
						  GetStringParam(pptszArgv[2]),
						  GetStringParam(pptszArgv[3]),
						  dwFlags);
	}
	else
	{
		ULONG	ulLen = 0;

		if (NULL != GetStringParam(pptszArgv[0]))
		{
			ulLen += _tcslen(GetStringParam(pptszArgv[0]));
		}

		ptszVolName = new TCHAR[ulLen+11];
		if (NULL != ptszVolName)
		{
			memset(ptszVolName, 0, (11+ulLen) * sizeof(TCHAR));
			if (NULL != GetStringParam(pptszArgv[0]))
			{
				_tcscpy(ptszVolName, GetStringParam(pptszArgv[0]));
			}

			for (ULONG i=ulLo;
				 i <= ulHi && ERROR_SUCCESS == ulErr;
				 i++)
			{
				memset(ptszVolName+ulLen, 0, sizeof(TCHAR)*11);
				_ltot(i, ptszVolName+ulLen, 10);

				ulErr = NetDfsAdd(ptszVolName,
								  GetStringParam(pptszArgv[1]),
								  GetStringParam(pptszArgv[2]),
								  GetStringParam(pptszArgv[3]),
								  dwFlags);
				MSG(fDebug,
					"NetDfsAdd(%ws, %ws, %ws, %ws, %lu) %s\n",
					ptszVolName,
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					GetStringParam(pptszArgv[3]),
					dwFlags,
					((ERROR_SUCCESS == ulErr) ? "succeded" : "failed"));
			} //for

			delete [] ptszVolName;
		}
		else
		{
			MSG(fDebug,
				"Error %lu: not enough memory\n",
				ulErr = ERROR_NOT_ENOUGH_MEMORY);
		} //else
	} //else

	MSG(fDebug, "Exiting Add(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Add



	
//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   This function performs NetDfsRemove.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug, "Entering Remove(%lu,..)\n", dwArgc);
	if (dwArgc < 1 || dwArgc > 3 || NULL == pptszArgv ||
		dwArgc > 1 && NULL == pptszArgv[1] ||
		dwArgc > 2 && NULL == pptszArgv[2] ||
		2 == dwArgc)
	{
		MSG(fDebug,
			"%lu < 1 || %lu > 3 || NULL == pptszArgv ||"
			" %lu > 1 && NULL == %ws ||"
			" %lu > 2 && NULL == %ws ||"
			" 2 == %lu",
			dwArgc, dwArgc, dwArgc, pptszArgv[1], dwArgc,
			pptszArgv[2], dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug, "Calling NetDfsRemove(%ws, %ws, %ws)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]));
	ulErr = NetDfsRemove(GetStringParam(pptszArgv[0]),
						 GetStringParam(pptszArgv[1]),
						 GetStringParam(pptszArgv[2]));

	MSG(fDebug, "Exiting Remove(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Remove



	
//+---------------------------------------------------------------------------
//
//  Function:   Enum
//
//  Synopsis:   This function performs NetDfsEnum.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	DWORD	dwPrefMaxLen = (DWORD)-1;
	LPBYTE	pBuffer = NULL;
	DWORD	dwEntriesRead = 0;
	DWORD	dwResumeHandle = 0;

	MSG(fDebug, "Entering Enum(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 ||
		NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[1], _T("1")))
	{
		dwLevel = 1;
		dwPrefMaxLen = sizeof(DFS_INFO_1);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("2")))
	{
		dwLevel = 2;
		dwPrefMaxLen = sizeof(DFS_INFO_2);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("3")))
	{
		dwLevel = 3;
		dwPrefMaxLen = sizeof(DFS_INFO_3);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("4")))
	{
		dwLevel = 4;
		dwPrefMaxLen = sizeof(DFS_INFO_4);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("200")))
	{
		dwLevel = 200;
		dwPrefMaxLen = sizeof(DFS_INFO_200);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("300")))
	{
		dwLevel = 300;
		dwPrefMaxLen = sizeof(DFS_INFO_300);
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc)
	{
		dwPrefMaxLen = (DWORD)-1;
	}
	else
	{
		if (3 != dwArgc || NULL == pptszArgv[2] ||
			0 >= _ttoi(pptszArgv[2]))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		dwPrefMaxLen *= _ttoi(pptszArgv[2]);
	}

	MSG(fDebug, "Calling NetDfsEnum(%ws,%lu,%lu,..,..,%lu)\n",
		pptszArgv[0], dwLevel, dwPrefMaxLen, dwResumeHandle);
	ulErr = NetDfsEnum(GetStringParam(pptszArgv[0]),
                       dwLevel,
					   dwPrefMaxLen,
					   &pBuffer,
					   &dwEntriesRead,
					   &dwResumeHandle);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	if ((DWORD)-1 == dwPrefMaxLen)
	{
		LPBYTE	pCurBuffer = pBuffer;
		for (DWORD i=0; i<dwEntriesRead; i++)
		{
			ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}

			switch (dwLevel)
			{
				case 1:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
					break;
				case 2:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
					break;
				case 3:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
					break;
				case 4:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
					break;
                                case 200:
                                        pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
                                        break;
                                case 300:
                                        pCurBuffer = (LPBYTE)(((PDFS_INFO_300)pCurBuffer)+1);
                                        break;
				default:
					ulErr = ERROR_INVALID_PARAMETER;
					goto Error;
			} //switch
		} //for
	}
	else
	{
		do
		{
			LPBYTE	pCurBuffer = pBuffer;
			for (DWORD i=0; i<dwEntriesRead; i++)
			{
				ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
				if (ERROR_SUCCESS != ulErr)
				{
					goto Error;
				}
	
				switch (dwLevel)
				{
					case 1:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
						break;
					case 2:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
						break;
					case 3:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
						break;
					case 4:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
						break;
					case 200:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
						break;
                                        case 300:
                                                pCurBuffer = (LPBYTE)(((PDFS_INFO_300)pCurBuffer)+1);
                                                break;

					default:
						ulErr = ERROR_INVALID_PARAMETER;
						goto Error;
				} //switch
			} //for

			if (NULL != pBuffer)
			{
				NetApiBufferFree(pBuffer);
				pBuffer = NULL;
			}

			MSG(fDebug,
				"Calling NetDfsEnum(%ws, %lu, %lu,..,..,%lu)\n",
				GetStringParam(pptszArgv[0]),
				dwLevel,
				dwPrefMaxLen,
				dwResumeHandle);
			ulErr = NetDfsEnum(
						GetStringParam(pptszArgv[0]),
						dwLevel,
						dwPrefMaxLen,
						&pBuffer,
						&dwEntriesRead,
						&dwResumeHandle);
			if (ERROR_NO_MORE_ITEMS == ulErr)
			{
				if (0 != dwEntriesRead)
				{
					continue;
				}
				else
				{
					ulErr = ERROR_SUCCESS;
					break;
				}
			} //if

			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}
		}
		while(TRUE);
	} //else

Error:;
	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug,
		"Exiting Enum with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //Enum




	
//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   This function performs NetDfsGetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug, "4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		dwLevel = 100;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Calling NetDfsGetInfo(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetInfo(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[2]),
				dwLevel,
				&pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetInfo




	
//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   This function performs NetDfsSetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug,
		"Calling SetInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		DFS_INFO_100 info;

		if (4 < dwArgc)
		{
			if (5 != dwArgc)
			{
				MSG(fDebug,
					"%ws == \"100\" && 5 != %dwArgc\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			}

			info.Comment = pptszArgv[4];
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            GetStringParam(pptszArgv[2]),
			100);
		ulErr = NetDfsSetInfo(
					GetStringParam(pptszArgv[0]),
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					100,
					(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws==\"101\" && "
					"4 < %lu && "
					"8 < %lu",
					pptszArgv[3], dwArgc, dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			if (NULL != GetStringParam(pptszArgv[1]))
			{
				if (NULL == GetStringParam(pptszArgv[2]))
				{
					MSG(fDebug,
						"4 < %lu && "
						"NULL != %ws && "
						"NULL == %ws\n",
						dwArgc, GetStringParam(pptszArgv[1]),
						GetStringParam(pptszArgv[2]));
					RETURN(ERROR_INVALID_PARAMETER);
				}

				for (i = 4; i<dwArgc; i++)
				{
					if (0 == _tcsicmp(pptszArgv[i], _T("active")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ACTIVE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_OFFLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ONLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("standby")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_STANDBY))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_VOLUME_STATE_STANDBY;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("master")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_MASTER))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_VOLUME_STATE_RESYNCHRONIZE;
					}
					else
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
				} //for i
			}
			else
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("ok")))
				{
					info.State = DFS_VOLUME_STATE_OK;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("inconsistent")))
				{
					info.State = DFS_VOLUME_STATE_INCONSISTENT;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					info.State = DFS_VOLUME_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					info.State = DFS_VOLUME_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //else
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetInfo(GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  101,
							  (LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[4],
					dwTimeout);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetInfo(
							  GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  102,
							  (LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Exiting SetInfo(..) with %lu", ulErr);
	RETURN(ulErr);
}; //SetInfo




	
//+---------------------------------------------------------------------------
//
//  Function:   GetClientInfo
//
//  Synopsis:   This function performs NetDfsGetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetClientInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Calling NetDfsGetClientInfo"
		"(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetClientInfo(
			  GetStringParam(pptszArgv[0]),
			  GetStringParam(pptszArgv[1]),
			  GetStringParam(pptszArgv[2]),
			  dwLevel,
			  &pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetClientInfo





//+---------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Synopsis:   This function performs NetDfsSetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug, "Entering SetClientInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws == \"101\" && "
					"4 < %lu && "
					"8 < %lu\n",
					pptszArgv[3],
					dwArgc,
					dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			for (i = 4; i<dwArgc; i++)
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("active")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ACTIVE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //for i
		} //if

		MSG(fDebug,
			"Calling NetDfsSetClientInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									101,
									(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		}

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;


		MSG(fDebug,
			"Calling NetDfsSetClientInfo"
			"(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									102,
									(LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Exiting SetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //SetClientInfo




#if NOREBOOT
//+---------------------------------------------------------------------------
//
//  Function:   AddStdRoot
//
//  Synopsis:   This function performs NetDfsAddStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	MSG(fDebug,
		"Calling NetDfsAddStdRoot(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsAddStdRoot(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
                GetStringParam(pptszArgv[2]),
				dwOptions);

	MSG(fDebug, "Exiting AddStdRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   RemoveStdRoot
//
//  Synopsis:   This function performs NetDfsRemoveStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 3 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || %lu > 3 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (3 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[2]);
	}

	MSG(fDebug,
		"Calling NetDfsRemoveStdRoot"
		"(%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		dwOptions);
	ulErr = NetDfsRemoveStdRoot(
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            dwOptions);

	MSG(fDebug,
		"Exiting RemoveStdRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   AddFtRoot
//
//  Synopsis:   This function performs NetDfsAddFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[4]);
	}

	MSG(fDebug,
		"Calling NetDfsAddFtRoot(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
        GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsAddFtRoot(GetStringParam(pptszArgv[0]),
							GetStringParam(pptszArgv[1]),
							GetStringParam(pptszArgv[2]),
							GetStringParam(pptszArgv[3]),
							dwOptions);

	MSG(fDebug, "Exiting AddFtRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRoot
//
//  Synopsis:   This function performs NetDfsRemoveFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || %lu > 4 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRoot"
		"(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsRemoveFtRoot(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[2]),
							   dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRootForced
//
//  Synopsis:   This function performs NetDfsRemoveFtRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || %lu > 5 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRootForced"
		"(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsRemoveFtRootForced(GetStringParam(pptszArgv[0]),
									 GetStringParam(pptszArgv[1]),
									 GetStringParam(pptszArgv[2]),
									 GetStringParam(pptszArgv[3]),
									 dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRootForced(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRootForced





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRootForced
//
//  Synopsis:   This function performs NetDfsAddStdRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsAddStdRootForced(%ws,%ws,%ws,%ws)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]));
	ulErr = NetDfsAddStdRootForced(GetStringParam(pptszArgv[0]),
								   GetStringParam(pptszArgv[1]),
								   GetStringParam(pptszArgv[2]),
								   GetStringParam(pptszArgv[3]));

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot





//+---------------------------------------------------------------------------
//
//  Function:   GetDcAddress
//
//  Synopsis:   This function performs NetDfsGetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;
	LPTSTR	ptszIpAddress = NULL;
	BOOLEAN	bIsRoot = FALSE;
	ULONG	ulTimeout = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (1 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu != 1 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsGetDcAddress(%ws,...)\n",
		GetStringParam(pptszArgv[0]));
	ulErr = NetDfsGetDcAddress(GetStringParam(pptszArgv[0]),
							   &ptszIpAddress,
							   &bIsRoot,
							   &ulTimeout);

	if (ERROR_SUCCESS == ulErr)
	{
		LPTSTR	ptszIs = bIsRoot?_T("is"):_T("is not");

		fprintf(stdout,
				"%ws %ws a Dfs server and it will be "
				"sticking to the DC having the %ws "
				"address for %lu seconds\n",
				GetStringParam(pptszArgv[0]),
				ptszIs,
				ptszIpAddress,
				ulTimeout);
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve DC address "
				"for %ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]));
	}

	if (NULL != ptszIpAddress)
	{
		NetApiBufferFree(ptszIpAddress);
	}

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetDcAddress




#if 0
//+---------------------------------------------------------------------------
//
//  Function:   SetDcAddress
//
//  Synopsis:   This function performs NetDfsSetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	ULONG	ulTimeout = 0;
	ULONG	ulFlags = 0;

	MSG(fDebug,
		"Entering SetDcAddress(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	ulTimeout = (ULONG)_ttol(GetStringParam(pptszArgv[2]));
	ulFlags = 0;

	MSG(fDebug,
		"Calling NetDfsSetDcAddress(%ws,%ws,%lu,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		ulTimeout,
		ulFlags);
	ulErr = NetDfsSetDcAddress(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   ulTimeout,
							   ulFlags);

	MSG(fDebug, "Exiting NetDfsSetDcAddress(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot
#endif	// 0
#endif	// NOREBOOT




#if 0
//+---------------------------------------------------------------------------
//
//  Function:   AddConnection
//
//  Synopsis:   This function performs WNetAddConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = AddConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = AddConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //AddConnection





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection1
//
//  Synopsis:   This function performs WNetAddConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //AddConnection1





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection2
//
//  Synopsis:   This function performs WNetAddConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG		ulErr = ERROR_SUCCESS;
	NETRESOURCE	NetResource;
	DWORD		dwFlags = 0;
	TCHAR		tszLocalName[128+1];
	ULONG		ulLocalNameLen = 128;

	MSG(fDebug,
		 "Entering AddConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 5)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}
	
	memset(tszLocalName, 0, sizeof(tszLocalName));
	ulErr = GetLocalName(tszLocalName,
						 ulLocalNameLen,
						 GetStringParam(pptszArgv[2]));
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	ulErr = GetNetResource(&NetResource,
						   GetStringParam(pptszArgv[3]),	// type
						   tszLocalName,					// localname
						   GetStringParam(pptszArgv[0]),	// remotename
						   GetStringParam(pptszArgv[4]));	// provider
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-6,
								   pptszArgv+6);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		 "Calling WNetAddConnection2(.., %ws, %ws, %lu)\n",
		 GetStringParam(pptszArgv[1]),
		 GetStringParam(pptszArgv[5]),
		 dwFlags);
	ulErr = WNetAddConnection2(&NetResource,
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[5]),
							   dwFlags);
Error:;	
	
	MSG(fDebug,
		 "Exiting AddConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //AddConnection2





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection
//
//  Synopsis:   This function performs WNetCancelConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = CancelConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = CancelConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //CancelConnection





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection1
//
//  Synopsis:   This function performs WNetCancelConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //CancelConnection1





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection2
//
//  Synopsis:   This function performs WNetCancelConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	BOOL	bForce = FALSE;

	MSG(fDebug,
		 "Entering CancelConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 0)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc	&&
		0 == _tcsicmp(_T("force"), pptszArgv[dwArgc-1]))
	{
		bForce = TRUE;
		--dwArgc;
	}
	
	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-1,
								   pptszArgv+1);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		"Calling WNetCancelConnection2(%ws, %lu, %ws)\n",
		GetStringParam(pptszArgv[0]),
		dwFlags,
		bForce ? _T("TRUE") : _T("FALSE"));
	ulErr = WNetCancelConnection2(GetStringParam(pptszArgv[0]),
								  dwFlags,
								  bForce);
	
Error:;	
	
	MSG(fDebug,
		 "Exiting CancelConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //CancelConnection2


#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetLocalName
//
//  Synopsis:   This function returns the first available letter for net 
//				use
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg)
{
	ULONG	ulErr = ERROR_SUCCESS;
	CHAR	szDrive[4];
	BOOL	bFound = FALSE;

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws)\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg);
	if (NULL != ptszArg	&&
		0 != _tcsicmp(ptszArg, _T("available")) &&
		0 != _tcsicmp(ptszArg, _T("*")))
	{
		if (ulLocalNameLen < _tcslen(ptszArg))
		{
			RETURN(ERROR_NO_SYSTEM_RESOURCES);
		}

		_tcscpy(ptszLocalName, ptszArg);
	}
	else
	{
		if (ulLocalNameLen < 2)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	szDrive[1] = ':';
	szDrive[2] = '\\';
	szDrive[3] = '\0';
	for (CHAR C='C'; !bFound && C<='Z'; C++)
	{
		ULONG	ulType = 0;

		szDrive[0] = C;
		switch (ulType = GetDriveTypeA(szDrive))
		{
			case	0:
			case	DRIVE_REMOVABLE:
			case	DRIVE_FIXED:
			case	DRIVE_REMOTE:
			case	DRIVE_CDROM:
			case	DRIVE_RAMDISK:
				MSG(fDebug,
					"%s is of type %lu\n",
					szDrive,
					ulType);
				continue;

			case	1:
				bFound = TRUE;
				break;

			default:
				ASSERT(FALSE);
		}// switch
	} //for

	if (!bFound)
	{
		ulErr = ERROR_NO_SYSTEM_RESOURCES;
	}
	else
	{
		szDrive[2] = '\0';
#ifdef	UNICODE
		mbstowcs(ptszLocalName, szDrive, ulLocalNameLen);
#else
		_strcpy(ptszLocalName, szDrive);
#endif
	}

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws) with %lu\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg,
		ulErr);
	RETURN(ulErr);
}; //GetLocalName




//+---------------------------------------------------------------------------
//
//  Function:   GetNetResource
//
//  Synopsis:   This function fils a NETRESOURCE structure out
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwType = 0;
	
	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws)\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider);
	if (NULL == pNetResource	||
		NULL == ptszType)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	memset(pNetResource, 0, sizeof(NETRESOURCE));
	if (0 == _tcsicmp(ptszType, _T("disk")))
	{
		dwType = RESOURCETYPE_DISK;
	}
	else if (0 == _tcsicmp(ptszType, _T("print")))
	{
		dwType = RESOURCETYPE_PRINT;
	}
	else if (0 == _tcsicmp(ptszType, _T("any")))
	{
		dwType = RESOURCETYPE_ANY;
	}
	else
	{
		MSG(fDebug,
			 "%ws is an invalid type\n",
			 ptszType);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	pNetResource->dwType = dwType;
	pNetResource->lpLocalName = ptszLocalName;
	pNetResource->lpRemoteName = ptszRemoteName;
	pNetResource->lpProvider = ptszProvider;

	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws) with %lu\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider,
		 ulErr);
	RETURN(ulErr);
}; //GetNetResource





//+---------------------------------------------------------------------------
//
//  Function:   GetWNetConnectionFlags
//
//  Synopsis:   This function returns flags for WNetAddConnection2
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug,
		 "Entering CWNetAddConnection2Flags(.., %lu, ..)\n",
		 dwArgc);
	if (NULL == pdwFlags	||
		NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	*pdwFlags = 0;
	for (ULONG i=0; i<dwArgc; i++)
	{
		if (0 == _tcsicmp(_T("update_profile"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_PROFILE;
		}
		else if (0 == _tcsicmp(_T("update_recent"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_RECENT;
		}
		else if (0 == _tcsicmp(_T("temporary"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_TEMPORARY;
		}
		else if (0 == _tcsicmp(_T("interactive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_INTERACTIVE;
		}
		else if (0 == _tcsicmp(_T("prompt"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_PROMPT;
		}
		else if (0 == _tcsicmp(_T("need_drive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_NEED_DRIVE;
		}
		else if (0 == _tcsicmp(_T("refcount"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REFCOUNT;
		}
		else if (0 == _tcsicmp(_T("redirect"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REDIRECT;
		}
		else if (0 == _tcsicmp(_T("localdrive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_LOCALDRIVE;
		}
		else if (0 == _tcsicmp(_T("current_media"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_CURRENT_MEDIA;
		}
		else if (0 == _tcsicmp(_T("deferred"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_DEFERRED;
		}
		else
		{
			MSG(fDebug,
				 "Error %lu: %ws is an invalid flag\n",
				 ulErr = ERROR_INVALID_PARAMETER,
				 pptszArgv[i]);
		}
	} //for

	MSG(fDebug,
		 "Exiting CWNetAddConnection2Flags(.., %lu, ..) with %lu\n",
		 dwArgc,
		 ulErr);
	RETURN(ulErr);
}; //GetWNetAddconnection2Flags



#if 0
//+---------------------------------------------------------------------------
//
//  Function:   AddressToSite
//
//  Synopsis:   This function performs DsAddressToSiteNames
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv)
{
	ULONG			ulErr = ERROR_SUCCESS;
	CString			sIp;
	CStringA		sIpA;
	ULONG			ulIP = 0;
	WSADATA			wsaData;
	PHOSTENT		pHost = NULL;
	SOCKET_ADDRESS	SocketAddress;
	SOCKADDR_IN		SockAddrIn;
	LPTSTR*			pptszSites = NULL;

	MSG(fDebug,
		"Entering AddressToSite(%lu, ...)\n",
		dwArgc);

	if (2 != dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (NULL == GetStringParam(pptszArgv[1]))
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	ulErr = sIp.Set(GetStringParam(pptszArgv[1]));
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}

	ulErr = sIpA.Set(sIp);
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}
	
	ulIP = inet_addr(sIpA.GetStringA());
	if (INADDR_NONE == ulIP)
	{
		fprintf(stderr,
				"Error %lu: invalid address %s\n",
				ulErr = ERROR_INVALID_PARAMETER,
				sIpA.GetStringA());
		RETURN(ulErr);
	}

	ulErr = WSAStartup(MAKEWORD(2,2),
					   &wsaData);
	if (ERROR_SUCCESS != ulErr)
	{
		fprintf(stderr,
				"Error %lu: cannot startup sockets",
				ulErr);
		RETURN(ulErr);
	}

	pHost = gethostbyaddr((LPCSTR)&ulIP,
						  sizeof(ulIP),
						  AF_INET);
	if (NULL == pHost)
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve host address "
				"for %ws",
				ulErr = WSAGetLastError(),
				GetStringParam(pptszArgv[1]));

		WSACleanup();
		RETURN(ulErr);
	}

	
	SockAddrIn.sin_family = pHost->h_addrtype;
	SockAddrIn.sin_port = 0;
	memcpy(&SockAddrIn.sin_addr,
		   pHost->h_addr,
		   pHost->h_length);

	SocketAddress.iSockaddrLength = sizeof(SockAddrIn);
	SocketAddress.lpSockaddr = (LPSOCKADDR)&SockAddrIn;

	ulErr = DsAddressToSiteNames(GetStringParam(pptszArgv[0]),
								 1,
								 &SocketAddress,
								 &pptszSites);
	if (ERROR_SUCCESS == ulErr && NULL != pptszSites[0])
	{
		fprintf(stdout,
				"The site of %ws on DC \\\\%ws is %ws\n",
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[0]),
				pptszSites[0]);
		NetApiBufferFree(pptszSites);
	}
	else if (ERROR_SUCCESS == ulErr && NULL == pptszSites[0])
	{
		fprintf(stdout,
				"Error %lu: address %ws is not associated "
				"to a site or it has an invalid format\n",
				ulErr = ERROR_INVALID_PARAMETER,
				GetStringParam(pptszArgv[1]));
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve site of "
				"%ws from DC \\\\%ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]));
	}

	WSACleanup();

	MSG(fDebug,
		"Exiting AddressToSite(%lu, ...) with %lu\n",
		dwArgc,
		ulErr);
	RETURN(ulErr);
};	// AddressToSite



#endif

//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo
//
//  Synopsis:   This function prints a DFS_INFO_XXX buffer out.
//
//  Arguments:  [dwLevel]	the info level
//				[pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo(%lu,..)\n",
		dwLevel);
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	switch (dwLevel)
	{
		case 1:
			ulErr = PrintDfsInfo1((PDFS_INFO_1)pBuffer);
			break;
		case 2:
			ulErr = PrintDfsInfo2((PDFS_INFO_2)pBuffer);
			break;
		case 3:
			ulErr = PrintDfsInfo3((PDFS_INFO_3)pBuffer);
			break;
		case 4:
			ulErr = PrintDfsInfo4((PDFS_INFO_4)pBuffer);
			break;
		case 200:
			ulErr = PrintDfsInfo200((PDFS_INFO_200)pBuffer);
			break;
                case 300:
                        ulErr = PrintDfsInfo300((PDFS_INFO_300)pBuffer);
                        break;

		default:
			RETURN(ERROR_INVALID_PARAMETER);		
	} //switch

	MSG(fDebug,
		"Exiting PrintDfsInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo1
//
//  Synopsis:   This function prints a DFS_INFO_1 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo1(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->EntryPath);

	MSG(fDebug,
		"Exiting PrintDfsInfo1(..) witb %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo1





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo2
//
//  Synopsis:   This function prints a DFS_INFO_2 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo2(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);

	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
        fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);

	MSG(fDebug,
		"Exiting PrintDfsInfo2(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo2





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo3
//
//  Synopsis:   This function prints a DFS_INFO_3 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo3(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);
	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo3(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo3





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo4
//
//  Synopsis:   This function prints a DFS_INFO_4 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo4(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
	fprintf(stdout, "%lus   ", pBuffer->Timeout);
	fprintf(stdout, "%lu storage(s)\n", pBuffer->NumberOfStorages);

	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo4(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo200
//
//  Synopsis:   This function prints a DFS_INFO_200 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo200(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->FtDfsName);

	MSG(fDebug,
		"Exiting PrintDfsInfo200(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4


//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo300
//
//  Synopsis:   This function prints a DFS_INFO_200 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo300(PDFS_INFO_300 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo300(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws:", pBuffer->DfsName);
        fprintf(stdout, "Flavor: %x\n", pBuffer->Flags);

	MSG(fDebug,
		"Exiting PrintDfsInfo300(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintStgInfo
//
//  Synopsis:   This function prints a DFS_STORAGE_INFO buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintStgInfo(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "\t\\\\%ws\\%ws\t",
			pBuffer->ServerName, pBuffer->ShareName);

	if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
	{
		fprintf(stdout, "online  ");

		if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
	{
		fprintf(stdout, "offline ");

		if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_ACTIVE)
	{
		fprintf(stdout, "active  ");
	}

	fprintf(stdout, "\n");

	MSG(fDebug,
		"Exiting PrintStgInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintStgInfo





//+---------------------------------------------------------------------------
//
//  Function:   GetStringParam
//
//  Synopsis:   This function receives a string and it returns the 
//				string itself if it is a "good" one (not null, not 
//				empty, etc).
//
//  Arguments:  [ptszParam]	the string to evaluate
//
//  Returns:    the string itself or NULL.
//
//	Notes:
//
//----------------------------------------------------------------------------
LPTSTR	GetStringParam(LPTSTR ptszParam)
{
	if (NULL == ptszParam ||
		_T('\0') == ptszParam[0] ||
		0 == _tcscmp(_T("\"\""), ptszParam))
	{
		return(NULL);
	}

	return(ptszParam);
}; //GetStringParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscmd\makefile.inc ===
$(O)\app.res: \
        $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        app.rc \
        app.rc2 \
        resource.h \
        sharing.ico \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscmd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_SYS_MSG_NOT_FOUND           2
#define IDI_SHARING                     100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscompat\dfscomp.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dfsComp.c

Abstract:
    dll to check compatability of existing DFS with Windows XP professional

Revision History:
    Aug. 7 2001,    Author: navjotv

--*/

#include "dfsCompCheck.hxx"

BOOL 
WINAPI 
DllMain (
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID pvReserved )
{
	 switch (dwReason) {
	 case DLL_PROCESS_ATTACH:
		 break;

	 case DLL_THREAD_ATTACH:
		 break;

	 case DLL_THREAD_DETACH:
		 break;

	 case DLL_PROCESS_DETACH:
		 break;
	 }
	 return (TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscmd\cmd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:      cmd.cxx
//
//  Contents:  Command-line operations
//
//  History:   7-May-96     BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <shlobj.h>
#include "cmd.hxx"
#include "myutil.hxx"

ULONG
DfscmdPrintf(
    PWCHAR format,
    ...);

//
//      -- create intermediate directories
//      -- don't remove if it's the last one
//      --

// This function determines where the server and share name are in a UNC path,
// and sets them to the output parameters. Note that the input parameter is
// munged in the process. E.g.:
//        input:  \\brucefo4\root\hello
//        output: \\brucefo4\0root\hello
//                  ^server   ^share
//
// FALSE is returned if it doesn't appear to be a UNC path. TRUE is returned
// if everything seems ok.

BOOL
GetServerShare(
    IN OUT PWSTR pszUncPath,
    OUT PWSTR* ppszServer,
    OUT PWSTR* ppszShare
    )
{
    appAssert(NULL != pszUncPath);

    //
    // Do a quick check that this is a UNC path
    //

    PWSTR pT;

    if (   L'\\' != pszUncPath[0]
        || L'\\' != pszUncPath[1]
        || L'\\' == pszUncPath[2] || L'\0' == pszUncPath[2]
        || (NULL == (pT = wcschr(&pszUncPath[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszServer = &pszUncPath[2];
    *pT++ = L'\0';
    *ppszShare = pT;

    appDebugOut((DEB_TRACE,
        "GetServerShare: Server: %ws, share: %ws\n",
        *ppszServer, *ppszShare));
    return TRUE;
}

// This function determines the appropriate Dfs name to pass to the NetDfs
// APIs. The input buffer is modified. E.g.:
//        input:  \\dfsname\dfsshare
//        output: \\dfsname\0dfsshare
//                  ^dfs
//
// FALSE is returned if it doesn't appear to be a dfs name. TRUE is returned
// if everything seems ok.

BOOL
GetDfs(
    IN OUT PWSTR pszDfsName,
    OUT PWSTR* ppszDfs
    )
{
    appAssert(NULL != pszDfsName);

    //
    // Do a quick check that this is a Dfs name
    //

    PWSTR pT;

    if (   L'\\' != pszDfsName[0]
        || L'\\' != pszDfsName[1]
        || L'\\' == pszDfsName[2] || L'\0' == pszDfsName[2]
        || (NULL == (pT = wcschr(&pszDfsName[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszDfs = &pszDfsName[2];

    //
    // Go to next slash or end
    //
    pT++;
    while (*pT != L'\\' && *pT != L'\0')
        pT++;

    *pT = L'\0';

    appDebugOut((DEB_TRACE,
        "GetDfs: Dfs: %ws\n",
        *ppszDfs));
    return TRUE;
}


VOID
CmdMap(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN PWSTR pszComment,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdMap(%ws, %ws, %ws)\n",
        pszDfsPath, pszUncPath, pszComment));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }


    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                pszComment,
                                (fRestore == FALSE) ?
                                    DFS_ADD_VOLUME : DFS_ADD_VOLUME | DFS_RESTORE_VOLUME);
    if (status == NERR_Success)
    {
        // Notify shell of change.

        appDebugOut((DEB_TRACE,
            "Notify shell about new path %ws\n",
            pszDfsPath));

        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszDfsPath, NULL);
    }
    else
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdUnmap(
    IN PWSTR pszDfsPath
    )
{
    appDebugOut((DEB_TRACE,"CmdUnmap(%ws)\n",
        pszDfsPath));

    //
    // Delete all the replicas, and hence the volume
    //

    HRESULT hr = S_OK;
    PDFS_INFO_3 pVolumeInfo = NULL;
    NET_API_STATUS status = NetDfsGetInfo(
                                pszDfsPath,
                                NULL,
                                NULL,
                                3,
                                (LPBYTE*)&pVolumeInfo);
    CHECK_NET_API_STATUS(status);
    if (NERR_Success == status)
    {
        // now, we have pVolumeInfo memory to delete

        for (ULONG i = 0; i < pVolumeInfo->NumberOfStorages; i++)
        {
            appDebugOut((DEB_TRACE,
                "Deleting replica %d of %d\n",
                i + 1, pVolumeInfo->NumberOfStorages));

            PDFS_STORAGE_INFO pDfsStorageInfo = &pVolumeInfo->Storage[i];

            status = NetDfsRemove(
                            pszDfsPath,
                            pDfsStorageInfo->ServerName,
                            pDfsStorageInfo->ShareName);
            if (status != NERR_Success)
            {
				DfsErrorMessage(status);
            }
        }
        NetApiBufferFree(pVolumeInfo);
    }
    else
    {
		DfsErrorMessage(status);
    }

    // Notify shell of change.

    appDebugOut((DEB_TRACE,
            "Notify shell about deleted path %ws\n",
            pszDfsPath));

    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszDfsPath, NULL);
}

VOID
CmdAdd(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdAdd(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                NULL,
                                (fRestore == FALSE) ? 0 : DFS_RESTORE_VOLUME);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRemove(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRemove(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsRemove(
                                pszDfsPath,
                                pszServer,
                                pszShare);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdView(
    IN PWSTR pszDfsName,    // of form \\dfsname\dfsshare
    IN DWORD level,
    IN BOOLEAN fBatch,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdView(%ws, %d)\n",
        pszDfsName, level));

    PWSTR pszDfs;   // of form 'dfsname'
    if (!GetDfs(pszDfsName, &pszDfs))
    {
		Usage();
    }

    DWORD entriesread;
    LPBYTE buffer;
    DWORD resumeHandle = 0;
    NET_API_STATUS status = NetDfsEnum(
                                pszDfs,
                                level,
                                0xffffffff,
                                (LPBYTE*)&buffer,
                                &entriesread,
                                &resumeHandle);
    if (status == NERR_Success)
    {
        PDFS_INFO_3 pDfsInfo = (PDFS_INFO_3)buffer;
        DWORD i, j;
        LPDFS_STORAGE_INFO pStorage;

#if DBG == 1
        appDebugOut((DEB_TRACE,"NetDfsEnum returned %d entries\n", entriesread));
        for (i = 0; i < entriesread; i++)
        {
            if (level == 1)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_1)buffer)[i]));
            }
            else if (level == 2)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_2)buffer)[i]));
            }
            else if (level == 3)
            {
                pDfsInfo = &(((PDFS_INFO_3)buffer)[i]);
            }
            else
            {
                // bug!
                break;
            }
            appDebugOut((DEB_TRACE,"\t%ws\n", pDfsInfo->EntryPath));
        }
        pDfsInfo = (PDFS_INFO_3)buffer;
#endif // DBG == 1

        if (fBatch == FALSE)
        {
            for (i = 0; i < entriesread; i++)
            {
                DfscmdPrintf(L"%ws", pDfsInfo->EntryPath);

                if (level == 1)
                {
                    DfscmdPrintf(L"\r\n");
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_1));
                    continue;
                }

                if (L'\0' != *pDfsInfo->Comment)
                {
                    // Print the comment at column 60.
                    int len = wcslen(pDfsInfo->EntryPath);
                    while (len++ < 58)
                    {
                        DfscmdPrintf(L" ");    // putchar?
                    }

                    DfscmdPrintf(L"  %ws\r\n", pDfsInfo->Comment);
                }
                else
                {
                    DfscmdPrintf(L"\r\n");
                }

                if (level == 2)
                {
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_2));
                    continue;
                }

                pStorage = pDfsInfo->Storage;

                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {
                    DfscmdPrintf(L"\t\\\\%ws\\%ws\r\n",
                        pStorage[j].ServerName,
                        pStorage[j].ShareName);
                }

                pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }
        else
        {
            DfscmdPrintf(L"REM BATCH RESTORE SCRIPT\r\n\r\n");
            for (i = 0; i < entriesread; i++)
            {
                pStorage = pDfsInfo->Storage;
    
                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {

                    if (pDfsInfo->Comment == NULL
                          ||
                        j > 0
                          || 
                        (wcslen(pDfsInfo->Comment) == 1 && pDfsInfo->Comment[0] == L' ')
                    ) {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     } else {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\" \"%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            pDfsInfo->Comment,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     }
                }
                DfscmdPrintf(L"\r\n");
                pDfsInfo = (LPDFS_INFO_3) ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }

        NetApiBufferFree( buffer );
    }
    else
    {
		DfsErrorMessage(status);
    }
}


//
// The following is copied from dfsutil code, which allows redirection of
// output to a file.
//

#define MAX_MESSAGE_BUF 4096
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR MsgBuf[MAX_MESSAGE_BUF];
CHAR AnsiBuf[MAX_ANSI_MESSAGE_BUF];

ULONG
DfscmdPrintf(
   PWCHAR format,
   ...)
{
   DWORD written;
   va_list va;

   va_start(va, format);
   wvsprintf(MsgBuf, format, va);
   written = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
   WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, written, &written, NULL);

   va_end(va);
   return written;
}
                              

#ifdef MOVERENAME

VOID
CmdMove(
    IN PWSTR pszDfsPath1,
    IN PWSTR pszDfsPath2
    )
{
    appDebugOut((DEB_TRACE,"CmdMove(%ws, %ws)\n",
        pszDfsPath1, pszDfsPath2));

    NET_API_STATUS status = NetDfsMove(
                                pszDfsPath1,
                                pszDfsPath2);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRename(
    IN PWSTR pszPath,
    IN PWSTR pszNewPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRename(%ws, %ws)\n",
        pszPath, pszNewPath));

    NET_API_STATUS status = NetDfsRename(
                                pszPath,
                                pszNewPath);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsblobanalyze\dfsblobanalyze.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "dfsheader.h"
#include "dfsmisc.h"
#include <shellapi.h>
#include <ole2.h>
#include <activeds.h>
#include <DfsServerLibrary.hxx>

#include <WinLdap.h>
#include <NtLdap.h>


#define ADBlobAttribute  L"pKT"
#define ADBlobPktGuidAttribute  L"pKTGuid"
#define ADBlobSiteRoot   L"\\SITEROOT"
#define DFS_AD_CONFIG_DATA    L"CN=Dfs-configuration, CN=System"

DFSSTATUS
DfsWriteBlobToFile( 
    PBYTE pBlob,
    ULONG BlobSize, 
    LPWSTR FileName);

// dfsdev: comment this properly.
//
LPWSTR RootDseString=L"LDAP://RootDSE";

//
// The prefix for AD path string. This is used to generate a path of
// the form "LDAP://<dcname>/CN=,...DC=,..."
//
LPWSTR LdapPrefixString=L"LDAP://";


//
// The first part of this file contains the marshalling/unmarshalling
// routines that are used by the old stores (registry and AD)
// These routines help us read a binary blob and unravel their contents.
//
// the latter part defines the common store class for all our stores.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define MTYPE_BASE_TYPE             (0x0000ffffL)

#define MTYPE_COMPOUND              (0x00000001L)
#define MTYPE_GUID                  (0x00000002L)
#define MTYPE_ULONG                 (0x00000003L)
#define MTYPE_USHORT                (0x00000004L)
#define MTYPE_PWSTR                 (0x00000005L)
#define MTYPE_UCHAR                 (0x00000006L)

#define _MCode_Base(t,s,m,i)\
    {t,offsetof(s,m),0L,0L,i}

#define _MCode_struct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND,s,m,i)

#define _MCode_pwstr(s,m)\
    _MCode_Base(MTYPE_PWSTR,s,m,NULL)

#define _MCode_ul(s,m)\
    _MCode_Base(MTYPE_ULONG,s,m,NULL)

#define _MCode_guid(s,m)\
    _MCode_Base(MTYPE_GUID,s,m,NULL)

#define _mkMarshalInfo(s, i)\
    {(ULONG)sizeof(s),(ULONG)(sizeof(i)/sizeof(MARSHAL_TYPE_INFO)),i}




typedef struct _MARSHAL_TYPE_INFO
{

    ULONG _type;                    // the type of item to be marshalled
    ULONG _off;                     // offset of item (in the struct)
    ULONG _cntsize;                 // size of counter for counted array
    ULONG _cntoff;                  // else, offset count item (in the struct)
    struct _MARSHAL_INFO * _subinfo;// if compound type, need info

} MARSHAL_TYPE_INFO, *PMARSHAL_TYPE_INFO;

typedef struct _MARSHAL_INFO
{

    ULONG _size;                    // size of item
    ULONG _typecnt;                 // number of type infos
    PMARSHAL_TYPE_INFO _typeInfo;   // type infos

} MARSHAL_INFO, *PMARSHAL_INFO;


typedef struct _DFS_NAME_INFORMATION_
{
    PVOID          pData;
    ULONG          DataSize;
    UNICODE_STRING Prefix;
    UNICODE_STRING ShortPrefix;
    GUID           VolumeId;
    ULONG          State;
    ULONG          Type;
    UNICODE_STRING Comment;
    FILETIME       PrefixTimeStamp;
    FILETIME       StateTimeStamp;
    FILETIME       CommentTimeStamp;
    ULONG          Timeout;
    ULONG          Version;
    FILETIME       LastModifiedTime;
} DFS_NAME_INFORMATION, *PDFS_NAME_INFORMATION;


//
// Defines for ReplicaState.
//
#define REPLICA_STORAGE_STATE_OFFLINE 0x1

typedef struct _DFS_REPLICA_INFORMATION__
{
    PVOID          pData;
    ULONG          DataSize;
    FILETIME       ReplicaTimeStamp;
    ULONG          ReplicaState;
    ULONG          ReplicaType;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
} DFS_REPLICA_INFORMATION, *PDFS_REPLICA_INFORMATION;

typedef struct _DFS_REPLICA_LIST_INFORMATION_
{
    PVOID          pData;
    ULONG          DataSize;
    ULONG ReplicaCount;
    DFS_REPLICA_INFORMATION *pReplicas;
} DFS_REPLICA_LIST_INFORMATION, *PDFS_REPLICA_LIST_INFORMATION;


extern MARSHAL_INFO     MiFileTime;

#define INIT_FILE_TIME_INFO()                                                \
    static MARSHAL_TYPE_INFO _MCode_FileTime[] = {                           \
        _MCode_ul(FILETIME, dwLowDateTime),                                  \
        _MCode_ul(FILETIME, dwHighDateTime),                                 \
    };                                                                       \
    MARSHAL_INFO MiFileTime = _mkMarshalInfo(FILETIME, _MCode_FileTime);


//
// Marshalling info for DFS_REPLICA_INFO structure
//

extern MARSHAL_INFO     MiDfsReplicaInfo;

#define INIT_DFS_REPLICA_INFO_MARSHAL_INFO()                                 \
    static MARSHAL_TYPE_INFO _MCode_DfsReplicaInfo[] = {                     \
        _MCode_struct(DFS_REPLICA_INFORMATION, ReplicaTimeStamp, &MiFileTime),   \
        _MCode_ul(DFS_REPLICA_INFORMATION, ReplicaState),             \
        _MCode_ul(DFS_REPLICA_INFORMATION, ReplicaType),              \
        _MCode_pwstr(DFS_REPLICA_INFORMATION, ServerName),           \
        _MCode_pwstr(DFS_REPLICA_INFORMATION, ShareName),            \
    };                                                                       \
    MARSHAL_INFO MiDfsReplicaInfo = _mkMarshalInfo(DFS_REPLICA_INFORMATION, _MCode_DfsReplicaInfo);


extern MARSHAL_INFO     MiADBlobDfsIdProperty;

#define INIT_ADBLOB_DFS_ID_PROPERTY_INFO()                                          \
    static MARSHAL_TYPE_INFO _MCode_ADBlobDfsIdProperty[] = {                       \
        _MCode_guid(DFS_NAME_INFORMATION, VolumeId),                          \
        _MCode_pwstr(DFS_NAME_INFORMATION, Prefix),                          \
        _MCode_pwstr(DFS_NAME_INFORMATION, ShortPrefix),                     \
        _MCode_ul(DFS_NAME_INFORMATION, Type),                                \
        _MCode_ul(DFS_NAME_INFORMATION, State),                               \
        _MCode_pwstr(DFS_NAME_INFORMATION, Comment),                         \
        _MCode_struct(DFS_NAME_INFORMATION, PrefixTimeStamp, &MiFileTime),    \
        _MCode_struct(DFS_NAME_INFORMATION, StateTimeStamp, &MiFileTime),     \
        _MCode_struct(DFS_NAME_INFORMATION, CommentTimeStamp, &MiFileTime),   \
        _MCode_ul(DFS_NAME_INFORMATION, Version),                             \
    };                                                                        \
    MARSHAL_INFO MiADBlobDfsIdProperty = _mkMarshalInfo(DFS_NAME_INFORMATION, _MCode_ADBlobDfsIdProperty);



DFSSTATUS
DfsLdapConnect(
    LPWSTR DCName,
    LDAP **ppLdap )
{
    LDAP *pLdap = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR DCNameToUse = NULL;
    const TCHAR * apszSubStrings[4];

    DCNameToUse = DCName;
 
    apszSubStrings[0] = DCNameToUse;

    pLdap = ldap_initW(DCNameToUse, LDAP_PORT);
    if (pLdap != NULL)
    {
        Status = ldap_set_option(pLdap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
        if (Status == LDAP_SUCCESS)
        {
            Status = ldap_bind_s(pLdap, NULL, NULL, LDAP_AUTH_SSPI);
        }
    }
    else
    {
        Status = LdapGetLastError();
        Status = LdapMapErrorToWin32(Status);
    }

    *ppLdap = pLdap;
    return Status;
}



// Initialize the common marshalling info for Registry and ADLegacy stores.
//
INIT_FILE_TIME_INFO();
INIT_DFS_REPLICA_INFO_MARSHAL_INFO();

//+-------------------------------------------------------------------------
//
//  Function:   PackGetInfo - unpacks information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              interpret the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
PackGetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackGetInformation(Info + typeInfo->_off,
                                           ppBuffer,
                                           pSizeRemaining,
                                           typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackGetULong( (PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackGetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackGetGuid( (GUID *)(Info + typeInfo->_off),
                                  ppBuffer,
                                  pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}



INIT_ADBLOB_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiADBlobDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status = STATUS_SUCCESS;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_AD_BLOB;
        }
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PackGetReplicaInformation - Unpacks the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete replica
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine expects to find "replicaCount" number of individual
//               binary streams in passed in buffer. Each stream starts with
//               the size of the stream, followed by that size of data.
//
//--------------------------------------------------------------------------

DFSSTATUS
PackGetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;


    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackGetULong( &pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );


        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because UnpackUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this unpack returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackGetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );
            //
            // We now point the buffer to the next sub-stream, which is the previos
            // stream + the size of the stream. We also set the remaining size
            // appropriately.
            //
            *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
            *pSizeRemaining -= pReplicaInfo->DataSize;

        }
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

    }

    return Status;
}

DFSSTATUS
GetSubBlob(
    PUNICODE_STRING pName,
    BYTE **ppBlobBuffer,
    PULONG  pBlobSize,
    BYTE **ppBuffer,
    PULONG pSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // ppbuffer is the main blob, and it is point to a stream at this
    // point
    // the first part is the name of the sub-blob.
    //
    Status = PackGetString( pName, (PVOID *) ppBuffer, pSize );
    if (Status == ERROR_SUCCESS)
    {
        //
        // now get the size of the sub blob.
        //
        Status = PackGetULong( pBlobSize, (PVOID *) ppBuffer, pSize );
        if (Status == ERROR_SUCCESS)
        {
            //
            // At this point the main blob is point to the sub-blob itself.
            // So copy the pointer of the main blob so we can return it
            // as the sub blob.
            //
            *ppBlobBuffer = *ppBuffer;

            //
            // update the main blob pointer to point to the next stream
            // in the blob.

            *ppBuffer = (BYTE *)*ppBuffer + *pBlobSize;
            *pSize -= *pBlobSize;
        }
    }

    return Status;
}

VOID
DumpNameInformation(
    PDFS_NAME_INFORMATION pNameInfo)
{

    printf("Name is %wZ, State %x, Type %x\n", 
           &pNameInfo->Prefix, pNameInfo->State, pNameInfo->Type );

    return;
}

VOID
DumpReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaInfo)
{
    ULONG x;
    printf("Replica Count %d\n", pReplicaInfo->ReplicaCount);

    for (x = 0; x < pReplicaInfo->ReplicaCount; x++) 
    {
        printf("Replica %x, Server %wZ Share %wZ\n",
               x,
               &pReplicaInfo->pReplicas[x].ServerName,
               &pReplicaInfo->pReplicas[x].ShareName );
    }
    return;
}

DFSSTATUS
DfsGenerateRootCN(
    LPWSTR RootName,
    LPWSTR *pRootCNName)
{
    *pRootCNName = new WCHAR[MAX_PATH];
    if (*pRootCNName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(*pRootCNName, L"CN=");
    wcscat(*pRootCNName, RootName);

    return ERROR_SUCCESS;
}


VOID
DfsCreateDN(
    OUT LPWSTR PathString,
    LPWSTR DCName,
    LPWSTR PathPrefix,
    LPWSTR *CNNames )
{
    LPWSTR *InArray = CNNames;
    LPWSTR CNName;

    //
    // If we are not adding the usual "LDAP://" string,
    // Start with a NULL so wcscat would work right.
    //
    if (PathPrefix != NULL)
    {
        wcscpy(PathString, PathPrefix);
        
    } else {
    
        *PathString = UNICODE_NULL;
    }
    
    //
    // if the dc name is specified, we want to go to a specific dc
    // add that in.
    //
    if ((DCName != NULL) && (wcslen(DCName) > 0))
    {
        wcscat(PathString, DCName);
        wcscat(PathString, L"/");
    }
    //
    // Now treat the CNNames as an array of LPWSTR and add each one of
    // the lpwstr to our path.
    //
    if (CNNames != NULL)
    {
        while ((CNName = *InArray++) != NULL) 
        {
            wcscat(PathString, CNName);
            if (*InArray != NULL)
            {
                wcscat(PathString,L",");
            }
        }
    }

    return NOTHING;
}

DFSSTATUS
DfsGenerateDfsAdNameContext(
    PUNICODE_STRING pString )

{
    IADs *pRootDseObject;
    HRESULT HResult;
    VARIANT VarDSRoot;
    DFSSTATUS Status = ERROR_SUCCESS;

    HResult = ADsGetObject( RootDseString,
                            IID_IADs,
                            (void **)&pRootDseObject );
    if (SUCCEEDED(HResult))
    {
        VariantInit( &VarDSRoot );
        // Get the Directory Object on the root DSE, to get to the server configuration
        HResult = pRootDseObject->Get(L"defaultNamingContext",&VarDSRoot);

        if (SUCCEEDED(HResult))
        {
            Status = DfsCreateUnicodeStringFromString( pString,
                                                       (LPWSTR)V_BSTR(&VarDSRoot) );
        }
        else
        {
            Status = HResult;
        }

        VariantClear(&VarDSRoot);

        pRootDseObject->Release();
    }
    else
    {
        Status = HResult;
    }

    return Status;
}



DFSSTATUS
DfsGenerateADPathString(
    IN LPWSTR DCName,
    IN LPWSTR ObjectName,
    IN LPWSTR PathPrefix,
    OUT LPOLESTR *pPathString)
{
    LPWSTR CNNames[4];
    LPWSTR DCNameToUse;
    ULONG Index;
    UNICODE_STRING ADNameContext;

    DFSSTATUS Status;
    
    *pPathString = new OLECHAR[4096];
    if (*pPathString == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = DfsGenerateDfsAdNameContext(&ADNameContext);
    if (Status == ERROR_SUCCESS)
    {
        DCNameToUse = DCName;

        Index = 0;
        if (ObjectName != NULL)
        {
            CNNames[Index++] = ObjectName;
        }
        CNNames[Index++] = DFS_AD_CONFIG_DATA;
        CNNames[Index++] = ADNameContext.Buffer;
        CNNames[Index++] = NULL;

        DfsCreateDN( *pPathString, DCNameToUse, PathPrefix, CNNames);

        DfsFreeUnicodeString(&ADNameContext);
    }
    
    //
    // Since we initialized DCName with empty string, it is benign
    // to call this, even if we did not call GetBlobDCName above.
    //
    
    return Status;
}


DFSSTATUS
UnpackBlob(
    BYTE *pBuffer,
    PULONG pLength )
{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pUseBuffer = NULL;
    ULONG BufferSize = 0;
    ULONG ObjNdx = 0;
    ULONG TotalObjects = 0;
    ULONG  BlobSize = 0;
    ULONG AD_BlobSize = 0;
    BYTE *BlobBuffer = NULL;
    UNICODE_STRING BlobName;

    pUseBuffer = pBuffer;
    BufferSize = *pLength;

#ifdef SUPW_DBG
    printf("*blobsize = 0x%x\n", BufferSize);
#endif

    //
    // Note the size of the whole blob.
    //
    AD_BlobSize = BufferSize;
    
    
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are discarding it.
    //
    Status = PackGetULong( &Discard, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if(BufferSize == 0)
    {
        goto done;
    }

    Status = PackGetULong(&TotalObjects, (PVOID *) &pUseBuffer, &BufferSize);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }

    printf("The blob has %d objects, Blob Start Address 0x%x, size 0x%x (%d bytes)\n", TotalObjects,
           pBuffer, AD_BlobSize, AD_BlobSize);

    for (ObjNdx = 0; ObjNdx < TotalObjects; ObjNdx++)
    {

        BOOLEAN FoundSite = FALSE;
        BOOLEAN FoundRoot = FALSE;
        ULONG ReplicaBlobSize;

        printf("\n\nGetting blob %d: Offset 0x%x (%d)\n", ObjNdx + 1, 
               AD_BlobSize - BufferSize,
               AD_BlobSize - BufferSize );



        Status = GetSubBlob( &BlobName,
                             &BlobBuffer,
                             &BlobSize,
                             &pUseBuffer,
                             &BufferSize );

        if (Status == ERROR_SUCCESS)
        {
            DFS_NAME_INFORMATION NameInfo;
            DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
            PVOID pBuffer = BlobBuffer;
            ULONG Size = BlobSize;


            printf("Found Blob %wZ, Size 0x%x (%d bytes), (address 0x%x)\n",
                   &BlobName, BlobSize, BlobSize, BlobBuffer);

            Status = PackGetNameInformation( &NameInfo,
                                             &pBuffer,
                                             &Size );
            if (Status == ERROR_SUCCESS)
            {
                DumpNameInformation(&NameInfo);

                Status = PackGetULong( &ReplicaBlobSize,
                                       &pBuffer,
                                       &Size );
                if (Status == ERROR_SUCCESS) 
                {
                    Status = PackGetULong( &ReplicaListInfo.ReplicaCount,
                                           &pBuffer,
                                           &ReplicaBlobSize );
                }
                if (Status == ERROR_SUCCESS) 
                {
                    ReplicaListInfo.pReplicas = new DFS_REPLICA_INFORMATION[ ReplicaListInfo.ReplicaCount ];
                    if (ReplicaListInfo.pReplicas == NULL)
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if (Status == ERROR_SUCCESS) 
                {
                    printf("Reading replica information, size 0x%x\n",
                           ReplicaBlobSize);
                    Status = PackGetReplicaInformation( &ReplicaListInfo,
                                                        &pBuffer,
                                                        &ReplicaBlobSize);

                    printf("Read replica information 0x%x\n", Status);
                    if (Status == ERROR_SUCCESS) 
                    {
                        DumpReplicaInformation(&ReplicaListInfo);
                    }
                    else
                    {
                        printf("Could not read replica information, Status 0x%x\n", Status);
                    }

                    delete [] ReplicaListInfo.pReplicas;
                }
                else
                {
                    printf("Could not read replica size information, Status 0x%x\n", Status);
                }
            }
            else
            {
                printf("Could not read name information, Status 0x%x\n", Status);
            }
        }
    }

done:
    return Status;
}

DFSSTATUS
DfsGetPktBlob(
    LDAP *pLdap,
    LPWSTR ObjectDN,
    LPWSTR FileName )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus = ERROR_SUCCESS;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject = NULL;
    PLDAP_BERVAL *pLdapPktAttr = NULL;
    LPWSTR Attributes[2];
    PBYTE pBlob;
    ULONG BlobSize;



    Status = ERROR_ACCESS_DENIED;     // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.

    Attributes[0] = ADBlobAttribute;
    Attributes[1] = NULL;


    LdapStatus = ldap_search_ext_sW( pLdap,
                                     ObjectDN,
                                     LDAP_SCOPE_BASE,
                                     L"(objectClass=*)",
                                     Attributes,
                                     0,            // attributes only
                                     NULL,         // server controls
                                     NULL,         // client controls
                                     NULL,
                                     0,            // size limit
                                     &pLdapSearchedObject);
    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapPktAttr = ldap_get_values_len( pLdap,
                                                pLdapObject,
                                                Attributes[0] );
            if (pLdapPktAttr != NULL)
            {
                pBlob = (PBYTE)pLdapPktAttr[0]->bv_val;
                BlobSize = pLdapPktAttr[0]->bv_len;

                if (FileName != NULL) 
                {
                    Status = DfsWriteBlobToFile( pBlob, BlobSize, FileName);
                }
                else
                {
                    Status = UnpackBlob( pBlob, &BlobSize );
                }

                ldap_value_free_len( pLdapPktAttr );
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}




DFSSTATUS
DfsWriteBlobToFile( 
    PBYTE pBlob,
    ULONG BlobSize, 
    LPWSTR FileName)
{
    HANDLE FileHandle;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG BytesWritten;

    FileHandle = CreateFile( FileName,
                             GENERIC_ALL,
                             FILE_SHARE_WRITE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             0);

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        Status = GetLastError();
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (WriteFile( FileHandle,
                       pBlob,
                       BlobSize,
                       &BytesWritten,
                       NULL) == TRUE)
        {
            if (BlobSize != BytesWritten) 
            {
                printf("Blob Size %d, Written %d\n", BlobSize, BytesWritten);
            }
        }
        else
        {
            Status = GetLastError();
        }
    }

    return Status;
}


DfsReadFromFile(
    LPWSTR Name )
{
    HANDLE FileHandle;
    ULONG Size, HighValue;
    BYTE *pBuffer;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG BytesRead;

    FileHandle = CreateFile( Name,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        Status = GetLastError();
    }
    if (Status == ERROR_SUCCESS) 
    {
        Size = GetFileSize( FileHandle,
                            &HighValue );
        if (Size == INVALID_FILE_SIZE)
        {
            Status = GetLastError();
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        pBuffer = new BYTE[Size];
        if (pBuffer == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (ReadFile( FileHandle,
                      pBuffer,
                      Size,
                      &BytesRead,
                      NULL ) == TRUE) 
        {
            if (Size != BytesRead) 
            {
                printf("File size %d, Read %d\n", Size, BytesRead);
            }
            Status = UnpackBlob( pBuffer,
                                 &BytesRead );
        }
        else
        {
            Status = GetLastError();
        }
    }
    return Status;
}





DfsReadFromAD( 
    LPWSTR Name,
    LPWSTR FileName )
{
    DWORD dwErr = ERROR_SUCCESS;
    LDAP *pLdap;
    LPWSTR ObjectDN;
    HRESULT Hr;
    DFSSTATUS Status;
    LPWSTR ObjectName;
    //
    //  We need to initialize the COM library for use by DfsUtil.exe
    //
    Hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    if (Hr != S_OK)
    {
        return Hr;
    }


    Status = DfsLdapConnect( NULL, &pLdap );

    printf("Ldap Connect Status 0x%x\n", Status);
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateRootCN( Name,
                                    &ObjectName );
        if (Status == ERROR_SUCCESS) {
            Status = DfsGenerateADPathString( NULL,
                                              ObjectName,
                                              NULL,
                                              &ObjectDN);
            printf("Generate path Status 0x%x\n", Status);

            if (Status == ERROR_SUCCESS) 
            {
                printf("Generated path %wS\n", ObjectDN);
                Status = DfsGetPktBlob(pLdap, ObjectDN, FileName );

                printf("Getblob Status 0x%x\n", Status);
            }
        }
    }

    CoUninitialize();

    return Status;
}


_cdecl
main(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argcw;


    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    if ( argvw == NULL ) {
        dwErr = GetLastError();
        return dwErr;
    }

    if (argcw == 2)
    {
        DfsReadFromAD(argvw[1], NULL);
    }
    else if (argcw == 3) 
    {
        DfsReadFromAD(argvw[1], argvw[2]);
    }
    else if (argcw == 4) 
    {
        DfsReadFromFile(argvw[3]);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscmd\myutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       myutil.cxx
//
//  Contents:   Helper APIs for Sharing Tool
//
//  History:    6-Jun-93   WilliamW   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     MyGetLastComponent, public
//
//  Synopsis:   Parse a string to a (prefix, last-component) pair.  Any
//              trailing text after L'.' will be ignored
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszPrefix and pszLastComponent should be pre-allocated
//
//--------------------------------------------------------------------------

VOID
MyGetLastComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszPrefix,
    OUT PWSTR pszLastComponent
    )
{
    PWSTR pszTmp     = NULL;
    PWSTR pszTmpLast = NULL;

    //
    // Manufacture the prefix part by replacing L'\\' with L'\0'
    //

    wcscpy(pszPrefix, pszStr);

    pszTmp = wcsrchr(pszPrefix, L'\\');
    if (pszTmp != NULL)
    {
        *pszTmp = L'\0';

        //
        // Extract the last component.  The L'.' part will be replaced
        // by a L'\0'
        //

        pszTmpLast = pszTmp + 1;
        pszTmp = wcsrchr(pszTmpLast, L'.');
        if (pszTmp != NULL)
        {
            //
            // Replace with a L'\0' character
            //

            *pszTmp = L'\0';
        }
        wcscpy(pszLastComponent, pszTmpLast);
    }
    else
    {
        *pszPrefix = L'\0';
        wcscpy(pszLastComponent, pszStr);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyFindLastComponent, public
//
//  Synopsis:   Parse a string to find the last component. This is different
//              from MyGetLastComponent as it doesn't copy any data, but just
//              looks for the last backslash and points one after it.
//
//  History:    21-Nov-94   BruceFo
//
//--------------------------------------------------------------------------

PWSTR
MyFindLastComponent(
    IN const WCHAR* pszStr
    )
{
    PWSTR pszTmp = wcsrchr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        return pszTmp + 1;
    }
    else
    {
        return (PWSTR)pszStr;  // cast away const
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyGetNextComponent(), public
//
//  Synopsis:   Parse a string to a (next-components, remaing-components)
//              pair.  Any
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszNextComponent and pszRemaining should be pre-allocated.
//
//--------------------------------------------------------------------------
VOID
MyGetNextComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszNextComponent,
    OUT PWSTR pszRemaining
    )
{
    PWSTR pszTmp = NULL;

    if (*pszStr == L'\0')
    {
       *pszNextComponent = *pszRemaining = L'\0';
       return;
    }

#if DBG == 1
    if (*pszStr == L'\\')
    {
        appDebugOut((DEB_IERROR,
            "WARNING: MyGetNextComponent takes a relative path as its first argument\n"));
    }
#endif // DBG == 1

    //
    // Manufacture the next component part by replacing L'\\' with L'\0'
    //

    pszTmp = wcschr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        ULONG cchNextComponent = (ULONG)(pszTmp - pszStr);
        wcsncpy(pszNextComponent, pszStr, cchNextComponent);
        pszNextComponent[cchNextComponent] = L'\0';

        //
        // Handle the remaining component.
        //

        wcscpy(pszRemaining, pszTmp + 1);
    }
    else
    {
        //
        // No remaining part, this is the last component
        //

        *pszRemaining = L'\0';

        wcscpy(pszNextComponent, pszStr);
    }
}




//+-------------------------------------------------------------------------
//
//  Method:     MyStrStr
//
//  Synopsis:   A case insensitive version of wcsstr (i.e. strstr)
//
//--------------------------------------------------------------------------
PWSTR
MyStrStr(
    IN PWSTR pszInStr,
    IN PWSTR pszInSubStr
    )
{
    if (   pszInStr == NULL
        || pszInSubStr == NULL
        || *pszInStr == L'\0'
        || *pszInSubStr == L'\0')
    {
       return NULL;
    }

    INT iSubStrLen = wcslen(pszInSubStr);
    INT iStrLen = wcslen(pszInStr);

    PWSTR pszHeadInStr = pszInStr;
    PWSTR pszTailInStr = pszInStr + iSubStrLen;

    PWSTR pszEndInStr = pszInStr + iStrLen;

    while (pszTailInStr <= pszEndInStr)
    {
        if (0 != _wcsnicmp(pszHeadInStr, pszInSubStr, iSubStrLen))
        {
            return pszHeadInStr;
        }

        pszHeadInStr++;
        pszTailInStr++;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     MyFindPostfix
//
//  Synopsis:   Match the prefix with the string. If the string doesn't have
//              the prefix, return a pointer to the string itself. If it does,
//              then check to see if the character after the prefix is a
//              backslash. If it is, return a pointer to the character
//              following the backslash. Otherwise, return a pointer to the
//              character immediately after the prefix.
//
//              Examples:
//                      string          prefix      return
//                      \foo\bar\baz    \bad        \foo\bar\baz
//                      \foo\bar\baz    \foo\bar    baz
//                      \foo\bar\baz    \f          oo\bar\baz
//
//--------------------------------------------------------------------------

PWSTR
MyFindPostfix(
    IN PWSTR pszString,
    IN PWSTR pszPrefix
    )
{
    UINT cchPrefixLen = wcslen(pszPrefix);
    if (0 == _wcsnicmp(pszString, pszPrefix, cchPrefixLen))
    {
        PWSTR pszReturn = pszString + cchPrefixLen;

        if (*pszReturn == L'\\')
        {
            //
            // skip past the leading backslash.
            //
            ++pszReturn;
        }

        return pszReturn;
    }
    else
    {
        // prefix didn't match, return argument string

//         appDebugOut((DEB_ITRACE,
//                 "No postfix of ('%ws', '%ws')\n",
//                 pszString,
//                 pszPrefix));

        return pszString;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
                "Formatmessage failed = 0x%08lx\n",
                GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance,
                   (dwMsgId >= MSG_FIRST_MESSAGE)
                        ? IDS_APP_MSG_NOT_FOUND
                        : IDS_SYS_MSG_NOT_FOUND,
                   szText,
                   ARRAYLEN(szText));

        wsprintf(pszBuffer,szText,dwMsgId);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  Arguments:
//
//  Returns:
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Same as wcsstr (find string in string), but case-insensitive
//
//  Arguments:
//
//  Returns:
//
//  History:    2-Feb-95   BruceFo   Created
//
//----------------------------------------------------------------------------

wchar_t*
wcsistr(
    const wchar_t* string1,
    const wchar_t* string2
    )
{
    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    wchar_t* s1dup = NewDup(string1);
    wchar_t* s2dup = NewDup(string2);

    wchar_t* ret = NULL;

    if (NULL != s1dup && NULL != s2dup)
    {
        _wcslwr(s1dup); // lower case everything to make case-insensitive
        _wcslwr(s2dup);
        ret = wcsstr(s1dup, s2dup);
    }

    delete[] s1dup;
    delete[] s2dup;
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   IsDfsRoot
//
//  Synopsis:   Determine if the path passed in is a Dfs root, in form only.
//              Namely, does it look like "\\machine-or-domain\share"?
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
BOOL
IsDfsRoot(
    IN LPWSTR pszRoot
    )
{
    if (NULL != pszRoot
        && pszRoot[0] == L'\\'
        && pszRoot[1] == L'\\'
        && pszRoot[2] != L'\\'	// might be null
        )
    {
        LPWSTR pszTmp = wcschr(pszRoot + 2, L'\\');
        if (pszTmp != NULL)
        {
            if (pszTmp[1] != L'\0'
                && pszTmp[1] != L'\\'
                )
            {
                // ok, we've got "\\xxx\y...."
                // Now make sure it doesn't have a fourth backslash

                pszTmp = wcschr(pszTmp + 2, L'\\');
                if (pszTmp == NULL)
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   IsDfsShare
//
//  Synopsis:   Determine if the given share on the given server is a Dfs
//              share. This actually contacts the machine.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
DWORD
IsDfsShare(
    IN LPWSTR pszServer,
    IN LPWSTR pszShare,
    OUT BOOL* pfIsDfs
    )
{
    PSHARE_INFO_1005 pshi1005;
    NET_API_STATUS ret = NetShareGetInfo(pszServer, pszShare, 1005, (LPBYTE*)&pshi1005);
    if (NERR_Success == ret)
    {
        if (pshi1005->shi1005_flags & SHI1005_FLAGS_DFS)
        {
            *pfIsDfs = TRUE;
        }
        else
        {
            appDebugOut((DEB_ITRACE,
                "%ws not a Dfs share\n",
                pszShare));
        }

        NetApiBufferFree(pshi1005);
    }
    else
    {
        // This could be an access denied.

        appDebugOut((DEB_ERROR,
            "NetShareGetInfo(NULL, %ws...) failed, 0x%08lx\n",
            pszShare,
            ret));
    }

    return ret;
}



//+-------------------------------------------------------------------------
//
//  Member:     FindDfsRoot, public
//
//  Synopsis:   Parse a string to find the Dfs root. Returns a pointer to
//
//  History:    22-Apr-96   BruceFo
//
//--------------------------------------------------------------------------

BOOL
FindDfsRoot(
    IN PWSTR pszDfsPath,
    OUT PWSTR pszDfsRoot
    )
{
    PWSTR pszTmp;
    if (NULL != pszDfsPath
        && pszDfsPath[0] == L'\\'
        && pszDfsPath[1] == L'\\'
        && pszDfsPath[2] != L'\\'
        && pszDfsPath[2] != L'\0'
        && (NULL != (pszTmp = wcschr(pszDfsPath + 3, L'\\')))
        && pszTmp[1] != L'\\'
        && pszTmp[1] != L'\0'
        )
    {
        pszTmp = wcschr(pszTmp + 2, L'\\');

        if (NULL != pszTmp)
        {
            // the thing passed in was of the form "\\xxx\yyy\..."
            int len = (int)(pszTmp - pszDfsPath);
            wcsncpy(pszDfsRoot, pszDfsPath, len);
            pszDfsRoot[len] = L'\0';
        }
        else
        {
            // the thing passed in was of the form "\\xxx\yyy"
            wcscpy(pszDfsRoot, pszDfsPath);
        }

        appDebugOut((DEB_IERROR,
            "Dfs root of %ws is %ws\n",
            pszDfsPath, pszDfsRoot));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#define MAX_MESSAGE_BUF 8192
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR szMsgBuf[MAX_MESSAGE_BUF];
CHAR  szAnsiBuf[MAX_ANSI_MESSAGE_BUF];
VOID
StatusMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
    exit(1);
}

VOID
DfsErrorMessage(
    IN NET_API_STATUS status
    )
{
    ULONG written;

    MyFormatMessage(MSG_ERROR, szMsgBuf, ARRAYLEN(szMsgBuf), status);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);


	PWSTR pszDll = L"netmsg.dll";

	HINSTANCE hinst = LoadLibrary(pszDll);
	if (NULL == hinst)
	{
    	MyFormatMessage(MSG_NO_MESSAGES, szMsgBuf, ARRAYLEN(szMsgBuf), pszDll);
	}
	else
	{
    	DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             hinst,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
		FreeLibrary(hinst);

    	if (0 == dwReturn)   // couldn't find message
    	{
			// try system messages
    		dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_SYSTEM
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
    		if (0 == dwReturn)   // couldn't find message
    		{
    			MyFormatMessage(MSG_ERROR_UNKNOWN, szMsgBuf, ARRAYLEN(szMsgBuf));
    		}
    	}
	}
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    exit(1);
}

VOID
Usage(
    VOID
    )
{
    ErrorMessage(MSG_USAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscmd\winmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:      winmain.cxx
//
//  Contents:  Main DFS Administrator file
//
//  History:   05-May-93 WilliamW    Created
//             11-Jul-95 WayneSc     Bug Fixes
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "cmd.hxx"
#include "myutil.hxx"

//
// Debug flag
//

DECLARE_INFOLEVEL(DfsAdmin)

//////////////////////////////////////////////////////////////////////////////

HINSTANCE g_hInstance;

#define MAX_ARGS 25

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main routine for the Sharing app.
//
//  History:    11-May-93 WilliamW   Created.
//              16-Sep-93 DavidMun   Added load & free of ccsvr.dll; move
//                                   InfoLevel init inside #if DBG.
//
//  The command line accepted by this program is described in message
//  MSG_USAGE, in messages.mc. In addition to that, the following options are
//  accepted in debug builds. These must preceed any retail options.
//
//  Debug options:
//      /debug
//          -- dump basic error information
//      /fulldebug
//          -- dump all error and trace information
//
//--------------------------------------------------------------------------

int APIENTRY
WinMain(
    IN HINSTANCE hInst,
    IN HINSTANCE hPrevInstance,
    IN LPSTR lpszCommandLineAnsi,
    IN int cmdShow
    )
{
    HRESULT hr;
    HACCEL  hAccel;
    MSG     msg;
    PWSTR   pszInitialDfs = NULL;
    PWSTR   pszCommandLine = GetCommandLine();  // get the unicode command line
    BOOLEAN fBatch = FALSE;
    BOOLEAN fRestore = FALSE;

    //
    // Store the current instance away.
    //

    g_hInstance = hInst;

#if DBG == 1

    DebugInitialize();

    //
    // Set debug info level
    //

    DfsAdminInfoLevel = DEB_ERROR | DEB_WARN;

    if (NULL != wcsstr(pszCommandLine, L"/debug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                ;
    }

    if (NULL != wcsstr(pszCommandLine, L"/fulldebug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                | DEB_IERROR
                | DEB_IWARN
                | DEB_ITRACE
                ;
    }

    // For some reason, the MessageBox call done for ASSRT_POPUP
    // is failing with error 2 (???), and although the assert message gets
    // printed, it doesn't break.

    DebugSetAssertLevel(ASSRT_MESSAGE | ASSRT_BREAK);

#endif

    //
    // Parse the command line. First, break everything out into separate
    // strings (kind of like argv/argc). Note that the program name doesn't
    // appear in pszCommandLine.
    //

    DWORD cArgs = 0;
    DWORD iArg;
    LPWSTR apszArgs[MAX_ARGS];

    LPWSTR pT = pszCommandLine;
    if (NULL != pT)
    {
        for (; cArgs < MAX_ARGS;)
        {
            while (L' ' == *pT || L'\t' == *pT) { pT++; }   // eat whitespace
            if (L'\0' == *pT)
            {
                break;
            }

            // We found a parameter. Find how long it is, allocate a string
            // to store it, and copy it. If the argument begins with a double
            // quote, we continue until we find the next double quote. To allow
            // double-quotes within strings, we allow these two special
            // sequences:
            //              \" => "			backslash escapes quotes
            //              \\ => \         backslash escapes backslash
            //              \x => x         backslash escapes anything!

            // First, determine the string size

            DWORD cchArg = 0;
            BOOL fQuoted = (L'"' == *pT);
            if (fQuoted)
            {
                ++pT;
            }

            // count the # of characters in the string
            LPWSTR pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        pT2 += 2;
                    }
					else
					{
                        pT2 += 1;
					}
                    ++cchArg;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    Usage();
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        Usage();
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    ++pT2;
                    ++cchArg;
                }
            }

            // allocate storage for the parameter
            LPWSTR pszNew = new WCHAR[cchArg + 1];
            if (NULL == pszNew)
            {
                ErrorMessage(MSG_OUTOFMEMORY);
            }
            LPWSTR pCopy = pszNew;

            // copy the string
            pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        ++pT2;	// skip the backslash
                    }
                    *pCopy++ = *pT2++;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    appAssert(FALSE);
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        appAssert(FALSE);
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    *pCopy++ = *pT2++;
                }
            }

            *pCopy = L'\0';
            apszArgs[cArgs++] = pszNew;
            pT = pT2;
        }

        if (cArgs >= MAX_ARGS)
        {
            Usage();
        }

        //
        // We've got the arguments parsed out now, so do something with them
        //

        iArg = 1;   // skip the first one, which is the program name

#if DBG == 1
        for (; iArg < cArgs; )
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/debug")
                || 0 == _wcsicmp(apszArgs[iArg], L"/fulldebug")
                )
            {
                ++iArg; // skip it
            }
            else
            {
                break;
            }
        }
#endif // DBG == 1

        if (iArg < cArgs)
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/help")
                || 0 == _wcsicmp(apszArgs[iArg], L"/h")
                || 0 == _wcsicmp(apszArgs[iArg], L"/?")
                || 0 == _wcsicmp(apszArgs[iArg], L"-help")
                || 0 == _wcsicmp(apszArgs[iArg], L"-h")
                || 0 == _wcsicmp(apszArgs[iArg], L"-?")
                )
            {
                Usage();
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/map"))
            {
                LPWSTR pszComment = NULL;
                if (
                    iArg + 2 > cArgs - 1
                    || iArg + 4 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else 
                        pszComment = apszArgs[iArg + 3];
                }
                if (iArg + 4 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 4], L"/restore"))
                        fRestore = TRUE;
                    else if (pszComment != NULL)
                        Usage();
                    else
                        pszComment = apszArgs[iArg + 4];
                }
                CmdMap(apszArgs[iArg + 1], apszArgs[iArg + 2], pszComment, fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/unmap"))
            {
                if (iArg + 1 != cArgs - 1)
                {
                    Usage();
                }
                CmdUnmap(apszArgs[iArg + 1]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/add"))
            {
                if (iArg + 2 > cArgs - 1
                    || iArg + 3 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else
                        Usage();
                }
                CmdAdd(apszArgs[iArg + 1], apszArgs[iArg + 2], fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/remove"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRemove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/view"))
            {
                if (   iArg + 1 > cArgs - 1
                    || iArg + 2 < cArgs - 1
                    )
                {
                    Usage();
                }
                DWORD level = 1;
                if (iArg + 2 == cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 2], L"/partial"))
                    {
                        level = 2;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/full"))
                    {
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batch"))
                    {
                        fBatch = TRUE;
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batchrestore"))
                    {
                        fBatch = TRUE;
                        fRestore = TRUE;
                        level = 3;
                    }
                    else
                    {
                        Usage();
                    }
                }
                CmdView(apszArgs[iArg + 1], level, fBatch, fRestore);
            }
#ifdef MOVERENAME
            else if (0 == _wcsicmp(apszArgs[iArg], L"/move"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdMove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/rename"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRename(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
#endif
            else
            {
                Usage();
            }
        }
		else
		{
			Usage();
		}
    }
	else
	{
    	Usage();
	}

	StatusMessage(MSG_SUCCESSFUL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsremoverp\dfsremoverp.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "rpc.h"
#include "rpcdce.h"
#include <lm.h>
#include <winsock2.h>

#include <tchar.h>                    


#define IO_REPARSE_TAG_DFS 0x8000000A
#define UNICODE_PATH_SEP  L'\\'

  
  
VOID
CloseDirectory(
    HANDLE DirHandle )
{
    NtClose( DirHandle );
}

NTSTATUS
ClearDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    REPARSE_DATA_BUFFER ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DELETE_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    
    return NtStatus;
}

NTSTATUS
OpenDirectory(
    PUNICODE_STRING pDirectoryName,
    ULONG ShareMode,
    HANDLE RelativeHandle,
    PHANDLE pOpenedHandle,
    PBOOLEAN pIsNewlyCreated )
{

    NTSTATUS                    NtStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    ACCESS_MASK                 DesiredAccess;
    PLARGE_INTEGER              AllocationSize;
    ULONG                       FileAttributes;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    IO_STATUS_BLOCK IoStatusBlock;

    AllocationSize             = NULL;
    FileAttributes             = FILE_ATTRIBUTE_NORMAL;
    CreateDisposition          = FILE_OPEN_IF;
    CreateOptions              = FILE_DIRECTORY_FILE |
                                 FILE_OPEN_REPARSE_POINT |
                                 FILE_SYNCHRONOUS_IO_NONALERT;

    DesiredAccess              = FILE_READ_DATA | 
                                 FILE_WRITE_DATA |
                                 FILE_READ_ATTRIBUTES | 
                                 FILE_WRITE_ATTRIBUTES |
                                 SYNCHRONIZE;

    InitializeObjectAttributes (
        &ObjectAttributes, 
        pDirectoryName,              //Object Name
        0,                           //Attributes
        RelativeHandle,              //Root handle
        NULL);                       //Security descriptor.

    NtStatus = NtCreateFile(pOpenedHandle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,
                            FileAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,                // EaBuffer
                            0 );                 // EaLength

    
    if ( (NtStatus == STATUS_SUCCESS)  && (pIsNewlyCreated != NULL) )
    {
        *pIsNewlyCreated = (IoStatusBlock.Information == FILE_CREATED)? TRUE : FALSE;
    }

    return NtStatus;
}

NTSTATUS
IsDirectoryReparsePoint(
    IN  HANDLE DirHandle,
    OUT PBOOLEAN pReparsePoint,
    OUT PBOOLEAN pDfsReparsePoint )
{
    NTSTATUS NtStatus;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    //we assume these are not reparse points.
    //
    *pReparsePoint = FALSE;
    *pDfsReparsePoint = FALSE;

    //
    // Query for the basic information, which has the attributes.
    //
    NtStatus = NtQueryInformationFile( DirHandle,
                                     &IoStatusBlock,
                                     (PVOID)&BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (NtStatus == STATUS_SUCCESS)
    {
        //
        // If the attributes indicate reparse point, we have a reparse
        // point directory on our hands.
        //
        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) 
        {
            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            *pReparsePoint = TRUE;
            
            NtStatus = NtQueryInformationFile( DirHandle,
                                               &IoStatusBlock,
                                               (PVOID)&FileTagInformation,
                                               sizeof(FileTagInformation),
                                               FileAttributeTagInformation );

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Checkif the tag indicates its a DFS reparse point,
                // and setup the return accordingly.
                //
                if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_DFS)
                {
                    *pDfsReparsePoint = TRUE;
                }
            }
        }
    }

    return NtStatus;
}


BOOLEAN
IsEmptyDirectory(
    HANDLE DirectoryHandle,
    PVOID pDirectoryBuffer,
    ULONG DirectoryBufferSize )
{
    NTSTATUS NtStatus;
    FILE_NAMES_INFORMATION *pFileInfo;
    ULONG NumberOfFiles = 1;
    BOOLEAN ReturnValue = FALSE;
    IO_STATUS_BLOCK     IoStatus;

    NtStatus = NtQueryDirectoryFile ( DirectoryHandle,
                                      NULL,   // no event
                                      NULL,   // no apc routine
                                      NULL,   // no apc context
                                      &IoStatus,
                                      pDirectoryBuffer,
                                      DirectoryBufferSize,
                                      FileNamesInformation,
                                      FALSE, // return single entry = false
                                      NULL,  // filename
                                      FALSE ); // restart scan = false
    if (NtStatus == ERROR_SUCCESS)
    {
        pFileInfo =  (FILE_NAMES_INFORMATION *)pDirectoryBuffer;

        while (pFileInfo->NextEntryOffset) {
            NumberOfFiles++;
            if (NumberOfFiles > 3) 
            {
                break;
            }
            pFileInfo = (FILE_NAMES_INFORMATION *)((ULONG_PTR)(pFileInfo) + 
                                                   pFileInfo->NextEntryOffset);
        }

        if (NumberOfFiles <= 2)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;
}
    
NTSTATUS
StripLastPathComponent(
    PUNICODE_STRING pPath )
{
    USHORT i = 0, j;
    NTSTATUS Status = STATUS_SUCCESS;


    if (pPath->Length == 0)
    {
        return Status;
    }
    for( i = (pPath->Length - 1)/ sizeof(WCHAR); i != 0; i--) {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j != 0; j--){
        if (pPath->Buffer[j] == UNICODE_PATH_SEP) {
            break;
        }
    }

    pPath->Length = (j) * sizeof(WCHAR);
    return Status;
}

NTSTATUS
DeleteLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle )
{
    UNICODE_STRING DirectoryToDelete = *pLinkName;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE CurrentDirectory = NULL;
    ULONG ShareMode = 0;

    ShareMode =  FILE_SHARE_READ;
    //
    // dfsdev: fix this fixed size limit. it will hurt us in the future.
    //
    ULONG DirectoryBufferSize = 4096;
    PBYTE pDirectoryBuffer = new BYTE [DirectoryBufferSize];

    if (pDirectoryBuffer == NULL)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    while ( (NtStatus == STATUS_SUCCESS) && (DirectoryToDelete.Length != 0) )
    {
        NtStatus = OpenDirectory( &DirectoryToDelete,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  NULL );
        if (NtStatus == ERROR_SUCCESS)
        {
            if (IsEmptyDirectory(CurrentDirectory,
                                 pDirectoryBuffer,
                                 DirectoryBufferSize) == FALSE)
            {
                CloseDirectory( CurrentDirectory );

                break;
            }

            CloseDirectory( CurrentDirectory );
            InitializeObjectAttributes (
                &ObjectAttributes,
                &DirectoryToDelete,
                0,
                RelativeHandle,
                NULL);

            NtStatus = NtDeleteFile( &ObjectAttributes );

            StripLastPathComponent( &DirectoryToDelete );
        }
    }

    if (pDirectoryBuffer != NULL)
    {
        delete [] pDirectoryBuffer;
    }
    return NtStatus;
}


NTSTATUS
DeleteLinkReparsePoint( 
    PUNICODE_STRING pDirectoryName,
    HANDLE ParentHandle )
{
    NTSTATUS NtStatus;
    HANDLE LinkDirectoryHandle;
    BOOLEAN IsReparsePoint, IsDfsReparsePoint;

    NtStatus = OpenDirectory( pDirectoryName,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              ParentHandle,
                              &LinkDirectoryHandle,
                              NULL );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = IsDirectoryReparsePoint( LinkDirectoryHandle,
                                            &IsReparsePoint,
                                            &IsDfsReparsePoint );

        if ((NtStatus == STATUS_SUCCESS) && 
            (IsDfsReparsePoint == TRUE) )
        {

            NtStatus = ClearDfsReparsePoint( LinkDirectoryHandle );

            wprintf(L"ClearDfsReparsePoint for %s returned %x\n", pDirectoryName->Buffer, NtStatus);
        }
        else if(NtStatus != STATUS_SUCCESS)
        {
            NtStatus = RtlNtStatusToDosError(NtStatus);
            wprintf(L"Clearing DFS reparse point for %s failed %x\n", pDirectoryName->Buffer);
        }
        else if(IsDfsReparsePoint == FALSE)
        {
            wprintf(L"%s does not have a DFS reparse point %x\n", pDirectoryName->Buffer);
        }

        NtClose( LinkDirectoryHandle );
    }
    else
    {
       NtStatus = RtlNtStatusToDosError(NtStatus);
        wprintf(L"Open for %s returned %x\n", pDirectoryName->Buffer, NtStatus);
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DeleteLinkDirectories( pDirectoryName,
                                         NULL);
    }

    return NtStatus;

}

void
_cdecl
_tmain(int argc, LPWSTR *argv[])
{
  DWORD Status = 0;
  DWORD BuffLen = 0;
  LPWSTR lpExistingFileName = NULL;
  UNICODE_STRING UnicodeFileName;

  if(argc == 1)
  {
	  wprintf(L"Usage: DfsRemoverp [Dir]\n");
	  ExitProcess (0);
  }

  BuffLen = (wcslen(L"\\??\\") + 1) * sizeof(WCHAR);
  BuffLen += ((wcslen((const wchar_t *)argv[1])  + 1)* sizeof(WCHAR));


  lpExistingFileName = (LPWSTR)HeapAlloc (GetProcessHeap(), 0, BuffLen);
  if(lpExistingFileName == NULL)
  {
	  wprintf(L"Out of memory\n");
	  ExitProcess (0);
  }

  wcscpy(lpExistingFileName, L"\\??\\");
  wcscat(lpExistingFileName, (const wchar_t *) argv[1]); 

  UnicodeFileName.Buffer = lpExistingFileName ;
  UnicodeFileName.Length = wcslen(lpExistingFileName) * sizeof(WCHAR);
  UnicodeFileName.MaximumLength = UnicodeFileName.Length;


   wprintf(L"getting rid of reparse point for %s\n", UnicodeFileName.Buffer);
   
   Status = DeleteLinkReparsePoint( &UnicodeFileName,
                                    NULL);

   HeapFree(GetProcessHeap(), 0, lpExistingFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfscompat\dfscompcheck.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       dfsCompCheck.c
//
//  Contents:   Checks if the existing DFS root is compatible with Windows XP server.
//
//  History:    Aug. 8 2001,   Author: navjotv,	some code picked up from other dfs source code files.
//              
//
//-----------------------------------------------------------------------------
#include "dfsCompCheck.hxx"

BOOLEAN
IsNTFS(
	PFILE_FS_ATTRIBUTE_INFORMATION pInfo);


LPWSTR DfsOldStandaloneChild = L"domainroot";
LPWSTR DfsOldRegistryLocation = L"SOFTWARE\\Microsoft\\DfsHost\\volumes";
LPWSTR DfsLogicalShareValueName = L"LogicalShare";
LPWSTR DfsRootShareValueName = L"RootShare";

//+-------------------------------------------------------------------------
//
//  Function:   CompatibilityCheck
//
//  Arguments:  CompatibilityCallback - function to call if a compatibility problem is found
//				Context
//
//  Returns:    TRUE on success
//              FALSE otherwise
//
//
//  Description: Check if existing DFS root will be supported after system upgarde.
//
//--------------------------------------------------------------------------
BOOLEAN
APIENTRY
CompatibilityCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback, LPVOID Context)
{
	DFSSTATUS	   					Status = ERROR_SUCCESS;
	NTSTATUS                   		NtStatus = STATUS_SUCCESS;
	HKEY							OldStandaloneDfsKey;
	BOOLEAN							MachineContacted = FALSE;
    ULONG							pAttribInfoSize;
	PFILE_FS_ATTRIBUTE_INFORMATION	pAttribInfo = NULL;
	OBJECT_ATTRIBUTES           	ObjectAttributes;
    IO_STATUS_BLOCK             	IoStatusBlock;
	UNICODE_STRING             		DirectoryName;
	HANDLE                      	DirHandle = NULL;
	UNICODE_STRING					PhysicalShare;
	BOOLEAN							ReturnVal = FALSE;
	COMPATIBILITY_ENTRY				CompEntry;

	CompEntry.Description = L"The current DFS root hosted on this server will not be supported after this system upgrade";
	CompEntry.HtmlName = L"compdata\\dfsComp.htm";
	CompEntry.TextName = L"compdata\\dfsComp.txt";
	CompEntry.RegKeyName = NULL;
	CompEntry.RegValName = NULL;
	CompEntry.RegValDataSize = NULL;
	CompEntry.RegValData = NULL;
	CompEntry.SaveValue = NULL;
	CompEntry.Flags = 0x00000000;
	CompEntry.InfName = NULL;
	CompEntry.InfSection = NULL;

	printf("\n dfsCompCheck:: Entering CompatibilityCheck");



	Status = GetOldDfsRegistryKey( L"",
                                          FALSE,
                                          &MachineContacted,
                                          &OldStandaloneDfsKey );
	
	// If we cn open this registry key, then we know that this machine
	//has old style DFS.

	if (Status == ERROR_SUCCESS)
	{
		
		Status = GetRootPhysicalShare(OldStandaloneDfsKey,
									   &PhysicalShare);

		
		if (Status == ERROR_SUCCESS)
		{

			Status = DfsGetSharePath(L"",
									PhysicalShare.Buffer,
									&DirectoryName);
		
			if ( (DirectoryName.Buffer == NULL) ||
				(DirectoryName.Length == 0) )
			{
					Status = ERROR_INVALID_PARAMETER;
			}

			ReleaseRootPhysicalShare(&PhysicalShare);

			if (Status == ERROR_SUCCESS)
			{
			
			//why MAX_PATH??

				pAttribInfoSize = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH;
				pAttribInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) new BYTE [pAttribInfoSize];
	
				if (pAttribInfo != NULL)
				{
					InitializeObjectAttributes ( &ObjectAttributes, 
											 &DirectoryName,
											 OBJ_CASE_INSENSITIVE,  //Attributes
											 NULL,                  //Root handle
											 NULL );                //Security descriptor.

	
					NtStatus = NtOpenFile( &DirHandle,
									   (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
									   &ObjectAttributes,
									   &IoStatusBlock,
									   FILE_SHARE_READ | FILE_SHARE_WRITE,
									   FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT );
                    
					
					if (NtStatus == STATUS_SUCCESS)
					{

						//
						// Query for the basic information, which has the attributes.
						//
						NtStatus = NtQueryVolumeInformationFile( DirHandle,
															   &IoStatusBlock,
															   pAttribInfo,
															   pAttribInfoSize,
															   FileFsAttributeInformation );
						
						if (NtStatus == STATUS_SUCCESS)
						{
							//
							// If the attributes indicate reparse point, we have a reparse
							// point directory on our hands.
							//
							if ( (pAttribInfo->FileSystemAttributes & FILE_SUPPORTS_REPARSE_POINTS) == 0
								 && !IsNTFS(pAttribInfo))
							{
								NtStatus = STATUS_NOT_SUPPORTED;
                              
							  CompatibilityCallback(&CompEntry, Context);
							  ReturnVal = FALSE;
							
							}
							else 
							{
								ReturnVal = TRUE;
							}
						}
						
						CloseHandle (DirHandle);
						
						delete [] pAttribInfo;
					}

	
				}
			}
			
		}
		
	}
	else
	{
		//Does not have old DFS
		ReturnVal = TRUE; 
	}

	return ReturnVal;

}

//+-------------------------------------------------------------------------
//
//  Function:   GetOldStandaloneRegistryKey
//
//  Arguments:    
//
//  Returns:   SUCCESS or error
//
//  Description: Checks if Old Standalone DFS registry key exists.
// 				 
//
//--------------------------------------------------------------------------

static
DFSSTATUS 
GetOldStandaloneRegistryKey( IN LPWSTR MachineName,
							 BOOLEAN WritePermission,
							 OUT BOOLEAN *pMachineContacted,
							 OUT PHKEY pDfsRegKey )
{
	DFSSTATUS Status;
	HKEY DfsKey;

	Status =  GetOldDfsRegistryKey (MachineName,
									WritePermission,
									pMachineContacted,
									&DfsKey );
	if (Status == ERROR_SUCCESS)
	{
		Status = RegOpenKeyEx( DfsKey,
							   DfsOldStandaloneChild,
							   0,
							   KEY_READ | (WritePermission ? KEY_WRITE : 0),
							   pDfsRegKey );
		RegCloseKey( DfsKey);
	}
	return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetOldDfsRegistryKey
//
//  Arguments:    
//
//  Returns:   SUCCESS or error
//
//  Description: Checks if Old DFS registry key exists.
// 				 
//
//--------------------------------------------------------------------------

static
DFSSTATUS 
GetOldDfsRegistryKey( IN LPWSTR MachineName,
					  BOOLEAN WritePermission,
					  OUT BOOLEAN *pMachineContacted,
					  OUT PHKEY pDfsRegKey )
{
	return GetDfsRegistryKey (MachineName,
							  DfsOldRegistryLocation,
							  WritePermission,
							  pMachineContacted,
							  pDfsRegKey );
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDfsRegistryKey
//
//  Arguments:    
//
//  Returns:   SUCCESS or error
//
//  Description: 
// 				Function GetDfsRegistryKey: This function takes a Name as the input,
// 				and looks up all DFS roots in that namespace.
//
//--------------------------------------------------------------------------


static
DFSSTATUS 
GetDfsRegistryKey( IN LPWSTR MachineName,
				   IN LPWSTR LocationString,
				   BOOLEAN WritePermission,
				   OUT BOOLEAN *pMachineContacted,
				   OUT PHKEY pDfsRegKey )
{
	DFSSTATUS Status;
	HKEY RootKey;
	BOOLEAN Contacted = FALSE;
	LPWSTR UseMachineName = NULL;
	REGSAM DesiredAccess = KEY_READ;

	if (WritePermission == TRUE)
	{
		DesiredAccess |= KEY_WRITE;
	}

	if (IsEmptyString(MachineName) == FALSE) {
		UseMachineName = MachineName;
	}

	Status = RegConnectRegistry( UseMachineName,
								 HKEY_LOCAL_MACHINE,
								 &RootKey );

	if ( Status == ERROR_SUCCESS )
	{
		Contacted = TRUE;

		Status = RegOpenKeyEx( RootKey,
							   LocationString,
							   0,
							   DesiredAccess,
							   pDfsRegKey );

		//
		// There appears to be a bug in the registry code. When
		// we connect to the local machine, the key that is returned
		// in the RegConnectRegistry is HKEY_LOCAL_MACHINE. If we
		// then attempt to close it here, it affects other threads
		// that are using this code: they get STATUS_INVALID_HANDLE
		// in some cases. So, dont close the key if it is
		// HKEY_LOCAL_MACHINE.
		//

		if (RootKey != HKEY_LOCAL_MACHINE)
		{
			RegCloseKey( RootKey );
		}
	} 

	if (pMachineContacted != NULL)
	{
		*pMachineContacted = Contacted;
	}
	return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetRootPhysicalShare
//
//  Arguments:    
//
//  Returns:   SUCCESS or error
//
//  Description: Gets the value of the DFS root share
// 				 
//
//--------------------------------------------------------------------------


DFSSTATUS
GetRootPhysicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootPhysicalShare )
{
    DFSSTATUS Status;
    ULONG DataSize, DataType;
    LPWSTR DfsRootShare = NULL;

    Status = RegQueryInfoKey( RootKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        DfsRootShare = (LPWSTR) new BYTE [DataSize];
        if ( DfsRootShare == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( RootKey,
                                      DfsRootShareValueName,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)DfsRootShare,
                                      &DataSize );
        }
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (DataType == REG_SZ)
        {
            RtlInitUnicodeString( pRootPhysicalShare, DfsRootShare );
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        if (DfsRootShare != NULL)
        {
            delete [] DfsRootShare;
        }
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseRootPhysicalShare
//
//  Arguments:    
//
//  Returns:   
//
//  Description: Releases memory for pRootPhysicalShare->Buffer.
// 				 
//
//--------------------------------------------------------------------------


VOID
ReleaseRootPhysicalShare(
    PUNICODE_STRING pRootPhysicalShare )
{
    delete [] pRootPhysicalShare->Buffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetSharePath
//
//  Arguments:  ServerName - the name of the server
//              ShareName - the name of the share
//              pPathName - the unicode string representing the NT name
//                          of the local path representing the share
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a servername and a sharename, and
//               returns an NT pathname to the physical resource that is
//               backing the share name.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetSharePath( 
    IN  LPWSTR ServerName,
    IN  LPWSTR ShareName,
    OUT PUNICODE_STRING pPathName )
{
    LPWSTR UseServerName = NULL;
    ULONG InfoLevel = 2;
    PSHARE_INFO_2 pShareInfo;
    NET_API_STATUS NetStatus;
    DFSSTATUS Status;
    UNICODE_STRING NtSharePath;

    if (IsEmptyString(ServerName) == FALSE)
    {
        UseServerName = ServerName;
    }

    NetStatus = NetShareGetInfo( UseServerName,
                                 ShareName,
                                 InfoLevel,
                                 (LPBYTE *)&pShareInfo );
    if (NetStatus != ERROR_SUCCESS)
    {
        Status = (DFSSTATUS)NetStatus;
        return Status;
    }

    if( RtlDosPathNameToNtPathName_U(pShareInfo->shi2_path,
                                     &NtSharePath,
                                     NULL,
                                     NULL ) == TRUE )
    {
        Status = DfsCreateUnicodeString( pPathName,
                                         &NtSharePath );

        RtlFreeUnicodeString( &NtSharePath );
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    NetApiBufferFree( pShareInfo );
    
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodeString
//
//  Arguments:    pDest - the destination unicode string
//                pSrc - the source unicode string
//
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a new unicode string that is a copy
//               of the original. The copied unicode string has a buffer
//               that is null terminated, so the buffer can be used as a
//               normal string if necessary.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodeString( 
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc ) 
{
    LPWSTR NewString;

    NewString = (LPWSTR) malloc(pSrc->Length + sizeof(WCHAR));
    if ( NewString == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory( NewString, pSrc->Buffer, pSrc->Length);
    NewString[ pSrc->Length / sizeof(WCHAR)] = UNICODE_NULL;

    RtlInitUnicodeString( pDest, NewString );

    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsNTFS
//
//  Arguments:    pInfo
//
//  Returns:   True - if NTFS
//			   False - if not NTFS	
//
//  Description: Checks if filesystem is NTFS
//
//--------------------------------------------------------------------------

BOOLEAN
IsNTFS(
	PFILE_FS_ATTRIBUTE_INFORMATION pInfo)
{
	if (pInfo->FileSystemNameLength == 8 &&
        pInfo->FileSystemName[0] == 'N' &&
        pInfo->FileSystemName[1] == 'T' &&
        pInfo->FileSystemName[2] == 'F' &&
        pInfo->FileSystemName[3] == 'S') 
		return TRUE;
	else
		return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsreparse\dfsenum.cxx ===
#include "std.hxx"

#define IO_REPARSE_TAG_DFS 0x8000000A

class CException
{
protected:
    CException(
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        const DWORD  dwLine) :
            m_pcszDescription(pcszDescription),
            m_pcszFile(pcszFile),
            m_dwLine(dwLine) {}
public:
    PCTSTR GetDescription()  { return m_pcszDescription; }
    PCTSTR GetFile()         { return m_pcszFile; }
    DWORD  GetLine()         { return m_dwLine; }

    virtual void Throw() = 0;
protected:
    PCTSTR m_pcszDescription;
    PCTSTR m_pcszFile;
    DWORD  m_dwLine;
};


class CMemoryException : public CException
{
public:
    CMemoryException(
        DWORD  dwSize,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwSize(dwSize) {}
public:
    DWORD  GetSize() { return m_dwSize; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwSize;
};


class CApiException : public CException
{
public:
    CApiException(
        DWORD  dwGleCode,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwGleCode(dwGleCode) {}
public:
    DWORD  GetError() { return m_dwGleCode; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwGleCode;
};


#define THROW_API_EXCEPTION(description) \
    throw CApiException(                 \
        GetLastError(),                  \
        description,                     \
        _T(__FILE__),                    \
        __LINE__)



void CountReparsePoints(PCTSTR pcszInput);
void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir);
HANDLE xOpenReparseIndex(PCTSTR pcszVolume);
BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo);
HANDLE xOpenVolume(PCTSTR pcszVolume);
void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId);


extern "C"
void __cdecl _tmain(int argc, PTSTR argv[], PTSTR envv[])
{
    if (argc==2)
    {
        CountReparsePoints(
                argv[1]);
    }
    else
    {
        _tprintf(
            _T("dfsreparse: Enumerates and lists all DFS directories on a given volume.\n")
            _T("Usage: dfsreparse <location>"));
    }
}


void CountReparsePoints(PCTSTR pcszInput)
{
    PTSTR pszVolume = NULL;
    DWORD dwCount = 0;
    HANDLE hIndex = INVALID_HANDLE_VALUE;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    FILE_REPARSE_POINT_INFORMATION ReparseInfo;
    try
    {
        xGetRootDirectory(
            pcszInput,
            &pszVolume);

        hIndex = xOpenReparseIndex(
            pszVolume);

        hVolume = xOpenVolume(
            pszVolume);

        BOOL fDone = xGetNextReparseRecord(
            hIndex,
            &ReparseInfo);

        while (!fDone)
        {
            if (IO_REPARSE_TAG_DFS == ReparseInfo.Tag)
            {
                dwCount++;
                DisplayFileName(
                    pszVolume,
                    hVolume,
                    ReparseInfo.FileReference);
            }
            fDone = xGetNextReparseRecord(
                hIndex,
                &ReparseInfo);

        }

        CloseHandle(hIndex);
        hIndex = INVALID_HANDLE_VALUE;

        _tprintf(
            _T("This volume (%s) contains %u DFS Directories.\n"),
            pszVolume,
            dwCount);
    }
    catch (CApiException& e)
    {
        _tprintf(
            _T("Failure: %s\nFile:    %s\nLine:    %u\nError:   %u"),
            e.GetDescription(),
            e.GetFile(),
            e.GetLine(),
            e.GetError());
    }
    catch (CMemoryException& e)
    {
        _tprintf(
            _T("Out of memory.\n"));
    }

    if (hIndex!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hIndex);
    }
    if (hVolume!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hVolume);
    }
    delete []pszVolume;
}


void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir)
{
    DWORD dwBufferSize = MAX_PATH;
    PTSTR pszTemp;

    *pszRootDir = NULL;

    BOOL bResult;
    DWORD dwGleCode;

    do
    {
        pszTemp = new TCHAR[dwBufferSize];
        bResult = GetVolumePathName(
            pcszInput,
            pszTemp,
            dwBufferSize);

        if (!bResult)
        {
            delete []pszTemp;
            dwGleCode = GetLastError();
            if (ERROR_BUFFER_OVERFLOW==dwGleCode)
            {
                dwBufferSize *= 2;
            }
            else
            {
                THROW_API_EXCEPTION(_T("GetVolumePathName failed."));
            }
        }
    } while (!bResult);
    *pszRootDir = pszTemp;
}


HANDLE xOpenReparseIndex(PCTSTR pcszVolume)
{
    HANDLE hReparseIndex;
    PTSTR pszReparseIndex = NULL;

    pszReparseIndex = new TCHAR[_tcslen(pcszVolume)+64];
    _tcscpy(
        pszReparseIndex,
        pcszVolume);
    PathAddBackslash(pszReparseIndex);
    _tcscat(
        pszReparseIndex,
        _T("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

   hReparseIndex = CreateFile(
       pszReparseIndex,
       GENERIC_READ,
       FILE_SHARE_READ,
       NULL,
       OPEN_EXISTING,
       FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
       NULL);

   delete []pszReparseIndex;

   if (INVALID_HANDLE_VALUE == hReparseIndex)
   {
       THROW_API_EXCEPTION(_T("Unable to open reparse index."));
   }

   return hReparseIndex;
}


HANDLE xOpenVolume(PCTSTR pcszVolume)
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    PTSTR pszVolumeName = NULL;

    pszVolumeName = new TCHAR[MAX_PATH];

    BOOL bResult = GetVolumeNameForVolumeMountPoint(
        pcszVolume,
        pszVolumeName,
        MAX_PATH);

    if (bResult)
    {
        hVolume = CreateFile(
            pszVolumeName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
            NULL);
    }

    delete []pszVolumeName;

    if (INVALID_HANDLE_VALUE == hVolume)
    {
        THROW_API_EXCEPTION(_T("Unable to open volume."));
    }

   return hVolume;
}


BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS status = NtQueryDirectoryFile(hIndex,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        ReparseInfo,
        sizeof(FILE_REPARSE_POINT_INFORMATION),
        FileReparsePointInformation,
        TRUE,
        NULL,
        FALSE);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            THROW_API_EXCEPTION(_T("Unable to open reparse index."));
        }
        bResult = TRUE;
    }

    return bResult;
}


void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId)
{
    UNICODE_STRING          usIdString;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK         IoStatusBlock;

    struct {
        FILE_NAME_INFORMATION   FileInformation;
        WCHAR                   FileName[MAX_PATH];
    } NameFile;

    ZeroMemory(
        &NameFile,
        sizeof(NameFile));

    usIdString.Length = sizeof(LONGLONG);
    usIdString.MaximumLength = sizeof(LONGLONG);
    usIdString.Buffer = (PWCHAR)&llFileId;

    InitializeObjectAttributes(
            &ObjectAttributes,
            &usIdString,
            OBJ_CASE_INSENSITIVE,
            hVolume,
            NULL);      // security descriptor

    status = NtCreateFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT | FILE_OPEN_BY_FILE_ID,
                NULL,           // EA buffer
                0);             // EA length

    if (NT_SUCCESS(status))
    {
        status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            &(NameFile.FileInformation),
            sizeof(NameFile),
            FileNameInformation);

        if (NT_SUCCESS(status))
        {
            wprintf(L"%s\n",NameFile.FileInformation.FileName);
        }
        else
        {
            _tprintf(_T("Unable to query file name.\n"));
        }
    }
    else
    {
        _tprintf(_T("Unable to open file by ID.\n"));
    }

    if (hFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsenumerate.cxx ===
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>

#include <dfslink.hxx>
#include <dfsroot.hxx>
#include <dfstarget.hxx>


#include "dfsutil.hxx"
#include "dfspathname.hxx"

#define INFO4(x, y)     (((PDFS_INFO_4)x)->y)
#define INFO3(x, y)     (((PDFS_INFO_3)x)->y)
#define DFS_INFO(x, y, Level) ((Level == 4) ? INFO4(x, y) : INFO3(x, y))
#define SIZEOF_DFS_INFO(Level) ((Level == 4) ? sizeof(DFS_INFO_4) : sizeof(DFS_INFO_3))

DFSSTATUS
DfsUpdateLinkFromBuffer(
    PUNICODE_STRING pName,
    PVOID pBuf,
    ULONG Level,
    BOOLEAN SiteAware,
    DfsLink *pLink )
{
    DWORD i;
    PDFS_STORAGE_INFO pStorage;
    DFSSTATUS Status;

    DebugInformation((L"Link %ws in namespace, with %d targets\n",
                      DFS_INFO(pBuf, EntryPath, Level),
                      DFS_INFO(pBuf, NumberOfStorages, Level)));

    Status = pLink->SetLinkName(pName);

    if (Status == ERROR_SUCCESS)
    {
        Status = pLink->SetLinkComment(DFS_INFO(pBuf, Comment, Level));
    }
    pLink->SetLinkState(DFS_INFO(pBuf, State, Level));
    if (Level == 4)
    {
        pLink->SetLinkTimeout(INFO4(pBuf, Timeout));
    }
    else
    {
        pLink->SetLinkTimeout(300);
    }


    for(i = 0, pStorage = DFS_INFO(pBuf, Storage, Level);
        i < DFS_INFO(pBuf, NumberOfStorages, Level);
        i++, pStorage = DFS_INFO(pBuf, Storage, Level) + i) 
    {

        DfsTarget *pTarget;

        pTarget = new DfsTarget;
        if (pTarget == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status == ERROR_SUCCESS)
        {

            Status = pTarget->SetTargetServer(pStorage->ServerName,
                                              SiteAware);
        }
        if (Status == ERROR_SUCCESS)
        {
            Status = pTarget->SetTargetFolder(pStorage->ShareName);
        }

        if (Status == ERROR_SUCCESS)
        {
            pTarget->SetTargetState(pStorage->State);
            
            pLink->AddTarget(pTarget);
        }
    }
    return Status;
}

DFSSTATUS
DfsBuildNameSpaceInformation (
    DfsPathName *pNameSpace,
    LPWSTR UseDC,
    DFS_API_MODE Mode,
    BOOLEAN SiteAware,
    DfsRoot **ppRoot )
{
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = -1;
    DWORD Level = 4;
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pCurrentBuffer = NULL;
    DWORD i = 0;

    LPWSTR UseName = pNameSpace->GetPathString();
    

    DfsRoot *pRoot = NULL;
    DfsLink *pLink = NULL, *pStartLink = NULL, *pLastLink = NULL;
    ULONG LinkCount = 0;

    pRoot = new DfsRoot;
    if (pRoot == NULL) 
    {
      return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = pRoot->Initialize( UseName, Mode, UseDC );
    if (Status != ERROR_SUCCESS)
    {
        delete pRoot;
        return Status;
    }
    
    DebugInformation((L"Contacting %wS for enumeration \n", UseName));

    
    Status = DfsApiEnumerate( pRoot->GetMode(),
                              UseName,
                              Level, 
                              PrefMaxLen, 
                              &pBuffer, 
                              &EntriesRead, 
                              &ResumeHandle);

    //
    // if this failed, retry at level 3.
    //
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_NO_MORE_ITEMS))
    {
        Level--;

        Status = DfsApiEnumerate( pRoot->GetMode(),
                                  UseName,
                                  Level,
                                  PrefMaxLen, 
                                  &pBuffer, 
                                  &EntriesRead, 
                                  &ResumeHandle);

    }

    DebugInformation((L"Enumeration for %wS is complete %d entries, status 0x%x\n", 
                      UseName, 
                      EntriesRead, 
                      Status));



    if (Status == ERROR_SUCCESS)
    {
        pCurrentBuffer = (PVOID)pBuffer;

        for (i = 0;
             ((i < EntriesRead) && (Status == ERROR_SUCCESS));
             i++)
        {
            UNICODE_STRING LinkName, ServerName, ShareName, Remains;

            RtlInitUnicodeString( &LinkName, 
                                  DFS_INFO(pCurrentBuffer, EntryPath, Level));

            Status = DfsGetPathComponents(&LinkName,
                                          &ServerName,
                                          &ShareName,
                                          &Remains);

            if (Remains.Length == 0) 
            {
                if (ShareName.Length != 0)
                {
                    Status = DfsUpdateLinkFromBuffer( &LinkName,
                                                      pCurrentBuffer,
                                                      Level,
                                                      SiteAware,
                                                      pRoot );
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                pLink = new DfsLink;
                if (pLink == NULL) 
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = DfsUpdateLinkFromBuffer( &Remains, 
                                                      pCurrentBuffer, 
                                                      Level,
                                                      SiteAware,
                                                      pLink );
                }

                if (Status == ERROR_SUCCESS)
                {
                    LinkCount++;

                    if (pStartLink == NULL)
                    {
                        pStartLink = pLink;
                    }
                    else
                    {
                        pLastLink->AddNextLink(pLink);
                    }
                    pLastLink = pLink;
                }
            }
            pCurrentBuffer = (PVOID)((ULONG_PTR)pCurrentBuffer + SIZEOF_DFS_INFO(Level));
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        pRoot->AddLinks(pStartLink);
    }


    if (Status == ERROR_SUCCESS)
    {
        *ppRoot = pRoot;
    }
    else
    {
        if(pRoot)
        {
            delete pRoot;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsblobanalyze.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "dfsheader.h"
#include "dfsmisc.h"
#include <shellapi.h>
#include <ole2.h>
#include <activeds.h>
#include <DfsServerLibrary.hxx>

#include <WinLdap.h>
#include <NtLdap.h>
#include "dfsutil.hxx"
#include "dsgetdc.h"
#include <dsrole.h>
#include "DfsBlobInfo.hxx"

#define ADBlobAttribute  L"pKT"
#define ADBlobPktGuidAttribute  L"pKTGuid"
#define ADBlobSiteRoot   L"\\siteroot"
#define DFS_AD_CONFIG_DATA    L"CN=Dfs-configuration, CN=System"

DFSSTATUS
DfsWriteBlobToFile( 
    PBYTE pBlob,
    ULONG BlobSize, 
    LPWSTR FileName);

DFSSTATUS
DfsCreateDN(
    OUT LPWSTR PathString,
    IN size_t CharacterCount,
    LPWSTR DCName,
    LPWSTR PathPrefix,
    LPWSTR *CNNames );

DFSSTATUS
DfsGenerateRootCN(
    LPWSTR RootName,
    LPWSTR *pRootCNName);



DFSSTATUS
DfsGenerateADPathString(
    IN LPWSTR DCName,
    IN LPWSTR ObjectName,
    IN LPWSTR PathPrefix,
    OUT LPOLESTR *pPathString);



extern LPWSTR RootDseString;

//
// The prefix for AD path string. This is used to generate a path of
// the form "LDAP://<dcname>/CN=,...DC=,..."
//
extern LPWSTR LdapPrefixString;


//
// The first part of this file contains the marshalling/unmarshalling
// routines that are used by the old stores (registry and AD)
// These routines help us read a binary blob and unravel their contents.
//
// the latter part defines the common store class for all our stores.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define MTYPE_BASE_TYPE             (0x0000ffffL)

#define MTYPE_COMPOUND              (0x00000001L)
#define MTYPE_GUID                  (0x00000002L)
#define MTYPE_ULONG                 (0x00000003L)
#define MTYPE_USHORT                (0x00000004L)
#define MTYPE_PWSTR                 (0x00000005L)
#define MTYPE_UCHAR                 (0x00000006L)

#define _MCode_Base(t,s,m,i)\
    {t,offsetof(s,m),0L,0L,i}

#define _MCode_struct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND,s,m,i)

#define _MCode_pwstr(s,m)\
    _MCode_Base(MTYPE_PWSTR,s,m,NULL)

#define _MCode_ul(s,m)\
    _MCode_Base(MTYPE_ULONG,s,m,NULL)

#define _MCode_guid(s,m)\
    _MCode_Base(MTYPE_GUID,s,m,NULL)

#define _mkMarshalInfo(s, i)\
    {(ULONG)sizeof(s),(ULONG)(sizeof(i)/sizeof(MARSHAL_TYPE_INFO)),i}




typedef struct _MARSHAL_TYPE_INFO
{

    ULONG _type;                    // the type of item to be marshalled
    ULONG _off;                     // offset of item (in the struct)
    ULONG _cntsize;                 // size of counter for counted array
    ULONG _cntoff;                  // else, offset count item (in the struct)
    struct _MARSHAL_INFO * _subinfo;// if compound type, need info

} MARSHAL_TYPE_INFO, *PMARSHAL_TYPE_INFO;

typedef struct _MARSHAL_INFO
{

    ULONG _size;                    // size of item
    ULONG _typecnt;                 // number of type infos
    PMARSHAL_TYPE_INFO _typeInfo;   // type infos

} MARSHAL_INFO, *PMARSHAL_INFO;


extern MARSHAL_INFO     MiFileTime;

#define INIT_FILE_TIME_INFO()                                                \
    static MARSHAL_TYPE_INFO _MCode_FileTime[] = {                           \
        _MCode_ul(FILETIME, dwLowDateTime),                                  \
        _MCode_ul(FILETIME, dwHighDateTime),                                 \
    };                                                                       \
    extern MARSHAL_INFO MiFileTime; // = _mkMarshalInfo(FILETIME, _MCode_FileTime);


//
// Marshalling info for DFS_REPLICA_INFO structure
//

extern MARSHAL_INFO     MiDfsReplicaInfo;

#define INIT_DFS_REPLICA_INFO_MARSHAL_INFO()                                 \
    static MARSHAL_TYPE_INFO _MCode_DfsReplicaInfo[] = {                     \
        _MCode_struct(DFS_REPLICA_INFORMATION, ReplicaTimeStamp, &MiFileTime),   \
        _MCode_ul(DFS_REPLICA_INFORMATION, ReplicaState),             \
        _MCode_ul(DFS_REPLICA_INFORMATION, ReplicaType),              \
        _MCode_pwstr(DFS_REPLICA_INFORMATION, ServerName),           \
        _MCode_pwstr(DFS_REPLICA_INFORMATION, ShareName),            \
    };                                                                       \
    extern MARSHAL_INFO MiDfsReplicaInfo;// = _mkMarshalInfo(DFS_REPLICA_INFORMATION, _MCode_DfsReplicaInfo);


extern MARSHAL_INFO     MiADBlobDfsIdProperty;

#define INIT_ADBLOB_DFS_ID_PROPERTY_INFO()                                          \
    static MARSHAL_TYPE_INFO _MCode_ADBlobDfsIdProperty[] = {                       \
        _MCode_guid(DFS_NAME_INFORMATION, VolumeId),                          \
        _MCode_pwstr(DFS_NAME_INFORMATION, Prefix),                          \
        _MCode_pwstr(DFS_NAME_INFORMATION, ShortPrefix),                     \
        _MCode_ul(DFS_NAME_INFORMATION, Type),                                \
        _MCode_ul(DFS_NAME_INFORMATION, State),                               \
        _MCode_pwstr(DFS_NAME_INFORMATION, Comment),                         \
        _MCode_struct(DFS_NAME_INFORMATION, PrefixTimeStamp, &MiFileTime),    \
        _MCode_struct(DFS_NAME_INFORMATION, StateTimeStamp, &MiFileTime),     \
        _MCode_struct(DFS_NAME_INFORMATION, CommentTimeStamp, &MiFileTime),   \
        _MCode_ul(DFS_NAME_INFORMATION, Version),                             \
    };                                                                        \
    extern MARSHAL_INFO MiADBlobDfsIdProperty; //= _mkMarshalInfo(DFS_NAME_INFORMATION, _MCode_ADBlobDfsIdProperty);

extern MARSHAL_INFO     MiStdDfsIdProperty;



//+-------------------------------------------------------------------------
//
//  Function:   PackSetInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
PackSetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackSetInformation( Info + typeInfo->_off,
                                            ppBuffer,
                                            pSizeRemaining,
                                            typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackSetULong( *(PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackSetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackSetGuid( (GUID *)(Info + typeInfo->_off),
                                     ppBuffer,
                                     pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}

DFSSTATUS
DfsLdapConnect(
    LPWSTR DCName,
    LDAP **ppLdap )
{
    LDAP *pLdap = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR DCNameToUse = NULL;
    const TCHAR * apszSubStrings[4];

    DCNameToUse = DCName;
 
    apszSubStrings[0] = DCNameToUse;

    pLdap = ldap_initW(DCNameToUse, LDAP_PORT);
    if (pLdap != NULL)
    {
        Status = ldap_set_option(pLdap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
        if (Status == LDAP_SUCCESS)
        {
            Status = ldap_bind_s(pLdap, NULL, NULL, LDAP_AUTH_SSPI);
        }
    }
    else
    {
        Status = LdapGetLastError();
        Status = LdapMapErrorToWin32(Status);
    }

    *ppLdap = pLdap;
    return Status;
}



// Initialize the common marshalling info for Registry and ADLegacy stores.
//
INIT_FILE_TIME_INFO();
INIT_DFS_REPLICA_INFO_MARSHAL_INFO();

//+-------------------------------------------------------------------------
//
//  Function:   PackGetInfo - unpacks information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              interpret the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
PackGetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackGetInformation(Info + typeInfo->_off,
                                           ppBuffer,
                                           pSizeRemaining,
                                           typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackGetULong( (PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackGetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackGetGuid( (GUID *)(Info + typeInfo->_off),
                                  ppBuffer,
                                  pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PackSizeInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
ULONG
PackSizeInformation(
    ULONG_PTR Info,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    ULONG Size = 0;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Size += PackSizeInformation( Info + typeInfo->_off,
                                              typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Size += PackSizeULong();

            break;

        case MTYPE_PWSTR:
            Size += PackSizeString( (PUNICODE_STRING)(Info + typeInfo->_off) );
            
            break;

        case MTYPE_GUID:

            Size += PackSizeGuid();
            break;

        default:
            break;
        }
    }

    return Size;
}


INIT_ADBLOB_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiADBlobDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status = STATUS_SUCCESS;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_AD_BLOB;
        }
    }

    return Status;
}

DFSSTATUS
PackGetStandaloneNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory(pDfsNameInfo, sizeof(DFS_NAME_INFORMATION));
    
    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_STANDALONE;
        }
    }

    return Status;
}


ULONG
PackSizeNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo )
{
    ULONG Size;

    Size = PackSizeInformation( (ULONG_PTR)pDfsNameInfo,
                                 &MiStdDfsIdProperty );

    Size += PackSizeULong();

    return Size;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackSetNameInformation - Packs the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to pack.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the name info
//               error status otherwise.
//
//
//  Description: This routine takes the passedin name information and
//               stores it in the binary stream passed in.
//
//--------------------------------------------------------------------------
DFSSTATUS
PackSetStandaloneNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    pDfsNameInfo->State &= ~DFS_VOLUME_FLAVORS;

    pDfsNameInfo->PrefixTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->StateTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->CommentTimeStamp = pDfsNameInfo->LastModifiedTime;
    //
    // Store the DfsNameInfo in the stream first.
    //
    Status = PackSetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );

    //
    // Follow that info with the timeout information.
    // xxx this is not present in win2k?
    /* if ( Status == ERROR_SUCCESS )
    {
        Status = PackSetULong( pDfsNameInfo->Timeout,
                               ppBuffer,
                               pSizeRemaining);
    } */

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackGetReplicaInformation - Unpacks the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete replica
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine expects to find "replicaCount" number of individual
//               binary streams in passed in buffer. Each stream starts with
//               the size of the stream, followed by that size of data.
//
//--------------------------------------------------------------------------

DFSSTATUS
PackGetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;


    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackGetULong( &pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );


        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because UnpackUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this unpack returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackGetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );
            //
            // We now point the buffer to the next sub-stream, which is the previos
            // stream + the size of the stream. We also set the remaining size
            // appropriately.
            //
            *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
            *pSizeRemaining -= pReplicaInfo->DataSize;

        }
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

    }

    return Status;
}

DFSSTATUS
GetSubBlob(
    PUNICODE_STRING pName,
    BYTE **ppBlobBuffer,
    PULONG  pBlobSize,
    BYTE **ppBuffer,
    PULONG pSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // ppbuffer is the main blob, and it is point to a stream at this
    // point
    // the first part is the name of the sub-blob.
    //
    Status = PackGetString( pName, (PVOID *) ppBuffer, pSize );
    if (Status == ERROR_SUCCESS)
    {
        //
        // now get the size of the sub blob.
        //
        Status = PackGetULong( pBlobSize, (PVOID *) ppBuffer, pSize );
        if (Status == ERROR_SUCCESS)
        {
            //
            // At this point the main blob is point to the sub-blob itself.
            // So copy the pointer of the main blob so we can return it
            // as the sub blob.
            //
            *ppBlobBuffer = *ppBuffer;

            //
            // update the main blob pointer to point to the next stream
            // in the blob.

            *ppBuffer = (BYTE *)*ppBuffer + *pBlobSize;
            *pSize -= *pBlobSize;
        }
    }

    return Status;
}

VOID
DumpNameInformation(
    PDFS_NAME_INFORMATION pNameInfo)
{
    ShowInformation((L"Name is %wZ, State %x, Type %x, Comment \"%wZ\"\n", 
                     &pNameInfo->Prefix, pNameInfo->State, pNameInfo->Type,
                     &pNameInfo->Comment));

    return;
}

VOID
DumpReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaInfo)
{
    ULONG x;
    ShowInformation((L"Replica Count %d\n", pReplicaInfo->ReplicaCount));

    for (x = 0; x < pReplicaInfo->ReplicaCount; x++) 
    {
        ShowInformation((L"Replica %x, Server %wZ Share %wZ\n",
                         x,
                         &pReplicaInfo->pReplicas[x].ServerName,
                         &pReplicaInfo->pReplicas[x].ShareName ));
    }
    return;
}





DFSSTATUS
UnpackBlob(
    BYTE *pBuffer,
    PULONG pLength,
    BOOLEAN Show )
{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pUseBuffer = NULL;
    ULONG BufferSize = 0;
    ULONG ObjNdx = 0;
    ULONG TotalObjects = 0;
    ULONG  BlobSize = 0;
    ULONG AD_BlobSize = 0;
    BYTE *BlobBuffer = NULL;
    UNICODE_STRING BlobName;
    UNICODE_STRING SiteRoot;
    
    pUseBuffer = pBuffer;
    BufferSize = *pLength;

    //
    // Note the size of the whole blob.
    //
    AD_BlobSize = BufferSize;
    
    Status = DfsRtlInitUnicodeStringEx( &SiteRoot, ADBlobSiteRoot );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are discarding it.
    //
    Status = PackGetULong( &Discard, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if(BufferSize == 0)
    {
        goto done;
    }

    Status = PackGetULong(&TotalObjects, (PVOID *) &pUseBuffer, &BufferSize);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }

    DebugInformation((L"The blob has %d objects, Blob Start Address 0x%x, size 0x%x (%d bytes)\n", TotalObjects,
                      pBuffer, AD_BlobSize, AD_BlobSize));

    for (ObjNdx = 0; ObjNdx < TotalObjects; ObjNdx++)
    {

        BOOLEAN FoundSite = FALSE;
        BOOLEAN FoundRoot = FALSE;
        ULONG ReplicaBlobSize;

        DebugInformation((L"\n\nGetting blob %d: Offset 0x%x (%d)\n", 
                          ObjNdx + 1, 
                          AD_BlobSize - BufferSize,
                          AD_BlobSize - BufferSize ));



        Status = GetSubBlob( &BlobName,
                             &BlobBuffer,
                             &BlobSize,
                             &pUseBuffer,
                             &BufferSize );

        if (Status == ERROR_SUCCESS)
        {
            DFS_NAME_INFORMATION NameInfo;
            DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
            PVOID pNestedBuffer = BlobBuffer;
            ULONG Size = BlobSize;


            DebugInformation((L"Found Blob %wZ, Size 0x%x (%d bytes), (address 0x%x)\n",
                              &BlobName, BlobSize, BlobSize, BlobBuffer));


            if (RtlCompareUnicodeString( &BlobName, &SiteRoot, TRUE ) == 0)
            {
                extern DFSSTATUS DumpSiteBlob(PVOID pBuffer, ULONG Size, BOOLEAN Display);
                Status = DumpSiteBlob( BlobBuffer, BlobSize, FALSE);
                continue;
            }



            Status = PackGetNameInformation( &NameInfo,
                                             &pNestedBuffer,
                                             &Size );
            if (Status == ERROR_SUCCESS)
            {
                if (Show)
                {
                    DumpNameInformation(&NameInfo);
                }

                Status = PackGetULong( &ReplicaBlobSize,
                                       &pNestedBuffer,
                                       &Size );
                if (Status == ERROR_SUCCESS) 
                {
                    Status = PackGetULong( &ReplicaListInfo.ReplicaCount,
                                           &pNestedBuffer,
                                           &ReplicaBlobSize );
                }
                if (Status == ERROR_SUCCESS) 
                {
                    ReplicaListInfo.pReplicas = new DFS_REPLICA_INFORMATION[ ReplicaListInfo.ReplicaCount ];
                    if (ReplicaListInfo.pReplicas == NULL)
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if (Status == ERROR_SUCCESS) 
                {
                    DebugInformation((L"Reading replica information, size 0x%x\n",
                                      ReplicaBlobSize));
                    Status = PackGetReplicaInformation( &ReplicaListInfo,
                                                        &pNestedBuffer,
                                                        &ReplicaBlobSize);

                    DebugInformation((L"Read replica information 0x%x\n", Status));
                    if (Status == ERROR_SUCCESS) 
                    {
                        if (Show)
                        {
                            DumpReplicaInformation(&ReplicaListInfo);
                        }
                    }
                    else
                    {
                        DebugInformation((L"Could not read replica information, Status 0x%x\n", Status));
                    }

                    delete [] ReplicaListInfo.pReplicas;
                }
                else
                {
                    DebugInformation((L"Could not read replica size information, Status 0x%x\n", Status));
                }
            }
            else
            {
                DebugInformation((L"Could not read name information, Status 0x%x\n", Status));
            }
        }
    }

done:
    return Status;
}

DFSSTATUS
DfsGetPktBlob(
    LDAP *pLdap,
    LPWSTR ObjectDN,
    LPWSTR FileName )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus = ERROR_SUCCESS;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject = NULL;
    PLDAP_BERVAL *pLdapPktAttr = NULL;
    LPWSTR Attributes[2];
    PBYTE pBlob;
    ULONG BlobSize;



    Status = ERROR_ACCESS_DENIED;     // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.

    Attributes[0] = ADBlobAttribute;
    Attributes[1] = NULL;


    LdapStatus = ldap_search_ext_sW( pLdap,
                                     ObjectDN,
                                     LDAP_SCOPE_BASE,
                                     L"(objectClass=*)",
                                     Attributes,
                                     0,            // attributes only
                                     NULL,         // server controls
                                     NULL,         // client controls
                                     NULL,
                                     0,            // size limit
                                     &pLdapSearchedObject);
    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapPktAttr = ldap_get_values_len( pLdap,
                                                pLdapObject,
                                                Attributes[0] );
            if (pLdapPktAttr != NULL)
            {
                pBlob = (PBYTE)pLdapPktAttr[0]->bv_val;
                BlobSize = pLdapPktAttr[0]->bv_len;

                if (FileName != NULL) 
                {
                    Status = DfsWriteBlobToFile( pBlob, BlobSize, FileName);
                }
                else
                {
                    Status = UnpackBlob( pBlob, &BlobSize, FALSE );
                    if (Status == ERROR_SUCCESS)
                    {
                        ShowInformation((L"\nBlob Checked OK\n\n"));
                    }
                    else
                    {
                        ShowInformation((L"\nBlob check failed with %d\n\n", Status));
                    }
                }

                ldap_value_free_len( pLdapPktAttr );
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}




DFSSTATUS
DfsWriteBlobToFile( 
    PBYTE pBlob,
    ULONG BlobSize, 
    LPWSTR FileName)
{
    HANDLE FileHandle;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG BytesWritten;

    FileHandle = CreateFile( FileName,
                             GENERIC_ALL,
                             FILE_SHARE_WRITE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             0);

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        Status = GetLastError();
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (WriteFile( FileHandle,
                       pBlob,
                       BlobSize,
                       &BytesWritten,
                       NULL) == TRUE)
        {
            if (BlobSize != BytesWritten) 
            {
                DebugInformation((L"Blob Size %d, Written %d\n", BlobSize, BytesWritten));
            }
        }
        else
        {
            Status = GetLastError();
        }
    }

    return Status;
}

DFSSTATUS
DfsReadFromFile(
    LPWSTR Name )
{
    HANDLE FileHandle;
    ULONG Size, HighValue;
    BYTE *pBuffer;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG BytesRead;

    FileHandle = CreateFile( Name,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        Status = GetLastError();
    }
    if (Status == ERROR_SUCCESS) 
    {
        Size = GetFileSize( FileHandle,
                            &HighValue );
        if (Size == INVALID_FILE_SIZE)
        {
            Status = GetLastError();
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        pBuffer = new BYTE[Size];
        if (pBuffer == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (ReadFile( FileHandle,
                      pBuffer,
                      Size,
                      &BytesRead,
                      NULL ) == TRUE) 
        {
            if (Size != BytesRead) 
            {
                DebugInformation((L"File size %d, Read %d\n", Size, BytesRead));
            }
            Status = UnpackBlob( pBuffer,
                                 &BytesRead,
                                 TRUE );
        }
        else
        {
            Status = GetLastError();
        }
    }
    return Status;
}




DFSSTATUS
DfsReadFromAD( 
    LPWSTR DomainName,
    LPWSTR Name,
    LPWSTR FileName,
    LPWSTR UseDC )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    LDAP *pLdap;
    LPWSTR ObjectDN;
    HRESULT Hr;
    DFSSTATUS Status;
    LPWSTR ObjectName;

    //
    //  We need to initialize the COM library for use by DfsUtil.exe
    //
    Hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    if (!SUCCEEDED(Hr))
    {
        return HRESULT_CODE(Hr);
    }

    if (UseDC == NULL)
    {
        dwErr = DsGetDcName ( NULL,
                              DomainName,
                              NULL,
                              NULL,
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_PDC_REQUIRED | 
                              DS_FORCE_REDISCOVERY,
                              &pDomainControllerInfo );
        if (dwErr == ERROR_SUCCESS)
        {
            UseDC = &pDomainControllerInfo->DomainControllerName[2];
        }
        else
        {
            return dwErr;
        }
    }



    Status = DfsLdapConnect( UseDC, &pLdap );

    DebugInformation((L"Ldap Connect Status %ws 0x%x\n", UseDC, Status));
    if (Status == ERROR_SUCCESS)
    {
        LPWSTR NameContext = NULL;
        extern LPWSTR DfsGetDfsAdNameContextStringForDomain(LPWSTR UseDC);

        NameContext = DfsGetDfsAdNameContextStringForDomain(UseDC);
        if (NameContext == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY; // cookup an error.
        }
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsGenerateRootCN( Name,
                                        &ObjectName );
        }
        if (Status == ERROR_SUCCESS) {
            Status = DfsGenerateADPathString( NULL,
                                              ObjectName,
                                              NULL,
                                              &ObjectDN);
            DebugInformation((L"Generate path Status 0x%x\n", Status));

            if (Status == ERROR_SUCCESS) 
            {
                DebugInformation((L"Generated path %wS\n", ObjectDN));
                Status = DfsGetPktBlob(pLdap, ObjectDN, FileName );

                DebugInformation((L"Getblob Status 0x%x\n", Status));
            }
        }
    }

    CoUninitialize();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsgodmode\godmode.cxx ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...


VOID
TERROR(
    IN LPWSTR string
    )
{
    printf("%ls\n", string);
}

VOID
TERRORVAL(
    IN LPWSTR string,
    IN ULONG error
    )
{
    printf("%ls (errorcode=%lu)\n", string, error);
}




//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}



BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
//  RevertToSelf() must be called to restore original token  
//
//
DWORD
GetLocalSystemToken(
    IN ULONG ProcessId,
    OUT HANDLE *hPDupToken
    )
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
//    *phRet = NULL;


    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    do {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    ProcessId
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed! ", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(*hPDupToken)) {
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
                hPToken,
                DACL_SECURITY_INFORMATION,
                pSD
                )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;

#if 0
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }
#endif

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

        goto ret;

    } while(FALSE);


    if (!ImpersonateLoggedOnUser(*hPDupToken))  {
        dwErr = GetLastError();
        TERRORVAL(L"ImpersonateLoggedOnUser failed!", dwErr);
        goto ret;
    }   

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}



                    


//
//  LogoffAndRevert()
//
//  This function simply RevertsToSelf(), and then closes the logon token
//
//  Params:
//
//  hToken      -   Logon token from LogonUserW
//
//  Returns:
//  
//  dwErr from last failure, S_OK otherwise.
//
DWORD
LogoffAndRevert(HANDLE                  hToken,
                PSECURITY_DESCRIPTOR    pSD)
{
    
    HANDLE  hThread = INVALID_HANDLE_VALUE;
    DWORD   dwErr = 0;

    //
    //  Verify impersonation, and revert
    //
    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hThread
            )) {

        CloseHandle(hThread);
        RevertToSelf();
    }

    /*if (!SetKernelObjectSecurity(
        hToken,
        DACL_SECURITY_INFORMATION,
        pSD
        )) {
        dwErr = GetLastError();
        TCOMMENT(L"Security was not reset on kernel object!");
    }*/

    return dwErr;
}




 









extern "C"
int __cdecl wmain(
    int argc,
    WCHAR* argv[]
    )
{

    LPWSTR          wszUPN = NULL;
    LPWSTR          wszOldPwd = NULL;
    LPWSTR          wszNewPwd = NULL;

    DATA_BLOB*      arCipherData = NULL;

    INT             i = 1;
    DWORD           dwErr = S_OK;
    DWORD           dwCleanupErrors = S_OK;
    HANDLE          hToken = INVALID_HANDLE_VALUE;
    HANDLE          hLocalSystem = NULL;
    HANDLE          hProfile = INVALID_HANDLE_VALUE;
    BOOL            fTest = TRUE;

    PSECURITY_DESCRIPTOR    pSD = NULL;

    ULONG ProcessId = 8;

#if 0
    while (i < carg)  {

        if (!_wcsicmp(rgwszarg[i], L"-?")) {

            Usage();
            return 0;
        }

        if (!_wcsicmp(rgwszarg[i], L"-reset")) {

            ResetTestUser();
            return 0;

        }

        if (!_wcsicmp(rgwszarg[i], L"-create")) {

            CreateTestUser();
            return 0;

        }


        if (!_wcsicmp(rgwszarg[i], L"-user")) {

            if (carg < 4) {
                Usage();
            }

            fTest = TRUE;
        }

       
        i++;

    }

#endif


    if( argc == 2 )
    {
        ProcessId = _wtoi( argv[1] );
    }
 
    //
    //  Enable debug privilege
    //
    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (TCB) failed!");
        return E_FAIL;
    }


    //
    //  Run as local system
    //
    dwErr = GetLocalSystemToken(ProcessId, &hLocalSystem);
    if (NULL == hLocalSystem || dwErr != S_OK) {
        goto Ret;
    }

  
//    dwErr = LogoffAndRevert(hToken, pSD);

    {
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        ZeroMemory( &si, sizeof(si) );
        ZeroMemory( &pi, sizeof(pi) );

        si.cb = sizeof(si);
        si.lpTitle = "NT AUTHORITY\\SYSTEM";


        if(!CreateProcessAsUserA(
                hLocalSystem,
                NULL,
                "cmd.exe",
                NULL,
                NULL,
                FALSE,
                CREATE_NEW_CONSOLE,
                NULL,
                NULL,
                &si,
                &pi
                ))
        {
            TERRORVAL(L"CreateProcessAsUser", GetLastError());
        }

    }




    if (NULL != pSD) {
        MyFree(pSD);
        pSD = NULL;
    }
    
    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
        hToken = INVALID_HANDLE_VALUE;
    }


Ret:

    

    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }

    if (NULL != hLocalSystem) {
        RevertToSelf();
        CloseHandle(hLocalSystem);
    }

       return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsprocessroots.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       dfsprocessroots.cxx
//
//--------------------------------------------------------------------------
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>

#include <dfslink.hxx>
#include <dfsroot.hxx>
#include <dfstarget.hxx>


#include "dfsutil.hxx"
#include "dfspathname.hxx"
#include "misc.hxx"

#include <strsafe.h>



#define MAX_APPEND_SIZE 16
#define MAX_BACKUP_NAME_SIZE 512
#define TIME_STR_LEN 256
WCHAR BackupName[MAX_BACKUP_NAME_SIZE];
WCHAR TimeStr[TIME_STR_LEN];

DFSSTATUS
CreateBackupFile(
    DfsRoot *pOperateRoot,
    HANDLE *pBackupHandle )
{
    size_t CurrentChCount;
    SYSTEMTIME CurrentTime;
    LPWSTR Prefix = L"dfsutil.backup.";
    DfsPathName PathName;

    HANDLE BackupHandle;
    DFSSTATUS Status;
    HRESULT Hr = S_OK;

    Status = PathName.CreatePathName(pOperateRoot->GetLinkNameString());
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }
    GetLocalTime( &CurrentTime );

    Hr = StringCchPrintf(TimeStr,
                         TIME_STR_LEN,
                         L"%02d.%02d.%04d.%02d.%02d.%02d.%03d",
                         CurrentTime.wMonth, 
                         CurrentTime.wDay, 
                         CurrentTime.wYear,
                         CurrentTime.wHour, 
                         CurrentTime.wMinute, 
                         CurrentTime.wSecond, 
                         CurrentTime.wMilliseconds );
    

    CurrentChCount = MAX_BACKUP_NAME_SIZE;


    if (SUCCEEDED(Hr)) 
    {
        Hr = StringCchCopyEx( BackupName,
                              CurrentChCount,
                              PathName.GetServerString(),
                              NULL,
                              &CurrentChCount,
                              STRSAFE_IGNORE_NULLS);
    }
    if (SUCCEEDED(Hr)) 
    {
        Hr = StringCchCatNEx( BackupName,
                              CurrentChCount,
                              L".",
                              sizeof( L"." ) / sizeof( WCHAR ),
                              NULL,
                              &CurrentChCount,
                              STRSAFE_IGNORE_NULLS);
    }
    if (SUCCEEDED(Hr)) 
    {
        Hr = StringCchCatNEx( BackupName,
                              CurrentChCount,
                              PathName.GetShareString(),
                              MAX_APPEND_SIZE,
                              NULL,
                              &CurrentChCount,
                              STRSAFE_IGNORE_NULLS);
    }

    if (SUCCEEDED(Hr)) 
    {
        Hr = StringCchCatNEx( BackupName,
                              CurrentChCount,
                              L".",
                              sizeof( L"." ) / sizeof( WCHAR ),
                              NULL,
                              &CurrentChCount,
                              STRSAFE_IGNORE_NULLS);
    }

    if (SUCCEEDED(Hr)) 
    {

        Hr = StringCchCatNEx( BackupName,
                              CurrentChCount,
                              Prefix,
                              MAX_APPEND_SIZE,
                              NULL,
                              &CurrentChCount,
                              STRSAFE_IGNORE_NULLS);
    }

    if (SUCCEEDED(Hr)) 
    {
        Hr = StringCchCatEx( BackupName,
                             CurrentChCount,
                             TimeStr,
                             NULL,
                             &CurrentChCount,
                             STRSAFE_IGNORE_NULLS);
    }

    if (!SUCCEEDED(Hr)) 
    {
        return HRESULT_CODE(Hr);
    }


    Status = CreateDfsFile(BackupName, &BackupHandle);
    
    if (Status == ERROR_SUCCESS)
    {
        *pBackupHandle = BackupHandle;
        ShowInformation((L"Backup of %ws before modifications being written to %ws\n",
                         PathName.GetPathString(),
                         BackupName));
    }

    return Status;
}

DFSSTATUS
DfsGenerateBackupFile(
    DfsRoot *pOperateRoot,
    HANDLE BackupHandle )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE UseBackup = BackupHandle;

   if (BackupHandle == INVALID_HANDLE_VALUE) 
    {
        Status = CreateBackupFile(pOperateRoot, &UseBackup);
    }

    if (Status == ERROR_SUCCESS) 
    {
        Status = DumpRoots( pOperateRoot, UseBackup, TRUE);
    }

    if (Status == ERROR_SUCCESS)
    {
        FlushFileBuffers(BackupHandle);
    }
    return Status;
}




DFSSTATUS
DfsUpdateMetadata(
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsString *pRootString = pOperateRoot->GetRootApiName();

    DebugInformation((L"UpdateMetadata for roots %x and %x\n",
                      pOperateRoot, pMasterRoot));

    if (pOperateRoot != NULL) 
    {
        Status = pOperateRoot->ApplyApiChanges( pRootString->GetString(),
                                                pOperateRoot->GetMode(),
                                                pOperateRoot->GetVersion() );
        DebugInformation((L"ApplyApiChanges for root %x, Status %x\n",
                          pOperateRoot, Status));

    }

    if (Status == ERROR_SUCCESS)
    {
        if (pMasterRoot != NULL) 
        {
            Status = pMasterRoot->ApplyApiChanges(pRootString->GetString(),
                                                  pOperateRoot->GetMode(),
                                                  pOperateRoot->GetVersion() );
            DebugInformation((L"ApplyApiChanges for root %x, Status %x\n",
                              pMasterRoot, Status));

        }
    }

    DebugInformation((L"UpdateMetadata for roots %x and %x, done Status %x\n",
                      pOperateRoot, pMasterRoot, Status));

    return Status;
}

DFSSTATUS
DfsProcessRoots(
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsLink *pLink, *pExistingLink;

    DfsTarget *pTarget, *pExistingTarget;

    for (pLink = pMasterRoot->GetFirstLink();
         pLink != NULL;
         pLink = pLink->GetNextLink())
    {
        DFSSTATUS LinkStatus;

        LinkStatus = pOperateRoot->FindMatchingLink( pLink->GetLinkNameCountedString(),
                                                     &pExistingLink );

        if (LinkStatus == ERROR_SUCCESS)
        {
            for (pTarget = pLink->GetFirstTarget();
                 pTarget != NULL;
                 pTarget = pTarget->GetNextTarget())
            {
                DFSSTATUS TargetStatus;

                TargetStatus = pExistingLink->FindMatchingTarget( pTarget->GetTargetServer(),
                                                            pTarget->GetTargetFolder(),
                                                            &pExistingTarget);
                if (TargetStatus == ERROR_SUCCESS) 
                {
                    pExistingTarget->ResetChangeStatus();
                    pTarget->ResetChangeStatus();
                    if ((pTarget->IsMatchingState(pExistingTarget->GetTargetState())) == FALSE)
                    {
                        pTarget->SetChangeStatus(UPDATE_TARGET_STATE);
                    }
                    pExistingLink->ResetChangeStatus();
                    pLink->ResetChangeStatus();
                }
                else
                {
                    if (pTarget->IsMatchingState(DEFAULT_TARGET_STATE) == FALSE)
                    {
                        pTarget->SetChangeStatus(UPDATE_TARGET_STATE);
                    }
                }
            }

            if (pExistingLink->GetFirstTarget() == NULL)
            {
                pExistingLink->ResetChangeStatus();
            }

            if (pLink->IsMatchingState(pExistingLink->GetLinkState()) == FALSE)
            {
                pLink->SetChangeStatus(UPDATE_LINK_STATE);
            }
            if (pLink->IsMatchingTimeout(pExistingLink->GetLinkTimeout()) == FALSE)
            {
                pLink->SetChangeStatus(UPDATE_LINK_TIMEOUT);
            }
            if (pLink->IsMatchingComment(pExistingLink->GetLinkCommentCountedString())== FALSE)
            {
                pLink->SetChangeStatus(UPDATE_LINK_COMMENT);
            }
        }
        else
        {
            if (pLink->IsMatchingState(DEFAULT_LINK_STATE) == FALSE)
            {
                pLink->SetChangeStatus(UPDATE_LINK_STATE);
            }
            if (pLink->IsMatchingTimeout(DEFAULT_LINK_TIMEOUT) == FALSE) 
            {
                pLink->SetChangeStatus(UPDATE_LINK_TIMEOUT);
            }
            for (pTarget = pLink->GetFirstTarget();
                 pTarget != NULL;
                 pTarget = pTarget->GetNextTarget())
            {
                if (pTarget->IsMatchingState(DEFAULT_TARGET_STATE) == FALSE)
                {
                    pTarget->SetChangeStatus(UPDATE_TARGET_STATE);
                }
            }
        }
    }
    DebugInformation((L"DfsProcessRoots for %x and %x, done Status %x\n",
                      pOperateRoot,
                      pMasterRoot,
                      Status));
    return Status;
}

DFSSTATUS
DfsUpdate(
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot )
{
    DFSSTATUS Status;

    Status = DfsProcessRoots( pOperateRoot,
                              pMasterRoot );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsUpdateMetadata(pOperateRoot,
                                   pMasterRoot);
    }

    if (Status == ERROR_SUCCESS) 
    {
        PDFS_UPDATE_STATISTICS pOperateStats;
        PDFS_UPDATE_STATISTICS pMasterStats;

        pOperateStats = pOperateRoot->GetRootStatistics();
        pMasterStats = pMasterRoot->GetRootStatistics();

        pOperateStats->LinkModified += pMasterStats->LinkModified;
        pOperateStats->LinkAdded    += pMasterStats->LinkAdded;
        pOperateStats->LinkDeleted   += pMasterStats->LinkDeleted;
        pOperateStats->TargetModified += pMasterStats->TargetModified;
        pOperateStats->TargetAdded += pMasterStats->TargetAdded;
        pOperateStats->TargetDeleted += pMasterStats->TargetDeleted;
        pOperateStats->ApiCount += pMasterStats->ApiCount;

        ShowInformation((L"\nUpdate Statistics: Number of Apis %d\n",
                         pOperateStats->ApiCount));
        ShowInformation((L"Links: Added %d Deleted %d Modified %d\n",
                         pOperateStats->LinkAdded,
                         pOperateStats->LinkDeleted,
                         pOperateStats->LinkModified));
        ShowInformation((L"Targets: Added %d Deleted %d Modified %d\n",
                         pOperateStats->TargetAdded,
                         pOperateStats->TargetDeleted,
                         pOperateStats->TargetModified));
    }

    return Status;
}



DFSSTATUS
SetDfsRoots( 
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot,
    HANDLE BackupHandle,
    BOOLEAN NoBackup )
{
    DFSSTATUS Status;
    PUNICODE_STRING pRootToUpdate = pOperateRoot->GetLinkNameCountedString();


    if (NoBackup == FALSE)
    {
        Status = DfsGenerateBackupFile(pOperateRoot, BackupHandle);

        if (Status != ERROR_SUCCESS) 
        {
            return Status;
        }
    }

    pOperateRoot->SetRootApiName(pRootToUpdate);
    pOperateRoot->SetRootWriteable();
    
    pOperateRoot->MarkForDelete();
    pMasterRoot->MarkForAddition();

    Status = DfsUpdate( pOperateRoot,
                        pMasterRoot );

    if (Status == ERROR_SUCCESS)
    {
        Status = pOperateRoot->UpdateMetadata();
    }
    if (Status == ERROR_SUCCESS)
    {
        (VOID) ReSynchronizeRootTargets(pOperateRoot->GetLinkNameString());
    }

    return Status;
}

DFSSTATUS
MergeDfsRoots( 
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot,
    HANDLE BackupHandle,
    BOOLEAN NoBackup )
{
    DFSSTATUS Status;
    PUNICODE_STRING pRootToUpdate = pOperateRoot->GetLinkNameCountedString();
    

    if (NoBackup == FALSE)
    {
        Status = DfsGenerateBackupFile(pOperateRoot, BackupHandle);

        if (Status != ERROR_SUCCESS) 
        {
            return Status;
        }
    }

    pOperateRoot->SetRootApiName(pRootToUpdate);
    pOperateRoot->SetRootWriteable();
    
    pMasterRoot->MarkForAddition();

    Status = DfsUpdate( pOperateRoot,
                        pMasterRoot );

    if (Status == ERROR_SUCCESS)
    {
        Status = pOperateRoot->UpdateMetadata();
    }

    if (Status == ERROR_SUCCESS)
    {
        (VOID) ReSynchronizeRootTargets(pOperateRoot->GetLinkNameString());
    }

    return Status;
}



ULONG
DfsShowVerifyInformation(
    LPWSTR RootName,
    DfsRoot *pOperateRoot)
{
    DfsLink *pLink;
    DfsTarget *pTarget;
    ULONG Errors = 0;

    for (pLink = pOperateRoot->GetFirstLink();
         pLink != NULL;
         pLink = pLink->GetNextLink())
    {
        if (pLink->MarkedForDelete()) 
        {
            ShowInformation((L"%wS\\%wS, link additional\n",
                             RootName,
                             pLink->GetLinkNameString()));
            Errors++;
        }

        if (pLink->MarkedForAddition()) 
        {
            ShowInformation((L"%wS\\%wS, link missing\n",
                             RootName,
                             pLink->GetLinkNameString()));
            Errors++;

        }
        if (pLink->MarkedForCommentUpdate()) 
        {
            ShowInformation((L"%wS\\%wS, link Comment mismatch\n",
                             RootName,
                             pLink->GetLinkNameString()));
            Errors++;


        }
        if (pLink->MarkedForStateUpdate()) 
        {
            ShowInformation((L"%wS\\%wS, link State mismatch\n",
                             RootName,
                             pLink->GetLinkNameString()));
            Errors++;
        }
        if (pLink->MarkedForTimeoutUpdate()) 
        {
            ShowInformation((L"%wS\\%wS, link Timeout mismatch\n",
                             RootName,
                             pLink->GetLinkNameString()));
            Errors++;
        }

        for (pTarget = pLink->GetFirstTarget();
             (pTarget != NULL);
             pTarget = pTarget->GetNextTarget())
        {
            if (pTarget->MarkedForDelete())
            {
                ShowInformation((L"%wS\\%wS, Target (Server %wS, Folder %wS) Additional\n",
                                 RootName,
                                 pLink->GetLinkNameString(),
                                 pTarget->GetTargetServerString(),
                                 pTarget->GetTargetFolderString()));
                Errors++;

            }
            if (pTarget->MarkedForAddition())
            {
                ShowInformation((L"%wS\\%wS, Target (Server %wS, Folder %wS) Missing\n",
                                 RootName,
                                 pLink->GetLinkNameString(),
                                 pTarget->GetTargetServerString(),
                                 pTarget->GetTargetFolderString()));
                Errors++;
            }
            if (pTarget->MarkedForStateUpdate())
            {
                ShowInformation((L"%wS\\%wS, Target (Server %wS, Folder %wS) State mismatch\n",
                                 RootName,
                                 pLink->GetLinkNameString(),
                                 pTarget->GetTargetServerString(),
                                 pTarget->GetTargetFolderString()));
                Errors++;
            }

        }

    }
    return Errors;
}


DFSSTATUS
VerifyDfsRoots( 
    DfsRoot *pOperateRoot,
    DfsRoot *pMasterRoot )
{
    DFSSTATUS Status;

    ULONG Errors = 0;


    pOperateRoot->MarkForDelete();
    pMasterRoot->MarkForAddition();

    Status = DfsProcessRoots( pOperateRoot,
                              pMasterRoot );


    if (Status == ERROR_SUCCESS)
    {
        Errors = DfsShowVerifyInformation(
            pOperateRoot->GetLinkNameString(),
            pOperateRoot);

        Errors += DfsShowVerifyInformation(
            pOperateRoot->GetLinkNameString(),
            pMasterRoot);
    }

    if (Errors == 0)
    {
        ShowInformation((L"\n\nVerification successful for Namespace %wS\n\n",
                         pOperateRoot->GetLinkNameString()));
    }
    else
    {
        ShowInformation((L"\n\nVerification detected %d inconsistencies for Namespace %wS\n\n",
                         Errors,
                         pOperateRoot->GetLinkNameString()));

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsreparse.cxx ===
#define UNICODE  1
#define _UNICODE 1

#include <stdlib.h>
#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <ntioapi.h>

#include <windows.h>
#include <tchar.h>
#include <dbt.h>
#include <devguid.h>
#include <eh.h>

#include <shlwapi.h>
#include <dfsutil.hxx>
#define UNICODE_PATH_SEP  L'\\'

DWORD
DeleteLinkReparsePoint( 
    PUNICODE_STRING pDirectoryName,
    HANDLE ParentHandle );

DWORD DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId,
    BOOL fRemoveDirectory);

void 
CountReparsePoints(PCTSTR pcszInput);

DWORD
xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir);

HANDLE xOpenReparseIndex(PCTSTR pcszVolume);
HANDLE xOpenVolume(PCTSTR pcszVolume);
BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo);




DWORD CountReparsePoints(LPWSTR pcszInput, BOOL fRemoveDirectory)
{
    PTSTR pszVolume = NULL;
    DWORD dwCount = 0;
    DWORD Error = 0;
    BOOL fDone = TRUE;
    HANDLE hIndex = INVALID_HANDLE_VALUE;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    FILE_REPARSE_POINT_INFORMATION ReparseInfo;

    Error = xGetRootDirectory(
            pcszInput,
            &pszVolume);
    if(Error != 0)
    {
        return Error;
    }

    hIndex = xOpenReparseIndex(
            pszVolume);
    if(hIndex == INVALID_HANDLE_VALUE)
    {
        Error = GetLastError();
        goto Exit;
    }

    hVolume = xOpenVolume(
            pszVolume);

    if(hVolume == INVALID_HANDLE_VALUE)
    {
        Error = GetLastError();
        goto Exit;
    }


    fDone = xGetNextReparseRecord(
            hIndex,
            &ReparseInfo);

    while (!fDone)
    {
        if (IO_REPARSE_TAG_DFS == ReparseInfo.Tag)
        {
                dwCount++;
                DisplayFileName(
                    pszVolume,
                    hVolume,
                    ReparseInfo.FileReference,
                    fRemoveDirectory);
        }

        fDone = xGetNextReparseRecord(
                hIndex,
                &ReparseInfo);

     }

     
    Error = GetLastError();


  
Exit:

   if(hIndex != INVALID_HANDLE_VALUE )
   {
     CloseHandle(hIndex);
     hIndex = INVALID_HANDLE_VALUE;
   }

   _tprintf(
            _T("This volume (%ws) contains %u DFS Directories.\n"),
            pszVolume,
            dwCount);

   if (hVolume!=INVALID_HANDLE_VALUE)
   {
        CloseHandle(hVolume);
   }

   if(pszVolume)
   {
      delete []pszVolume;
   }

    return Error;
}


DWORD 
xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir)
{
    DWORD dwBufferSize = MAX_PATH;
    PTSTR pszTemp = NULL;
    BOOL bResult = FALSE;
    DWORD dwGleCode = 0;

    *pszRootDir = NULL;


    do
    {
        pszTemp = new TCHAR[dwBufferSize];
        if(pszTemp == NULL)
        {
            dwGleCode = ERROR_NOT_ENOUGH_MEMORY;
            return dwGleCode;

        }
        bResult = GetVolumePathName(
            pcszInput,
            pszTemp,
            dwBufferSize);

        if (!bResult)
        {
            delete []pszTemp;
            dwGleCode = GetLastError();
            if (ERROR_BUFFER_OVERFLOW==dwGleCode)
            {
                dwBufferSize *= 2;
            }
            else
            {
                break;
            }
        }
    } while (!bResult);

    *pszRootDir = pszTemp;

    return dwGleCode;
}


HANDLE xOpenReparseIndex(PCTSTR pcszVolume)
{
    HANDLE hReparseIndex = INVALID_HANDLE_VALUE;
    PTSTR pszReparseIndex = NULL;
    DWORD Error = 0;

    pszReparseIndex = new TCHAR[_tcslen(pcszVolume)+64];
    if(pszReparseIndex == NULL)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return hReparseIndex;

    }
    _tcscpy(
        pszReparseIndex,
        pcszVolume);
    PathAddBackslash(pszReparseIndex);
    _tcscat(
        pszReparseIndex,
        _T("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

   hReparseIndex = CreateFile(
       pszReparseIndex,
       GENERIC_READ,
       FILE_SHARE_READ,
       NULL,
       OPEN_EXISTING,
       FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
       NULL);

   Error = GetLastError ();

   delete []pszReparseIndex;

   SetLastError (Error);

   return hReparseIndex;
}


HANDLE xOpenVolume(PCTSTR pcszVolume)
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    PTSTR pszVolumeName = NULL;
    DWORD Error = 0;

    pszVolumeName = new TCHAR[MAX_PATH];

    BOOL bResult = GetVolumeNameForVolumeMountPoint(
        pcszVolume,
        pszVolumeName,
        MAX_PATH);

    if (bResult)
    {
        hVolume = CreateFile(
            pszVolumeName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
            NULL);

           Error = GetLastError ();

    }
    else
    {
        Error = GetLastError ();
    }

    delete []pszVolumeName;

    SetLastError (Error);

   return hVolume;
}


BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo)
{
    BOOL bResult = FALSE;
    DWORD Error = 0;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS status = NtQueryDirectoryFile(hIndex,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        ReparseInfo,
        sizeof(FILE_REPARSE_POINT_INFORMATION),
        FileReparsePointInformation,
        TRUE,
        NULL,
        FALSE);
    if (!NT_SUCCESS(status))
    {
        Error = RtlNtStatusToDosError(status);
        if(Error == ERROR_NO_MORE_FILES)
        {
            Error = 0;
        }

        bResult = TRUE;
    }

    SetLastError(Error);

    return bResult;
}

DWORD
DeleteDirectory(LPWSTR VolumeName, LPWSTR pDfsDirectory)
{
    DWORD Status = 0;
    DWORD BuffLen = 0;
    LPWSTR lpExistingFileName = NULL;
    UNICODE_STRING UnicodeFileName;

    BuffLen = (wcslen(L"\\??\\") + 1) * sizeof(WCHAR);
    BuffLen += ((wcslen((const wchar_t *)pDfsDirectory)  + 1)* sizeof(WCHAR));
    BuffLen += ((wcslen((const wchar_t *)VolumeName)  + 1)* sizeof(WCHAR));

    lpExistingFileName = (LPWSTR)HeapAlloc (GetProcessHeap(), 0, BuffLen);
    if(lpExistingFileName == NULL)
    {
       wprintf(L"Out of memory\n");
       Status = ERROR_NOT_ENOUGH_MEMORY;
       return Status;
    }

    wcscpy(lpExistingFileName, L"\\??\\");
    wcscat(lpExistingFileName, (const wchar_t *) VolumeName);
    wcscat(lpExistingFileName, (const wchar_t *) pDfsDirectory);

    UnicodeFileName.Buffer = lpExistingFileName ;
    UnicodeFileName.Length = wcslen(lpExistingFileName) * sizeof(WCHAR);
    UnicodeFileName.MaximumLength = UnicodeFileName.Length;

    Status = DeleteLinkReparsePoint( &UnicodeFileName,
                                    NULL);
    HeapFree(GetProcessHeap(), 0, lpExistingFileName);

    return Status;
}

DWORD DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId,
    BOOL fRemoveDirectory)
{
    UNICODE_STRING          usIdString;
    NTSTATUS                status = 0;
    DWORD                   ErrorCode = 0;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK         IoStatusBlock;

    struct {
        FILE_NAME_INFORMATION   FileInformation;
        WCHAR                   FileName[MAX_PATH];
    } NameFile;

    fRemoveDirectory;

    ZeroMemory(
        &NameFile,
        sizeof(NameFile));

    usIdString.Length = sizeof(LONGLONG);
    usIdString.MaximumLength = sizeof(LONGLONG);
    usIdString.Buffer = (PWCHAR)&llFileId;

    InitializeObjectAttributes(
            &ObjectAttributes,
            &usIdString,
            OBJ_CASE_INSENSITIVE,
            hVolume,
            NULL);      // security descriptor

    status = NtCreateFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT | FILE_OPEN_BY_FILE_ID,
                NULL,           // EA buffer
                0);             // EA length

    if (NT_SUCCESS(status))
    {
        status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            &(NameFile.FileInformation),
            sizeof(NameFile),
            FileNameInformation);

        if (NT_SUCCESS(status))
        {
            wprintf(L"%ws%ws\n",pszVolume, NameFile.FileInformation.FileName+1);
        }
        else
        {
            ErrorCode = RtlNtStatusToDosError(status);
            SetLastError(ErrorCode);

            _tprintf(_T("Unable to query file name.\n"));
        }
    }
    else
    {
        ErrorCode = RtlNtStatusToDosError(status);
        SetLastError(ErrorCode);

        _tprintf(_T("Unable to open file by ID.\n"));
    }

    if (hFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if((ErrorCode == 0) && fRemoveDirectory)
    {
        DeleteDirectory(pszVolume, NameFile.FileInformation.FileName+1);
    }

    return ErrorCode;

}

VOID
CloseDirectory(
    HANDLE DirHandle )
{
    NtClose( DirHandle );
}

NTSTATUS
ClearDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    REPARSE_DATA_BUFFER ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DELETE_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    
    return NtStatus;
}

NTSTATUS
OpenDirectory(
    PUNICODE_STRING pDirectoryName,
    ULONG ShareMode,
    HANDLE RelativeHandle,
    PHANDLE pOpenedHandle,
    PBOOLEAN pIsNewlyCreated )
{

    NTSTATUS                    NtStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    ACCESS_MASK                 DesiredAccess;
    PLARGE_INTEGER              AllocationSize;
    ULONG                       FileAttributes;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    IO_STATUS_BLOCK IoStatusBlock;

    AllocationSize             = NULL;
    FileAttributes             = FILE_ATTRIBUTE_NORMAL;
    CreateDisposition          = FILE_OPEN_IF;
    CreateOptions              = FILE_DIRECTORY_FILE |
                                 FILE_OPEN_REPARSE_POINT |
                                 FILE_SYNCHRONOUS_IO_NONALERT;

    DesiredAccess              = FILE_READ_DATA | 
                                 FILE_WRITE_DATA |
                                 FILE_READ_ATTRIBUTES | 
                                 FILE_WRITE_ATTRIBUTES |
                                 SYNCHRONIZE;

    InitializeObjectAttributes (
        &ObjectAttributes, 
        pDirectoryName,              //Object Name
        0,                           //Attributes
        RelativeHandle,              //Root handle
        NULL);                       //Security descriptor.

    NtStatus = NtCreateFile(pOpenedHandle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,
                            FileAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,                // EaBuffer
                            0 );                 // EaLength

    
    if ( (NtStatus == STATUS_SUCCESS)  && (pIsNewlyCreated != NULL) )
    {
        *pIsNewlyCreated = (IoStatusBlock.Information == FILE_CREATED)? TRUE : FALSE;
    }

    return NtStatus;
}

NTSTATUS
IsDirectoryReparsePoint(
    IN  HANDLE DirHandle,
    OUT PBOOLEAN pReparsePoint,
    OUT PBOOLEAN pDfsReparsePoint )
{
    NTSTATUS NtStatus;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    //we assume these are not reparse points.
    //
    *pReparsePoint = FALSE;
    *pDfsReparsePoint = FALSE;

    //
    // Query for the basic information, which has the attributes.
    //
    NtStatus = NtQueryInformationFile( DirHandle,
                                     &IoStatusBlock,
                                     (PVOID)&BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (NtStatus == STATUS_SUCCESS)
    {
        //
        // If the attributes indicate reparse point, we have a reparse
        // point directory on our hands.
        //
        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) 
        {
            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            *pReparsePoint = TRUE;
            
            NtStatus = NtQueryInformationFile( DirHandle,
                                               &IoStatusBlock,
                                               (PVOID)&FileTagInformation,
                                               sizeof(FileTagInformation),
                                               FileAttributeTagInformation );

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Checkif the tag indicates its a DFS reparse point,
                // and setup the return accordingly.
                //
                if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_DFS)
                {
                    *pDfsReparsePoint = TRUE;
                }
            }
        }
    }

    return NtStatus;
}


BOOLEAN
IsEmptyDirectory(
    HANDLE DirectoryHandle,
    PVOID pDirectoryBuffer,
    ULONG DirectoryBufferSize )
{
    NTSTATUS NtStatus;
    FILE_NAMES_INFORMATION *pFileInfo;
    ULONG NumberOfFiles = 1;
    BOOLEAN ReturnValue = FALSE;
    IO_STATUS_BLOCK     IoStatus;

    NtStatus = NtQueryDirectoryFile ( DirectoryHandle,
                                      NULL,   // no event
                                      NULL,   // no apc routine
                                      NULL,   // no apc context
                                      &IoStatus,
                                      pDirectoryBuffer,
                                      DirectoryBufferSize,
                                      FileNamesInformation,
                                      FALSE, // return single entry = false
                                      NULL,  // filename
                                      FALSE ); // restart scan = false
    if (NtStatus == ERROR_SUCCESS)
    {
        pFileInfo =  (FILE_NAMES_INFORMATION *)pDirectoryBuffer;

        while (pFileInfo->NextEntryOffset) {
            NumberOfFiles++;
            if (NumberOfFiles > 3) 
            {
                break;
            }
            pFileInfo = (FILE_NAMES_INFORMATION *)((ULONG_PTR)(pFileInfo) + 
                                                   pFileInfo->NextEntryOffset);
        }

        if (NumberOfFiles <= 2)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;
}

NTSTATUS
DeleteLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle )
{
    UNICODE_STRING DirectoryToDelete = *pLinkName;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE CurrentDirectory = NULL;
    ULONG ShareMode = 0;
    OBJECT_ATTRIBUTES           ObjectAttributes;

    ShareMode =  FILE_SHARE_READ;
    //
    // dfsdev: fix this fixed size limit. it will hurt us in the future.
    //
    ULONG DirectoryBufferSize = 4096;
    PBYTE pDirectoryBuffer = new BYTE [DirectoryBufferSize];

    if (pDirectoryBuffer == NULL)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // BUG 701594: Don't delete all directories under a reparse dir.
    // Just remove the reparse dir.
    if ( (NtStatus == STATUS_SUCCESS) && (DirectoryToDelete.Length != 0) )
    {
        NtStatus = OpenDirectory( &DirectoryToDelete,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  NULL );
        if (NtStatus == ERROR_SUCCESS)
        {
            if (IsEmptyDirectory(CurrentDirectory,
                                 pDirectoryBuffer,
                                 DirectoryBufferSize) == FALSE)
            {
                CloseDirectory( CurrentDirectory );
            }
            else
            {
                CloseDirectory( CurrentDirectory );
                InitializeObjectAttributes (
                    &ObjectAttributes,
                    &DirectoryToDelete,
                    0,
                    RelativeHandle,
                    NULL);

                NtStatus = NtDeleteFile( &ObjectAttributes );
                DebugInformation((L"Removed Directory %wZ, Status 0x%x\n", 
                                &DirectoryToDelete, NtStatus));
            }
        }
    }

    if (pDirectoryBuffer != NULL)
    {
        delete [] pDirectoryBuffer;
    }
    return NtStatus;
}


DWORD
DeleteLinkReparsePoint( 
    PUNICODE_STRING pDirectoryName,
    HANDLE ParentHandle )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD DosStatus = ERROR_SUCCESS;
    HANDLE LinkDirectoryHandle = INVALID_HANDLE_VALUE;
    BOOLEAN IsReparsePoint = FALSE;
    BOOLEAN IsDfsReparsePoint = FALSE;

    NtStatus = OpenDirectory( pDirectoryName,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              ParentHandle,
                              &LinkDirectoryHandle,
                              NULL );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = IsDirectoryReparsePoint( LinkDirectoryHandle,
                                            &IsReparsePoint,
                                            &IsDfsReparsePoint );

        if ((NtStatus == STATUS_SUCCESS) && 
            (IsDfsReparsePoint == TRUE) )
        {

            NtStatus = ClearDfsReparsePoint( LinkDirectoryHandle );
            DosStatus = RtlNtStatusToDosError(NtStatus);

            wprintf(L"ClearDfsReparsePoint for %ws returned %x\n", pDirectoryName->Buffer, DosStatus);
        }
        else if(NtStatus != STATUS_SUCCESS)
        {
            DosStatus = RtlNtStatusToDosError(NtStatus);
            wprintf(L"Clearing DFS reparse point for %ws failed %x\n", pDirectoryName->Buffer, DosStatus);
        }
        else if(IsDfsReparsePoint == FALSE)
        {
            DosStatus = RtlNtStatusToDosError(NtStatus);

            wprintf(L"%ws does not have a DFS reparse point %x\n", pDirectoryName->Buffer, DosStatus);
        }

        NtClose( LinkDirectoryHandle );
    }
    else
    {
       NtStatus = RtlNtStatusToDosError(NtStatus);
        wprintf(L"Open for %ws returned %x\n", pDirectoryName->Buffer, NtStatus);
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DeleteLinkDirectories( pDirectoryName,
                                         NULL);
    }

    DosStatus = RtlNtStatusToDosError(NtStatus);

    return DosStatus;

}


DWORD
DeleteReparsePoint(LPWSTR pDfsDirectory)
{
    DWORD Status = 0;
    DWORD BuffLen = 0;
    LPWSTR lpExistingFileName = NULL;
    UNICODE_STRING UnicodeFileName;

    BuffLen = (wcslen(L"\\??\\") + 1) * sizeof(WCHAR);
    BuffLen += ((wcslen((const wchar_t *)pDfsDirectory)  + 1)* sizeof(WCHAR));

    lpExistingFileName = (LPWSTR)HeapAlloc (GetProcessHeap(), 0, BuffLen);
    if(lpExistingFileName == NULL)
    {
       wprintf(L"Out of memory\n");
       Status = ERROR_NOT_ENOUGH_MEMORY;
       return Status;
    }

    wcscpy(lpExistingFileName, L"\\??\\");
    wcscat(lpExistingFileName, (const wchar_t *) pDfsDirectory);

    UnicodeFileName.Buffer = lpExistingFileName ;
    UnicodeFileName.Length = wcslen(lpExistingFileName) * sizeof(WCHAR);
    UnicodeFileName.MaximumLength = UnicodeFileName.Length;

    Status = DeleteLinkReparsePoint( &UnicodeFileName,
                                    NULL);

    HeapFree(GetProcessHeap(), 0, lpExistingFileName);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsutilschema.h ===
WCHAR SchemaStr[][100] = {
L"<?xml version=\"1.0\"?>",
L"<Schema xmlns=\"urn:schemas-microsoft-com:xml-data\"",
L"        xmlns:dt=\"urn:schemas-microsoft-com:datatypes\" >",
L"  <AttributeType name=\"Name\"     dt:type = \"string\" />",
L"  <AttributeType name=\"State\"    dt:type = \"int\"    />",
L"  <AttributeType name=\"Timeout\"  dt:type = \"int\"    />",
L"  <AttributeType name=\"Server\"   dt:type = \"string\" />",
L"  <AttributeType name=\"Folder\"   dt:type = \"string\" />",    
L"  <AttributeType name=\"Comment\"  dt:type = \"string\" />",    
L"  <ElementType   name = \"Target\" model = \"closed\" >",
L"     <attribute  type = \"Server\" required = \"yes\" />",
L"     <attribute  type = \"Folder\" required = \"yes\" />",
L"     <attribute  type = \"State\"  required = \"no\" />",
L"  </ElementType>",
L"  <ElementType   name = \"Link\"   content = \"eltOnly\" model = \"closed\" >",
L"     <element    type = \"Target\" maxOccurs = \"*\" />",
L"     <attribute  type = \"Name\"   required = \"yes\" />",
L"     <attribute  type = \"Timeout\" required = \"no\" />",
L"     <attribute  type = \"State\"  required = \"no\" />",
L"     <attribute  type = \"Comment\" required = \"no\" />",
L"  </ElementType>",
L"  <ElementType   name = \"Root\"   content = \"eltOnly\" model = \"closed\" >",
L"     <element    type = \"Target\" minOccurs = \"0\" maxOccurs = \"*\" />",
L"     <element    type = \"Link\"   minOccurs = \"0\" maxOccurs = \"*\" />",
L"     <attribute  type = \"Name\" required=\"no\" />",
L"     <attribute  type = \"Timeout\" required = \"no\" />",
L"     <attribute  type = \"State\"  required = \"no\" />",
L"     <attribute  type = \"Comment\" required = \"no\" />",
L"  </ElementType>",
L"</Schema>",
};

#if 0
<?xml version=\"1.0\"?>
<Schema xmlns=\"urn:schemas-microsoft-com:xml-data\"
        xmlns:dt=\"urn:schemas-microsoft-com:datatypes\">

  <AttributeType name=\"Name\"    dt:type=\"string\" />
  <AttributeType name=\"State\"   dt:type=\"int\"    />
  <AttributeType name=\"Timeout\" dt:type=\"int\"    />  
  <AttributeType name=\"Server\"  dt:type=\"string\"    />  
  <AttributeType name=\"Folder\"  dt:type=\"string\"    />      
  
  <ElementType name = \"Target\" model=\"closed\">
     <attribute type = \"Server\" required=\"yes\" />
     <attribute type = \"Folder\" required=\"yes\"/>
     <attribute type = \"State\"  required=\"no\"/>
  </ElementType>


  <ElementType name = \"Link\" content=\"eltOnly\" model=\"closed\">  
     <element type = \"Target\" maxOccurs=\"*\"/>
     <attribute type = \"Name\"/>          
     <attribute type = \"Timeout\" required=\"no\"/>
     <attribute type = \"State\" required=\"no\"/>
  </ElementType>
  
  <ElementType name = \"Root\" content=\"eltOnly\" model=\"closed\">  
     <element type = \"Target\" minOccurs=\"0\" maxOccurs=\"*\"/>
     <element type = \"Link\" maxOccurs=\"*\" />    
     <attribute type = \"Name\"/>     
     <attribute type = \"Timeout\" required=\"no\"/>
     <attribute type = \"State\" required=\"no\"/>
  </ElementType>     


</Schema>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsutil.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       dfsutil.cxx
//
//--------------------------------------------------------------------------

extern "C" {
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
}
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
#include <dsgetdc.h>
#include <ole2.h>
#include <activeds.h>
#include <dfsprefix.h>
#include <DfsServerLibrary.hxx>
#include <dfsmisc.h>
#include "dsgetdc.h"
#include "dsrole.h"

#include "dfsutil.hxx"
#include "dfspathname.hxx"

#include "struct.hxx"
#include "flush.hxx"
#include "misc.hxx"
#include "info.hxx"
#include "messages.h"
#include "dfsreparse.hxx"

#include "dfswmi.h"

#include "dfsroot.hxx"
#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)
  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)

#include "dfsutil.tmh"


UNICODE_STRING DCToUseFlatDomainName;
UNICODE_STRING DCToUseDNSDomainName;
LPWSTR DCToUse = NULL;
DFSSTATUS DCInfoStatus = ERROR_SUCCESS;

extern
void 
SetReferralControl(WPP_CB_TYPE * Control);

DFSSTATUS
ProcessRootForSite(
    DfsRoot *pRoot );

DFSSTATUS
PurgeSiteInformationForRoot(
    DfsRoot *pRoot );

DFSSTATUS
DumpSiteBlob(
    PVOID pBuffer,
    ULONG Size,
    BOOLEAN Display );

//
// How we make args & switches
//

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;

#define SWITCH(x) \
    WCHAR Sw##x[] = L"/" L#x ; \
    BOOLEAN fSw##x;

#define FMAKEARG(x) \
    static WCHAR Arg##x[] = L#x L":"; \
    static LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    static BOOLEAN fArg##x;

#define FSWITCH(x) \
    static WCHAR Sw##x[] = L"/" L#x ; \
    static BOOLEAN fSw##x;

DFSSTATUS
DfsReadFromAD( 
    LPWSTR DomainName,
    LPWSTR Name,
    LPWSTR FileName,
    LPWSTR UseDC );

DFSSTATUS
DfsReadFromFile(
    LPWSTR Name );



LPWSTR pwszServerName = NULL;
LPWSTR pwszDomainName = NULL;
LPWSTR pwszEntryToFlush = NULL;
LPWSTR pwszComment = NULL;
LPWSTR pwszShareName = NULL;
LPWSTR pwszLogicalName = NULL;
LPWSTR pwszHexValue = NULL;
LPWSTR ImportFile = NULL;

DfsPathName OperateNameSpace;
DfsPathName MasterNameSpace;
DfsPathName OldDomainName;
DfsPathName NewDomainName;

DfsString ClientForSiteName;

LPWSTR ExportBlobFile = NULL;
LPWSTR DisplayBlobFile = NULL;

BOOLEAN CmdRequiresDirect = FALSE;
LPWSTR ExportFile = NULL;
LPWSTR DebugFile = NULL;
LPWSTR BackupFile = NULL;
LPWSTR pwszVolumeName = NULL;
LPWSTR pwszDfsDirectoryName = NULL;
LPWSTR pwszDcName = NULL;

DFS_API_MODE Mode = MODE_EITHER;
    
DFSSTATUS DirectModeFailStatus = ERROR_SUCCESS;


HANDLE ShowHandle= INVALID_HANDLE_VALUE;
HANDLE DebugHandle= INVALID_HANDLE_VALUE;
HANDLE ExportHandle= INVALID_HANDLE_VALUE;
HANDLE BackupHandle = INVALID_HANDLE_VALUE;


MAKEARG(RemFtRoot);
SWITCH(RemFtRoot);

MAKEARG(Domain);
MAKEARG(Server);
MAKEARG(Share);

SWITCH(DisplayBlob);
MAKEARG(DisplayBlob);


MAKEARG(Import);
SWITCH(Import);     // The switch is just a cue for Help here.
MAKEARG(Export);
MAKEARG(Backup);
SWITCH(NoBackup);
SWITCH(Export);
MAKEARG(Root);
SWITCH(Root);
MAKEARG(DebugFile);
MAKEARG(OldDomain);
MAKEARG(NewDomain);
SWITCH(UnmapFtRoot);
SWITCH(Unmap);
MAKEARG(UnmapFtRoot);

MAKEARG(SiteName);
SWITCH(SiteName);
MAKEARG(Clean);
SWITCH(Clean);
SWITCH(Insite);
SWITCH(SiteCosting);
SWITCH(RootScalability);

SWITCH(ViewDfsDirs);
MAKEARG(ViewDfsDirs);

//MAKEARG(RemoveReparse);
MAKEARG(DebugDC);
SWITCH(RemoveReparse);
SWITCH(DC);

SWITCH(ExportBlob);
MAKEARG(ExportBlob);

MAKEARG(ImportRoot);
SWITCH(ImportRoot);

SWITCH(PurgeMupCache);
SWITCH(UpdateWin2kStaticSiteTable);
SWITCH(ShowWin2kStaticSiteTable);
SWITCH(PurgeWin2kStaticSiteTable);

SWITCH(CheckBlob);
SWITCH(BlobSize);



//
// Switches (ie '/arg')
//

SWITCH(AddStdRoot);
SWITCH(AddFtRoot);
SWITCH(Debug);
SWITCH(Verbose);
SWITCH(Help);
SWITCH(ScriptHelp);
SWITCH(PktInfo);
SWITCH(Dfs);
SWITCH(All);
SWITCH(Set);
SWITCH(Mirror);
SWITCH(RemStdRoot);
SWITCH(Api);

SWITCH(Compare);
SWITCH(Merge);
SWITCH(Direct);
SWITCH(RenameFtRoot);
SWITCH(View);
SWITCH(Disable);
SWITCH(Enable);
SWITCH(Display);



//
// Either a switch or an arg
//
MAKEARG(PktFlush);
SWITCH(PktFlush);
MAKEARG(SpcFlush);
SWITCH(SpcFlush);
MAKEARG(SpcInfo);
SWITCH(SpcInfo);
MAKEARG(Level);


//
// The macro can not make these
//

WCHAR SwQ[] = L"/?";
BOOLEAN fSwQ;

ULONG AddLinks, RemoveLinks, AddTargets, RemoveTargets, ErrorLinks,
       DirectMode, ApiCalls, SetInfoState, SetInfoComment;
ULONG TotalNamespaceCost;

BOOLEAN CommandSucceeded = FALSE;
BOOLEAN ErrorDisplayed = FALSE;
static BOOLEAN LastOptionWasInsite = FALSE;
static BOOLEAN DirectModeOnly = FALSE;
static BOOLEAN UserRequiresDirectMode = FALSE;

DFSSTATUS
CmdInitializeDirectMode(
    PBOOLEAN pCoInitialized);
    
DWORD
Usage();

DWORD
CmdProcessUserCreds(
    VOID);

BOOLEAN
CmdProcessArg(
    LPWSTR Arg);


DFSSTATUS
CmdCheckSyntax( BOOLEAN& Done );

DFSSTATUS
IsRootStandalone( 
    DfsPathName *PathComps,
    PBOOLEAN pIsAdBlob );

DWORD
IsThisADomainName(
    IN LPWSTR wszName,
    OUT PWCHAR *ppList OPTIONAL);

DFSSTATUS
CmdCheckExceptions( DfsPathName *Namespace );

extern DFSSTATUS
DfsExtendedWin2kRootAttributes(
    DfsPathName *Namespace,
    PULONG pAttr,
    BOOLEAN Set);


DFSSTATUS
GetDCInformation()
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DsRoleGetPrimaryDomainInformation( DCToUse,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&pPrimaryDomainInfo);
    if (Status != ERROR_SUCCESS)
    {
        DCInfoStatus = Status;
        return ERROR_SUCCESS;
    }

    if (Status == ERROR_SUCCESS)
    {
        UNICODE_STRING DomainNameFlat;
        Status = DfsRtlInitUnicodeStringEx( &DomainNameFlat, 
                                            pPrimaryDomainInfo->DomainNameFlat);
        if(Status == ERROR_SUCCESS)
        {
            Status = DfsCreateUnicodeString( &DCToUseFlatDomainName,
                                             &DomainNameFlat );

        }

        if (Status == ERROR_SUCCESS)
        {
            UNICODE_STRING DomainNameDNS;
            Status = DfsRtlInitUnicodeStringEx( &DomainNameDNS, 
                                            pPrimaryDomainInfo->DomainNameDns);
            if(Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodeString( &DCToUseDNSDomainName,
                                                 &DomainNameDNS );

            }
        }

        DsRoleFreeMemory(pPrimaryDomainInfo);
    }

    return Status;
}


DFSSTATUS
DfsEnumerateDomainDfs(
    LPWSTR Domain)
{
    DFSSTATUS Status;
    PDFS_INFO_200  pBuffer = NULL, pCurBuffer;
    DWORD   dwEntriesRead = 0;
    DWORD   dwResumeHandle = 0;
    DWORD   dwTotalEntries = 0;

    do {

        dwEntriesRead = 0;

        Status = NetDfsEnum( Domain,
                             200,
                             (DWORD)-1,
                             (LPBYTE *)&pBuffer,
                             &dwEntriesRead,
                             &dwResumeHandle );
    
        if (Status == ERROR_SUCCESS) 
        {
            pCurBuffer = pBuffer;
    
            if (dwEntriesRead) 
            {
                if (dwTotalEntries == 0) {
                    ShowInformation((L"\nRoots on Domain %ws\n\n", Domain));
                }
                for (DWORD i=0; i<dwEntriesRead; i++)
                {
                    ShowInformation((L"\t%ws\n", pCurBuffer[i].FtDfsName));
                    dwTotalEntries++;
                }
            }
        }
        if (NULL != pBuffer)
        {
                NetApiBufferFree(pBuffer);
                pBuffer = NULL;
        }
    } while ( Status == ERROR_SUCCESS && dwResumeHandle != NULL );

    if (dwTotalEntries > 0)
    {
        ShowInformation((L"\nDone with Roots on Domain %ws\n", Domain));

        if (Status == ERROR_NO_MORE_ITEMS) {
            Status = ERROR_SUCCESS;
        }
    }
    else
    {
        ShowInformation((L"\n\nNo roots exist on domain %ws\n\n", Domain));
    }

    return Status;
}

DFSSTATUS
DfsEnumerateMachineDfs(
    LPWSTR Server)
{
    DFSSTATUS Status;
    PDFS_INFO_300  pBuffer = NULL, pCurBuffer;
    DWORD   dwEntriesRead = 0;
    DWORD   dwResumeHandle = 0;
    DWORD   dwTotalEntries = 0;

    do {

        dwEntriesRead = 0;

        Status = NetDfsEnum( Server,
                             300,
                             (DWORD)-1,
                             (LPBYTE *)&pBuffer,
                             &dwEntriesRead,
                             &dwResumeHandle );
    
        if (Status == ERROR_SUCCESS) 
        {
            pCurBuffer = pBuffer;
            if (dwEntriesRead) 
            {
                if (dwTotalEntries == 0) {
                    ShowInformation((L"\nRoots on machine %ws\n\n", Server));
                }
                for (DWORD i=0; i<dwEntriesRead; i++)
                {
                    ShowInformation((L"\t%ws\n", pCurBuffer[i].DfsName));
                    dwTotalEntries++;
                }
            }
        }
        if (NULL != pBuffer)
        {
                NetApiBufferFree(pBuffer);
                pBuffer = NULL;
        }

    } while ( Status == ERROR_SUCCESS && dwResumeHandle != NULL );

    if (dwTotalEntries > 0)
    {
        ShowInformation((L"\nDone with Roots on machine %ws\n", Server));

        if (Status == ERROR_NO_MORE_ITEMS) {
            Status = ERROR_SUCCESS;
        }
    }
    else
    {
        ShowInformation((L"\n\nNo roots exist on machine %ws\n\n", Server));
    }

    return Status;
}
_cdecl
main(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argx;
    int argcw;
    BOOLEAN CoInitialized = FALSE;  
    BOOLEAN DirectModeInitialized = FALSE;
    BOOLEAN Done;
    
    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];

    WPP_INIT_TRACING(L"DfsUtil");
    SetReferralControl(pLogger);

    ShowHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    DebugHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    //
    // Do the work
    //
    do {
        ErrorMessage( MSG_COPYRIGHT );
    
        if ((dwErr = DfsPrefixTableInit()) != STATUS_SUCCESS)
        {
            break;
        }
        
        //
        // Get the command line in Unicode
        //

        CommandLine = GetCommandLine();

        argvw = CommandLineToArgvW(CommandLine, &argcw);

        if ( argvw == NULL ) {
            DebugInformation((L"DfsUtil:Can't convert command line to Unicode: %d\r\n", GetLastError()));
            dwErr = GetLastError();
            break;
        }

        //
        // Get the arguments
        //
        if (argcw <= 1) {
            dwErr = Usage();
            break;
        }

        
        //
        // Process arguments. Direct mode is enabled by default.
        //
        fSwDirect = TRUE;
        UserRequiresDirectMode = FALSE;
        Done = FALSE;
        
        for (argx = 1; argx < argcw && !Done; argx++) {
            Done = CmdProcessArg(argvw[argx]);
        }
        if (Done) {
            Usage();
            break;
        }

        //
        // Some sanity checking of cmd syntax.
        // This also prints all appropriate error help messages.
        //
        dwErr = CmdCheckSyntax( Done );
        if (Done) {
            break;
        }
        
        if (fSwPktFlush == TRUE || fArgPktFlush == TRUE) {
            dwErr = PktFlush(pwszEntryToFlush);
            break;
        } else if (fSwSpcFlush == TRUE || fArgSpcFlush == TRUE) {
            dwErr = SpcFlush(pwszEntryToFlush);
            break;
        } else if (fSwPktInfo == TRUE) {
            dwErr = PktInfo(fSwDfs, pwszHexValue);
            break;
        } else if (fSwSpcInfo == TRUE) {
            dwErr = SpcInfo(fSwAll);
            break;
        }

        if(fArgViewDfsDirs)
        {
            BOOL fRemove = FALSE;

            if(fSwRemoveReparse)
            {
               fRemove =TRUE;
            }

            dwErr = CountReparsePoints(pwszVolumeName, fRemove);
            break;
        }
/*
        BUG 736596: DeleteReparsePoint as implemented doesn't walk through
        all subdirectories of a given directory. In fact, it doesn't seem to work
        at all. We should probably address this in the longhorn timeframe.
        
        if(fArgRemoveReparse)
        {
            dwErr = DeleteReparsePoint(pwszDfsDirectoryName);
            break;
        }
*/
        if (fSwAddStdRoot == TRUE) {
            dwErr = CmdAddRoot(
                        FALSE,
                        pwszServerName,
                        pwszShareName,
                        pwszShareName, // Enforce RootName = Sharename
                        pwszComment);
            break;
        }

        if (fSwAddFtRoot == TRUE) {
            dwErr = CmdAddRoot(
                        TRUE,
                        pwszServerName,
                        pwszShareName,
                        pwszShareName, // Enforce RootName = Sharename
                        pwszComment);
            break;
        } 

        if (fSwRemStdRoot == TRUE) {
            dwErr = CmdRemRoot(
                        FALSE,
                        pwszServerName,
                        pwszShareName,
                        pwszShareName); // Sharename = logicalname.
            break;
        } 

        //
        // We allow users to delete roots whose logical name don't match
        // their physical share names for compatibility reasons.
        // DfsUtil itself doesn't allow people to create such roots however.
        //
        if (fArgRemFtRoot == TRUE || fSwRemFtRoot == TRUE) {
            dwErr = CmdRemRoot(
                        TRUE,
                        pwszServerName,
                        pwszShareName,
                        pwszLogicalName); // logical name may differ.
            break;
        } 


        if (fSwClean) {
            dwErr = CmdClean( pwszServerName, pwszShareName );
            break;
        }

        if ((Mode == MODE_DIRECT) || (Mode == MODE_EITHER))
        {
            dwErr = CmdInitializeDirectMode( &CoInitialized);

            if (dwErr != ERROR_SUCCESS)
            {
                DirectModeFailStatus = dwErr;
                if (Mode == MODE_DIRECT)
                {
                    DebugInformation((L"DfsUtil: Failed direct communication with DFS metadata, status 0x%x\n", dwErr));
                    ErrorMessage(MSG_ROOT_DIRECT_FAILED, dwErr);
                    break;
                }
                else if (CmdRequiresDirect == TRUE)
                {
                    ErrorMessage(MSG_ROOT_DIRECT_REQUIRED_FAILED, dwErr);
                    break;
                }
                else
                {
                    Mode = MODE_API;
                }
            }
            else
            {
                    DirectModeInitialized = TRUE;
            }
        }

        if (CmdRequiresDirect && (DirectModeInitialized == FALSE)) 
        {
            ErrorMessage(MSG_ROOT_DIRECT_REQUIRED);
            break;
        }

        if (fSwUpdateWin2kStaticSiteTable)
        {
            DfsRoot *pOperateRoot = NULL;
            dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                  DCToUse,
                                                  Mode,
                                                  TRUE, // site aware
                                                  &pOperateRoot);
            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = ProcessRootForSite(pOperateRoot );
            }

            if(pOperateRoot)
            {
                pOperateRoot->Close();
            }
            break;
        }


        if (fSwPurgeWin2kStaticSiteTable)
        {
            DfsRoot *pOperateRoot = NULL;
            dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                  DCToUse,
                                                  Mode,
                                                  FALSE,
                                                  &pOperateRoot);
            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = PurgeSiteInformationForRoot(pOperateRoot );
            }

            if(pOperateRoot)
            {
                pOperateRoot->Close();
            }
            break;
        }
        
        if (fSwShowWin2kStaticSiteTable)

        {
            DfsRoot *pOperateRoot = NULL;
            PVOID pBuffer = NULL;
            ULONG Size = 0;

            dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                  DCToUse,
                                                  Mode,
                                                  FALSE,
                                                  &pOperateRoot);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = pOperateRoot->RootGetSiteBlob(&pBuffer, &Size);
            }

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = DumpSiteBlob((PVOID)pBuffer, Size, TRUE);
            }
            if(pOperateRoot)
            {
                pOperateRoot->Close();
            }
            break;
        }

        //
        // Importing a namespace from a script file.
        //
        if (fArgImport) {

            DfsRoot *pMasterRoot;
            DfsRoot *pOperateRoot;

            dwErr = DfsReadDocument( ImportFile,
                                     &pMasterRoot );

            if (dwErr == ERROR_SUCCESS)
            {
                if (fSwBlobSize)
                {
                    ULONG RootBlobSize = 0;

                    extern DFSSTATUS SizeRoot(DfsRoot *pRoot, PULONG pSize);

                    dwErr = SizeRoot(pMasterRoot, &RootBlobSize);
                    if (dwErr == ERROR_SUCCESS)
                    {
                        ShowInformation((L"\n\nApproximate blob size for import file is %.2f Megabytes\n\n",
                                         (DOUBLE)RootBlobSize / (1024 * 1024)));

                    }
                }
                else if (fSwView)
                {
                    DumpRoots(pMasterRoot, ShowHandle, FALSE);
                }
                else 
                {
                    dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                          DCToUse,
                                                          Mode,
                                                          FALSE,
                                                          &pOperateRoot );

                    if (dwErr == ERROR_SUCCESS)
                    {
                        // 
                        // Iterate over the (real) options.
                        //
                        if (fSwCompare)
                        {
                            VerifyDfsRoots(pOperateRoot, pMasterRoot);
                        }
                        else if (fSwSet)
                        {
                            dwErr = SetDfsRoots(pOperateRoot, pMasterRoot, BackupHandle, fSwNoBackup);
                        }
                        else if (fSwMerge)
                        {
                            dwErr = MergeDfsRoots( pOperateRoot, pMasterRoot, BackupHandle, fSwNoBackup);
                        }
                        
                        pOperateRoot->Close();
                    }
                }
                pMasterRoot->Close();
            }
            break;
            
        }
        else if (fArgImportRoot) 
        {
            DfsRoot *pMasterRoot;
            DfsRoot *pOperateRoot;
            
            dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                  DCToUse,
                                                  Mode,
                                                  FALSE,
                                                  &pOperateRoot );

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = DfsBuildNameSpaceInformation( &MasterNameSpace,
                                                      DCToUse,
                                                      Mode,
                                                      FALSE,
                                                      &pMasterRoot );
      
                if ((dwErr == ERROR_SUCCESS) &&
                    (fSwVerbose == TRUE))
                {
                    DumpRoots( pMasterRoot, ShowHandle, FALSE);
                }

                if (dwErr == ERROR_SUCCESS)
                {
                    // 
                    // Iterate over the (real) options.
                    //
                    if (fSwCompare)
                    {
                        VerifyDfsRoots(pOperateRoot, pMasterRoot);
                    }
                    
                    else if (fSwMirror)
                    {
                        dwErr = SetDfsRoots(pOperateRoot, pMasterRoot, BackupHandle, fSwNoBackup);
                    }
                    pMasterRoot->Close();
                }
                pOperateRoot->Close();
            }
                    
            break;
        }
        else if (fArgDisplayBlob)
        {
            dwErr = DfsReadFromFile( DisplayBlobFile );          
            break;
        }
        else if (fArgExportBlob)
        {
            dwErr = DfsReadFromAD( OperateNameSpace.GetServerString(),
                                   OperateNameSpace.GetShareString(),
                                   ExportBlobFile,
                                   DCToUse);
            break;
        }
        else if (fSwCheckBlob)
        {  
            dwErr = DfsReadFromAD( OperateNameSpace.GetServerString(),
                                   OperateNameSpace.GetShareString(),
                                   NULL,
                                   DCToUse);
            break;
        }
        else if (fSwView)
        {
            if (fArgDomain) 
            {
                dwErr = DfsEnumerateDomainDfs(pwszDomainName);
            }
            else if (fArgServer) 
            {
               dwErr = DfsEnumerateMachineDfs(pwszServerName);
            }
            else
            {
                DfsRoot *pOperateRoot;

                dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                      DCToUse,
                                                      Mode,
                                                      TRUE,
                                                      &pOperateRoot );
                if (dwErr == ERROR_SUCCESS) 
                {
                    dwErr = DumpRoots( pOperateRoot, ShowHandle, FALSE);

                    pOperateRoot->Close();
                }
            }
            break;
        }
        else if (fArgExport) 
        {
            DfsRoot *pOperateRoot;
            
            dwErr = DfsBuildNameSpaceInformation( &OperateNameSpace,
                                                  DCToUse,
                                                  Mode,
                                                  FALSE,
                                                  &pOperateRoot );
            if (dwErr == ERROR_SUCCESS) 
            {
                dwErr = DumpRoots( pOperateRoot, ExportHandle, TRUE);

                pOperateRoot->Close();
            }           
            
            break;
        }




        if (fSwRenameFtRoot) {
            PVOID DirectModeHandle = NULL;
            
            dwErr = DfsDirectApiOpen( OperateNameSpace.GetPathString(), 
                                      DCToUse,
                                      &DirectModeHandle);

            if (dwErr == ERROR_SUCCESS)
            {
                //
                // Now do the rename. Note that we only use the first component.
                // If users enter /olddomain:\\xx.y.com\z we simply use xx.y.com without
                // the \\ or the sharename.
                //
                dwErr = DfsRenameLinksToDomain( &OperateNameSpace,
                                                OldDomainName.GetServerString(),
                                                NewDomainName.GetServerString());
                if (dwErr == ERROR_SUCCESS) 
                {
                    SetDirectHandleWriteable(DirectModeHandle);
                    dwErr = DfsDirectApiCommitChanges( DirectModeHandle);
                }
                DfsDirectApiClose( DirectModeHandle);
            }
            break;
        }

        if (fSwUnmapFtRoot) {
            dwErr = CmdUnmapRootReplica( OperateNameSpace.GetPathString(),
                                         pwszServerName, 
                                         pwszShareName );

            break;
        }

        if (fArgSiteName)
        {
            DfsString Site;

            dwErr = GetSites( ClientForSiteName.GetString(),
                              &Site );

            if (dwErr == ERROR_SUCCESS)
            {
                ShowInformation((L"\n\nSite for %wS is %wS\n\n",
                                 ClientForSiteName.GetString(),
                                 Site.GetString()));
            }
            break;
        }

        if (fSwInsite || fSwSiteCosting || fSwRootScalability)
        {
            PVOID DirectModeHandle = NULL;
            ULONG Attrib = 0;
            ULONG AttribMask = 0;
            LPWSTR AttribString;

            if (fSwInsite)
            {
                AttribMask = PKT_ENTRY_TYPE_INSITE_ONLY;
                AttribString = L"InSite Referrals";
            }
            else if (fSwSiteCosting)
            {
                AttribMask = PKT_ENTRY_TYPE_COST_BASED_SITE_SELECTION;
                AttribString = L"Cost-based Site Selection";
            }
            else
            {
                AttribMask = PKT_ENTRY_TYPE_ROOT_SCALABILITY;
                AttribString = L"Root Scalability";
            }

            dwErr = DfsDirectApiOpen( OperateNameSpace.GetPathString(), 
                                      DCToUse,
                                      &DirectModeHandle);


            if (dwErr == ERROR_SUCCESS)
            {

                dwErr = DfsExtendedRootAttributes( DirectModeHandle,
                                                   &Attrib,
                                                   OperateNameSpace.GetRemainingCountedString(),
                                                   FALSE );
                if (dwErr == ERROR_SUCCESS) {
                    
                    if (fSwDisplay) {
                        MyPrintf(L"Namespace %ws: %ws %ws\n",
                                 OperateNameSpace.GetPathString(),
                                 AttribString,
                                 ((Attrib & AttribMask) == AttribMask) ? L"ENABLED" : L"DISABLED");
                    } else {

                        SetDirectHandleWriteable(DirectModeHandle);

                        if (fSwEnable)  Attrib |= AttribMask;
                        else         Attrib &= ~AttribMask;

                        dwErr = DfsExtendedRootAttributes( DirectModeHandle,
                                                           &Attrib,
                                                           OperateNameSpace.GetRemainingCountedString(),
                                                           TRUE );
                        if (dwErr == ERROR_SUCCESS)
                        {
                            dwErr = DfsDirectApiCommitChanges( DirectModeHandle);
                        }

                        if (dwErr == ERROR_SUCCESS)
                        {
                            (VOID) ReSynchronizeRootTargetsFromPath(&OperateNameSpace);
                        }
                    }
                }
                
                DfsDirectApiClose( DirectModeHandle);
            }
            else if (fSwInsite)
            {
                DWORD PrevErr = dwErr; // Save this error in case of failure

                DebugInformation((L"Failure getting Windows .Net ExtendedAttributes for %wZ, Status 0x%x\n",
                    OperateNameSpace.GetPathCountedString(), dwErr));

                // Get the existing attrs. The root name will have to match although it's win2k.
                dwErr = DfsExtendedWin2kRootAttributes( &OperateNameSpace, &Attrib, FALSE );
                if (dwErr == ERROR_SUCCESS)
                {
                    if (fSwDisplay) {
                        MyPrintf(L"Namespace %ws: %ws %ws\n",
                                 OperateNameSpace.GetPathString(),
                                 AttribString,
                                 ((Attrib & AttribMask) == AttribMask) ? L"ENABLED" : L"DISABLED");
                    } 
                    else
                    {
                        if (fSwEnable)  Attrib |= AttribMask;
                        else         Attrib &= ~AttribMask;

                        // Set or reset this attr.
                        dwErr = DfsExtendedWin2kRootAttributes( &OperateNameSpace, &Attrib, TRUE );
                    }
                }
                
                //
                // If we couldn't find a win2k root by this name, then return the original error.
                //
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = PrevErr;
                }
            }
            
            break;
        }

        if (fSwPurgeMupCache) {

            dwErr = PurgeMupCache(NULL);
            break;
        }
        
        dwErr = Usage();

    } while( FALSE );



    if (CoInitialized) 
    {
        CoUninitialize();    
    }


    
    if (dwErr == ERROR_SUCCESS) {
        if (CommandSucceeded) {
            ErrorMessage( MSG_SUCCESSFUL );
        } else {
            ErrorMessage( MSG_COMMAND_DONE );
        }
    } else {
        LPWSTR MessageBuffer;
        DWORD dwBufferLength;

        dwBufferLength = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPWSTR) &MessageBuffer,
                            0,
                            NULL);

        ErrorMessage(MSG_ERROR, dwErr);
        if (dwBufferLength > 0) {
            MyPrintf(L"%ws\r\n", MessageBuffer);
            LocalFree(MessageBuffer);
        }
        ErrorMessage( MSG_COMMAND_DONE );
    }
    WPP_CLEANUP();
    return dwErr;
}


//
//  This is a laborious function that checks the current
//  argument for a match. DfsDbgPrints here are just
//  examples of random optimism: the /Verbose option has to
//  come before the current argument in order for those
//  lines to get printed.
//
BOOLEAN
CmdProcessArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN Terminate = FALSE;
    BOOLEAN FoundAnArg = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;

    if ( Arg != NULL && wcslen(Arg) > 1) {

        Terminate = FALSE;
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgRemFtRoot, ArgLenRemFtRoot) == 0) {
            FoundAnArg = fArgRemFtRoot = TRUE;
            if (ArgLen > ArgLenRemFtRoot)
                pwszLogicalName = &Arg[ArgLenRemFtRoot];
        } else if (_wcsnicmp(Arg, ArgShare, ArgLenShare) == 0) {
            FoundAnArg = fArgShare = TRUE;
            if (ArgLen > ArgLenShare)
                pwszShareName = &Arg[ArgLenShare];
            if (pwszLogicalName == NULL)
                pwszLogicalName = pwszShareName;
        } else if (_wcsnicmp(Arg, ArgServer, ArgLenServer) == 0) {
            FoundAnArg = fArgServer = TRUE;
            if (ArgLen > ArgLenServer)
                pwszServerName = &Arg[ArgLenServer];
        } else if (_wcsnicmp(Arg, ArgDomain, ArgLenDomain) == 0) {
            FoundAnArg = fArgDomain = TRUE;
            if (ArgLen > ArgLenDomain)
                pwszDomainName = &Arg[ArgLenDomain];
        } else if (_wcsnicmp(Arg, ArgPktFlush, ArgLenPktFlush) == 0) {
            FoundAnArg = fArgPktFlush = TRUE;
            if (ArgLen > ArgLenPktFlush)
                pwszEntryToFlush = &Arg[ArgLenPktFlush];
        } else if (_wcsnicmp(Arg, ArgSpcFlush, ArgLenSpcFlush) == 0) {
            FoundAnArg = fArgSpcFlush = TRUE;
            if (ArgLen > ArgLenSpcFlush)
                pwszEntryToFlush = &Arg[ArgLenSpcFlush];
        } else if (_wcsnicmp(Arg, ArgLevel, ArgLenLevel) == 0) {
            FoundAnArg = fArgLevel = TRUE;
            if (ArgLen > ArgLenLevel)
                pwszHexValue = &Arg[ArgLenLevel];
        }
        
        //
        //  DfsAdmin options
        //

        else if (_wcsnicmp(Arg, ArgImport, ArgLenImport) == 0)
        {
            FoundAnArg = fArgImport = TRUE;
            ImportFile = &Arg[ArgLenImport];
            if (wcslen(ImportFile) == 0)
            {
                ErrorMessage( MSG_USAGE_IMPORT );
                Terminate = TRUE;
                ImportFile = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgDisplayBlob, ArgLenDisplayBlob) == 0)
        {
            FoundAnArg = fArgDisplayBlob = TRUE;
            DisplayBlobFile = &Arg[ArgLenDisplayBlob];
            if (wcslen(DisplayBlobFile) == 0)
            {
                ErrorMessage( MSG_USAGE_DISPLAY_BLOB );
                Terminate = TRUE;
                ImportFile = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgExportBlob, ArgLenExportBlob) == 0)
        {
            FoundAnArg = fArgExportBlob = TRUE;
            ExportBlobFile = &Arg[ArgLenExportBlob];
            if (wcslen(ExportBlobFile)==0)
            {
                ErrorMessage( MSG_USAGE_EXPORT_BLOB );
                Terminate = TRUE;
                ExportBlobFile = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgExport, ArgLenExport) == 0)
        {
            FoundAnArg = fArgExport = TRUE;
            ExportFile = &Arg[ArgLenExport];
            if (wcslen(ExportFile) == 0)
            {
                ErrorMessage( MSG_USAGE_EXPORT );
                Terminate = TRUE;
                ExportFile = NULL;
            }
            else 
            {
                Status = CreateDfsFile(ExportFile, &ExportHandle);
            }
        }
        else if (_wcsnicmp(Arg, ArgBackup, ArgLenBackup) == 0)
        {
            FoundAnArg = fArgBackup = TRUE;
            BackupFile = &Arg[ArgLenBackup];
            if (wcslen(BackupFile) == 0)
            {
                ErrorMessage( MSG_USAGE_EXPORT );
                Terminate = TRUE;
                BackupFile = NULL;
            }
            else 
            {
                Status = CreateDfsFile(BackupFile, &BackupHandle);
            }
        }
        else if (_wcsnicmp(Arg, ArgDebugDC, ArgLenDebugDC) == 0)
        {
            FoundAnArg = fArgDebugDC = TRUE;
            DCToUse = &Arg[ArgLenDebugDC];
            Status = GetDCInformation();
            Mode = MODE_DIRECT;
        }
        else if (_wcsnicmp(Arg, ArgRoot, ArgLenRoot) == 0)
        {
            FoundAnArg = fArgRoot = TRUE;
            Status = OperateNameSpace.CreatePathName(&Arg[ArgLenRoot]);
        }
        else if (_wcsnicmp(Arg, ArgImportRoot, ArgLenImportRoot) == 0)
        {
            FoundAnArg = fArgImportRoot = TRUE;
            Status = MasterNameSpace.CreatePathName(&Arg[ArgLenImportRoot]);
        }
        else if (_wcsnicmp(Arg, ArgDebugFile, ArgLenDebugFile) == 0)
        {
            FoundAnArg = fArgDebugFile = TRUE;
            DebugFile = &Arg[ArgLenDebugFile];
            if (wcslen(DebugFile) == 0)
            {
                //Status = ERROR_INVALID_PARAMETER;
                Terminate = TRUE;
                DebugFile = NULL;
            }
            else {
                Status = CreateDfsFile(DebugFile, &DebugHandle);
            }
        }
        else if (_wcsnicmp(Arg, ArgOldDomain, ArgLenOldDomain) == 0)
        {
            FoundAnArg = fArgOldDomain = TRUE;
            Status = OldDomainName.CreatePathName( &Arg[ArgLenOldDomain] );
        }
        else if (_wcsnicmp(Arg, ArgNewDomain, ArgLenNewDomain) == 0)
        {
            FoundAnArg = fArgNewDomain = TRUE;
            Status = NewDomainName.CreatePathName( &Arg[ArgLenNewDomain] );
        }   
        else if (_wcsnicmp(Arg, ArgUnmapFtRoot, ArgLenUnmapFtRoot) == 0)
        {
            FoundAnArg = fArgUnmapFtRoot = TRUE;
        }
        else if (_wcsnicmp(Arg, ArgViewDfsDirs, ArgLenViewDfsDirs) == 0) {
            FoundAnArg = fArgViewDfsDirs = TRUE;
            pwszVolumeName = &Arg[ArgLenViewDfsDirs];
        }/*
        else if (_wcsnicmp(Arg, ArgRemoveReparse, ArgLenRemoveReparse) == 0) {
            FoundAnArg = fArgRemoveReparse = TRUE;
            pwszDfsDirectoryName = &Arg[ArgLenRemoveReparse];
        }*/
        else if (_wcsnicmp(Arg, ArgSiteName, ArgLenSiteName) == 0)
        {
            FoundAnArg = fArgSiteName = TRUE;
            Status = ClientForSiteName.CreateString(&Arg[ArgLenSiteName]);
        }


        
        // Switches go at the end!!

        else if (_wcsicmp(Arg, SwDebug) == 0) {
            FoundAnArg = fSwDebug = TRUE;
        }
        else if (_wcsicmp(Arg, SwNoBackup) == 0) {
            FoundAnArg = fSwNoBackup = TRUE;
        } else if (_wcsicmp(Arg, SwVerbose) == 0) {
            FoundAnArg = fSwVerbose = TRUE;
        } else if (_wcsicmp(Arg, SwPktFlush) == 0) {
            FoundAnArg = fSwPktFlush = TRUE;
        } else if (_wcsicmp(Arg, SwSpcFlush) == 0) {
            FoundAnArg = fSwSpcFlush = TRUE;
        } else if (_wcsicmp(Arg, SwPktInfo) == 0) {
            FoundAnArg = fSwPktInfo = TRUE;
        } else if (_wcsicmp(Arg, SwSpcInfo) == 0) {
            FoundAnArg = fSwSpcInfo = TRUE;
        } else if (_wcsicmp(Arg, SwDfs) == 0) {
            FoundAnArg = fSwDfs = TRUE;
        } else if (_wcsicmp(Arg, SwAll) == 0) {
            FoundAnArg = fSwSpcInfo = TRUE;    
        } else if (_wcsicmp(Arg, SwQ) == 0) {
            FoundAnArg = fSwQ = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwScriptHelp) == 0) {
            FoundAnArg = fSwScriptHelp = TRUE;
        } else if (_wcsicmp(Arg, SwHelp) == 0) {
            FoundAnArg = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwSet) == 0) {
            FoundAnArg = fSwSet = TRUE;
        } else if (_wcsicmp(Arg, SwMirror) == 0) {
            FoundAnArg = fSwMirror = TRUE;
        } else if (_wcsicmp(Arg, SwRemStdRoot) == 0) {
            FoundAnArg = fSwRemStdRoot = TRUE;
        } else if (_wcsicmp(Arg, SwRemFtRoot) == 0) {
            FoundAnArg = fSwRemFtRoot = TRUE;
        } else if (_wcsicmp(Arg, SwCompare) == 0) {
            FoundAnArg = fSwCompare = TRUE;
        } else if (_wcsicmp(Arg, SwCheckBlob) == 0) {
            FoundAnArg = fSwCheckBlob = TRUE;
        } else if (_wcsicmp(Arg, SwMerge) == 0) {
            FoundAnArg = fSwMerge = TRUE;
        } else if (_wcsicmp(Arg, SwRenameFtRoot) == 0) {
            FoundAnArg = fSwRenameFtRoot = TRUE;
            CmdRequiresDirect = TRUE;
        } else if (_wcsicmp(Arg, SwDirect) == 0) {
            //
            // This is switched on by default when appropriate.
            // If the user specifies this then it means that
            // she only wants to operate in Direct mode.
            //
            FoundAnArg = TRUE;
            fSwDirect = TRUE;
            UserRequiresDirectMode = TRUE;
            Mode = MODE_DIRECT;
        } else if (_wcsicmp(Arg, SwView) == 0) {
            FoundAnArg = fSwView = TRUE;
            ExportHandle = ShowHandle;
        } else if (_wcsicmp(Arg, SwImport) == 0) {
            FoundAnArg = fSwImport = TRUE;
        } else if (_wcsicmp(Arg, SwImportRoot) == 0) {
            FoundAnArg = fSwImportRoot = TRUE;
        } else if (_wcsicmp(Arg, SwBlobSize) == 0) {
            FoundAnArg = fSwBlobSize = TRUE;
        } else if (_wcsicmp(Arg, SwSiteName) == 0) {
            FoundAnArg = fSwSiteName = TRUE;
        } else if (_wcsicmp(Arg, SwExport) == 0) {
            FoundAnArg = fSwExport = TRUE;
        } else if (_wcsicmp(Arg, SwRoot) == 0) {
            FoundAnArg = fSwRoot = TRUE;
        } else if ((_wcsicmp(Arg, SwUnmapFtRoot) == 0) ||
                  (_wcsicmp(Arg, SwUnmap) == 0)) {
            FoundAnArg = fSwUnmapFtRoot = TRUE;
            CmdRequiresDirect = TRUE;
        } else if (_wcsicmp(Arg, SwClean) == 0) {
            //
            // This contacts the target registry directly but doesn't involve a
            // direct mode to do so.
            //
            FoundAnArg = fSwClean = TRUE;
        } else if (_wcsicmp(Arg, SwEnable) == 0) {
            FoundAnArg = fSwEnable = TRUE;
        } else if (_wcsicmp(Arg, SwDisable) == 0) {
            FoundAnArg = fSwDisable = TRUE;
        }  else if (_wcsicmp(Arg, SwDisplay) == 0) {
            FoundAnArg = fSwDisplay = TRUE;
        } else if (_wcsicmp(Arg, SwInsite) == 0) {
            FoundAnArg = fSwInsite = TRUE;
            CmdRequiresDirect = TRUE;
            
        } else if (_wcsicmp(Arg, SwAddStdRoot) == 0) {
            FoundAnArg = fSwAddStdRoot = TRUE;
        } else if (_wcsicmp(Arg, SwAddFtRoot) == 0) {
            FoundAnArg = fSwAddFtRoot = TRUE;
        } else if (_wcsicmp(Arg, SwApi) == 0) {
            FoundAnArg = fSwApi = TRUE;
            Mode = MODE_API;
        } else if (_wcsicmp(Arg, SwRemoveReparse) == 0) {
            FoundAnArg = fSwRemoveReparse = TRUE;
        } else if (_wcsicmp(Arg, SwSiteCosting) == 0) {
            FoundAnArg = fSwSiteCosting = TRUE;
            CmdRequiresDirect = TRUE;
        } else if (_wcsicmp(Arg, SwRootScalability) == 0) {
            FoundAnArg = fSwRootScalability = TRUE;
            CmdRequiresDirect = TRUE;
        } else if (_wcsicmp(Arg, SwPurgeMupCache) == 0) {
            FoundAnArg = fSwPurgeMupCache = TRUE;
        }
        else if (_wcsicmp(Arg, SwUpdateWin2kStaticSiteTable) == 0) {
            FoundAnArg = fSwUpdateWin2kStaticSiteTable = TRUE;
            CmdRequiresDirect = TRUE;
        }
        else if (_wcsicmp(Arg, SwShowWin2kStaticSiteTable) == 0) {
            FoundAnArg = fSwShowWin2kStaticSiteTable = TRUE;
            CmdRequiresDirect = TRUE;
        }
        else if (_wcsicmp(Arg, SwPurgeWin2kStaticSiteTable) == 0) {
            FoundAnArg = fSwPurgeWin2kStaticSiteTable = TRUE;
            CmdRequiresDirect = TRUE;
        }
        else if (_wcsicmp(Arg, SwViewDfsDirs) == 0) {
            FoundAnArg = fSwViewDfsDirs = TRUE;
        }
        else if (_wcsicmp(Arg, SwDisplayBlob) == 0) {
            FoundAnArg = fSwDisplayBlob = TRUE;
        }
        else if (_wcsicmp(Arg, SwExportBlob) == 0) {
            FoundAnArg = fSwExportBlob = TRUE;
        }

        //
        // Done processing Arguments and Switches. 
        // Decide whether to terminate or not.
        //
        if (FoundAnArg == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, &Arg[1]);
            Terminate = TRUE;
        }

        if (Status != ERROR_SUCCESS)
        {
            ErrorMessage(MSG_ERROR, Status);
            Terminate = TRUE;
        }
    }

    return Terminate;
}

DWORD
Usage()
{

    ErrorMessage(MSG_USAGE);

    return ERROR_SUCCESS;
}

DFSSTATUS
CmdCheckSyntax( BOOLEAN& Done )
{

    // the following require a namespace to work with
    // BlobSize cmd works without a root.
    #define REQUIRES_ROOT_NAME (fArgExport || fSwRenameFtRoot || fSwInsite || fSwMirror || \
                               (fArgImport && !fSwBlobSize) || \
                               fSwSiteCosting || fArgDebugDC || \
                               fArgImportRoot || fSwRootScalability || \
                               fArgExportBlob || fSwCheckBlob)

    DFSSTATUS dwErr = ERROR_SUCCESS;
    Done = FALSE;
    
    do {
        if ((fSwHelp == TRUE) || 
           ((OperateNameSpace.IsEmptyPath() == TRUE) && (REQUIRES_ROOT_NAME) ))
        {
        
            if (fArgImport || fSwImport || fSwBlobSize) {
                ErrorMessage( MSG_USAGE_IMPORT );
            } else if (fArgExport || fSwExport) {
                ErrorMessage( MSG_USAGE_EXPORT );
            } else if (fSwRenameFtRoot) {
                ErrorMessage( MSG_USAGE_RENAME );
            } else if (fSwUnmapFtRoot) {
                ErrorMessage( MSG_USAGE_UNMAP );
            } else if (fSwClean) {
                ErrorMessage( MSG_USAGE_CLEAN );
            } else if (fSwInsite) {
                ErrorMessage( MSG_USAGE_INSITE );
            } else if (fSwSiteCosting) {
                ErrorMessage( MSG_USAGE_SITECOSTING );
            } else if (fSwAddFtRoot || fSwAddStdRoot) {
                ErrorMessage( MSG_USAGE_ADDROOT );
            } else if (fSwRemFtRoot || fArgRemFtRoot) {
                ErrorMessage( MSG_USAGE_REM_FTROOT );
            } else if (fSwRemStdRoot) {
                ErrorMessage( MSG_USAGE_REM_STDROOT );
            } else if (fArgSiteName || fSwSiteName) {
                ErrorMessage( MSG_USAGE_SITENAME );
            } else if (fSwView) {
                ErrorMessage( MSG_USAGE_VIEW );
            } else if (fArgImportRoot || fSwImportRoot) {
                ErrorMessage( MSG_USAGE_IMPORT_ROOT);
            } else if (fSwCheckBlob) {
                ErrorMessage( MSG_USAGE_CHECK_BLOB );
            } else if (fSwExportBlob || fArgExportBlob) {
                ErrorMessage( MSG_USAGE_EXPORT_BLOB );
            } else if (fSwDisplayBlob || fArgDisplayBlob) {
                ErrorMessage( MSG_USAGE_DISPLAY_BLOB );
            } else if (fSwRootScalability) {
                ErrorMessage( MSG_USAGE_ROOT_SCALABILITY );
            } else if (fSwViewDfsDirs || fArgViewDfsDirs) {
                ErrorMessage( MSG_USAGE_VIEW_DIRS );
            } else if (fSwRemoveReparse) {
                ErrorMessage( MSG_USAGE_VIEW_DIRS );
            } else if (fSwPurgeMupCache) {
                ErrorMessage( MSG_USAGE_PURGE_MUP_CACHE );
            } else if (fSwUpdateWin2kStaticSiteTable ||
                      fSwPurgeWin2kStaticSiteTable ||
                      fSwShowWin2kStaticSiteTable) {
                ErrorMessage( MSG_USAGE_W2K_SITETABLE );
            } else if (fSwPktInfo) {
                ErrorMessage( MSG_USAGE_PKT_INFO );
            } else if (fSwPktFlush) {
                ErrorMessage( MSG_USAGE_PKT_FLUSH );
            } else if (fSwSpcInfo) {
                ErrorMessage( MSG_USAGE_SPC_INFO );
            } else if (fSwSpcFlush) {
                ErrorMessage( MSG_USAGE_SPC_FLUSH );
            } else {
                dwErr = Usage();
            }
            Done = TRUE;
            break;
        }

        if (fSwView) 
        {
            if (!(fArgDomain || fArgRoot || fArgServer || fArgImport)) 
            {
                ErrorMessage(MSG_USAGE_VIEW);
                Done = TRUE;
                break;
            }
        }


        // Set, merge and verify work with import.
        if (fArgImport) {
        
           if (!(fSwSet || fSwMerge || fSwCompare || fSwView || fSwBlobSize)) {

                MyPrintf(L"You must specify one of /View, /Set, /Merge, /BlobSize or /Compare to Import\n");
                ErrorMessage( MSG_USAGE_IMPORT );
                Done = TRUE;
                break;
           }

        }

        if (fSwInsite) {
            if (!(fSwEnable || fSwDisable || fSwDisplay)) {
                MyPrintf(L"You must specify one of /Enable, /Disable or /Display with /Insite command.\n");
                ErrorMessage( MSG_USAGE_INSITE );
                Done = TRUE;
                break;
            }

            if (OperateNameSpace.IsEmptyPath() == TRUE)
            {
                MyPrintf(L"You must specify a DFS root with /Insite command.\n");
                ErrorMessage( MSG_USAGE_INSITE );
                Done = TRUE;
                break;
            }
            if (fSwApi) {
                MyPrintf(L"Insite command does not work in the /Api mode. Use default.\n");
                ErrorMessage( MSG_USAGE_INSITE );
                Done = TRUE;
                break;
            }
        } else if (fSwSiteCosting) {
            if (!(fSwEnable || fSwDisable || fSwDisplay)) {
                MyPrintf(L"You must specify one of /Enable, /Disable or /Display with /SiteCosting command.\n");
                ErrorMessage( MSG_USAGE_SITECOSTING );
                Done = TRUE;
                break;
            }
            if ((OperateNameSpace.IsEmptyPath() == TRUE) ||
                (IsEmptyString(OperateNameSpace.GetRemainingString()) == FALSE))
            {
                MyPrintf(L"You must specify a well-formed DFS root with /SiteCosting command.\n");
                ErrorMessage( MSG_USAGE_SITECOSTING );
                Done = TRUE;
                break;
            }

            if (fSwApi) {
                MyPrintf(L"SiteCosting command does not work in the /Api mode. Use default.\n");
                ErrorMessage( MSG_USAGE_SITECOSTING );
                Done = TRUE;
                break;
            }
        } else if (fSwRootScalability) {
            if (!(fSwEnable || fSwDisable || fSwDisplay)) {
                MyPrintf(L"You must specify one of /Enable, /Disable or /Display with /RootScalability command.\n");
//                ErrorMessage( MSG_USAGE_ROOTSCALABILITY);
                Done = TRUE;
                break;
            }
            if ((OperateNameSpace.IsEmptyPath() == TRUE) ||
                (IsEmptyString(OperateNameSpace.GetRemainingString()) == FALSE))
            {
                MyPrintf(L"You must specify a DFS root with /RootScalability command.\n");
//                ErrorMessage( MSG_USAGE_ROOTSCALABILITY);
                Done = TRUE;
                break;
            }

            if (fSwApi) {
                MyPrintf(L"RootScalability command does not work in the /Api mode. Use default.\n");
//                ErrorMessage( MSG_USAGE_ROOTSCALABILITY);
                Done = TRUE;
                break;
            }
        }   
  

        // These three dont work with any other command (except for /Set with Insite).
        else if ((fSwSet || fSwMerge) &&
                (!fArgImport)) {

           MyPrintf(L"/Set and /Merge options apply only to /Import: command.\n");
           Done = TRUE;
           break;
        }
        else if ((fSwMirror) &&
                (!fArgImportRoot)) {

           MyPrintf(L"/Mirror option applies only to /ImportRoot: command.\n");
           Done = TRUE;
           break;
        }
        else if ((fSwCompare) &&
                ((!fArgImportRoot) && (!fArgImport))) {

           MyPrintf(L"/Compare option applies only to /Import: or /ImportRoot: commands.\n");
           Done = TRUE;
           break;
        }


        if ((fSwView) &&
            (fArgExport || fSwRenameFtRoot)) {

            MyPrintf(L"The /View command cannot be combined with others.\n");
            Usage();
            Done = TRUE;
            break;
        }

        if (fSwRenameFtRoot) {

            if (NewDomainName.IsEmptyPath() == TRUE ||
               OldDomainName.IsEmptyPath() == TRUE ||
               (OperateNameSpace.IsEmptyPath() == TRUE))
            {
                ErrorMessage( MSG_USAGE_RENAME );
                Done = TRUE;
                break;
            }
            DebugInformation((L"DfsUtil: New domain name will be %wS\n", NewDomainName.GetServerString()));
            DebugInformation((L"DfsUtil: Old domain to be renamed is %wS\n", OldDomainName.GetServerString()));
        }   
                         


        if ((fArgUnmapFtRoot) || // Arg gets an automatic usage.

            ((fSwUnmapFtRoot) &&
             ( (OperateNameSpace.IsEmptyPath() == TRUE) ||
               (pwszServerName == NULL) ||
               (pwszShareName == NULL)))) {

              ErrorMessage( MSG_USAGE_UNMAP );
              Done = TRUE;
              break;
        }

        if ((fArgClean) || // Arg gets an automatic usage.

            ((fSwClean) &&
             ((pwszServerName == NULL) ||
              (pwszShareName == NULL)))) {

              ErrorMessage( MSG_USAGE_CLEAN );
              Done = TRUE;
              break;
        }

        if (fSwClean)
        {
            DWORD Status;
            
            //
            // We don't allow domain names here. That can lead to incorrect
            // results as well as data loss.
            //
            Status = IsThisADomainName( pwszServerName, NULL );
            if (Status == ERROR_SUCCESS)
            {
                MyPrintf(L"/Server: parameter must be the name of a DFS root server. It cannot be a domain name\n");
                ErrorMessage( MSG_USAGE_CLEAN );
                Done = TRUE;
                break;
            }
        }
        
        if ( fSwAddStdRoot && 
            (IsEmptyString( pwszServerName ) || IsEmptyString( pwszShareName ))) {
            MyPrintf(L"You must specify a valid target server and a share for the new root\n");
            ErrorMessage( MSG_USAGE_ADDROOT );
            Done = TRUE;
            break;
        }

        if ((fArgRemFtRoot || fSwRemFtRoot || fSwRemStdRoot) && 
            (IsEmptyString( pwszServerName ) || IsEmptyString( pwszShareName ))) {

            MyPrintf(L"You must specify a valid target server and a share to remove.\n");
            if (fSwRemStdRoot)
                ErrorMessage( MSG_USAGE_REM_STDROOT );
            else
                ErrorMessage( MSG_USAGE_REM_FTROOT );
            
            Done = TRUE;
            break;
        }

        /*if ((fArgRemoveReparse) && // Arg gets an automatic usage.

              (pwszDfsDirectoryName == NULL)) {
               MyPrintf(L"You must specify a volume name\n");
              Done = TRUE;
              break;
        }*/

        if (fArgViewDfsDirs) {
            if (pwszVolumeName == NULL) {
                MyPrintf(L"You must specify a directory name\n");
                Done = TRUE;
                break;
            }
            if (wcschr(pwszVolumeName, ':') == NULL) {
                MyPrintf(L"The volume drive letter must contain a colon at the end.\n");
                ErrorMessage( MSG_USAGE_VIEW_DIRS );
                Done = TRUE;
                break;
            }
        }

        //
        // If at this point we have a root:\\x\y, we need to make sure that we have
        // exactly two path components. It is too cumbersome to use REQUIRES_ROOT_NAME
        // check here because there are options like /View that needs /Root only for some cases.
        //
        if ((OperateNameSpace.IsEmptyPath() != TRUE) &&
            ((IsEmptyString(OperateNameSpace.GetShareString()) == TRUE) ||
             (IsEmptyString(OperateNameSpace.GetRemainingString()) == FALSE)) &&
            (fSwInsite == FALSE))
            {
                MyPrintf(L"Root must be of the form \\\\DomainOrServer\\RootName.\n");
                Done = TRUE;
                break;
            }

        if (OperateNameSpace.IsEmptyPath() != TRUE)
        {
            //
            // Now that we have valid args, check to see if there are any exceptions to
            // the rules we've applied so far. For example, we Standalone roots
            // and Direct mode won't mix well for some switches of /Import cmd.
            //
            dwErr = CmdCheckExceptions( &OperateNameSpace );
            if (dwErr != ERROR_SUCCESS)
            {
                Done = TRUE;
                break;
            }
        }

        if (MasterNameSpace.IsEmptyPath() != TRUE)
        {
            dwErr = CmdCheckExceptions( &MasterNameSpace );
            if (dwErr != ERROR_SUCCESS)
            {
                Done = TRUE;
                break;
            }
        }
        
        if (fArgDebugDC != NULL)
        {
            if (DCInfoStatus != ERROR_SUCCESS)
            {
                MyPrintf(L"Could not get information from DC %wS, error 0x%x\n",
                         DCToUse, DCInfoStatus);
                Done = TRUE;
                break;
            }
            if (OperateNameSpace.IsEmptyPath() != TRUE)
            {
                if (DfsIsThisADomainName(OperateNameSpace.GetServerString()) == ERROR_SUCCESS)
                {
                    if ((RtlCompareUnicodeString(OperateNameSpace.GetServerCountedString(), &DCToUseFlatDomainName, TRUE) != 0)
                         &&
                         (RtlCompareUnicodeString(OperateNameSpace.GetServerCountedString(), &DCToUseDNSDomainName, TRUE) != 0))
                    {
                        MyPrintf(L"DC %ws belongs to %wZ domain, and not to %wS domain\n",
                                 DCToUse, &DCToUseDNSDomainName, OperateNameSpace.GetServerString());

                        Done = TRUE;
                        break;
                    }
                }
            }
            if (MasterNameSpace.IsEmptyPath() != TRUE)
            {   
                if (DfsIsThisADomainName(MasterNameSpace.GetServerString()) == ERROR_SUCCESS)
                {
                    if ((RtlCompareUnicodeString(MasterNameSpace.GetServerCountedString(), &DCToUseFlatDomainName, TRUE) != 0)
                         &&
                         (RtlCompareUnicodeString(MasterNameSpace.GetServerCountedString(), &DCToUseDNSDomainName, TRUE) != 0))
                    {
                        MyPrintf(L"DC %ws belongs to %wZ domain, and not to %wS domain\n",
                                 DCToUse, &DCToUseDNSDomainName, MasterNameSpace.GetServerString());
                        Done = TRUE;
                        break;

                    }
                }
            }
        
        }
        
    } while (FALSE);

    return dwErr;
}

DFSSTATUS
CmdInitializeDirectMode(
    PBOOLEAN pCoInitialized)
{
    DFSSTATUS Status;
    HRESULT Hr = S_OK;
    
    *pCoInitialized = FALSE;

    Hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    if (Hr == S_OK)
    {
        *pCoInitialized = TRUE;
        Status = DfsServerLibraryInitialize(DFS_DIRECT_MODE|DFS_DONT_SUBSTITUTE_PATHS);
    }
    else
    {
        Status = DfsGetErrorFromHr(Hr);
    }

    return Status;
}


DWORD
ReSynchronizeRootTargets(
    IN LPWSTR PathString)
{
    DfsPathName PathName;
    DFSSTATUS Status;

    Status = PathName.CreatePathName(PathString);
    if (Status == ERROR_SUCCESS)
    {
        Status = ReSynchronizeRootTargetsFromPath(&PathName);
    }
    return Status;
}


DWORD
ReSynchronizeRootTargetsFromPath(
    IN DfsPathName *pPathName)
{
    DFSSTATUS Status, SetStatus;
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = 1;
    DWORD Level = 4;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i; 
    PDFS_STORAGE_INFO pStorage;
    LPWSTR DfsPathString;

    DfsPathString = pPathName->GetPathString();
    //
    // We are reading in just the ROOT.
    //
    Status = DfsApiEnumerate( MODE_DIRECT,
                              DfsPathString, 
                              Level, 
                              PrefMaxLen, 
                              &pBuffer, 
                              &EntriesRead, 
                              &ResumeHandle);
    
    if ((Status == ERROR_SUCCESS) && EntriesRead != 0)
    {   
        pCurrentBuffer = (PDFS_INFO_4)pBuffer;

        //
        // Now contact the appropriate server(s) for the root replicas
        // and ask them to re-read their roots. Things have been
        // changed under them.
        //
        
        for( i = 0, pStorage = pCurrentBuffer->Storage;
            i < pCurrentBuffer->NumberOfStorages;
            i++, pStorage = pCurrentBuffer->Storage + i )
        {
            SetStatus = SetInfoReSynchronize( pStorage->ServerName, 
                                              pPathName->GetShareString());
            
            //
            //  We just go on to the next server since we don't do any undo's anyway.
            //
            if (SetStatus != ERROR_SUCCESS)
                Status = SetStatus;
        }

        //
        // Free the allocated memory.
        //

        DfsFreeApiBuffer(pBuffer);

    }    
    
    return Status;
}



//
// the following code exists to read and write the old style static
// site table in the AD blob.
//
//
typedef struct _DFS_SITE_UPDATE
{
    UNICODE_STRING Server;
    UNICODE_STRING Site;
    struct _DFS_SITE_UPDATE *pNext;
} DFS_SITE_UPDATE, *PDFS_SITE_UPDATE;

DFS_SITE_UPDATE *pSiteList = NULL;
PDFS_SITE_UPDATE pSiteNext = NULL;
struct _DFS_PREFIX_TABLE *pServerSiteTable;


VOID
DumpSiteInformation(
    PUNICODE_STRING pServer,
    PUNICODE_STRING pSite )
{
    ShowInformation((L"Server %wZ, Site %wZ\n", pServer, pSite));
}

DFSSTATUS
DumpSiteBlob(
    PVOID pBuffer,
    ULONG Size,
    BOOLEAN Display )
{

    PVOID pUseBuffer = pBuffer;
    ULONG RemainingSize = Size;
    GUID SiteGuid;
    UNICODE_STRING Server, Site;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Objects = 0, SiteNum, NumSites, Flags;

    if (Size == 0)
    {
        if (Display)
        {
            ShowInformation((L"\nSite Blob with %d sites\n", Objects));
        }
        return Status;
    }

    Status = PackGetGuid(&SiteGuid, &pUseBuffer, &RemainingSize);
    if (Status == ERROR_SUCCESS)
    {
        Status = PackGetULong( &Objects, &pUseBuffer, &RemainingSize );
    }

    if (Display)
    {
        ShowInformation((L"\nSite Blob with %d sites\n", Objects));
    }
    if (Status == ERROR_SUCCESS)
    {
        for (SiteNum = 0; SiteNum < Objects; SiteNum++)
        {
            Status = PackGetString( &Server, &pUseBuffer, &RemainingSize);
            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &NumSites, &pUseBuffer, &RemainingSize);
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &Flags, &pUseBuffer, &RemainingSize);
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetString( &Site, &pUseBuffer, &RemainingSize);
            }
            if (Status != ERROR_SUCCESS)
            {
                break;
            }

            if (Display)
            {
                DumpSiteInformation(&Server, &Site);
            }
        }
    }
    return Status;
}


DFSSTATUS
AddServerToSiteList(
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pSiteName )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN Insert = FALSE;
    PDFS_SITE_UPDATE pSiteUpdate;
    UNICODE_STRING RemainingName;
    PVOID pData;
    BOOLEAN SubStringMatch;
    DFSSTATUS Status = ERROR_SUCCESS;



    NtStatus = DfsPrefixTableAcquireWriteLock( pServerSiteTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( pServerSiteTable,
                                               pServerName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );
        if (NtStatus != STATUS_SUCCESS)
        {
            Insert = TRUE;

            NtStatus = DfsInsertInPrefixTableLocked( pServerSiteTable,
                                                     pServerName,
                                                     pSiteName);
        }
        else
        {
            Insert = FALSE;
            NtStatus = STATUS_SUCCESS;
        }
        DfsPrefixTableReleaseLock( pServerSiteTable );
    }

    if (NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    if (Status == ERROR_SUCCESS)
    {
        if (Insert)
        {
            pSiteUpdate = new DFS_SITE_UPDATE;

            if (pSiteUpdate == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodeString( &pSiteUpdate->Server, pServerName);
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodeString( &pSiteUpdate->Site, pSiteName);
            }

            if (Status == ERROR_SUCCESS)
            {
                pSiteUpdate->pNext = NULL;

                if (pSiteList == NULL)
                {
                    pSiteList = pSiteUpdate;

                }
                else
                {
                    pSiteNext->pNext = pSiteUpdate;
                }
                pSiteNext = pSiteUpdate;
            }
        }
    }

    return Status;
}


DFSSTATUS
ProcessTargetForSite(
    DfsTarget *pTarget )
{
    PUNICODE_STRING pServer, pSite;
    DFSSTATUS Status = ERROR_SUCCESS;

    for (;
         pTarget != NULL;
         pTarget = pTarget->GetNextTarget())
    {
        pServer = pTarget->GetTargetServerCountedString();
        pSite = pTarget->GetTargetSiteCountedString();
        if (pSite->Length != 0)
        {
            Status = AddServerToSiteList( pServer, pSite);
        }
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
    }
    return Status;
}


ULONG
SizeSiteInformationBlob(
    PDFS_SITE_UPDATE pSiteUpdate)
{
    ULONG Size = 0;

    Size += PackSizeString(&pSiteUpdate->Server);
    Size += PackSizeULong();
    Size += PackSizeULong();
    Size += PackSizeString(&pSiteUpdate->Site);

    return Size;
}


DFSSTATUS
UpdateSiteBlob(
    DfsRoot *pRoot)
{
    PDFS_SITE_UPDATE pSiteUpdate;

    GUID NewGuid;
    ULONG TotalObjects = 0;
    DFSSTATUS Status;
    ULONG SiteBlobSize;
    PBYTE pBuffer;
    PVOID pUseBuffer;
    ULONG SizeRemaining;

    pSiteUpdate = pSiteList;

    Status = UuidCreate(&NewGuid);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    SiteBlobSize = sizeof(ULONG) + sizeof(GUID);

    pSiteUpdate = pSiteList;
    while (pSiteUpdate != NULL)
    {
        SiteBlobSize += SizeSiteInformationBlob(pSiteUpdate);
        TotalObjects++;
        pSiteUpdate = pSiteUpdate->pNext;
    }

    pBuffer = new BYTE[SiteBlobSize];
    if (pBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pUseBuffer = pBuffer;
    SizeRemaining = SiteBlobSize;

    Status = PackSetGuid( &NewGuid, &pUseBuffer, &SizeRemaining);
    if (Status == ERROR_SUCCESS)
    {
        Status = PackSetULong( TotalObjects, &pUseBuffer, &SizeRemaining );
    }

    pSiteUpdate = pSiteList;
    while (pSiteUpdate != NULL)
    {
        Status = PackSetString( &pSiteUpdate->Server, &pUseBuffer, &SizeRemaining );
        if (Status == ERROR_SUCCESS)
        {
            //
            // We allow only 1 site information for each server.
            //
            Status = PackSetULong( 1, &pUseBuffer, &SizeRemaining );
        }

        if (Status == ERROR_SUCCESS)
        {
            //
            // Flags: alwyas 0.
            //

            Status = PackSetULong( 0, &pUseBuffer, &SizeRemaining );
        }


        if (Status == ERROR_SUCCESS)
        {
            Status = PackSetString( &pSiteUpdate->Site, &pUseBuffer, &SizeRemaining );
        }

        pSiteUpdate = (PDFS_SITE_UPDATE)(pSiteUpdate->pNext);
    }


    if (Status == ERROR_SUCCESS)
    {
        PUNICODE_STRING pRootToUpdate = pRoot->GetLinkNameCountedString();
        pRoot->SetRootApiName(pRootToUpdate);
        pRoot->SetRootWriteable();

        Status = pRoot->RootSetSiteBlob(pBuffer, SiteBlobSize);
        if (Status == ERROR_SUCCESS)
        {
            Status = pRoot->UpdateMetadata();
        }
    }

    delete [] pBuffer;

    return Status;
}


DFSSTATUS
PurgeSiteBlob(
    DfsRoot *pRoot)
{
    PDFS_SITE_UPDATE pSiteUpdate = NULL;

    GUID NewGuid;
    ULONG TotalObjects = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG SiteBlobSize = 0;
    PBYTE pBuffer = NULL;
    PVOID pUseBuffer = NULL;
    ULONG SizeRemaining = 0;

    pSiteUpdate = pSiteList;

    Status = UuidCreate(&NewGuid);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    SiteBlobSize = sizeof(ULONG) + sizeof(GUID);

    pBuffer = new BYTE[SiteBlobSize];
    if (pBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pUseBuffer = pBuffer;
    SizeRemaining = SiteBlobSize;

    Status = PackSetGuid( &NewGuid, &pUseBuffer, &SizeRemaining);
    if (Status == ERROR_SUCCESS)
    {
        Status = PackSetULong( TotalObjects, &pUseBuffer, &SizeRemaining );
    }


    if (Status == ERROR_SUCCESS)
    {
        PUNICODE_STRING pRootToUpdate = pRoot->GetLinkNameCountedString();
        pRoot->SetRootApiName(pRootToUpdate);
        pRoot->SetRootWriteable();

        Status = pRoot->RootSetSiteBlob(pBuffer, SiteBlobSize);
        if (Status == ERROR_SUCCESS)
        {
            pRoot->UpdateMetadata();
        }
    }

    delete [] pBuffer;

    return Status;
}




DFSSTATUS
ProcessRootForSite(
    DfsRoot *pRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsLink *pLink = NULL;


    Status = DfsInitializePrefixTable( &pServerSiteTable,
                                       FALSE, 
                                       NULL );
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    Status = ProcessTargetForSite(pRoot->GetFirstTarget());

    if (Status == ERROR_SUCCESS)
    {
        for (pLink = pRoot->GetFirstLink();
             pLink != NULL;
             pLink = pLink->GetNextLink())
        {
            Status = ProcessTargetForSite( pLink->GetFirstTarget());
            if (Status != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = UpdateSiteBlob(pRoot);
    }
    return Status;
}

DFSSTATUS
PurgeSiteInformationForRoot(
    DfsRoot *pRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsInitializePrefixTable( &pServerSiteTable,
                                       FALSE, 
                                       NULL );
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }


    if (Status == ERROR_SUCCESS)
    {
        Status = PurgeSiteBlob(pRoot);
    }
    return Status;
}

DFSSTATUS
IsRootStandalone( 
    DfsPathName *Namespace,
    BOOLEAN& IsStandalone )
{
    DFSSTATUS Status;
    LPBYTE  pBuffer = NULL;
    DWORD RootFlavor = 0;
    
    IsStandalone = FALSE;
    Status = NetDfsGetInfo( Namespace->GetPathCountedString()->Buffer, NULL, NULL, 3, &pBuffer );

    if (Status == ERROR_SUCCESS) {
        RootFlavor = ((PDFS_INFO_3)pBuffer)->State & DFS_VOLUME_FLAVORS;

        //
        // There is no real easy way to find out the type of a Win2K root. The FLAVORS bit
        // is post-win2k. In that case, err on the safe side and return Standalone.
        //
        if (RootFlavor == 0)
        {
            DebugInformation((L"NetDfsGetInfo returns 0 for DFS_VOLUME_FLAVORS. Assuming a standalone root\n"));
            IsStandalone = TRUE;
        }
        else if (RootFlavor == DFS_VOLUME_FLAVOR_STANDALONE) 
        {
            IsStandalone = TRUE;
        }
        NetApiBufferFree( pBuffer );
    }

    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   IsThisADomainName
//
//  Synopsis:   Calls the mup to have it check the special name table to see if the
//              name matches a domain name.  Returns a list of DC's in the domain,
//              as a list of strings.  The list is terminated with a double-null.
//
//  Arguments:  [wszName] -- Name to check
//              [ppList]  -- Pointer to pointer for results.
//
//  Returns:    [ERROR_SUCCESS] -- Name is indeed a domain name.
//
//              [ERROR_FILE_NOT_FOUND] -- Name is not a domain name
//
//-----------------------------------------------------------------------------

DWORD
IsThisADomainName(
    IN LPWSTR wszName,
    OUT PWCHAR *ppList OPTIONAL)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    HANDLE DriverHandle = NULL;
    DWORD dwErr;
    PCHAR OutBuf = NULL;
    ULONG Size = 0x100;
    ULONG Count = 0;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (!NT_SUCCESS(NtStatus)) {
        return ERROR_FILE_NOT_FOUND;
    }

Retry:

    OutBuf = (PCHAR)malloc(Size);

    if (OutBuf == NULL) {

        NtClose(DriverHandle);
        return ERROR_NOT_ENOUGH_MEMORY;

    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   wszName,
                   (wcslen(wszName) + 1) * sizeof(WCHAR),
                   OutBuf,
                   Size
               );

    if (NtStatus == STATUS_SUCCESS) {

        dwErr = ERROR_SUCCESS;

    } else if (NtStatus == STATUS_BUFFER_OVERFLOW && ++Count < 5) {

        Size = *((ULONG *)OutBuf);
        free(OutBuf);
        goto Retry;
    
    } else {

        dwErr = ERROR_FILE_NOT_FOUND;

    }

    NtClose(DriverHandle);

    if (ppList == NULL)
    {
        free(OutBuf);
        OutBuf = NULL;
    }
    else
    {
        *ppList = (WCHAR *)OutBuf;
    }
    
    return dwErr;
}

DFSSTATUS
CmdCheckExceptions( 
    DfsPathName *pNameSpace)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // 733898 : disable /Import and /ImportRoot writable operations
    // over direct mode for standalone roots. This is so that 
    // we won't race with DfsSvc's synchronize and possibly
    // create inconsistencies. 
    // Besides since direct mode registry blob updates aren't 
    // 'atomic' import can create inconsistencies anyway.
    //
    if ((fArgImport && (fSwSet || fSwMerge)) 
        || 
       (fArgImportRoot && (fSwMirror)))
    {
        BOOLEAN IsStandalone = FALSE;
        do  {
            Status = IsRootStandalone( pNameSpace, IsStandalone );

            // Err on the safe side if we get an error doing GetInfo.
            if (Status != ERROR_SUCCESS || (IsStandalone))
            {
                if (UserRequiresDirectMode)
                {
                    MyPrintf(L"Import /Set, /Merge and ImportRoot /Mirror commands on Standalone roots must use API mode.\n");
                    ErrorMessage( MSG_USAGE_IMPORT );
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }

                DebugInformation((L"%ws is a Standalone root. Switching to API mode for this operation.\n", 
                                pNameSpace->GetPathCountedString()->Buffer));
                Mode = MODE_API;
            }

            // Don't return GetInfo errors. Those aren't fatal.
            Status = ERROR_SUCCESS;
      
        } while (FALSE);
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\flush.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       flush.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include "struct.hxx"
#include "dfsfsctl.h"
#include "messages.h"
#include <dfsutil.hxx>
#include "misc.hxx"

WCHAR wszEverything[] = L"*";

DWORD
PktFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    DebugInformation((L"PktFlush(%ws)\r\n", EntryPath));

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    DebugInformation((L"EntryPath=[%ws]\r\n", EntryPath));

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        DebugInformation((L"NtCreateFile returned 0x%x\r\n", NtStatus));
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        DebugInformation((L"NtFsControlFile returned 0x%x\r\n", NtStatus));
        ErrorMessage(NtStatus);
    } else {
        CommandSucceeded = TRUE;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (dwErr != ERROR_SUCCESS)
        DebugInformation((L"PktFlush exit %d\r\n", dwErr));

    return(dwErr);
}

DWORD
SpcFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    DebugInformation((L"SpcFlush(%ws)\r\n", EntryPath));

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        DebugInformation((L"NtCreateFile returned 0x%x\r\n", NtStatus));
        goto Cleanup;
    }

    DebugInformation((L"EntryPath=[%ws]\r\n", EntryPath));

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_SPC_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        DebugInformation((L"NtFsControlFile returned 0x%x\r\n", NtStatus));
    } else {
        CommandSucceeded = TRUE;
    }
    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (dwErr != ERROR_SUCCESS)
        DebugInformation((L"SpcFlush exit %d\r\n", dwErr));

    return(dwErr);
}


DWORD
PurgeMupCache(
    LPWSTR ServerName)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    //
    // Currently no server name is ever sent.
    //
    DebugInformation((L"PurgeMupCache(%ws)\r\n", ServerName));

    if (ServerName == NULL)
        ServerName = L"*";

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        DebugInformation((L"NtCreateFile returned 0x%x\r\n", NtStatus));
        goto Cleanup;
    }

    DebugInformation((L"ServerName=[%ws]\r\n", ServerName));

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CSC_SERVER_ONLINE,
                   ServerName,
                   wcslen(ServerName) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        DebugInformation((L"NtFsControlFile returned 0x%x\r\n", NtStatus));
    } else {
        CommandSucceeded = TRUE;
    }
    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (dwErr != ERROR_SUCCESS)
        DebugInformation((L"PurgeMupCache exit %d\r\n", dwErr));

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\dfswin2k.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       misc.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include <dfsprefix.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
}
#include <DfsServerLibrary.hxx>
#include <DfsRegStrings.hxx>
#include "struct.hxx"
#include "flush.hxx"
#include "misc.hxx"
#include "messages.h"

#include <strsafe.h>

#include <dfsutil.hxx>
#include <DfsBlobInfo.hxx>

#include "dfspathname.hxx"

DFSSTATUS
GetWin2kStandaloneMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PDFS_NAME_INFORMATION pNameInfo);


DFSSTATUS
SetWin2kStandaloneMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize );

DFSSTATUS 
GetDfsRegistryKey( IN LPWSTR MachineName,
                   IN LPWSTR LocationString,
                   BOOLEAN WritePermission,
                   OUT BOOLEAN *pMachineContacted,
                   OUT PHKEY pDfsRegKey );
DFSSTATUS
GetRootPhysicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootPhysicalShare );



DFSSTATUS
GetRootPhysicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootPhysicalShare )
{
    DFSSTATUS Status;
    ULONG DataSize, DataType;
    LPWSTR DfsRootShare = NULL;

    Status = RegQueryInfoKey( RootKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        DfsRootShare = (LPWSTR) new BYTE [DataSize];
        if ( DfsRootShare == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( RootKey,
                                      DFS_REG_ROOT_SHARE_VALUE,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)DfsRootShare,
                                      &DataSize );
        }
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (DataType == REG_SZ)
        {
            RtlInitUnicodeString( pRootPhysicalShare, DfsRootShare );
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        if (DfsRootShare != NULL)
        {
            delete [] DfsRootShare;
        }
    }
    return Status;
}

DFSSTATUS 
GetDfsRegistryKey( IN LPWSTR MachineName,
                   IN LPWSTR LocationString,
                   BOOLEAN WritePermission,
                   OUT BOOLEAN *pMachineContacted,
                   OUT PHKEY pDfsRegKey )
{
    DFSSTATUS Status;
    HKEY RootKey;
    BOOLEAN Contacted = FALSE;
    LPWSTR UseMachineName = NULL;
    REGSAM DesiredAccess = KEY_READ;

    if (WritePermission == TRUE)
    {
        DesiredAccess |= KEY_WRITE;
    }

    if (IsEmptyString(MachineName) == FALSE) {
        UseMachineName = MachineName;
    }

    Status = RegConnectRegistry( UseMachineName,
                                 HKEY_LOCAL_MACHINE,
                                 &RootKey );

    if ( Status == ERROR_SUCCESS )
    {
        Contacted = TRUE;

        Status = RegOpenKeyEx( RootKey,
                               LocationString,
                               0,
                               DesiredAccess,
                               pDfsRegKey );

        //
        // There appears to be a bug in the registry code. When
        // we connect to the local machine, the key that is returned
        // in the RegConnectRegistry is HKEY_LOCAL_MACHINE. If we
        // then attempt to close it here, it affects other threads
        // that are using this code: they get STATUS_INVALID_HANDLE
        // in some cases. So, dont close the key if it is
        // HKEY_LOCAL_MACHINE.
        //

        if (RootKey != HKEY_LOCAL_MACHINE)
        {
            RegCloseKey( RootKey );
        }
    } 

    if (pMachineContacted != NULL)
    {
        *pMachineContacted = Contacted;
    }
    return Status;
}

DFSSTATUS
CreateNameInformationBlob(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    OUT PVOID *ppBlob,
    OUT PULONG pDataSize )
{
    PVOID pBlob = NULL;
    PVOID pUseBlob = NULL;
    ULONG BlobSize = 0;
    ULONG UseBlobSize = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    BlobSize = PackSizeNameInformation( pDfsNameInfo );

    pBlob = (PVOID) new BYTE[BlobSize];
    if (pBlob == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pUseBlob = pBlob;
    UseBlobSize = BlobSize;

    // Pack the name information into the binary stream allocated.
    //
    Status = PackSetStandaloneNameInformation( pDfsNameInfo,
                                     &pUseBlob,
                                     &UseBlobSize );
    if (Status != ERROR_SUCCESS)
    {
        delete [] pBlob;
        pBlob = NULL;
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppBlob = pBlob;
        *pDataSize = BlobSize - UseBlobSize;
    }

    return Status;
}

DFSSTATUS
DfsSetWin2kStdNameInfo(
    HKEY DomainRootKey,
    LPWSTR LinkName,
    PDFS_NAME_INFORMATION pNameInfo)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pBlob = NULL;
    ULONG BlobSize = 0;

    
    Status = CreateNameInformationBlob( pNameInfo,
                                    &pBlob,
                                    &BlobSize );
    
    if (Status != ERROR_SUCCESS)
    {
        DebugInformation((L"Error 0x%x creating registry blob with NameInfo\n", Status));
        return Status;
    }
    
    
    if (Status == ERROR_SUCCESS)
    {
        Status = SetWin2kStandaloneMetadata( DomainRootKey, 
                                    LinkName, // Can be NULL for roots
                                    L"ID",
                                    pBlob,
                                    BlobSize );

        if (Status == ERROR_SUCCESS)
        {
            DebugInformation((L"Successfully wrote changes to the Windows2000 standalone root\n"));
        }
        else
        {
            DebugInformation((L"Error 0x%x writing changes to the Windows2000 standalone root\n", Status));
        }
    }

    delete [] pBlob;
    
    return Status;
}

#if 0
DFSSTATUS
DfsGetWin2kStdReplicaInfo(
    LPWSTR MachineName,
    PDFS_REPLICA_LIST_INFORMATION pReplicaInfo)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY VolumesKey = NULL;
    BOOLEAN MachineContacted = FALSE;
    PVOID pBlob = NULL;
    ULONG BlobSize = 0;

    Status = GetDfsRegistryKey (MachineName,
                                      DFS_REG_OLD_HOST_LOCATION,
                                      FALSE,
                                      &MachineContacted,
                                      &VolumesKey );
       

    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    
    Status = GetWin2kStandaloneMetadata( VolumesKey, 
                                DFS_REG_OLD_STANDALONE_CHILD,
                                L"Svc",
                                &pBlob,
                                &BlobSize );
    RegCloseKey( VolumesKey );
    
    RtlZeroMemory (pReplicaInfo, sizeof(DFS_REPLICA_LIST_INFORMATION));

    Status = PackGetULong( &pReplicaInfo->ReplicaCount,
                           &pBlob,
                           &BlobSize );
    if (Status == ERROR_SUCCESS)
    {
        pReplicaInfo->pReplicas = new DFS_REPLICA_INFORMATION[ pReplicaInfo->ReplicaCount];
        if ( pReplicaInfo->pReplicas != NULL )
        {
            Status = PackGetReplicaInformation( pReplicaInfo, 
                                               &pBlob,
                                               &BlobSize );
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        DumpReplicaInformation( pReplicaInfo );
        delete [] pReplicaInfo->pReplicas;
    }
    
    return Status;
}
#endif


DFSSTATUS
DfsGetWin2kStdLinkNameInfo(
    HKEY DomainRootKey,
    PUNICODE_STRING pLinkName,
    PBOOLEAN pLinkFound,
    LPWSTR *pChildGuidName,
    PDFS_NAME_INFORMATION pNameInfo)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG ChildNum = 0;
    DWORD CchMaxName = 0;
    DWORD CchChildName = 0;
    LPWSTR ChildName = NULL;

    *pLinkFound = FALSE;
    
    //
    // First find the length of the longest subkey 
    // and allocate a buffer big enough for it.
    //
    Status = RegQueryInfoKey( DomainRootKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              &CchMaxName,  // max size of subkey name in TCHARs
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              NULL,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        // Space for the NULL terminator.
        CchMaxName++; 

        ChildName = (LPWSTR) new WCHAR [CchMaxName];
        if (ChildName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    do
    {
        //
        // For each child, get the child name.
        //

        CchChildName = CchMaxName;

        Status = RegEnumKeyEx( DomainRootKey,
                               ChildNum,
                               ChildName,
                               &CchChildName,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        ChildNum++;

        //
        // Read in the child link and see if that's the link we need.
        //
        if ( Status == ERROR_SUCCESS )
        {
            UNICODE_STRING PrefixName;
              
            Status = GetWin2kStandaloneMetadata( DomainRootKey, 
                                               ChildName,
                                               L"ID",
                                               pNameInfo);
            if (Status == ERROR_SUCCESS)
            {
                DumpNameInformation( pNameInfo );

                // Skip the leading '\'s if any.
                PrefixName = pNameInfo->Prefix;
                while (PrefixName.Buffer[0] == UNICODE_PATH_SEP)
                {
                    PrefixName.Buffer++;
                    PrefixName.Length -= sizeof(WCHAR);
                }
                
                if (RtlCompareUnicodeString( &PrefixName, pLinkName, TRUE ) == 0)
                {
                    *pLinkFound = TRUE;
                    *pChildGuidName = ChildName;
                    Status = ERROR_SUCCESS;
                    break;
                }
                else
                {
                    // Go on to the next link
                    DebugInformation((L"Found W2k Link %wZ, doesn't match %wZ\n", &PrefixName, pLinkName));
                }
            }
        }

    } while ( Status == ERROR_SUCCESS );

    if (*pLinkFound == FALSE)
    {
        delete [] ChildName;
        Status = ERROR_PATH_NOT_FOUND;
    }
 
    return Status;
}

DFSSTATUS
DfsGetWin2kStdNameInfo(
    HKEY VolumesKey,
    HKEY DomainRootKey,
    PUNICODE_STRING pShareName,
    PDFS_NAME_INFORMATION pNameInfo)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING W2kRootName;


    // Look at DfsHost\volumes-> RootShare key to get at the root name.
    Status = GetRootPhysicalShare( VolumesKey, &W2kRootName );
    if (Status == ERROR_SUCCESS)
    {
        // We need to find a matching share. Win2k has only one root.
        if (RtlCompareUnicodeString( &W2kRootName, pShareName, TRUE ) == 0)
        {
            Status = GetWin2kStandaloneMetadata( DomainRootKey, 
                                            NULL,
                                            L"ID",
                                            pNameInfo);
        }
        else
        {
            Status = ERROR_PATH_NOT_FOUND;
            DebugInformation((L"Found W2k root %wZ, doesn't match %wZ\n", &W2kRootName, pShareName));
        }

        delete [] W2kRootName.Buffer;
    }
    
    return Status;
}


DFSSTATUS
GetWin2kStandaloneMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PDFS_NAME_INFORMATION pNameInfo)
{

    HKEY NewKey = NULL;
    HKEY UseKey = NULL;
    PVOID pDataBuffer = NULL;
    ULONG DataSize, DataType;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    if ( RelativeName != NULL )
    {
        Status = RegOpenKeyEx( DfsMetadataKey, 
                               RelativeName, 
                               0,
                               KEY_READ,
                               &NewKey );
        if ( Status == ERROR_SUCCESS )
        {
            UseKey = NewKey;
        }
        else
        {
            //DFS_TRACE_HIGH( REFERRAL_SERVER, "registry store, GetMetadata-RegOpenKeyEx %ws status=%d\n", RelativeName, Status);
        }
    } else
    {
        UseKey = DfsMetadataKey;
    }

    //
    // Get the largest size of any value under the key of interest, so we know
    // how much we need to allocate in the worst case.
    // (If a subkey has 3 values, this returns the maximum memory size required
    // to read any one of the values.)
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegQueryInfoKey( UseKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  NULL ); // Last write time
    }

    //
    // We have the required size now: allocate a buffer for that size and
    // read the value we are interested in.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pDataBuffer = new BYTE [DataSize];

        if ( pDataBuffer == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } 
        else
        {
            Status = RegQueryValueEx( UseKey,
                                      RegistryValueNameString, // eg. "ID"
                                      NULL,
                                      &DataType,
                                      (LPBYTE)pDataBuffer,
                                      &DataSize );
            //
            // If the format of data is not a certain type (usually binary type for DFS)
            // we have bogus data.
            //
            if ( (Status == ERROR_SUCCESS) && (DataType != DFS_REGISTRY_DATA_TYPE) )
            {
                Status = ERROR_INVALID_DATA;
            }
        }
    }

    //
    // If we are successful in reading the value, pass the allcoated buffer and
    // size back to caller. Otherwise, free up the allocate buffer and return
    // error status to the caller.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = PackGetStandaloneNameInformation( pNameInfo, &pDataBuffer, &DataSize );
    } 
  
    if ( pDataBuffer != NULL )
    {
        delete [] pDataBuffer;
        pDataBuffer = NULL;
    }
    

    //
    // If we did open a new key, it is time to close it now.
    //
    if ( NewKey != NULL )
        RegCloseKey(NewKey);


    return Status;
}


DFSSTATUS
SetWin2kStandaloneMetadata (
    IN HKEY DomainRootKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize )
{
    HKEY UseKey = DomainRootKey;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    if (RelativeName)
    {
        Status = RegOpenKeyEx( DomainRootKey, 
                           RelativeName, 
                           0,
                           KEY_READ | KEY_WRITE,
                           &UseKey );

    }
    
    //
    // Store the value against the passed in value string
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = RegSetValueEx( UseKey,
                                RegistryValueNameString,
                                NULL,
                                DFS_REGISTRY_DATA_TYPE,
                                (LPBYTE)pData,
                                DataSize );
        
        if (UseKey != DomainRootKey)
            RegCloseKey(UseKey);
    }

    return Status;
}

//
// Look at the Win2k standalone location on the remote
// machine to see if it has a matching root. If this is a
// set operation, the Type info will be changed. Else this
// returns existing Type attribute in NameInformation.
//
DFSSTATUS
DfsExtendedWin2kRootAttributes(
    DfsPathName *Namespace,
    PULONG pAttr,
    BOOLEAN Set)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFS_NAME_INFORMATION NameInfo;
    BOOLEAN PathFound = FALSE;
    LPWSTR ChildGuidName = NULL;
    HKEY VolumesKey = NULL;
    HKEY DomainRootKey = NULL;
    
        // Open DfsHost\volumes
    Status = GetDfsRegistryKey (Namespace->GetServerString(),
                              DFS_REG_OLD_HOST_LOCATION,
                              TRUE, // RW
                              NULL,
                              &VolumesKey );
       

    if (Status != ERROR_SUCCESS)
    {
        Status = ERROR_PATH_NOT_FOUND;
        return Status;
    }

    Status = RegOpenKeyEx( VolumesKey, 
                       DFS_REG_OLD_STANDALONE_CHILD, // 'domainroot', 
                       0,
                       KEY_READ|KEY_WRITE,
                       &DomainRootKey );

    if (Status != ERROR_SUCCESS)
    {
        RegCloseKey( VolumesKey ); 
        Status = ERROR_PATH_NOT_FOUND;
        return Status;
    }
    
    do {
        DebugInformation((L"Attempting to get Windows2000 standalone root information for %wZ\n", 
                        Namespace->GetPathCountedString()));
        Status = DfsGetWin2kStdNameInfo( VolumesKey,
                                        DomainRootKey,
                                        Namespace->GetShareCountedString(),
                                        &NameInfo );

        if (Status != ERROR_SUCCESS)
        {
            Status = ERROR_PATH_NOT_FOUND;
            break;
        }

        //DumpNameInformation( &NameInfo );
        
        // We've matched the root name so far. See if we need to find the link component.
        if (!IsEmptyUnicodeString( Namespace->GetRemainingCountedString() ))
        {
            Status = DfsGetWin2kStdLinkNameInfo( DomainRootKey,
                                              Namespace->GetFolderCountedString(),
                                              &PathFound,
                                              &ChildGuidName,
                                              &NameInfo );
            if (!PathFound)
            {
                Status = ERROR_PATH_NOT_FOUND;
                break;
            }
        }
        
        if (!Set)
        {
            *pAttr = NameInfo.Type & PKT_ENTRY_TYPE_EXTENDED_ATTRIBUTES;
        } 
        else
        {
            NameInfo.Type &= ~PKT_ENTRY_TYPE_EXTENDED_ATTRIBUTES;
            NameInfo.Type |= *pAttr;

            //DebugInformation((L"New name information type flags will be 0x%x\n", NameInfo.Type));
            Status = DfsSetWin2kStdNameInfo( DomainRootKey,
                                            ChildGuidName,  // NULL for roots
                                            &NameInfo );
        }
    } while (FALSE);

    RegCloseKey( DomainRootKey );
    RegCloseKey( VolumesKey );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\misc.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       misc.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include <dfsprefix.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
}
#include <DfsServerLibrary.hxx>
#include "struct.hxx"
#include "flush.hxx"
#include "misc.hxx"
#include "messages.h"

#include <strsafe.h>

#include <dfsutil.hxx>
#include "dfspathname.hxx"
#include "resapi.h"

#define MAX_BUF_SIZE    10000

WCHAR MsgBuf[MAX_BUF_SIZE];
CHAR  AnsiBuf[MAX_BUF_SIZE*3];

WCHAR wszRootShare[MAX_PATH+1] = { 0 };
#define WINLOGON_FOLDER L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SFCVALUE L"SFCDisable"
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))



DWORD
DfspGetLinkName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszLinkName);


DWORD
AtoHex(
    LPWSTR pwszHexValue,
    PDWORD pdwErr)
{
    DWORD dwHexValue = 0;
    DWORD DiscardResult;
    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex(%ws)\r\n", pwszHexValue);

    if (pwszHexValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    if (pwszHexValue[0] == L'0' && (pwszHexValue[1] == L'x' || pwszHexValue[1] == L'X'))
        pwszHexValue = &pwszHexValue[2];

    DiscardResult = swscanf(pwszHexValue, L"%x", &dwHexValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex returning 0x%x (dwErr=0x%x)\r\n", dwHexValue, *pdwErr);

    return dwHexValue;
}

DWORD
AtoDec(
    LPWSTR pwszDecValue,
    PDWORD pdwErr)
{
    DWORD dwDecValue = 0;
    DWORD DiscardResult;
    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec(%ws)\r\n", pwszDecValue);

    if (pwszDecValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    DiscardResult = swscanf(pwszDecValue, L"%d", &dwDecValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec returning 0x%x (dwErr=0x%x)\r\n", dwDecValue, *pdwErr);

    return dwDecValue;
}

DFSSTATUS
IsClusterNode(
    LPWSTR pNodeName,
    PBOOLEAN pIsCluster )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD ClusterState;

    *pIsCluster = FALSE;

    Status = GetNodeClusterState( pNodeName,
                                  &ClusterState );

    if (Status == ERROR_SUCCESS)
    {
        if ( (ClusterStateRunning == ClusterState) ||
             (ClusterStateNotRunning == ClusterState) )
        {
            *pIsCluster = TRUE;

        }
    }

    return Status;
}

#if 0
// We might enable this code in a more cluster friendly
// dfsutil version.
//
typedef struct _DFSUTIL_CLUSTER_CONTEXT {
    PUNICODE_STRING pShareName;
    BOOLEAN bIsClustered;
        
} DFSUTIL_CLUSTER_CONTEXT;

DWORD
DfsUtilClusterCallBackFunction(
    HRESOURCE hSelf,
    HRESOURCE hResource,
    PVOID Context)
{

    UNREFERENCED_PARAMETER( hSelf );

    HKEY HKey = NULL;
    HKEY HParamKey = NULL;
    DFSUTIL_CLUSTER_CONTEXT *pContext = (DFSUTIL_CLUSTER_CONTEXT *)Context;


    DWORD Status = ERROR_SUCCESS;
    DWORD Value = 0;

    pContext->bIsClustered = FALSE;
    HKey = GetClusterResourceKey(hResource, KEY_READ);

    if (HKey != NULL) {
        Status = ClusterRegOpenKey( HKey, 
                                    L"Parameters", 
                                    KEY_READ, 
                                    &HParamKey );

        ClusterRegCloseKey( HKey );

        if (ERROR_SUCCESS == Status)
        {
            LPWSTR ResShareName = NULL;
            UNICODE_STRING VsName;

            ResShareName = ResUtilGetSzValue( HParamKey,
                                              L"ShareName" );
            Status = DfsRtlInitUnicodeStringEx(&VsName, ResShareName);
            if(Status == ERROR_SUCCESS)
            {
                if (pContext->pShareName->Length == VsName.Length)
                {
                    Status = ResUtilGetDwordValue(HParamKey, L"IsDfsRoot", &Value, 0);

                    if ((ERROR_SUCCESS == Status)  &&
                        (Value == 1))
                    {

                        if (_wcsnicmp(pContext->pShareName->Buffer,
                                     VsName.Buffer,
                                     VsName.Length) == 0)
                        {
                           pContext->bIsClustered = TRUE;
                        }
                    }
                }
            }
            ClusterRegCloseKey( HParamKey );
        }
    }

    return Status;
}

DWORD
IsClusterRoot(
    LPWSTR pNodeName,
    PUNICODE_STRING pShareName,
    PBOOLEAN pIsClustered )

{
    DWORD Status;
    DFSUTIL_CLUSTER_CONTEXT Context;
    UNREFERENCED_PARAMETER(pNodeName);
    
    Context.pShareName = pShareName;
    Context.bIsClustered = FALSE;

    Status = ResUtilEnumResources(NULL,
                                  L"File Share",
                                  DfsUtilClusterCallBackFunction,
                                  (PVOID)&Context );
    if (Status == ERROR_SUCCESS)
    {
        *pIsClustered = Context.bIsClustered;
    }
    return Status;


}
#endif

DWORD
CmdAddRoot(
    BOOLEAN DomainDfs,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName,
    LPWSTR pwszRootName,
    LPWSTR pwszComment)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOLEAN bIsClustered = FALSE;
    
    DebugInformation((L"CmdAddRoot (%ws,%ws)\r\n", pwszServerName, pwszShareName));

    if (DomainDfs == FALSE)
    {
        // see if the server is a clustered node.
        dwErr = IsClusterNode( pwszServerName, &bIsClustered );
        if (dwErr == ERROR_SUCCESS && bIsClustered)
        {
            DebugInformation((L"Node %ws is in a cluster\r\n", pwszServerName));
            
        }

        if (!bIsClustered)
        {
            DebugInformation((L"<%ws, %ws> is not clustered. Calling NetDfsAddStdRoot\r\n", 
                            pwszServerName, pwszShareName));
            dwErr = NetDfsAddStdRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszComment,
                    0);;
        }
        else
        {
            MyPrintf(L"Node %ws belongs to a cluster environment. This command is not supported.\r\n", pwszServerName);
            dwErr = ERROR_NOT_SUPPORTED;
        }

    } else {
        dwErr = NetDfsAddFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszRootName,
                    pwszComment,
                    0);

    }
    DebugInformation((L"CmdAddRoot returning %d\r\n", dwErr));
    if (dwErr == ERROR_SUCCESS)
        CommandSucceeded = TRUE;
    return dwErr;
}


DWORD
CmdRemRoot(
    BOOLEAN DomDfs,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName,
    LPWSTR pwszRootName)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOLEAN bIsClustered = FALSE;
    
    DebugInformation((L"CmdRemRoot: Server %ws, Physical Share %ws, Logical Share %ws)\r\n",
                    pwszServerName, pwszShareName, pwszRootName));

    if (DomDfs == FALSE) 
    {
        // see if the server is a clustered node.
        dwErr = IsClusterNode( pwszServerName, &bIsClustered );
        if (dwErr == ERROR_SUCCESS && bIsClustered)
        {
            DebugInformation((L"Node %ws is in a cluster.\r\n", pwszServerName));            
        }

        if (!bIsClustered)
        {
            DebugInformation((L"<%ws, %ws> is not clustered. Calling NetDfsRemoveStdRoot\r\n", 
                            pwszServerName, pwszShareName));
            dwErr = NetDfsRemoveStdRoot(
                        pwszServerName,
                        pwszShareName,
                        0);
        }
        else
        {
            MyPrintf(L"Node %ws belongs to a cluster environment. This command is not supported.\r\n",pwszServerName);
            dwErr = ERROR_NOT_SUPPORTED;
        }
    } 
    else {
        dwErr = NetDfsRemoveFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszRootName,
                    0);

    }
    DebugInformation((L"CmdRemRoot returning %d\r\n", dwErr));
    if (dwErr == ERROR_SUCCESS)
        CommandSucceeded = TRUE;
    return dwErr;
}

VOID
MyFormatMessageText(
    HRESULT   dwMsgId,
    PWSTR     pszBuffer,
    DWORD     dwBufferSize,
    va_list   *parglist)
{
    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (dwReturn == 0 && fSwDebug)
        MyPrintf(L"Formatmessage failed 0x%x\r\n", GetLastError());
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...)
{
    ULONG cch;
    va_list arglist;

    HRESULT HResult;
    size_t CharacterCount;

    va_start(arglist, hr);
    MyFormatMessageText(hr, MsgBuf, ARRAYLEN(MsgBuf), &arglist);

    HResult = StringCchLength( MsgBuf,
                               MAX_BUF_SIZE,
                               &CharacterCount );

    if (SUCCEEDED(HResult)) 
    {
        cch = WideCharToMultiByte(CP_OEMCP, 0,
                                  MsgBuf, CharacterCount,
                                  AnsiBuf, MAX_BUF_SIZE*3,
                                  NULL, NULL);
        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    }

    va_end(arglist);
}

VOID
DfsVPrintToFile(
    HANDLE FileHandle,
    PWCHAR format,
    va_list va)
{
    ULONG cch;
    HRESULT HResult;
    size_t CharacterCount;
    
    HResult = StringCchVPrintf( MsgBuf,
                                MAX_BUF_SIZE,
                                format,
                                va );
    if (SUCCEEDED(HResult))
    {
        HResult = StringCchLength( MsgBuf,
                                   MAX_BUF_SIZE,
                                   &CharacterCount );
    }

    if (SUCCEEDED(HResult))
    {
        cch = WideCharToMultiByte(CP_OEMCP, 0,
                                  MsgBuf, CharacterCount,
                                  AnsiBuf, MAX_BUF_SIZE*3,
                                  NULL, NULL);
        WriteFile(FileHandle, AnsiBuf, cch, &cch, NULL);

    }

    return;
}


VOID
DfsVPrintWideToFile(
    HANDLE FileHandle,
    PWCHAR format,
    va_list va)
{
    ULONG cch;
    HRESULT HResult;
    size_t CharacterCount;
    
    HResult = StringCchVPrintf( MsgBuf,
                                MAX_BUF_SIZE,
                                format,
                                va );
    if (SUCCEEDED(HResult))
    {
        HResult = StringCchLength( MsgBuf,
                                   MAX_BUF_SIZE,
                                   &CharacterCount );
    }

    if (SUCCEEDED(HResult))
    {
        //cch = WideCharToMultiByte(CP_OEMCP, 0,
        //                          MsgBuf, CharacterCount,
        //                          AnsiBuf, MAX_BUF_SIZE*3,
        //                          NULL, NULL);

        // WriteFile(FileHandle, AnsiBuf, cch, &cch, NULL);

        WriteFile(FileHandle, MsgBuf, CharacterCount*sizeof(WCHAR), &cch, NULL);
    }

    return;
}

VOID
DfsPrintToFile(
    HANDLE FileHandle,
    BOOLEAN ScriptOut,
    PWCHAR format,
    ...)
{
    va_list va;
    
    va_start(va, format);

    if (ScriptOut)
    {
        DfsVPrintWideToFile( FileHandle, format, va);
    }

    else
    {
        DfsVPrintToFile( FileHandle, format, va);
    }


    va_end(va);
    return;
}

VOID
MyPrintf(
    PWCHAR format,
    ...)
{
    va_list va;
    
    va_start(va, format);

    DfsVPrintToFile( GetStdHandle(STD_OUTPUT_HANDLE), format, va);

    va_end(va);
    return;
}


VOID
ShowVerboseInformation(
    PWCHAR format,
    ...)
{
    va_list va;
    
    extern HANDLE ShowHandle;
    va_start(va, format);

    DfsVPrintToFile( ShowHandle, format, va);

    va_end(va);
    return;
}
    
VOID
ShowDebugInformation(
    PWCHAR format,
    ...)
{
    va_list va;
    extern HANDLE DebugHandle;
    va_start(va, format);

    DfsVPrintToFile( DebugHandle, format, va);

    va_end(va);
    return;
}


DFSSTATUS
SetInfoReSynchronize(
    LPWSTR ServerName,
    LPWSTR ShareName)
{
    DfsPathName RootTarget;
    DFS_INFO_101 Info101;
    DFSSTATUS Status;
    
    //
    // First create a UNC path name to the root target.
    //
    Status = RootTarget.SetPathName( ServerName, ShareName );
    if (Status != ERROR_SUCCESS) 
    {
        DebugInformation((L"DfsUtil: Error 0x%x in creating RootTarget<%wS, %wS>\n", 
            Status, ServerName, ShareName));
        ErrorMessage(Status);
        return Status;
    }

    DebugInformation((L"DfsUtil: ReSynchronize notification to root target %wS\n", RootTarget.GetPathString()));
    
    //
    // Ask the dfs service to synchronize. It is important that we don't
    // use direct mode operations (ie. DFS_SET_INFO macro) here. These are the root targets.
    //
    Info101.State = DFS_VOLUME_STATE_RESYNCHRONIZE;
    Status = NetDfsSetInfo( RootTarget.GetPathString(), NULL, NULL, 101, (LPBYTE)&Info101 );
    
    //
    // It is entirely fine to get an error from W2K servers. Still, we'll defer that decision to the
    // to the caller and return the real error.
    //
    if (Status != ERROR_SUCCESS) 
    {
        DebugInformation((L"DfsUtil: Error 0x%x hit in attempting to contact root target %wS\n",
                Status, RootTarget.GetPathString()));
    }
    
    return Status;
}

//
// Just take out the <target,share> tuple from the replicalist
// in the AD directly. This doesn't involve any attempts to
// contact that replica server other than a feeble attempt to
// send a RESYNCHRONIZE message to it. We fully expect that
// the typically scenario will be one of a dead replica server.
//
DWORD
CmdUnmapRootReplica( 
    LPWSTR DomainDfsPath, 
    LPWSTR ReplicaServerName, 
    LPWSTR ReplicaShareName )
{

    DfsPathName DfsPathName;
    DFSSTATUS Status;

    Status = DfsPathName.CreatePathName( DomainDfsPath );
    if (Status == ERROR_SUCCESS) 
    {
        PUNICODE_STRING pRemaining = DfsPathName.GetRemainingCountedString();
        if (pRemaining->Length != 0) 
        {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status == ERROR_SUCCESS) 
        {
            Status = NetDfsRemoveFtRootForced( DfsPathName.GetServerString(),
                                               ReplicaServerName,
                                               ReplicaShareName,
                                               DfsPathName.GetShareString(),
                                               0 );
        }
    }
    return Status;
}


DWORD
CmdClean( 
    LPWSTR HostServerName, 
    LPWSTR RootShareName )
{
    DWORD Status;

    DebugInformation((L"DfsUtil: Contacting registry of %wS to remove %wS\n",
        HostServerName, RootShareName));
    
    Status = DfsClean( HostServerName, RootShareName );
    
    if (Status != ERROR_SUCCESS) {
        DebugInformation((L"DfsUtil: Specified registry entry was not found.\n"));
    }
    return Status;
}



DWORD
CreateDfsFile( LPWSTR pFileString,
               PHANDLE pFileHandle )
{
    HANDLE FileHandle;
    DWORD Status = ERROR_SUCCESS;

    FileHandle = CreateFile( pFileString,
                             GENERIC_ALL,
                             FILE_SHARE_READ|FILE_SHARE_DELETE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        Status = GetLastError();
    }
    else
    {
        *pFileHandle = FileHandle;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\info.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       info.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
#include "struct.hxx"
#include "misc.hxx"
#include <dfsutil.hxx>

#define OFFSET_TO_POINTER(f,b) \
    ((VOID *)((PCHAR)(f) + (ULONG_PTR)(b)))

CHAR *OutBuf = NULL;
ULONG OutBufSize = 0x1000;
HANDLE DriverHandle = NULL;
CHAR InBuf[0x1000];
CHAR OutBuf2[0x1000];

VOID
GetDCs(
    LPWSTR Name);

DWORD
PktInfo(
    BOOLEAN fSwDfs,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type;
    ULONG State;
    ULONG Entry;
    ULONG Service;
    ULONG Level = 0;
    PDFS_GET_PKT_ARG pGetPkt = NULL;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fSwDfs == TRUE) {
        MyPrintf(L"--dfs.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_SERVER_NAME);
    } else {
        MyPrintf(L"--mup.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    }

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            DebugInformation((L"Bad Level %ws\r\n", pwszHexValue));
            goto Cleanup;
        }
    }
            
    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        DebugInformation((L"NtCreateFile returned 0x%x\r\n", NtStatus));
        goto Cleanup;
    }

TryAgain:

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_PKT,
                   NULL,
                   0,
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR) malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }


    dwErr = RtlNtStatusToDosError(NtStatus);

    if (!NT_SUCCESS(NtStatus))
        goto Cleanup;

    pGetPkt = (PDFS_GET_PKT_ARG)OutBuf;

    MyPrintf(L"%d entries...\r\n", pGetPkt->EntryCount);

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        pGetPkt->EntryObject[Entry].Prefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].Prefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].ShortPrefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].ShortPrefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].Address = (PDFS_PKT_ADDRESS_OBJECT *) OFFSET_TO_POINTER(
                                                            pGetPkt->EntryObject[Entry].Address,
                                                            OutBuf);
        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            pGetPkt->EntryObject[Entry].Address[Service] = (PDFS_PKT_ADDRESS_OBJECT)
                                                OFFSET_TO_POINTER(
                                                    pGetPkt->EntryObject[Entry].Address[Service],
                                                    OutBuf);
        }
    }

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        MyPrintf(L"Entry: %ws\r\n", pGetPkt->EntryObject[Entry].Prefix);
        MyPrintf(L"ShortEntry: %ws\r\n", pGetPkt->EntryObject[Entry].ShortPrefix);
        MyPrintf(L"Expires in %d seconds\r\n", pGetPkt->EntryObject[Entry].ExpireTime);
        MyPrintf(L"UseCount: %d Type:0x%x (",
                    pGetPkt->EntryObject[Entry].UseCount,
                    pGetPkt->EntryObject[Entry].Type);
        Type = pGetPkt->EntryObject[Entry].Type;
        if (Type & PKT_ENTRY_TYPE_OFFLINE)
            MyPrintf(L" OFFLINE");
        if (Type & PKT_ENTRY_TYPE_LOCAL)
            MyPrintf(L" LOCAL");
        if (Type & PKT_ENTRY_TYPE_STALE)
            MyPrintf(L" STALE");
        if (Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)
            MyPrintf(L" LOCAL_XPOINT");
        if (Type & PKT_ENTRY_TYPE_DELETE_PENDING)
            MyPrintf(L" DELETE_PENDING");
        if (Type & PKT_ENTRY_TYPE_PERMANENT)
            MyPrintf(L" PERMANENT");
        if (Type & PKT_ENTRY_TYPE_REFERRAL_SVC)
            MyPrintf(L" REFERRAL_SVC");
        if (Type & PKT_ENTRY_TYPE_SYSVOL)
            MyPrintf(L" SYSVOL");
        if (Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM)
            MyPrintf(L" OUTSIDE_MY_DOM");
        if (Type & PKT_ENTRY_TYPE_LEAFONLY)
            MyPrintf(L" LEAFONLY");
        if (Type & PKT_ENTRY_TYPE_NONDFS)
            MyPrintf(L" NONDFS");
        if (Type & PKT_ENTRY_TYPE_MACHINE)
            MyPrintf(L" MACHINE");
        if (Type & PKT_ENTRY_TYPE_DFS)
            MyPrintf(L" DFS");
        if (Type & PKT_ENTRY_TYPE_INSITE_ONLY)
            MyPrintf(L" INSITE");

        MyPrintf(L" )\r\n");

        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            MyPrintf(L"%4d:[%ws] State:0x%02x ",
                Service,
                pGetPkt->EntryObject[Entry].Address[Service]->ServerShare,
                pGetPkt->EntryObject[Entry].Address[Service]->State);
            State = pGetPkt->EntryObject[Entry].Address[Service]->State;
            //
            // Ugly - used to have State == 0x1 mean 'active'.  Now we return an
            // ULONG with multiple bits set, so 0x1 indicates the old way and
            // more than 1 bit set means the new way.
            //
            if (State == 0x0) {
                MyPrintf(L"\r\n");
            } else if (State == 0x1) {
                MyPrintf(L"( ACTIVE )\r\n");
            } else {
                MyPrintf(L"(");
                if (State & DFS_SERVICE_TYPE_ACTIVE)
                    MyPrintf(L" ACTIVE");
                if (State & DFS_SERVICE_TYPE_OFFLINE)
                    MyPrintf(L" OFFLINE");
                if (Level >= 1) {
                    if (State & DFS_SERVICE_TYPE_MASTER)
                        MyPrintf(L" MASTER");
                    if (State & DFS_SERVICE_TYPE_READONLY)
                        MyPrintf(L" READONLY");
                    if (State & DFS_SERVICE_TYPE_LOCAL)
                        MyPrintf(L" LOCAL");
                    if (State & DFS_SERVICE_TYPE_REFERRAL)
                        MyPrintf(L" REFERRAL");
                    if (State & DFS_SERVICE_TYPE_DOWN_LEVEL)
                        MyPrintf(L" DOWNLEVEL");
                    if (State & DFS_SERVICE_TYPE_COSTLIER)
                        MyPrintf(L" COSTLIER");
                }
                MyPrintf(L" )\r\n");
            }
        }
        MyPrintf(L"\r\n");
    }

Cleanup:

    if (OutBuf != NULL) {
        free(OutBuf); 
        OutBuf = NULL;
    }

    if (DriverHandle != NULL) {
        NTSTATUS st;
        st = NtClose(DriverHandle);
        DriverHandle = NULL;
    }

    if (dwErr == ERROR_SUCCESS) {
        CommandSucceeded = TRUE;
    }
    
    return dwErr;
}

DWORD
SpcInfo(
    BOOLEAN fSwAll)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    WCHAR *wCp;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        DebugInformation((L"NtCreateFile returned 0x%x\r\n", NtStatus));
        ErrorMessage(dwErr);
        goto Cleanup;
    } else {
        CommandSucceeded = TRUE;
    }

TryAgain:

    wcscpy((WCHAR *)InBuf, L"*");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            wCp += wcslen(wCp) + 1;
        }
    }

    wcscpy((WCHAR *)InBuf, L"");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            if (fSwAll == TRUE || *wCp == '+') {
                GetDCs((wCp+1));
            }
            wCp += wcslen(wCp) + 1;
        }
    }

Cleanup:

    if (DriverHandle != NULL) {
        NtClose(DriverHandle);
        DriverHandle = NULL;
    }
    if (OutBuf != NULL) {
        free(OutBuf);
        OutBuf = NULL;
    }

    if (dwErr == ERROR_SUCCESS) {
        CommandSucceeded = TRUE;
    }
    return dwErr;
}

VOID
GetDCs(
    LPWSTR Name)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR *wCp;

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   Name,
                   (wcslen(Name) + 1) * sizeof(WCHAR),
                   OutBuf2,
                   sizeof(OutBuf2));

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf2;
        while (*wCp) {
            MyPrintf(L"\t[%ws]\r\n", wCp);
            wCp += wcslen(wCp) + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\siteinformation.cxx ===
//+-------------------------------------------------------------------------
//
//
//  Copyright (C) 2002, Microsoft Corporation
//
//  File:       SiteInformation.cxx
//
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "rpc.h"
#include "rpcdce.h"
#include <lm.h>
#include <winsock2.h>

#include <dsgetdc.h>
#include <dsrole.h>

#include <dfsutil.hxx>
#include <dfsstrings.hxx>
    //
    // Flags used in DsGetDcName()
    //
    
struct _DFS_PREFIX_TABLE *_pSiteTable;

DWORD DcFlags[] = {
        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED,

        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_FORCE_REDISCOVERY
     };
       

DfsString UseDcName;

DFSSTATUS
FindSiteInformation( PUNICODE_STRING pName,
                     DfsString *pSite )
{
    NTSTATUS NtStatus;
    UNICODE_STRING Suffix;
    DfsString *pStoredSite;
    DFSSTATUS Status;

    if (_pSiteTable == NULL) 
    {
        Status = ERROR_NOT_FOUND;
        return Status;
    }

    Status =  ERROR_NOT_FOUND;

    NtStatus = DfsPrefixTableAcquireReadLock( _pSiteTable );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsFindUnicodePrefixLocked( _pSiteTable,
                                               pName,
                                               &Suffix,
                                               (PVOID *)&pStoredSite,
                                               NULL );

        DfsPrefixTableReleaseLock( _pSiteTable );
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        Status = pSite->CreateString(pStoredSite->GetString());
    }
    DebugInformation((L"Find site %wZ, status %x\n", pName, Status));
    return Status;
}


DFSSTATUS
StoreSiteInformation( PUNICODE_STRING pName,
                      DfsString *pSite )
{

    DfsString *pStoreSite;
    DFSSTATUS Status;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    pStoreSite = new DfsString;
    if (pStoreSite == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = pStoreSite->CreateString(pSite->GetString());
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (_pSiteTable == NULL) 
    {
        NtStatus = DfsInitializePrefixTable( &_pSiteTable,
                                             FALSE, 
                                             NULL );
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsPrefixTableAcquireWriteLock( _pSiteTable);


        if (NtStatus == STATUS_SUCCESS)
        {

            NtStatus = DfsInsertInPrefixTableLocked( _pSiteTable,
                                                     pName,
                                                     (PVOID)(pStoreSite));
            DfsPrefixTableReleaseLock(_pSiteTable);
        }
    }

    DebugInformation((L"Storing name %wZ, status %x\n", pName, NtStatus));
    return RtlNtStatusToDosError(NtStatus);
}


DWORD
GetSiteNameFromIpAddress(char * IpData, 
                            ULONG IpLength, 
                            USHORT IpFamily,
                            LPWSTR **SiteNames)
{
    DWORD Status = ERROR_INVALID_PARAMETER;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    PSOCKET_ADDRESS pSockAddr = NULL;
    PSOCKADDR_IN pSockAddrIn = NULL;
    struct hostent* pH = NULL;
    DWORD cRetry = 0;
    SOCKET_ADDRESS SockAddr;
    SOCKADDR_IN SockAddrIn;


    //setup the socket structures in order to call DsAddressToSiteNames
    pSockAddr = &SockAddr;
    pSockAddr->iSockaddrLength = sizeof(SOCKADDR_IN);
    pSockAddr->lpSockaddr = (LPSOCKADDR)&SockAddrIn;
    pSockAddrIn = &SockAddrIn;
    pSockAddrIn->sin_family = IpFamily;
    pSockAddrIn->sin_port = 0;
    RtlCopyMemory(
                &pSockAddrIn->sin_addr,
                IpData,
                (IpLength & 0xff));


    //
    // Call DsGetDcName() with ever-increasing urgency, until either
    // we get a good DC or we just give up.
    //


    if (IsEmptyString(UseDcName.GetString()) == FALSE)
    {
        Status = DsAddressToSiteNames( UseDcName.GetString(),
                                       1,
                                       pSockAddr,
                                       SiteNames);
        if (Status == ERROR_SUCCESS)
        {
            return Status;
        }
    }


    for (cRetry = 0; cRetry <= (sizeof(DcFlags) / sizeof(DcFlags[1])); cRetry++)
    {

        Status = DsGetDcName( NULL,             // Computer to remote to
                              NULL,             // Domain - use local domain
                              NULL,             // Domain Guid
                              NULL,             // Site Guid
                              DcFlags[cRetry],  // Flags
                              &pDCInfo);


        if (Status == ERROR_SUCCESS) 
        {
            DebugInformation((L"Trying DC %ws with address %ws in domain %ws within forest %ws\n\n", 
                   pDCInfo->DomainControllerName, 
                   pDCInfo->DomainControllerAddress,
                   pDCInfo->DomainName,
                   pDCInfo->DnsForestName));
            Status = DsAddressToSiteNames( pDCInfo->DomainControllerAddress,
                                           1,
                                           pSockAddr,
                                           SiteNames);
            if(Status != ERROR_SUCCESS)
            {
                DebugInformation((L"DsAddressToSiteNames failed using DC %ws with error %d\n", pDCInfo->DomainControllerAddress, Status));
            }
            if (Status == ERROR_SUCCESS) 
            {
                UseDcName.CreateString(pDCInfo->DomainControllerAddress);
                goto Exit;
            }

            NetApiBufferFree( pDCInfo );

        }
        else
        {
            DebugInformation((L"DsGetDcName failed with error %d\n", Status));
        }
    }
Exit:
    return Status;
}


DWORD
GetSites(LPWSTR Target,
         DfsString *pSite )
{

    DWORD Status = 0;
    DWORD Loop = 0;
    struct hostent *hp = NULL;
    unsigned long InetAddr = 0;
    char * IpAddr = NULL;
    WSADATA   wsadata;
    in_addr inAddrIpServer;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ANSI_STRING DestinationString;
    UNICODE_STRING ServerName;

    LPWSTR *pSiteNamesArray = NULL;

    Status = DfsRtlInitUnicodeStringEx(&ServerName, Target);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = FindSiteInformation( &ServerName,
                                  pSite);
    if (Status == ERROR_SUCCESS)
    {
        return Status;
    }

    Status = WSAStartup( MAKEWORD( 1, 1 ), &wsadata );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }


    DestinationString.Buffer = NULL;
  
    NtStatus = RtlUnicodeStringToAnsiString(&DestinationString,
                                            &ServerName,
                                            TRUE);

    if (NtStatus != STATUS_SUCCESS)
    {
        return RtlNtStatusToDosError(NtStatus);
    }

    //
    // This can be a bogus host name. So beware.
    //
    hp = gethostbyname (DestinationString.Buffer);

    if(hp != NULL)
    {
        for (Loop = 0; (hp->h_addr_list[Loop] != NULL); Loop++)
        {
            CopyMemory(&inAddrIpServer, hp->h_addr_list[Loop], sizeof(DWORD));
            DebugInformation((L"Finding site for %wZ\n", &ServerName));

            Status = GetSiteNameFromIpAddress( hp->h_addr_list[Loop],
                                                  4,
                                                  AF_INET,
                                                  &pSiteNamesArray );
        }
    }
    else 
    {
        Status = WSAGetLastError();

        InetAddr = inet_addr( DestinationString.Buffer );
        if((InetAddr == INADDR_NONE) || (InetAddr == 0))
        {
            DebugInformation((L"gethostbyname for site for %wZ failed with error %d\n", 
                              &ServerName, Status));
        }
        else
        {
            DebugInformation((L"Finding site for %wZ\n", &ServerName));
            IpAddr = (char *) &InetAddr;

            
            Status = GetSiteNameFromIpAddress( IpAddr,
                                                  4,
                                                  AF_INET,
                                                  &pSiteNamesArray );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if ((pSiteNamesArray != NULL) && (pSiteNamesArray[0] != NULL))
        {
            Status = pSite->CreateString(pSiteNamesArray[0]);
        }
        else
        {
            Status = pSite->CreateString(L"(No site association)");
        }

        if (Status == ERROR_SUCCESS)
        {
            StoreSiteInformation( &ServerName, pSite);
        }
    }

    if (pSiteNamesArray != NULL)
    {
        NetApiBufferFree(pSiteNamesArray);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\rename.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
}
#include <ole2.h>
#include <activeds.h>
#include <dfsprefix.h>
#include <DfsServerLibrary.hxx>
#include <DfsRegStrings.hxx>
#include <dfsutil.hxx>
#include <dfsmisc.h>
#include <dfspathname.hxx>
#include <struct.hxx>

LPWSTR UtilRegistryHostLocation = DFS_REG_HOST_LOCATION;
LPWSTR UtilVolumesLocation = DFS_REG_VOLUMES_LOCATION;
LPWSTR UtilFtDfsConfigDNValueName = DFS_REG_FT_DFS_CONFIG_DN_VALUE;

LPWSTR DfsHostLastDomainValueName = DFS_REG_HOST_LAST_DOMAIN_VALUE;
LPWSTR DfsDriverLocalVolumesLocation = DFS_REG_LOCAL_VOLUMES_LOCATION;
LPWSTR DfsDriverLocalVolumesEntryPath = DFS_REG_ENTRY_PATH;
LPWSTR DfsDriverLocalVolumesShortEntryPath = DFS_REG_SHORT_ENTRY_PATH;

DFSSTATUS
DfsFixupRegistryValues(
    IN LPWSTR DfsPathString,
    IN LPWSTR RootName,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName);

DFSSTATUS
DfsRenameRegistries(
    IN DfsPathName *pPathName,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName);

DFSSTATUS
GetCurrentRegDomainName(
    IN HKEY VolumeKey,
    IN LPWSTR DfsHostValueName,
    OUT LPWSTR *pValueString);

DFSSTATUS
DfsSetRegDomainName(
    IN const HKEY DfsKey,
    IN const LPWSTR RegValueName,
    IN const LPWSTR DomainString);

BOOLEAN
DfsRenameFTConfigValueName(
    IN LPWSTR DNString,
    IN LPWSTR NewDomainString,
    IN PUNICODE_STRING OldDomain,
    OUT LPWSTR *NewDNString);

DFSSTATUS
GetRegVolumesHKey(
    IN LPWSTR MachineName,
    OUT HKEY *VolumeKey);

DFSSTATUS
GetRegLocalVolumesHKey(
    IN LPWSTR MachineName,
    OUT HKEY *LocalVolumeKey);

//
// DfsRenameRegistries
//
// This contacts all root targets affected by the rename
// operation to possibly change their registry references
// to the obsolete domain name.
//
DFSSTATUS
DfsRenameRegistries(
    IN DfsPathName *pPathName,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName)
{
    DFSSTATUS Status;
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = 1;
    DWORD Level = 4;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i; 
    PDFS_STORAGE_INFO pStorage;

    //
    // We are reading in just the ROOT.
    // supw: DfsGetInfo is a better way to do this.
    //
    Status = DfsApiEnumerate( MODE_DIRECT,
                              pPathName->GetPathString(),
                              Level, 
                              PrefMaxLen, 
                              &pBuffer, 
                              &EntriesRead, 
                              &ResumeHandle);
    
    if ((Status == ERROR_SUCCESS) && EntriesRead != 0)
    {
        pCurrentBuffer = (PDFS_INFO_4)pBuffer;
        for( i = 0, pStorage = pCurrentBuffer->Storage;
            i < pCurrentBuffer->NumberOfStorages;
            i++, pStorage = pCurrentBuffer->Storage + i )
        {
            DebugInformation((L"DfsUtil: RenameRegistries: TARGET SERVER \\\\%ws\\%ws\n", 
                 pStorage->ServerName, pStorage->ShareName));

            //
            // Now contact the appropriate server(s) for the root replicas
            // and fix up their registry values if they happen to still 
            // point back at the obsolete domain name. Only the pre-Whistler
            // servers do that currently.
            // Errors are ignored entirely. The target server may or may not be a
            // W2K machine.
            //
            // xxx supw: skip duplicate servernames here.
            (VOID)DfsFixupRegistryValues(pStorage->ServerName, 
                                         pPathName->GetShareString(),
                                         OldDomainName, 
                                         NewDomainName);

            //
            // Don't bother to resynchrnoize. W2K systems don't respond to RESYNCHRONIZE calls.
            // Besides, the administrator is supposed to reboot all root servers.
            //
            // (VOID)SetInfoReSynchronize( pStorage->ServerName, pStorage->ShareName );

        }

        //
        // Free the allocated memory.
        //
        DfsFreeApiBuffer(pBuffer);
    }    
    
    return Status;
}

DFSSTATUS
DfsFixupRegistryValues(
    IN LPWSTR MachineName,
    IN LPWSTR RootName,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName)
{
    HKEY VolumeKey, LocalVolKey;
    LPWSTR DNString = NULL;
    LPWSTR EntryString = NULL;
    DFSSTATUS Status;
    DFSSTATUS RetStatus = ERROR_SUCCESS;
    UNICODE_STRING OldDomUnicode;
    UNICODE_STRING DomUnicode;
    BOOLEAN Changed = FALSE;
    
    Status = GetRegVolumesHKey( MachineName, &VolumeKey );

    if (Status != ERROR_SUCCESS)
    {
        if (fSwDebug) {
            DebugInformation((L"DfsUtil: RegOpen of DfsHost Volumes failed for machine %ws, with error 0x%x\n",
                MachineName, Status));
        }
        
        //
        // Only return fatal conditions that'll prompt us to abort.
        //
        return RetStatus;
    }
        
    RtlInitUnicodeString( &OldDomUnicode, OldDomainName );

    //
    //  The \DfsHost\volumes\FTDfsObjectDN may need fixing.
    //
    Status = GetCurrentRegDomainName( VolumeKey, 
                                      UtilFtDfsConfigDNValueName, 
                                      &DNString);
    if (Status == ERROR_SUCCESS)
    {
        LPWSTR NewDNString;

        //
        //  The DNString is of the form "CN=,CN=,...DC=DomainName,DC=..."
        //  See if the substring DC=DomainName matches the OldDomainName.
        //  If so substitute it with the NewDomainName and get a new DN string.
        //
        //if (DfsRenameFTConfigValueName( DNString, NewDomainName, &OldDomUnicode, &NewDNString ))

        //
        // Simply replace the existing string with a new DN string we generate. 
        // This assumes that the system has already rebooted since the DC was renamed.
        //
        {
            Status = DfsGenerateDNPathString( RootName, &NewDNString );
            if (Status == ERROR_SUCCESS)
            {
                Status = DfsSetRegDomainName( VolumeKey, UtilFtDfsConfigDNValueName, NewDNString );
                if (Status == ERROR_SUCCESS)
                {
                    Changed = TRUE;
                    DebugInformation((L"FTDfsObjectDN = %ws\n", NewDNString));
                }
                DfsDeleteDNPathString( NewDNString );
            }
        }
                                       
        delete [] DNString;
    }

    //
    //  The \DfsHost\volumes\LastDomainName shouldn't mention the old domain name.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = GetCurrentRegDomainName( VolumeKey, 
                                         DfsHostLastDomainValueName, 
                                         &DNString );
        if (Status == ERROR_SUCCESS)
        {
            RtlInitUnicodeString( &DomUnicode, DNString );
            if (RtlEqualDomainName( &DomUnicode, &OldDomUnicode ))
            {
                //
                // Go ahead and make the substitution in the registry.
                //
                Status = DfsSetRegDomainName( VolumeKey, 
                                              DfsHostLastDomainValueName, 
                                              NewDomainName );
                if (Status == ERROR_SUCCESS)
                {
                    Changed = TRUE;
                    DebugInformation((L"DfsUtil: Rename of LastDomainName RegKey to %ws successful\n", 
                            NewDomainName));
                }
            }
            delete [] DNString;
        }
    }

    RegCloseKey( VolumeKey );


    Status = GetRegLocalVolumesHKey( MachineName, &LocalVolKey );

    if (Status != ERROR_SUCCESS)
    {
        if (fSwDebug) {
            DebugInformation((L"DfsUtil: RegOpen of Services\\DfsDriver\\LocalVolume failed for machine %ws, with error 0x%x\n",
                MachineName, Status));
        }
        
        //
        // Only return fatal conditions that'll prompt us to abort.
        //
        return RetStatus;
    }
    
    //
    //  The HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\DfsDriver\LocalVolume
    //  shouldn't mention the old domain name.
    //

    Status = GetCurrentRegDomainName( LocalVolKey, 
                                     DfsDriverLocalVolumesEntryPath, 
                                     &EntryString );
    if (Status == ERROR_SUCCESS)
    {
        DfsPathName EntryPath;
        Status = EntryPath.CreatePathName(EntryString );
        if (Status == ERROR_SUCCESS)
        {             
            if (RtlEqualDomainName( EntryPath.GetServerCountedString(), &OldDomUnicode ))
            {
                DfsPathName NewEntryPath;
                //
                // Go ahead and make the substitution in the registry.
                // But first recreate the EntryPath using the new domain name.
                //
                NewEntryPath.SetPathName( NewDomainName,
                                          EntryPath.GetShareString(),
                                          1);
               
                Status = DfsSetRegDomainName( LocalVolKey, 
                                              DfsDriverLocalVolumesEntryPath, 
                                              NewEntryPath.GetPathString() );
                
                if (Status == ERROR_SUCCESS)
                {
                    Changed = TRUE;
                    DebugInformation((L"DfsUtil: Rename of EntryPath RegKey from %ws to %ws successful\n", 
                        EntryPath.GetPathString(), NewEntryPath.GetPathString()));
                }
            }
        }
        delete [] EntryString;
    }

    Status = GetCurrentRegDomainName( LocalVolKey, 
                                     DfsDriverLocalVolumesShortEntryPath, 
                                     &EntryString );
    if (Status == ERROR_SUCCESS)
    {
        DfsPathName ShortEntryPath;
        Status = ShortEntryPath.CreatePathName(EntryString );
        if (Status == ERROR_SUCCESS)
        {             
            if (RtlEqualDomainName( ShortEntryPath.GetServerCountedString(), &OldDomUnicode ))
            {
                //
                // Go ahead and make the substitution in the registry.
                // But first recreate the EntryPath using the new domain name.
                //
                DfsPathName NewEntryPath;
                //
                // Go ahead and make the substitution in the registry.
                // But first recreate the EntryPath using the new domain name.
                //
                NewEntryPath.SetPathName( NewDomainName,
                                          ShortEntryPath.GetShareString(),
                                          1 );

                Status = DfsSetRegDomainName( LocalVolKey, 
                                              DfsDriverLocalVolumesShortEntryPath,
                                              NewEntryPath.GetPathString() );

                if (Status == ERROR_SUCCESS)
                {
                    Changed = TRUE;
                    DebugInformation((L"DfsUtil: Rename of ShortEntryPath RegKey From %ws to %ws successful\n", 
                            ShortEntryPath.GetPathString(),
                            NewEntryPath.GetPathString()));
                }
            }
        }
        delete [] EntryString;
    }
    
    RegCloseKey( LocalVolKey );

    if (Changed) {
        DebugInformation((L"DfsUtil: Renamed registry references in root target system %wS\n", MachineName));
    }
    return RetStatus;
}

DFSSTATUS
GetCurrentRegDomainName(
    IN HKEY VolumeKey,
    IN LPWSTR DfsHostValueName,
    OUT LPWSTR *pValueString)
{
    LPWSTR FtDfsValue = NULL;
    ULONG DataSize, DataType;
    ULONG FtDfsValueSize;

    DWORD Status;

    *pValueString = NULL;
    
    //
    // If we opened the DFS hierarchy key properly, get the maximum
    // size of any of the values under this key. This is so that we
    // know how much memory to allocate, so that we can read any of
    // the values we desire.
    // 
    //
    Status = RegQueryInfoKey( VolumeKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time

    
    //
    // check if the value is a string.
    //
    if (Status == ERROR_SUCCESS)
    {
        FtDfsValueSize = DataSize;
        FtDfsValue = (LPWSTR) new BYTE[DataSize];
        if (FtDfsValue == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            //
            // Now check if this is a Domain Based root.
            //
            Status = RegQueryValueEx( VolumeKey,
                                      DfsHostValueName,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)FtDfsValue,
                                      &FtDfsValueSize);
        
            if (Status == ERROR_SUCCESS) {
            
                *pValueString = FtDfsValue;
                
            } else {

                delete [] FtDfsValue;
            }
        }
    }

    return Status;
 }   

DFSSTATUS
DfsSetRegDomainName(
    IN const HKEY DfsKey,
    IN const LPWSTR RegValueName,
    IN const LPWSTR DomainString)
{
    DFSSTATUS Status;

    Status = RegSetValueEx( DfsKey,
                        RegValueName,
                        0,
                        REG_SZ,
                        (PBYTE)DomainString,
                        wcslen(DomainString) * sizeof(WCHAR) );

    
    return Status;
}


DFSSTATUS
GetRegVolumesHKey(
    IN LPWSTR MachineName,
    OUT HKEY *VolumeKey)
{
    DFSSTATUS Status;
    HKEY RootKey;
    HKEY HostKey;
    
    Status = RegConnectRegistry( MachineName,
                               HKEY_LOCAL_MACHINE,
                               &RootKey );

    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }
    
    Status = RegOpenKeyEx( RootKey,
                           UtilRegistryHostLocation,
                           0,
                           KEY_READ|KEY_WRITE,
                           &HostKey );

    if (RootKey != HKEY_LOCAL_MACHINE)
    {
        RegCloseKey( RootKey );
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = RegOpenKeyEx( HostKey,
                           UtilVolumesLocation,
                           0,
                           KEY_READ|KEY_WRITE,
                           VolumeKey );

        RegCloseKey( HostKey );
    }
    
    return Status;
}

DFSSTATUS
GetRegLocalVolumesHKey(
    IN LPWSTR MachineName,
    OUT HKEY  *LocalVolumeKey)
{
    DFSSTATUS Status;
    HKEY RootKey;
    HKEY LocalParentKey;
    
    Status = RegConnectRegistry( MachineName,
                               HKEY_LOCAL_MACHINE,
                               &RootKey );

    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }
    
    Status = RegOpenKeyEx( RootKey,
                           DfsDriverLocalVolumesLocation,
                           0,
                           KEY_READ|KEY_WRITE,
                           &LocalParentKey );

    if (RootKey != HKEY_LOCAL_MACHINE)
    {
        RegCloseKey( RootKey );
    }

    //
    // We know for a fact that the old W2K servers can
    // host only one root. Therefore, there can only be one
    // child here.
    //
    if (Status == ERROR_SUCCESS) {
    
        DWORD ChildNameLen = MAX_PATH;
        WCHAR ChildName[MAX_PATH];

        Status = RegEnumKeyEx( LocalParentKey,
                               0,
                               ChildName,
                               &ChildNameLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL );


        if ( Status == ERROR_SUCCESS )
        {
            //
            // We have the name of a child, so open the key to
            // that root.
            //
            Status = RegOpenKeyEx( LocalParentKey,
                                   ChildName,
                                   0,
                                   KEY_READ|KEY_WRITE,
                                   LocalVolumeKey );
        }
            
        RegCloseKey( LocalParentKey );
    }
        
    return Status;
}

DFSSTATUS
DfsRenameLinksToDomain(
    IN DfsPathName *pDfsPath,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName)
{
    DFSSTATUS Status;

    DebugInformation((L"DfsUtil: Starting renaming links from %ws to %ws in ROOT %ws\n",
        OldDomainName, NewDomainName, pDfsPath->GetPathString()));

    Status = DfsRenameLinks( pDfsPath->GetPathString(), OldDomainName, NewDomainName );

    if (Status == ERROR_SUCCESS)
    {
        (VOID)DfsRenameRegistries( pDfsPath, OldDomainName, NewDomainName );
        CommandSucceeded = TRUE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\tools\dfsutil\xmlengine.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       XMLEngine.cxx
//
// Author: udayh
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>

#include <dfslink.hxx>
#include <dfsroot.hxx>
#include <dfstarget.hxx>

#include "dfsutil.hxx"

#include <ole2.h>
#include <msxml2.h>


#include "dfsutilschema.h"

#include "dfspathname.hxx"  
#define STANDARD_ILLEGAL_CHARS  TEXT("\"&'<>")

VOID
DumpLoadFailureInformation(
    IXMLDOMParseError *pParseError);




DFSSTATUS
GetXMLSchema( BSTR *pSchemaBstr )
{

    INT j;
    size_t CharacterCount = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    LPWSTR SchemaCopy;
    for (j = 0; j < sizeof(SchemaStr)/sizeof(SchemaStr[0]); j++)
    {
        CharacterCount += wcslen(SchemaStr[j]) + 1;
    }
    CharacterCount++;

    SchemaCopy = new WCHAR[CharacterCount];
    if (SchemaCopy == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        for (j = 0; j < sizeof(SchemaStr)/sizeof(SchemaStr[0]); j++)
        {
            if (j==0) wcscpy(SchemaCopy,SchemaStr[j]);
            else wcscat(SchemaCopy,SchemaStr[j]);
        }

        *pSchemaBstr = SysAllocString(SchemaCopy);
        if (*pSchemaBstr == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return Status;
}


VOID
ReleaseXMLSchema( BSTR SchemaBstr )
{
    SysFreeString(SchemaBstr);

    return NOTHING;
}



HRESULT
ValidateXMLDocument( 
    IXMLDOMDocument*  pXMLDoc )
{

    BSTR Schema;
    IXMLDOMDocument*  pXSDDoc;
    HRESULT HResult;
    VARIANT_BOOL IsSuccessful;

    DFSSTATUS Status;

    Status = GetXMLSchema(&Schema);
    if (Status != ERROR_SUCCESS)
    {
        return E_FAIL;
    }


    HResult = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                               IID_IXMLDOMDocument, (void**)&pXSDDoc);

    if (SUCCEEDED(HResult))
    {
        HResult = pXSDDoc->put_async(VARIANT_FALSE);
    }
            
    if (SUCCEEDED(HResult))
    {
        HResult = pXSDDoc->loadXML(Schema, &IsSuccessful);
    }

    if (SUCCEEDED(HResult))
    {
        IXMLDOMParseError *pParseError;
        if (!IsSuccessful)
        {
            ShowInformation((L"XML schema not success loaded\n"));
            HResult = pXSDDoc->get_parseError(&pParseError);

            if (SUCCEEDED(HResult)) 
            {
                DumpLoadFailureInformation(pParseError);
            }
        }
        else
        {
            IXMLDOMSchemaCollection* pSchemaCache;
            HResult = CoCreateInstance(CLSID_XMLSchemaCache, NULL, CLSCTX_SERVER, 
                                       IID_IXMLDOMSchemaCollection, (void**)&pSchemaCache);


            VARIANT vSchemas;
            VariantInit( &vSchemas);
            vSchemas.vt = VT_DISPATCH;
            vSchemas.pdispVal = pSchemaCache;

            IXMLDOMDocument2 * pDoc2 = NULL;
            pXMLDoc->QueryInterface(IID_IXMLDOMDocument2, (void**)&pDoc2);
            if (pDoc2)
            {
                VARIANT_BOOL ParseValidate = VARIANT_TRUE;
                pDoc2->putref_schemas( vSchemas);
                pDoc2->put_validateOnParse(ParseValidate);
                pDoc2->Release();
            }


            VARIANT vXSD;
            VariantInit( &vXSD);

            vXSD.vt = VT_DISPATCH;
            vXSD.pdispVal = pXSDDoc;

            //hook it up with XML Document
            HResult = pSchemaCache->add(SysAllocString(L""), vXSD);
        }
    }

    return HResult;
}

extern DWORD
GetSites(LPWSTR Target,
         DfsString *pSite );

DFSSTATUS
InitializeVariantFromString( 
    VARIANT *pVar,
    LPWSTR InString )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    pVar->bstrVal = SysAllocString( InString );
    if (pVar->bstrVal) 
    {
        pVar->vt = VT_BSTR;
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}



DFSSTATUS
DfsAddAttributeToTarget (
    DfsTarget *pTarget,
    IXMLDOMNode *pAttribute )
{
    HRESULT HResult;
    BSTR AttributeName;
    VARIANT AttributeValue;
    DFSSTATUS Status = ERROR_SUCCESS;


    VariantInit(&AttributeValue);

    HResult = pAttribute->get_nodeName( &AttributeName );
    if (SUCCEEDED(HResult))
    {
        HResult = pAttribute->get_nodeValue( &AttributeValue );
    }

    if (wcscmp((LPWSTR)AttributeName, L"Server") == 0)

    {
        Status = pTarget->SetTargetServer((LPWSTR)V_BSTR(&AttributeValue), FALSE);
    }
    else if (wcscmp((LPWSTR)AttributeName, L"Folder") == 0)
    {
        Status = pTarget->SetTargetFolder((LPWSTR)V_BSTR(&AttributeValue));
    }
    else if (wcscmp((LPWSTR)AttributeName, L"UNCName") == 0)
    {
        Status = pTarget->SetTargetUNCName((LPWSTR)V_BSTR(&AttributeValue), FALSE);
    }
    else if (wcscmp((LPWSTR)AttributeName, L"State")==0)
    {
        ULONG State = wcstoul((LPWSTR)V_BSTR(&AttributeValue),
                              NULL,
                              10 );

        pTarget->SetTargetState(State);
    }
    else
    {
        Status = ERROR_INVALID_PARAMETER;
    }


    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }
    return Status;

}

DFSSTATUS
DfsProcessTargetAttributes(
    DfsTarget *pTarget,
    IXMLDOMNode *pTargetNode )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    
    IXMLDOMNamedNodeMap *pTargetAttributeMap;
    LONG TotalAttributes;
    IXMLDOMNode *pAttribute;

    LONG Attrib;


    HResult = pTargetNode->get_attributes( &pTargetAttributeMap );

    if (SUCCEEDED(HResult))
    {
        HResult = pTargetAttributeMap->get_length(&TotalAttributes);

        if (SUCCEEDED(HResult))
        {

            for (Attrib = 0;
                 Attrib < TotalAttributes;
                 Attrib++ ) 
            {
                HResult = pTargetAttributeMap->get_item( Attrib, 
                                                         &pAttribute );
                if (SUCCEEDED(HResult))
                {
                    Status = DfsAddAttributeToTarget( pTarget,
                                                      pAttribute );
                }
            }
        }
    }

    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    return Status;
}

DFSSTATUS
DfsAddTargetToLink (
    DfsLink *pLink,
    IXMLDOMNode *pTargetNode )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsTarget *pTarget;

    pTarget = new DfsTarget;
    if (pTarget == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        Status = DfsProcessTargetAttributes( pTarget, pTargetNode );

        if (Status == ERROR_SUCCESS)
        {
            if (pTarget->IsValidTarget())
            {
                Status = pLink->AddTarget(pTarget);
            }
            else
            {
                Status = ERROR_INVALID_PARAMETER;
            }
        }
    }
    return Status;
}



DFSSTATUS
DfsAddAttributeToLink (
    DfsLink *pLink,
    IXMLDOMNode *pAttribute )
{
    HRESULT HResult;
    BSTR AttributeName;
    VARIANT AttributeValue;
    DFSSTATUS Status = ERROR_SUCCESS;

    VariantInit(&AttributeValue);
    HResult = pAttribute->get_nodeName( &AttributeName );
    if (SUCCEEDED(HResult))
    {
        HResult = pAttribute->get_nodeValue( &AttributeValue );
    }

    if (wcscmp((LPWSTR)AttributeName, L"Name")==0)
    {
        Status = pLink->SetLinkName((LPWSTR)V_BSTR(&AttributeValue));
    }
    else if (wcscmp((LPWSTR)AttributeName, L"Comment")==0)
    {
        Status = pLink->SetLinkComment((LPWSTR)V_BSTR(&AttributeValue));
    }
    else if (wcscmp((LPWSTR)AttributeName, L"Timeout")==0)
    {
        ULONG Timeout = wcstoul((LPWSTR)V_BSTR(&AttributeValue),
                                NULL, 
                                10);
        pLink->SetLinkTimeout(Timeout);
    }
    else if (wcscmp((LPWSTR)AttributeName, L"State")==0)
    {
        ULONG State = wcstoul((LPWSTR)V_BSTR(&AttributeValue),
                              NULL, 
                              10);

        //(LPWSTR)V_BSTR(&AttributeValue));
        pLink->SetLinkState(State);
    }
    else
    {
        Status = ERROR_INVALID_PARAMETER;
    }


    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }
    return Status;

}


DfsProcessLinkTargets(
    DfsLink *pLink,
    IXMLDOMNode *pLinkNode )
{
    IXMLDOMNodeList *pChildrenList;
    LONG Child;
    LONG TotalChildren;
    HRESULT HResult;
    DFSSTATUS Status = ERROR_SUCCESS;
    IXMLDOMNode *pTargetNode;

    HResult = pLinkNode->get_childNodes( &pChildrenList );

    if (SUCCEEDED(HResult))
    {
        HResult = pChildrenList->get_length(&TotalChildren);

        if (SUCCEEDED(HResult))
        {
            if (TotalChildren == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            }

            for (Child = 0; 
                 ((Child < TotalChildren) && (Status == ERROR_SUCCESS));
                 Child++) 
            {
                HResult = pChildrenList->get_item( Child, &pTargetNode);

                if (SUCCEEDED(HResult)) 
                {
                    Status = DfsAddTargetToLink( pLink, pTargetNode );
                }
                else
                { 
                    break;
                }
            }
        }
    }
    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }


    return Status;
}


DfsProcessLinkAttributes(
    DfsLink *pLink,
    IXMLDOMNode *pLinkNode )
{
    HRESULT HResult;
    IXMLDOMNamedNodeMap *pLinkAttributeMap;
    IXMLDOMNode *pAttribute;
    DFSSTATUS Status = ERROR_SUCCESS;

    LONG TotalAttributes, Attrib;

    HResult = pLinkNode->get_attributes( &pLinkAttributeMap );

    if (SUCCEEDED(HResult))
    {
        HResult = pLinkAttributeMap->get_length(&TotalAttributes);

        if (SUCCEEDED(HResult))
        {
            for (Attrib = 0;
                 ((Attrib < TotalAttributes) && (Status == ERROR_SUCCESS));
                 Attrib++ ) 
            {
                HResult = pLinkAttributeMap->get_item( Attrib, 
                                                       &pAttribute );
                if (SUCCEEDED(HResult))
                {
                    Status = DfsAddAttributeToLink( pLink,
                                                    pAttribute );
                }
                else
                {
                    break;
                }
            }
        }
    }

    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    return Status;
}


            
DFSSTATUS
DfsAddLinkToRoot(
    DfsRoot *pRoot,
    IXMLDOMNode *pLinkNode )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsLink *pLink;

    pLink = new DfsLink;
    if (pLink == NULL) 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsProcessLinkTargets( pLink, pLinkNode);
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsProcessLinkAttributes( pLink, pLinkNode);
    }

    if (Status == ERROR_SUCCESS)
    {
        if (pLink->IsValidLink()) 
        {
            Status = pRoot->AddLinks(pLink);
        }
        else
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    return Status;
}






DFSSTATUS
DfsAddElementToRoot( 
    DfsRoot *pRoot,
    IXMLDOMNode *pDomNode )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DOMNodeType NodeType;
    HRESULT HResult;
    BSTR NodeName;

    HResult = pDomNode->get_nodeType( &NodeType );
    if (SUCCEEDED(HResult)) 
    {
        switch (NodeType)
        {
        case NODE_ELEMENT:

            HResult = pDomNode->get_nodeName( &NodeName );
            if (SUCCEEDED(HResult)) 
            {
                if (wcscmp((LPWSTR)NodeName, L"Target") == 0)
                {
                    Status = DfsAddTargetToLink(pRoot, pDomNode);
                }
                else if (wcscmp((LPWSTR)NodeName, L"Link") == 0)
                {
                    Status = DfsAddLinkToRoot( pRoot, pDomNode);
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
            break;

        default:
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    return Status;
}


DFSSTATUS
DfsReadTreeRoot(
    DfsRoot *pRoot,
    IXMLDOMElement *pRootNode)
{
    IXMLDOMNodeList *pChildrenList;
    LONG TotalChildren, Child;
    HRESULT HResult;
    DFSSTATUS Status = ERROR_SUCCESS;
    IXMLDOMNode *pRootChild;

    Status = DfsProcessLinkAttributes( pRoot, pRootNode);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    HResult = pRootNode->get_childNodes( &pChildrenList );
    if (SUCCEEDED(HResult))
    {
        HResult = pChildrenList->get_length(&TotalChildren);

        if (SUCCEEDED(HResult))
        {
            for (Child = 0; 
                 ((Child < TotalChildren) && (Status == ERROR_SUCCESS));
                 Child++) 
            {
                HResult = pChildrenList->get_item( Child, &pRootChild);

                if (SUCCEEDED(HResult)) 
                {
                    Status = DfsAddElementToRoot( pRoot, pRootChild);
                }
                else
                { 
                    break;
                }
            }
        }
    }


    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    return Status;
}


VOID
DumpLoadFailureInformation(
    IXMLDOMParseError *pParseError)
{
    BSTR Reason, Text;
    HRESULT HResult;
    LONG ErrorCode, LineNum, LinePos;

    HResult = pParseError->get_reason(&Reason);
    if (SUCCEEDED(HResult)) 
    {
        HResult = pParseError->get_errorCode(&ErrorCode);
    }
    if (SUCCEEDED(HResult)) 
    {
        HResult = pParseError->get_line(&LineNum);
    }
    if (SUCCEEDED(HResult)) 
    {
        HResult = pParseError->get_linepos(&LinePos);
    }
    if (SUCCEEDED(HResult)) 
    {
        HResult = pParseError->get_srcText(&Text);
    }
    

    if (SUCCEEDED(HResult)) 
    {
        ShowInformation((L"\r\n\r\nERROR in import file:\r\n"));
        ShowInformation((L"Error Code = 0x%x\r\n", ErrorCode));
        ShowInformation((L"Source = Line : %ld; Position : %ld\r\n", 
                         LineNum, LinePos));
        ShowInformation((L"Error String: %wS\r\n", (LPWSTR)Text));
        ShowInformation((L"Error Description: %ws\r\n\r\n", (LPWSTR)Reason));
    }
    else
    {
        ShowInformation((L"Error in XML file: No more information available\r\n"));
    }


}

DFSSTATUS
DfsReadDocument(
    LPWSTR FileToRead,
    DfsRoot **ppRoot )
{
    IXMLDOMElement* pRootNode;
    HRESULT HResult;
    DFSSTATUS Status = ERROR_SUCCESS;

    VARIANT           Variant;

    DfsRoot *pRoot = NULL;

    VariantInit(&Variant);

    Status = InitializeVariantFromString( &Variant, FileToRead);

    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    pRoot = new DfsRoot;
    if (pRoot != NULL)
    {
        // Declare variables.
        IXMLDOMDocument*  pXMLDoc;

        // Initialize the COM library and retrieve a pointer
        // to an IXMLDOMDocument interface.
        HResult = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);


        if (SUCCEEDED(HResult))
        {
            HResult = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                                       IID_IXMLDOMDocument, (void**)&pXMLDoc);


            if (SUCCEEDED(HResult))
            {
                VARIANT_BOOL IsSuccessful;


                HResult = ValidateXMLDocument(pXMLDoc);

                if (SUCCEEDED(HResult))
                {
                    HResult = pXMLDoc->load( Variant, &IsSuccessful);
                }

                if (SUCCEEDED(HResult))
                {
                    if (!IsSuccessful) 
                    {
                        IXMLDOMParseError *pParseError;

                        HResult = pXMLDoc->get_parseError(&pParseError);

                        if (SUCCEEDED(HResult)) 
                        {
                            DumpLoadFailureInformation(pParseError);
                        }
                        Status = ERROR_INVALID_PARAMETER;
                    }
                    else
                    {


                        if (SUCCEEDED(HResult))
                        {
                            HResult = pXMLDoc->get_documentElement( &pRootNode );

                            if (SUCCEEDED(HResult)) 
                            {
                                Status = DfsReadTreeRoot( pRoot,
                                                          pRootNode );
                            }
                        }
                    }
                }
            }

            CoUninitialize();
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!SUCCEEDED(HResult))
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppRoot = pRoot;
    } 
    else if (pRoot != NULL) 
    {
        delete pRoot;
        pRoot = NULL;
    }
    return Status;
}



LPWSTR AmpString = L"&amp;";
LPWSTR LtString = L"&lt;";
LPWSTR GtString = L"&gt;";
LPWSTR QtString = L"&quot;";
LPWSTR AposString = L"&apos;";


DFSSTATUS
GetXMLStringToUse(
    LPWSTR UseString,
    BOOLEAN ScriptOut,
    LPWSTR *pOutString,
    BOOLEAN *pAllocated)
{
    LPWSTR NewString;
    LONG Position;
    LONG CharLength, NewCharLength;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (ScriptOut == FALSE) 
    {
        *pOutString = UseString;
        *pAllocated = FALSE;
        return ERROR_SUCCESS;
    }

    CharLength = wcslen(UseString);
    Position = wcscspn(UseString, STANDARD_ILLEGAL_CHARS);
    if (Position == CharLength)
    {
        *pAllocated = FALSE;
        *pOutString = UseString;
        return ERROR_SUCCESS;
    }
    else
    {
        //
        // Allocate the maximum we ever need! In the case the string has all ', 
        // the string will need 6 times as much space as the original string.
        //

        NewCharLength = CharLength * 6 + 1;
        NewString = new WCHAR[NewCharLength];
        if (NewString == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            LONG SpLength;
            LPWSTR CurrentString = NewString;
            LPWSTR OldString = UseString;
            LONG CurrentLength = NewCharLength;
            LONG OldLength = CharLength;
            RtlZeroMemory(NewString, NewCharLength * sizeof(WCHAR));

            do {

                if (Position)
                {
                    RtlCopyMemory(CurrentString, 
                                  OldString, 
                                  Position * sizeof(WCHAR));
                }

                WCHAR BadChar = *(OldString + Position);
                OldString += (Position + 1);
                CurrentString += Position;
                CurrentLength -= Position;
                OldLength -= (Position + 1);
                    
                switch(BadChar)
                {
                case L'&':
                    SpLength = wcslen(AmpString);
                    RtlCopyMemory(CurrentString, 
                                  AmpString, 
                                  SpLength * sizeof(WCHAR));
                    CurrentString += SpLength;
                    CurrentLength -= SpLength + 1;
                    break;

                case L'<':
                    SpLength = wcslen(LtString);
                    RtlCopyMemory(CurrentString, 
                                  LtString, 
                                  SpLength * sizeof(WCHAR));
                    CurrentString += SpLength;
                    CurrentLength -= SpLength;
                    break;

                case L'>':
                    SpLength = wcslen(GtString);
                    RtlCopyMemory(CurrentString, 
                                  GtString, 
                                  SpLength * sizeof(WCHAR));
                    CurrentString += SpLength;
                    CurrentLength -= SpLength;
                    break;

                case L'\"':
                    SpLength = wcslen(QtString);
                    RtlCopyMemory(CurrentString, 
                                  QtString, 
                                  SpLength * sizeof(WCHAR));
                    CurrentString += SpLength;
                    CurrentLength -= SpLength;

                    break;

                case L'\'':
                    
                    SpLength = wcslen(AposString);
                    RtlCopyMemory(CurrentString, 
                                  AposString, 
                                  SpLength * sizeof(WCHAR));
                    CurrentString += SpLength;
                    CurrentLength -= SpLength;
                    break;

                default:
                    Status = ERROR_INVALID_PARAMETER;
                }

                if (OldLength)
                {
                    Position = wcscspn(OldString, STANDARD_ILLEGAL_CHARS);

                    if (Position == OldLength)
                    {
                        RtlCopyMemory(CurrentString, 
                                      OldString, 
                                      Position * sizeof(WCHAR));
                    }
                }
                else
                {
                    break;
                }

                if (CurrentLength < OldLength)
                {
                    Status = ERROR_GEN_FAILURE;
                    break;
                }
            } while (Position != OldLength);
        }
        if (Status == ERROR_SUCCESS)
        {
            *pOutString = NewString;
            *pAllocated = TRUE;
        }
    }
    return Status;
}


VOID
ReleaseXMLStringToUse(
    LPWSTR UseString, 
    BOOLEAN Allocated)
{
    if (Allocated)
    {
        delete [] UseString;
    }
}

DFSSTATUS
DumpTargetInformation (
    DfsTarget *pTarget,
    HANDLE FileHandle,
    LPWSTR StartFormat,
    BOOLEAN ScriptOut )
{
    LPWSTR UseString;
    BOOLEAN Allocated = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;


    for ( ;
         pTarget != NULL;
         pTarget = pTarget->GetNextTarget())
    {
        DfsPrintToFile( FileHandle, ScriptOut, L"%ws", StartFormat);
        if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut, L"<");

        Status = GetXMLStringToUse(pTarget->GetTargetServerString(),
                                   ScriptOut,
                                   &UseString,
                                   &Allocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }
        
        DfsPrintToFile( FileHandle, ScriptOut, L"Target Server=\"%wS\" ", UseString);
        
        ReleaseXMLStringToUse(UseString, Allocated);


        Status = GetXMLStringToUse(pTarget->GetTargetFolderString(),
                                   ScriptOut,
                                   &UseString,
                                   &Allocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }

        DfsPrintToFile( FileHandle, ScriptOut, L"Folder=\"%wS\" ", UseString);
        
        ReleaseXMLStringToUse(UseString, Allocated);

        if (pTarget->GetTargetState()) 
        {
            DfsPrintToFile( FileHandle, ScriptOut, L"State=\"%d\"", pTarget->GetTargetState());       
        }
        if (ScriptOut) 
        {
            DfsPrintToFile( FileHandle, ScriptOut, L"/>");
        }
        else
        {
            DfsPrintToFile( FileHandle, ScriptOut, L" [Site: %wS]", pTarget->GetTargetSiteString());
        }

    }

    DfsPrintToFile( FileHandle, ScriptOut, L"\r\n");

done:
    return Status;
}

DFSSTATUS
DumpLinkInformation(
    DfsLink *pLink,
    HANDLE FileHandle,
    BOOLEAN ScriptOut )
{
    LPWSTR UseString;
    BOOLEAN Allocated = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( ;
         pLink != NULL;
         pLink = pLink->GetNextLink())
    {
        if (pLink->GetFirstTarget() == NULL)
        {
            continue;
        }
        DfsPrintToFile( FileHandle, ScriptOut, L"\r\n\r\n\t");
        if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut,L"<");

        Status = GetXMLStringToUse(pLink->GetLinkNameString(),
                                   ScriptOut,
                                   &UseString,
                                   &Allocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }

        DfsPrintToFile( FileHandle, ScriptOut,L"Link Name=\"%wS\" ", UseString);
        ReleaseXMLStringToUse(UseString, Allocated);

        if (IsEmptyString(pLink->GetLinkCommentString()) == FALSE)
        {
            Status = GetXMLStringToUse(pLink->GetLinkCommentString(),
                                       ScriptOut,
                                       &UseString,
                                       &Allocated );
            if (Status != ERROR_SUCCESS) 
            {
                goto done;
            }

            DfsPrintToFile( FileHandle, ScriptOut,L"Comment=\"%wS\" ", UseString);
            ReleaseXMLStringToUse(UseString, Allocated);

        }
        if (pLink->GetLinkState()) 
        {
            DfsPrintToFile( FileHandle, ScriptOut,L"State=\"%d\" ", pLink->GetLinkState());
        }
        if (pLink->GetLinkTimeout()) 
        {
            DfsPrintToFile( FileHandle, ScriptOut,L"Timeout=\"%d\" ", pLink->GetLinkTimeout());
        }
        if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut,L">");

        Status = DumpTargetInformation(pLink->GetFirstTarget(),
                                       FileHandle,
                                       L"\r\n\t\t",
                                       ScriptOut);
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }

        if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut,L"\t</Link>\r\n");
    }

done:
    return Status;
}


DFSSTATUS
DumpRoots (
    DfsRoot *pRoot,
    HANDLE FileHandle,
    BOOLEAN ScriptOut )
{
    LPWSTR UseString;
    BOOLEAN Allocated = FALSE;
    ULONG BlobSize = 0, Attrib = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN GotBlobSize = FALSE, GotAttrib = FALSE;
    LPWSTR RootType = L"";
    
    if (pRoot->RootBlobSize(&BlobSize) == ERROR_SUCCESS)
    {
        GotBlobSize = TRUE;
    }
    if (pRoot->GetExtendedAttributes(&Attrib) == ERROR_SUCCESS)
    {
        GotAttrib = TRUE;
    }

    if (ScriptOut) 
    {
        ULONG cch;
        //
        // we want to start the file with FFFE. This is the key word to get the file
        // to be recognized as containing unicode, so we support globalization.
        //
        WriteFile(FileHandle, "\xFF\xFE", 2, &cch, NULL);
        DfsPrintToFile( FileHandle, ScriptOut, L"<?xml version=\"1.0\"?>\r\n");
    }
    else 
    {
        if ((pRoot->GetLinkState() & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_STANDALONE)
        {
            RootType = L"Standalone";
        }
        else if ((pRoot->GetLinkState() & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_AD_BLOB)
        {
            RootType = L"Domain";
        }
        
        DfsPrintToFile( FileHandle, ScriptOut,L"%ws Root with %d Links", RootType, pRoot->GetLinkCount());
        if (GotBlobSize && (BlobSize != 0))
        {
            DfsPrintToFile( FileHandle, ScriptOut,L" [Blob Size: %d bytes]", BlobSize);
        }
        DfsPrintToFile( FileHandle, ScriptOut,L"\r\n");


        if (GotAttrib)
        {
            BOOLEAN Found = FALSE;
            if (Attrib & PKT_ENTRY_TYPE_INSITE_ONLY)
            {
                Found = TRUE;
                DfsPrintToFile( FileHandle, ScriptOut,L"InSite:ENABLED ");
            }
#if 0
            else
            {
                DfsPrintToFile( FileHandle, ScriptOut,L"InSite:DISABLED ");
            }
#endif
            if (Attrib & PKT_ENTRY_TYPE_COST_BASED_SITE_SELECTION)
            {
                Found = TRUE;
                DfsPrintToFile( FileHandle, ScriptOut,L"SiteCosting:ENABLED ");
            }
#if 0
            else
            {
                DfsPrintToFile( FileHandle, ScriptOut,L"SiteCosting:DISABLED ");
            }
#endif
            if (Attrib & PKT_ENTRY_TYPE_ROOT_SCALABILITY)
            {
                Found = TRUE;
                DfsPrintToFile( FileHandle, ScriptOut,L"RootScalability:ENABLED ");
            }
#if 0
            else
            {
                DfsPrintToFile( FileHandle, ScriptOut,L"RootScalability:DISABLED ");
            }
#endif
            if (Found == FALSE)
            {
                DfsPrintToFile( FileHandle, ScriptOut,L"Root information follows ");
            }
            DfsPrintToFile( FileHandle, ScriptOut,L"\r\n");
        }
        DfsPrintToFile( FileHandle, ScriptOut,L"\r\n");
    }

    DfsPrintToFile( FileHandle, ScriptOut,L"\r\n");
    if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut,L"<");

    DfsPrintToFile( FileHandle, ScriptOut,L"Root ");

    if (pRoot->GetLinkNameString() != NULL)
    {
        Status = GetXMLStringToUse(pRoot->GetLinkNameString(),
                                   ScriptOut,
                                   &UseString,
                                   &Allocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }
        DfsPrintToFile( FileHandle, ScriptOut,L"Name=\"%ws\" ", UseString);

        ReleaseXMLStringToUse(UseString, Allocated);
    }
    if (IsEmptyString(pRoot->GetLinkCommentString()) == FALSE)
    {
        Status = GetXMLStringToUse(pRoot->GetLinkCommentString(),
                                   ScriptOut,
                                   &UseString,
                                   &Allocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }

        DfsPrintToFile( FileHandle, ScriptOut,L"Comment=\"%wS\" ", UseString);
        ReleaseXMLStringToUse(UseString, Allocated);

    }
    if (pRoot->GetLinkState()) 
    {
        DfsPrintToFile( FileHandle, ScriptOut,L"State=\"%d\" ", pRoot->GetLinkState() & DFS_VOLUME_STATES);
    }
    if (pRoot->GetLinkTimeout()) 
    {
        DfsPrintToFile( FileHandle, ScriptOut,L"Timeout=\"%d\" ", pRoot->GetLinkTimeout());
    }
    
    if (ScriptOut) DfsPrintToFile( FileHandle, ScriptOut,L">");

    Status = DumpTargetInformation(pRoot->GetFirstTarget(),
                                   FileHandle,
                                   L"\r\n\t",
                                   ScriptOut);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }
    Status = DumpLinkInformation(pRoot->GetFirstLink(),
                                 FileHandle,
                                 ScriptOut);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }

    if (ScriptOut) 
    {
        DfsPrintToFile( FileHandle, ScriptOut,L"\r\n</Root>");
    }
    else
    {

  

        DfsPrintToFile( FileHandle, ScriptOut,L"\r\n\r\nRoot with %d Links", pRoot->GetLinkCount());


        if (GotBlobSize && (BlobSize != 0))
        {
            DfsPrintToFile( FileHandle, ScriptOut,L" [Blob Size: %d bytes]", BlobSize);
        }

        DfsPrintToFile( FileHandle, ScriptOut,L"\r\n\r\n\r\nNOTE: All site information shown was generated by this utility.\r\n");
        DfsPrintToFile( FileHandle, ScriptOut,L"      Actual DFS behavior depends on site information currently in use by \r\n");
        DfsPrintToFile( FileHandle, ScriptOut,L"      DFS service, and may not reflect configuration changes made recently.\r\n");

    }

    DfsPrintToFile( FileHandle, ScriptOut,L"\r\n\r\n");

done:
    return Status;
}



DFSSTATUS
AddTargetCosting(
    DfsTarget *pTarget,
    PULONG pCumulative,
    BOOLEAN RootTarget )
{
    LPWSTR ServerString, FolderString;
    BOOLEAN ServerAllocated = FALSE, FolderAllocated = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( ;
         pTarget != NULL;
         pTarget = pTarget->GetNextTarget())
    {
        Status = GetXMLStringToUse(pTarget->GetTargetServerString(),
                                   FALSE,
                                   &ServerString,
                                   &ServerAllocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }
        
        Status = GetXMLStringToUse(pTarget->GetTargetFolderString(),
                                   FALSE,
                                   &FolderString,
                                   &FolderAllocated );
        if (Status != ERROR_SUCCESS) 
        {
            goto done;
        }

        if (RootTarget)
        {
            *pCumulative += 6;
            *pCumulative += wcslen(ServerString) * sizeof(WCHAR);
            *pCumulative += wcslen(FolderString) * sizeof(WCHAR);
        }

        *pCumulative += 20;
        *pCumulative += 6;
        *pCumulative += wcslen(ServerString) * sizeof(WCHAR);
        *pCumulative += wcslen(FolderString) * sizeof(WCHAR);

        ReleaseXMLStringToUse(ServerString, ServerAllocated);
        ReleaseXMLStringToUse(FolderString, FolderAllocated);
    }
done:
    return Status;
}


DFSSTATUS
AddLinkCosting(
    DfsLink *pLink,
    ULONG FixedOverhead,
    PULONG pCumulative )
{
    LPWSTR LinkNameString = NULL, CommentString = NULL; 
    BOOLEAN LinkNameAllocated = FALSE, CommentAllocated = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG LinkCost;

    for ( ;
         pLink != NULL;
         pLink = pLink->GetNextLink())
    {
        LinkCost = 0;
        if (pLink->GetFirstTarget() == NULL)
        {
            continue;
        }

        Status = GetXMLStringToUse(pLink->GetLinkNameString(),
                                   FALSE,
                                   &LinkNameString,
                                   &LinkNameAllocated );
        if (Status != ERROR_SUCCESS) 
        {
            break;
        }

        if (IsEmptyString(pLink->GetLinkCommentString()) == FALSE)
        {
            Status = GetXMLStringToUse(pLink->GetLinkCommentString(),
                                       FALSE,
                                       &CommentString,
                                       &CommentAllocated );
            if (Status != ERROR_SUCCESS) 
            {
                break;
            }
        }

        LinkCost += 214;
        LinkCost += FixedOverhead * 2;
        LinkCost += (wcslen(pLink->GetLinkNameString()) * sizeof(WCHAR)) * 2;

        if (CommentString)
        {
            LinkCost += wcslen(CommentString) * sizeof(WCHAR);
        }

        ReleaseXMLStringToUse(LinkNameString, LinkNameAllocated);
        ReleaseXMLStringToUse(CommentString, CommentAllocated);

        Status = AddTargetCosting( pLink->GetFirstTarget(), &LinkCost, FALSE);
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        DebugInformation((L"Cost for link %ws is %d\r\n",
                          pLink->GetLinkNameString(), LinkCost));
        *pCumulative += LinkCost;
    }

    return Status;
}



//
//For each DFS root and for each link, the DFS overhead is 180 bytes. 
//The total space, in bytes, taken up by a root is 180 + (number of 
// characters in DFS Name * 4) + (number of characters in each root 
// target * 2). 
//The total space, in bytes, taken up by each link is 180 + (number of 
// characters in the link name  number of characters in the domain name)
//  * 4) 
//For each DFS root target or target, the DFS overhead is 20 bytes. 
//The total space, in bytes, taken up by a target is 20 + (number of 
// characters in target name * 2) For each unique server that is added 
// as a target or root target, site information takes up some space. 
//This space, in bytes, is 12 + (number of characters in server name 
// + number of characters in site name) * 2. 
//
DFSSTATUS
SizeRoot(
    DfsRoot *pRoot,
    PULONG pBlobSize )
{
    ULONG FixedOverhead;

    ULONG Cumulative = 0;

    DfsPathName PathName;
    DFSSTATUS Status;
    LPWSTR RootName;

    RootName = pRoot->GetLinkNameString();
    if (IsEmptyString(RootName) == FALSE)
    {
        Status = PathName.CreatePathName(RootName);
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
        FixedOverhead = wcslen(PathName.GetShareString()) * sizeof(WCHAR);

        Cumulative += 180 + wcslen(pRoot->GetLinkNameString()) * sizeof(WCHAR) * 2;
    }
    else
    {
        FixedOverhead = 100;
        Cumulative += 380;
    }

    Status = AddTargetCosting(pRoot->GetFirstTarget(), &Cumulative, TRUE);

    if (Status == ERROR_SUCCESS)
    {
        Status = AddLinkCosting(pRoot->GetFirstLink(), FixedOverhead, &Cumulative);
    }

    if (Status == ERROR_SUCCESS)
    {
        // 100K is the smallest amount we display.
        if (Cumulative < 100 * 1024)
        {
            Cumulative = 100 *1024;
        }
        *pBlobSize = Cumulative;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\copyfile.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    SIS fast copy file routines

Authors:

    Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// This is ugly, but we need it in order to check the node type codes on files
// that we're trying to copy, and I figure that it's better than trying to hard
// code the constant.
//
//#include "..\..\..\cntfs\nodetype.h"

NTSTATUS
SipCopyStream(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PUNICODE_STRING      srcFileName,
    IN LONGLONG             srcStreamSize,
    IN PUNICODE_STRING      dstFileName,
    IN PUNICODE_STRING      streamName)
/*++

Routine Description:

    Copy a stream from a source file to a destination file.

Arguments:

    deviceExtension - The device extension for the target device.

    srcFileName     - The fully qualified file name of the source file, not including any stream name.

    srcStreamSize   - The size of the source stream in bytes.

    dstFileName     - The fully qualified file name of the destination file, not including any stream name.

    streamName      - The name of the stream to copy.

Return Value:

    The status of the copy.

--*/
{
    HANDLE              srcFileHandle = NULL;
    HANDLE              dstFileHandle = NULL;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   Obja[1];
    HANDLE              copyEventHandle = NULL;
    PKEVENT             copyEvent = NULL;
    IO_STATUS_BLOCK     Iosb[1];
    UNICODE_STRING      fullName[1];

#if     DBG
    if (BJBDebug & 0x8) {
        return STATUS_UNSUCCESSFUL;
    }
#endif  // DBG

    fullName->Buffer = NULL;

    if (srcFileName->Length > dstFileName->Length) {
        fullName->MaximumLength = srcFileName->Length + streamName->Length;
    } else {
        fullName->MaximumLength = dstFileName->Length + streamName->Length;
    }


    fullName->Buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        fullName->MaximumLength,
                        ' siS');

    if (NULL == fullName->Buffer) {
        SIS_MARK_POINT();
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = SipCreateEvent(
                SynchronizationEvent,
                &copyEventHandle,
                &copyEvent);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    fullName->Length = 0;
    RtlCopyUnicodeString(fullName,srcFileName);

    status = RtlAppendUnicodeStringToString(
                fullName,
                streamName);

    ASSERT(STATUS_SUCCESS == status);   // We guaranteed that the buffer was big enough.

    InitializeObjectAttributes( Obja,
                                fullName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    status = IoCreateFile(
                &srcFileHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                0,                          // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE
                 | FILE_NO_INTERMEDIATE_BUFFERING,
                NULL,                       // EA Buffer
                0,                          // EA length
                CreateFileTypeNone,
                NULL,                       // Extra create parameters
                IO_FORCE_ACCESS_CHECK
                 | IO_NO_PARAMETER_CHECKING
                );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    fullName->Length = 0;
    RtlCopyUnicodeString(fullName,dstFileName);

    status = RtlAppendUnicodeStringToString(
                fullName,
                streamName);

    ASSERT(STATUS_SUCCESS == status);   // We guaranteed that the buffer was big enough.

    InitializeObjectAttributes( Obja,
                                fullName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    status = IoCreateFile(
                &dstFileHandle,
                GENERIC_READ | GENERIC_WRITE,
                Obja,
                Iosb,
                &deviceExtension->FilesystemBytesPerFileRecordSegment,
                FILE_ATTRIBUTE_NORMAL,
                0,                                                      // share access
                FILE_CREATE,
                FILE_NON_DIRECTORY_FILE,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING
                );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    status = SipBltRange(
                deviceExtension,
                srcFileHandle,
                dstFileHandle,
                0,                      // starting offset
                srcStreamSize,          // length
                copyEventHandle,
                copyEvent,
                NULL,                   // abortEvent
                NULL);                  // checksum (we don't care)

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

done:

    if (NULL != fullName->Buffer) {
        ExFreePool(fullName->Buffer);
    }

    if (NULL != srcFileHandle) {
        ZwClose(srcFileHandle);
    }

    if (NULL != dstFileHandle) {
        ZwClose(dstFileHandle);
    }

    if (NULL != copyEvent) {
        ObDereferenceObject(copyEvent);
    }

    if (NULL != copyEventHandle) {
        ZwClose(copyEventHandle);
    }

    return status;
}

NTSTATUS
SipCopyFileCreateDestinationFile(
    IN PUNICODE_STRING              dstFileName,
    IN ULONG                        createDisposition,
    IN PFILE_OBJECT                 calledOnFileObject,
    OUT PHANDLE                     dstFileHandle,
    OUT PFILE_OBJECT                *dstFileObject,
    IN PDEVICE_EXTENSION            deviceExtension)
/*++

Routine Description:

    Create the destination file for a SIS copyfile.  This code is split out from
    the mainline copyfile code because we create the destination in different places
    depending on whether replace-if-exists is set.  This function creates the file
    using the user's privs and verifies that it is on the correct volume and is not
    mapped by the user.  The file is opened exclusively.

Arguments:

    dstFileName         -   The fully qualified name of the file to create.

    createDisposition   -   How to create the file

    calledOnFileObject  -   The file object on which the COPYFILE call was made; used to
                            verify that the destination file is on the right volume.

    dstFileHandle       -   returns a handle to the newly created file

    dstFileObject       -   returns a pointer to the newly created file object

    deviceExtension     -   the device extension for the SIS device

Return Value:

    The status of the create.

--*/
{
    OBJECT_ATTRIBUTES           Obja[1];
    IO_STATUS_BLOCK             Iosb[1];
    NTSTATUS                    status;
    OBJECT_HANDLE_INFORMATION   handleInformation;
    LARGE_INTEGER               zero;
    FILE_STANDARD_INFORMATION   standardInfo[1];
    ULONG                       returnedLength;

    zero.QuadPart = 0;

#if     DBG
    {
        ULONG data = 0;
        ULONG i;

        for (i = 0; (i < 4) && (i * sizeof(WCHAR) < dstFileName->Length); i++) {
            data = data << 8 | (dstFileName->Buffer[dstFileName->Length / sizeof(WCHAR) - i - 1] & 0xff);
        }
        SIS_MARK_POINT_ULONG(data);
    }
#endif  // DBG

    //
    // Create the destination file with exclusive access.  We create the file with an initial allocation of
    // the size of the underlying NTFS BytesPerFileRecordSegment.  We do this in order to force the $DATA attribute
    // to always be nonresident; we deallocate the space later in the copyfile process.  We need to have the
    // attribute be nonresident because otherwise in certain cases when it gets converted to nonresident (which
    // can happen when the reparse point is written) NTFS will generate a paging IO write to the attribute,
    // which SIS will interpret as as a real write, and destroy the file contents.
    //

    InitializeObjectAttributes( Obja,
                                dstFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = IoCreateFile(
                dstFileHandle,
                GENERIC_READ | GENERIC_WRITE | DELETE,
                Obja,
                Iosb,
                &deviceExtension->FilesystemBytesPerFileRecordSegment,
                FILE_ATTRIBUTE_NORMAL,
                0,                                                      // share access
                createDisposition,
                FILE_NON_DIRECTORY_FILE,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING
                );


    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return status;
    }

    //
    // Dereference the file handle to a pointer to the file object.
    //

    status = ObReferenceObjectByHandle( *dstFileHandle,
                                        FILE_WRITE_DATA,
                                        *IoFileObjectType,
                                        UserMode,
                                        (PVOID *) dstFileObject,
                                        &handleInformation );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return status;
    }

    SIS_MARK_POINT_ULONG(*dstFileObject);

    //
    // Make sure the file is on the same device as the file object on which the
    // fsctl came down.
    //

    if (IoGetRelatedDeviceObject( *dstFileObject) !=
        IoGetRelatedDeviceObject( calledOnFileObject )) {

        //
        // The two files refer to different devices. Return an appropriate
        // error.
        //

        SIS_MARK_POINT();

        return STATUS_NOT_SAME_DEVICE;
    }

    //
    // Make sure no one has a section mapped to the destination file.
    //
    if ((NULL != (*dstFileObject)->SectionObjectPointer) &&
        !MmCanFileBeTruncated((*dstFileObject)->SectionObjectPointer,&zero)) {
        //
        // There's a mapped section to the file, so we don't really have it
        // exclusive, so we can't safely turn it into a SIS file.
        //
        SIS_MARK_POINT();
        return STATUS_SHARING_VIOLATION;
    }

    //
    // Make sure the destination file doesn't have hard links to it.
    //

    status = SipQueryInformationFile(
                *dstFileObject,
                deviceExtension->DeviceObject,
                FileStandardInformation,
                sizeof(*standardInfo),
                standardInfo,
                &returnedLength);

    if (sizeof(*standardInfo) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // standard information.
        //
        SIS_MARK_POINT_ULONG(returnedLength);

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    if (1 != standardInfo->NumberOfLinks) {
        SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    return STATUS_SUCCESS;
}

void NTAPI
SipCopyfileSourceOplockCompletionAPC(
    IN PVOID                ApcContext,
    IN PIO_STATUS_BLOCK     iosb,
    IN ULONG                Reserved)
/*++

Routine Description:

    Copyfile sometimes sets an oplock on the source file in order to
    avoid sharing violations.  This is the oplock completion APC that
    gets called when the oplock completes.  All we do is to free the
    IO status block; we're really using the oplock to prevent sharing
    violations, we're not ever going to acknowledge it, we're just going
    to finish the copy and then close the file.

Arguments:

    ApcContext - a pointer to the io status block.

    iosb - a pointer to the same io status block

Return Value:

--*/
{
    UNREFERENCED_PARAMETER( Reserved );
    UNREFERENCED_PARAMETER( ApcContext );

    ASSERT(ApcContext == iosb);

    ExFreePool(iosb);
}

NTSTATUS
SipFsCopyFile(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp)

/*++

Routine Description:

    This fsctrl function copies a file.  Source and destination path names
    are passed in via the input buffer (see SI_COPYFILE).

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PSI_COPYFILE                    copyFile;
    UNICODE_STRING                  fileName[2];
    PFILE_OBJECT                    fileObject[2] = {NULL,NULL};
    HANDLE                          fileHandle[2] = {NULL,NULL};
    LINK_INDEX                      linkIndex[2];
    CSID                            CSid;
    PVOID                           streamInformation = NULL;
    ULONG                           streamAdditionalLengthMagnitude;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                        status;
    OBJECT_HANDLE_INFORMATION       handleInformation;
    IO_STATUS_BLOCK                 Iosb[1];
    PDEVICE_EXTENSION               deviceExtension = DeviceObject->DeviceExtension;
    OBJECT_ATTRIBUTES               Obja[1];
    int                             i;
    PSIS_PER_FILE_OBJECT            perFO;
    PSIS_SCB                        scb;
    LARGE_INTEGER                   zero;
    LARGE_INTEGER                   underlyingFileSize;
    BOOLEAN                         srcIsSISLink;
    FILE_END_OF_FILE_INFORMATION    endOfFile;
    FILE_BASIC_INFORMATION          basicInformation[1];
    FILE_STANDARD_INFORMATION       standardInfo[1];
    FILE_INTERNAL_INFORMATION       internalInformation[1];
    PSIS_PER_LINK                   srcPerLink = NULL;
    PSIS_PER_LINK                   dstPerLink = NULL;
    LARGE_INTEGER                   CSFileNtfsId;
    FILE_ZERO_DATA_INFORMATION      zeroDataInformation[1];
    BOOLEAN                         prepared = FALSE;
    LONGLONG                        CSFileChecksum;
    CHAR                            reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
    PSIS_CS_FILE                    CSFile = NULL;
    ULONG                           returnedLength;
    SIS_CREATE_CS_FILE_REQUEST      createRequest[1];
    PDEVICE_OBJECT                  srcFileRelatedDeviceObject;


#define srcFileName   fileName[0]
#define dstFileName   fileName[1]
#define srcFileObject fileObject[0]
#define dstFileObject fileObject[1]
#define dstFileHandle fileHandle[0]
#define srcFileHandle fileHandle[1]
#define srcLinkIndex  linkIndex[0]
#define dstLinkIndex  linkIndex[1]

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    zero.QuadPart = 0;

    if (!SipCheckPhase2(deviceExtension)) {
        //
        // SIS couldn't initialize.  This probably isn't a SIS-enabled volume, so punt
        // the request.
        //

        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    SIS_MARK_POINT();

    //
    // Make sure the MaxIndex file is already open.  We need to do this
    // to prevent a deadlock if someone perversely wants to do a copyfile
    // with the MaxIndex file itself as the source.  If we can't open it,
    // fail with STATUS_INVALID_DEVICE_REQUEST, because SIS can't properly
    // initialize.
    //
    status = SipAssureMaxIndexFileOpen(deviceExtension);

    if (!NT_SUCCESS(status)) {

        SIS_MARK_POINT_ULONG(status);

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    copyFile = (PSI_COPYFILE) Irp->AssociatedIrp.SystemBuffer;

    //
    // Verify that the input buffer is present, and that it's long enough to contain
    // at least the copyfile header, and that the user isn't expecting output.
    //
    if ((NULL == copyFile)
        || (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(SI_COPYFILE))
        || (irpSp->Parameters.FileSystemControl.OutputBufferLength  != 0)) {
        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_1;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_1;
    }

#if     DBG
    //
    // Check for the magic "checkpoint log" call, which will make a copy of the
    // mark point string buffer.  (This doesn't have anything to do with a legit
    // copyfile request, it's just a convenient entry point for a test application
    // to request this function.)
    //
    if (copyFile->Flags & 0x80000000) {
        SipCheckpointLog();

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = GCH_MARK_POINT_ROLLOVER;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }
#endif  // DBG

    if (copyFile->Flags & ~COPYFILE_SIS_FLAGS) {
        status = STATUS_INVALID_PARAMETER_2;
        goto Error;
    }

    //
    // Verify that the user isn't passing in null-string filenames.
    //
    if ((copyFile->SourceFileNameLength <= 0) ||
        (copyFile->DestinationFileNameLength <= 0)) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_3;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_3;
    }

    srcFileName.Buffer = copyFile->FileNameBuffer;
    srcFileName.MaximumLength = (USHORT) copyFile->SourceFileNameLength;
    srcFileName.Length = srcFileName.MaximumLength - sizeof(WCHAR);

    dstFileName.Buffer = &copyFile->FileNameBuffer[srcFileName.MaximumLength / sizeof(WCHAR)];
    dstFileName.MaximumLength = (USHORT) copyFile->DestinationFileNameLength;
    dstFileName.Length = dstFileName.MaximumLength - sizeof(WCHAR);

    //
    // Verify that the user didn't supply file name length(s) that are too big
    // to fit in a USHORT.
    //
    if (((ULONG)srcFileName.MaximumLength != copyFile->SourceFileNameLength) ||
        ((ULONG)dstFileName.MaximumLength != copyFile->DestinationFileNameLength)) {
        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER;
    }

#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: (%.*ls -> %.*ls)\n",
             __LINE__,
             srcFileName.Length / sizeof(WCHAR),
             srcFileName.Buffer ? srcFileName.Buffer : L"",
             dstFileName.Length / sizeof(WCHAR),
             dstFileName.Buffer ? dstFileName.Buffer : L"");
    }
#endif  // DBG

    //
    // Verify that the buffer is big enough to contain the strings it claims to
    // contain, and that the string lengths passed in by the user make sense.
    //
    if (((ULONG)(srcFileName.MaximumLength
            + dstFileName.MaximumLength
            + FIELD_OFFSET(SI_COPYFILE, FileNameBuffer))
          > irpSp->Parameters.FileSystemControl.InputBufferLength)
        || (0 != (srcFileName.MaximumLength % sizeof(WCHAR)))
        || (0 != (dstFileName.MaximumLength % sizeof(WCHAR)))) {

        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_4;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Open the source file for share read.  Ask only for read access.
    // If it turns out that the source file is not a SIS link, then
    // we'll reopen it exclusively.
    //
    // Note that we must call IoCreateFile instead of ZwCreateFile--the latter
    // bypasses access checking.  IO_NO_PARAMETER_CHECKING causes IoCreateFile
    // to change its local var RequestorMode (PreviousMode) to KernelMode, and
    // IO_FORCE_ACCESS_CHECK forces the same access checking that would be done
    // if the user mode caller had called NtCreateFile directly.
    //

    SIS_MARK_POINT();

    InitializeObjectAttributes( Obja,
                                &srcFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    status = IoCreateFile(
                &srcFileHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                0,                          // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE
                 | FILE_NO_INTERMEDIATE_BUFFERING,
                NULL,                       // EA Buffer
                0,                          // EA length
                CreateFileTypeNone,
                NULL,                       // Extra create parameters
                IO_FORCE_ACCESS_CHECK
                 | IO_NO_PARAMETER_CHECKING
                );

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (! NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Dereference the file handle to a pointer to the file object.
    //

    status = ObReferenceObjectByHandle( srcFileHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        UserMode,
                                        (PVOID *) &srcFileObject,
                                        &handleInformation );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }


    SIS_MARK_POINT_ULONG(srcFileObject);

    srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);

    //
    // Make sure the file is on the same device as the file object on which the
    // fsctl came down.
    //

    if ( srcFileRelatedDeviceObject !=
        IoGetRelatedDeviceObject( irpSp->FileObject )) {

        //
        // The source file is on a different device than the file on which the
        // fsctl was called.  Fail the call.
        //

        SIS_MARK_POINT();

        status = STATUS_NOT_SAME_DEVICE;
        goto Error;
    }

    //
    // Make sure that this file object looks like a valid NTFS file object.
    // There's no really good way to do this, so we just make sure that the file
    // has FsContext and FsContext2 filled in, and that the NodeTypeCode in the
    // FsContext pointer is correct for an NTFS file.  We use a try-except block
    // in case the FsContext pointer is filled in with something that's not really
    // a valid pointer.
    //
    try {
        if (NULL == srcFileObject->FsContext ||
            NULL == srcFileObject->FsContext2 ||
            // NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
            NTFS_NTC_SCB_DATA != ((PFSRTL_COMMON_FCB_HEADER)srcFileObject->FsContext)->NodeTypeCode
           ) {
            SIS_MARK_POINT();

            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

#if     DBG
        DbgPrint("SIS: SipFsCopyFile: took an exception accessing srcFileObject->FsContext.\n");
#endif  // DBG
        SIS_MARK_POINT();

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto Error;
    }


    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    srcIsSISLink = SipIsFileObjectSIS(srcFileObject, DeviceObject, FindActive, &perFO, &scb);
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!srcIsSISLink) {
        //
        // The source file isn't a SIS link, so we need to close it and reopen it exclusively.
        //

        ObDereferenceObject(srcFileObject);
        srcFileObject = NULL;

        ZwClose(srcFileHandle);
        srcFileHandle = NULL;

        SIS_MARK_POINT();

        status = IoCreateFile(
                    &srcFileHandle,
                    GENERIC_READ,
                    Obja,
                    Iosb,
                    0,                          // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    0,                          // sharing (exclusive)
                    FILE_OPEN,
                    FILE_NON_DIRECTORY_FILE
                     | FILE_NO_INTERMEDIATE_BUFFERING,
                    NULL,                       // EA Buffer
                    0,                          // EA length
                    CreateFileTypeNone,
                    NULL,                       // Extra create parameters
                    IO_FORCE_ACCESS_CHECK
                     | IO_NO_PARAMETER_CHECKING
                    );

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Error;
        }

        //
        // Dereference the file handle to a pointer to the file object.
        //

        status = ObReferenceObjectByHandle( srcFileHandle,
                                            FILE_READ_DATA,
                                            *IoFileObjectType,
                                            UserMode,
                                            (PVOID *) &srcFileObject,
                                            &handleInformation );

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        SIS_MARK_POINT_ULONG(srcFileObject);

        srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);

        //
        // Make sure the file is on the same device as the file object on which the
        // fsctl came down.
        //

        if (srcFileRelatedDeviceObject !=
            IoGetRelatedDeviceObject( irpSp->FileObject )) {

            //
            // The source file is on a different device than the file on which the
            // fsctl was called.  Fail the call.
            //

            SIS_MARK_POINT();

            status = STATUS_NOT_SAME_DEVICE;
            goto Error;
        }

        //
        // Make sure that this file object looks like a valid NTFS file object.
        // There's no really good way to do this, so we just make sure that the file
        // has FsContext and FsContext2 filled in, and that the NodeTypeCode in the
        // FsContext pointer is correct for an NTFS file.  We use a try-except block
        // in case the FsContext pointer is filled in with something that's not really
        // a valid pointer.
        //
        try {
            if (NULL == srcFileObject->FsContext ||
                NULL == srcFileObject->FsContext2 ||
                // NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
                NTFS_NTC_SCB_DATA != ((PFSRTL_COMMON_FCB_HEADER)srcFileObject->FsContext)->NodeTypeCode
               ) {
                SIS_MARK_POINT();

                status = STATUS_OBJECT_TYPE_MISMATCH;
                goto Error;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

#if     DBG
            DbgPrint("SIS: SipFsCopyFile: took an exception accessing srcFileObject->FsContext.\n");
#endif  // DBG
            SIS_MARK_POINT();

            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    }

    //
    // Get the basic information to get the file attributes and the date
    // so that we can reset it after we transmute the file if needed.
    // We will also use this to set the data on the destination file.
    //

    status = SipQueryInformationFile(
                srcFileObject,
                DeviceObject,
                FileBasicInformation,
                sizeof(*basicInformation),
                basicInformation,
                &returnedLength);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    if (sizeof(*basicInformation) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // basic information.
        //
        status = STATUS_INFO_LENGTH_MISMATCH;
        SIS_MARK_POINT_ULONG(returnedLength);
        goto Error;
    }

    status = SipQueryInformationFile(
                srcFileObject,
                DeviceObject,
                FileStandardInformation,
                sizeof(*standardInfo),
                standardInfo,
                &returnedLength);

    if (sizeof(*standardInfo) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // standard information.
        //
        status = STATUS_INFO_LENGTH_MISMATCH;

        SIS_MARK_POINT_ULONG(returnedLength);

        goto Error;
    }

    if (1 != standardInfo->NumberOfLinks) {
        SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

        status = STATUS_OBJECT_TYPE_MISMATCH;

        goto Error;
    }

    if (!srcIsSISLink) {

        if (basicInformation->FileAttributes & (FILE_ATTRIBUTE_REPARSE_POINT |
                                                FILE_ATTRIBUTE_ENCRYPTED |
                                                FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // We can't SIS-ify other drivers' reparse points
            // and we don't touch encrypted files or directories.
            // Reject the call.
            //
            SIS_MARK_POINT();
            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        if (copyFile->Flags & COPYFILE_SIS_LINK) {
            //
            // The caller wants a copy only if the source is already a link
            // (fast copy).  It isn't, so return.
            //
            SIS_MARK_POINT();
            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        if (basicInformation->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
            //
            // We only copy sparse files if they're fully allocated.  Check to see
            // if it is.
            //

            FILE_STANDARD_INFORMATION       lStandardInfo[1];
            FILE_ALLOCATED_RANGE_BUFFER     inArb[1];
            FILE_ALLOCATED_RANGE_BUFFER     outArb[1];

            status = SipQueryInformationFile(
                        srcFileObject,
                        DeviceObject,
                        FileStandardInformation,
                        sizeof(FILE_STANDARD_INFORMATION),
                        lStandardInfo,
                        NULL);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);

                goto Error;
            }

            inArb->FileOffset.QuadPart = 0;
            inArb->Length.QuadPart = MAXLONGLONG;

            status = SipFsControlFile(
                        srcFileObject,
                        DeviceObject,
                        FSCTL_QUERY_ALLOCATED_RANGES,
                        inArb,
                        sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                        outArb,
                        sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                        &returnedLength);

            if ((returnedLength == 0)
                || (outArb->FileOffset.QuadPart != 0)
                || (outArb->Length.QuadPart < lStandardInfo->EndOfFile.QuadPart)) {

                //
                // It's not fully allocated.  Disallow the copy.
                //
                status = STATUS_OBJECT_TYPE_MISMATCH;
                SIS_MARK_POINT();
                goto Error;
            }
        }

    }

    if ((NULL != srcFileObject->SectionObjectPointer) &&
        !MmCanFileBeTruncated(srcFileObject->SectionObjectPointer,&zero)) {
        //
        // There's a mapped section to the file, so we don't really have it
        // exclusive, so we can't use it for a source file.  Fail.
        //

        SIS_MARK_POINT_ULONG(srcFileObject);

        status = STATUS_SHARING_VIOLATION;
        goto Error;
    }

    if (!(copyFile->Flags & COPYFILE_SIS_REPLACE)) {

        //
        // We're not doing an overwrite create, so open the file before we do anything
        // else.  This allows us to do more validity checks before making the common
        // store file and mutating the source link (if needed).  If we're opening overwrite
        // then we postpone the open so that certain errors (like not being able to create
        // the common store file) do not cause us to overwrite the destination.
        //

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipCopyFileCreateDestinationFile(
                    &dstFileName,
                    FILE_CREATE,
                    irpSp->FileObject,
                    &dstFileHandle,
                    &dstFileObject,
                    deviceExtension);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }
    }

    //
    // If the source file is not already a SIS link, then move the file
    // into the common store and create a link to it.
    //

    if (!srcIsSISLink) {

        FILE_STANDARD_INFORMATION       standardInformation[1];

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        //
        // Query the standard information to get the file length.
        //
        status = SipQueryInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileStandardInformation,
                    sizeof(*standardInformation),
                    standardInformation,
                    NULL);                          // returned length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        underlyingFileSize = standardInformation->EndOfFile;

        //
        // Get the NTFS file id.  We need this in order to write the log record for the
        // CS file refcount change without a per-FO.
        //
        status = SipQueryInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileInternalInformation,
                    sizeof(*internalInformation),
                    internalInformation,
                    NULL);                      // returned length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Copy the source file into the common store directory and set
        // its ref count.
        //

        createRequest->deviceExtension = deviceExtension;
        createRequest->CSid = &CSid;
        createRequest->NtfsId = &CSFileNtfsId;
        createRequest->abortEvent = NULL;
        createRequest->CSFileChecksum = &CSFileChecksum;
#undef  srcFileObject   // this is ugly, but I'm in a hurry.  Clean up later.  BJB
        createRequest->srcFileObject = fileObject[0];
#define srcFileObject   fileObject[0]

        KeInitializeEvent(createRequest->doneEvent,NotificationEvent,FALSE);

        ExInitializeWorkItem(
                createRequest->workQueueItem,
                SipCreateCSFileWork,
                createRequest);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ExQueueWorkItem(
                createRequest->workQueueItem,
                DelayedWorkQueue);

        status = KeWaitForSingleObject(
                    createRequest->doneEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ASSERT(STATUS_SUCCESS == status);       // createRequest is on our stack, so we really need to wait

        status = createRequest->status;

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Error;
        }

        //
        // Lookup a CSFile object.
        //
        CSFile = SipLookupCSFile(
                    &CSid,
                    &CSFileNtfsId,
                    DeviceObject);

        if (NULL == CSFile) {
            SIS_MARK_POINT();
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Indicate that this is a new CS file that's never had a reference
        // to it.  We don't need to take the spin lock because before we write
        // the reparse point no one can know the GUID to get to this CS file, so
        // we're sure we have it exclusively.
        //
        CSFile->Flags |= CSFILE_NEVER_HAD_A_REFERENCE;

        //
        // Prepare to increment the reference count on the CS file, and allocate
        // a new link index and per link for the file.
        //
        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                    CSFile,
                    &internalInformation->IndexNumber,
                    DeviceObject,
                    &srcLinkIndex,
                    &srcPerLink,
                    &prepared);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Fill in the reparse point data.
        //

        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
                 reparseBuffer,
                 &CSid,
                 &srcLinkIndex,
                 &CSFileNtfsId,
                 &internalInformation->IndexNumber,
                 &CSFileChecksum,
                 TRUE)) {

            SIS_MARK_POINT();

            status = STATUS_DRIVER_INTERNAL_ERROR;
            goto Error;

        }

        //
        // Set the reparse point information and increment the CS file refcount.
        // This needs to proceed using the prepare/act/finish protocol for updating
        // the reference count.  Note that we do this before zeroing the file
        // so as not to lose the contents in the event of a failure later on.
        //

        status = SipFsControlFile(
                     srcFileObject,
                     DeviceObject,
                     FSCTL_SET_REPARSE_POINT,
                     reparseBuffer,
                     FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
                     NULL,                //  Output buffer
                     0,                   //  Output buffer length
                     NULL);               //  returned output buffer length

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        prepared = FALSE;
        status = SipCompleteCSRefcountChange(
                        srcPerLink,
                        &srcPerLink->Index,
                        CSFile,
                        TRUE,
                        TRUE);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            //
            // Now what?  Probably should back out the file copy, but we'll just pretend
            // that it worked.
            //
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipFsCopyFile: unable to complete refcount change, 0x%x\n",status);
#endif  // DBG
        }

        //
        // Set the file sparse, and zero it.
        //

        status = SipFsControlFile(
                    srcFileObject,
                    DeviceObject,
                    FSCTL_SET_SPARSE,
                    NULL,               // input buffer
                    0,                  // i.b. length
                    NULL,               // output buffer
                    0,                  // o.b. length
                    NULL);              // returned length

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        if (underlyingFileSize.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
            //
            // Only zero the file if we're sure that it's $DATA attribute is non-resident.
            // If it's resident, then either we'll convert it to non-resident below, which will
            // generate a paging IO write that will confuse us, or else it will stay resident
            // in which case it will appear to be allocated when we open the file.  If that happens,
            // we want to have the correct data in the file, hence we avoid zeroing it here.
            //

            zeroDataInformation->FileOffset.QuadPart = 0;
            zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

            status = SipFsControlFile(
                        srcFileObject,
                        DeviceObject,
                        FSCTL_SET_ZERO_DATA,
                        zeroDataInformation,
                        sizeof(FILE_ZERO_DATA_INFORMATION),
                        NULL,               // output buffer
                        0,                  // o.b. length
                        NULL);              // returned length

            SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                goto Error;
            }
        }

        //
        // Reset the file times that are contained in the basic information.
        //

        status = SipSetInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileBasicInformation,
                    sizeof(*basicInformation),
                    basicInformation);

        //
        // Just ignore errors on this (maybe we should return a warning?)
        //
#if DBG
        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            DbgPrint("SIS: SipFsCopyFile: set basic information returned 0x%x\n",status);
        }
#endif  // DBG

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ASSERT(NULL != CSFile);
        SipDereferenceCSFile(CSFile);
        CSFile = NULL;

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    } else {

        //
        // The source file is a SIS link.
        //

        PSIS_CS_FILE        csFile = scb->PerLink->CsFile;
        KIRQL               OldIrql;
        BOOLEAN             SourceDirty, SourceDeleted;

        srcPerLink = scb->PerLink;

        SipReferencePerLink(srcPerLink);

        KeAcquireSpinLock(srcPerLink->SpinLock, &OldIrql);
        SourceDirty = (srcPerLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
        SourceDeleted = (srcPerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;
        KeReleaseSpinLock(srcPerLink->SpinLock, OldIrql);

        SipAcquireScb(scb);
        if (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) {
            SIS_MARK_POINT();
            SourceDirty = TRUE;
        }
        SipReleaseScb(scb);

        if (SourceDirty) {
            //
            // The source is a SIS link, but it is dirty, so we can't just copy the CS file.
            // Furthermore, we're not really equipped to make it into a new CS file while
            // it's still open and dirty.  Just fail the request.  NB: There is no race
            // here between checking the dirty bit and completing the copy.  If someone
            // sets the dirty bit later, all that will happen is that we'll have a copy
            // of the old file.
            //
            SIS_MARK_POINT();
            status = STATUS_SHARING_VIOLATION;
            goto Error;
        }

        if (SourceDeleted) {
            //
            // The source file is deleted, so we can't copy it.
            //
            SIS_MARK_POINT();
            status = STATUS_FILE_DELETED;
            goto Error;
        }

        //
        // Get the existing common store index.
        //

        CSid = csFile->CSid;

        CSFileNtfsId = csFile->CSFileNtfsId;
        underlyingFileSize = csFile->FileSize;
        CSFileChecksum = csFile->Checksum;
    }

    if (copyFile->Flags & COPYFILE_SIS_REPLACE) {

        //
        // We've postponed opening (and therefore destroying) the destination file
        // as long as possible.  Do it now.
        //

        ASSERT(NULL == dstFileHandle);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipCopyFileCreateDestinationFile(
                    &dstFileName,
                    FILE_OVERWRITE_IF,
                    irpSp->FileObject,
                    &dstFileHandle,
                    &dstFileObject,
                    deviceExtension);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }
    }

    //
    // Set the destination file sparse and set its length to be equal to
    // that of the underlying file.
    //
    status = SipFsControlFile(
                dstFileObject,
                DeviceObject,
                FSCTL_SET_SPARSE,
                NULL,               // input buffer
                0,                  // i.b. length
                NULL,               // output buffer
                0,                  // o.b. length
                NULL);              // returned o.b. length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    endOfFile.EndOfFile = underlyingFileSize;

    status = SipSetInformationFile(
                 dstFileObject,
                 DeviceObject,
                 FileEndOfFileInformation,
                 sizeof(FILE_END_OF_FILE_INFORMATION),
                 &endOfFile);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Zero the file to blow away the allocation.
    //

    zeroDataInformation->FileOffset.QuadPart = 0;
    zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

    status = SipFsControlFile(
                dstFileObject,
                DeviceObject,
                FSCTL_SET_ZERO_DATA,
                zeroDataInformation,
                sizeof(FILE_ZERO_DATA_INFORMATION),
                NULL,               // output buffer
                0,                  // o.b. length
                NULL);              // returned length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Get the NTFS file id.  We need this in order to write the log record for the
    // CS file refcount change without a per-FO.
    //
    status = SipQueryInformationFile(
                dstFileObject,
                DeviceObject,
                FileInternalInformation,
                sizeof(*internalInformation),
                internalInformation,
                NULL);                          // returned length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Prepare a refcount change for the common store file, allocate a new
    // link index and a new perLink.
    //
    status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                srcPerLink->CsFile,
                &internalInformation->IndexNumber,
                DeviceObject,
                &dstLinkIndex,
                &dstPerLink,
                &prepared);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    //  Build destination reparse point data.
    //

    reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

    if (!SipIndicesIntoReparseBuffer(
             reparseBuffer,
             &CSid,
             &dstLinkIndex,
             &CSFileNtfsId,
             &internalInformation->IndexNumber,
             &CSFileChecksum,
             TRUE)) {

        SIS_MARK_POINT();

        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto Error;

    }

    //
    //  Set a SIS link reparse point.
    //

#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: SipFsControlFile on dstFile\n",__LINE__);
    }
#endif  // DBG

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    status = SipFsControlFile(
                 dstFileObject,
                 DeviceObject,
                 FSCTL_SET_REPARSE_POINT,
                 reparseBuffer,
                 FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
                 NULL,                //  Output buffer
                 0,                   //  Output buffer length
                 NULL);               //  returned output buffer length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Set the file times on the destination file to be the same as the source.
    //

    status = SipSetInformationFile(
                dstFileObject,
                DeviceObject,
                FileBasicInformation,
                sizeof(*basicInformation),
                basicInformation);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        //
        // Not sure what to do if this fails.  Just ignore it for now.
        //
        SIS_MARK_POINT_ULONG(status);
#if     DBG
        DbgPrint("SIS: SipFsCopyFile: set times on source failed 0x%x\n",status);
#endif  // DBG
    }

    prepared = FALSE;
    status = SipCompleteCSRefcountChange(
                dstPerLink,
                &dstPerLink->Index,
                dstPerLink->CsFile,
                TRUE,
                TRUE);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

#if     DBG
        DbgPrint("SIS: SipFsCopyFile: final complete failed 0x%x\n",status);
#endif  // DBG

        goto Error;
    }


    //
    // Figure out if the source file has more than one stream, and if it does
    // copy the extra streams into the destination file.  We do not support
    // single instancing on secondary streams, but do allow them to have
    // ordinary alternate data streams, which may or may not have different
    // content.
    //
    // We need to close the primary stream before we copy the alternate
    // streams, or else we wind up with ValidDataLength getting messed up, which
    // is why we do this so late.
    //
    // The API for querying the names of the additional streams leaves something
    // to be desired, in that there is no way to tell how much buffer to use.
    // We work around this issue by exponentially increasing (by powers of 4) the amount of buffer
    // and calling back into NTFS each time we find that we hadn't supplied enough.
    // We start with 1 kilobyte of extra space, and then increase up to a
    // megabyte before giving up.
    //

    for (streamAdditionalLengthMagnitude = 10;
         streamAdditionalLengthMagnitude <= 20;
         streamAdditionalLengthMagnitude += 2)  {

        ULONG                       streamBufferSize = (1 << streamAdditionalLengthMagnitude) + sizeof(FILE_STREAM_INFORMATION);
        PFILE_STREAM_INFORMATION    currentStream;

        if (NULL != streamInformation) {
            ExFreePool(streamInformation);
        }

        streamInformation = ExAllocatePoolWithTag(PagedPool,
                                                  streamBufferSize,
                                                  ' siS');

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (NULL == streamInformation) {
            SIS_MARK_POINT();

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        status = SipQueryInformationFile(
                     srcFileObject,
                     DeviceObject,
                     FileStreamInformation,
                     streamBufferSize,
                     streamInformation,
                     NULL                                   // returned length
                     );

        if (STATUS_BUFFER_OVERFLOW == status) {
            //
            // We didn't supply enough buffer.  Grow it and try again.
            continue;
        }

        if (!NT_SUCCESS( status )) {
            //
            // It failed for some other reason, so we can't do the copy.
            //
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Run through the list of streams, and copy each one that's not named ::DATA$
        //
        currentStream = (PFILE_STREAM_INFORMATION)streamInformation;
        for (;;) {
            UNICODE_STRING  string;

            //
            // The "stream" name should be of the form :stream:DATA$.  If it's not of this form,
            // we ignore it.  If "stream" is the null string, we also ignore it.
            //

            ASSERT(currentStream->StreamNameLength < MAXUSHORT);

            if ((currentStream->StreamNameLength > 7 * sizeof(WCHAR)) &&
                (':' == currentStream->StreamName[0])) {
                //
                // The name starts with a colon, and is long enough to conclude with :DATA$
                // and have a non-null stream name.  Verify that it ends with :DATA$.
                //
                string.MaximumLength = string.Length =  5 * sizeof(WCHAR);
                string.Buffer = currentStream->StreamName + currentStream->StreamNameLength/sizeof(WCHAR) - 5;
                if (RtlEqualUnicodeString(&string,&NtfsDataString,TRUE) &&
                    (':' == currentStream->StreamName[currentStream->StreamNameLength/sizeof(WCHAR) - 6])) {

                    //
                    // We have an alternate data stream to copy.  If we haven't already, close the main
                    // stream so that NTFS doesn't reset ValidDataLength to 0.
                    //
                    if (NULL != dstFileHandle) {
                        ZwClose(dstFileHandle);
                        dstFileHandle = NULL;

                        ASSERT(NULL != dstFileObject);
                        ObDereferenceObject(dstFileObject);
                        dstFileObject = NULL;
                    } else {
                        ASSERT(NULL == dstFileObject);
                    }

                    //
                    // The stream name is of the form :stream:DATA$, and "stream" is not the null string.
                    // Copy the stream to the destination file.
                    //
                    string.MaximumLength = string.Length = (USHORT)(currentStream->StreamNameLength - 6 * sizeof(WCHAR));
                    string.Buffer = currentStream->StreamName;

                    status = SipCopyStream(
                                deviceExtension,
                                &srcFileName,
                                currentStream->StreamSize.QuadPart,
                                &dstFileName,
                                &string);

                    if (!NT_SUCCESS(status)) {
                        NTSTATUS        reopenStatus;

                        SIS_MARK_POINT_ULONG(status);

                        //
                        // Try to reopen the destination file so that we can later delete it.
                        //

                        reopenStatus = SipCopyFileCreateDestinationFile(
                                            &dstFileName,
                                            FILE_OVERWRITE_IF,
                                            irpSp->FileObject,
                                            &dstFileHandle,
                                            &dstFileObject,
                                            deviceExtension);

                        SIS_MARK_POINT_ULONG(reopenStatus);

                        //
                        // We don't care if the reopen worked; if it didn't, then we just won't be able to
                        // delete the partially created destinaion file object, which is just too bad.
                        // Note that we have already written the reparse point and finished the refcount update,
                        // so this create will be a full SIS create, and the delete below will be a full SIS
                        // delete, which will remove the newly created backpointer.
                        //

                        goto Error;
                    }
                }
            }

            if (0 == currentStream->NextEntryOffset) {
                //
                // This was the last stream in the buffer.  We're done.
                //
                goto doneWithStreams;
            }

            currentStream = (PFILE_STREAM_INFORMATION)(((PCHAR)currentStream) + currentStream->NextEntryOffset);
        }

    }   // Loop over stream buffer size

doneWithStreams:

    if (STATUS_BUFFER_OVERFLOW == status) {
        ASSERT(streamAdditionalLengthMagnitude > 20);

        //
        // Even a truly enormous buffer wasn't enough.  Too bad.
        //
        SIS_MARK_POINT();

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto Error;

    } else {
        ASSERT(streamAdditionalLengthMagnitude <= 20);
    }


Error:

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        if (prepared) {
            if (NULL == CSFile) {
                if (NULL != srcPerLink) {
                    SipCompleteCSRefcountChange(
                        srcPerLink,
                        &srcPerLink->Index,
                        srcPerLink->CsFile,
                        FALSE,
                        TRUE);
                } else {
                    ASSERT(NULL != dstPerLink);
                    SipCompleteCSRefcountChange(
                        dstPerLink,
                        &dstPerLink->Index,
                        dstPerLink->CsFile,
                        FALSE,
                        TRUE);
                }
            } else {
                SipCompleteCSRefcountChange(
                        NULL,
                        NULL,
                        CSFile,
                        FALSE,
                        TRUE);
            }
        }

        //
        // Delete the destination file if it was created.
        //

        if (dstFileObject) {

            FILE_DISPOSITION_INFORMATION disposition[1];
            NTSTATUS deleteStatus;

            disposition->DeleteFile = TRUE;

            //
            // We might be in the error path because the destination file was not on the
            // right device object.  If that's the case, then we can't use SipSetInformationFile
            // on it because it will hand the file object to the wrong device.  Instead, use
            // the generic version of the call, and start the irp at the top of the device
            // stack for the particular file object.
            //

            deleteStatus = SipSetInformationFileUsingGenericDevice(
                                dstFileObject,
                                IoGetRelatedDeviceObject(dstFileObject),
                                FileDispositionInformation,
                                sizeof(FILE_DISPOSITION_INFORMATION),
                                disposition);

#if DBG
            if (deleteStatus != STATUS_SUCCESS) {

                //
                // Not much we can do about this.  Just leak the file.
                //

                DbgPrint("SipFsCopyFile: unable to delete copied file, err 0x%x, initial error 0x%x\n", deleteStatus, status);
            }
#endif
        }
    } else {
        ASSERT(!prepared);
    }

    //
    // If there is a source file handle, close it.
    //
    if (NULL != srcFileHandle && NULL != srcFileObject) {
        ZwClose(srcFileHandle);
    }

    //
    // Close the destination file handle if there is one.
    //
    if (NULL != dstFileHandle) {
        ZwClose(dstFileHandle);
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    for (i = 0; i < 2; ++i) {
        if (fileObject[i]) {
            ObDereferenceObject(fileObject[i]);
        }
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (streamInformation) {
        ExFreePool(streamInformation);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != srcPerLink) {
        SipDereferencePerLink(srcPerLink);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != dstPerLink) {
        SipDereferencePerLink(dstPerLink);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != CSFile) {
        SipDereferenceCSFile(CSFile);
#if     DBG
        CSFile = NULL;
#endif  // DBG
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);


#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: status %x\n", status);
    }
#endif  // DBG

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    return status;
}
#undef  reparseBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\refcount.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    refcount.c

Abstract:

	Common store file refcount support for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipProcessRefcountUpdateLogRecord)
#if		ENABLE_LOGGING
#pragma alloc_text(PAGE, SipRemoveRefBecauseOfLog)
#pragma alloc_text(PAGE, SipProcessRefcountLogDeleteRecord)
#pragma alloc_text(PAGE, SipAssureBackpointer)
#endif	// ENABLE_LOGGING
#endif	// ALLOC_PRAGMA
//
// A request to delete a common store file.
//
typedef struct _SI_DELETE_CS_FILE_REQUEST {
	WORK_QUEUE_ITEM			workQueueItem[1];
	PSIS_CS_FILE			CSFile;
	NTSTATUS				Status;
	KEVENT					event[1];
} SI_DELETE_CS_FILE_REQUEST, *PSI_DELETE_CS_FILE_REQUEST;

NTSTATUS
SipDeleteCSFile(
	PSIS_CS_FILE					CSFile)
/*++

Routine Description:

	Delete a common store file and close the handles/file objects we have to
	it.  Must be called in the PsInitialSystemProcess context (ie. on a worker
	thread).

Arguments:

	CSFile - the common store file to delete

Return Value:

	Returns the status of call.

--*/
{
	KIRQL							OldIrql;
	HANDLE							handleForDeleting = NULL;
	FILE_DISPOSITION_INFORMATION 	dispositionInformation[1];
	IO_STATUS_BLOCK					Iosb[1];
	NTSTATUS						status;

	status = SipAcquireUFO(CSFile/*,TRUE*/);

    if (!NT_SUCCESS(status)) {

        SIS_MARK_POINT_ULONG(status);
        return status;
    }

	SIS_MARK_POINT_ULONG(CSFile);

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
	CSFile->Flags |= CSFILE_FLAG_DELETED;
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

	status = SipOpenCSFileWork(
					CSFile, 
					TRUE, 						// openByName
					FALSE, 						// volCheck
					TRUE,						// openForDelete
					&handleForDeleting);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	dispositionInformation->DeleteFile = TRUE;
	status = NtSetInformationFile(	
				handleForDeleting,
				Iosb,
				dispositionInformation,
				sizeof(FILE_DISPOSITION_INFORMATION),
				FileDispositionInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// The file's gone now, so close all handles and file objects
	// that refer to it, except for the UndelyingFileObject.  We
	// keep that one around to avoid races with threads that have
	// already looked at it but haven't yet finished using it.
	//

	if (NULL != CSFile->UnderlyingFileHandle) {
		NtClose(CSFile->UnderlyingFileHandle);
		CSFile->UnderlyingFileHandle = NULL;
	}

	if (NULL != CSFile->BackpointerStreamFileObject) {
		ObDereferenceObject(CSFile->BackpointerStreamFileObject);
		CSFile->BackpointerStreamFileObject = NULL;
	}

	if (NULL != CSFile->BackpointerStreamHandle) {
		NtClose(CSFile->BackpointerStreamHandle);
		CSFile->BackpointerStreamHandle = NULL;
	}

done:

	if (NULL != handleForDeleting) {
		NtClose(handleForDeleting);
	}

	SipReleaseUFO(CSFile);

	return status;
}

VOID
SipDeleteCSFileWork(
	PVOID								Parameter)
/*++

Routine Description:

	A wrapper function for SipDeleteCSFile that extract the CSFile pointer from
	a request, calls SipDeleteCSFile, sticks the status in the request and sets
	the appropriate event.

Arguments:

	Parameter - a PSI_DELETE_CS_FILE_REQUEST

Return Value:

	void

--*/
{
	PSI_DELETE_CS_FILE_REQUEST		deleteRequest = Parameter;
	PSIS_CS_FILE					CSFile = deleteRequest->CSFile;

    deleteRequest->Status = SipDeleteCSFile(CSFile);

	KeSetEvent(deleteRequest->event, IO_NO_INCREMENT, FALSE);

	return;
}

NTSTATUS
SipPrepareCSRefcountChange(
	IN PSIS_CS_FILE						CSFile,
	IN OUT PLINK_INDEX					LinkIndex,
	IN PLARGE_INTEGER					LinkFileNtfsId,
	IN ULONG							UpdateType)
/*++

Routine Description:

	The first half of a prepare/commit pair for updating the refcount on a common
	store file.  This function must be called (and complete successfully) before
	we can add/delete the reparse point for a given per-link.

	If we're adding a reference, this routine will allocate a new link index
	and return it in the LinkIndex field.

	This function takes the backpointer resource for the given common store file
	exclusively, effectively serializing all updates to a particular common store
	file.

Arguments:

	CSFile - the common store file to which we're going to add/delete a reference

	LinkIndex - a pointer to the link index.  This is an IN parameter if
		increment is FALSE, an OUT parameter otherwise.
	
	LinkFileNtfsId - a pointer to the NTFS file id for the link file.  

	UpdateType - is this a create, delete or overwrite?

Return Value:

	Returns the status of call.  A successful return means that the appropriate
	log record has been committed to disk and the link index allocated if
	appropriate.

--*/
{
	NTSTATUS					status;
	SIS_LOG_REFCOUNT_UPDATE		logRecord[1];

	ASSERT((SIS_REFCOUNT_UPDATE_LINK_DELETED == UpdateType)
			|| (SIS_REFCOUNT_UPDATE_LINK_CREATED == UpdateType)
			|| (SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN == UpdateType));

	SipAcquireBackpointerResource(CSFile, TRUE, TRUE);

	if (SIS_REFCOUNT_UPDATE_LINK_CREATED == UpdateType) {
		PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;

		status = SipAllocateIndex(deviceExtension,LinkIndex);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			SipReleaseBackpointerResource(CSFile);

			return status;
		}
	}

	//
	// Log the update.
	//

	logRecord->UpdateType = UpdateType;
	logRecord->LinkFileNtfsId = *LinkFileNtfsId;
	logRecord->LinkIndex = *LinkIndex;
	logRecord->CSid = CSFile->CSid;

	status = SipMakeLogEntry(
				CSFile->DeviceObject->DeviceExtension,
				SIS_LOG_TYPE_REFCOUNT_UPDATE,
				sizeof(SIS_LOG_REFCOUNT_UPDATE),
				logRecord);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		SipReleaseBackpointerResource(CSFile);

		return status;
	}

	ASSERT(STATUS_PENDING != status);

	return STATUS_SUCCESS;
}


NTSTATUS
SipCompleteCSRefcountChangeForThread(
	IN OUT PSIS_PER_LINK				PerLink,
	IN PLINK_INDEX						LinkIndex,
	IN PSIS_CS_FILE						CSFile,
    IN BOOLEAN							Success,
	IN BOOLEAN							Increment,
	IN ERESOURCE_THREAD					thread)
/*++

Routine Description:

	The second half of a prepare/commit pair for updating the refcount on a common
	store file.  This function is called when the resolution of the action proposed
	in a prepare is known.  If the action worked (indicated by setting Success to
	TRUE), this function will appropriately update the backpointer stream for the
	affected common store file.

	This function releases the backpointer resource for the common store file.
	

Arguments:

	PerLink		- the per-link for the added/deleted link.  Only required if Success is
					TRUE.

    LinkIndex   - the index of the added/deleted link.  Only required if Success is TRUE.

	CSFile		- the common store file we're updating.

	Success		- did the update work

	Increment	- was this a create (TRUE) or delete (FALSE) operation?

	thread		- the ERESOURCE_THREAD on which the prepare was called

Return Value:

	Returns the status of call.  

--*/
{
	NTSTATUS					status;
	BOOLEAN						referencesRemain;
	SI_DELETE_CS_FILE_REQUEST	deleteRequest[1];
	KIRQL						OldIrql;
	BOOLEAN						deleteCSFile = FALSE;

    UNREFERENCED_PARAMETER(thread);

	SIS_MARK_POINT_ULONG(PerLink);
	SIS_MARK_POINT_ULONG(CSFile);
	SIS_MARK_POINT_ULONG((Success << 1) | Increment);


	//ASSERT(NULL == PerLink || (PerLink->CsFile == CSFile));	// SipMergeFiles associates a PerLink with a different CSFile
	ASSERT((NULL != LinkIndex) || !Success);
	ASSERT((NULL != PerLink) || !Success);

	if (Success) {
		if (Increment) {
			status = SipAddBackpointer(CSFile,LinkIndex,&PerLink->LinkFileNtfsId);
			if (NT_SUCCESS(status)) {
				KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
				CSFile->Flags &= ~CSFILE_NEVER_HAD_A_REFERENCE;
				KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
			}
		} else {
			status = SipRemoveBackpointer(CSFile,LinkIndex,&PerLink->LinkFileNtfsId,&referencesRemain);

			if (NT_SUCCESS(status)) {

				//
				// We've blasted the backpointer successfully, mark the file as deleted.
				//

				KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
				ASSERT(!(PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE));
				PerLink->Flags |= SIS_PER_LINK_BACKPOINTER_GONE;
				KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

				SIS_MARK_POINT_ULONG(referencesRemain);

				//
				// If this was the last reference to the common store file, delete it.  We need to
				// post to do this because we need a new handle in order to properly call delete.
				//

				if (!referencesRemain) {
					deleteCSFile = TRUE;
				}
			} else {
				SIS_MARK_POINT_ULONG(status);
			}
		}
	} else {
		if (Increment) {
			//
			// This is a failed increment.  See if the common store file never had a reference,
			// in which case we delete it.
			//
			KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
			if (CSFile->Flags & CSFILE_NEVER_HAD_A_REFERENCE) {
				deleteCSFile = TRUE;
			}
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
		}
		status = STATUS_SUCCESS;
	}

	if (deleteCSFile) {
		//
		// We need to post work to PsInitialSystemProcess in order
		// to delete the common store file.
		//

		deleteRequest->CSFile = CSFile;
		KeInitializeEvent(deleteRequest->event, NotificationEvent, FALSE);

		ExInitializeWorkItem(deleteRequest->workQueueItem, SipDeleteCSFileWork, deleteRequest);
		ExQueueWorkItem(deleteRequest->workQueueItem, CriticalWorkQueue);

		status = KeWaitForSingleObject(deleteRequest->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);
	}

	SipReleaseBackpointerResource(CSFile);

	return status;
}



NTSTATUS
SipCompleteCSRefcountChange(
	IN OUT PSIS_PER_LINK				PerLink,
    IN PLINK_INDEX						LinkIndex,
	IN PSIS_CS_FILE						CSFile,
	IN BOOLEAN							Success,
	IN BOOLEAN							Increment)
/*++

Routine Description:

	Wrapper for SipCompleteCSRefcountChangeForThread that fills in the current thread.
	See SipCompleteCSRefcountChangeForThread for comments.
	

Arguments:

	See SipCompleteCSRefcountChangeForThread.

Return Value:

	Returns the status of call.

--*/
{
	return SipCompleteCSRefcountChangeForThread(
			PerLink,
            LinkIndex,
			CSFile,
			Success,
			Increment,
			ExGetCurrentResourceThread());
}


#if		DBG
//
// Instrumentation
//

ULONG	BPCacheHits = 0;
ULONG	BPPageHits = 0;
ULONG	BPCacheMisses = 0;
ULONG	BPLookupSteps = 0;
ULONG	BPLookupReads = 0;
ULONG	BPDeleteAttempts = 0;
ULONG	BPDeleteReads = 0;
ULONG	BPDeleteTruncations = 0;
#endif	// DBG

NTSTATUS
SiDeleteAndSetCompletion(
	IN PDEVICE_OBJECT			DeviceObject,
	IN PIRP						Irp,
	IN PVOID					Context)
/*++

Routine Description:

	An IO completion routine for making asyncronous IO calls synchronous.
	Takes an event pointer as its parameter, sets the event, frees
	the irp (and its MDL) and terminates completion processing by returning
	STATUS_MORE_PROCESSING_REQUIRED.

Arguments:

	DeviceObject - ignored

	Irp - the irp that's being completed

	Context - pointer to the event to set

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

	
--*/
{
	PKEVENT		event = (PKEVENT)Context;
	PMDL		mdl, nextMdl;

    UNREFERENCED_PARAMETER( DeviceObject );
	ASSERT(NULL != Irp->UserIosb);

	*Irp->UserIosb = Irp->IoStatus;

	mdl = Irp->MdlAddress;
	while (NULL != mdl) {
		nextMdl = mdl->Next;
		MmUnlockPages(mdl);
		IoFreeMdl( mdl);
		mdl = nextMdl;
	}

	ASSERT(NULL == Irp->Tail.Overlay.AuxiliaryBuffer);	// else we'd have to free it.

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;

	
}

NTSTATUS
SipCheckBackpointer(
	IN PSIS_PER_LINK			PerLink,
    IN BOOLEAN                  Exclusive,
	OUT PBOOLEAN				foundMatch		OPTIONAL)
/*++

Routine Description:

	Check to be sure that there is a backpointer for this link index, and that
	the backpointer has the right file id.  If there isn't, initiate a volume check.

	Caller must hold the BackpointerResource (either shared or exclusive will do),
	this routine will not release it.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	PerLink - the perLink whose backpointer we want to check

	foundMatch - out boolean set to whether we found a match

Return Value:

	status of the check

	
--*/
{
	ULONG					i;
	ULONG					x, l, r;
	PSIS_BACKPOINTER		sector = NULL;
	PCHAR					page = NULL;
	PSIS_BACKPOINTER		thisEntry;
	ULONG					currentSectorMinEntry = MAXULONG;
	ULONG					currentPageMinEntry = MAXULONG;
	ULONG					sectorsPerPage;
	PIRP					irp;
	KEVENT					event[1];
	PSIS_CS_FILE			CSFile = PerLink->CsFile;
	PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;
	LARGE_INTEGER			fileOffset;
	IO_STATUS_BLOCK			Iosb[1];
	KIRQL					OldIrql;
	PIO_STACK_LOCATION		irpSp;
	BOOLEAN					matched = FALSE;
	NTSTATUS				status;
	ULONG					sectorsReadIntoPage = 0;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	sectorsPerPage = PAGE_SIZE / deviceExtension->FilesystemVolumeSectorSize;

	//
	// First, figure out if we've already verified the backpointer for
	// this per link.  If so, then we're done.  Note that more than
	// one thread may verify the same backpointer at the same time, which is OK.
	//
	KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
	if (PerLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) {
		KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

        matched = TRUE;
		status = STATUS_SUCCESS;
        goto done;
	}
	KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

	status = SipAssureCSFileOpen(PerLink->CsFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// Now, check the cache.
	//

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);

	for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
		if (CSFile->BackpointerCache[i].LinkFileIndex.QuadPart == PerLink->Index.QuadPart) {
			if (CSFile->BackpointerCache[i].LinkFileNtfsId.QuadPart == PerLink->LinkFileNtfsId.QuadPart) {
				//
				// We have a match.
				//
				status = STATUS_SUCCESS;

				matched = TRUE;

                ASSERT(CSFile->BackpointerCache[i].LinkFileIndex.Check);
#if		DBG
				InterlockedIncrement(&BPCacheHits);
#endif	// DBG

				KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
				goto done;
			}
			//
			// Otherwise we have an Index match without a NtfsId match.  Initiate volume check.
			//
			SIS_MARK_POINT_ULONG(PerLink->Index.LowPart);
			SIS_MARK_POINT_ULONG(PerLink->LinkFileNtfsId.LowPart);
			SIS_MARK_POINT_ULONG(CSFile->BackpointerCache[i].LinkFileNtfsId.LowPart);
			status = STATUS_SUCCESS;
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

			if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
				SipCheckVolume(deviceExtension);
			}

			goto done;
		}
	}
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

#if		DBG
	InterlockedIncrement(&BPCacheMisses);
#endif	// DBG

	page = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, ' siS');
	if (NULL == page) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent,FALSE);

	//
	// It didn't hit in the cache.  Search the backpointer index in the CS file.  Use
	// a standard binary search.
	//

    if (0 == CSFile->BPStreamEntries) {
        goto NoMatch;
    }

    l = SIS_BACKPOINTER_RESERVED_ENTRIES;
    r = CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES - 1;

	do {
		ASSERT(l <= r);

		x = (l + r) / 2;

		ASSERT(x >= l);
		ASSERT(x <= r);

#if		DBG
		InterlockedIncrement(&BPLookupSteps);
#endif	// DBG

		if ((x < currentSectorMinEntry) || 
			(x >= currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector)) {

			//
			// Sector doesn't point at the sector we need.  See if we already have it read into
			// page.
			//
			if ((x >= currentPageMinEntry) && 
				(x < currentPageMinEntry
				 + sectorsReadIntoPage * deviceExtension->BackpointerEntriesPerSector)) {

				//
				// We do, so just reset sector and currentSectorMinEntry.
				//
				ULONG sectorWithinPage = (x - currentPageMinEntry) / deviceExtension->BackpointerEntriesPerSector;
				ASSERT(sectorWithinPage < sectorsReadIntoPage);

#if		DBG
				InterlockedIncrement(&BPPageHits);
#endif	// DBG

				sector = (PSIS_BACKPOINTER)(page + deviceExtension->FilesystemVolumeSectorSize * sectorWithinPage);

				currentSectorMinEntry = currentPageMinEntry + sectorWithinPage * deviceExtension->BackpointerEntriesPerSector;

            } else {
				//
				// The current page doesn't have what we need, read something in.  We read a page if
				// we can fit all of the range from l to r within it; otherwise, we just read in one
				// sector.
				//

#if		DBG
				InterlockedIncrement(&BPLookupReads);
#endif	// DBG

				//
				// We don't have the sector we need.  Get it.
				//

/*BJB - for now, always read in one sector at a time. */
/*BJB*/ sector = (PSIS_BACKPOINTER)page;
/*BJB*/ sectorsReadIntoPage = 1;

				fileOffset.QuadPart = ((x * sizeof(SIS_BACKPOINTER)) /
										deviceExtension->FilesystemVolumeSectorSize) * 
										deviceExtension->FilesystemVolumeSectorSize;

				irp = IoBuildAsynchronousFsdRequest(
							IRP_MJ_READ,
							deviceExtension->AttachedToDeviceObject,
							sector,
							deviceExtension->FilesystemVolumeSectorSize,
							&fileOffset,
							Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));

					KeClearEvent(event);
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
			
				currentSectorMinEntry = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER));

/*BJB*/ currentPageMinEntry = currentSectorMinEntry;
			}
		}

		ASSERT((x >= currentSectorMinEntry) && (x < currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector));

		thisEntry = &sector[x - currentSectorMinEntry];

		if (PerLink->Index.QuadPart < thisEntry->LinkFileIndex.QuadPart) {
			r = x-1;
		} else {
			l = x+1;
		}

	} while ((thisEntry->LinkFileIndex.QuadPart != PerLink->Index.QuadPart) && (l <= r));

	if (thisEntry->LinkFileIndex.QuadPart != PerLink->Index.QuadPart) {
        //
		// No match.
		//
		SIS_MARK_POINT_ULONG(thisEntry->LinkFileIndex.LowPart);
NoMatch:
		SIS_MARK_POINT_ULONG(PerLink);

		if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {	
			SipCheckVolume(deviceExtension);
		}

	} else {
		if (thisEntry->LinkFileNtfsId.QuadPart != PerLink->LinkFileNtfsId.QuadPart) {

			//
			// No match, do a volume check.
			//
			SIS_MARK_POINT_ULONG(PerLink);
			SIS_MARK_POINT_ULONG(thisEntry->LinkFileNtfsId.LowPart);

			if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
				SipCheckVolume(deviceExtension);
			}

		} else {
            BOOLEAN writeBack;

			//
			// Match.
			//
			matched = TRUE;

            //
            // We always make sure the Check flag is set.  If it's clear, we must
            // write the backpointer back to disk.  (Volume check is the only
            // code that ever clears this flag.)  STATUS_MEDIA_WRITE_PROTECTED
            // is used as the error code that the caller keys off of to retry
            // the operation with the backpointer resource held exclusive.
            //
            writeBack = thisEntry->LinkFileIndex.Check == 0;
            thisEntry->LinkFileIndex.Check = 1;

            if (writeBack && !Exclusive) {
                status = STATUS_MEDIA_WRITE_PROTECTED;
                goto done;
            }

            //
            // Stick it in the cache.
            //
			KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
			CSFile->BackpointerCache[CSFile->BPCacheNextSlot] = *thisEntry;
			CSFile->BPCacheNextSlot = (CSFile->BPCacheNextSlot + 1) % SIS_CS_BACKPOINTER_CACHE_SIZE;
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

            if (writeBack) {

				//
				// We need to rewrite the sector we just read.
				//
				
				irp = IoBuildAsynchronousFsdRequest(
						IRP_MJ_WRITE,
						deviceExtension->AttachedToDeviceObject,
						sector,
						deviceExtension->FilesystemVolumeSectorSize,
						&fileOffset,
						Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));
					//
					// No need to clear the event, because we'll never use it again.
					//
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
            }
		}
	}

	status = STATUS_SUCCESS;

done:

	if (matched) {
		//
		// Set the verified flag in the PerLink so that if anyone
		// else opens this link, we won't have to redo the check.  Note
		// that we need to do this before we release the BackpointerResource
		// so that we're not racing with someone who wants to delete this
		// backpointer.
		//
		KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
		PerLink->Flags |= SIS_PER_LINK_BACKPOINTER_VERIFIED;
		KeReleaseSpinLock(PerLink->SpinLock, OldIrql);
	}

	if (NULL != page) {
		ExFreePool(page);
	}

	if (NULL != foundMatch) {
		*foundMatch = matched;
	}

	return status;
}

NTSTATUS
SipAddBackpointer(
	IN PSIS_CS_FILE			CSFile,
	IN PLINK_INDEX			LinkFileIndex,
	IN PLARGE_INTEGER		LinkFileNtfsId)
/*++

Routine Description:

	Add a backpointer to the given common store file for the LinkFileIndex,LinkFileNtfsId pair.
	Note that the LinkFileIndex for this file must be the largest that has ever had a backpointer
	added for this particular common store file.

	Caller must hold the CSFile->BackpointerResource exclusive.  This routine does not release it.

	Does not return until the backpointer index is updated.  This update is atomic (because of
	being a single sector write).

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	CSFile - the common store file to which the backpointer should be attached.

	LinkFileIndex - the index

	LinkFileNtfsId - the file id for the appropriate file


Return Value:

	status of the add

	
--*/
{
	PSIS_BACKPOINTER		sector = NULL;
	LARGE_INTEGER			fileOffset;
	PIRP					irp;
	BOOLEAN					isThisSectorZero;
	PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;
	NTSTATUS				status;
	KEVENT					event[1];
	IO_STATUS_BLOCK			Iosb[1];
	ULONG                   index, startIndex, stopIndex;
	PIO_STACK_LOCATION		irpSp;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SIS_MARK_POINT_ULONG(LinkFileIndex->LowPart);
	SIS_MARK_POINT_ULONG(LinkFileNtfsId->LowPart);

	status= SipAssureCSFileOpen(CSFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');

	if (NULL == sector) {
		SIS_MARK_POINT();

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent, FALSE);

	//
	// Read in the last sector of the backpointer file.
	//

	fileOffset.QuadPart = (((CSFile->BPStreamEntries - 1 + SIS_BACKPOINTER_RESERVED_ENTRIES) * sizeof(SIS_BACKPOINTER)) /
							deviceExtension->FilesystemVolumeSectorSize) * 
							deviceExtension->FilesystemVolumeSectorSize;

	ASSERT(fileOffset.QuadPart >= 0);

	if (fileOffset.QuadPart == 0) {
		isThisSectorZero = TRUE;
	} else {
		isThisSectorZero = FALSE;
	}

	ASSERT(isThisSectorZero == 
			(CSFile->BPStreamEntries <= (deviceExtension->BackpointerEntriesPerSector - SIS_BACKPOINTER_RESERVED_ENTRIES)));

	irp = IoBuildAsynchronousFsdRequest(
			IRP_MJ_READ,
			deviceExtension->AttachedToDeviceObject,
			sector,
			deviceExtension->FilesystemVolumeSectorSize,
			&fileOffset,
			Iosb);

	if (NULL == irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = CSFile->BackpointerStreamFileObject;

    ASSERT(irpSp->FileObject);

	IoSetCompletionRoutine(
		irp,
		SiDeleteAndSetCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	ASSERT(0 == KeReadStateEvent(event));

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
		status = Iosb->Status;
	} else {
		ASSERT(0 != KeReadStateEvent(event));
		KeClearEvent(event);
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}


	//
	// Scan the sector to find the place to insert the new mapping.
	// This will be the first terminal free entry (ie., the first
	// entry with LinkFileIndex == MAXLONGLONG).  This is not the
	// same as a deleted entry (one in which LinkFileNtfsId is
	// MAXLONGLONG).  Search from back to front so we're guaranteed
    // to always insert at the end, irregardless of any backpointer
    // stream corruption.
    //
    // Be careful, unsigned integers...
	//
    startIndex = deviceExtension->BackpointerEntriesPerSector - 1;
    stopIndex = (isThisSectorZero ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0) - 1;

    for (index = startIndex;
         index != stopIndex && sector[index].LinkFileIndex.QuadPart == MAXLONGLONG;
         index--) {
        continue;
    }

    if (index != startIndex) {
		//
		// We found a free entry.  Note that we always
		// set the check bit (used during volume checking).
		//
        if (index != stopIndex &&
            sector[index].LinkFileIndex.QuadPart >= LinkFileIndex->QuadPart) {
			//
			// We should always be inserting the highest allocated link file index.
			// We're not, so something's corrupt.  Initiate a volume check.
			//
			SIS_MARK_POINT_ULONG(CSFile);
			SIS_MARK_POINT_ULONG(index);
			SIS_MARK_POINT_ULONG(sector[index].LinkFileIndex.LowPart);
			SIS_MARK_POINT_ULONG(LinkFileIndex->LowPart);

			// Initiate a volume check, but don't abort.

			SipCheckVolume(deviceExtension);
        }

        index++;                                // bump up to free entry

		sector[index].LinkFileIndex = *LinkFileIndex;
		sector[index].LinkFileIndex.Check = 1;
		sector[index].LinkFileNtfsId = *LinkFileNtfsId;

		if (isThisSectorZero) {
			ASSERT(index >= SIS_BACKPOINTER_RESERVED_ENTRIES);
			CSFile->BPStreamEntries = index + 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;
		} else {
			CSFile->BPStreamEntries = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER)) + index + 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;
		}
		ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
               CSFile->BPStreamEntries > 0);
	} else {
		//
		// We need to add a new sector to the end of the file.  Initialize
		// a new one containing only this entry.
		//

		sector[0].LinkFileIndex = *LinkFileIndex;
		sector[0].LinkFileIndex.Check = 1;
		sector[0].LinkFileNtfsId = *LinkFileNtfsId;

		for (index = 1; 
			 index < deviceExtension->BackpointerEntriesPerSector;
			 index++) {
			
			sector[index].LinkFileIndex.QuadPart = MAXLONGLONG;
			sector[index].LinkFileNtfsId.QuadPart = MAXLONGLONG;
		}

		fileOffset.QuadPart += deviceExtension->FilesystemVolumeSectorSize;
		ASSERT(fileOffset.QuadPart >= 0);

		ASSERT(CSFile->BPStreamEntries < ((ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER))) - 
									SIS_BACKPOINTER_RESERVED_ENTRIES + 1);

		CSFile->BPStreamEntries = ((ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER))) - 
									SIS_BACKPOINTER_RESERVED_ENTRIES + 1;

		ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
               CSFile->BPStreamEntries > 0);
	}

	//
	// Write out the newly updated sector
	//
	
	irp = IoBuildAsynchronousFsdRequest(
			IRP_MJ_WRITE,
			deviceExtension->AttachedToDeviceObject,
			sector,
			deviceExtension->FilesystemVolumeSectorSize,
			&fileOffset,
			Iosb);

	if (NULL == irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = CSFile->BackpointerStreamFileObject;

	IoSetCompletionRoutine(
		irp,
		SiDeleteAndSetCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	ASSERT(0 == KeReadStateEvent(event));

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
		status = Iosb->Status;
	} else {
		ASSERT(0 != KeReadStateEvent(event));
		//
		// No need to clear the event, because we're never going to use it again.
		//
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

done:

	if (NULL != sector) {
		ExFreePool(sector);
	}	

	return status;
}

NTSTATUS
SipRemoveBackpointer(
	IN PSIS_CS_FILE					CSFile,
	IN PLINK_INDEX					LinkIndex,
	IN PLARGE_INTEGER				LinkFileNtfsId,
	OUT PBOOLEAN					ReferencesRemain)
/*++

Routine Description:

	Remove a backpointer from the given common store file.  If this is the last
	backpointer, will indicate so by setting ReferencesRemain to false.

	Does not return until the update is complete.

	Caller must hold the backpointer resource exclusively for this CS file. This
	routine does not release it.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	CSFile - the common store file to which the backpointer should be attached.

	LinkFileIndex - the index

	LinkFileNtfsId - the file id for the appropriate file

	ReferencesRemain - set TRUE iff there are more backpointers left for the file

Return Value:

	status of the remove

	
--*/
{
	NTSTATUS						status;
	KIRQL							OldIrql;
	PSIS_BACKPOINTER				sector = NULL;
	ULONG							i;
	ULONG							x, l, r;
	KEVENT							event[1];
	BOOLEAN							truncateFile;
	PIRP							irp;
	FILE_END_OF_FILE_INFORMATION	endOfFileInfo[1];
	PDEVICE_EXTENSION				deviceExtension = CSFile->DeviceObject->DeviceExtension;
	ULONG							currentSectorMinEntry = MAXULONG;
	LARGE_INTEGER					fileOffset;
	IO_STATUS_BLOCK					Iosb[1];
	PIO_STACK_LOCATION				irpSp;
	PSIS_BACKPOINTER				thisEntry;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SIS_MARK_POINT_ULONG(LinkIndex->LowPart);

	status= SipAssureCSFileOpen(CSFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

#if		DBG
	InterlockedIncrement(&BPDeleteAttempts);
#endif	// DBG

	*ReferencesRemain = TRUE;		// We'll fix this up later if need be.

	//
	// Blow away any entry in the cache.  We don't need to worry about it getting
	// refilled before we've updated the backpointer index, because we hold the
	// BackPointer resource exclusive.
	//

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);

	for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
		if (CSFile->BackpointerCache[i].LinkFileIndex.QuadPart == LinkIndex->QuadPart) {
			CSFile->BackpointerCache[i].LinkFileIndex.QuadPart = MAXLONGLONG;
		}
	}
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');
	if (NULL == sector) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent,FALSE);

	//
	// Search the backpointer index in the CS file.  Use
	// a standard binary search.
	//

    if (0 == CSFile->BPStreamEntries) {
        goto NoMatch;
    }

    l = SIS_BACKPOINTER_RESERVED_ENTRIES;
    r = CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES - 1;

	do {
		ASSERT(l <= r);

		x = (l + r) / 2;

		ASSERT(l <= x);
		ASSERT(r >= x);

		if ((x < currentSectorMinEntry) || 
			(x >= currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector)) {

			//
			// We don't have the sector we need.  Get it.
			//

#if		DBG
			InterlockedIncrement(&BPDeleteReads);
#endif	// DBG

			fileOffset.QuadPart = ((x * sizeof(SIS_BACKPOINTER)) /
									deviceExtension->FilesystemVolumeSectorSize) * 
									deviceExtension->FilesystemVolumeSectorSize;

			ASSERT(fileOffset.QuadPart >= 0);

			irp = IoBuildAsynchronousFsdRequest(
					IRP_MJ_READ,
					deviceExtension->AttachedToDeviceObject,
					sector,
					deviceExtension->FilesystemVolumeSectorSize,
					&fileOffset,
					Iosb);

			if (NULL == irp) {
				SIS_MARK_POINT();
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto done;
			}

			irpSp = IoGetNextIrpStackLocation(irp);
			irpSp->FileObject = CSFile->BackpointerStreamFileObject;

			IoSetCompletionRoutine(
				irp,
				SiDeleteAndSetCompletion,
				event,
				TRUE,
				TRUE,
				TRUE);


			ASSERT(0 == KeReadStateEvent(event));

			status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

			if (STATUS_PENDING == status) {
				status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
				ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
				status = Iosb->Status;
			} else {
				ASSERT(0 != KeReadStateEvent(event));
				KeClearEvent(event);
			}

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto done;
			}
			
			currentSectorMinEntry = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER));
		}

		ASSERT((x >= currentSectorMinEntry) && (x < currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector));

		thisEntry = &sector[x - currentSectorMinEntry];

		if (LinkIndex->QuadPart < thisEntry->LinkFileIndex.QuadPart) {
			r = x-1;
		} else {
			l = x+1;
		}
	} while ((thisEntry->LinkFileIndex.QuadPart != LinkIndex->QuadPart) && (l <= r));

	if (thisEntry->LinkFileIndex.QuadPart != LinkIndex->QuadPart) {
		//
		// No match.
		//
NoMatch:
		SIS_MARK_POINT_ULONG(CSFile);

		if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
			//
			// If we're not in Phase2 initialization, then we expect that the backpointer should
			// be there, and we need to kick off a volume check if it's not.  If we are in
			// Phase2, then we're just processing the log and it's not too surprising that
			// the file isn't there, so just ignore it.
			//
			SipCheckVolume(deviceExtension);
		}
	} else {
		if (thisEntry->LinkFileNtfsId.QuadPart != LinkFileNtfsId->QuadPart) {

			//
			// No match, do a volume check.
			//
			SIS_MARK_POINT_ULONG(CSFile);
			SipCheckVolume(deviceExtension);

		} else {
			//
			// We found the entry we wanted.  Figure out whether this was the last entry
			// in the file and the only entry in the sector.  First, blow away the entry
			// that we're supposed to delete.
			//

			thisEntry->LinkFileNtfsId.QuadPart = MAXLONGLONG;

			if (currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector >= CSFile->BPStreamEntries) {
				//
				// This is the last sector in the file.  Figure out if this is the last entry in the
				// sector.
				//
				truncateFile = TRUE;

				for (i = fileOffset.QuadPart == 0 ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0;
					 i < deviceExtension->BackpointerEntriesPerSector;
					 i++) {
					if (sector[i].LinkFileNtfsId.QuadPart != MAXLONGLONG) {
						truncateFile = FALSE;
						break;
					}
				}
			} else {
				//
				// This isn't the last sector in the file, so we're not going to be truncating.
				//
				truncateFile = FALSE;
			}

			if (truncateFile) {
				//
				// We need to scan backward through the file looking for empty sectors in order
				// to figure out how much to delete. 
				//

#if		DBG
				InterlockedIncrement(&BPDeleteTruncations);
#endif	// DBG

				while (fileOffset.QuadPart > 0) {
					//
					// Read in the next lower sector.  
					//
					ASSERT(fileOffset.QuadPart >= deviceExtension->FilesystemVolumeSectorSize);

					fileOffset.QuadPart -= deviceExtension->FilesystemVolumeSectorSize;

					ASSERT(fileOffset.QuadPart >= 0);

					irp = IoBuildAsynchronousFsdRequest(
							IRP_MJ_READ,
							deviceExtension->AttachedToDeviceObject,
							sector,
							deviceExtension->FilesystemVolumeSectorSize,
							&fileOffset,
							Iosb);

					if (NULL == irp) {
						SIS_MARK_POINT();
						status = STATUS_INSUFFICIENT_RESOURCES;
						goto done;
					}

					irpSp = IoGetNextIrpStackLocation(irp);
					irpSp->FileObject = CSFile->BackpointerStreamFileObject;

					IoSetCompletionRoutine(
						irp,
						SiDeleteAndSetCompletion,
						event,
						TRUE,
						TRUE,
						TRUE);

					ASSERT(0 == KeReadStateEvent(event));

					status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

					if (STATUS_PENDING == status) {
						status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
						ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
						status = Iosb->Status;
					} else {
						ASSERT(0 != KeReadStateEvent(event));
						KeClearEvent(event);
					}

					if (!NT_SUCCESS(status)) {
						SIS_MARK_POINT_ULONG(status);
						goto done;
					}

					//
					// Check this sector
					//
					for (i = fileOffset.QuadPart == 0 ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0;
						 i < deviceExtension->BackpointerEntriesPerSector; 
						 i++) {

						if (sector[i].LinkFileNtfsId.QuadPart != MAXLONGLONG) {
							//
							// This entry is valid, so we're not going to truncate this sector.
							// Stop here.
							//
							fileOffset.QuadPart += deviceExtension->FilesystemVolumeSectorSize;
							ASSERT(fileOffset.QuadPart >= 0);

							goto truncateNow;
						}
					}
				}
truncateNow:
				ASSERT(fileOffset.QuadPart % deviceExtension->FilesystemVolumeSectorSize == 0);

				if (0 == fileOffset.QuadPart) {
					//
					// There's nothing in sector 0, so the backpointer list is empty.  Indicate that
					// to our caller, and then set the truncate so that it won't wipe out sector 0
					// where the header is held.
					//
                    if ((deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_NODELETE) == 0) {
                        //
                        // Never delete a common store file while a volume check
                        // is in progress.
                        //
					    *ReferencesRemain = FALSE;
                    } else {
#if DBG
                        DbgPrint("SipRemoveBackpointer volume check not deleting\n");
#endif
                    }
					endOfFileInfo->EndOfFile.QuadPart = deviceExtension->FilesystemVolumeSectorSize;
					CSFile->BPStreamEntries = 0;
				} else {
					endOfFileInfo->EndOfFile = fileOffset;
					CSFile->BPStreamEntries = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER) - SIS_BACKPOINTER_RESERVED_ENTRIES);
					ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
                           CSFile->BPStreamEntries > 0);
				}

				status = SipSetInformationFile(
							CSFile->BackpointerStreamFileObject,
							deviceExtension->DeviceObject,
							FileEndOfFileInformation,
							sizeof(FILE_END_OF_FILE_INFORMATION),
							endOfFileInfo);

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}

			}

            if (!truncateFile || 0 == currentSectorMinEntry) {

                ASSERT(0 == fileOffset.QuadPart || 0 != currentSectorMinEntry);

				//
				// We need to rewrite the sector with the given entry deleted.
				//
				irp = IoBuildAsynchronousFsdRequest(
						IRP_MJ_WRITE,
						deviceExtension->AttachedToDeviceObject,
						sector,
						deviceExtension->FilesystemVolumeSectorSize,
						&fileOffset,
						Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));
					//
					// No need to clear the event, because we'll never use it again.
					//
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
			}
		}
	}

	status = STATUS_SUCCESS;

done:

	if (NULL != sector) {
		ExFreePool(sector);
	}

	return status;
}

#if	ENABLE_LOGGING
VOID
SipAssureBackpointer(
	IN PFILE_OBJECT						fileObject,
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_SCB							scb)
/*++

Routine Description:

	We're playing back the log and we've decided that a given file
	should still exist and have a backpointer.  Check it out, and if
	necessary rewrite the reparse point on the file with a new
	backpointer.

Arguments:

	fileObject - for the file to check

	deviceExtension - for the volume on which this record resides

	scb - of the file in question

Return Value:

	void	
--*/
{
	BOOLEAN					foundMatch;
	NTSTATUS				status;
	REPARSE_DATA_BUFFER		reparseBuffer[1];
	LINK_INDEX				newLinkIndex;

	PAGED_CODE();

	ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);

	status = SipCheckBackpointer(
				scb->PerLink,
				&foundMatch);

	if (!NT_SUCCESS(status)) {
		//
		// Just bag it.
		//

		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (foundMatch) {
		//
		// The backpointer is already there, so we're done.
		//
		goto done;
	}

	//
	// The backpointer's gone.  Check the file to see if it's got a valid reparse
	// point on it.  If it does, then we'll fix up the backpointer.
	//

	if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&scb->PerLink->CsFile->CSid,
				&newLinkIndex,

done:

}

VOID
SipRemoveRefBecauseOfLog(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLINK_INDEX						linkIndex,
	IN PLARGE_INTEGER					linkFileNtfsId,
	IN PCSID							CSid)
/*++

Routine Description:

	We're playing back the log and we've decided that we want to delete
	a reference to a common store file.  Delete it.

Arguments:

	deviceExtension - for the volume on which this record resides

	linkIndex - the link index for the backpointer we're deleting

	linkFileNtfsId - the NTFS id for the backpointer we're deleting

	CSid - the common store ID for the CS file holding the backpointer

Return Value:

	void	
--*/
{
	PSIS_CS_FILE			CSFile = NULL;
	BOOLEAN					referencesRemain;

	PAGED_CODE();

	ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);

	CSFile = SipLookupCSFile(
				&logRecord->CSid,
				NULL,
				deviceExtension->DeviceObject);

	if (NULL == CSFile) {
		//
		// We're out of memory.  Just ignore this log record.
		//
		SIS_MARK_POINT();
		goto done;
	}

	//
	// Since we're in Phase2, we know that we're the only thread messing with
	// this CS file.  Therefore, we don't need to bother synchronizing (ie., taking
	// the backpointer resource).  Just blow away the backpointer.  Note that there
	// is special code in the backpointer routine that will avoid starting a volume
	// check in the Phase2 thread even if we try to remove a backpointer that's already
	// gone.
	//

	status = SipRemoveBackpointer(
				CSFile,
				&logRecord->LinkIndex,
				&logRecord->LinkFileNtfsId,
				&referencesRemain);

	if (NT_SUCCESS(status) && !referencesRemain) {
		//
		// This was the last reference to the CS file.  Delete it.  We are already
		// in the PsInitialSystemProcess, so we don't need to post, we'll just call
		// the work routine directly.
		//
		SI_DELETE_CS_FILE_REQUEST		deleteRequest[1];

		SIS_MARK_POINT();

		deleteRequest->CSFile = CSFile;
		KeInitializeEvent(deleteRequest->event, NotificationEvent, FALSE);

		SipDeleteCSFileWork(deleteRequest);
	}

done:
	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}
}

VOID
SipProcessRefcountLogDeleteRecord(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_LOG_REFCOUNT_UPDATE			logRecord)
{
	NTSTATUS				status;
	HANDLE					fileHandle = NULL;
	PFILE_OBJECT			fileObject = NULL;
	PSIS_SCB				scb;
	PSIS_PER_FO				perFO;

	PAGED_CODE();

	ASSERT(SIS_REFCOUNT_UPDATE_LINK_DELETED == logRecord->UpdateType);

	//
	// We have a delete record in the log file.  We need to assure that either
	// the delete happened and the backpointer was eliminated, or else the
	// delete didn't happen and the backpointer is still there, but not one
	// without the other.
	//

	//
	// Proceed by opening the file named in the record and checking to see if
	// it has a SIS reparse point on it.  If it does, then we'll back out the
	// delete.  Otherwise, we'll make sure the backpointer is gone.
	//

	status = SipOpenFileById(
				deviceExtension,
				&logRecord->LinkFileNtfsId,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				0,										// exclusive
				FILE_NON_DIRECTORY_FILE,
				&fileHandle);

	if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
		//
		// The file's gone.  Make sure the backpointer is similarly gone.
		//
		SipRemoveRefBecauseOfLog(
			deviceExtension,
			&logRecord->LinkIndex,
			&logRecord->LinkFileNtfsId,
			&logRecord->CSid);

		goto done;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// We can't open the file, but it's not because it's missing.
		// Just ignore the log record.
		//
		goto done;
	}

	//
	// The file still exists.  See if it's a SIS link.
	//
	status = ObReferenceObjectByHandle(
				fileHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				KernelMode,
				&fileObject,
				NULL);							// Handle information

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (SipIsFileObjectSIS(fileObject, deviceExtension->DeviceObject, FindActive, &perFO, &scb)) {
		//
		// It's there and it is a SIS file object.  Make sure that it's got a valid backpointer.
		//

		SipAssureBackpointer(
			fileObject,
			deviceExtension,
			scb);
			
	} else {
		//
		// It's there, but it's not a SIS file object.
		//
	}
				

done:

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
		fileObject = NULL;
	}
	if (NULL != fileHandle) {
		ZwClose(fileHandle);
		fileHandle = NULL;
	}	

				
}
VOID
SipProcessRefcountUpdateLogRecord(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_LOG_REFCOUNT_UPDATE			logRecord)
/*++

Routine Description:

	We're in phase 2 initialization reading back the log.  We've got a refcount
	update log record.  Look at it and ensure that what it describes has really
	either happened or not happened, not part way.

	In particular, these log records all describe either creates or deletes.
	In either case, we check to see if the link file still exists, and if it
	does we update the backpointers accordingly.  In the case of deletes, this
	means that we might have to restore a deleted backpointer.  For creates, we
	might have to add a never-created backpointer.

	The one exception is that when the common store file is gone, then the link
	file gets deleted if it exists, because it's of little 

	If, on the other hand, the link file is gone, then we make sure that the
	backpointer is similarly gone.

Arguments:

	deviceExtension - for the volume on which this record resides

	logRecord - the log record in question

Return Value:

	void	
--*/
{
	PAGED_CODE();

	ASSERT(!deviceExtension->Phase2InitializationComplete);
	ASSERT(deviceExtension->Phase2ThreadId == PsGetCurrentThreadId());

	switch (logRecord->UpdateType) {
		case SIS_REFCOUNT_UPDATE_LINK_DELETED:
		case SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN:
			SipProcessRefcountLogDeleteRecord(deviceExtension,logRecord);
	}

}
#endif	// ENABLE_LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\index.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    index.c

Abstract:

	Support for SIS indices.

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

BOOLEAN
SipIndicesFromReparseBuffer(
	IN PREPARSE_DATA_BUFFER		reparseBuffer,
	OUT PCSID					CSid,
	OUT PLINK_INDEX				LinkIndex,
    OUT PLARGE_INTEGER          CSFileNtfsId,
    OUT PLARGE_INTEGER          LinkFileNtfsId,
	OUT PLONGLONG				CSFileChecksum OPTIONAL,
	OUT PBOOLEAN				EligibleForPartialFinalCopy OPTIONAL,
	OUT PBOOLEAN				ReparseBufferCorrupt OPTIONAL)
/*++

Routine Description:

	Take a SIS reparse buffer, check it for internal consistency and
	decode it to its constituient parts.

Arguments:

	reparseBuffer	- the buffer to decode
	CSid
	LinkIndex
	CSFileNtfsId
	LinkFileNtfsId
	CSFileChecksum	- the values from the reparse point
	EligibleForPartialFinalCopy - can we do a partial final copy on this file (ie., is the
								  reparse format version > 4?)
	ReparseBufferCorrupt - are we convinced that the buffer is corrupt (rather than just
									being too new a version)  Meaningful only if
									the return value of the function is FALSE

Return Value:

	TRUE if the buffer was decoded successfully, FALSE otherwise.

--*/
{
    PSI_REPARSE_BUFFER sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseBuffer->GenericReparseBuffer.DataBuffer;
    LONGLONG Checksum = 0;

	//
	// First check to be sure that we understand this reparse point format version and
	// that it has the correct size.
	//
	if (reparseBuffer->ReparseDataLength < sizeof(ULONG)) {
		//
		// The reparse buffer is to small to include a version number.  We guarantee that
		// no SIS version will ever produce such a reparse point, so it is corrupt.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}

		return FALSE;
	}

	if (sisReparseBuffer->ReparsePointFormatVersion < 4) {
		//
		// It's too old to be supported.  Treat it as corrupt.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}
		return FALSE;
	}

	if (sisReparseBuffer->ReparsePointFormatVersion > SIS_REPARSE_BUFFER_FORMAT_VERSION) {
		//
		// This buffer is from a newer version of SIS than the filter.  It is non-corrupt,
		// but we don't understand it.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = FALSE;
		}

		return FALSE;
	}

    //
    // Now check the checksum.
    //
    SipComputeChecksum(
	    sisReparseBuffer,
	    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	    &Checksum);

    if (Checksum != sisReparseBuffer->Checksum.QuadPart) {

		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}

        return FALSE;
    }

	//
	// Fill in the return values from the reparse point.
	//
	*CSid = sisReparseBuffer->CSid;
	*LinkIndex = sisReparseBuffer->LinkIndex;
    *LinkFileNtfsId = sisReparseBuffer->LinkFileNtfsId;
    *CSFileNtfsId = sisReparseBuffer->CSFileNtfsId;

	if (NULL != CSFileChecksum) {
		*CSFileChecksum = sisReparseBuffer->CSChecksum;
	}

	if (NULL != EligibleForPartialFinalCopy) {
		*EligibleForPartialFinalCopy = (sisReparseBuffer->ReparsePointFormatVersion > 4);
	}

	if (NULL != ReparseBufferCorrupt) {
		*ReparseBufferCorrupt = FALSE;
	}

	return TRUE;
}

BOOLEAN
SipIndicesIntoReparseBuffer(
	OUT PREPARSE_DATA_BUFFER	reparseBuffer,
	IN PCSID				    CSid,
	IN PLINK_INDEX              LinkIndex,
    IN PLARGE_INTEGER           CSFileNtfsId,
    IN PLARGE_INTEGER           LinkFileNtfsId,
	IN PLONGLONG				CSFileChecksum,
	IN BOOLEAN					EligibleForPartialFinalCopy)
/*++

Routine Description:

	Given the information that goes into a SIS reparse buffer, construct the
	buffer.  The caller must provide a sufficiently large buffer, and is
	responsible for filling in the ReparseDataLength field of the buffer
	with a size that corresponds to the size of the buffer (note that this is
	not EQUAL to the size of the buffer, because the meaning of this field
	is that it gives the length of the buffer beyond the mandatory header
	portion).

Arguments:

	reparseBuffer	- the buffer into which to write the reparse data
	CSid
	LinkIndex
	CSFileNtfsId
	LinkFileNtfsId
	CSFileChecksum	- the values to go into the reparse point

Return Value:

	TRUE if the buffer was encoded successfully, FALSE otherwise.

--*/
{
    PSI_REPARSE_BUFFER sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseBuffer->GenericReparseBuffer.DataBuffer;

	//
	// Check that we've got enough space.
	//
	if (reparseBuffer->ReparseDataLength < sizeof(SI_REPARSE_BUFFER)) {
		return FALSE;
	}

	//
	// Fill in the NTFS part of the reparse buffer.
	//
    reparseBuffer->ReparseTag = IO_REPARSE_TAG_SIS;
    reparseBuffer->Reserved = 0xcaf; //???

	//
	// Fill in SIS's part of the buffer.
	//
	if (EligibleForPartialFinalCopy) {
		sisReparseBuffer->ReparsePointFormatVersion = SIS_REPARSE_BUFFER_FORMAT_VERSION;
	} else {
		//
		// When we go to version 6 of the reparse buffer, EligibleForPartialFinalCopy should be
		// built into the reparse point.  For now, we'll just use a version 4 reparse point.
		//
		sisReparseBuffer->ReparsePointFormatVersion = 4;
	}
	sisReparseBuffer->Reserved = 0xb111b010;
	sisReparseBuffer->CSid = *CSid;
	sisReparseBuffer->LinkIndex = *LinkIndex;
    sisReparseBuffer->LinkFileNtfsId = *LinkFileNtfsId;
    sisReparseBuffer->CSFileNtfsId = *CSFileNtfsId;
	sisReparseBuffer->CSChecksum = *CSFileChecksum;

    //
    // Compute the checksum.
    //
	sisReparseBuffer->Checksum.QuadPart = 0;
    SipComputeChecksum(
	    sisReparseBuffer,
	    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	    &sisReparseBuffer->Checksum.QuadPart);

	//
	// Indicate the size.
	//
	reparseBuffer->ReparseDataLength = sizeof(SI_REPARSE_BUFFER);

	return TRUE;
}

NTSTATUS
SipIntegerToBase36UnicodeString(
		ULONG					Value,
		PUNICODE_STRING			String)
/*++

Routine Description:

	This does what RtlIntegerToUnicodeString(Value,36,String) would do if it
	handled base 36.  We use the same rules for digits as are normally used
	in Hex: 0-9, followed by a-z.  Note that we're intentionally using Arabic
	numerals and English letters here rather than something localized because
	this is intended to generate filenames that are never seen by users, and
	are constant regardless of the language used on the machine.

Arguments:

	Value 	- The ULONG to be converted into a base36 string
	String 	- A pointer to a UNICODE string to receive the result

Return Value:

	success or buffer overflow

--*/

{
	ULONG numChars;
	ULONG ValueCopy = Value;
	ULONG currentCharacter;

    // First, figure out the length by seeing how many times we can divide 36 into the value
	for (numChars = 0; ValueCopy != 0; ValueCopy /= 36, numChars++) {
		// No loop body
	}

	// Special case the value 0.
	if (numChars == 0) {
		ASSERT(Value == 0);
		if (String->MaximumLength < sizeof(WCHAR))
			return STATUS_BUFFER_OVERFLOW;
		String->Buffer[0] = '0';
		String->Length = sizeof(WCHAR);

		return STATUS_SUCCESS;
	}

	// If the string is too short, quit now.
	if (numChars * sizeof(WCHAR) > String->MaximumLength) {
		return STATUS_BUFFER_OVERFLOW;
	}

	// Convert the string character-by-character starting at the lowest order (and so rightmost) "digit"
	ValueCopy = Value;
	for (currentCharacter = 0 ; currentCharacter < numChars; currentCharacter++) {
		ULONG digit = ValueCopy % 36;
		ASSERT(ValueCopy != 0);
		if (digit < 10) {
			String->Buffer[numChars - (currentCharacter + 1)] = (WCHAR)('0' + (ValueCopy % 36));
		} else {
			String->Buffer[numChars - (currentCharacter + 1)] = (WCHAR)('a' + ((ValueCopy % 36) - 10));
		}
		ValueCopy /= 36;
	}
	ASSERT(ValueCopy == 0);

	// Fill in the string length, and we're done
	String->Length = (USHORT)(numChars * sizeof(WCHAR));
	
	return STATUS_SUCCESS;
}

NTSTATUS
SipIndexToFileName(
    IN PDEVICE_EXTENSION 	deviceExtension,
	IN PCSID	  			CSid,
	IN ULONG				appendBytes,
	IN BOOLEAN				mayAllocate,
    OUT PUNICODE_STRING 	fileName
	)
/*++

Routine Description:

	Given an index, returns the corresponding fully qualified file name.

Arguments:

    deviceExtension  - device extension
	CSid 	         - The id to convert
	appendBytes		 - A number of bytes that must be left unused at the end of fileName
	mayAllocate		 - May we allocate a new string, or do we have to live with what we have?
	fileName         - A pointer to a UNICODE string to receive the result

Return Value:

	success or buffer overflow

--*/
{
    NTSTATUS 			status;
	USHORT				stringMaxLength;
	UNICODE_STRING		GUIDString[1];
	BOOLEAN				allocatedBufferSpace = FALSE;

	//
	// We generate the filename as <common store path>\<guid>.sis, where <guid> is
	// the standard striung representation of the GUID for the common store file (ie.,
	// its CSid).
	//

	stringMaxLength = (USHORT)(deviceExtension->CommonStorePathname.Length +
						INDEX_MAX_NUMERIC_STRING_LENGTH +
						appendBytes);

	if (mayAllocate && stringMaxLength > fileName->MaximumLength) {
		fileName->Buffer = ExAllocatePoolWithTag(PagedPool, stringMaxLength, ' siS');
		if (!fileName->Buffer) {
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		allocatedBufferSpace = TRUE;
		fileName->MaximumLength = stringMaxLength;
	} else if (fileName->MaximumLength < stringMaxLength) {
        return STATUS_BUFFER_OVERFLOW;
	}

	RtlCopyUnicodeString(fileName,&deviceExtension->CommonStorePathname);
	ASSERT(fileName->Length < fileName->MaximumLength);
	ASSERT(fileName->Length == deviceExtension->CommonStorePathname.Length);

	status = RtlStringFromGUID(CSid,GUIDString);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Get rid of the leading and trailing curly braces in the GUID name.
	//
	ASSERT(GUIDString->Buffer[0] == '{' && GUIDString->Buffer[(GUIDString->Length/sizeof(WCHAR)) - 1] == '}');
	GUIDString->Buffer++;
	GUIDString->Length -= 2 * sizeof(WCHAR);

	status = RtlAppendUnicodeStringToString(
				fileName,
				GUIDString);

	//
	// Just for safety, undo the hacking that we did on the GUID string before freeing it.
	//
	GUIDString->Buffer--;
	GUIDString->Length += 2 * sizeof(WCHAR);

	RtlFreeUnicodeString(GUIDString);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	status = RtlAppendUnicodeToString(fileName,L".sis");
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

    return STATUS_SUCCESS;

Error:

	if (allocatedBufferSpace) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}

	return status;
}

BOOLEAN
SipFileNameToIndex(
    IN PUNICODE_STRING		fileName,
    OUT PCSID		        CSid)
/*++

Routine Description:

	Given a common store file name, returns the corresponding index.  The
    file name must be in the format generated by SipIndexToFileName().

Arguments:

	fileName         - A pointer to a UNICODE string containing the file name.
	CSid 	         - A pointer to a CSID to receive the result.

Return Value:

	TRUE if successful, else FALSE

--*/
{
	UNICODE_STRING		substring[1];
	NTSTATUS			status;
#define BUFSIZE 42
    WCHAR               buffer[BUFSIZE];

    //
    // Format: "<guid>.sis", where <guid> is the standard string representation of the
	// csid guid with the curly braces stripped off.
    //

	if (fileName->Length <= 4 * sizeof(WCHAR)) {
		//
		// It doesn't end in .sis, ignore it.
		//
		return FALSE;
	}

	substring->Buffer = buffer;
    substring->Buffer[0] = L'{';
    substring->Length = sizeof(WCHAR);
    substring->MaximumLength = BUFSIZE * sizeof(WCHAR);

    status = RtlAppendUnicodeStringToString(substring, fileName);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return FALSE;
	}

	substring->Length = substring->Length - 3 * sizeof(WCHAR);
    substring->Buffer[(substring->Length - 1) / sizeof(WCHAR)] = L'}';

	status = RtlGUIDFromString(substring, CSid);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return FALSE;
	}

    return TRUE;
}

NTSTATUS
SipOpenMaxIndexFile(
	IN OUT PDEVICE_EXTENSION			deviceExtension,
	IN BOOLEAN							create
	)
/*++

Routine Description:

	Open the MaxIndex file for a given volume.  Must be called in the
	PsInitialSystemProcess context.

Arguments:

	deviceExtension	- For the volume on which to open the MaxIndex file

	create			- May we create the file, or must it already exist?

Return Value:

	status of the open

--*/
{
	OBJECT_ATTRIBUTES		Obja;
	UNICODE_STRING			fileName;
	NTSTATUS				status;
	IO_STATUS_BLOCK			Iosb;

	ASSERT(deviceExtension->MaxAllocatedIndex.QuadPart == 0 || create);

	fileName.Buffer = ExAllocatePoolWithTag(
							NonPagedPool,
							deviceExtension->CommonStorePathname.Length + 8 * sizeof(WCHAR),
							' siS');

	if (!fileName.Buffer) {
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}
	fileName.MaximumLength = deviceExtension->CommonStorePathname.Length + 8 * sizeof(WCHAR);
	fileName.Length = 0;

	RtlCopyUnicodeString(&fileName,&deviceExtension->CommonStorePathname);
	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);

	status = RtlAppendUnicodeToString(&fileName,L"MaxIndex");
	if (!NT_SUCCESS(status)) {
		goto done;
	}

	InitializeObjectAttributes(
				&Obja,
				&fileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL);

	status = NtCreateFile(
				&deviceExtension->IndexHandle,
				GENERIC_READ|GENERIC_WRITE,
				&Obja,
				&Iosb,
				NULL,							// Allocation Size
				0,								// File Attributes
				FILE_SHARE_READ,
				create ? FILE_OVERWRITE_IF : FILE_OPEN,
				FILE_WRITE_THROUGH,
				NULL,							// EA Buffer
				0);								// EA Length


done:

	if (NULL != fileName.Buffer) {
		ExFreePool(fileName.Buffer);
	}

	return status;

}

VOID
SipAllocateIndices(
	IN PVOID					Parameter)
/*++

Routine Description:

	This is a worker thread routine that allocates a new chunk of indices
	from the index file.  Essentially, opens the index file and reads
	the old value if necessary.  Then, it adds the chunk size onto the
	max allocated index, and writes the new value back into the file
	write through.  When the write completes, set the event and exit.

Arguments:

    parameter - a PSI_ALLOCATE_INDICES.

Return Value:

	void

--*/
{
    PSI_ALLOCATE_INDICES 	allocateRequest = Parameter;
	KIRQL 					OldIrql;
	PDEVICE_EXTENSION		deviceExtension = allocateRequest->deviceExtension;
	NTSTATUS 				status;
	IO_STATUS_BLOCK			Iosb;
	LARGE_INTEGER			ByteOffset;

#if	DBG
	// Just to ensure that we don't have more then one allocator running at once, we check
	// that the allocation request is really == TRUE (rather than just != 0), and then set
	// it to 2.

	KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);
	ASSERT(deviceExtension->IndexAllocationInProgress == TRUE);
	deviceExtension->IndexAllocationInProgress = 2;
	KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);
#endif	// DBG

	if (deviceExtension->IndexHandle == NULL) {
		status = SipCreateEvent(
					SynchronizationEvent,
					&deviceExtension->IndexFileEventHandle,
					&deviceExtension->IndexFileEvent);
	
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto done;
		}

		status = SipOpenMaxIndexFile(
                    deviceExtension,
                    (BOOLEAN) (deviceExtension->MaxAllocatedIndex.QuadPart != 0));
	
		if (!NT_SUCCESS(status)) {
			//
			// We can't open the MaxIndex file.  It was probably deleted
			// or something.  Kick off a volume check to rebuild it.
			//
			SIS_MARK_POINT_ULONG(status);

            KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
            deviceExtension->Flags |= SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
            KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

            status = STATUS_CORRUPT_SYSTEM_FILE;

            //
            // Do a volume check only if this is the first attempt.
            //
	        if (deviceExtension->MaxAllocatedIndex.QuadPart == 0) {
			    SipCheckVolume(deviceExtension);
            }

			goto done;
		}
	}

	if (deviceExtension->MaxAllocatedIndex.QuadPart == 0) {

		ByteOffset.QuadPart = 0;

		status = ZwReadFile(
					deviceExtension->IndexHandle,
					deviceExtension->IndexFileEventHandle,
					NULL,											// APC routine
					NULL,											// APC Context
					&Iosb,
					&deviceExtension->MaxAllocatedIndex,
					sizeof(deviceExtension->MaxAllocatedIndex),
					&ByteOffset,
					NULL);											// Key

		if (status == STATUS_PENDING) {
			status = KeWaitForSingleObject(deviceExtension->IndexFileEvent,Executive,KernelMode,FALSE,NULL);
			ASSERT(status == STATUS_SUCCESS);
			status = Iosb.Status;
		}

		if (!NT_SUCCESS(status) || Iosb.Information != sizeof(LONGLONG) || deviceExtension->MaxAllocatedIndex.Check) {
#if		DBG
			DbgPrint(
				"SIS: SipAllocateIndices: ZwReadFile of MaxIndex file failed, wrong length or invalid value, 0x%x, %d\n",
				status,Iosb.Information);
#endif	// DBG
			ZwClose(deviceExtension->IndexHandle);
			deviceExtension->IndexHandle = NULL;

            KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
            deviceExtension->Flags |= SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
            KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

            status = STATUS_CORRUPT_SYSTEM_FILE;

			SipCheckVolume(deviceExtension);

			goto done;
		}

		deviceExtension->MaxUsedIndex = deviceExtension->MaxAllocatedIndex;
	}

	deviceExtension->MaxAllocatedIndex.QuadPart += 1000;			// 1000 is pretty arbitrary.  We can do better.

	ByteOffset.QuadPart = 0;

	status = ZwWriteFile(
				deviceExtension->IndexHandle,
				deviceExtension->IndexFileEventHandle,
				NULL,												// APC routine
				NULL,												// APC context
				&Iosb,
				&deviceExtension->MaxAllocatedIndex,
				sizeof(deviceExtension->MaxAllocatedIndex),
				&ByteOffset,
				NULL);												// key

    if (status == STATUS_PENDING) {
		status = KeWaitForSingleObject(deviceExtension->IndexFileEvent,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = Iosb.Status;
    }

	if (!NT_SUCCESS(status)) {
		// The write failed.  Back out the allocation.
		deviceExtension->MaxAllocatedIndex.QuadPart -= 1000;
#if		DBG
		DbgPrint("SIS: SipAllocateIndices: writing MaxIndex file failed, 0x%x\n",status);
#endif	// DBG
	}

done:

	KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);
	deviceExtension->IndexStatus = status;
	deviceExtension->IndexAllocationInProgress = FALSE;
	KeSetEvent(deviceExtension->IndexEvent, 0, FALSE);	// we may no longer touch allocationRequest after this set
	KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

	return;

	
}

NTSTATUS
SipAllocateIndex(
	IN PDEVICE_EXTENSION		DeviceExtension,
	OUT PLINK_INDEX				Index)
/*++

Routine Description:

	Allocate a new LINK_INDEX.  If there are indices that have been reserved from the
	file but not yet allocated, we can just grab one and return it.  Otherwise, we
	need to wait for a new index allocation.  If one is not already in progress, we
	start it and wait for it to complete.

Arguments:

	deviceExtension	- for the volume on which we're to allocate the index.

	Index - returns the new index

Return Value:

	status of the allocation.

--*/
{
    KIRQL 					OldIrql;
	BOOLEAN					StartAllocator;
	SI_ALLOCATE_INDICES		AllocateRequest[1];
	NTSTATUS				status;

    if (DeviceExtension->Flags & SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX) {
        return STATUS_CORRUPT_SYSTEM_FILE;
    }

	KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);

	while (TRUE) {
		if (DeviceExtension->MaxAllocatedIndex.QuadPart > DeviceExtension->MaxUsedIndex.QuadPart) {
			DeviceExtension->MaxUsedIndex.QuadPart++;
			*Index = DeviceExtension->MaxUsedIndex;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return STATUS_SUCCESS;
		}

		// There are no free indices left, we have to block.
		if (!DeviceExtension->IndexAllocationInProgress) {
			StartAllocator = TRUE;
			DeviceExtension->IndexAllocationInProgress = TRUE;

			// Stop anyone from passing the barrier until the allocator runs.
			KeClearEvent(DeviceExtension->IndexEvent);

		} else {
			StartAllocator = FALSE;
		}

		KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);

		if (StartAllocator) {
			ExInitializeWorkItem(AllocateRequest->workQueueItem, SipAllocateIndices, AllocateRequest);
			AllocateRequest->deviceExtension = DeviceExtension;
			ExQueueWorkItem(AllocateRequest->workQueueItem, CriticalWorkQueue);
		}

		status = KeWaitForSingleObject(DeviceExtension->IndexEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		if ((status != STATUS_SUCCESS) && !StartAllocator) {
			// The reason that we check StartAllocator here is because the allocation request is
			// on our stack, and we really can't return until the work item is completed.  (Of course,
			// the KeWaitForSingleObject should never fail in the first place...)
			return status;
		}

		KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);
	
		if (!NT_SUCCESS(DeviceExtension->IndexStatus)) {
			status = DeviceExtension->IndexStatus;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return status;
		}
	}
}

NTSTATUS
SipGetMaxUsedIndex(
	IN PDEVICE_EXTENSION				DeviceExtension,
	OUT PLINK_INDEX						Index)
/*++

Routine Description:

	Return a number that's at least as big as the largest LINK_INDEX ever allocated
	on this volume.  Note that if it looks like we don't have any indices available
	we'll kick the index allocator, because otherwise we can't be sure that the
	index values are valid (they may have never been read for this volume).

Arguments:

	deviceExtension	- for the volume we're considering

	Index - returns new index

Return Value:

	status of the check.  *Index is meaningful iff NT_SUCCESS(return value).

--*/
{
    KIRQL 					OldIrql;
	BOOLEAN					StartAllocator;
	SI_ALLOCATE_INDICES		AllocateRequest[1];
	NTSTATUS				status;

	KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);

	while (TRUE) {
		if (DeviceExtension->MaxAllocatedIndex.QuadPart > DeviceExtension->MaxUsedIndex.QuadPart) {
			*Index = DeviceExtension->MaxUsedIndex;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return STATUS_SUCCESS;
		}

		// There are no free indices left, we have to block.
		if (!DeviceExtension->IndexAllocationInProgress) {
			StartAllocator = TRUE;
			DeviceExtension->IndexAllocationInProgress = TRUE;

			// Stop anyone from passing the barrier until the allocator runs.
			KeClearEvent(DeviceExtension->IndexEvent);

		} else {
			StartAllocator = FALSE;
		}

		KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);

		if (StartAllocator) {
			ExInitializeWorkItem(AllocateRequest->workQueueItem, SipAllocateIndices, AllocateRequest);
			AllocateRequest->deviceExtension = DeviceExtension;
			ExQueueWorkItem(AllocateRequest->workQueueItem, CriticalWorkQueue);
		}

		status = KeWaitForSingleObject(DeviceExtension->IndexEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		if ((status != STATUS_SUCCESS) && !StartAllocator) {
			// The reason that we check StartAllocator here is because the allocation request is
			// on our stack, and we really can't return until the work item is completed.  (Of course,
			// the KeWaitForSingleObject should never fail in the first place...)
			return status;
		}

		KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);
	
		if (!NT_SUCCESS(DeviceExtension->IndexStatus)) {
			status = DeviceExtension->IndexStatus;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return status;
		}
	}
}

NTSTATUS
SipAssureMaxIndexFileOpen(
	IN PDEVICE_EXTENSION		deviceExtension)
{
	NTSTATUS		status;
	KIRQL			OldIrql;
	LINK_INDEX		uselessIndex;
	

	//
	// Make sure that the MaxIndex file is already opened.  We need to
	// do this here to avoid a deadlock if someone
	// tries to do a copyfile with MaxIndex as the source, which would
	// otherwise deadlock.  If things are messed up, this might kick off
	// a volume check, but we should still fail the open.
	//
	if (deviceExtension->IndexHandle != NULL) {
		//
		// The file's already open, no need to do any work.
		//

		return STATUS_SUCCESS;
	}

	//
	// The index file isn't open.  Rather than trying to open it directly,
	// we avoid races by just calling the index allocator.  We'll throw away
	// the index we get back, but they're plentiful so it's not much of a
	// problem.
	//

	status = SipAllocateIndex(deviceExtension, &uselessIndex);

	if (!NT_SUCCESS(status)) {
		BOOLEAN volumeCheckPending;

		SIS_MARK_POINT_ULONG(status);

		//
		// If we're in a volume check, transmute the error to STATUS_RETRY on the
		// theory that the volume check will rebuild the MaxIndex file.  If not,
		// then just leave it alone.
		//

		KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
		volumeCheckPending = (deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_PENDING) ? TRUE : FALSE;
		KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

		if (volumeCheckPending) {
			SIS_MARK_POINT();
			status = STATUS_RETRY;
		}

		return status;
	}
	
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\cow.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cow.c

Abstract:

	Copy on write support for the single instance store	
	
Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef		ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipBltRange)
#pragma alloc_text(PAGE, SipBltRangeByObject)
#endif		// ALLOC_PRAGMA

LIST_ENTRY CopyList[1];
KSPIN_LOCK CopyListLock[1];
KSEMAPHORE CopySemaphore[1];

NTSTATUS
SipBltRange(
	IN PDEVICE_EXTENSION		deviceExtension,
	IN HANDLE					sourceHandle,
	IN OUT HANDLE				dstHandle,
	IN LONGLONG					startingOffset,
	IN LONGLONG					length,
	IN HANDLE					copyEventHandle,
	IN PKEVENT					copyEvent,
    IN PKEVENT                  abortEvent,
	IN OUT PLONGLONG			checksum)
/*++

Routine Description:

	Wrapper for SipBltRangeByObject that takes a source handle rather than
	a file object pointer.  All this function does is to get the file object
	from the handle and call SipBltRangeByObject.

	This function must be called in the PsInitialSystemProcess context.

Arguments:

	sourceHandle - handle to the file from which to copy

	others - see SipBltRangeByObject for description

Return Value:

	status of the copy
--*/
{
	PFILE_OBJECT				srcFileObject = NULL;
	NTSTATUS					status;
	OBJECT_HANDLE_INFORMATION 	handleInformation[1];

	PAGED_CODE();

	status = ObReferenceObjectByHandle(
				sourceHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				KernelMode,
				(PVOID *) &srcFileObject,
				handleInformation);

	if (!NT_SUCCESS(status)) {
		ASSERT(NULL == srcFileObject);
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	status = SipBltRangeByObject(
				deviceExtension,
				srcFileObject,
				dstHandle,
				startingOffset,
				length,
				copyEventHandle,
				copyEvent,
				abortEvent,
				checksum);

done:

	if (NULL != srcFileObject) {
		ObDereferenceObject(srcFileObject);
	}

	return status;
}


NTSTATUS
SipBltRangeByObject(
	IN PDEVICE_EXTENSION		deviceExtension,
	IN PFILE_OBJECT				srcFileObject,
	IN OUT HANDLE				dstHandle,
	IN LONGLONG					startingOffset,
	IN LONGLONG					length,
	IN HANDLE					copyEventHandle,
	IN PKEVENT					copyEvent,
    IN PKEVENT                  abortEvent,
	IN OUT PLONGLONG			checksum)
/*++

Routine Description:

	Copy a range of a file from one place to another.  Maps the destination
	and does noncached reads from the source into the mapped
	region.  Does not return STATUS_SUCCESS until all of the bits
	of the new file are on the disk.

	This function must be called in the PsInitialSystemProcess context
	(ie., from a worker thread).

    This function may also be used to simply compute the checksum on a range
    of a file without doing a file copy.  Pass in srcFileObject == NULL and
    dstHandle == file to compute checksum on.

    NTRAID#65184-2000/03/09-nealch  SIS needs to check for sparse ranges when copying a file and not copy them


Arguments:

	deviceExtension - For the volume on which we're copying

	srcFileObject - the file from which to copy.  If NULL, checksum on
                    dstHandle file will be computed.

	dstHandle - Handle for the file into which to copy

	startingOffset - offset within the files from which to start copying

	length - the number of bytes to copy

	copyEventHandle - handle to an event that no one else
						is using now

	copyEvent - pointer to the same event as copyEventHandle

    abortEvent - pointer to an event that signals an abort request

	checksum - pointer to a place to hold the checksum of the blt'ed range.
				if NULL no checksum is computed.  Note that this must be
				initialized to 0 by the caller, unless a partial checksum has
				already beem computed, in which case it should contain the
				partial checksum.

Return Value:

	status of the copy
--*/
{
#define	MM_MAP_ALIGNMENT (64 * 1024 /*VACB_MAPPING_GRANULARITY*/)   // The file offset granularity that MM enforces.
#define	COPY_AMOUNT	(64 * 1024)	// How much we read or write at a time.  Must be >= MM_MAP_ALIGNMENT

	HANDLE				sectionHandle = NULL;
	NTSTATUS			status;
	LARGE_INTEGER		byteOffset;
	LONGLONG			finalOffset;
	IO_STATUS_BLOCK		Iosb[1];
	LARGE_INTEGER		maxSectionSize;
	ULONG				sectorSize = deviceExtension->FilesystemVolumeSectorSize;
	PIRP				readIrp = NULL;
	PDEVICE_OBJECT		srcFileRelatedDeviceObject;
	PIO_STACK_LOCATION	irpSp;

	PAGED_CODE();
    UNREFERENCED_PARAMETER( copyEventHandle );

	ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());
    ASSERT(checksum || srcFileObject);

	SIS_MARK_POINT_ULONG(startingOffset);
	SIS_MARK_POINT_ULONG(length);

    if (srcFileObject) {
	    srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);
    } else {
	    srcFileRelatedDeviceObject = NULL;
    }

	finalOffset = startingOffset + length;
	maxSectionSize.QuadPart = finalOffset;

	status = ZwCreateSection(
				&sectionHandle,
				SECTION_MAP_WRITE | STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY,
				NULL,
				&maxSectionSize,
				PAGE_READWRITE,
				SEC_COMMIT,
				dstHandle);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}
	ASSERT(status == STATUS_SUCCESS);	// and not STATUS_PENDING or anything weird

	for (byteOffset.QuadPart = startingOffset; byteOffset.QuadPart < finalOffset;) {
		ULONG 				validBytes, bytesToCopy;
		PCHAR				mappedBuffer = NULL, flushBuffer;
		LARGE_INTEGER		mappedOffset;
		ULONG_PTR		    viewSize;
        ULONG_PTR           flushSize;
		PCHAR				copyIntoAddress;
		ULONG				bytesCopied;

		SIS_MARK_POINT_ULONG(byteOffset.LowPart);

		mappedOffset.QuadPart = byteOffset.QuadPart - (byteOffset.QuadPart % MM_MAP_ALIGNMENT);
		ASSERT(mappedOffset.QuadPart <= byteOffset.QuadPart && mappedOffset.QuadPart + MM_MAP_ALIGNMENT > byteOffset.QuadPart);

        //
        // Abort if an oplock break has been received.
        //

        if (SipAbort(abortEvent)) {
			SIS_MARK_POINT();
            status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
            goto done;
        }

		if (finalOffset - mappedOffset.QuadPart > COPY_AMOUNT) {
			//
			// We can't map enough of the file to do the whole copy
			// here, so only map COPY_AMOUNT on this pass.
			//
			viewSize = COPY_AMOUNT;
		} else {
			//
			// We can map all the way to the end of the file.
			//
			viewSize = (ULONG)(finalOffset - mappedOffset.QuadPart);
		}
		ASSERT(viewSize >=
               (ULONG_PTR)(byteOffset.QuadPart - mappedOffset.QuadPart));
		validBytes = (ULONG)(viewSize - (ULONG)(byteOffset.QuadPart - mappedOffset.QuadPart));
		
		//
		// Now round validBytes up to a sector size.
		//
		bytesToCopy = ((validBytes + sectorSize - 1) / sectorSize) * sectorSize;

		ASSERT(bytesToCopy <= COPY_AMOUNT);

		//
		// Map in the region to which we're about to copy.
		//
		status = ZwMapViewOfSection(
					sectionHandle,
					NtCurrentProcess(),
					&mappedBuffer,
					0,							// zero bits
					0,							// commit size (ignored for mapped files)
					&mappedOffset,
					&viewSize,
					ViewUnmap,
					0,							// allocation type
					PAGE_READWRITE);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto done;
		}

		ASSERT(viewSize >= bytesToCopy);	// We have enough space allocated for the rounded up read

		copyIntoAddress = mappedBuffer + (ULONG)(byteOffset.QuadPart - mappedOffset.QuadPart);

        if (srcFileObject) {

		    // Now, read the bits in from the source file
		    readIrp = IoBuildSynchronousFsdRequest(
					    IRP_MJ_READ,
					    srcFileRelatedDeviceObject,
					    copyIntoAddress,
					    bytesToCopy,
					    &byteOffset,
					    copyEvent,
					    Iosb);

		    if (NULL == readIrp) {
			    status = STATUS_INSUFFICIENT_RESOURCES;
			    goto done;
		    }

		    irpSp = IoGetNextIrpStackLocation(readIrp);
		    irpSp->FileObject = srcFileObject;

		    status = IoCallDriver(srcFileRelatedDeviceObject, readIrp);

			if (STATUS_PENDING == status) {
			    status = KeWaitForSingleObject(copyEvent, Executive, KernelMode, FALSE, NULL);
			    ASSERT(status == STATUS_SUCCESS);
			    status = Iosb->Status;
			} else {
				KeClearEvent(copyEvent);
			}

		    if (!NT_SUCCESS(status)) {
			    SIS_MARK_POINT_ULONG(status);
			    ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);
			    goto done;
		    }

		    //
		    // Iosb->Information returns the actual number of bytes read from the
		    // file and into the mapped CS file, hence the actual number of bytes we
		    // copied on this trip through the loop.
		    //
		    bytesCopied = (ULONG)Iosb->Information;

        } else {

		    bytesCopied = validBytes;

        }

        //
        // Abort if an oplock break has been received.
        //

        if (SipAbort(abortEvent)) {
            status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
			ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);
			goto done;
        }

		if (NULL != checksum) {
			SipComputeChecksum(copyIntoAddress,bytesCopied,checksum);
		}

		flushBuffer = mappedBuffer;
		flushSize = viewSize;
		status = ZwFlushVirtualMemory(
					NtCurrentProcess(),
					&flushBuffer,
					&flushSize,
					Iosb);

		ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			goto done;
		}

		//
		// Add in the number of bytes that we actually copied into the file.
		//
		byteOffset.QuadPart += bytesCopied;
	}

	done:

	if (sectionHandle != NULL) {
		ZwClose(sectionHandle);
		sectionHandle = NULL;
	}

	return status;
#undef	COPY_AMOUNT
#undef	MM_MAP_ALIGNMENT
}

VOID
SiCopyThreadStart(
	IN PVOID		parameter)
/*++

Routine Description:

	A thread to handle SIS copy on write operations.  Because these operations may
	take a very large amount of time, we have our own thread rather than holding an
	ExWorker thread.  This thread waits for requests for initial or final copies to
	be posted, and then processes them.  The thread uses a global work queue, not
	one per volume.

Arguments:

	parameter - PVOID NULL.

Return Value:

	never returns.
--*/
{
	NTSTATUS 				status;
	PSI_COPY_THREAD_REQUEST	copyRequest;
	HANDLE					copyEventHandle;
	PKEVENT					copyEvent;

    UNREFERENCED_PARAMETER( parameter );
    ASSERT(parameter == NULL);

	status = SipCreateEvent(
				SynchronizationEvent,
				&copyEventHandle,
				&copyEvent);

	if (!NT_SUCCESS(status)) {
		DbgPrint("SipCopyThreadStart: unable to allocate copyevent, 0x%x\n",status);
		return;	// now what??
	}

	while (TRUE) {

		status = KeWaitForSingleObject(CopySemaphore,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);

		copyRequest = (PSI_COPY_THREAD_REQUEST)ExInterlockedRemoveHeadList(CopyList,CopyListLock);
        ASSERT(copyRequest != NULL);	// Else the semaphore isn't working right

        if (copyRequest) {

		    status = SipCompleteCopyWork(copyRequest->scb,copyEventHandle,copyEvent,copyRequest->fromCleanup);

		    ExFreePool(copyRequest);
        }
	}
}

NTSTATUS
SipOpenFileById(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLARGE_INTEGER					linkFileNtfsId,
    IN ACCESS_MASK                      desiredAccess,
    IN ULONG                            shareAccess,
	IN ULONG							createOptions,
	OUT PHANDLE							openedFileHandle)
/*++

Routine Description:

	Open a file by file id and return a handle to it.  Must be called in the
	PsInitialSystemProcess context.

Arguments:

	deviceExtension	- For the device on which this file is to be opened.

	linkFileNtfsId	- A pointer to the file ID of the file to open

    desiredAccess	- Access to request to the file.

    shareAccess		- Sharing mode.

	createOptions	- Options for the open.

	openedFileHandle- The opened handle
	
Return Value:

	the status of the open
--*/
{
	OBJECT_ATTRIBUTES				Obja[1];
	IO_STATUS_BLOCK					Iosb[1];
	UNICODE_STRING					fileNameString;
	CHAR							fileNameBuffer[sizeof(LARGE_INTEGER)];
	NTSTATUS						status;

	fileNameString.MaximumLength = sizeof(LARGE_INTEGER);
	fileNameString.Buffer = (PWCHAR)fileNameBuffer;
	
	RtlCopyMemory(fileNameString.Buffer,linkFileNtfsId,sizeof(*linkFileNtfsId));

	fileNameString.Length = sizeof(LARGE_INTEGER);

	//
	// We don't need to hold GrovelerFileResource here because we're only accessing
	// the handle, and the worst thing that an invalid handle will do here is to 
	// make the create file call fail.  Also, we don't have to worry about malicious
	// messing with the handle since we're in the system process context.
	//

	InitializeObjectAttributes(
		Obja,
		&fileNameString,
		OBJ_CASE_INSENSITIVE,
		deviceExtension->GrovelerFileHandle,
		NULL);

	status = NtCreateFile(
				openedFileHandle,
				desiredAccess,
				Obja,
				Iosb,
				NULL,				// Allocation size
				0,					// file attributes
				shareAccess,
				FILE_OPEN,
				createOptions | 
				FILE_OPEN_BY_FILE_ID,
				NULL,				// EA buffer
				0);					// EA length

#if		DBG
	if (!NT_SUCCESS(status) && STATUS_SHARING_VIOLATION != status) {
		DbgPrint("SIS: SipOpenFileById failed 0x%x\n",status);
	}
#endif	// DBG

	return status;
}

NTSTATUS
SipCompleteCopy(
	IN PSIS_SCB							scb,
	OUT BOOLEAN							fromCleanup)
/*++

Routine Description:

	Post a request to do a final copy on a file.  Does not wait for its
	completion.

Arguments:

	scb			- The scb for the file on which to try the final copy.

	fromCleanup	- TRUE iff this call was made from cleanup rather than from
					close.  Errors on final copies generated from cleanup
					are ignored, ones from close are retried on an exponential
					backoff schedule.
	
Return Value:

	STATUS_SUCCESS
--*/
{
	PSI_COPY_THREAD_REQUEST		copyRequest;

	copyRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof (SI_COPY_THREAD_REQUEST), ' siS');
	if (NULL == copyRequest) {
        //NTRAID#65186-2000/03/10-nealch  Handle out of memory without droping entry

#if DBG
		DbgPrint("SIS: SipCompleteCopy: Unable to allocate copy request for scb 0x%x\n",scb);
        ASSERT(FALSE);
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	ASSERT(copyRequest == (PSI_COPY_THREAD_REQUEST)copyRequest->listEntry);	// This is assumed at the dequeue side

	copyRequest->scb = scb;
	copyRequest->fromCleanup = fromCleanup;

	ExInterlockedInsertTailList(CopyList,copyRequest->listEntry,CopyListLock);
	KeReleaseSemaphore(CopySemaphore,IO_NO_INCREMENT,1,FALSE);

	return STATUS_SUCCESS;
}

//
// A context record used for final copies that have failed and are to be retried later.
//
typedef struct _SIS_RETRY_FINAL_COPY_CONTEXT {
		//
		// The timer DPC that executes to kick off the retry
		//
		KDPC			dpc[1];

		//
		// The timer that's used to start the DPC.
		//
		KTIMER			timer[1];

		//
		// The scb of the file on which to retry the final copy.
		//
		PSIS_SCB		scb;

		//
		// A work queue item to be used to start the actual retry.
		//
		WORK_QUEUE_ITEM	workItem[1];
} SIS_RETRY_FINAL_COPY_CONTEXT, *PSIS_RETRY_FINAL_COPY_CONTEXT;

VOID
SiRetryFinalCopyWork(
	IN PVOID			parameter)
/*++

Routine Description:

	A worker thread routine to retry a final copy that's failed.  We don't really directly
	retry the final copy here, but instead we just drop the reference to the scb that we've
	been holding.  Once all other references are also dropped to this scb, the final copy
	will be re-attempted.

Arguments:

	parameter - a pointer to a SIS_RETRY_FINAL_COPY_CONTEXT.  We free this when we're done.

Return Value:

	void
--*/
{
	PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext = (PSIS_RETRY_FINAL_COPY_CONTEXT)parameter;
	PDEVICE_EXTENSION				deviceExtension;

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ASSERT(NULL != retryContext);

	deviceExtension = retryContext->scb->PerLink->CsFile->DeviceObject->DeviceExtension;
	InterlockedDecrement(&deviceExtension->OutstandingFinalCopyRetries);

	SipDereferenceScb(retryContext->scb,RefsFinalCopyRetry);

	ExFreePool(retryContext);
}

VOID
SiRetryFinalCopyDpc(
	IN PKDPC			dpc,
	IN PVOID			context,
	IN PVOID			systemArg1,
	IN PVOID			systemArg2)
/*++

Routine Description:

	A timer-fired DPC routine that handles retrying a failed final copy.
	This just queues up a work item to do the final copy.

Arguments:

	dpc 		- The DPC that's executing

	context		- a PSIS_RETRY_FINAL_COPY_CONTEXT; see the definition of that structure
					for a description of the fields

	systemArg 1 & 2	- unused DPC parameters

Return Value:

	void
--*/
{
	PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext = (PSIS_RETRY_FINAL_COPY_CONTEXT)context;

    UNREFERENCED_PARAMETER( dpc );
    UNREFERENCED_PARAMETER( systemArg1 );
    UNREFERENCED_PARAMETER( systemArg2 );

	ASSERT(NULL != retryContext);
	ASSERT(retryContext->dpc == dpc);

	ExQueueWorkItem(retryContext->workItem,DelayedWorkQueue);
}


NTSTATUS
SipCompleteCopyWork(
	IN PSIS_SCB						scb,
	IN HANDLE						eventHandle,
	IN PKEVENT						event,
	IN BOOLEAN						fromCleanup)
/*++

Routine Description:

	A worker thread routine that does final copy on a file.  This function
	itself just checks some things (like whether the file's been deleted in the
	interim), calls SipFinalCopy to actually do the final copy, and then deals
	appropriately with errors if there are any.  If this is a close-generated
	call, we retry errors on an expeonential backoff schedule (with a time limit);
	if from cleanup, we ignore them on the theory that a close will eventually come
	along and we'll deal with it then.

	If we get an OPLOCK_BREAK_IN_PROGRESS, then someone else wants to use the file
	and we just stop.

Arguments:

	scb			- The scb on which to do the final copy

	eventHandle	- Handle to an event that we can use exclusively for now

	event		- Pointer to the same event as represented by eventHandle

	fromCleanup	- Whether this call originated in cleanup (TRUE) or close (FALSE)


Return Value:

	status of the final copy operation
--*/
{
	PSIS_PER_LINK					perLink = scb->PerLink;
	PDEVICE_EXTENSION				deviceExtension = perLink->CsFile->DeviceObject->DeviceExtension;
	NTSTATUS						status;
	KIRQL							OldIrql;
	BOOLEAN							wakeupNeeded;
	BOOLEAN							deleted;

	ASSERT(sizeof(scb->PerLink->LinkFileNtfsId) == sizeof(LARGE_INTEGER));

	SIS_MARK_POINT_ULONG(scb);

	//
	// The last reference to the SCB for a copied file has been dropped.
	// If there have been any writes into the file, then fill in any regions
	// that are unwritten from the underlying file.  If there have been no
	// writes into the file (which can happen for a mapped file) then
	// revert it into a reparse point.
	//

	//
	// Check to see whether the file was written into (a file can be
	// "copied" without being dirty if it's ever mapped).  We could probably
	// get away without taking the lock here because we hold the last
	// reference.
	//
	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;
	deleted = (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: SipCompleteCopyWork: scb %p, wakeupNeeded %d, deleted %d\n",scb,wakeupNeeded,deleted);
	}

	ASSERT((0 == scb->referencesByType[RefsFinalCopyRetry]) || fromCleanup);
	ASSERT((1 == scb->referencesByType[RefsFinalCopy]) || fromCleanup);
#endif	// DBG

	SIS_MARK_POINT_ULONG(wakeupNeeded);

	ASSERT((perLink->Flags & 
			(SIS_PER_LINK_FINAL_COPY | 
				SIS_PER_LINK_DIRTY |
				SIS_PER_LINK_FINAL_COPY_DONE)) ==
					(SIS_PER_LINK_DIRTY |
					 SIS_PER_LINK_FINAL_COPY));

	if (deleted) {

        SIS_MARK_POINT();
		//
		// This file was deleted after (possibly) being modified.  Make it look like
		// it's finished its final copy.
		//

		scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
		scb->PerLink->Flags &= ~(	SIS_PER_LINK_FINAL_COPY | 
									SIS_PER_LINK_FINAL_COPY_WAITERS);

		if (wakeupNeeded) {
			KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
		}

		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		SipDereferenceScb(scb, RefsFinalCopy);

		return STATUS_SUCCESS;
	}

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);

#if		DBG
	if (BJBDebug & 0x200000) {
		DbgPrint("SIS: SipCompleteCopyWork: skipping final copy because of set debug bit.\n");
		status = STATUS_SUCCESS;
	} else
#endif	// DBG

    SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	status = SipFinalCopy(
				deviceExtension,
				&perLink->LinkFileNtfsId,
				scb,
				eventHandle,
				event);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(scb);
		goto done;
	}

done:
				
	//
	// Set the flag indicating that the final copy is finished; this will result in
	// the dereference of the SCB actually deallocating it rather than just calling
	// us again.
	//

	KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);

	ASSERT(scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY);
	ASSERT(perLink->COWingThread == NULL);

	wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;

	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
		//
		// The final copy didn't complete because of an oplock break (ie,. someone else wanted
		// to use the file).  We'll leave it a SIS file for now and allow others to use it; we'll
		// complete the final copy later.
		//
        SIS_MARK_POINT_ULONG(status);

	} else if (NT_SUCCESS(status)) {

		scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
        SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	} else if (!fromCleanup) {

		//
		// The final copy failed for some reason other than an oplock break.
		// If we haven't retried too many times, schedule a retry for later.
		// We use an exponential backoff on the retries so they don't do
		// too much work in case it's a persistent error.  If the copy failed
		// with STATUS_INVALID_PARAMETER, it's probably becauce the file is
		// gone, so don't bother to try to retry in that case.
		//
		// The way that the retry works is that we just take a reference to the
		// scb and hold it until the timer expires.  We never go into final copy
		// when there are outstanding references, so this will prevent final
		// copy from happening until then.
		//
		// If this final copy was generated from cleanup rather than from close,
		// we don't do the error retry, but rather just ignore it.  Most likely it
		// was a sharing violation opening the file because another user opened it.
		// In any case, final copy will be rerun on close, so we needn't do anything here.
		//

		scb->ConsecutiveFailedFinalCopies++;
        SIS_MARK_POINT_ULONG(scb->PerLink->Flags);
        SIS_MARK_POINT_ULONG(scb->ConsecutiveFailedFinalCopies);

		if ((deviceExtension->OutstandingFinalCopyRetries < 130)
			&& (scb->ConsecutiveFailedFinalCopies <= (13 - (deviceExtension->OutstandingFinalCopyRetries / 10)))
			&& (STATUS_INVALID_PARAMETER != status)) {

			PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext;
			LARGE_INTEGER	dueTime;

			retryContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_RETRY_FINAL_COPY_CONTEXT), ' siS');
			

			if (NULL == retryContext) {
				//
				// Too bad.  Treat this like an unrecoverable failure and get out of the way.
				//
				SIS_MARK_POINT_ULONG(scb);

				goto doneCheckingRetry;
			}

			SipReferenceScb(scb,RefsFinalCopyRetry);

			InterlockedIncrement(&deviceExtension->OutstandingFinalCopyRetries);

			KeInitializeTimer(retryContext->timer);
			KeInitializeDpc(retryContext->dpc, SiRetryFinalCopyDpc, retryContext);
			ExInitializeWorkItem(retryContext->workItem, SiRetryFinalCopyWork, retryContext);
			retryContext->scb = scb;

			//
			// We sleep for 2 ^ RetryCount seconds before retrying (ie., exponential backoff).
			//
			dueTime.QuadPart = -10 * 1000 * 1000 * (1 << scb->ConsecutiveFailedFinalCopies);

			KeSetTimerEx(
				retryContext->timer,
				dueTime,
				0,				// period (ie., non-recurring)
				retryContext->dpc);
				
		} else {
			//
			// We've retried too many times, just give up on the final copy.
			//
			SIS_MARK_POINT_ULONG(scb);

			scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
		}
	}

doneCheckingRetry:

	scb->PerLink->Flags &= ~(	SIS_PER_LINK_FINAL_COPY | 
								SIS_PER_LINK_FINAL_COPY_WAITERS);

    SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	if (wakeupNeeded) {
		KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
	}

	KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

	SipDereferenceScb(scb, RefsFinalCopy);

	return status;
}

NTSTATUS
SipFinalCopy(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLARGE_INTEGER					linkFileNtfsId,
	IN OUT PSIS_SCB						scb,
	IN HANDLE							eventHandle,
	IN PKEVENT							event)

/*++

Routine Description:

	Perform the final copy from the copied file area into a file
	that has been copied-on-write.  

Arguments:

	deviceExtension - the device extension for the volume on which
		we're working.

	linkFileNtfsId  - the file id (as in FILE_OPEN_BY_FILE_ID) for
		the final file into which we're to copy

	scb - the scb for the file (NB: should really be a per-link)

	copyEventHandle - A handle to an event used for internal synchronization

	copyEvent - a PKEVENT for the event reprsented by copyEventHandle

Return Value:

	Returns the status of the copy.
--*/
{
	HANDLE							linkFileHandle = NULL;
	NTSTATUS						status;
	NTSTATUS						queryAllocatedStatus;
	NTSTATUS						failureStatus = STATUS_SUCCESS;
	PSIS_PER_LINK					perLink = scb->PerLink;
	HANDLE							underlyingFileHandle = perLink->CsFile->UnderlyingFileHandle;
	LONGLONG						fileOffset;
    PREPARSE_DATA_BUFFER    		ReparseBufferHeader = NULL;
    UCHAR              				ReparseBuffer[SIS_REPARSE_DATA_SIZE];
	PFILE_OBJECT					fileObject = NULL;
	BOOLEAN							prepareWorked;
	KIRQL							OldIrql;
	HANDLE							oplockEventHandle = NULL;
	PKEVENT							oplockEvent = NULL;
	IO_STATUS_BLOCK					oplockIosb[1];
	BOOLEAN							deleteReparsePoint;
	BOOLEAN							foundRange;
	SIS_RANGE_STATE					rangeState;
	LONGLONG						rangeLength;
#if		DBG
	BOOLEAN							deletedReparsePoint = FALSE;
#endif	// DBG
#define	OUT_ARB_COUNT	10
	FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
	FILE_ALLOCATED_RANGE_BUFFER		outArb[OUT_ARB_COUNT];
	ULONG							returnedLength;
	ULONG							i;
	LARGE_INTEGER					zero;

	SipAcquireScb(scb);
	ASSERT(perLink->COWingThread == NULL);
	perLink->COWingThread = PsGetCurrentThread();
	SipReleaseScb(scb);

	status = SipCreateEvent(
				NotificationEvent,
				&oplockEventHandle,
				&oplockEvent);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

#if		DBG
		DbgPrint("SIS: SipFinalCopy: unable to create event, 0x%x\n",status);
#endif	// DBG

		goto done;
	}

	status = SipOpenFileById(
				deviceExtension,
				linkFileNtfsId,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                0,						// createOptions
				&linkFileHandle);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		if (STATUS_SHARING_VIOLATION != status) {
			DbgPrint("SIS: SipFinalCopy failed open, 0x%x\n", status);
		}
#endif	// DBG
		goto done;
	}

	//
	// Place a batch oplock on the file so that if someone tries to open it we'll
	// get a chance to finish/stop our copy without having them fail the open, but
	// rather just wait for us.
	//

	status = NtFsControlFile(
				linkFileHandle,
				oplockEventHandle,
				NULL,					// APC routine
				NULL,					// APC context
				oplockIosb,
				FSCTL_REQUEST_BATCH_OPLOCK,
				NULL,					// input buffer
				0,						// i.b. length
				NULL,					// output buffer
				0);						// output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (STATUS_OPLOCK_NOT_GRANTED != status) {
			DbgPrint("SIS: SipFinalCopy: request batch oplock failed, 0x%x\n",status);
		}
#endif	// DBG

		if (STATUS_OPLOCK_NOT_GRANTED == status) {
			//
			// Treat this as an oplock break, which will cause us to retry later.
			//
			status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		}

		goto done;
	}

	ASSERT(STATUS_PENDING == status);

	status = ObReferenceObjectByHandle(
				linkFileHandle,
				FILE_WRITE_DATA,
				*IoFileObjectType,
				KernelMode,
				&fileObject,
				NULL);								// Handle information

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SIS: SipFinalCopy failed ObReferenceObjectByHandle, 0x%x\n",status);
#endif	// DBG
		goto done;
	}

#if		DBG
	if (BJBDebug & 0x01000000) {
		DbgPrint("SIS: SipFinalCopy: failing request because of set BJBDebug bit\n");
		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
#endif	// DBG

	//
	// See if the file has any user mapped sections, in which case we can't do a final copy yet.
	// We'll probably have to wait for the reference count to go to 0.  We'll fail with oplock
	// break in progress, which will cause us to not set up a failure retry.
	//
	zero.QuadPart = 0;
	if ((NULL != fileObject->SectionObjectPointer) && 
		!MmCanFileBeTruncated(fileObject->SectionObjectPointer, &zero)) {
		SIS_MARK_POINT_ULONG(fileObject->FsContext);

		status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		goto done;
	}

	//
	// Flush the file.  We need to do this because we could have dirty data that came in through a mapped
	// file write, and we wouldn't notice that it's dirty yet.
	//
	status = SipFlushBuffersFile(
				fileObject,
				deviceExtension->DeviceObject);

	ASSERT(STATUS_PENDING != status);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// Cruise through the file and find all of the allocated ranges.  Fill in any clean portions
	// of those allocated ranges.  We do this regardless of whether we're doing a "partial" final
	// copy, because these copies are less likely to fail with a "disk full" error.  Attempt the copyout
	// to all clean, allocated regions regardless of errors.
	//
	inArb->FileOffset.QuadPart = 0;
	inArb->Length.QuadPart = MAXLONGLONG;

	for (;;) {

		//
		// Query the allocated ranges for this file.
		//

		queryAllocatedStatus = SipFsControlFile(
					fileObject,
					deviceExtension->DeviceObject,
					FSCTL_QUERY_ALLOCATED_RANGES,
					inArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					outArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER) * OUT_ARB_COUNT,
					&returnedLength);

		//
		// Run through all of the returned allocated ranges and find any clean regions within them.
		//
		ASSERT((returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0) && 
			   (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) <= OUT_ARB_COUNT));

		//
		// If the query allocated ranges failed for some other reason that having too much to write
		// into the buffer we provided, then pretend that the rest of the file is allocated
		// and fill it all in.
		//
		if (!NT_SUCCESS(queryAllocatedStatus) && (STATUS_BUFFER_OVERFLOW != queryAllocatedStatus)) {

			returnedLength = sizeof(FILE_ALLOCATED_RANGE_BUFFER);

			outArb->FileOffset.QuadPart = inArb->FileOffset.QuadPart;
			outArb->Length.QuadPart = scb->SizeBackedByUnderlyingFile - outArb->FileOffset.QuadPart;

			ASSERT(outArb->Length.QuadPart >= 0);
		}

		for (i = 0; i < returnedLength/sizeof(FILE_ALLOCATED_RANGE_BUFFER); i++) {
			//
			// Assert that the allocated ranges are in order; if this isn't true the code will still work, but it
			// will query the same range repetedly.
			//
			ASSERT(i == 0 || outArb[i].FileOffset.QuadPart > outArb[i-1].FileOffset.QuadPart);

			//
			// Figure out if there's anything clean in the allocated range, and if so do a copy out to it.
			//

			fileOffset = outArb[i].FileOffset.QuadPart;

			while (fileOffset < outArb[i].FileOffset.QuadPart + outArb[i].Length.QuadPart) {

				if (fileOffset >= scb->SizeBackedByUnderlyingFile) {
					goto CheckedAllRanges;
				}

				SipAcquireScb(scb);

				foundRange = SipGetRangeEntry(
								deviceExtension,
								scb,
								fileOffset,
								&rangeLength,
								&rangeState);

				if (!foundRange) {
					//
					// This and everything up to SizeBackedByUnderlyingFile are clean.
					//
					rangeLength = outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart);
					rangeState = Untouched;
				} else {
					//
					// If this range extends beyond the end of the allocated region, truncate it.
					//
					if (rangeLength > outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart)) {
						rangeLength = outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart);
					}
				}

				ASSERT(fileOffset + rangeLength <= outArb[i].FileOffset.QuadPart + outArb[i].Length.QuadPart);

				//
				// Don't let this extend beyond sizeBacked.
				//
				if (fileOffset + rangeLength > scb->SizeBackedByUnderlyingFile) {
					rangeLength = scb->SizeBackedByUnderlyingFile - fileOffset;
				}

				SipReleaseScb(scb);

				if (rangeState == Untouched || rangeState == Faulted) {
					//
					// We need to copy into this range.  Do it now.
					//

					SIS_MARK_POINT_ULONG(fileOffset);

					status = SipBltRange(
								deviceExtension,
								underlyingFileHandle,
								linkFileHandle,
								fileOffset,
								rangeLength,
								eventHandle,
								event,
#if		INTERRUPTABLE_FINAL_COPY
								oplockEvent,
#else	// INTERRUPTABLE_FINAL_COPY
								NULL,
#endif	// INTERRUPTABLE_FINAL_COPY
								NULL					// checksum
		                        );

					if (!NT_SUCCESS(status)) {
						SIS_MARK_POINT_ULONG(status);
#if		DBG
						if (STATUS_FILE_LOCK_CONFLICT != status) {
							DbgPrint("SIS: SipFinalCopy failed blt, 0x%x\n", status);
						}
#endif	// DBG
						failureStatus = status;
					} else if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
						SIS_MARK_POINT_ULONG(scb);
						goto done;
					}
					
				}

				//
				// update fileOffset and continue checking within this outArb entry.
				//
				fileOffset += rangeLength;

			}	// while loop of SIS ranges within the NTFS allocated range

		} // for loop of outArb entries

		//
		// If this isn't the last iteration, update the inArb.
		//
		if (STATUS_BUFFER_OVERFLOW == queryAllocatedStatus) {
			//
			// Assert that we're making progress.
			//
			ASSERT((outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart >= inArb->FileOffset.QuadPart) && (outArb[OUT_ARB_COUNT-1].Length.QuadPart > 0));

			//
			// Move up our input range.
			//
			inArb->FileOffset.QuadPart = outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart + outArb[OUT_ARB_COUNT-1].Length.QuadPart;
			inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;
				
		} else {
			break;
		}
	} // for loop of calls to QueryAllocatedRanges

CheckedAllRanges:

#if		ENABLE_PARTIAL_FINAL_COPY

	//
	// If any of the copies failed, then just punt the whole thing.
	//
	if (!NT_SUCCESS(failureStatus)) {
		SIS_MARK_POINT_ULONG(failureStatus);

		status = failureStatus;
		goto done;
	}

	//
	// Figue out if we want to delete the reparse point.  We do this if and only if the file is dirty all the way from 0
	// to SizeBackedByUnderlyingFile.  Note that the SipBltFile call above actually will set the ranges dirty because it's
	// just a normal (mapped) write that goes through SiWrite.
	//

	fileOffset = 0;

	SipAcquireScb(scb);

	rangeState = SipGetRangeDirty(
					deviceExtension,
					scb,
					(PLARGE_INTEGER)&fileOffset,	// we rely on LARGE_INTEGER and LONGLONG being the same thing
					scb->SizeBackedByUnderlyingFile,
					FALSE);

	if (Dirty == rangeState) {
		deleteReparsePoint = TRUE;		
	} else {
		deleteReparsePoint = FALSE;
	}

	SipReleaseScb(scb);

#undef	OUT_ARB_COUNT	
#else	// ENABLE_PARTIAL_FINAL_COPY

	//
	// We don't care if any of the copies in the allocated range pass failed, because
	// the following code is sufficient for all cases.
	//
	SIS_MARK_POINT_ULONG(failureStatus);

	//
	// Look through all of the ranges of the file up to the
	// maximum possible size backed by the underlying file,
	// and copy any ranges that aren't written from the underlying
	// file to the copied file.
	//
	fileOffset = 0;
	while (fileOffset < scb->SizeBackedByUnderlyingFile) {
		BOOLEAN				waiters;

#if		INTERRUPTABLE_FINAL_COPY
		if (fileOffset + 0x10000 < scb->SizeBackedByUnderlyingFile) {
			//
			// We've got a decent amount of the file left to cover.  Check to
			// see if we should abort because someone wants the file.
			//
			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			waiters = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (waiters) {
				//
				// Someone'e waiting for the file, and we're more than 64K from the end, so
				// abort the final copy now.
				//
				SIS_MARK_POINT_ULONG(scb);
				status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
				goto done;
			}
		}
#endif	// INTERRUPTABLE_FINAL_COPY

		SipAcquireScb(scb);

		foundRange = SipGetRangeEntry(
						deviceExtension,
						scb,
						fileOffset,
						&rangeLength,
						&rangeState);

		if (!foundRange) {
			//
			// The range was never filled in in the MCB, and hence everything
			// from here to SizeBackedByUnderlyingFile is untouched.  Munge
			// the locals to look like that.
			// 
			rangeLength = scb->SizeBackedByUnderlyingFile - fileOffset;
			rangeState = Untouched;
		} else if (fileOffset + rangeLength > scb->SizeBackedByUnderlyingFile) {
			//
			// This range extends beyond sizeBacked, so truncate it so that it
			// just meets the size.
			//
			rangeLength = (ULONG)(scb->SizeBackedByUnderlyingFile - fileOffset);
		}


		ASSERT(rangeLength > 0);
		ASSERT(fileOffset + rangeLength <= scb->SizeBackedByUnderlyingFile);

		SipReleaseScb(scb);

		if (rangeState == Untouched || rangeState == Faulted) {
			//
			// The bytes in this range have never been written into the backing file.
			// write them in now.
			//

			SIS_MARK_POINT_ULONG(fileOffset);

			status = SipBltRange(
						deviceExtension,
						underlyingFileHandle,
						linkFileHandle,
						fileOffset,
						rangeLength,
						eventHandle,
						event,
#if		INTERRUPTABLE_FINAL_COPY
						oplockEvent,
#else	// INTERRUPTABLE_FINAL_COPY
						NULL,
#endif	// INTERRUPTABLE_FINAL_COPY
						NULL					// checksum
                        );
 
			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
#if		DBG
				if (STATUS_FILE_LOCK_CONFLICT != status) {
					DbgPrint("SIS: SipFinalCopy failed blt, 0x%x\n", status);
				}
#endif	// DBG
				goto done;
			} else if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
				SIS_MARK_POINT_ULONG(scb);
				goto done;
			}
		} else {
			//
			// The range is written, meaning that the correct bytes are in the
			// copied file already, and we don't need to do a thing.
			//
			ASSERT(rangeState == Written);
		}

		//
		// Update our pointer to show we've covered this range, and move on.
		//
		fileOffset += rangeLength;
	}

	deleteReparsePoint = TRUE;	// the full final copy always deletes the reparse point
#endif	// ENABLE_PARTIAL_FINAL_COPY

	if (deleteReparsePoint) {

		//
		// Prepare to change the CS file reference count.  We need to do this
		// before we can delete the reparse point.
		//
		status = SipPrepareCSRefcountChange(
					perLink->CsFile,
					&perLink->Index,
					linkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			//
			// The prepare failed.  We'll just delete the reparse point and leak the reference.
			//
			SIS_MARK_POINT_ULONG(status);

#if		DBG
			DbgPrint("SIS: SipFinalCopy: prepare failed 0x%x\n",status);
#endif	// DBG

			prepareWorked = FALSE;
		} else {
			prepareWorked = TRUE;
		}

		//
		// Now, delete the reparse point.
		//

	    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    	ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SIS;
	    ReparseBufferHeader->ReparseDataLength = 0;
    	ReparseBufferHeader->Reserved = 0xcabd;	// ???

		SIS_MARK_POINT_ULONG(scb);

		status = SipFsControlFile(
					fileObject,
					deviceExtension->DeviceObject,
					FSCTL_DELETE_REPARSE_POINT,
					ReparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
					NULL,									// output buffer
					0,										// output buffer length
					NULL);									// returned output buffer length

		if (!NT_SUCCESS(status)) {

			SIS_MARK_POINT_ULONG(status);

			if (prepareWorked) {
				SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					FALSE,
					FALSE);
			}

			goto done;
		}
		ASSERT(status != STATUS_PENDING);

#if		DBG
		deletedReparsePoint = TRUE;
#endif	// DBG

		if (prepareWorked) {
			SIS_MARK_POINT_ULONG(perLink->CsFile);

			status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					TRUE,
					FALSE);

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
#if		DBG
				DbgPrint("SIS: SipFinalCopy: complete failed 0x%x\n",status);
#endif	// DBG
			}
		}
	}	// if delete reparse point

done:

	ASSERT(deletedReparsePoint || !NT_SUCCESS(status) || (STATUS_OPLOCK_BREAK_IN_PROGRESS == status));

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
#if		DBG
		fileObject = NULL;
#endif	// DBG
	}

	if (NULL != linkFileHandle) {
		SIS_MARK_POINT_ULONG(scb);
		NtClose(linkFileHandle);
		SIS_MARK_POINT_ULONG(scb);
	}

	if (NULL != oplockEvent) {
		ObDereferenceObject(oplockEvent);
#if		DBG
		oplockEvent = NULL;
#endif	// DBG
	}

	if (NULL != oplockEventHandle) {
		NtClose(oplockEventHandle);
	}

	SipAcquireScb(scb);
	ASSERT(perLink->COWingThread == PsGetCurrentThread());
	perLink->COWingThread = NULL;
	SipReleaseScb(scb);

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sicalls.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sicalls.c

Abstract:

	Routines to make calls into the underlying file system for the
	Single Instance Store.  Generally, these are similar to the
	similar Zw calls, but they take file objects rather than handles
	and call down directly to the driver below SIS rather than going
	through the entire stack.

Authors:

    Bill Bolosky & Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// Context used to communicate between SipQueryInformationFile and
// SiQueryInformationCompleted.
//
typedef struct _SI_QUERY_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_QUERY_COMPLETION_CONTEXT, *PSI_QUERY_COMPLETION_CONTEXT;

NTSTATUS
SiQueryInformationCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipQueryInformationFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_QUERY_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_QUERY_COMPLETION_CONTEXT completionContext = (PSI_QUERY_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipQueryInformationFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN ULONG 					InformationClass,
    IN ULONG 					Length,
    OUT PVOID 					Information,
    OUT PULONG					ReturnedLength		OPTIONAL
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.  This call sends the
	irp directly to the driver immediately below SIS, so the file object
	must be something that's understood by the stack beneath SIS.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    InformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    Information - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipQueryInformationFileUsingGenericDevice(
				FileObject,
				deviceExtension->AttachedToDeviceObject,
				InformationClass,
				Length,
				Information,
				ReturnedLength);
}

NTSTATUS
SipQueryInformationFileUsingGenericDevice(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN ULONG 					InformationClass,
    IN ULONG 					Length,
    OUT PVOID 					Information,
    OUT PULONG					ReturnedLength		OPTIONAL
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    InformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    Information - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	SI_QUERY_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.  Set a valid return Length.
        //

	    if (NULL != ReturnedLength) {
	        *ReturnedLength = 0;
	    }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = Information;
    irp->Flags = IRP_BUFFERED_IO;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

	IoSetCompletionRoutine(
			irp,
			SiQueryInformationCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

	if (NULL != ReturnedLength) {
	    *ReturnedLength = (ULONG)completionContext->Iosb->Information;
	}
    return status;
}

//
// Context used to communicate between SipSetInformationFile and
// SiSetInformationCompleted.
//
typedef struct _SI_SET_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_SET_COMPLETION_CONTEXT, *PSI_SET_COMPLETION_CONTEXT;


NTSTATUS
SiSetInformationCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipSetInformationFileUsingGenericDevice.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_SET_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_SET_COMPLETION_CONTEXT completionContext = (PSI_SET_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipSetInformationFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN FILE_INFORMATION_CLASS	InformationClass,
    IN ULONG 					Length,
    IN PVOID 					Information
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

	All this routine really does is to pull the filesystem device object
	out of the SIS device extension and pass it into the generic version
	of set information file.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipSetInformationFileUsingGenericDevice(
				FileObject,
				deviceExtension->AttachedToDeviceObject,
				InformationClass,
				Length,
				Information);
}

NTSTATUS
SipSetInformationFileUsingGenericDevice(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN FILE_INFORMATION_CLASS	InformationClass,
    IN ULONG 					Length,
    IN PVOID 					Information
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	SI_SET_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

	ASSERT(InformationClass != FilePositionInformation);	// This call isn't supported in this routine
	ASSERT(InformationClass != FileTrackingInformation);	// This call isn't supported in this routine
	ASSERT(InformationClass != FileModeInformation);		// This call isn't supported in this routine
	ASSERT(InformationClass != FileCompletionInformation);	// This call isn't supported in this routine

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;

	irp->Flags = IRP_SYNCHRONOUS_API;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;
	if (FileDispositionInformation == InformationClass) {
		//
		// Auditing code needs to know the handle used for a delete.
		// We're in kernel mode, so we don't need to provide one.
		// Null out the field.
		//
		irpSp->Parameters.SetFile.DeleteHandle = NULL;
	}

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = Information;

    irp->Flags |= IRP_BUFFERED_IO;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = InformationClass;

	IoSetCompletionRoutine(
			irp,
			SiSetInformationCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

    return status;
}


//
// Context used to communicate between SipFsControlFile and
// SiFsControlCompleted.
//

#if DBG
//used to detect if we are returning from IOCallDriver without STATUS_PENDING
//being returned but with the completion routine not yet called.
#define SIMAGIC_INIT        0xBad4Babe
#define SIMAGIC_COMPLETED   0xBad2Babe
#endif

typedef struct _SI_FS_CONTROL_COMPLETION_CONTEXT {

#if DBG
        ULONG               magic;
#endif

		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_FS_CONTROL_COMPLETION_CONTEXT, *PSI_FS_CONTROL_COMPLETION_CONTEXT;

NTSTATUS
SiFsControlCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipQueryInformationFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done, copy the output
	data into the caller's buffer if appropriate, and free the irp

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_FS_CONTROL_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_FS_CONTROL_COMPLETION_CONTEXT completionContext = (PSI_FS_CONTROL_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

    ASSERT(completionContext->magic == SIMAGIC_INIT);
	*completionContext->Iosb = Irp->IoStatus;

	//
	// Handle cleanup processing for buffered IO.
	//
	if (Irp->Flags & IRP_BUFFERED_IO) {
		if (Irp->Flags & IRP_INPUT_OPERATION &&
			Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
			!NT_ERROR(Irp->IoStatus.Status)) {

            //
            // Copy the information from the system buffer to the caller's
            // buffer.  We don't need to worry about problems with the copy
			// because only KernelMode callers can use this interface.
            //

            RtlCopyMemory( Irp->UserBuffer,
                           Irp->AssociatedIrp.SystemBuffer,
                           Irp->IoStatus.Information );
		}

        //
        // Free the buffer if needed.
        //

        if (Irp->Flags & IRP_DEALLOCATE_BUFFER) {
            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        }

	}

#if DBG
    completionContext->magic = SIMAGIC_COMPLETED;
#endif

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipFsControlFile(
	IN PFILE_OBJECT				fileObject,
	IN PDEVICE_OBJECT			DeviceObject,
	IN ULONG					ioControlCode,
	IN PVOID					inputBuffer,
	IN ULONG					inputBufferLength,
	OUT PVOID					outputBuffer,
	IN ULONG					outputBufferLength,
	OUT PULONG					returnedOutputBufferLength	OPTIONAL)
/*++

Routine Description:

	Call a file system control given a file object.  This file object must
	be recognized by the components underlying SIS on the driver stack.

Arguments:
    FileObject - Supplies a pointer to the file object on which to make the
		fsctl call

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

	ioControlCode - The fsctl itself

	inputBuffer	- pointer to the buffer containing input data for the fsctl.  May be
			NULL is inputBufferLength is zero

	inputBufferLength - the size of the input buffer

	outputBuffer - buffer into which to place the data returned from the fsctl call.
		May be NULL is outputBufferLength is 0.

	outputBufferLength - the length of the output buffer.

	returnedOutputBufferLength - the actual count of bytes returned by the fsctl call.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipFsControlFileUsingGenericDevice(
				fileObject,
				deviceExtension->AttachedToDeviceObject,
				ioControlCode,
				inputBuffer,
				inputBufferLength,
				outputBuffer,
				outputBufferLength,
				returnedOutputBufferLength);
}


NTSTATUS
SipFsControlFileUsingGenericDevice(
	IN PFILE_OBJECT				fileObject,
	IN PDEVICE_OBJECT			DeviceObject,
	IN ULONG					ioControlCode,
	IN PVOID					inputBuffer,
	IN ULONG					inputBufferLength,
	OUT PVOID					outputBuffer,
	IN ULONG					outputBufferLength,
	OUT PULONG					returnedOutputBufferLength	OPTIONAL)
/*++

Routine Description:

	Call a file system control given a file object.

Arguments:
    FileObject - Supplies a pointer to the file object on which to make the
		fsctl call

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

	ioControlCode - The fsctl itself

	inputBuffer	- pointer to the buffer containing input data for the fsctl.  May be
			NULL is inputBufferLength is zero

	inputBufferLength - the size of the input buffer

	outputBuffer - buffer into which to place the data returned from the fsctl call.
		May be NULL is outputBufferLength is 0.

	outputBufferLength - the length of the output buffer.

	returnedOutputBufferLength - the actual count of bytes returned by the fsctl call.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PIO_STACK_LOCATION					irpSp;
	PIRP								irp;
	SI_FS_CONTROL_COMPLETION_CONTEXT	completionContext[1];
	NTSTATUS							status;
	ULONG								method;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(IoGetRelatedDeviceObject(fileObject) == IoGetAttachedDevice(DeviceObject));

#if		DBG
	if ((BJBDebug & 0x00800000) && (FSCTL_SET_REPARSE_POINT == ioControlCode)) {
		//
		// Fail the call for debugging 
		//
		DbgPrint("SIS: SipFsControlFile: intentionally failing FSCTL_SET_REPARSE_POINT for debugging reasons\n");
		return STATUS_UNSUCCESSFUL;
	}
#endif	// DBG

	//
	// Temporary hack: we need to do FSCTL_SET_REPARSE_POINT and FSCTL_DELETE_REPARSE_POINT on file objects
	// that the user opened read only.  In order to get NTFS to do this, we set the WriteAccess bit in the file
	// object.  Remove this hack once there's a more permanent fix in NTFS.
	//
	// We also now need to do this for FSCTL_SET_SPARSE.
	//
	if ((FSCTL_SET_REPARSE_POINT == ioControlCode) || (FSCTL_DELETE_REPARSE_POINT == ioControlCode) ||
		(FSCTL_SET_SPARSE == ioControlCode)) {
		fileObject->WriteAccess = TRUE;
	}

	//
	// The method is the input/output method of the IO control.  It is the low
	// two bits of the IO control code.
	//
	method = ioControlCode & 3;

	irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

	if (!irp) {
		SIS_MARK_POINT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

	irp->UserEvent = NULL;
	irp->UserIosb = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
	irpSp->FileObject = fileObject;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = outputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = inputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = ioControlCode;

    irp->MdlAddress = (PMDL) NULL;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

	switch (method) {
		case 0:
				if (inputBufferLength || outputBufferLength) {
					irp->AssociatedIrp.SystemBuffer = 
						ExAllocatePoolWithTag(NonPagedPool, 
							(inputBufferLength > outputBufferLength) ? inputBufferLength : outputBufferLength,
							' siS');

					if (irp->AssociatedIrp.SystemBuffer == NULL) {
						IoFreeIrp(irp);
						return STATUS_INSUFFICIENT_RESOURCES;
					}

					if (ARGUMENT_PRESENT(inputBuffer)) {
						RtlCopyMemory(	irp->AssociatedIrp.SystemBuffer,
										inputBuffer,
										inputBufferLength);
					}
					irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
					irp->UserBuffer = outputBuffer;

					if (ARGUMENT_PRESENT(outputBuffer)) {
						irp->Flags |= IRP_INPUT_OPERATION;
					}
				} else {
					irp->Flags = 0;
					irp->UserBuffer = NULL;
				}
				break;
		case 1:
		case 2:
				ASSERT(FALSE && "WRITEME");
		case 3:
				irpSp->Parameters.DeviceIoControl.Type3InputBuffer = inputBuffer;
				irp->Flags = 0;
				irp->UserBuffer = outputBuffer;
				break;
		default:
			ASSERT(FALSE && "SIS: SipFsControlFile: bogus method number\n");
	}

#if DBG
    completionContext->magic = SIMAGIC_INIT;
#endif
	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

	IoSetCompletionRoutine(
			irp,
			SiFsControlCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);
			
	status = IoCallDriver(DeviceObject, irp);

	if (status == STATUS_PENDING) {

		status = KeWaitForSingleObject(completionContext->event,Executive,KernelMode,FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = completionContext->Iosb->Status;
	}

#if DBG
    ASSERT(completionContext->magic == SIMAGIC_COMPLETED);
    if (completionContext->magic != SIMAGIC_COMPLETED) {    //wait for completion routine

		DbgPrint("SIS: SipFsControlFile: waiting for completion routine!\n");
		status = KeWaitForSingleObject(completionContext->event,Executive,KernelMode,FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = completionContext->Iosb->Status;
    }
#endif

	SIS_MARK_POINT_ULONG(completionContext->Iosb->Information);

	if (NULL != returnedOutputBufferLength) {
		*returnedOutputBufferLength =
            (ULONG)completionContext->Iosb->Information;
	}

#if DBG
    completionContext->magic = 0;   //mark it as freed
#endif
	return status;
	
}


//
// Context used to communicate between SipFlushBuffersFile and
// SiFlushBuffersCompleted.
//
typedef struct _SI_FLUSH_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];
} SI_FLUSH_COMPLETION_CONTEXT, *PSI_FLUSH_COMPLETION_CONTEXT;

NTSTATUS
SiFlushBuffersCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipFlushBuffersFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_FLUSH_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_QUERY_COMPLETION_CONTEXT completionContext = (PSI_QUERY_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipFlushBuffersFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject
    )

/*++

Routine Description:

	This routine flushes the cache for a given file object.  It is
	synchronous; it doesn't return until the flush is completed.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	PDEVICE_EXTENSION				deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	SI_FLUSH_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceExtension->AttachedToDeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = FileObject;

    irp->Flags = IRP_SYNCHRONOUS_API;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // The flush buffers irp doesn't have any parameters.
    //

	IoSetCompletionRoutine(
			irp,
			SiFlushBuffersCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceExtension->AttachedToDeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\post.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    post.c

Abstract:

	SIS support for posting to the Fsp

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

NTSTATUS
SiPrePostIrp(
	IN OUT PIRP		Irp)
/*++

Routine Description:

	Code to prepare an irp for posting.  Just locks the buffers for
	appropriate operations and marks the irp pending.

Arguments:

    Irp - Pointer to the Irp to be posted

Return Value:

    status of perparation

--*/

{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS status = STATUS_SUCCESS;

	if (irpSp->MajorFunction == IRP_MJ_READ
		|| irpSp->MajorFunction == IRP_MJ_WRITE) {
		if (!(irpSp->MinorFunction & IRP_MN_MDL)) {
			status = SipLockUserBuffer(
							Irp,
							irpSp->MajorFunction == IRP_MJ_READ ? IoWriteAccess : IoReadAccess,
							irpSp->Parameters.Read.Length);
		}
	}

	IoMarkIrpPending(Irp);

	return status;
}

NTSTATUS
SipLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

	This routine is stolen from NTFS.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    status of locking

--*/

{
    PMDL Mdl = NULL;

    ASSERT( Irp != NULL );

    if (Irp->MdlAddress == NULL) {

        //
        // Allocate the Mdl, and Raise if we fail.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, FALSE, Irp );

        if (Mdl == NULL) {
			return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, Irp->RequestorMode, Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;

			return Status;
        }
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}

VOID
SiFspDispatch(
	IN PVOID			parameter)
/*++

Routine Description:

	Generic dispatch routine for SIS posted irps.  Take the posted irp and execute
	it.  Frees the request buffer on completion.

Arguments:

	parameter - a PSI_FSP_REQUEST containing the information for the posted irp

Return Value:

	void

--*/
{
	PSI_FSP_REQUEST 			fspRequest = parameter;
	PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(fspRequest->Irp);

	SIS_MARK_POINT();
			 
	ASSERT(irpSp != NULL);

	switch (irpSp->MajorFunction) {
		case IRP_MJ_READ:		
			SIS_MARK_POINT_ULONG(fspRequest->Irp);
			SipCommonRead(fspRequest->DeviceObject, fspRequest->Irp, TRUE);
			break;

		default:
			SIS_MARK_POINT();
#if		DBG
			DbgPrint("SiFspDispatch: Invalid major function code in posted irp, 0x%x.\n", irpSp->MajorFunction);
			DbgBreakPoint();
#endif	// DBG
	}
	SIS_MARK_POINT();

	ExFreePool(fspRequest);
}

NTSTATUS
SipPostRequest(
	IN PDEVICE_OBJECT			DeviceObject,
	IN OUT PIRP					Irp,
	IN ULONG					Flags)
/*++

Routine Description:

	Routine to post a SIS irp.  Prepares the irp, constructs a post request 
	and queues it to a critical worker thread.

Arguments:

	DeviceObject	- For the SIS device

	Irp				- The IRP to be posted

	Flags			- currently unused

Return Value:

	status of the posting

--*/
{
	NTSTATUS 				status;
	PSI_FSP_REQUEST			fspRequest;

	fspRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_FSP_REQUEST), ' siS');
	if (fspRequest == NULL) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	fspRequest->Irp = Irp;
	fspRequest->DeviceObject = DeviceObject;
	fspRequest->Flags = Flags;

    status = SiPrePostIrp(Irp);
	
	if (!NT_SUCCESS(status)) {
		ExFreePool(fspRequest);
		return status;
	}

	ExInitializeWorkItem(
		fspRequest->workQueueItem,
		SiFspDispatch,
		(PVOID)fspRequest);
	
	ExQueueWorkItem(fspRequest->workQueueItem,CriticalWorkQueue);

	return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sicheck.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sicheck.c

Abstract:

    Code to rebuild the SIS common store backpointers after corruption.

Authors:

    Bill Bolosky, 1998

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

typedef struct _FILE_FIND_INFO {
    HANDLE              FindHandle;
    PVOID               FindBufferNext;
    ULONG               FindBufferLength;
    NTSTATUS            Status;
    PDEVICE_EXTENSION   DeviceExtension;
    PVOID               FindBuffer;
} FILE_FIND_INFO, *PFILE_FIND_INFO;

NTSTATUS
SipVCInitFindFile(
    OUT PFILE_FIND_INFO FindInfo,
    IN PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    Initializes the volume check common store directory findfirst/findnext
    functionality.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure to be passed to
                      SipVCFindNextFile.
    deviceExtension - the D.E. for the volume to be checked

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK ioStatusBlock;

    FindInfo->DeviceExtension = deviceExtension;
    FindInfo->Status = STATUS_SUCCESS;
    FindInfo->FindBufferLength = 4096;

    FindInfo->FindBuffer = ExAllocatePoolWithTag(
                                PagedPool,
                                FindInfo->FindBufferLength,
                                ' siS');

    FindInfo->FindBufferNext = FindInfo->FindBuffer;

    if (!FindInfo->FindBuffer) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        InitializeObjectAttributes(
            &Obja,
            &deviceExtension->CommonStorePathname,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL );

        //
        // Open the directory for list access.
        //
        status = NtOpenFile(
                    &FindInfo->FindHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

        //
        //  If the open failed, free the pool alocation
        //

        if (!NT_SUCCESS(status)) {

            ExFreePool( FindInfo->FindBuffer );
            FindInfo->FindBuffer = FindInfo->FindBufferNext = NULL;
        }
    }

    return status;
}

NTSTATUS
SipVCCloseFindFile(
    IN PFILE_FIND_INFO FindInfo)
/*++

Routine Description:

    Closes the FILE_FIND_INFO handles.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.

Return Value:

    status of operation.

--*/
{

    ASSERT(FindInfo->FindBuffer);
    ExFreePool(FindInfo->FindBuffer);
    FindInfo->FindBuffer = FindInfo->FindBufferNext = NULL;

    return NtClose(FindInfo->FindHandle);
}

NTSTATUS
SipVCFindNextFile(
    IN PFILE_FIND_INFO FindInfo,
    OUT PFILE_DIRECTORY_INFORMATION *DirectoryInfo)
/*++

Routine Description:

    Returns the next entry in the common store directory.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.
    DirectoryInfo   - pointer to FILE_DIRECTORY_INFORMATION structure
                      to be filled in.

Return Value:

    status of operation.

--*/
{
    PFILE_DIRECTORY_INFORMATION dirInfo;
    IO_STATUS_BLOCK ioStatusBlock;

Restart:
    dirInfo = (PFILE_DIRECTORY_INFORMATION) FindInfo->FindBufferNext;

    if (dirInfo == (PFILE_DIRECTORY_INFORMATION) FindInfo->FindBuffer) { 

        //
        // Read in the next batch of file names.
        //

        FindInfo->Status = NtQueryDirectoryFile(
                                FindInfo->FindHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                dirInfo,
                                FindInfo->FindBufferLength,
                                FileDirectoryInformation,
                                FALSE,
                                NULL,
                                FALSE
                                );

        if (! NT_SUCCESS(FindInfo->Status) &&
            STATUS_BUFFER_OVERFLOW != FindInfo->Status) {

            //
            // We handle STATUS_BUFFER_OVERFLOW below.
            //
            return FindInfo->Status;

        }
    }

    //
    // Adjust FindBufferNext for the next time we're called.
    //
    if (dirInfo->NextEntryOffset) {

        FindInfo->FindBufferNext = (PVOID) ((PUCHAR) dirInfo + dirInfo->NextEntryOffset);

    } else {

        FindInfo->FindBufferNext = FindInfo->FindBuffer;

        if (FindInfo->Status == STATUS_BUFFER_OVERFLOW) {

            //
            // The current entry is incomplete.
            //
            goto Restart;
        }    
    }

    *DirectoryInfo = dirInfo;

    return STATUS_SUCCESS;
}

NTSTATUS
SipComputeCSChecksum(
    IN PSIS_CS_FILE     csFile,
    IN OUT PLONGLONG    csFileChecksum,
    HANDLE              eventHandle,
    PKEVENT             event)
/*++

Routine Description:

    Computes the checksum of the specified common store file.

Arguments:

    csFile          - common store file.

    csFileChecksum  - pointer to variable to receive checksum value.

    eventHandle     - event handle required by SipBltRangeByObject.

    event           - corresponding event required by SipBltRangeByObject.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;

    *csFileChecksum = 0;

	if (0 == csFile->FileSize.QuadPart) {
		//
		// We can't call SipBltRangeByObject for empty files because it tries
		// to map them, which is illegal.  However, we know the checksum value for
		// the empty file is 0, so we'll just run with that.
		//
		SIS_MARK_POINT_ULONG(csFile);

		return STATUS_SUCCESS;
	}

    status = SipBltRangeByObject(
                csFile->DeviceObject->DeviceExtension,
                NULL,                       // srcFileObject
                csFile->UnderlyingFileHandle,
                0,                          // startingOffset,
                csFile->FileSize.QuadPart,
                eventHandle,
                event,
                NULL,                       // abortEvent,
                csFileChecksum);

    return status;
}

NTSTATUS
SipVCGetNextCSFile(
    PFILE_FIND_INFO FindInfo,
    PSIS_CS_FILE *cs)
/*++

Routine Description:

    Returns the next common store file to process.  The file is verified to have
    the proper guid style name and a valid backpointer stream header.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.
    cs              - variable to receive pointer to SIS_CS_FILE structure.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    PFILE_DIRECTORY_INFORMATION dirInfo;
    UNICODE_STRING fileName;
    CSID CSid;
    PSIS_CS_FILE csFile;
    PDEVICE_EXTENSION deviceExtension = FindInfo->DeviceExtension;

    //
    // Ignore non-CS files.
    //

    for (;;) {

        //
        // Get the next file name in the directory.
        //
        status = SipVCFindNextFile(FindInfo, &dirInfo);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (dirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }

        ASSERT(dirInfo->FileNameLength < MAXUSHORT);

        fileName.Buffer = dirInfo->FileName;
        fileName.Length = fileName.MaximumLength = (USHORT) dirInfo->FileNameLength;

        if (SipFileNameToIndex(&fileName, &CSid)) {

            //
            // This is a valid CS file name.  Lookup/create a SIS object for it.
            //
            csFile = SipLookupCSFile( &CSid, 0, deviceExtension->DeviceObject);

            if (NULL == csFile) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {
                //
                // It's not marked for deletion; make sure it's open.
                //

                status = SipAcquireUFO(csFile/*,TRUE*/);

                if (!NT_SUCCESS(status)) {
                    SIS_MARK_POINT_ULONG(status);
                    return status;
                }

                if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {

#if DBG
                    if (csFile->Flags & CSFILE_FLAG_CORRUPT) {
                        ASSERT(NULL == csFile->UnderlyingFileObject);
                        ASSERT(NULL == csFile->UnderlyingFileHandle);
                        ASSERT(NULL == csFile->BackpointerStreamFileObject);
                        ASSERT(NULL == csFile->BackpointerStreamHandle);
                    }
#endif

                    if (NULL == csFile->UnderlyingFileObject) {
                        SIS_MARK_POINT_ULONG(csFile);
                        //
                        // Open the CS file.  
                        //
                        status = SipOpenCSFileWork(
                                    csFile,             // common store file to open
                                    FALSE,              // open by ID if possible
                                    FALSE,              // TRUE => don't close handles if backpointer stream is corrupt
						            FALSE,				// don't request delete access
                                    NULL);              // do complete open
                    } else {
                        //
                        // The underlying file was already open, so we just succeed.
                        //
                        status = STATUS_SUCCESS;
                    }
                }

                SipReleaseUFO(csFile);

                if (STATUS_SUCCESS == status) {

                    *cs = csFile;
                    return status;

                } else {

                    // eventlog?
#if DBG
                    if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
                        DbgPrint("SipVCGetNextCSFile: SipOpenCSFileForVolCheck failed, %x, on:\n     %0.*ws\n",
                            status,
                            fileName.Length / sizeof(WCHAR),
                            fileName.Buffer);
                    }
#endif
                }
            }

            //
            // Skip this file.
            //
            SipDereferenceCSFile(csFile);
        }
    }
}


typedef struct _CSFILE_INFO {
    PSIS_CS_FILE        CSFile;
    HANDLE              SectionHandle;
    PSIS_BACKPOINTER    BPBuffer;           // mapped buffer address
    ULONG               BufferSize;         // mapped buffer size
    ULONG               BPCount;            // # entries rounded up to sector granularity
    ULONG               BPCountAdjusted;    // # entries after compaction, sector gran
    ULONG               BPActiveCount;      // # entries after compaction, non-sector gran
} CSFILE_INFO, *PCSFILE_INFO;


NTSTATUS
SipVCMapBPStream(
    IN PSIS_CS_FILE     csFile,
    OUT PCSFILE_INFO    csInfo)
/*++

Routine Description:

    Maps the common store file's backpointer stream into memory.

Arguments:

    csFile          - the common store file to map.

    csInfo          - CSFILE_INFO structure to hold information on the mapping.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    ULONG bpSize;
    LARGE_INTEGER   maxSectionSize;
    PDEVICE_EXTENSION deviceExtension = csFile->DeviceObject->DeviceExtension;
    ULONG_PTR viewSize;

    csInfo->CSFile = csFile;

    //
    // Compute the size of the backpointer stream rounded up to sector
    // granularity.
    //
    bpSize = ((((csFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) *
                sizeof(SIS_BACKPOINTER)) +
                deviceExtension->FilesystemVolumeSectorSize - 1) /
                deviceExtension->FilesystemVolumeSectorSize) * 
                deviceExtension->FilesystemVolumeSectorSize;

    maxSectionSize.QuadPart = bpSize;

    csInfo->BPCount = bpSize / sizeof(SIS_BACKPOINTER);
    csInfo->BPCountAdjusted = csInfo->BPCount;
    ASSERT(bpSize % sizeof(SIS_BACKPOINTER) == 0);

    //
    // Create a section to map the stream.
    //
    status = ZwCreateSection(
                &csInfo->SectionHandle,
                SECTION_MAP_WRITE | STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY,
                NULL,
                &maxSectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                csFile->BackpointerStreamHandle);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("SIS SipVCMapBPStream: ZwCreateSection failed, %x\n", status);
#endif
        goto Error;
    }
    ASSERT(status == STATUS_SUCCESS);       // and not STATUS_PENDING or anything weird

    //
    // Make sure we map the entire stream.
    //
    csInfo->BPBuffer = NULL;
    csInfo->BufferSize = 0;

    //
    // Map in the backpointer region.
    //

    viewSize = csInfo->BufferSize;
    status = ZwMapViewOfSection(
                csInfo->SectionHandle,
                NtCurrentProcess(),
                &csInfo->BPBuffer,
                0,                          // zero bits
                0,                          // commit size (ignored for mapped files)
                0,                          // section offset
                &viewSize,
                ViewUnmap,
                0,                          // allocation type
                PAGE_READWRITE);

    if (NT_SUCCESS(status)) {

        csInfo->BufferSize = (ULONG)viewSize;
        ASSERT(status == STATUS_SUCCESS);   // and not STATUS_PENDING or anything weird
        return status;
    }

#if DBG
    DbgPrint("SIS SipVCMapBPStream: ZwMapViewOfSection failed, %x\n", status);
#endif

    status = ZwClose(csInfo->SectionHandle);
    ASSERT(STATUS_SUCCESS == status);

    csInfo->SectionHandle = NULL;

Error:

    return status;
}

NTSTATUS
SipVCUnmapBPStream(
    IN PCSFILE_INFO    csInfo)
/*++

Routine Description:

    Undoes the mapping done in SipVCMapBPStream.

Arguments:

    csInfo          - CSFILE_INFO structure filled in by SipVCMapBPStream.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;

    status = ZwUnmapViewOfSection(NtCurrentProcess(), csInfo->BPBuffer);
    ASSERT(STATUS_SUCCESS == status);

    status = ZwClose(csInfo->SectionHandle);
    ASSERT(STATUS_SUCCESS == status);

    return STATUS_SUCCESS;
}

INLINE
NTSTATUS
SipVCReadBP(
    PCSFILE_INFO        csInfo,
    ULONG               i,
    PSIS_BACKPOINTER    *bp)
/*++

Routine Description:

    Returns a pointer to the specified backpointer entry.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

    i               - index into backpointer array to find.

    bp              - variable to received pointer to desired entry.

Return Value:

    status of operation.

--*/
{
    if (i >= csInfo->BPCount) {
        return STATUS_END_OF_FILE;
    }

    *bp = &csInfo->BPBuffer[i];
    return STATUS_SUCCESS;
}

INLINE
NTSTATUS
SipVCWriteBP(
    PCSFILE_INFO        csInfo,
    ULONG               i,
    PSIS_BACKPOINTER    bp)
/*++

Routine Description:

    Overwrites the contents of the specifed backpointer entry.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

    i               - index into backpointer array to overwrite.

    bp              - pointer to SIS_BACKPOINTER structure the contents of which will
                      overwrite the specified stream entry.

Return Value:

    status of operation.

--*/
{
    ASSERT(i < csInfo->BPCount);

    if (&csInfo->BPBuffer[i] != bp) {
        csInfo->BPBuffer[i] = *bp;
    }
    return STATUS_SUCCESS;
}

#if DBG
BOOLEAN
issorted(
    PCSFILE_INFO        csInfo)
/*++

Routine Description:

    Verify the backpointer stream is properly sorted.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

Return Value:

    status of operation.

--*/
{
#define key LinkFileIndex.QuadPart
    PSIS_BACKPOINTER a = &csInfo->BPBuffer[SIS_BACKPOINTER_RESERVED_ENTRIES];
    int i, r;

    r = csInfo->BPActiveCount - 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;

    for (i=0; i < r; i++)
        if (a[i].key > a[i+1].key)
            return FALSE;
    return TRUE;
}
#endif

VOID
SipVCSort(
    PCSFILE_INFO        csInfo)
/*++

Routine Description:

    Sort the backpointer stream by link index in ascending order.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

Return Value:

    none.

--*/
{
#define key LinkFileIndex.QuadPart
    PSIS_BACKPOINTER a = &csInfo->BPBuffer[SIS_BACKPOINTER_RESERVED_ENTRIES];
    const static ULONG ha[] = {1, 8, 23, 77, 281, 1073, 4193, 16577, 65921, 262913, MAXULONG};
    SIS_BACKPOINTER v;
    ULONG i, j, h, r;
    int k;

    r = csInfo->BPActiveCount - 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;

    ASSERT(r > 0 && r < MAXULONG);

    // Shell sort.  Adapted from Sedgewick, "Algorithms in C", 3rd edition

    for (k = 0; ha[k] <= r; k++)
        continue;

    while (--k >= 0) {
        h = ha[k];
        for (i = h; i <= r; i++) {
            j = i;
            if (a[i].key < a[j-h].key) {
                v = a[i];
                do {
                    a[j] = a[j-h];
                    j -= h;
                } while (j >= h && v.key < a[j-h].key);
                a[j] = v;
            }
        }
    }

#if DBG
    ASSERT(issorted(csInfo));
#endif

}

NTSTATUS
SipVCPhase1(
    PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    First phase of volume checking.  Repair backpointer stream in all
    common store files and clear backpointer check bits.

Arguments:

    deviceExtension - the D.E. for the volume to be checked

Return Value:

    status of operation.

--*/
{
    PSIS_CS_FILE csFile;
    CSFILE_INFO csInfo;
    KIRQL OldIrql;
    ULONG r, w;
    FILE_FIND_INFO FindInfo;
    LINK_INDEX maxIndexSeen;
    NTSTATUS status;
    BOOLEAN sortNeeded, corruptMaxIndex;
    SIS_BACKPOINTER dummyBP;
    PSIS_BACKPOINTER bp;
    PSIS_BACKPOINTER prevBP;
	LINK_INDEX Index;
    ULONG nScans;
#if DBG
    ULONG csFileCount = 0;
#endif

    dummyBP.LinkFileIndex.QuadPart = 0;
    dummyBP.LinkFileNtfsId.QuadPart = 0;

    //
    // Make sure the index allocator is initialized before we begin.
    //
    status = SipAllocateIndex(deviceExtension, &maxIndexSeen);

    if (STATUS_CORRUPT_SYSTEM_FILE == status) {
        //
        // We need to repair the maxIndex file.
        //
        corruptMaxIndex = TRUE;
    } else {
        ASSERT(NT_SUCCESS(status));
        corruptMaxIndex = FALSE;
    }

    maxIndexSeen.QuadPart = 0;

    //
    // Phase 1: Scan the Common Store directory.
    //          - Check for legal GUID name.  Ignore file if invalid name.
    //          - Verify that backpointer link indices are in ascending order.
    //          - Reset all backpointer check flags.
    //          - Compact the backpointer stream.
    //          - Track MaxIndex.
    //          - Don't allocate new indices.
    //
    //
    // When we're done with this phase, the backpointer stream can still
    // have duplicate link indices.  They will be fixed in the subsequent
    // phases.
    // 
    // How do we check for cross-CS file link collisions?
    // Should we handle "too big" link indices?  That is,
    // probable pending MaxIndex wrap?
    //
    status = SipVCInitFindFile(
                &FindInfo,
                deviceExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (;;) {

        status = SipVCGetNextCSFile(&FindInfo, &csFile);

        if (!NT_SUCCESS(status)) {

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase1: SipVCGetNextCSFile failed, %x\n", status);
#endif
            }

            break;
        }

        //
        // Acquire exclusive access to the backpointer stream.
        //
		SipAcquireBackpointerResource(csFile, TRUE, TRUE);

        //
        // Skip if this file has been deleted.
        //
        if (csFile->Flags & CSFILE_FLAG_DELETED) {
            goto SkipCSFile;
        }

#if DBG
        ++csFileCount;
#endif
        //
        // Map the backpointer stream into memory.
        //
        status = SipVCMapBPStream(csFile, &csInfo);

        if (!NT_SUCCESS(status)) {
            goto SkipCSFile;
        }

        nScans = 0;

Restart:
        ++nScans;                           // shouldn't have to restart more than once
        sortNeeded = FALSE;
        prevBP = &dummyBP;

        //
        // Walk the backpointer list.
        //
        for (r = w = SIS_BACKPOINTER_RESERVED_ENTRIES; ; ++r) {

            status = SipVCReadBP(&csInfo, r, &bp);

            if (STATUS_END_OF_FILE == status) {

                BOOLEAN resetMaxIndex = FALSE;

                //
                // We've processed all the backpointers.  Check MaxIndex.
                // If it's invalid, reset it to the maximum value we've
                // seen thus far.
                //
                KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);

                if (maxIndexSeen.QuadPart > deviceExtension->MaxUsedIndex.QuadPart) {

                    //
                    // MaxIndex is bogus, reset it.  Note that we
                    // have not allocated any new indices during this
                    // phase, so we haven't made the situation any worse
                    // than it was when we started.
                    //
                    // We'll now reset MaxIndex, and phase 2 will
                    // reallocate any indices for backpointers that aren't
                    // found, and phase 3 will delete the backpointers
                    // that existed but were not detected during phase 2.
                    //
                    deviceExtension->MaxUsedIndex.QuadPart = 
                    deviceExtension->MaxAllocatedIndex.QuadPart = maxIndexSeen.QuadPart + 10000;

                }

                KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

                if (r > w) {

                    ULONG d;
                    SIS_BACKPOINTER delBP;

                    //
                    // We compacted the stream.  Mark the entries at the end
                    // deleted.  We only need to go up as far as the end of
                    // the sector containing the last valid back pointer.
                    //
                    delBP.LinkFileIndex.QuadPart = MAXLONGLONG;
                    delBP.LinkFileNtfsId.QuadPart = MAXLONGLONG;

                    csInfo.BPCountAdjusted =
                          ((((w * sizeof(SIS_BACKPOINTER)) +
                          deviceExtension->FilesystemVolumeSectorSize - 1) /
                          deviceExtension->FilesystemVolumeSectorSize) *
                          deviceExtension->FilesystemVolumeSectorSize) /
                          sizeof(SIS_BACKPOINTER);

                    ASSERT(csInfo.BPCountAdjusted <= csInfo.BPCount);
                    ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);
                    ASSERT((csInfo.BPCount * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

                    for (d = csInfo.BPCountAdjusted - 1; d >= w; --d) {
                        status = SipVCWriteBP(&csInfo, d, &delBP);
                    }
                }

                csInfo.BPActiveCount = w;

                //
                // See if we need to do a sort.
                //
                if (sortNeeded) {
                    if (nScans > 1) {
                        //
                        // Should never have to sort more than once.
                        //
                        ASSERT(!"SIS: SipVCPhase1 internal error");
                        break;
                    }

                    SipVCSort(&csInfo);
                    goto Restart;
                }

                break;
            }

            //
            // We have the backpointer, now validate it.
            //
            if (MAXLONGLONG != bp->LinkFileIndex.QuadPart &&
                MAXLONGLONG != bp->LinkFileNtfsId.QuadPart &&
                0           != bp->LinkFileIndex.QuadPart &&
                0           != bp->LinkFileNtfsId.QuadPart) {

                //
                // Track the highest in-use index.
                //
                if (bp->LinkFileIndex.QuadPart > maxIndexSeen.QuadPart) {
                    maxIndexSeen = bp->LinkFileIndex;
                }

                //
                // Mark this backpointer as unreferenced.
                //
                bp->LinkFileIndex.Check = 0;

                //
                // Check for out of order backpointers.
                //
                if (bp->LinkFileIndex.QuadPart < prevBP->LinkFileIndex.QuadPart) {

                    //
                    // The backpointer list is not sorted.  This can happen if
                    // the MaxIndex wraps or is somehow corrupted.
                    //
                    sortNeeded = TRUE;

                }

                //
                // Check for duplicate and colliding link indices.  Handle them simply
                // by deleting them.  The link enumeration phase will find or add all
                // appropriate backpointers.
                //
                if (bp->LinkFileIndex.QuadPart != prevBP->LinkFileIndex.QuadPart) {

                    //
                    // Write the backpointer back to the file, compacting the list.
                    //
                    status = SipVCWriteBP(&csInfo, w, bp);
                    ASSERT(STATUS_SUCCESS == status);

                    //
                    // The value just written is the new prevBP.
                    //
                    SipVCReadBP(&csInfo, w, &prevBP);
                    ++w;
                }
            }
        }

        ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);

        ASSERT(csFile->BPStreamEntries >= csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES);

        status = SipVCUnmapBPStream(&csInfo);
        ASSERT(STATUS_SUCCESS == status);

        //
        // Truncate the stream if necessary.  Both BPCountAdjusted
        // and BPCount are sector granular counts.
        //
        if (csInfo.BPCountAdjusted < csInfo.BPCount) {
            FILE_END_OF_FILE_INFORMATION    endOfFileInfo[1];

            ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);

            csFile->BPStreamEntries = csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES;

            ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

            endOfFileInfo->EndOfFile.QuadPart = csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER);

            status = SipSetInformationFile(
                        csFile->BackpointerStreamFileObject,
                        deviceExtension->DeviceObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        endOfFileInfo);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh1: Can't truncate csFile, %x\n", status);
            }
#endif
        }

SkipCSFile:
		SipReleaseBackpointerResource(csFile);
        SipDereferenceCSFile(csFile);
    }

    //
    // If the MaxIndex file was corrupt, it will be repaired on the next call
    // to SipAllocateIndex.  Clear the corrupt flag so the call will go through.
    //
    if (corruptMaxIndex) {
        KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
        deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
        KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);
    }

    //
    // Allocate an index.  This will cause the MaxIndex file to be updated
    // with the new value set above (if one was set).
    //
    SipAllocateIndex(deviceExtension, &Index);

#if DBG
    DbgPrint("SIS SipVCPhase1 processed %d common store files\n", csFileCount);
#endif

    SipVCCloseFindFile(&FindInfo);
    return status;
}

#define nRPI 256
#define sizeof_ReparsePointInfo (nRPI * sizeof(FILE_REPARSE_POINT_INFORMATION))
#define INDEX_NAME_LENGTH (37*sizeof(WCHAR))    // sizeof(L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION")

UNICODE_STRING reparseIndexDir = {
    INDEX_NAME_LENGTH,
    INDEX_NAME_LENGTH,
    L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION"
};

BOOLEAN
SipRecheckPerLinks(
    PDEVICE_EXTENSION deviceExtension,
    BOOLEAN ForceLookup)
/*++

Routine Description:

    Either calls SipCheckBackpointer or forces it to be called at the next file open.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

    ForceLookup     - set to TRUE if only want to force SipCheckBackpointer to be called
                      at next open time, otherwise SipCheckBackpointer will be called
                      immediately if the backpointer has not already been verified.

Return Value:

    status of operation.

--*/
{
    PSIS_SCB scb = NULL;
    BOOLEAN retStatus = TRUE;

    //
    // Walk the list of scb's.  SipEnumerateScbList grabs a reference
    // to the returned scb for us, and releases a reference from the
    // passed in scb.
    //
    while (scb = SipEnumerateScbList(deviceExtension, scb)) {
        KIRQL OldIrql;
        BOOLEAN found;
        PSIS_CS_FILE csFile;
        PSIS_PER_LINK perLink;
        NTSTATUS status;
        int i;

        perLink = scb->PerLink;
        csFile = perLink->CsFile;

        if (ForceLookup ||
            (perLink->Flags & (SIS_PER_LINK_BACKPOINTER_VERIFIED | SIS_PER_LINK_BACKPOINTER_GONE)) == 0) {
            //
            // Take exclusive access to the backpointer stream.
            //
			SipAcquireBackpointerResource(csFile, TRUE, TRUE);
            SipAcquireScb(scb);

            if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {
                //
                // Force a backpointer lookup.
                //
                KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                perLink->Flags &= ~SIS_PER_LINK_BACKPOINTER_VERIFIED;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                //
                // Clear the cache so it isn't found there.
                //
                for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
                    csFile->BackpointerCache[i].LinkFileIndex.QuadPart = -1;
                }

                if (!ForceLookup) {
                    //
                    // Recheck the backpointer.  This will find the check flag
                    // clear and rewrite the backpointer with the check flag set.
                    //
                    status = SipCheckBackpointer(perLink, TRUE, &found);

                    if (!NT_SUCCESS(status)) {
#if DBG
                        DbgPrint("SIS SipRecheckPerLinks: SipCheckBackpointer failed, %s\n", status);
#endif
                        retStatus = FALSE;

                    } else if (!found && (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) == 0) {
                        //
                        // This can happen if the open during phase 2 fails.  It shouldn't.
                        // NTRAID#65187-2000/03/10-nealch  Restore backpointer
                        //
                        ASSERT(!"SipRecheckPerLinks: backpointer not found.");
                    }
                }
            }

            //
            // We're done with this one.
            //
            SipReleaseScb(scb);
			SipReleaseBackpointerResource(csFile);
        }
    }

    return retStatus;
}

NTSTATUS
SipVCPhase2(
    PDEVICE_EXTENSION deviceExtension,
    BOOLEAN *verifiedAll)
/*++

Routine Description:

    Second phase of volume checking.  Enumerate all SIS link files and open
    and close them.  Normal validation/repair performed in SiCreate will
    correct any inconsistencies.  It will also set the backpointer check
    bit in the common store file for use in phase 3.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

    verifiedAll     - pointer to BOOLEAN to receive indication of whether all
                      all link files were successfully verified.  If FALSE, not
                      all link files were verified, therefore phase 3 should not
                      be run.

Return Value:

    status of operation.

--*/
{
    HANDLE hIndex = NULL, hFile;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS status;
    UNICODE_STRING reparseIndexName;
    PFILE_REPARSE_POINT_INFORMATION reparsePointInfo = NULL;
    BOOLEAN restartScan;
    BOOLEAN linkOpenFailure = FALSE;
    ULONG returnedCount;
    ULONG i;

    //
    // Phase 2: Enumerate all SIS link files.
    //          - Open/close each file.  Normal driver operation will validate
    //            reparse point information and CS backpointer as well as
    //            set the backpointer check flag.
    //
    // What do we do about errors during the scan?
    //  Ignore sharing violations (assume we already have the file open)
    //  Don't delete any CS files (err toward conservativeness.)
    //

    //
    // Force a back pointer recheck on all open per-links.
    //
    if (! SipRecheckPerLinks(deviceExtension, TRUE)) {
        linkOpenFailure = TRUE;
    }

    reparsePointInfo = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof_ReparsePointInfo,
                            ' siS');

    if (!reparsePointInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Concatenate the file system root pathname with the reparse index pathname.
    // (Yes, we should be able to open just the reparse index pathname using
    // the filesystem root handle as the parent directory, but that's not working...)
    //
    reparseIndexName.MaximumLength = deviceExtension->FilesystemRootPathname.Length +
                                     reparseIndexDir.Length;

    reparseIndexName.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    reparseIndexName.MaximumLength,
                                    ' siS');

    if (!reparseIndexName.Buffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlCopyUnicodeString(&reparseIndexName, &deviceExtension->FilesystemRootPathname);

    status = RtlAppendUnicodeStringToString(&reparseIndexName, &reparseIndexDir);
    ASSERT(STATUS_SUCCESS == status);

    InitializeObjectAttributes(
        &Obja,
        &reparseIndexName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access.
    //
    status = NtOpenFile(
                &hIndex,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &ioStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    ExFreePool(reparseIndexName.Buffer);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("SIS SipVCPhase2: reparse index open failed, %x\n", status);
#endif
        goto Error;
    }

    restartScan = TRUE;

    //
    // Loop reading a bunch of directory entries.
    //
    for (;;) {

        status = NtQueryDirectoryFile(
                        hIndex,
                        NULL,            //  Event
                        NULL,            //  ApcRoutine
                        NULL,            //  ApcContext
                        &ioStatusBlock,
                        reparsePointInfo,
                        sizeof_ReparsePointInfo,
                        FileReparsePointInformation,
                        FALSE,           //  ReturnSingleEntry
                        NULL,            //  FileName
                        restartScan );   //  RestartScan

        restartScan = FALSE;

        if (STATUS_SUCCESS != status) {

            ASSERT(STATUS_BUFFER_OVERFLOW != status);

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase2: NtQueryDirectoryFile failed, %x\n", status);
#endif
            }

            break;

        }

        returnedCount = (ULONG)ioStatusBlock.Information /
                        sizeof(FILE_REPARSE_POINT_INFORMATION);

        //
        // Loop processing each directory entry (reparse point).
        //
        for (i = 0; i < returnedCount; ++i) {

            if (IO_REPARSE_TAG_SIS == reparsePointInfo[i].Tag) {
                UNICODE_STRING  fid;

                //
                // Open/Close the SIS link.  If we get a sharing violation,
                // assume that we already have it open.
                //

                fid.Length = fid.MaximumLength = sizeof(LONGLONG);
                fid.Buffer = (PVOID) &reparsePointInfo[i].FileReference;

                InitializeObjectAttributes(
                    &Obja,
                    &fid,
                    OBJ_CASE_INSENSITIVE,
                    deviceExtension->GrovelerFileHandle,
                    NULL);

                //
                // Open the link file.  Use DesiredAccess == 0 to avoid
                // sharing violations.
                //

                status = NtCreateFile(
                            &hFile,
                            0,                  // DesiredAccess,
                            &Obja,
                            &ioStatusBlock,
                            NULL,               // Allocation size
                            0,                  // file attributes
                            0,                  // ShareAccess
                            FILE_OPEN,
                            FILE_NON_DIRECTORY_FILE |
                            //FILE_COMPLETE_IF_OPLOCKED | 
                            FILE_OPEN_BY_FILE_ID,
                            NULL,               // EA buffer
                            0);                 // EA length

                if (NT_SUCCESS(status)) {

                    NtClose(hFile);

                } else {

                    switch (status) {
                        //
                        // These errors can safely be ignored.
                        //
                    case STATUS_INVALID_PARAMETER:
                    case STATUS_OBJECT_PATH_NOT_FOUND:
                    case STATUS_SHARING_VIOLATION:
                    case STATUS_DELETE_PENDING:
#if DBG
                        DbgPrint("SIS SipVCPhase2: ignored open failure, ID: %08x%08x, status: %x\n",
                            reparsePointInfo[i].FileReference, status);
#endif
                        break;

                    default:
                        //
                        // We were unable to validate the reparse info and CS
                        // backpointer, so we cannot delete any unreferenced
                        // backpointers in any common store files nor any common
                        // store files themselves.
                        //
#if DBG
                        DbgPrint("SIS SipVCPhase2: open failure, ID: %08x%08x, status: %x\n",
                            reparsePointInfo[i].FileReference, status);
#endif
                        linkOpenFailure = TRUE;
                    }
                }
            }
        }
    }

    //
    // The open/close above should have verified all link file backpointers,
    // including those already open.  Double check that all open link
    // files have had their backpointers verified.
    //
    if (! SipRecheckPerLinks(deviceExtension, FALSE)) {
        linkOpenFailure = TRUE;
    }

Error:
    if (hIndex)
        NtClose(hIndex);
    if (reparsePointInfo)
        ExFreePool(reparsePointInfo);

    *verifiedAll = !linkOpenFailure;

    return status;
}

NTSTATUS
SipVCPhase3(
    PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    Third and final phase of volume checking.  Enumerate all common store
    files and delete any that have no valid backpointers.  All valid
    backpointers should have their check bit set at this point.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

Return Value:

    status of operation.

--*/
{
    PSIS_CS_FILE csFile;
    CSFILE_INFO csInfo;
    KIRQL OldIrql;
    ULONG r, w;
    FILE_FIND_INFO FindInfo;
    LINK_INDEX maxIndexSeen;
    NTSTATUS status;
    SIS_BACKPOINTER dummyBP;
    PSIS_BACKPOINTER bp;
    PSIS_BACKPOINTER prevBP;
#if DBG
    ULONG csFileCount = 0, deletedCSCount = 0;
#endif

    dummyBP.LinkFileIndex.QuadPart = 0;
    dummyBP.LinkFileNtfsId.QuadPart = 0;

    maxIndexSeen.QuadPart = 0;

    //
    // Phase 3: Scan the Common Store directory.
    //          - Check for legal GUID name.  Ignore file if invalid name.
    //          - Verify that backpointer link indices are in ascending order.
    //          - Reset all backpointer check flags.
    //          - Compact the backpointer stream.
    //          - Track MaxIndex.
    //          - Don't allocate new indices.
    //
    //
    // When we're done with this phase, the backpointer stream can still
    // duplicate link indices.  They will be fixed in the subsequent
    // phases.
    // 
    // How do we check for cross-CS file link collisions?
    // Should we handle "too big" link indices?  That is,
    // probable pending MaxIndex wrap?
    //
    status = SipVCInitFindFile(
                &FindInfo,
                deviceExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (;;) {

        status = SipVCGetNextCSFile(&FindInfo, &csFile);

        if (!NT_SUCCESS(status)) {

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase3: SipVCGetNextCSFile failed, %x\n", status);
#endif
            }

            break;
        }

        //
        // Acquire exclusive access to the backpointer stream.
        //
		SipAcquireBackpointerResource(csFile,TRUE,TRUE);

        //
        // Skip if this file has been deleted.
        //
        if (csFile->Flags & CSFILE_FLAG_DELETED) {
            goto SkipCSFile;
        }

#if DBG
        ++csFileCount;
#endif
        //
        // Map the backpointer stream into memory.
        //
        status = SipVCMapBPStream(csFile, &csInfo);

        if (!NT_SUCCESS(status)) {
            goto SkipCSFile;
        }

        prevBP = &dummyBP;

        //
        // Walk the backpointer list.
        //
        for (r = w = SIS_BACKPOINTER_RESERVED_ENTRIES; ; ++r) {

            status = SipVCReadBP(&csInfo, r, &bp);

            if (STATUS_END_OF_FILE == status) {

                BOOLEAN resetMaxIndex = FALSE;
                LINK_INDEX Index;

                //
                // We've processed all the backpointers.  Check MaxIndex.
                // It should be valid unless corruption is occuring during
                // the volume check.
                //
                KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);

                if (maxIndexSeen.QuadPart > deviceExtension->MaxUsedIndex.QuadPart) {

                    //
                    // MaxIndex is bogus, reset it.  Note that we
                    // have not allocated any new indices during this
                    // phase, so we haven't made the situation any worse
                    // than it was when we started.
                    //
                    // We'll now reset MaxIndex, and phase 2 will
                    // reallocate any indices for backpointers that aren't
                    // found, and phase 3 will delete the backpointers
                    // that existed but were not detected during phase 2.
                    //
                    deviceExtension->MaxUsedIndex.QuadPart = 
                    deviceExtension->MaxAllocatedIndex.QuadPart = maxIndexSeen.QuadPart + 10000;

                    resetMaxIndex = TRUE;

                    //
                    // Event log
                    //

                }

                KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

                if (resetMaxIndex) {

                    //
                    // Allocate an index.  This will cause the MaxIndex file
                    // to be updated with the new value set above.
                    //

                    status = SipAllocateIndex(deviceExtension, &Index);

                    if (!NT_SUCCESS(status)) {

                        //
                        // This is bad.
                        //
                    }
                }

                if (r > w) {

                    ULONG d;
                    SIS_BACKPOINTER delBP;

                    //
                    // We compacted the stream.  Mark the entries at the end
                    // deleted.  We only need to go up as far as the end of
                    // the sector containing the last valid back pointer.
                    //
                    delBP.LinkFileIndex.QuadPart = MAXLONGLONG;
                    delBP.LinkFileNtfsId.QuadPart = MAXLONGLONG;

                    csInfo.BPCountAdjusted =
                          ((((w * sizeof(SIS_BACKPOINTER)) +
                          deviceExtension->FilesystemVolumeSectorSize - 1) /
                          deviceExtension->FilesystemVolumeSectorSize) *
                          deviceExtension->FilesystemVolumeSectorSize) /
                          sizeof(SIS_BACKPOINTER);

                    ASSERT(csInfo.BPCountAdjusted <= csInfo.BPCount);
                    ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);
                    ASSERT((csInfo.BPCount * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

                    for (d = csInfo.BPCountAdjusted - 1; d >= w; --d) {
                        status = SipVCWriteBP(&csInfo, d, &delBP);
                    }
                }

                csInfo.BPActiveCount = w;

                break;
            }

            //
            // We have the backpointer, now validate it.
            //
            if (MAXLONGLONG != bp->LinkFileIndex.QuadPart &&
                MAXLONGLONG != bp->LinkFileNtfsId.QuadPart &&
                0           != bp->LinkFileIndex.QuadPart &&
                0           != bp->LinkFileNtfsId.QuadPart) {

                //
                // If this backpointer is unreferenced, delete it.
                //
                if (0 == bp->LinkFileIndex.Check) {
                    continue;
                }

                //
                // Track the highest in-use index.
                //
                if (bp->LinkFileIndex.QuadPart > maxIndexSeen.QuadPart) {

                    maxIndexSeen = bp->LinkFileIndex;

                }

                //
                // We should not see duplicate link indices unless corruption is
                // occuring during the volume check.
                //
                if (bp->LinkFileIndex.QuadPart == prevBP->LinkFileIndex.QuadPart) {

                    // event log

                }

                //
                // We should not see out of order backpointers unless corruption is
                // occuring during the volume check.
                //
                if (bp->LinkFileIndex.QuadPart < prevBP->LinkFileIndex.QuadPart) {

                    // Event log
                }

                //
                // Write the backpointer back to the file, compacting the list.
                // Note that this doesn't actually write anything in the case
                // where r == w.
                //
                status = SipVCWriteBP(&csInfo, w, bp);
                ASSERT(STATUS_SUCCESS == status);

                SipVCReadBP(&csInfo, w, &prevBP);
                ++w;

            }
        }

        ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);
        ASSERT(csFile->BPStreamEntries >= csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES);

        status = SipVCUnmapBPStream(&csInfo);
        ASSERT(STATUS_SUCCESS == status);

        csFile->BPStreamEntries = csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES;

        //
        // Delete the common store file if there are no references to it.
        //
        if (0 == csFile->BPStreamEntries) {

            status = SipDeleteCSFile(csFile);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh3: Can't delete csFile, %x\n", status);
            }

            ++deletedCSCount;
#endif
        } else if (csInfo.BPCountAdjusted < csInfo.BPCount) {

            //
            // Truncate the stream.  Both BPCountAdjusted
            // and BPCount are sector granular counts.
            //
            FILE_END_OF_FILE_INFORMATION    endOfFileInfo[1];

            ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

            endOfFileInfo->EndOfFile.QuadPart = csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER);

            status = SipSetInformationFile(
                        csFile->BackpointerStreamFileObject,
                        deviceExtension->DeviceObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        endOfFileInfo);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh3: Can't truncate csFile, %x\n", status);
            }
#endif
        }

SkipCSFile:
		SipReleaseBackpointerResource(csFile);
        SipDereferenceCSFile(csFile);
    }

#if DBG
    DbgPrint("SIS SipVCPhase3 processed %d common store files, deleted %d.\n", csFileCount, deletedCSCount);
#endif

    SipVCCloseFindFile(&FindInfo);
    return status;
}

VOID
SiVolumeCheckThreadStart(
    IN PVOID        context)
/*++

Routine Description:

    A thread to handle SIS volume check operations.  This thread is created to
    perform a volume check on one volume, and when it completes it terminates.
    It synchronizes with nothing.

Arguments:

    context - Pointer to the device extension needing the volume check.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION       deviceExtension = context;
    NTSTATUS                status;
    KIRQL                   OldIrql;
    OBJECT_ATTRIBUTES       Obja[1];
    IO_STATUS_BLOCK         Iosb[1];
    UNICODE_STRING          fileName;
    BOOLEAN                 verifiedAll;
    HANDLE                  vHandle = NULL;

	if (!SipCheckPhase2(deviceExtension)) {
		//
		// SIS can't initialize, so just give up.
		//
		SIS_MARK_POINT();

	    PsTerminateSystemThread(STATUS_SUCCESS);
	}

    //
    // Create the volume check indicator file in the common store directory
    // so that if we crash before we finish, we'll restart on next reboot.
    // (A file is preferred over a registry entry in case the volume is moved
    // before rebooting.)
    //
    fileName.MaximumLength = 
        deviceExtension->CommonStorePathname.Length
        + SIS_VOLCHECK_FILE_STRING_SIZE
        + sizeof(WCHAR);

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' siS');

    if (NULL != fileName.Buffer) {

        RtlCopyUnicodeString(&fileName, &deviceExtension->CommonStorePathname);
        RtlAppendUnicodeToString(&fileName, SIS_VOLCHECK_FILE_STRING);

        InitializeObjectAttributes(
                Obja,
                &fileName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

        status = ZwCreateFile(
                &vHandle,
                DELETE,
                Obja,
                Iosb,
                NULL,                   // Allocation size
                FILE_ATTRIBUTE_NORMAL,  // file attributes
                0,                      // share mode
                FILE_OPEN_IF,           // always create
                0,                      // create options
                NULL,                   // EA buffer
                0);                     // EA length

        ExFreePool(fileName.Buffer);

        if (!NT_SUCCESS(status)) {
            vHandle = NULL;
#if DBG
            DbgPrint("SIS SipCheckVolume unable to create indicator file, %s\n", status);
#endif
        }
    }

    //
    // Phase 1: Scan the Common Store directory.
    //

    status = SipVCPhase1(deviceExtension);

    //
    // Phase 2: Enumerate all SIS link files.
    //

    status = SipVCPhase2(deviceExtension, &verifiedAll);

    //
    // Turn off the no-delete flag.  During phase 1 & phase 2, the no-delete
    // flag prevented common store files from being deleted during normal
    // driver operation.  It is now safe (and is necessary) to turn this flag
    // off now.
    // The exlusive flag instructs SiCreate to acquire the backpointer
    // resource exclusive rather than shared, since it is likely that it
    // will have to write the backpointer back to the stream during a volume
    // check.
    //

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
    deviceExtension->Flags &= ~(SIP_EXTENSION_FLAG_VCHECK_NODELETE | SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE);
    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // Phase 3: Scan the Common Store directory again.
    //

    if (verifiedAll) {
        status = SipVCPhase3(deviceExtension);
    } else {
        
        // eventlog

#if DBG
        DbgPrint("SIS: Volume Check skipping CS delete phase\n");
#endif
    }

    //
    // Done.  Delete the volume check indicator file, turn off the volume check
    // enabled flag and terminate this thread.
    //
    if (vHandle) {
        FILE_DISPOSITION_INFORMATION disposition[1];

        disposition->DeleteFile = TRUE;

        status = ZwSetInformationFile(
                        vHandle,
                        Iosb,
                        disposition,
                        sizeof(FILE_DISPOSITION_INFORMATION),
                        FileDispositionInformation);
#if DBG
        if (STATUS_SUCCESS != status) {
            DbgPrint("SIS: SipCheckVolume can't delete indicator file, %x\n", status);
        }
#endif
        ZwClose(vHandle);
    }

    // eventlog

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);

    deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_VCHECK_PENDING;

    ASSERT((deviceExtension->Flags &
                (SIP_EXTENSION_FLAG_VCHECK_PENDING |
                 SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE |
                 SIP_EXTENSION_FLAG_VCHECK_NODELETE)) == 0);

    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

#if DBG
    DbgPrint("SIS: SipCheckVolume complete.\n");
#endif

    PsTerminateSystemThread(STATUS_SUCCESS);
}

NTSTATUS
SipCheckVolume(
    IN OUT PDEVICE_EXTENSION            deviceExtension)
/*++

Routine Description:

    Initiates a full volume check for the specified volume.  This call returns
    before the volume check completes.

Arguments:

    deviceExtension - the D.E. for the volume to be checked

Return Value:

    None.

--*/
{
    KIRQL                   OldIrql;
    ULONG                   fl;
    NTSTATUS                status;
    HANDLE                  threadHandle;
    OBJECT_ATTRIBUTES       oa;

    SIS_MARK_POINT();

    //
    // Indicate we're doing a volume check.
    //
    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);

    fl = deviceExtension->Flags;

    if ((fl & SIP_EXTENSION_FLAG_VCHECK_PENDING) == 0) {
        deviceExtension->Flags |= 
            SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE |
            SIP_EXTENSION_FLAG_VCHECK_PENDING |
            SIP_EXTENSION_FLAG_VCHECK_NODELETE;
    }

    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // If we're currenty running a volume check, do nothing.
    //
    if (fl & SIP_EXTENSION_FLAG_VCHECK_PENDING) {
        return STATUS_SUCCESS;
    }

#if DBG
    DbgPrint("SIS: SipCheckVolume starting.\n");
    if (BJBDebug & 0x00080000) {
        ASSERT(!"Volume Check");
    }
#endif

    //
    // Create a thread which will do the volume check and terminate when
    // it's complete.
    //
    InitializeObjectAttributes (&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    status = PsCreateSystemThread(
                    &threadHandle,
                    THREAD_ALL_ACCESS,
                    &oa,                // Object Attributes
                    NULL,               // Process (NULL => PsInitialSystemProcess)
                    NULL,               // Client ID
                    SiVolumeCheckThreadStart,
                    deviceExtension);   // context

    if (NT_SUCCESS (status)) {
       status = ZwClose (threadHandle);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siclnup.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siclnup.c

Abstract:

	Cleanup routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#endif	// ALLOC_PRAGMA


void
SipCheckOverwrite(
    IN PSIS_PER_FILE_OBJECT perFO,
    IN PSIS_SCB             scb,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine determines if the file has been completely overwritten,
    and if it has, it removes the SIS reparse point to convert the
    file back to non-SIS state.

Arguments:

    perFO - pointer to the file's perFO structure.

    scb - pointer to the primary scb of the perFO.

    DeviceObject - Pointer to this driver's device object.

Return Value:

    None.

--*/

{
    PSIS_PER_LINK           perLink;
    KIRQL                   OldIrql;
    NTSTATUS                status;

    perLink = scb->PerLink;

    //
    // If the file has been completely overwritten, remove the reparse point
    // now to avoid having to reopen the file later.
    //

    if ((perLink->Flags & (SIS_PER_LINK_DIRTY|
                           SIS_PER_LINK_BACKPOINTER_GONE|
						   SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|
                           SIS_PER_LINK_FINAL_COPY|
                           SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

        SIS_RANGE_STATE     rangeState;
        LONGLONG            rangeLength;
        BOOLEAN             foundRange;
        BOOLEAN             overwritten;
        PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

        SipAcquireScb(scb);

        if ((perLink->Flags & SIS_PER_LINK_OVERWRITTEN) ||
            scb->SizeBackedByUnderlyingFile == 0) {

            overwritten = TRUE;

        } else {

            foundRange = SipGetRangeEntry(
                            deviceExtension,
                            scb,
                            0,                      // starting offset
                            &rangeLength,
                            &rangeState);
            
            overwritten = foundRange &&
                          rangeState == Written &&
                          rangeLength >= scb->SizeBackedByUnderlyingFile;

        }

        SipReleaseScb(scb);

        if (overwritten) {

            BOOLEAN     tagRemoved = FALSE;
            BOOLEAN     wakeupNeeded;

            //
            // The file has been completely overwritten.  See if
            // another thread sneaked in and did final copy for us, or
			// deleted the file.
            //

            KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

            if ((perLink->Flags & (SIS_PER_LINK_DIRTY|
                                   SIS_PER_LINK_BACKPOINTER_GONE|
								   SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|
                                   SIS_PER_LINK_FINAL_COPY|
                                   SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

                perLink->Flags |= SIS_PER_LINK_OVERWRITTEN | SIS_PER_LINK_FINAL_COPY;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

            } else {

				//
				// Someone else has already dealt with this file.  Just mark it overwritten so that
				// we won't have to check ranges in the future and punt.
				//

                perLink->Flags |= SIS_PER_LINK_OVERWRITTEN;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                return;

            }

            //
            // Prepare to change the CS file reference count.  We need to do this
            // before we can delete the reparse point.
            //
            status = SipPrepareCSRefcountChange(
						perLink->CsFile,
						&perLink->Index,
						&perLink->LinkFileNtfsId,
						SIS_REFCOUNT_UPDATE_LINK_DELETED);

            //
            // Abort if the prepare failed.
            //

            if (NT_SUCCESS(status)) {

                PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
                UCHAR                   ReparseBuffer[SIS_REPARSE_DATA_SIZE];

                //
                // Now, delete the reparse point.  We need to set the "can ignore" flag
                // in the per-link first so that any creates that happen once we delete the
                // reparse point don't cause problems later on.
                //

                ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
                ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SIS;
                ReparseBufferHeader->ReparseDataLength = 0;
                ReparseBufferHeader->Reserved = 0xcabd; // ???

                SIS_MARK_POINT_ULONG(scb);

                status = SipFsControlFile(
                            perFO->fileObject,
                            deviceExtension->DeviceObject,
                            FSCTL_DELETE_REPARSE_POINT,
                            ReparseBuffer,
                            FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
                            NULL,									// output buffer
                            0,										// output buffer length
							NULL);									// returned output buffer length

                ASSERT(status != STATUS_PENDING);

                if (NT_SUCCESS(status)) {
                    tagRemoved = TRUE;

                }
        #if     DBG
                if (!tagRemoved) {
                    SIS_MARK_POINT_ULONG(status);
					if ((!(perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE)) && (STATUS_NOT_A_REPARSE_POINT != status)) {
	                    DbgPrint("SIS: SipCheckOverwrite: FSCTL_DELETE_REPARSE_POINT failed %x%s pl %x fo %x\n",
    	                    status, (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? " (Deleted)" : "", perLink, perFO->fileObject);
					}
                }
        #endif

				SIS_MARK_POINT_ULONG(perLink->CsFile);

                status = SipCompleteCSRefcountChange(
							perLink,
							&perLink->Index,
							perLink->CsFile,
							tagRemoved,
							FALSE);

                if (!NT_SUCCESS(status)) {
                    SIS_MARK_POINT_ULONG(status);
        #if     DBG
                    DbgPrint("SIS: SipCheckOverwrite: complete failed 0x%x\n",status);
        #endif  // DBG
                }

                SIS_MARK_POINT_ULONG(tagRemoved);

            } else {

                //
                // The prepare failed--abort.
                //
                SIS_MARK_POINT_ULONG(status);

        #if     DBG
                DbgPrint("SIS: SipCheckOverwrite: prepare failed 0x%x\n",status);
        #endif  // DBG

            }

            //
            // Wake up any threads that are waiting on us.
            //

            KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

            wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) != 0;

            if (tagRemoved) {

        #if     DBG
                //DbgPrint("SIS: SipCheckOverwrite: FinalCopy performed, pl %x fo %x scb %x\n", perLink, perFO->fileObject, scb);
        #endif  // DBG

                perLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
            }

            perLink->Flags &= ~(SIS_PER_LINK_FINAL_COPY_WAITERS|SIS_PER_LINK_FINAL_COPY);

            KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

            if (wakeupNeeded) {
                KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
            }

        }

    }

}


NTSTATUS
SiCleanupCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	IRP completion routine for SiCleanup for SIS files in certain circumstances.
	Re-synchronizes with the calling thread by clearing PendingReturned and setting
	an event.

Arguments:

    DeviceObject - Pointer to this driver's device object.

	Irp			 - The IRP that's completing

	Context		 - pointer to the event to set to indicate completion

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT			event = (PKEVENT)Context;

    UNREFERENCED_PARAMETER( DeviceObject );

	//
	// We're re-syncing with the calling site, so clear PendingReturned.
	//
	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

#if		DBG
	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		DbgPrint("SIS: SiCleanupCompletion: cleanup failed 0x%x\n",Irp->IoStatus.Status);
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
	}
#endif	// DBG

	return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
SiCleanup(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp
	)
/*++

Routine Description:

	General SIS Irp dispatch routine for cleanup irps.  For SIS files, handle stuff like
	lock cleanup and delete processing.  If this is the last handle to the file (ie.,
	cleanup count is 0) then deal with delete processing, and if appropriate kick off a
	final copy.

Arguments:

    DeviceObject - Pointer to this driver's device object.

	Irp			 - The cleanup IRP

Return Value:

	status of the cleanup returned from NTFS

--*/
{
	PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT 				fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT 		perFO;
	PSIS_SCB					scb;
	NTSTATUS 					status;
	PIO_STACK_LOCATION			nextIrpSp;
	PDEVICE_EXTENSION			deviceExtension = DeviceObject->DeviceExtension;
	LONG						uncleanCount;
	KIRQL						OldIrql;
	BOOLEAN						uncleanup;
	BOOLEAN						deleteOnClose;
	BOOLEAN						deletingFile;
	BOOLEAN						finalCopyDone;
	PSIS_PER_LINK				perLink;
	BOOLEAN 					dirty;
	BOOLEAN						abortDelete;
	KEVENT						event[1];
	BOOLEAN						prepared;
	BOOLEAN						startFinalCopy;
	BOOLEAN						anythingInCopiedFile;

    //
    //  The control device object can't be opened
    //

    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindAny,&perFO,&scb)) {
        return SiPassThrough(DeviceObject,Irp);
	}

	perLink = scb->PerLink;

	nextIrpSp = IoGetNextIrpStackLocation(Irp);

	SIS_MARK_POINT_ULONG(scb);
	SIS_MARK_POINT_ULONG(perFO);

    //
    // If the file has been completely overwritten, convert it back to a
    // non-SIS file now.
    //

    SipCheckOverwrite(perFO, scb, DeviceObject);

	SipAcquireScb(scb);

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

	uncleanup = (perFO->Flags & SIS_PER_FO_UNCLEANUP) ? TRUE : FALSE;
	deleteOnClose = (perFO->Flags & SIS_PER_FO_DELETE_ON_CLOSE) ? TRUE : FALSE;
#if		DBG
	//
	// Assert that we're not seeing two cleanups on the same file object.
	//
	ASSERT(!uncleanup || !(perFO->Flags & SIS_PER_FO_CLEANED_UP));
	perFO->Flags |= SIS_PER_FO_CLEANED_UP;
#endif	// DBG

	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

#if		DBG
	if (BJBDebug & 0x20) {
		DbgPrint("SIS: SipCommonCleanup: scb %p, uncleanup %d, uncleancount %d\n",scb,uncleanup,perFO->fc->UncleanCount);
	}
#endif	// DBG

	if (!uncleanup) {
		//
		// We're seeing a cleanup on a file object for which we didn't see a
		// corresponding create.  This most often happens during stress when someone
		// opens a file that's in the process of being created/turned into a SIS
		// link by copyfile.  Even though copyfile opens the files exclusively,
		// it's possible to open them if the user asks for no permission, and then
		// the file object created by copyfile will show up here.  This is benign.
		//
		SipReleaseScb(scb);

#if		DBG
		if (BJBDebug & 0x40000) {
			DbgPrint("SIS: SipCommonCleanup: ignoring cleanup on unexpected file object %p\n",fileObject);
		}
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);
		SIS_MARK_POINT_ULONG(fileObject);
		SIS_MARK_POINT_ULONG(perFO);
		return SiPassThrough(DeviceObject,Irp);
	}
	SipReleaseScb(scb);

	//  Unlock all outstanding file locks.
			
	(VOID) FsRtlFastUnlockAll( &scb->FileLock,
							   fileObject,
							   IoGetRequestorProcess( Irp ),
							   NULL );
	SipAcquireScb(scb);

	// GCH: To do: Make sure all cleanups come through here.
    uncleanCount = InterlockedDecrement(&perFO->fc->UncleanCount);

	ASSERT(uncleanCount >= 0);

	if (uncleanCount == 0) {

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		deletingFile = ((perLink->Flags & SIS_PER_LINK_DELETE_DISPOSITION_SET) ? TRUE : FALSE) || deleteOnClose;
		dirty = (perLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
		finalCopyDone = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		anythingInCopiedFile = (scb->Flags & SIS_SCB_ANYTHING_IN_COPIED_FILE) ? TRUE : FALSE;

		SipReleaseScb(scb);

		if (deletingFile) {
			status = SipPrepareCSRefcountChange(
						perLink->CsFile,
						&perLink->Index,
						&perLink->LinkFileNtfsId,
						SIS_REFCOUNT_UPDATE_LINK_DELETED);

			prepared = NT_SUCCESS(status);

			SIS_MARK_POINT_ULONG(status);
			//
			// Mark the link as FINAL_DELETE_IN_PROGRESS, which will prevent
			// the file from being opened (causing it to fail with 
			// STATUS_ACCESS_DENIED).  We need to do this after the
			// prepare in order to properly serialize with supersede/overwrite
			// creates.  Also, if the DELETED flag is already set, then the file
			// was probably destroyed by overwrite/supersede, and so we'll just abort
			// the refcount change.
			//
			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			if (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) {
				abortDelete = TRUE;
			} else {
				abortDelete = FALSE;
				perLink->Flags |= SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS;
			}
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (abortDelete) {
				SIS_MARK_POINT_ULONG(scb);
#if DBG && 0
	            DbgPrint("SipCommonCleanup: aborting refcount change, fileObject @ 0x%x, %0.*ws\n",
				            irpSp->FileObject,
				            irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

				if (prepared) {
					SipCompleteCSRefcountChange(
						perLink,
						&perLink->Index,
						perLink->CsFile,
						FALSE,
						FALSE);
				}
				deletingFile = FALSE;
			}
		} else {
			if (anythingInCopiedFile && !dirty) {
				//
				// We might have user mapped writes to the file.  Flush it and recheck to see if it's dirty.
				//
				SipFlushBuffersFile(fileObject,DeviceObject);

				KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
				dirty = (perLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
				KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			}
		}
	} else {
		SipReleaseScb(scb);
		deletingFile = FALSE;
	}

	//
	// Now send the cleanup down to NTFS.  
	//
	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

	if (deletingFile || ((0 == uncleanCount) && dirty && !finalCopyDone)) {

		KeInitializeEvent(event,NotificationEvent,FALSE);

		IoSetCompletionRoutine(
			Irp,
			SiCleanupCompletion,
			event,
			TRUE,
			TRUE,
			TRUE);

		status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);
		}

		if (deletingFile && prepared) {

			SIS_MARK_POINT_ULONG(perLink->CsFile);

			//
			// Cover for a race with create where we think the file is gone but NTFS doesn't
			// because it saw a new create before the final cleanup came down.  By setting this
			// bit, create will just fail rather than letting the underlying file get opened.
			//

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			perLink->Flags |= SIS_PER_LINK_FILE_DELETED;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			

			status = SipCompleteCSRefcountChange(
						perLink,
						&perLink->Index,
						perLink->CsFile,
						TRUE,
						FALSE);

			SIS_MARK_POINT_ULONG(status);
		} else if ((0 == uncleanCount) && dirty && !finalCopyDone) {
			//
			// Kick off a final copy.
			//
			SIS_MARK_POINT_ULONG(scb);

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			//
			// Check to see if it's already entered (or finished) final copy.  We need to recheck
			// here because someone could have gotten in since we checked finalCopyDone above.
			//
			if (perLink->Flags & (SIS_PER_LINK_FINAL_COPY|SIS_PER_LINK_FINAL_COPY_DONE)) {
				startFinalCopy = FALSE;
			} else {
				startFinalCopy = TRUE;
				perLink->Flags |= SIS_PER_LINK_FINAL_COPY;
			} 
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (startFinalCopy) {
				SipReferenceScb(scb, RefsFinalCopy);
				SipCompleteCopy(scb,TRUE);
			}
		}

		status = Irp->IoStatus.Status;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return status;
	} else {
		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		status = IoCallDriver(deviceExtension->AttachedToDeviceObject,Irp);
#if		DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SiCleanup: cleanup failed in ntfs 0x%x, perFO 0x%x, scb 0x%x\n",status,perFO,scb);
			SIS_MARK_POINT_ULONG(status);
		}
#endif	// DBG
		return status;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siinfo.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siinfo.c

Abstract:

	Set/Query info routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// The parameters for a SipRenameOverCheck call.
//
// 

typedef struct _SIS_CHECK_OVERWRITE_REQUEST {

	//
	// The WORK_QUEUE_ITEM needed to get the request posted.
	//
	WORK_QUEUE_ITEM					workItem[1];

	//
	// An event to set to signify completion
	//
	KEVENT							event[1];

	//
	// The per link for the target file.
	//
	PSIS_PER_LINK					perLink;

	//
	// The file ID for the target file.
	//
	PFILE_INTERNAL_INFORMATION		internalInfo;

	//
	// The DeviceObject on which we were called.
	//
	PDEVICE_OBJECT					DeviceObject;

	//
	// The thread that called SipPrepareCSRefcountChange
	//
	ERESOURCE_THREAD				thread;

} SIS_CHECK_OVERWRITE_REQUEST, *PSIS_CHECK_OVERWRITE_REQUEST;

VOID
SipRenameOverCheck(
	PVOID					parameter)
/*++

Routine Description:

	Someone did a replace-if-exists NtSetInformationFile call, the target was
	a SIS link, and NTFS completed the request successfully.  The caller posted
	to a worker thread to make the final determination if the file is really
	gone, and this function is the worker routine that makes that check.

	We open the target SIS file by ID, and if it's still there we check to see
	if it's still the same SIS file.  If it is, we abort the refcount update,
	otherwise we complete it.

Arguments:

	parameter	- a PSIS_CHECK_OVERWRITE_REQUEST.  See the structure definition for
					a description of the fields.

Return Value:

	void

--*/
{
	PSIS_CHECK_OVERWRITE_REQUEST	checkRequest = parameter;
	PDEVICE_OBJECT					DeviceObject = checkRequest->DeviceObject;
	PDEVICE_EXTENSION				deviceExtension = DeviceObject->DeviceExtension;
	IO_STATUS_BLOCK					Iosb[1];
	NTSTATUS						status;
	OBJECT_ATTRIBUTES				Obja[1];
	UNICODE_STRING					fileIdString[1];
	HANDLE							dstFileHandle = NULL;
	PFILE_OBJECT					dstFileObject = NULL;
	BOOLEAN							fileGone = FALSE;
	PSIS_PER_FILE_OBJECT			perFO;
	PSIS_SCB						scb;
	KIRQL							OldIrql;

	fileIdString->Length = fileIdString->MaximumLength = sizeof(LARGE_INTEGER);
	fileIdString->Buffer = (PWCHAR)&checkRequest->internalInfo->IndexNumber;

	InitializeObjectAttributes(
				Obja,
				fileIdString,
				OBJ_CASE_INSENSITIVE,
				deviceExtension->GrovelerFileHandle,
				NULL);

	status = NtCreateFile(
				&dstFileHandle,
				0,
				Obja,
				Iosb,
				NULL,					// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | 
					FILE_SHARE_WRITE | 
					FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,					// EA buffer
				0);						// EA length

	if (!NT_SUCCESS(status)) {
		//
		// We couldn't open the file.  open-by-id creates fail with invalid parameter
		// when there is no file with that id.  If that's what happened, then the file's
		// gone and we can delete the backpointer.  If it failed for some other reason,
		// then we'll err on the side of conservatism and leave it be.
		//

		SIS_MARK_POINT_ULONG(status);

		if ((STATUS_INVALID_PARAMETER == status) || 
			(STATUS_OBJECT_NAME_NOT_FOUND == status) ||
			(STATUS_OBJECT_PATH_NOT_FOUND == status)) {
			fileGone = TRUE;
		}

		goto done;
	}

	//
	// We opened a file with the right file ID.  See if it's still a SIS file.
	//

	status = ObReferenceObjectByHandle(
				dstFileHandle,
				0,
				*IoFileObjectType,
				KernelMode,
				&dstFileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		//
		// The file's there, but for some reason we can't access the file object.
		// Be conservative and assume that it's still the link.
		//
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	if (!SipIsFileObjectSIS(dstFileObject, DeviceObject, FindActive, &perFO, &scb)) {
		//
		// The file exists, but it's not a SIS file.
		//
		SIS_MARK_POINT();
		fileGone = TRUE;

		goto done;
	}

	//
	// The file exists, and it's a SIS file.  See if it's a reference to the same file,
	// or to a different one.  We don't have to worry about it's being a new reference to the
	// same file, because we hold the refcount update resource for the common store file.
	//

	if (scb->PerLink != checkRequest->perLink) {
		SIS_MARK_POINT();
		fileGone = TRUE;
	} else {
		//
		// It's still there.  Presumably someone renamed it before the rename that we're
		// tracking could blow it away.
		//
	}

done:

	SIS_MARK_POINT_ULONG(checkRequest->perLink->CsFile);

	if (fileGone) {
		KeAcquireSpinLock(checkRequest->perLink->SpinLock, &OldIrql);
		checkRequest->perLink->Flags |= SIS_PER_LINK_FILE_DELETED;
		KeReleaseSpinLock(checkRequest->perLink->SpinLock, OldIrql);
		
	}

	SipCompleteCSRefcountChangeForThread(
		checkRequest->perLink,
		&checkRequest->perLink->Index,
		checkRequest->perLink->CsFile,
		fileGone,
		FALSE,
		checkRequest->thread);

	SipDereferencePerLink(checkRequest->perLink);

	if (NULL != dstFileObject) {
		ObDereferenceObject(dstFileObject);
	}

	if (NULL != dstFileHandle) {
		NtClose(dstFileHandle);
	}

	KeSetEvent(checkRequest->event, IO_NO_INCREMENT, FALSE);

	return;
}

NTSTATUS
SiRenameOverCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				context)
/*++

Routine Description:

	An IRP completion routine for a rename call with a SIS link as a target.
	This function just resynchronizes with the calling thread by clearing
	PendingReturned and setting an event.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing rename request.


Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT					event = (PKEVENT)context;

    UNREFERENCED_PARAMETER( DeviceObject );

	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipReplaceIfExistsRename(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp)
/*++

Routine Description:

	Someone did a replace-if-exists NtSetInformationFile call.  We need to
	figure out if the target is a SIS link, and if so remove the backpointer
	for the file.  This function does about half of the work, and then posts
	to a worker thread (SipRenameOverCheck) to do the final check to see if 
	the SIS file was really overwritten.

	It is the responsibility of this function to complete the irp.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing rename request.


Return Value:

	The status of the request

--*/
{
	HANDLE						dstFileHandle = NULL;
	OBJECT_ATTRIBUTES			Obja[1];
	PFILE_RENAME_INFORMATION	renameInfo = Irp->AssociatedIrp.SystemBuffer;
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION			nextIrpSp;
	UNICODE_STRING				dstFileName[1];
	NTSTATUS					status;
	IO_STATUS_BLOCK				Iosb[1];
	PFILE_OBJECT				dstFileObject = NULL;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_SCB					scb;
	FILE_INTERNAL_INFORMATION	internalInfo[1];
	PSIS_PER_LINK				perLink;
	KEVENT						event[1];
	SIS_CHECK_OVERWRITE_REQUEST	checkRequest[1];
	PDEVICE_EXTENSION			deviceExtension = DeviceObject->DeviceExtension;

	ASSERT(IRP_MJ_SET_INFORMATION == irpSp->MajorFunction);
	ASSERT(renameInfo->ReplaceIfExists);

	//
	// The basic strategy here is similar to what we do in the overwrite/supersede open
	// case: we figure out if the file is a SIS file, and if so which one, let the
	// rename proceed and then see if the suspected target is gone.  Like overwrite/supersede,
	// we're subject to a race in the case where someone renames a SIS link under the
	// destination after we do our local check.  If that race goes the wrong way, we'll
	// lose the refcount decrement.  This won't ever result in user data loss, but we
	// won't be able to reclaim the common store file until we do a volume check.  C'est la vie.
	//

	//
	// The first step is to open the target file and see if it is a SIS link.
	//

	//
	// We have to be careful in dealing with the string lengths in the renameInfo buffer,
	// because they have not been checked anywhere.
	//

	if (renameInfo->FileNameLength + FIELD_OFFSET(FILE_RENAME_INFORMATION,FileName) > 
			irpSp->Parameters.SetFile.Length) {
		//
		// It's bogus, just let NTFS deal with it.
		//
		SIS_MARK_POINT();

		goto PassThrough;
	}

	//
	// The length is OK, so build up an object attributes for this file.
	//
	dstFileName->Length = (USHORT)renameInfo->FileNameLength;
	dstFileName->MaximumLength = (USHORT)renameInfo->FileNameLength;
	dstFileName->Buffer = renameInfo->FileName;

	InitializeObjectAttributes(
				Obja,
				dstFileName,
				OBJ_CASE_INSENSITIVE,
				renameInfo->RootDirectory,
				NULL);

	//
	// Open the file.  It's somewhat unusual to open a file with kernel privs in the
	// user context, but it's OK in this case for the following reasons:
	//		1) We're opening the file for no access, so the user can't do anything
	//		   aisde from close the handle.
	//		2) If the user does close the handle before we reference it, the worst
	// 		   that happens is that we miss the loss of a SIS link, which could happen
	//		   via the rename race anyway.
	//

	status = ZwCreateFile(
				&dstFileHandle,
				0,						// desired access; avoid sharing violations
				Obja,
				Iosb,
				NULL,					// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | 
					FILE_SHARE_WRITE | 
					FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,					// EA buffer
				0);						// EA length

	if (!NT_SUCCESS(status)) {
		//
		// For whatever reason, we couldn't open the file.  It probably doesn't exist.
		// Just pass the request through.
		//
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	status = ObReferenceObjectByHandle(
				dstFileHandle,
				0,
				*IoFileObjectType,
				KernelMode,
				&dstFileObject,
				NULL);					// handle info

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	//
	// See if this file is on the same device as we're being called on.
	//
	if (IoGetRelatedDeviceObject(dstFileObject) !=
		IoGetRelatedDeviceObject(irpSp->FileObject)) {

		//
		// They're not.  This call will most likely fail in NTFS since cross-volume
		// renames aren't supported at the NT interface level.  We'll just pass it
		// through.
		//

		SIS_MARK_POINT();
		goto PassThrough;
	}

	if (!SipCheckPhase2(deviceExtension)) {
		SIS_MARK_POINT();
		goto PassThrough;
	}

	if (!SipIsFileObjectSIS(dstFileObject, DeviceObject, FindActive, &perFO, &scb)) {
		//
		// It exists, but it's not a SIS file object.  Pass through.
		//
		SIS_MARK_POINT();

		goto PassThrough;
	}

	perLink = scb->PerLink;

	//
	// This is a rename-over with a destination that's a SIS file object.  Get the file
	// id of the destination file, prepare a refcount change, and close our handle to the
	// file.
	//

	status = SipQueryInformationFile(
				dstFileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);								// returnedLength

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	status = SipPrepareCSRefcountChange(
				perLink->CsFile,
				&perLink->Index,
				&internalInfo->IndexNumber,
				SIS_REFCOUNT_UPDATE_LINK_DELETED);		// rename-over destroys the destination file ID, so it's DELETED, not OVERWRITTEN

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	SipReferencePerLink(perLink);

	ObDereferenceObject(dstFileObject);
	ZwClose(dstFileHandle);

	dstFileObject = NULL;
	dstFileHandle = NULL;

	//
	// Now call NTFS and resynchronize with the irp when it completes.
	//

	KeInitializeEvent(event,NotificationEvent,FALSE);

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));
				
	IoSetCompletionRoutine(	Irp,
							SiRenameOverCompletion,
							event,
							TRUE,
							TRUE,
							TRUE);

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	if (STATUS_PENDING == status) {
		KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
	}

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// It failed, so the SIS link target wasn't destroyed.
		//
		SIS_MARK_POINT_ULONG(status);

		goto NoOverwrite;
	}

	//
	// The rename completed successfully.  See if the destination file is still there.
	// Unfortunately, we have to post to do this, because we can't open the file by
	// name, lest someone rename it away from the rename-over that just completed (this
	// is a different race than the one that's left open, and would cause the backpointer
	// to go away when the file still exists, which is a much worse problem).  In order
	// to open it by ID, we need a handle to a file on this volume, which we have in the
	// device extension, but it's in the system process context.
	//
	// We need to take an extra reference to the PerLink before handing off to the
	// worker thread.  This is because we need to call SipHandoffBackpointerResource
	// after posting our work request, but in posting the work request we lose our
	// original reference to the per link, so there's no way to guarantee that the
	// csfile still exists after the post happens.
	//

	SipReferencePerLink(perLink);

	KeInitializeEvent(checkRequest->event, NotificationEvent, FALSE);
	checkRequest->perLink = perLink;
	checkRequest->internalInfo = internalInfo;
	checkRequest->DeviceObject = DeviceObject;
	checkRequest->thread = ExGetCurrentResourceThread();

	ExInitializeWorkItem(
		checkRequest->workItem,
		SipRenameOverCheck,
		checkRequest);

	ExQueueWorkItem(
		checkRequest->workItem,
		CriticalWorkQueue);

	//
	// The worker thread now will complete the refcount change, so we
	// need to say that we've handed off, and also drop the extra perLink
	// reference that we took.
	//

	SipHandoffBackpointerResource(perLink->CsFile);
	SipDereferencePerLink(perLink);

	KeWaitForSingleObject(checkRequest->event, Executive, KernelMode, FALSE, NULL);

	//
	// Now it's all done, just complete the irp.
	//

	status = Irp->IoStatus.Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;


PassThrough:

	//
	// Something went wrong (or this just isn't a SIS file or doesn't exist or whatever).
	// Clean up and pass the request down.
	//

	if (NULL != dstFileObject) {
		ObDereferenceObject(dstFileObject);
	}

	if (NULL != dstFileHandle) {
		ZwClose(dstFileHandle);
	}

	SipDirectPassThroughAndReturn(DeviceObject, Irp);

NoOverwrite:

	//
	// We got far enough to prepare the refcount change, but have decided that the
	// file wasn't overwritten.  Get out.  Note that we need to complete the irp
	// ourselves here, because we've already called into NTFS and stopped the
	// irp completion processing.
	//

	SipCompleteCSRefcountChange(
		perLink,
		&perLink->Index,
		perLink->CsFile,
		FALSE,
		FALSE);

	SipDereferencePerLink(perLink);

	status = Irp->IoStatus.Status;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	ASSERT(NULL == dstFileObject);
	ASSERT(NULL == dstFileHandle);

	return status;
				
}

NTSTATUS
SiDeleteCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
{
	PSIS_PER_LINK	 				perLink = (PSIS_PER_LINK)Context;
	KIRQL							OldIrql;
	PFILE_DISPOSITION_INFORMATION	disposition;

    UNREFERENCED_PARAMETER( DeviceObject );

	if (Irp->PendingReturned) {
		IoMarkIrpPending(Irp);
	}

	disposition = Irp->AssociatedIrp.SystemBuffer;
	ASSERT(NULL != disposition);

    // We just sent a delete setInformation call down to the link file.  If it worked,
	// we need to decrement the reference count on the underlying CS file (the file, not
	// the SIS_CS_FILE object).

	SIS_MARK_POINT_ULONG(perLink);

	if (NT_SUCCESS(Irp->IoStatus.Status)) {

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

		if (disposition->DeleteFile) {
			perLink->Flags |= SIS_PER_LINK_DELETE_DISPOSITION_SET;
		} else {
			perLink->Flags &= ~SIS_PER_LINK_DELETE_DISPOSITION_SET;
		}

		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

	} 

	SipEndDeleteModificationOperation(perLink,disposition->DeleteFile);

	SIS_MARK_POINT_ULONG(perLink);
	return STATUS_SUCCESS;
}

NTSTATUS
SiSetEofCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A SetFileInformation with class FileEndOfFileInformation has completed.
	We hold the scb for this file.  Release it.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the set EOF request.

    Context - Context parameter, a PSI_SET_EOF_COMPLETION_CONTEXT.

Return Value:

    The function value for this routine is always success.

--*/
{
	PIO_STACK_LOCATION				irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT					fileObject;
	PSIS_SCB						scb = (PSIS_SCB)Context;
	PFILE_END_OF_FILE_INFORMATION	eofInfo;
	LONGLONG						newLength;
	KIRQL							OldIrql;

    UNREFERENCED_PARAMETER( DeviceObject );

	fileObject = irpSp->FileObject;
	eofInfo = Irp->AssociatedIrp.SystemBuffer;
	ASSERT(eofInfo);
	newLength = eofInfo->EndOfFile.QuadPart;

	SipAcquireScb(scb);

	//
	// If the set EOF succeeded, update our internal data structures to
	// record the new file length.
	//
	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		ASSERT(Irp->IoStatus.Status != STATUS_PENDING);

		if (newLength != scb->SizeBackedByUnderlyingFile) {
			//
			// This call set the length to something other than the size of the
			// underlying file, which means that the file is now dirty.  Indicate so.
			//
			PSIS_PER_LINK perLink = scb->PerLink;

			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			perLink->Flags |= SIS_PER_LINK_DIRTY;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);
		}

		if (newLength < scb->SizeBackedByUnderlyingFile) {

			//
			// This truncated the file.  
			//
			SipTruncateScb(scb,newLength);

		}

	} 

	SipReleaseScb(scb);

    //
    // Propogate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;
}

NTSTATUS
SiSetInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	This is invoked on all NtSetInformationFile calls.  We need to catch delete requests for files in
	the common store, which need to be turned into delete requests for the links (and also result in
	decrementing the ref count for the common store object, possibly deleting that as well.)  All other
	set information calls are handled by the normal parts of the driver stack.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the set file information request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation( Irp );
	PDEVICE_EXTENSION 		deviceExtension;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
    FILE_INFORMATION_CLASS 	FileInformationClass;
	NTSTATUS 				status;
	PSIS_SCB				scb;
	PSIS_PER_FILE_OBJECT	perFO;
	PIO_STACK_LOCATION		nextIrpSp;

	SipHandleControlDeviceObject(DeviceObject, Irp);

    FileInformationClass = irpSp->Parameters.SetFile.FileInformationClass;

	if (FileRenameInformation == FileInformationClass) {
		//
		// We need to deal with the case where the target of a rename replace-if-exists
		// is a SIS link.  So, regardless of what type of file the source is, if this
		// rename has replace-if-exists set, we have to deal with it.
		//

		PFILE_RENAME_INFORMATION	fileRenameInfo = Irp->AssociatedIrp.SystemBuffer;

		if (fileRenameInfo->ReplaceIfExists) {
			//
			// This is a replace-if-exists rename request.  Let our special code handle it.
			// 

			return SipReplaceIfExistsRename(DeviceObject, Irp);
		}
	}

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		// This isn't a SIS file, just pass the call through to NTFS

		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	ASSERT(scb);
	
	SIS_MARK_POINT_ULONG(FileInformationClass);
	SIS_MARK_POINT_ULONG(scb);
	
	switch (FileInformationClass) {

		case FileLinkInformation: {
			//
			// Don't allow hard links to SIS files.
			//
			status = STATUS_OBJECT_TYPE_MISMATCH;

			SIS_MARK_POINT();
			
			Irp->IoStatus.Status = status;
			Irp->IoStatus.Information = 0;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);

			SIS_MARK_POINT();
			return status;
		}

		case  FileDispositionInformation: {
			PFILE_DISPOSITION_INFORMATION 	disposition;
			PSIS_PER_LINK 					perLink;

			perLink = scb->PerLink;

			disposition = Irp->AssociatedIrp.SystemBuffer;

			SipBeginDeleteModificationOperation(perLink, disposition->DeleteFile);

			//
			// Send the delete irp down on the link/copied file.
			//
			nextIrpSp = IoGetNextIrpStackLocation( Irp );
			RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));
				
			IoSetCompletionRoutine(	Irp,
									SiDeleteCompletion,
									perLink,
									TRUE,
									TRUE,
									TRUE);

			SIS_MARK_POINT_ULONG(scb);
			status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
			return status;
		}

		case FilePositionInformation: {
				PFILE_POSITION_INFORMATION 		position = Irp->AssociatedIrp.SystemBuffer;
				
				
		        //
        		//  Check if the file uses intermediate buffering.  If it does
		        //  then the new position we're supplied must be aligned properly 
				//  for the device
		        //
				if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)
					&& position->CurrentByteOffset.LowPart % deviceExtension->FilesystemVolumeSectorSize) {

					status = STATUS_INVALID_PARAMETER;
				} else {
					//
					// Just set the offset, regardless of whether it's beyond EOF.
					//
					fileObject->CurrentByteOffset = position->CurrentByteOffset;
					status = STATUS_SUCCESS;
				}

				Irp->IoStatus.Status = status;
				Irp->IoStatus.Information = 0;
				IoCompleteRequest(Irp, IO_NO_INCREMENT);

				SIS_MARK_POINT();
				return status;
		}

		case FileEndOfFileInformation: {
				PFILE_END_OF_FILE_INFORMATION	endOfFile = Irp->AssociatedIrp.SystemBuffer;

				SIS_MARK_POINT_ULONG(endOfFile->EndOfFile.LowPart);

#if		DBG
				if (BJBDebug & 0x10000) {
					DbgPrint("SIS: SiSetInfo: set EOF information scb %p, AO %d, eof.lp 0x%x\n",
								scb,irpSp->Parameters.SetFile.AdvanceOnly,endOfFile->EndOfFile.LowPart);
				}
#endif	// DBG

				if (irpSp->Parameters.SetFile.AdvanceOnly) {
					//
					// This is the lazywriter advancing valid data length, so it's guaranteed
					// not to truncate the file, so we don't need to pay attention to it.
					// Just pass it down to NTFS unattended.
					//
					SIS_MARK_POINT_ULONG(scb);
					SipDirectPassThroughAndReturn(DeviceObject,Irp);
				}

				nextIrpSp = IoGetNextIrpStackLocation(Irp);
				RtlMoveMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

				//
				// We've completed the copy on write.  Pass the call down on the copied file object.
				// Hold the Scb while the call goes down, and release it in the completion routine.
				//

				IoSetCompletionRoutine(
					Irp,
					SiSetEofCompletion,
					scb,
					TRUE,
					TRUE,
					TRUE);

				return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
		}

		default: {
			// Just pass it down

			SIS_MARK_POINT();
			SipDirectPassThroughAndReturn(DeviceObject, Irp);
		}
	}

	/*NOTREACHED*/
	ASSERT(FALSE && "NOTREACHED");
	SIS_MARK_POINT();
	SipDirectPassThroughAndReturn(DeviceObject, Irp);

}

NTSTATUS
SiQueryBasicInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileBasicInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query basic information
			request.

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_BASIC_INFORMATION basicInfo = (PFILE_BASIC_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != basicInfo);

	SIS_MARK_POINT_ULONG(Irp);

	basicInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);
	
	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == basicInfo->FileAttributes) {
		basicInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryAllInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileAllInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query all information
			request

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_ALL_INFORMATION allInfo = (PFILE_ALL_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != allInfo);

	SIS_MARK_POINT_ULONG(Irp);

	allInfo->BasicInformation.FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == allInfo->BasicInformation.FileAttributes) {
		allInfo->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryNetworkOpenInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileNetworkOpenInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query network open information
			request

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_NETWORK_OPEN_INFORMATION netOpenInfo = (PFILE_NETWORK_OPEN_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != netOpenInfo);

	SIS_MARK_POINT_ULONG(Irp);

	netOpenInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == netOpenInfo->FileAttributes) {
		netOpenInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryAttributeTagInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileAttributeTagInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags, and set
	the reparse tag as if it were not a reparse point.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query attribute tag request.

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_ATTRIBUTE_TAG_INFORMATION attributeTagInfo = (PFILE_ATTRIBUTE_TAG_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != attributeTagInfo);

	SIS_MARK_POINT_ULONG(Irp);

	attributeTagInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);
	attributeTagInfo->ReparseTag = IO_REPARSE_TAG_RESERVED_ZERO;

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == attributeTagInfo->FileAttributes) {
		attributeTagInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	The top level entry point for a query information irp.  We do special
	processing for a few of these, check to see if it's one and dispatch
	appropriately.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query request.

Return Value:

	status of the request, typically returned from NTFS

--*/
{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation( Irp );
	PIO_STACK_LOCATION		nextIrpSp;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PIO_COMPLETION_ROUTINE	completionRoutine;
	KIRQL					OldIrql;
	BOOLEAN					openedAsReparsePoint;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;
	
	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,NULL)) {
		// This isn't a SIS file, just pass the call through to NTFS
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
	openedAsReparsePoint = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	if (openedAsReparsePoint) {
		//
		// This was opened as a reparse point, so let the user see the real truth.
		//
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT_ULONG(irpSp->Parameters.QueryFile.FileInformationClass);
	SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);

#if		DBG
	if (BJBDebug & 0x10) {
		DbgPrint("SIS: SiQueryInfo: InformationClass %d\n",
			 irpSp->Parameters.QueryFile.FileInformationClass);
	}
#endif	// DBG

	// Handle the request.
	//
	switch (irpSp->Parameters.QueryFile.FileInformationClass) {

	case FileDirectoryInformation:						// 1	// diretory-only call, let NTFS reject it
	case FileFullDirectoryInformation:					// 2	// diretory-only call, let NTFS reject it
	case FileBothDirectoryInformation:					// 3	// diretory-only call, let NTFS reject it
														// 4	// FileBasicInfo handled separately
	case FileStandardInformation:						// 5
	case FileInternalInformation:						// 6
	case FileEaInformation:								// 7
	case FileAccessInformation:							// 8
	case FileNameInformation:							// 9
	case FileRenameInformation:							// 10	// rename isn't valid for query, but we'll let NTFS reject it
	case FileLinkInformation:							// 11	// link isn't valid for query, but we'll let NTFS reject it
	case FileNamesInformation:							// 12	// diretory-only call, let NTFS reject it
	case FileDispositionInformation:					// 13
	case FilePositionInformation:						// 14
	case FileFullEaInformation:							// 15	// NTFS doesn't support this, but we'll let it reject it
	case FileModeInformation:							// 16
	case FileAlignmentInformation:						// 17
														// 18	// FileAllInformation handled separately
	case FileAllocationInformation:						// 19
	case FileEndOfFileInformation:						// 20
	case FileAlternateNameInformation:					// 21
	case FileStreamInformation:							// 22
	case FilePipeInformation:							// 23	// NTFS doesn't support this, but we'll let it reject it
	case FilePipeLocalInformation:						// 24	// NTFS doesn't support this, but we'll let it reject it
	case FilePipeRemoteInformation:						// 25	// NTFS doesn't support this, but we'll let it reject it
	case FileMailslotQueryInformation:					// 26	// NTFS doesn't support this, but we'll let it reject it
	case FileMailslotSetInformation:					// 27	// NTFS doesn't support this, but we'll let it reject it
	case FileCompressionInformation:					// 28
	case FileObjectIdInformation:						// 29
	case FileCompletionInformation:						// 30	// NTFS doesn't support this, but we'll let it reject it
														// 31	FileMoveCluserInformation - intentionally failed for SIS files (+ not supported by NTFS)
	case FileQuotaInformation:							// 32	// diretory-only call, let NTFS reject it
	case FileReparsePointInformation:					// 33	// diretory-only call, let NTFS reject it
														// 34	// FileNetworkOpenInformation handled separately
														// 35	// FileAttributeTagInformation handled separately
	case FileTrackingInformation:						// 36	// NTFS doesn't support this, but we'll let it reject it

			//
			// Set the completion routine to NULL, which says that we never want to
			// catch completions on these calls.
			//
			completionRoutine = NULL;
			break;



	case FileBasicInformation:							// 4
			completionRoutine = SiQueryBasicInfoCompletion;
			break;

	case FileAllInformation:							// 18
			completionRoutine = SiQueryAllInfoCompletion;
			break;

	case FileNetworkOpenInformation:					// 34
			completionRoutine = SiQueryNetworkOpenInfoCompletion;
			break;

	case FileAttributeTagInformation:					// 35
			completionRoutine = SiQueryAttributeTagInfoCompletion;
			break;

	case FileMoveClusterInformation:					// 31	// NTFS doesn't implement this, but it's too scary to pass through anyway

		//
		// Reject these calls, for now.
		//

		SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);
		
#if		DBG
		DbgPrint("SIS: SiQueryInfo: aborting FileInformationClass %d\n",irpSp->Parameters.QueryFile.FileInformationClass);
#endif	// DBG

		Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return STATUS_INVALID_PARAMETER;

	default:

		//
		// It's an unknown or invalid information class.  Assume that it's newly added and
		// benign, and pass it down to NTFS unmodified.
		//

		SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);
		SIS_MARK_POINT_ULONG(irpSp->Parameters.QueryFile.FileInformationClass);
		completionRoutine = NULL;

#if		DBG
		DbgPrint("SIS: SiQueryInfo: passing though unknown FileInformationClass %d\n",irpSp->Parameters.QueryFile.FileInformationClass);
#endif	// DBG
		break;

	}

	if (NULL == completionRoutine) {
		//
		// This call doesn't require fixup on completion.  Pass it through.
		//
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	} else {
		//
		// This call requires fixup on the way out.  Only invoke the
		// completion routine on success; else, there's nothing to fix up.
		//
		nextIrpSp = IoGetNextIrpStackLocation( Irp );
		RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));

		IoSetCompletionRoutine(
			Irp,
			completionRoutine,
			perFO,
			TRUE,
			FALSE,
			FALSE);

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}
	
}

VOID
SipTruncateScb(
	IN OUT PSIS_SCB						scb,
	IN LONGLONG							newLength)
{
	LONGLONG				newLengthInSectors;
	PDEVICE_EXTENSION		deviceExtension;

	deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;

	newLengthInSectors = (newLength + deviceExtension->FilesystemVolumeSectorSize - 1) /
							deviceExtension->FilesystemVolumeSectorSize;

	ASSERT(newLength < scb->SizeBackedByUnderlyingFile);	// else this isn't a truncation

	FsRtlTruncateLargeMcb(scb->Ranges,newLengthInSectors);

	scb->SizeBackedByUnderlyingFile = newLength;
}

VOID
SipBeginDeleteModificationOperation(
	IN OUT PSIS_PER_LINK				perLink,
	IN BOOLEAN							delete)
/*++

Routine Description:

	We are beginning a delete or undelete operation on the given
	per-link.  If there is the opposite kind of operation in
	progress, wait for it to complete.  Otherwise, indicate that
	the new operation is in progress and continue.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	perLink - the per link for the file on which we're doing the (un)delete.

	delete - TRUE for delete, FALSE for undelete

Return Value:

	void

--*/
{
	KIRQL		OldIrql;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

	while ((perLink->PendingDeleteCount > 0) &&
			((delete && (perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS)) ||
			(((!delete) && !(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS))))) {
		//
		// The wrong kind of operation is happening now, so we need to block.
		//
		if (!(perLink->Flags & SIS_PER_LINK_DELETE_WAITERS)) {
			KeClearEvent(perLink->DeleteEvent);
			perLink->Flags |= SIS_PER_LINK_DELETE_WAITERS;
		}
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		KeWaitForSingleObject(perLink->DeleteEvent, Executive, KernelMode, FALSE, NULL);

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	}

	if (!delete) {
		ASSERT((perLink->PendingDeleteCount == 0) || (perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
		perLink->Flags |= SIS_PER_LINK_UNDELETE_IN_PROGRESS;
	} else {
		ASSERT(!(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
	}

	perLink->PendingDeleteCount++;

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);
}

VOID
SipEndDeleteModificationOperation(
	IN OUT PSIS_PER_LINK				perLink,
	IN BOOLEAN							delete)
/*++

Routine Description:

	We just finished a delete/undelete operation.  Decrement our count and
	if appropriate wake up any waiters.

	Must be called with IRQL <= DISPATCH_LEVEL.

Arguments:

	perLink - the per link for the file on which we're doing the (un)delete.

	delete - TRUE for delete, FALSE for undelete

Return Value:

	void

--*/
{
	KIRQL		OldIrql;

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

	ASSERT(perLink->PendingDeleteCount > 0);

	perLink->PendingDeleteCount--;

#if		DBG
	if (delete) {
		ASSERT(!(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
	} else {
		ASSERT(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS);
	}
#endif	// DBG

	if (0 == perLink->PendingDeleteCount) {

		if (perLink->Flags & SIS_PER_LINK_DELETE_WAITERS) {
			perLink->Flags &= ~SIS_PER_LINK_DELETE_WAITERS;
			KeSetEvent(perLink->DeleteEvent, IO_NO_INCREMENT, FALSE);
		}
		if (!delete) {
			perLink->Flags &= ~SIS_PER_LINK_UNDELETE_IN_PROGRESS;
		}
	}

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siclose.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siclose.c

Abstract:

	Close routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

NTSTATUS
SiClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is invoked upon file close operations.  If it's a SIS file,
	remove our filter context and clean up after ourselves.  In any case,
	let the close go down to NTFS.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the close irp

Return Value:

	The status from the NTFS close

--*/

{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PSIS_SCB 				scb;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

    //
    //  The control device object can not be opened
    //

    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

#if DBG
	if (BJBDebug & 0x1) {
		DbgPrint("SIS: SiClose: fileObject %p, %0.*ws\n",
		    fileObject,fileObject->FileName.Length / sizeof(WCHAR),fileObject->FileName.Buffer);
	}
#endif	// DBG

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindAny,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT_ULONG(perFO);

	//
	// Get rid of the perFO for this file object.  If this was the last file object,
	// then the filter context will get removed by NTFS, and deallocated by the appropriate
	// callback routine.
	//

	SipDeallocatePerFO(perFO,DeviceObject);

	//
	// We don't need to do any further processing on this SIS file object, so pass it
	// through.
	//
	SipDirectPassThroughAndReturn(DeviceObject, Irp);	// NB: This was a SIS file object!!!!

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\siinit.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    siinit.c

Abstract:

    SIS initialization and mount/attach support

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

/////////////////////////////////////////////////////////////////////////////
//
//                          Globals
//

/////////////////////////////////////////////////////////////////////////////

//
//  This is the string for the data attribute, $DATA, cribbed from ntfsdata.c
//

const UNICODE_STRING NtfsDataString = CONSTANT_UNICODE_STRING( L"$DATA" );


//
//  Holds pointer to the device object that represents this driver and is used
//  by external programs to access this driver.
//

PDEVICE_OBJECT SisControlDeviceObject = NULL;


//
//  List head for list of device extensions
//

KSPIN_LOCK DeviceExtensionListLock;
LIST_ENTRY DeviceExtensionListHead;

//
//  Global logging variables
//

KTIMER              LogTrimTimer[1];
KDPC                LogTrimDpc[1];
WORK_QUEUE_ITEM     LogTrimWorkItem[1];

//
//  This lock is used to synchronize our attaching to a given device object.
//  This lock fixes a race condition where we could accidently attach to the
//  same device object more then once.  This race condition only occurs if
//  a volume is being mounted at the same time as this filter is being loaded.
//  This problem will never occur if this filter is loaded at boot time before
//  any file systems are loaded.
//
//  This lock is used to atomically test if we are already attached to a given
//  device object and if not, do the attach.
//

FAST_MUTEX SisDeviceAttachLock;

/////////////////////////////////////////////////////////////////////////////
//
//                      Function Prototypes
//
/////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SipAttachToFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SipDetachFromFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SipEnumerateFileSystemVolumes(
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );

VOID
SipGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SipFsNotification)
#endif  // ALLOC_PRAGMA



//
//  Given a device type, return a valid name
//

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (sizeof(DeviceTypeNames) / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Known device type names
//

static const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

/////////////////////////////////////////////////////////////////////////////
//
//                          FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the SIS file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    PFAST_IO_DISPATCH   fastIoDispatch;
    UNICODE_STRING      nameString;
    NTSTATUS            status;
    ULONG               i;
    HANDLE              threadHandle;
    LARGE_INTEGER       dueTime;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_TRACE_LEVEL,
                "SIS: SIS.sys built %s. %s\n",
                 __DATE__ " " __TIME__,
                GCHEnableFastIo ? "FastIo " : "NO-FastIo" );

    //DbgBreakPoint();
#endif

    UNREFERENCED_PARAMETER( RegistryPath );
    SIS_MARK_POINT();

#if DBG
    KeInitializeSpinLock(MarkPointSpinLock);

    for (i = 0; i < NumScbReferenceTypes; i++) {
        totalScbReferencesByType[i] = 0;
    }
#endif  // DBG

#if COUNTING_MALLOC
    //
    // We need to initialize counting malloc before failing malloc.
    //
    SipInitCountingMalloc();
#endif  // COUNTING_MALLOC

#if RANDOMLY_FAILING_MALLOC
    SipInitFailingMalloc();
#endif  // RANDOMLY_FAILING_MALLOC

    //
    // Assert that we've left enough room in the backpointer streams for the header.
    //

    ASSERT(sizeof(SIS_BACKPOINTER_STREAM_HEADER) <= sizeof(SIS_BACKPOINTER) * SIS_BACKPOINTER_RESERVED_ENTRIES);

    ASSERT(sizeof(GUID) == 2 * sizeof(LONGLONG));   // SipCSFileTreeCompare relies on this

    ASSERT(sizeof(SIS_LOG_HEADER) % 4 == 0);    // The log drain code relies on this.

    //
    //  Save our Driver Object
    //

    FsDriverObject = DriverObject;

    //
    //  Create the Control Device Object (CDO).  This object represents this 
    //  driver.  Note that it does not have a device extension.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem\\Filters\\Sis" );
    status = IoCreateDevice(
                DriverObject,
                0,
                &nameString,
                FILE_DEVICE_DISK_FILE_SYSTEM,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &SisControlDeviceObject );

    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: Error creating control device object, status=%08x\n", status );
#endif // DBG
        SIS_MARK_POINT();
        return status;
    }

#if TIMING
    SipInitializeTiming();
#endif  // TIMING

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SiPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SiCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] = SiOtherCreates;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] = SiOtherCreates;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SiClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SiCleanup;
    DriverObject->MajorFunction[IRP_MJ_READ] = SiRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = SiWrite;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SiFsControl;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = SiSetInfo;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = SiQueryInfo;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = SiLockControl;

    //
    // Allocate fast I/O data structure and fill it in.
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), SIS_POOL_TAG );
    if (!fastIoDispatch) {
        IoDeleteDevice( SisControlDeviceObject );
        SIS_MARK_POINT();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );

    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SiFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SiFastIoRead;
    fastIoDispatch->FastIoWrite = SiFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SiFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SiFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SiFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SiFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SiFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SiFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SiFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SiFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SiFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SiFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SiFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SiFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SiFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SiFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SiFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SiFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SiFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SiFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

    //
    //  Setup list of device extensions
    //

    KeInitializeSpinLock(&DeviceExtensionListLock);
    InitializeListHead(&DeviceExtensionListHead);

    //
    //  Init other globals
    //

    ExInitializeFastMutex( &SisDeviceAttachLock );

    //
    // Set up the list & synch stuff for handing copy requests off to the copy thread(s).
    //

    InitializeListHead(CopyList);
    KeInitializeSpinLock(CopyListLock);
    KeInitializeSemaphore(CopySemaphore,0,MAXLONG);

    //
    //  Register this driver for watching file systems coming and going.  This
    //  enumeates all existing file systems as well as new file systems as they
    //  come and go.
    //

    status = IoRegisterFsRegistrationChange( DriverObject, SipFsNotification );
    if (!NT_SUCCESS( status )) {

        //
        //  Error cleanup
        //

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: Error registering FS change notification, status=%08x\n", status );
#endif // DBG

        DriverObject->FastIoDispatch = NULL;
        ExFreePool(fastIoDispatch);
        IoDeleteDevice( SisControlDeviceObject );
        SIS_MARK_POINT();
        return status;
    }

    //
    //  Create the thread that does the copy-on-write copies.  We may need to
    //  deal with having more than one thread if necessary...
    //

    status = PsCreateSystemThread(
                    &threadHandle,
                    THREAD_ALL_ACCESS,
                    NULL,               // Object Attributes
                    NULL,               // Process (NULL => PsInitialSystemProcess)
                    NULL,               // Client ID
                    SiCopyThreadStart,
                    NULL);              // context

    if (NT_SUCCESS(status)) {

        //
        //  If this was successful, close the thread handle.  Note that this
        //  does not make the thread go away.
        //

        ZwClose(threadHandle);
    }

    //
    //  Initialize timer
    //

    KeInitializeDpc(LogTrimDpc,SiLogTrimDpcRoutine,NULL);
    KeInitializeTimerEx(LogTrimTimer, SynchronizationTimer);
    ExInitializeWorkItem(LogTrimWorkItem,SiTrimLogs,NULL);

    dueTime.QuadPart = LOG_TRIM_TIMER_INTERVAL;

    KeSetTimerEx(LogTrimTimer,dueTime,0,LogTrimDpc);

#if TIMING && !DBG
    //
    // We need to have some way to get at the timing variables through the debugger.
    //
    {
        extern ULONG BJBClearTimingNow, BJBDumpTimingNow, SipEnabledTimingPointSets;

        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: BJBClearTimingNow %p; BJBDumpTimingNow %p; SipEnabledTimingPointSets %p\n",
                    &BJBClearTimingNow, 
                    &BJBDumpTimingNow, 
                    &SipEnabledTimingPointSets);
    }
#endif  // TIMING && !DBG

    SIS_MARK_POINT();
    return STATUS_SUCCESS;
}

NTSTATUS
SipInitializeDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    

Arguments:

    DevExt - the device extension to initialize

Return Value:

    Status of the operation

--*/
{
    PDEVICE_EXTENSION           devExt = DeviceObject->DeviceExtension;
    PWCHAR                      nameBuffer;
    ULONG                       nameLen;
    UNICODE_STRING              name;
    WCHAR                       lnameBuf[MAX_DEVNAME_LENGTH];

    SIS_MARK_POINT();

    //
    //  Set our device object into our extension
    //

    devExt->DeviceObject = DeviceObject;

    //
    // Initialize the various splay trees.
    //

    SipInitializeTree(devExt->ScbTree, SipScbTreeCompare);
    KeInitializeSpinLock(devExt->ScbSpinLock);
    SipInitializeTree(devExt->PerLinkTree, SipPerLinkTreeCompare);
    KeInitializeSpinLock(devExt->PerLinkSpinLock);
    SipInitializeTree(devExt->CSFileTree, SipCSFileTreeCompare);
    KeInitializeSpinLock(devExt->CSFileSpinLock);

    InitializeListHead(&devExt->ScbList);

    ExInitializeResourceLite(devExt->CSFileHandleResource);
    ExInitializeResourceLite(devExt->GrovelerFileObjectResource);

    //
    //  The only time this will be null is if we are attaching to the file
    //  system CDO (control device object).  Init the common store name
    //  (to null) and return.
    //

    if (!devExt->RealDeviceObject) {

        SIS_MARK_POINT();
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);

        devExt->Flags |= SIP_EXTENSION_FLAG_INITED_CDO;
        return STATUS_SUCCESS;
    }

    //
    //  We are attaching to a mounted volume.  Get the name of that volume.
    //

    RtlInitEmptyUnicodeString( &name, lnameBuf, sizeof(lnameBuf) );
    SipGetBaseDeviceObjectName( devExt->RealDeviceObject, &name );
    
    //
    //  Allocate a buffer to hold the name we received and store it in our
    //  device extension
    //
    
    nameLen = name.Length + SIS_CSDIR_STRING_SIZE + sizeof(WCHAR);

    nameBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       nameLen,
                                       SIS_POOL_TAG);

    if (NULL == nameBuffer) {

        SIS_MARK_POINT();
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  We got the buffer, store the name in it
    //

    RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,
                              nameBuffer,
                              nameLen);

    RtlCopyUnicodeString(&devExt->CommonStorePathname,
                         &name);

    //
    //  We want to save the path to the root of the volume.  Save a copy of
    //  the pointer and lengths before we add the common store name onto the
    //  string.  We do want to add the "\" character.

    devExt->FilesystemRootPathname = devExt->CommonStorePathname;
    devExt->FilesystemRootPathname.Length += sizeof(WCHAR);

    //
    //  Append the common store name to it
    //

    RtlAppendUnicodeToString(&devExt->CommonStorePathname,SIS_CSDIR_STRING);

    //
    // Set up the stuff for the index allocator.  Note that by setting MaxAllocatedIndex
    // equal to MaxUsedIndex, we force the allocator to run the first time that anyone
    // tries to get an index.  It'll recognize the special case, open the index file
    // and do the right thing.
    //

    devExt->MaxAllocatedIndex.QuadPart = devExt->MaxUsedIndex.QuadPart = 0;
    KeInitializeSpinLock(devExt->IndexSpinLock);
    KeInitializeEvent(devExt->IndexEvent,NotificationEvent,FALSE);
    devExt->IndexHandle = NULL;
    devExt->IndexFileEventHandle = NULL;
    devExt->IndexFileEvent = NULL;

    devExt->GrovelerFileHandle = NULL;
    devExt->GrovelerFileObject = NULL;
    KeInitializeSpinLock(devExt->FlagsLock);
    devExt->Flags = 0;
    KeInitializeEvent(devExt->Phase2DoneEvent,NotificationEvent,FALSE);

    KeInitializeMutex(devExt->CollisionMutex, 0);

#if     ENABLE_LOGGING
    devExt->LogFileHandle = NULL;
    devExt->LogFileObject = NULL;
    devExt->LogWriteOffset.QuadPart = 0;
    KeInitializeMutant(devExt->LogFileMutant, FALSE);
#endif  // ENABLE_LOGGING

    devExt->OutstandingFinalCopyRetries = 0;

    devExt->FilesystemVolumeSectorSize = devExt->AttachedToDeviceObject->SectorSize;
    ASSERT(devExt->FilesystemVolumeSectorSize > 63);       // do any disks have sectors this small?

    devExt->BackpointerEntriesPerSector = devExt->FilesystemVolumeSectorSize / sizeof(SIS_BACKPOINTER);

    //
    // Add this device extension to the list of SIS device extensions.
    //

    ExInterlockedInsertTailList(
            &DeviceExtensionListHead,
            &devExt->DevExtLink,
            &DeviceExtensionListLock );

    SIS_MARK_POINT();

    //
    //  Mark extension as initialized
    //

    devExt->Flags |= SIP_EXTENSION_FLAG_INITED_VDO;

    return STATUS_SUCCESS;
}


VOID
SipCleanupDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    We're about to free a device extension, probably because the
    volume has been dismounted for some reason.  Clean it up.

Arguments:

    devExt - the device extension to clean

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION       devExt = DeviceObject->DeviceExtension;
    KIRQL OldIrql;

    SIS_MARK_POINT();

    //
    //  Cleanup the name strings
    //

    if (NULL != devExt->CommonStorePathname.Buffer) {

        ASSERT(devExt->CommonStorePathname.Buffer == devExt->FilesystemRootPathname.Buffer);
        ExFreePool(devExt->CommonStorePathname.Buffer);
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);
        RtlInitEmptyUnicodeString(&devExt->FilesystemRootPathname,NULL,0);
    }

#if DBG
    //
    //  If a name buffer is allocated, free it
    //

    if (NULL != devExt->Name.Buffer) {

        ExFreePool( devExt->Name.Buffer );
        RtlInitEmptyUnicodeString( &devExt->Name, NULL, 0 );
    }
#endif

    //
    //  Cleanup if initialized
    //

    if (devExt->Flags & (SIP_EXTENSION_FLAG_INITED_CDO|SIP_EXTENSION_FLAG_INITED_VDO)) {

        //
        // Verify the splay trees are empty
        //

        ASSERT(devExt->ScbTree->TreeRoot == NULL);
        ASSERT(devExt->PerLinkTree->TreeRoot == NULL);
        ASSERT(devExt->CSFileTree->TreeRoot == NULL);


        ASSERT(IsListEmpty(&devExt->ScbList));

        //
        //  Cleanup resouces
        //

        ExDeleteResourceLite(devExt->CSFileHandleResource);
        ExDeleteResourceLite(devExt->GrovelerFileObjectResource);

        //
        //  Unlink from the device extension list (if VDO)
        //

        if (devExt->Flags & SIP_EXTENSION_FLAG_INITED_VDO) {

            KeAcquireSpinLock(&DeviceExtensionListLock, &OldIrql);

            RemoveEntryList( &devExt->DevExtLink );

            KeReleaseSpinLock(&DeviceExtensionListLock, OldIrql);
        }
    }
}


VOID
SipFsNotification(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Ffolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
    UNICODE_STRING name;
    WCHAR nameBuf[MAX_DEVNAME_LENGTH];

    PAGED_CODE();
    SIS_MARK_POINT();

    RtlInitEmptyUnicodeString( &name, nameBuf, sizeof(nameBuf) );

#if DBG
    //
    //  Display the names of all the file system we are notified of
    //

    SipGetBaseDeviceObjectName( DeviceObject, &name );
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
              "SIS: %s       \"%wZ\" (%s)\n",
              (FsActive) ? "Activating file system  " : "Deactivating file system",
              &name,
              GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType) );
#endif

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {

        SipAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SipDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
SipAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    UNICODE_STRING ntfsName;
    NTSTATUS status;

    PAGED_CODE();
    SIS_MARK_POINT();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    }

    //
    //  See if this is one of the standard Microsoft file system recognizer
    //  devices (see if this device is in the FS_REC driver).  If so skip it.
    //  We no longer attach to file system recognizer devices, we simply wait
    //  for the real file system driver to load.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    SipGetObjectName( DeviceObject->DriverObject, Name );

    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    }

    //
    //  See if this is NTFS's control device object (CDO)
    //

    RtlInitUnicodeString( &ntfsName, L"\\Ntfs" );
    SipGetBaseDeviceObjectName( DeviceObject, Name );

    if (RtlCompareUnicodeString( &ntfsName, Name, TRUE ) == 0) {

        SIS_MARK_POINT();

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Found NTFS Control Device Object\n");
#endif

        //
        //  We found the ntfs control device object, save it
        //

        FsNtfsDeviceObject = DeviceObject;

    } else {

        //
        //  Not NTFS CDO, return
        //

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    } 

    SIS_MARK_POINT();

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( FsDriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        SIS_MARK_POINT();
        return status;
    }

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( newDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( newDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Do the attachment
    //

    devExt = newDeviceObject->DeviceExtension;

    status = IoAttachDeviceToDeviceStackSafe( newDeviceObject, 
                                              DeviceObject,
                                              &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS(status)) {

        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializaing our device extension
    //

    status = SipInitializeDeviceExtension( newDeviceObject );
    ASSERT(STATUS_SUCCESS == status);

    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

#if DBG
    //
    //  Display who we have attached to
    //

    SipCacheDeviceName( newDeviceObject );
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                "SIS: Attaching to file system       \"%wZ\" (%s)\n",
                &devExt->Name,
                GET_DEVICE_TYPE_NAME(newDeviceObject->DeviceType) );
#endif

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = SipEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( newDeviceObject );

    ErrorCleanupDevice:
        SipCleanupDeviceExtension( newDeviceObject );
        IoDeleteDevice( newDeviceObject );

    return status;
}


VOID
SipDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

#if DBG
            //
            //  Display who we detached from
            //

            SipCacheDeviceName( ourAttachedDevice );
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                        "SIS: Detaching from file system     \"%wZ\" (%s)\n",
                        &devExt->Name,
                        GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
#endif

            //
            //  Since we only attached to NTFS, we can only detach from
            //  NTFS
            //

            ASSERT(FsNtfsDeviceObject == DeviceObject);
            FsNtfsDeviceObject = NULL;

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoDetachDevice( DeviceObject );
            SipCleanupDeviceExtension( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            SIS_MARK_POINT();
            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
    SIS_MARK_POINT();
}


NTSTATUS
SipEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT realDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList(
                    FSDeviceObject->DriverObject,
                    NULL,
                    0,
                    &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         SIS_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !SipAttachedToDevice( devList[i] )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                SipGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the real (disk) device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &realDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( FsDriverObject,
                                                 sizeof( DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &newDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  We have done a lot of work since the last time
                            //  we tested to see if we were already attached
                            //  to this device object.  Test again, this time
                            //  with a lock, and attach if we are not attached.
                            //  The lock is used to atomically test if we are
                            //  attached, and then do the attach.
                            //

                            ExAcquireFastMutex( &SisDeviceAttachLock );

                            if (!SipAttachedToDevice( devList[i] )) {

                                //
                                //  attach to volume.  If this operation
                                //  fails, this routine cleans up 
                                //  newDeviceObject
                                //

                                SipAttachToMountedDevice( devList[i], 
                                                          newDeviceObject, 
                                                          realDeviceObject );
                            } else {

                                //
                                //  The mount request failed.  Cleanup and delete the device
                                //  object we created.
                                //

                                SipCleanupDeviceExtension( newDeviceObject );
                                IoDeleteDevice( newDeviceObject );
                            }

                            //
                            //  Release the lock
                            //

                            ExReleaseFastMutex( &SisDeviceAttachLock );
                        }

                        //
                        //  Remove reference added by IoGetDiskDeviceObject
                        //

                        ObDereferenceObject( realDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}


NTSTATUS
SipAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT NewDeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject
    )
/*++

Routine Description:

    This will attach to a DeviceObject that represents a mounted volume.

Arguments:

    DeviceObject - The device to attach to

    NewDeviceObject - Our device object we are going to attach

    RealDeviceObject - The real device object associated with DeviceObject

Return Value:

    Status of the operation

--*/
{        
    PDEVICE_EXTENSION newDevExt = NewDeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(IS_MY_DEVICE_OBJECT( NewDeviceObject ));
    ASSERT(!SipAttachedToDevice ( DeviceObject ));

    //
    //  Initialize our device extension
    //

    newDevExt->RealDeviceObject = RealDeviceObject;

    //
    //  We don't want to attach to the BOOT partition, skip this volume
    //  (and cleanup) if this is the boot partition
    //

    if (RealDeviceObject->Flags & DO_SYSTEM_BOOT_PARTITION) {

#if DBG
        SipCacheDeviceName( NewDeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Not filtering boot volume      \"%wZ\"\n",
                    &newDevExt->Name );
#endif

        //
        //  Cleanup
        //

        SipCleanupDeviceExtension( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );

        return STATUS_SUCCESS;
    }

    //
    //  Propagate Device flags from Device Object we are attaching to
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( NewDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( NewDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Attach our device object to the given device object
    //

    status = IoAttachDeviceToDeviceStackSafe( NewDeviceObject, 
                                              DeviceObject,
                                              &newDevExt->AttachedToDeviceObject );

    if (!NT_SUCCESS(status)) {

        //
        //  The attachment failed, delete the device object
        //

        SipCleanupDeviceExtension( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );

    } else {

        //
        //  Initialize our device extension
        //

        SipInitializeDeviceExtension( NewDeviceObject );

        ClearFlag( NewDeviceObject->Flags, DO_DEVICE_INITIALIZING );

        //
        //  Display the name
        //

#if DBG
        SipCacheDeviceName( NewDeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Attaching to volume            \"%wZ\"\n", 
                    &newDevExt->Name );
#endif
    }

    return status;
}


VOID
SipGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}


VOID
SipGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    SipGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}


BOOLEAN
SipAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.

Arguments:

    DeviceObject - The device chain we want to look through

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.  This is returned
    //  with a refrence on it.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            ObDereferenceObject( currentDevObj );
            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

#if DBG
VOID
SipCacheDeviceName (
    IN PDEVICE_OBJECT OurDeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object.  This always allocates a buffer to hold the name, even if
    a name can not be found.  It does this so we won't keep trying to find
    a name during later calls (if it doesn't have a name now, it won't have
    one in the future).
    
    If the given device object already has a name, it immediatly returns.

    If not it will try and get the name from:
        - The device object
        - The real device object if there is one

Arguments:

    OurDeviceObject - The device object to store the name in.
    NamedDeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION devExt = OurDeviceObject->DeviceExtension;
    PWCHAR nameBuffer;
    UNICODE_STRING deviceName;
    WCHAR deviceNameBuffer[MAX_DEVNAME_LENGTH];

    ASSERT(IS_MY_DEVICE_OBJECT( OurDeviceObject ));

    //
    //  If there is already a name, return
    //

    if (NULL != devExt->Name.Buffer) {

        return;
    }

    //
    //  Get the name of the given device object.
    //

    RtlInitEmptyUnicodeString( &deviceName, deviceNameBuffer, sizeof(deviceNameBuffer) );
    SipGetBaseDeviceObjectName( OurDeviceObject, &deviceName );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((deviceName.Length <= 0) && (NULL != devExt->RealDeviceObject)) {

        SipGetBaseDeviceObjectName( devExt->RealDeviceObject, &deviceName );
    }

    //
    //  Allocate a buffer to insert into the device extension to hold
    //  this name.
    //

    nameBuffer = ExAllocatePoolWithTag( 
                                NonPagedPool, 
                                deviceName.Length + sizeof(WCHAR),
                                SIS_POOL_TAG );

    if (NULL != nameBuffer) {

        //
        //  Insert the name into the device extension.
        //

        RtlInitEmptyUnicodeString( &devExt->Name, 
                                   nameBuffer, 
                                   deviceName.Length + sizeof(WCHAR) );

        RtlCopyUnicodeString( &devExt->Name, &deviceName );
    }
}
#endif //DBG


VOID
SipPhase2Work(
    PVOID                   context)
{
    HANDLE                  vHandle;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       Obja[1];
    IO_STATUS_BLOCK         Iosb[1];
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)context;
    UNICODE_STRING          fileName;
    HANDLE                  volumeRootHandle = NULL;
    PFILE_OBJECT            volumeRootFileObject = NULL;
    NTFS_VOLUME_DATA_BUFFER volumeDataBuffer[1];
    ULONG                   returnedLength;
    PFILE_OBJECT            volumeFileObject = NULL;
    HANDLE                  volumeHandle = NULL;
    UNICODE_STRING          volumeName;
    BOOLEAN                 initializationWorked = TRUE;
    BOOLEAN                 grovelerFileResourceHeld = FALSE;
    KIRQL                   OldIrql;

    fileName.Buffer = NULL;

    SIS_MARK_POINT();

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                "SIS: SipPhase2Work                  \"%wZ\"\n",
                &deviceExtension->Name);
#endif  // DBG

    deviceExtension->Phase2ThreadId = PsGetCurrentThreadId();

    fileName.MaximumLength =
        deviceExtension->CommonStorePathname.Length
        + max(SIS_GROVELER_FILE_STRING_SIZE, SIS_VOLCHECK_FILE_STRING_SIZE)
        + sizeof(WCHAR);

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, SIS_POOL_TAG);

    if (NULL == fileName.Buffer) {

        initializationWorked = FALSE;
        goto done;
    }

    //
    // Open the groveler file.  Take the GrovelerFileObjectResource exclusive, even through
    // we probably don't need it here since we're creating it rather than destroying it.
    // We don't need to disable APCs, since we're in a system thread.
    //
	ASSERT(PsIsSystemThread(PsGetCurrentThread()));

    ExAcquireResourceExclusiveLite(deviceExtension->GrovelerFileObjectResource, TRUE);
    grovelerFileResourceHeld = TRUE;

    fileName.Length = 0;

    RtlCopyUnicodeString(&fileName,&deviceExtension->CommonStorePathname);

    ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);
    RtlAppendUnicodeToString(&fileName,SIS_GROVELER_FILE_STRING);

    InitializeObjectAttributes(
            Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtCreateFile(
            &deviceExtension->GrovelerFileHandle,
            GENERIC_READ,
            Obja,
            Iosb,
            NULL,                   // Allocation size
            0,                      // file attributes
            FILE_SHARE_READ |
            FILE_SHARE_WRITE,
            FILE_OPEN_IF,           // create it if necessary
            0,                      // create options
            NULL,                   // EA buffer
            0);                     // EA length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    ASSERT(STATUS_PENDING != status);   // create is always synchronous

    status = ObReferenceObjectByHandle(
                deviceExtension->GrovelerFileHandle,
                FILE_READ_DATA,
                *IoFileObjectType,
                KernelMode,
                &deviceExtension->GrovelerFileObject,
                NULL);          // handleInformation

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        initializationWorked = FALSE;
        goto done;
    }

    ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
    grovelerFileResourceHeld = FALSE;

    //
    // Temporarily open a handle to the volume root, just to verify that the
    // groveler file is on the same volume as the device to which we're attached.
    // Essentially, this is checking for rogue mount points.
    //

    InitializeObjectAttributes(
        Obja,
        &deviceExtension->FilesystemRootPathname,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &volumeRootHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                NULL,               // allocation size
                0,                  // file attributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE |
                FILE_SHARE_DELETE,
                FILE_OPEN,
                0,                  // create options
                NULL,               // EA buffer
                0);                 // EA length

    if (!NT_SUCCESS(status)) {
        //
        // Since this is only a paranoid consistency check, we'll just ignore
        // the check and continue as if it succeeded.
        //
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SipPhase2Work: unable to open volume root, 0x%x\n",status);
#endif  // DBG
    } else {
        status = ObReferenceObjectByHandle(
                    volumeRootHandle,
                    FILE_READ_DATA,
                    *IoFileObjectType,
                    KernelMode,
                    &volumeRootFileObject,
                    NULL);          // handle info

        if (!NT_SUCCESS(status)) {
            //
            // Just blow off the consistency check.
            //
#if DBG
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                        "SIS: SipPhase2Work: unable to reference volume root handle, 0x%x\n",status);
#endif  // DBG
        } else {
            if (IoGetRelatedDeviceObject(volumeRootFileObject) !=
                IoGetRelatedDeviceObject(deviceExtension->GrovelerFileObject)) {
#if DBG
                DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                            "SIS: \\SIS Common Store\\GrovelerFile is on the wrong volume from \\.  SIS aborted for this volume.\n");
#endif  // DBG
                ObDereferenceObject(deviceExtension->GrovelerFileObject);
                ZwClose(deviceExtension->GrovelerFileHandle);

                deviceExtension->GrovelerFileObject = NULL;
                deviceExtension->GrovelerFileHandle = NULL;

                goto done;
            }
        }
    }

    //
    // Try to open the volume check file.  If it exists, then we must initiate a
    // volume check.
    //

    RtlCopyUnicodeString(&fileName, &deviceExtension->CommonStorePathname);

    ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);
    RtlAppendUnicodeToString(&fileName, SIS_VOLCHECK_FILE_STRING);

    InitializeObjectAttributes(
            Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtCreateFile(
            &vHandle,
            0,
            Obja,
            Iosb,
            NULL,                   // Allocation size
            0,                      // file attributes
            0,                      // share mode
            FILE_OPEN,              // don't create
            0,                      // create options
            NULL,                   // EA buffer
            0);                     // EA length

    if (NT_SUCCESS(status)) {

        NtClose(vHandle);

        //
        // This will create a new thread to do the volume check, which
        // will immediately block waiting for us to finish phase 2
        // initialization.
        //
        SipCheckVolume(deviceExtension);
    }

    //
    // Get the NTFS volume information to find the bytes per file record segment.
    // We first need to open a volume handle to do this.  We get the volume name
    // by stripping the trailing backslash from the root pathanme.
    //

    //
    // Start by setting the bytes per file record to a safe size, in case for some
    // reason we can't get the volume information.  For our purposes, we want to err
    // on the high side.
    //

    deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart = 16 * 1024;

    volumeName.Length = deviceExtension->FilesystemRootPathname.Length - sizeof(WCHAR);
    volumeName.MaximumLength = volumeName.Length;
    volumeName.Buffer = deviceExtension->FilesystemRootPathname.Buffer;

    InitializeObjectAttributes(
        Obja,
        &volumeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &volumeHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                NULL,               // allocation size
                0,                  // file attributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE |
                FILE_SHARE_DELETE,
                FILE_OPEN,
                0,                  // create options
                NULL,               // EA buffer
                0);                 // EA length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    status = ObReferenceObjectByHandle(
                volumeHandle,
                FILE_READ_DATA,
                *IoFileObjectType,
                KernelMode,
                &volumeFileObject,
                NULL);          // handleInformation

    if (!NT_SUCCESS(status))  {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    status = SipFsControlFile(
                    volumeFileObject,
                    deviceExtension->DeviceObject,
                    FSCTL_GET_NTFS_VOLUME_DATA,
                    NULL,                           // input buffer
                    0,                              // i.b. length
                    volumeDataBuffer,
                    sizeof(NTFS_VOLUME_DATA_BUFFER),
                    &returnedLength);

    if (!NT_SUCCESS(status) || (sizeof(NTFS_VOLUME_DATA_BUFFER) != returnedLength)) {
        SIS_MARK_POINT_ULONG(status);
        SIS_MARK_POINT_ULONG(returnedLength);

#if     DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SipPhase2Work: unable to get NTFS volume data (or wrong length) 0x%x, %d\n",status,returnedLength);
#endif  // DBG

        initializationWorked = FALSE;
        // fall through

    } else {
        deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart =
            volumeDataBuffer->BytesPerFileRecordSegment;

        ASSERT(volumeDataBuffer->BytesPerSector == deviceExtension->FilesystemVolumeSectorSize);
    }

    if (NULL != volumeHandle) {
        NtClose(volumeHandle);
        volumeHandle = NULL;
    }

    if (NULL != volumeFileObject) {
        ObDereferenceObject(volumeFileObject);
        volumeFileObject = NULL;
    }


    //
    // Open the log file, which will also replay the log.  Note that we MUST have opened
    // the root handle before we make this call.
    //
    SipOpenLogFile(deviceExtension);

    // Whatever other phase 2 initialization we need to do

done:

    ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);
    deviceExtension->Phase2ThreadId = NULL;
    SIS_MARK_POINT();

    if (grovelerFileResourceHeld) {
        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileResourceHeld = FALSE;
    }

    //
    // Indicate that we're done.  Once we do this set, we have to assume that folks are
    // using the phase2 initialized stuff.
    //

    ASSERT(!deviceExtension->Phase2InitializationComplete);

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
    deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_PHASE_2_STARTED;
    deviceExtension->Phase2InitializationComplete = initializationWorked;

    //
    // Finally, wake up any threads that happend to block on phase 2 initialization
    // while we were doing it.
    //

    KeSetEvent(deviceExtension->Phase2DoneEvent, IO_DISK_INCREMENT, FALSE);
    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    if (NULL != fileName.Buffer) {

        ExFreePool(fileName.Buffer);
    }

    if (NULL != volumeRootHandle) {

        NtClose(volumeRootHandle);
    }

    if (NULL != volumeRootFileObject) {

        ObDereferenceObject(volumeRootFileObject);
    }
}


BOOLEAN
SipHandlePhase2(
    PDEVICE_EXTENSION               deviceExtension)
{
    KIRQL               OldIrql;
    BOOLEAN             startPhase2;
    NTSTATUS            status;
    WORK_QUEUE_ITEM     workItem[1];

    SIS_MARK_POINT();

	//
	// If this is the device object that we created to attach to the
	// Ntfs primary device object to watch for mount requests, then just
	// say no.
	//
	if (NULL == deviceExtension->RealDeviceObject) {
		return FALSE;
	}

	//
	// First, figure out if anyone else has started phase 2, and indicate that
	// it's started now.
	//
	KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
	startPhase2 = !(deviceExtension->Flags & SIP_EXTENSION_FLAG_PHASE_2_STARTED);
	deviceExtension->Flags |= SIP_EXTENSION_FLAG_PHASE_2_STARTED;
	KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // If we're the ones who need to start phase 2, then do it.
    //
    if (startPhase2) {

        KeClearEvent(deviceExtension->Phase2DoneEvent);

        ExInitializeWorkItem(
            workItem,
            SipPhase2Work,
            (PVOID)deviceExtension);

        ExQueueWorkItem(workItem,CriticalWorkQueue);
    }

    //
    // Allow the phase2 worker thread to proceed, since it may well do the phase2 check while
    // doing its internal work.
    //
    if (PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId) {
        SIS_MARK_POINT();
        return TRUE;
    }

    status = KeWaitForSingleObject(deviceExtension->Phase2DoneEvent, Executive, KernelMode, FALSE, NULL);
    ASSERT(status == STATUS_SUCCESS);
    SIS_MARK_POINT();

    return deviceExtension->Phase2InitializationComplete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sifsctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sifsctl.c

Abstract:

        File system control routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef  ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA

typedef struct _SIS_DISMOUNT_CONTEXT {
    WORK_QUEUE_ITEM         workItem[1];
    PDEVICE_EXTENSION       deviceExtension;
} SIS_DISMOUNT_CONTEXT, *PSIS_DISMOUNT_CONTEXT;

VOID
SiDismountWork(
    IN PVOID                            parameter)
{
    PSIS_DISMOUNT_CONTEXT   dismountContext = parameter;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                "SIS: SiDismountWork\n");
#endif  // DBG

    //
    // We're in a system thread, so we don't need to diable APCs before taking the
    // GrovelerFileObjectResource.
    //
    ASSERT(PsIsSystemThread(PsGetCurrentThread()));

    ExAcquireResourceExclusiveLite(dismountContext->deviceExtension->GrovelerFileObjectResource, TRUE);


    if (NULL != dismountContext->deviceExtension->GrovelerFileHandle) {
        NtClose(dismountContext->deviceExtension->GrovelerFileHandle);
        dismountContext->deviceExtension->GrovelerFileHandle = NULL;
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountWork closed GrovelerFile handle\n");
#endif  // DBG
    }

    if (NULL != dismountContext->deviceExtension->GrovelerFileObject) {
        ObDereferenceObject(dismountContext->deviceExtension->GrovelerFileObject);
        dismountContext->deviceExtension->GrovelerFileObject = NULL;
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountWork closed GrovelerFile object\n");
#endif  // DBG
    }

    ExReleaseResourceLite(dismountContext->deviceExtension->GrovelerFileObjectResource);

    ExFreePool(dismountContext);
}

NTSTATUS
SiDismountVolumeCompletion(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp,
        IN PVOID                        Context)
{
    PDEVICE_EXTENSION       deviceExtension = Context;
    PSIS_DISMOUNT_CONTEXT   dismountContext;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));
    ASSERT(STATUS_PENDING != Irp->IoStatus.Status);

    dismountContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_DISMOUNT_CONTEXT), ' siS');

    if (NULL != dismountContext) {
        SIS_MARK_POINT_ULONG(dismountContext);

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountCompletion: queueing dismount work\n");
#endif  // DBG

        ExInitializeWorkItem(dismountContext->workItem, SiDismountWork, dismountContext);
        dismountContext->deviceExtension = deviceExtension;
        ExQueueWorkItem(dismountContext->workItem,CriticalWorkQueue);
    } else {
        //
        // Too bad, we'll just dribble it.
        //
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SiDismountCompletion: Unable to allocate dismount context\n");
#endif  // DBG
        SIS_MARK_POINT();
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SipDismountVolume(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp)

/*++

Routine Description:

    Someone is trying a dismount volume request.  We can't tell if it's valid, so
    trap the completion.  If it completes successfully, then we need to clean up our
    state.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the FSCTL_DISMOUNT_VOLUME

Return Value:

    The function value is the status of the operation.

--*/
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                "SIS: SipDismountVolume: called, DO 0x%x, Irp 0x%x\n",DeviceObject, Irp);
#endif  // DBG

    RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

    IoSetCompletionRoutine(
            Irp,
            SiDismountVolumeCompletion,
            DeviceObject->DeviceExtension,
            TRUE,                           // invoke on success
            FALSE,                          // invoke on error
            FALSE);                         // invoke on cancel

    return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
}

NTSTATUS
SiUserSetSISReparsePointCompletion(
    IN PDEVICE_OBJECT               DeviceObject,
    IN PIRP                         Irp,
    IN PVOID                        Context)
{
    PKEVENT event = (PKEVENT)Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    Irp->PendingReturned = FALSE;

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipUserSetSISReparsePoint(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp)
{
        PREPARSE_DATA_BUFFER    reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
        PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
        PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
        PIO_STACK_LOCATION      nextIrpSp;
        ULONG                   InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;
        BOOLEAN                 validReparseData;
        CSID                    CSid;
        LINK_INDEX              LinkIndex;
        LARGE_INTEGER           CSFileNtfsId;
        LARGE_INTEGER           LinkFileNtfsId;
        LONGLONG                CSFileChecksum;
        PSIS_CS_FILE            CSFile = NULL;
        NTSTATUS                status;
        ULONG                   returnedLength;
        BOOLEAN                 prepared = FALSE;
        LINK_INDEX              newLinkIndex;
        KEVENT                  event[1];
        PSIS_PER_LINK           perLink = NULL;
        FILE_ALL_INFORMATION    allInfo[1];
        BOOLEAN                 EligibleForPartialFinalCopy;
        KIRQL                   OldIrql;
        PSIS_PER_FILE_OBJECT    perFO;
        PSIS_SCB                scb;

        SIS_MARK_POINT();

        if (!SipCheckPhase2(deviceExtension)) {
                //
                // This isn't a SIS enabled volume, or something else bad happened.  Just let it go.
                //
                SIS_MARK_POINT();
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        ASSERT(InputBufferLength >= SIS_REPARSE_DATA_SIZE);     // must have been checked by caller

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        //
        // This is a SIS reparse point.  Figure out whether it's valid.
        //

        validReparseData = SipIndicesFromReparseBuffer(
                                reparseBuffer,
                                &CSid,
                                &LinkIndex,
                                &CSFileNtfsId,
                                &LinkFileNtfsId,
                                &CSFileChecksum,
                                &EligibleForPartialFinalCopy,
                                NULL);

        if (SipIsFileObjectSIS(irpSp->FileObject, DeviceObject, FindActive, &perFO, &scb)) {
                perLink = scb->PerLink;
                //
                // This is a SIS file object.  If we're setting a reparse point where the CSid and
                // CSFile checksum are the same as the current file, assume that it's restore doing
                // the set, and just clear the dirty bit and leave the file be.  If someone other
                // than restore does this, it's harmless to anyone but them.
                //
                if ((!validReparseData) || (!IsEqualGUID(&CSid, &perLink->CsFile->CSid)) || CSFileChecksum != perLink->CsFile->Checksum) {
                        //
                        // The user is trying to set to an invalid reparse point, a different file or
                        // has a bogus checksum.  This isn't implemented.
                        //
                        SIS_MARK_POINT_ULONG(scb);

#if DBG
                        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                    "SIS: SipUserSetSISReparsePoint: unimplemented set\n");
#endif  // DBG

                        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                        Irp->IoStatus.Information = 0;

                        IoCompleteRequest(Irp, IO_NO_INCREMENT);

                        return STATUS_NOT_IMPLEMENTED;
                }

                KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                if ((perLink->Flags &
                                ( SIS_PER_LINK_BACKPOINTER_GONE
                                | SIS_PER_LINK_FINAL_COPY
                                | SIS_PER_LINK_FINAL_COPY_DONE
                                | SIS_PER_LINK_OVERWRITTEN
                                | SIS_PER_LINK_FILE_DELETED
                                | SIS_PER_LINK_DELETE_DISPOSITION_SET)) == 0) {

                        SIS_MARK_POINT_ULONG(scb);

                        Irp->IoStatus.Status = STATUS_SUCCESS;
                        Irp->IoStatus.Information = 0;

                        perLink->Flags &= ~SIS_PER_LINK_DIRTY;

                } else {
                        SIS_MARK_POINT_ULONG(scb);
#if DBG
                        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                    "SIS: SipUserSetSISReparsePoint: trying to re-set reparse point on file in funny state\n");
#endif  // DBG
                        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                        Irp->IoStatus.Information = 0;
                }
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                status = Irp->IoStatus.Status;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                return status;
        }


        if (!validReparseData) {
            //
            // It's not a valid reparse point, so we don't update our backpointers.  Just let
            // it get set, and we'll delete it if anyone tries to open the resulting file.
            //
            SIS_MARK_POINT();
            SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Rewrite reparse point in the buffer pointed to by the irp to have a new, unused link index
        // which prevents problems with files existing on disk with link indices > MaxIndex.
        //
        status = SipAllocateIndex(deviceExtension,&newLinkIndex);
        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            newLinkIndex.QuadPart = 0;
            newLinkIndex.Check = 0;
        }

        if (!SipIndicesIntoReparseBuffer(
                                reparseBuffer,
                                &CSid,
                                &newLinkIndex,
                                &CSFileNtfsId,
                                &LinkFileNtfsId,
                                &CSFileChecksum,
                                EligibleForPartialFinalCopy)) {

                status = STATUS_DRIVER_INTERNAL_ERROR;
                SIS_MARK_POINT();
                goto Error;
        }

        //
        // Get the file information.
        //
        status = SipQueryInformationFile(
                                irpSp->FileObject,
                                DeviceObject,
                                FileAllInformation,
                                sizeof(FILE_ALL_INFORMATION),
                                allInfo,
                                &returnedLength);

        if ((STATUS_BUFFER_OVERFLOW == status) && (returnedLength == sizeof(FILE_ALL_INFORMATION))) {
                //
                // We expect to get a buffer overflow, because of the file name return.  Treat this
                // like success.
                //
                SIS_MARK_POINT();
                status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // If this is a sparse file and eliginle for partial final copy, then zero out any
        // trailing unallocated region.
        //
        if (EligibleForPartialFinalCopy && (allInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE)) {
#define NUM_RANGES_PER_ITERATION        10

                FILE_ALLOCATED_RANGE_BUFFER     inArb[1];
                FILE_ALLOCATED_RANGE_BUFFER     outArb[NUM_RANGES_PER_ITERATION];
                FILE_ZERO_DATA_INFORMATION      zeroData[1];
                unsigned                                        allocatedRangesReturned;

                for (inArb->FileOffset.QuadPart = 0;
                         inArb->FileOffset.QuadPart < allInfo->StandardInformation.EndOfFile.QuadPart;
                        ) {
                        //
                        // Query the range.
                        //
                        inArb->Length.QuadPart = MAXLONGLONG;

                        status = SipFsControlFile(
                                                irpSp->FileObject,
                                                DeviceObject,
                                                FSCTL_QUERY_ALLOCATED_RANGES,
                                                inArb,
                                                sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                                                outArb,
                                                sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGES_PER_ITERATION,
                                                &returnedLength);

                        if (!NT_SUCCESS(status)) {
                                //
                                // Just skip this part.
                                //
                                SIS_MARK_POINT_ULONG(status);
                                goto VDLExtended;
                        }

                        ASSERT(returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0);

                        allocatedRangesReturned = returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

                        if (allocatedRangesReturned < NUM_RANGES_PER_ITERATION) {
                                if ((1 == allocatedRangesReturned) &&
                                        (0 == inArb->FileOffset.QuadPart) &&
                                        (0 == outArb[0].FileOffset.QuadPart) &&
                                        (allInfo->StandardInformation.EndOfFile.QuadPart <= outArb[0].Length.QuadPart) &&
                                        (deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart >= allInfo->StandardInformation.EndOfFile.QuadPart)) {

                                        //
                                        // This is a special case.  This is a small file with a single allocated range extending from
                                        // the start of the file to the end.  It's possibly a resident stream, so we FSCTL_SET_ZERO_DATA
                                        // won't necessarily make it go away.  We just deal with this by make it not be eligible for partial
                                        // final copy.
                                        //

                                        EligibleForPartialFinalCopy = FALSE;

                                } else if (allocatedRangesReturned > 0) {
                                        inArb->FileOffset.QuadPart =
                                                outArb[allocatedRangesReturned-1].FileOffset.QuadPart + outArb[allocatedRangesReturned-1].Length.QuadPart;
                                }
                                //
                                // Zero out the remainder of the file, in order to extend ValidDataLength.
                                //
                                zeroData->FileOffset = inArb->FileOffset;
                                zeroData->BeyondFinalZero.QuadPart = MAXLONGLONG;

                                status = SipFsControlFile(
                                                        irpSp->FileObject,
                                                        DeviceObject,
                                                        FSCTL_SET_ZERO_DATA,
                                                        zeroData,
                                                        sizeof(FILE_ZERO_DATA_INFORMATION),
                                                        NULL,                                                           // output buffer
                                                        0,                                                                      // o.b. length
                                                        NULL);                                                          // returned length

#if DBG
                                if (!NT_SUCCESS(status)) {
                                    SIS_MARK_POINT_ULONG(status);
                                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                                "SIS: SipUserSetSISReparsePoint: unable to zero data, 0x%x\n",status);
                                }
#endif  // DBG
                                goto VDLExtended;
                        }

                        ASSERT(allocatedRangesReturned == NUM_RANGES_PER_ITERATION);
                        inArb->FileOffset.QuadPart =
                                outArb[NUM_RANGES_PER_ITERATION-1].FileOffset.QuadPart + outArb[NUM_RANGES_PER_ITERATION-1].Length.QuadPart;
                }



#undef  NUM_RANGES_PER_ITERATION
        }

VDLExtended:

        CSFile = SipLookupCSFile(
                                &CSid,
                                &CSFileNtfsId,
                                DeviceObject);

        if (NULL == CSFile) {
                //
                // We couldn't allocate a CSFile, just fail the request.
                //
                SIS_MARK_POINT();
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
        }

        //
        // Make sure the common store file is open.
        //
        status = SipAssureCSFileOpen(CSFile);

        if (!NT_SUCCESS(status)) {
                //
                // It wasn't there or we couldn't get to it for some reason, just let the set proceed.
                //
                SIS_MARK_POINT_ULONG(status);
                SipDereferenceCSFile(CSFile);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Check the checksum.
        //
        if (CSFile->Checksum != CSFileChecksum) {
                SIS_MARK_POINT();

                //
                // The checksum's bogus, so the reparse point isn't good for much.  Let the set
                // proceed anyway.  When the user tries to open this file, we'll delete the reparse
                // point.
                //
                SipDereferenceCSFile(CSFile);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Prepare for a refcount change, allocate the new link index,
        // and create a new perLink.
        //

        status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                    CSFile,
                    &allInfo->InternalInformation.IndexNumber,
                    DeviceObject,
                    &newLinkIndex,
                    &perLink,
                    &prepared);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Construct the new reparse point in the buffer pointed to by the irp.
        //
        if (!SipIndicesIntoReparseBuffer(
                                reparseBuffer,
                                &CSFile->CSid,
                                &newLinkIndex,
                                &CSFile->CSFileNtfsId,
                                &allInfo->InternalInformation.IndexNumber,
                                &CSFileChecksum,
                                EligibleForPartialFinalCopy)) {

            status = STATUS_DRIVER_INTERNAL_ERROR;
            SIS_MARK_POINT();
            goto Error;
        }

        //
        // Set an event to synchronize completion.
        //
        KeInitializeEvent(event, NotificationEvent, FALSE);

        //
        // Set up the irp
        //
        nextIrpSp = IoGetNextIrpStackLocation(Irp);
        RtlCopyMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

        IoSetCompletionRoutine(
                Irp,
                SiUserSetSISReparsePointCompletion,
                event,
                TRUE,
                TRUE,
                TRUE);

        IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

        status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
        ASSERT(STATUS_SUCCESS == status);

        if (!NT_SUCCESS(Irp->IoStatus.Status)) {
                SipCompleteCSRefcountChange(
                        NULL,
            NULL,
                        CSFile,
                        FALSE,
                        TRUE);
        } else {
                status = SipCompleteCSRefcountChange(
                                        perLink,
                                    &perLink->Index,
                                        CSFile,
                                        TRUE,
                                        TRUE);

                if (!NT_SUCCESS(status)) {
                        //
                        // We know we just messeded up, so just kick off the volume
                        // check right away.
                        //
                        SIS_MARK_POINT_ULONG(status);

                        SipCheckVolume(deviceExtension);
                }
        }

        SipDereferencePerLink(perLink);
        SipDereferenceCSFile(CSFile);

#if             DBG
        perLink = NULL;
        CSFile = NULL;
#endif  // DBG

        status = Irp->IoStatus.Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

Error:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        if (prepared) {
                ASSERT(NULL != CSFile);

                status = SipCompleteCSRefcountChange(
                                        NULL,
                    NULL,
                                        CSFile,
                                        FALSE,
                                        TRUE);

                if (!NT_SUCCESS(status)) {
                        SIS_MARK_POINT_ULONG(status);
                }
        }

        if (NULL != CSFile) {
                SipDereferenceCSFile(CSFile);
#if             DBG
                CSFile = NULL;
#endif  // DBG
        }

        if (NULL != perLink) {
                SipDereferencePerLink(perLink);
#if             DBG
                perLink = NULL;
#endif  // DBG
        }

        return status;
}



NTSTATUS
SipQueryAllocatedRanges(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                                 Irp)
/*++

Routine Description:

        This routine implements FSCTL_QUERY_ALLOCATED_RANGES for SIS links.  SIS links
        that weren't opened FILE_OPEN_REPARSE_POINT look like they're completely allocated
        (ie., that they're all data and no holes).  This function returns such.

        We complete the irp and return the appropriate status.

        This code is stolen from NTFS.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the FSCTL_QUERY_ALLOCATED_RANGES.

Return Value:

    The function value is the status of the operation.

--*/

{
        BOOLEAN                                                 validUserBuffer = TRUE;
        PFILE_ALLOCATED_RANGE_BUFFER    OutputBuffer;
        LONGLONG                                                Length, StartingOffset;
        NTSTATUS                                                status;
        FILE_STANDARD_INFORMATION               standardInformation[1];
        PIO_STACK_LOCATION                              IrpSp = IoGetCurrentIrpStackLocation(Irp);
        ULONG                                                   returnedLength;
        ULONG                                                   RemainingBytes;

        Irp->IoStatus.Information = 0;

        //
        // Query the file's standard information to get the length.
        //
        status = SipQueryInformationFile(
                                IrpSp->FileObject,
                                DeviceObject,
                                FileStandardInformation,
                                sizeof(FILE_STANDARD_INFORMATION),
                                standardInformation,
                                &returnedLength);

        if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);

                goto done;
        }

        ASSERT(returnedLength == sizeof(FILE_STANDARD_INFORMATION));

        //
        // This is a METHOD_NEITHER buffer, so we have to be careful in touching it.
        // Code to check it out stolen from NTFS.
        //

        try {
                if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(FILE_ALLOCATED_RANGE_BUFFER)) {
                        status = STATUS_INVALID_PARAMETER;
                        leave;
                }

        RemainingBytes = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
                OutputBuffer = (PFILE_ALLOCATED_RANGE_BUFFER)SipMapUserBuffer(Irp);

                if (NULL == OutputBuffer) {
                        //
                        // We couldn't map the user buffer because of resource shortages.
                        //
                        SIS_MARK_POINT_ULONG(IrpSp->FileObject);

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto done;
                }

                if (KernelMode != Irp->RequestorMode) {
            ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                      IrpSp->Parameters.FileSystemControl.InputBufferLength,
                                          sizeof( ULONG ));

                        ProbeForWrite( OutputBuffer, RemainingBytes, sizeof( ULONG ));

        } else if (!IsLongAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer ) ||
                   !IsLongAligned( OutputBuffer )) {
                        validUserBuffer = FALSE;
            leave;
                }

        StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
        Length = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;

        //
        //  Check that the input parameters are valid.
        //

        if ((Length < 0) ||
            (StartingOffset < 0) ||
            (Length > MAXLONGLONG - StartingOffset)) {

            status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Check that the requested range is within file size
        //  and has a non-zero length.
        //

        if (Length == 0) {
                        SIS_MARK_POINT();
            leave;
        }

        if (StartingOffset >= standardInformation->EndOfFile.QuadPart) {
                        SIS_MARK_POINT();
            leave;
        }

        if (standardInformation->EndOfFile.QuadPart - StartingOffset < Length) {

            Length = standardInformation->EndOfFile.QuadPart - StartingOffset;
        }

                //
                // Show that the entire requested range is allocated.
                //
        if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

            status = STATUS_BUFFER_TOO_SMALL;

                        SIS_MARK_POINT();

        } else {

            OutputBuffer->FileOffset.QuadPart = StartingOffset;
            OutputBuffer->Length.QuadPart = Length;
            Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                        status = STATUS_SUCCESS;
        }

        } except (EXCEPTION_EXECUTE_HANDLER) {
                validUserBuffer = FALSE;
        }

        if (!validUserBuffer) {
                status = STATUS_INVALID_USER_BUFFER;
        }

done:
        Irp->IoStatus.Status = status;


        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
}


NTSTATUS
SipMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  This
    simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SipLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a LoadFileSystem request.
    This simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SiFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE_EXTENSION       devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          newDeviceObject;
    PDEVICE_EXTENSION       newDevExt;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                status;
    PIO_STACK_LOCATION      nextIrpSp;
    PSIS_PER_FILE_OBJECT    perFO;
    PSIS_SCB                scb;
    PVPB                    vpb;
    KEVENT                  waitEvent;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_FSCONTROL_TRACE_LEVEL,
                "SIS: SiFsControl: fo %p, mf %x, code %x\n",
                irpSp->FileObject,
                irpSp->MinorFunction,
                irpSp->Parameters.FileSystemControl.FsControlCode );
#endif

    //
    //  The control device object can't be opened
    //

    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        SIS_MARK_POINT();

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.  
        //
        //  Since the device object we are going to attach to has not yet been
        //  created (it is created by the base file system) we are going to use
        //  the type of the file system control device object.  We are assuming
        //  that the file system control device object will have the same type
        //  as the volume device objects associated with it.
        //

        ASSERT(IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType));

        status = IoCreateDevice(
                    FsDriverObject,
                    sizeof( DEVICE_EXTENSION ),
                    (PUNICODE_STRING) NULL,
                    DeviceObject->DeviceType,
                    0,
                    FALSE,
                    &newDeviceObject );

        if (NT_SUCCESS( status )) {

            //
            //  We need to save the RealDevice object pointed to by the vpb
            //  parameter because this vpb may be changed by the underlying
            //  file system.  Both FAT and CDFS may change the VPB address if
            //  the volume being mounted is one they recognize from a previous
            //  mount.
            //

            newDevExt = newDeviceObject->DeviceExtension;
            newDevExt->RealDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine(
                Irp,
                SipMountCompletion,
                &waitEvent,
                TRUE,
                TRUE,
                TRUE);

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

            //
            //  Wait for the completion routine to be called
            //

	        if (STATUS_PENDING == status) {

		        NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		        ASSERT(localStatus == STATUS_SUCCESS);
	        }

            //
            //  Get the correct VPB from the real device object saved in our
            //  device extension.  We do this because the VPB in the IRP stack
            //  may not be the correct VPB when we get here.  The underlying
            //  file system may change VPBs if it detects a volume it has
            //  mounted previously.
            //

            vpb = newDevExt->RealDeviceObject->Vpb;

            //
            //  If the operation succeeded and we are not alreayd attached,
            //  attach to the device object.
            //

            if (NT_SUCCESS( Irp->IoStatus.Status )) {

                //
                //  Acquire lock so we can atomically test if we area already attached
                //  and if not, then attach.  This prevents a double attach race
                //  condition.
                //

                ExAcquireFastMutex( &SisDeviceAttachLock );

                //
                //  The mount succeeded.  If we are not already attached,
                //  attach to the device object.  Note: one reason we could
                //  already be attached is if the underlying file system
                //  revived a previous mount.
                //

                if (!SipAttachedToDevice( vpb->DeviceObject )) {

                    //
                    //  Attach to the new mounted volume.  Note that we must
                    //  go through the VPB to locate the file system volume
                    //  device object.
                    //  This routine will cleanup "newDeviceObject" if this
                    //  operation fails.
                    //

                    SipAttachToMountedDevice( vpb->DeviceObject, 
                                              newDeviceObject, 
                                              newDevExt->RealDeviceObject );

                } else {
        #if DBG
                    SipCacheDeviceName( newDeviceObject );
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                              "SIS: Mount volume failure for       \"%wZ\", already attached\n", 
                              &newDevExt->Name );
        #endif

                    //
                    //  The mount request failed.  Cleanup and delete the device
                    //  object we created.
                    //

                    SipCleanupDeviceExtension( newDeviceObject );
                    IoDeleteDevice( newDeviceObject );
                }

                //
                //  Release the lock
                //

                ExReleaseFastMutex( &SisDeviceAttachLock );

            } else {

        #if DBG
                //
                //  Display what mount failed.
                // 

                SipCacheDeviceName( newDeviceObject );
                DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                          "SIS: Mount volume failure for       \"%wZ\", status=%08x\n",
                          &newDevExt->Name, 
                          Irp->IoStatus.Status );
        #endif

                //
                //  The mount request failed.  Cleanup and delete the device
                //  object we created.
                //

                SipCleanupDeviceExtension( newDeviceObject );
                IoDeleteDevice( newDeviceObject );
            }

            //
            //  Continue processing the operation
            //

            status = Irp->IoStatus.Status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;

        } else {

#if DBG
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                        "SIS: Error creating volume device object, status=%08x\n", 
                        status );
#endif

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.
        //

#if DBG
        SipCacheDeviceName( DeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Loading File System, Detaching from \"%wZ\"\n", 
                    &devExt->Name );
#endif

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            SipLoadFsCompletion,
            &waitEvent,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

		    NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(localStatus == STATUS_SUCCESS);
	    }

#if DBG
        //
        //  Display the name if requested
        //

        SipCacheDeviceName( DeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Detaching from recognizer      \"%wZ\", status=%08x\n", 
                    &devExt->Name,
                    Irp->IoStatus.Status );
#endif

        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            status = IoAttachDeviceToDeviceStackSafe( DeviceObject, 
                                                      devExt->AttachedToDeviceObject,
                                                      &devExt->AttachedToDeviceObject );

            ASSERT(STATUS_SUCCESS == status);

        } else {

            //
            //  The load was successful, delete the Device object attached to the
            //  recognizer.
            //

            SipCleanupDeviceExtension( DeviceObject );
            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction && 
            SipIsFileObjectSIS(irpSp->FileObject,DeviceObject,FindActive,&perFO,&scb)) {

        SIS_MARK_POINT_ULONG(scb);
        SIS_MARK_POINT_ULONG(irpSp->Parameters.FileSystemControl.FsControlCode);

        //
        // This is a big switch of all of the known fsctl calls.  Most of these calls just get
        // passed through on the link file, but we explicity list them to indicate that we put
        // some thought into the particular call and determined that passing it through is
        // appropriate.  In the checked build, we generate a DbgPrint for unknown fsctl calls,
        // then pass them through on the link file.
        //

        switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

            //
            // Fsctl calls 0-5
            //
            // oplock calls all get passed through.
            //

            case FSCTL_REQUEST_OPLOCK_LEVEL_1:
            case FSCTL_REQUEST_OPLOCK_LEVEL_2:
            case FSCTL_REQUEST_BATCH_OPLOCK:
            case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
            case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
            case FSCTL_OPLOCK_BREAK_NOTIFY:
                goto PassThrough;

            //
            // Fsctl call 6
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_LOCK_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 7
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_UNLOCK_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 8
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_DISMOUNT_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 9 is decommissioned.
            //

            //
            // Fsctl call 10
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_IS_VOLUME_MOUNTED:
                goto PassThrough;

            //
            // Fsctl call 11
            //
            // Ntfs doesn't even look at the parameters, it just succeeds the request.
            //

            case FSCTL_IS_PATHNAME_VALID:
                goto PassThrough;

            //
            // Fsctl call 12
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_MARK_VOLUME_DIRTY:
                goto PassThrough;

            //
            // Fsctl call 13 is decommissioned.
            //

            //
            // Fsctl call 14
            //
            // This is valid only on paging files and only in kernel mode.  Pass through and let NTFS
            // fail or assert.
            //

            case FSCTL_QUERY_RETRIEVAL_POINTERS:
                goto PassThrough;

            //
            // Fsctl calls 15 and 16
            //
            // The compression state of the link file is independent
            // of the compression state of the CS file (which preferably
            // is compressed).  Pass through.
            //

            case FSCTL_GET_COMPRESSION:
            case FSCTL_SET_COMPRESSION:
                goto PassThrough;

            //
            // Fsctl calls 17 and 18 are decommissioned.
            //

            //
            // Fsctl call 19
            //
            // This is disconcerting--ntfs treats system hives specially.
            // Basically, it works hard to keep them consistent across crashes.
            // It's not such a good idea to do this with a SIS file, since we're
            // not going to be all that great with user data across a crash.  However,
            // given that we've gotten here, just go for it.
            //

            case FSCTL_MARK_AS_SYSTEM_HIVE:
                ASSERT(!"SIS: SiFsControl: Someone called FSCTL_MARK_AS_SYSTEM_HIVE on a SIS file!\n");
                goto PassThrough;

            //
            // Fsctl call 20
            //
            // oplock calls all get passed through.
            //

            case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                goto PassThrough;

            //
            // Fsctl call 21
            //
            // NTFS doesn't even mention this fsctl.  We'll let it fail it.
            //

            case FSCTL_INVALIDATE_VOLUMES:
                goto PassThrough;

            //
            // Fsctl call 22
            //
            // NTFS doesn't even mention this fsctl.  We'll let it fail it.
            //

            case FSCTL_QUERY_FAT_BPB:
                goto PassThrough;

            //
            // Fsctl call 23
            //
            // oplock calls all get passed through.
            //

            case FSCTL_REQUEST_FILTER_OPLOCK:
                goto PassThrough;

            //
            // Fsctl call 24
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_FILESYSTEM_GET_STATISTICS:
                goto PassThrough;

            //
            // Fsctl call 25
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_GET_NTFS_VOLUME_DATA:
                goto PassThrough;

            //
            // Fsctl call 26
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_GET_NTFS_FILE_RECORD:
                goto PassThrough;

            //
            // Fsctl call 27
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_GET_VOLUME_BITMAP:
                goto PassThrough;

            //
            // Fsctl call 28
            //
            // This returns file cluster allocation information.
            // If opened reparse, pass through.  If not, then send to
            // where the data is.
            //

            case FSCTL_GET_RETRIEVAL_POINTERS: {
                BOOLEAN         openedAsReparse;
                KIRQL           OldIrql;
                BOOLEAN         dirty;

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (openedAsReparse) {
                    //
                    // The user opened this file FILE_OPEN_REPARSE_POINT, so tell the truth
                    // about the link file.
                    //
                    goto PassThrough;
                }

                KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
                dirty = (scb->PerLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
                KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

                //
                // Just because the per-link dirty bit isn't set doesn't mean that the
                // file's totally clean.  Check the scb bits.
                //
                if (!dirty) {
                    SipAcquireScb(scb);
                    if (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) {
                        dirty = TRUE;
                    }
                    SipReleaseScb(scb);
                }

                if (dirty) {

                    //
                    // We should look at the ranges queried and split things up, much like we do with
                    // reads that span dirty/clean boundaries.
                    //
                    // NTRAID#65190-2000/03/10-nealch  Handle FSCTL_GET_RETRIEVAL_POINTERS for "dirtied" sis files.
                    //

                    SIS_MARK_POINT_ULONG(scb);

#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: SiFsControl: FSCTL_GET_RETRIEVAL_POINTERS: called on dirty file, returning STATUS_NOT_IMPLEMENTED\n");
#endif  // DBG

                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                //
                // Just send this to the common store file.
                //

                goto SendToCSFile;
            }

            //
            // Fsctl call 29
            //
            // This is called on a volume handle, but a file handle
            // is passed in the input buffer.  It moves a range of the
            // file to a specified location on the volume.  We just pass it through
            // regardless; trying to move unallocated regions of a link file is
            // meaningless, and trying to move allocated regions will do the
            // right thing.  To move the common store file, it can be called with
            // a CS file handle.
            //

            case FSCTL_MOVE_FILE:
                goto PassThrough;

            //
            // Fsctl call 30
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_IS_VOLUME_DIRTY:
                goto PassThrough;

            //
            // Fsctl call 32
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_ALLOW_EXTENDED_DASD_IO:
                goto PassThrough;

            //
            // Fsctl call 33 is decommissioned.
            //

            //
            // Fsctl call 35
            //
            // Directory only - pass through and let NTFS fail.
            //

            case FSCTL_FIND_FILES_BY_SID:
                goto PassThrough;

            //
            // Fsctl call 36 is decommissioned.
            //

            //
            // Fsctl call 37 is decommissioned.
            //

            //
            // Fsctls 38-40.
            //
            // Pass through.  Object ID's are similar to file ID's, but are user assigned.
            //

            case FSCTL_SET_OBJECT_ID:
            case FSCTL_GET_OBJECT_ID:
            case FSCTL_DELETE_OBJECT_ID:
                goto PassThrough;

            //
            // Fsctl call 41
            //
            // We can have only one reparse point on a file, and SIS is using it.  We should
            // probably COW this file, but for now just disallow this, except in the case
            // where it's a SIS reparse point being set, in which case we forward the request to
            // SipUserSetSISReparsePoint.
            //

            case FSCTL_SET_REPARSE_POINT: {
                PREPARSE_DATA_BUFFER reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
                ULONG InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

                if ((NULL == reparseBuffer) || 
                            (InputBufferLength < SIS_REPARSE_DATA_SIZE)) {

                    SIS_MARK_POINT_ULONG(InputBufferLength);

                    status = STATUS_INVALID_PARAMETER;
                    goto CompleteWithStatus;
                }

                if (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag) {

                    status = STATUS_INVALID_PARAMETER;
                    goto CompleteWithStatus;
                }

                status = SipUserSetSISReparsePoint(DeviceObject, Irp);

                SIS_MARK_POINT_ULONG(status);

                return status;
            }

            //
            // Fsctl call 42
            //
            // Just let the user read the SIS reparse point.
            //

            case FSCTL_GET_REPARSE_POINT:
                goto PassThrough;

            //
            // Fsctl call 43
            //
            // Disallow deleting SIS reparse points directly.
            //

            case FSCTL_DELETE_REPARSE_POINT:
                status = STATUS_ACCESS_DENIED;
                goto CompleteWithStatus;

            //
            // Fsctl call 44
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_ENUM_USN_DATA:
                goto PassThrough;

            //
            // Fsctl call 45
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_SECURITY_ID_CHECK:
                goto PassThrough;

            //
            // Fsctl call 46
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_READ_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctls 47 and 48
            //
            // Pass through.  Object ID's are similar to file ID's, but are user assigned.
            //

            case FSCTL_SET_OBJECT_ID_EXTENDED:
            case FSCTL_CREATE_OR_GET_OBJECT_ID:
                goto PassThrough;

            //
            // Fsctl call 49
            //
            // SIS link files are already sparse.
            //

            case FSCTL_SET_SPARSE:
                goto PassThrough;

            //
            // Fsctl call 50
            //
            // This is only partially implemented, for the case where the user opened the
            // file FILE_OPEN_REPARSE_POINT.
            //

            case FSCTL_SET_ZERO_DATA: {
                BOOLEAN openedAsReparse;
                BOOLEAN openedDirty;
                KIRQL OldIrql;

                //
                // Check to see if the file is opened FILE_OPEN_REPARSE_POINT, and fail the request if not.
                //

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (!openedAsReparse) {

                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                //
                // Verify that this file wasn't opened dirty.
                //

                SipAcquireScb(scb);
                openedDirty = (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) ? TRUE : FALSE;
                SipReleaseScb(scb);

                if (openedDirty) {
                    SIS_MARK_POINT();
#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: tried FSCTL_SET_ZERO_DATA on file that was opened dirty.  Failing it.\n");
#endif  // DBG
                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                goto PassThrough;
            }


            //
            // Fsctl call 51
            //
            // Depends on whether the file is opened FILE_OPEN_REPARSE.  Implemented in its own
            // function.
            //

            case FSCTL_QUERY_ALLOCATED_RANGES: {
                BOOLEAN openedAsReparse;
                KIRQL   OldIrql;

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (openedAsReparse) {

                    //
                    // This file was opened as a reparse point, so we just pass it
                    // through and let the real set of allocated ranges show through.
                    //

                    goto PassThrough;

                } else {

                    //
                    // This was a normal open, so call our special routine that will
                    // show the file as a single, allocated chunk.
                    //

                    return SipQueryAllocatedRanges(DeviceObject,Irp);
                }
            }

            //
            // Fsctl call 52 obsolete
            //

            //
            // Fsctl calls 53-56
            //
            // Encrypting a file results in the file being completely
            // overwritten.  SIS files, therefore, will simply COW back
            // to normal if they're encrypted.
            //

            case FSCTL_SET_ENCRYPTION:
            case FSCTL_ENCRYPTION_FSCTL_IO:
            case FSCTL_WRITE_RAW_ENCRYPTED:
            case FSCTL_READ_RAW_ENCRYPTED:
                goto PassThrough;

            //
            // Fsctl call 57
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_CREATE_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 58
            //
            // Returns USN data for a file.
            //

            case FSCTL_READ_FILE_USN_DATA:
                goto PassThrough;

            //
            // Fsctl call 59
            //
            // This call writes a USN record as if the file were closed, and posts
            // any USN updates that were pending a close for this file.  Pass it
            // through on the link file.
            //

            case FSCTL_WRITE_USN_CLOSE_RECORD:
                goto PassThrough;

            //
            // Fsctl call 60
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_EXTEND_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 61
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_QUERY_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 62
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_DELETE_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 63
            //
            // This sets some bits in the CCB related to USN processing
            // for the file.  These bits don't appear to be read by anything
            // in ntfs.
            //

            case FSCTL_MARK_HANDLE:
                goto PassThrough;

            //
            // Fsctl call 64
            //
            // Our very own copyfile request.
            //
            case FSCTL_SIS_COPYFILE:
                return SipFsCopyFile(DeviceObject,Irp);

            //
            // Fsctl call 65
            //
            // The groveler fsctl.  This is valid only on \SIS Common Store\GrovelerFile, which
            // can never be a SIS link.  Fail the request.
            //

            case FSCTL_SIS_LINK_FILES:
                status = STATUS_ACCESS_DENIED;
                goto CompleteWithStatus;

            //
            // Fsctl call 66
            //
            // Something related to HSM.  Not sure what to do with this; just pass it through.
            //

            case FSCTL_HSM_MSG:
                goto PassThrough;

            //
            //  Handle everything else
            //

            default:
#if DBG
                DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                            "SiFsControl with unknown code 0x%x\n",irpSp->Parameters.FileSystemControl.FsControlCode);
                if (BJBDebug & 0x400) {
                    DbgBreakPoint();
                }
#endif  // DBG
                goto PassThrough;
        }

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                FSCTL_SIS_COPYFILE == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipFsCopyFile(DeviceObject,Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                       FSCTL_SIS_LINK_FILES == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipLinkFiles(DeviceObject, Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                       FSCTL_DISMOUNT_VOLUME == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipDismountVolume(DeviceObject, Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                    FSCTL_SET_REPARSE_POINT == irpSp->Parameters.FileSystemControl.FsControlCode) {

        PREPARSE_DATA_BUFFER reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
        ULONG InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Handle a user set of a SIS reparse point.
        //

        if ((NULL == reparseBuffer) || 
                (InputBufferLength < SIS_REPARSE_DATA_SIZE) || 
                (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag)) {

            //
            // This isn't a valid SIS reparse point being set, just pass the call through.
            //

            goto PassThrough;
        }

        status =  SipUserSetSISReparsePoint(DeviceObject, Irp);
        return status;

    } else {

        //
        // Simply pass this file system control request through, we don't need a callback
        //

PassThrough:
        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    // Any special processing has been completed, so simply pass the request
    // along to the next driver.
    //

    return IoCallDriver( devExt->AttachedToDeviceObject, Irp );

/////////////////////////////////////////////////////////////////////////////
//                  Handle status cases
/////////////////////////////////////////////////////////////////////////////

CompleteWithStatus:

    SIS_MARK_POINT_ULONG(status);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

SendToCSFile:
    IoCopyCurrentIrpStackLocationToNext( Irp );

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->FileObject = scb->PerLink->CsFile->UnderlyingFileObject;

    IoSetCompletionRoutine(
                Irp,
                NULL,
                NULL,
                FALSE,
                FALSE,
                FALSE);

    return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sidebug.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sidebug.c

Abstract:

	Various debugging and instrumentation code that isn't used in the product

Authors:

    Bill Bolosky, Summer, 1998

Environment:

    Kernel mode


Revision History:
	June, 1998 - split out of other files


--*/

#include "sip.h"

#if		TIMING
KSPIN_LOCK	SipTimingLock[1];

SIS_TREE	SipTimingPairTree[1];
SIS_TREE	SipThreadLastPointTree[1];

//
// How many timing points are currently in the timing point tree.
//
ULONG		SipTimingPointEntries = 0;

typedef	struct _SIS_TIMING_PAIR_KEY {
	PCHAR							file1;
	ULONG							line1;
	PCHAR							file2;
	ULONG							line2;
} SIS_TIMING_PAIR_KEY, *PSIS_TIMING_PAIR_KEY;

typedef	struct _SIS_TIMING_PAIR {
	RTL_SPLAY_LINKS					Links;

	SIS_TIMING_PAIR_KEY;

	LONGLONG						accumulatedTime;
	LONGLONG						accumulatedSquareTime;
	LONGLONG						maxTime;
	LONGLONG						minTime;
	ULONG							count;

	struct _SIS_TIMING_PAIR			*next;
} SIS_TIMING_PAIR, *PSIS_TIMING_PAIR;

typedef	struct _SIS_THREAD_LAST_POINT_KEY {
	HANDLE							threadId;
} SIS_THREAD_LAST_POINT_KEY, *PSIS_THREAD_LAST_POINT_KEY;

typedef	struct _SIS_THREAD_LAST_POINT {
	RTL_SPLAY_LINKS					Links;

	SIS_THREAD_LAST_POINT_KEY;

	PCHAR							file;
	LONGLONG						time;
	ULONG							line;

	struct _SIS_THREAD_LAST_POINT	*next;
	struct _SIS_THREAD_LAST_POINT	*prev;
} SIS_THREAD_LAST_POINT, *PSIS_THREAD_LAST_POINT;

PSIS_TIMING_PAIR			SipTimingPairStack = NULL;
SIS_THREAD_LAST_POINT		SipThreadLastPointHeader[1];

ULONG	SipEnabledTimingPointSets = MAXULONG;

BOOLEAN		SipTimingInitialized = FALSE;

LONG NTAPI 
SipTimingPairCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_TIMING_PAIR_KEY	key = Key;
	PSIS_TIMING_PAIR		node = Node;

	if (key->file1 < node->file1) return -1;
	if (key->file1 > node->file1) return 1;
	if (key->line1 < node->line1) return -1;
	if (key->line1 > node->line1) return 1;

	if (key->file2 < node->file2) return -1;
	if (key->file2 > node->file2) return 1;
	if (key->line2 < node->line2) return -1;
	if (key->line2 > node->line2) return 1;

	return 0;
}

LONG NTAPI
SipThreadLastPointCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_THREAD_LAST_POINT_KEY	key = Key;
	PSIS_THREAD_LAST_POINT		node = Node;

	if (key->threadId > node->threadId) return -1;
	if (key->threadId < node->threadId) return 1;
	
	return 0;
}


VOID
SiThreadCreateNotifyRoutine(
	IN HANDLE		ProcessId,
	IN HANDLE		ThreadId,
	IN BOOLEAN		Create)
/*++
Routine Description:

	This routine is called whenever any thread is created or deleted in the system.
	We're interested in tracking thread deletions so that we can clean out any
	entries that they might have in the last point list.

Arguments:

	ProcessId - The process in which the created/deleted thread lives.  Unused.
	ThreadId  -	The ID of the newly created/deleted thread
	Create	  - Whether the thread is being created or deleted.

Return Value:

	void

--*/
{
	KIRQL						OldIrql;
	SIS_THREAD_LAST_POINT_KEY	key[1];
	PSIS_THREAD_LAST_POINT		lastPoint;

	if (Create) {
		//
		// We only care about deletes; new threads are handled correctly the first
		// time they execute a SIS_TIMING_POINT.
		//
		return;
	}
	

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	key->threadId = PsGetCurrentThreadId();
	lastPoint = SipLookupElementTree(SipThreadLastPointTree, key);

	if (NULL != lastPoint) {
		SipDeleteElementTree(SipThreadLastPointTree, lastPoint);

		//
		// Remove it from the linked list.
		//
		ASSERT(lastPoint != SipThreadLastPointHeader);

		lastPoint->next->prev = lastPoint->prev;
		lastPoint->prev->next = lastPoint->next;

		//
		// And free its memory.
		//

		ExFreePool(lastPoint);
	}

	KeReleaseSpinLock(SipTimingLock, OldIrql);
}


VOID
SipInitializeTiming()
/*++

Routine Description:

	Initialize the internal timing system structures.  Must be called once
	per system, and must be called before any SIS_TIMING_POINTS are called.

Arguments:

	None

Return Value:

	None

--*/
{
	NTSTATUS	status;

	KeInitializeSpinLock(SipTimingLock);

	SipThreadLastPointHeader->next = SipThreadLastPointHeader->prev = SipThreadLastPointHeader;

	status = PsSetCreateThreadNotifyRoutine(SiThreadCreateNotifyRoutine);

	if (!NT_SUCCESS(status)) {
		//
		// We include this DbgPrint even in free builds on purpose.  TIMING is only
		// going to be turned on when a developer is running, not in the retail build,
		// so this string won't ever get sent to a customer.  However, it makes lots of
		// sense for a developer to want to run the timing on the free build, since it
		// won't have the debugging code timing distortions caused by running checked.
		// That developer probably wants to know if the initialization failed, so I'm
		// leaving this DbgPrint turned on.
		//

		DbgPrint("SIS: SipInitializeTiming: PsSetCreateThreadNotifyRoutine failed, 0x%x\n",status);

		//
		// Just punt without setting SipTimingInitialized.
		//

		return;
	}


	//
	// Set up the splay trees.
	//

	SipInitializeTree(SipTimingPairTree, SipTimingPairCompareRoutine);
	SipInitializeTree(SipThreadLastPointTree, SipThreadLastPointCompareRoutine);

	SipTimingInitialized = TRUE;	
}


VOID
SipTimingPoint(
	IN PCHAR							file,
	IN ULONG							line,
	IN ULONG							n)
/*++

Routine Description:

	An instrumentation routine for measuring performance.  This routine keeps
	track of pairs of timing points for particular threads with associated times,
	and can produce statistics about the amount of (wall clock) time that has
	elapsed between them.

Arguments:

	file - The file holding the timing point.

	line - the line number within the file that has the timing point

	n - the timing point set; these can be enabled and disabled dynamically

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	LARGE_INTEGER				perfTimeIn = KeQueryPerformanceCounter(NULL);	
	LARGE_INTEGER				perfTimeOut;
	SIS_THREAD_LAST_POINT_KEY	lastPointKey[1];
	PSIS_THREAD_LAST_POINT		lastPoint;
	SIS_TIMING_PAIR_KEY			timingPairKey[1];
	PSIS_TIMING_PAIR			timingPair;
	LONGLONG					thisTime;


	if (!SipTimingInitialized) {
		SIS_MARK_POINT();
		return;
	}

	ASSERT(n < 32);
	if (!(SipEnabledTimingPointSets & (1 << n))) {
		//
		// This timing point set isn't enabled.  Just ignore the call.
		//
		return;
	}

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	//
	// Look up the last SIS_TIMING_POINT called by this thread.
	//

	lastPointKey->threadId = PsGetCurrentThreadId();
	lastPoint = SipLookupElementTree(SipThreadLastPointTree, lastPointKey);

	if (NULL == lastPoint) {
		//
		// This is the first timing point for this thread.  Just make a new
		// entry in the tree and continue.
		//

		lastPoint = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_THREAD_LAST_POINT), ' siS');

		if (NULL == lastPoint) {
			//
			// See the comment in SipInitializeTiming for justification of why we have this
			// DbgPrint on even in a free build.
			//
			DbgPrint("SIS: SipTimingPoint: unable to allocate new SIS_THREAD_LAST_POINT.\n");
			goto done;
		}

		lastPoint->threadId = lastPointKey->threadId;

		SipInsertElementTree(SipThreadLastPointTree, lastPoint, lastPointKey);

		//
		// Insert the thread in the global last point linked list.
		//
		lastPoint->next = SipThreadLastPointHeader->next;
		lastPoint->prev = SipThreadLastPointHeader;
		lastPoint->next->prev = lastPoint;
		lastPoint->prev->next = lastPoint;

	} else {
		//
		// This isn't the first time this thread has done a timing point.  Make an
		// entry in the pairs tree.
		//

		thisTime = perfTimeIn.QuadPart - lastPoint->time;

		timingPairKey->file1 = lastPoint->file;
		timingPairKey->line1 = lastPoint->line;
		timingPairKey->file2 = file;
		timingPairKey->line2 = line;

		timingPair = SipLookupElementTree(SipTimingPairTree, timingPairKey);

		if (NULL == timingPair) {
			//
			// This is the first time we've seen this pair of timing points in sequence.
			// Build a new timing pair.
			//

			timingPair = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_TIMING_PAIR), ' siS');

			if (NULL == timingPair) {
				DbgPrint("SIS: SipTimingPoint: couldn't allocate timing pair.\n");
				goto done;
			} else {
				//
				// Initialize the new timing pair entry.
				//
				timingPair->file1 = timingPairKey->file1;
				timingPair->line1 = timingPairKey->line1;
				timingPair->file2 = timingPairKey->file2;
				timingPair->line2 = timingPairKey->line2;

				timingPair->accumulatedTime = 0;
				timingPair->accumulatedSquareTime = 0;
				timingPair->maxTime = 0;
				timingPair->minTime = perfTimeIn.QuadPart - lastPoint->time;

				timingPair->count = 0;

				timingPair->next = SipTimingPairStack;
				SipTimingPairStack = timingPair;

				SipInsertElementTree(SipTimingPairTree, timingPair, timingPairKey);

				SipTimingPointEntries++;
			}
		}

		//
		// Update the statistice in the timing pair.
		//
		timingPair->accumulatedTime += thisTime;
		timingPair->accumulatedSquareTime += thisTime * thisTime;

		if (timingPair->maxTime < thisTime) {
			timingPair->maxTime = thisTime;
		}

		if (timingPair->minTime > thisTime) {
			timingPair->minTime = thisTime;
		}

		timingPair->count++;
	}

done:

	if (NULL != lastPoint) {
		//
		// Finally, update the last point information.  Recheck the time here in
		// order to reduce the interference from the timing function itself.
		//

		lastPoint->file = file;
		lastPoint->line = line;

		perfTimeOut = KeQueryPerformanceCounter(NULL);
		lastPoint->time = perfTimeOut.QuadPart;
	}

	KeReleaseSpinLock(SipTimingLock, OldIrql);

}

VOID
SipClearTimingInfo()
{
	KIRQL					OldIrql;
	PSIS_THREAD_LAST_POINT	lastPoint;

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	//
	// First blow away all of the thread entries.
	//

	lastPoint = SipThreadLastPointHeader->next;
	while (SipThreadLastPointHeader != lastPoint) {
		PSIS_THREAD_LAST_POINT		next = lastPoint->next;

		//
		// Remove it from the tree
		//
		SipDeleteElementTree(SipThreadLastPointTree, lastPoint);

		//
		// Remove it from the linked list.
		//
		lastPoint->next->prev = lastPoint->prev;
		lastPoint->prev->next = lastPoint->next;

		//
		// Free its memory.
		//
		ExFreePool(lastPoint);

		lastPoint = next;
	}

	//
	// Now blow away all of the pair entries.
	//

	while (NULL != SipTimingPairStack) {
		PSIS_TIMING_PAIR		next = SipTimingPairStack->next;

		ASSERT(0 != SipTimingPointEntries);

		SipDeleteElementTree(SipTimingPairTree, SipTimingPairStack);

		ExFreePool(SipTimingPairStack);

		SipTimingPairStack = next;
		SipTimingPointEntries--;
	}

	ASSERT(0 == SipTimingPointEntries);

	KeReleaseSpinLock(SipTimingLock, OldIrql);
}

VOID
SipDumpTimingInfo()
{
	KIRQL				OldIrql;
	LARGE_INTEGER		perfFreq;
	PSIS_TIMING_PAIR	timingPair;

	KeQueryPerformanceCounter(&perfFreq);

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	DbgPrint("File1\tLine1\tFile2\tLine2\taccTime\tatSquared\tmaxTime\tminTime\tcount\n");

	for (timingPair = SipTimingPairStack; NULL != timingPair; timingPair = timingPair->next) {
		DbgPrint("%s\t%d\t%s\t%d\t%I64d\t%I64d\t%I64d\t%I64d\t%d\n",
					timingPair->file1,
					timingPair->line1,
					timingPair->file2,
					timingPair->line2,
					timingPair->accumulatedTime,
					timingPair->accumulatedSquareTime,
					timingPair->maxTime,
					timingPair->minTime,
					timingPair->count);
	}
	
	DbgPrint("performance frequency (in Hertz)\t%I64d\n",perfFreq.QuadPart);
	DbgPrint("%d total entries\n",SipTimingPointEntries);

	KeReleaseSpinLock(SipTimingLock, OldIrql);
	
}
#endif	// TIMING

#if		RANDOMLY_FAILING_MALLOC
#undef  ExAllocatePoolWithTag

#if		COUNTING_MALLOC
#define	ExAllocatePoolWithTag(poolType, size, tag)	SipCountingExAllocatePoolWithTag((poolType),(size),(tag), __FILE__, __LINE__)
#endif	// COUNTING_MALLOC

//
// This is copied from ntos\inc\ex.h
//
#if		!defined(POOL_TAGGING) && !COUNTING_MALLOC
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif	// !POOL_TAGGING && !COUNTING_MALLOC

typedef struct _SIS_FAIL_ENTRY_KEY {
	PCHAR				File;
	ULONG				Line;
} SIS_FAIL_ENTRY_KEY, *PSIS_FAIL_ENTRY_KEY;

typedef struct _SIS_FAIL_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_FAIL_ENTRY_KEY;
	ULONG				count;
	ULONG				Era;
} SIS_FAIL_ENTRY, *PSIS_FAIL_ENTRY;

ULONG				FailFrequency = 30;				// Fail a malloc 1 time in this many
ULONG				FailMallocRandomSeed = 0xb111b010;
ULONG				FailMallocAttemptCount = 0;
ULONG				FailMallocEraSize = 1000;
KSPIN_LOCK			FailMallocLock[1];
SIS_TREE			FailMallocTree[1];
ERESOURCE_THREAD	CurrentFailThread = 0;
FAST_MUTEX			FailFastMutex[1];
#define		FAIL_RANDOM_TABLE_SIZE	1024
ULONG				FailRandomTable[FAIL_RANDOM_TABLE_SIZE];
ULONG				FailRandomTableIndex = FAIL_RANDOM_TABLE_SIZE;
ULONG				IntentionallyFailedMallocs = 0;

VOID
SipFillFailRandomTable(void)
{
	ULONG		i;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ExAcquireFastMutex(FailFastMutex);

	for (i = 0; i < FAIL_RANDOM_TABLE_SIZE && i < FailRandomTableIndex; i++) {
		FailRandomTable[i] = RtlRandom(&FailMallocRandomSeed);
	}
	FailRandomTableIndex = 0;
	ExReleaseFastMutex(FailFastMutex);
}

ULONG
SipGenerateRandomNumber(void)
{
	if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
		//
		// We need to subtract one from the returned TableIndex, because InterlockedIncrement is
		// pre-increment, not post-increment.
		//
		ULONG	tableIndex = InterlockedIncrement(&FailRandomTableIndex) - 1;
		ASSERT(tableIndex != 0xffffffff);

		return(FailRandomTable[tableIndex % FAIL_RANDOM_TABLE_SIZE]);
	}
	SipFillFailRandomTable();
	return RtlRandom(&FailMallocRandomSeed);
}

LONG NTAPI
SipFailMallocCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_FAIL_ENTRY_KEY		key = Key;
	PSIS_FAIL_ENTRY			entry = Node;

	if (entry->File < key->File) return -1;
	if (entry->File > key->File) return 1;
	ASSERT(entry->File == key->File);

	if (entry->Line < key->Line) return -1;
	if (entry->Line > key->Line) return 1;
	ASSERT(entry->Line == key->Line);

	return 0;
}

VOID 
SipInitFailingMalloc(void)
{
	ULONG	i;
	LARGE_INTEGER	time = KeQueryPerformanceCounter(NULL);

	SipInitializeTree(FailMallocTree, SipFailMallocCompareRoutine);
	KeInitializeSpinLock(FailMallocLock);
	ExInitializeFastMutex(FailFastMutex);

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	FailMallocRandomSeed = (ULONG)(time.QuadPart >> 8);	// roughly time since boot in us, which should be fairly random

	SipFillFailRandomTable();

}

VOID *
SipRandomlyFailingExAllocatePoolWithTag(
    IN POOL_TYPE 		PoolType,
    IN ULONG 			NumberOfBytes,
    IN ULONG 			Tag,
	IN PCHAR			File,
	IN ULONG			Line)
{
	KIRQL				OldIrql;
	ERESOURCE_THREAD	threadId = ExGetCurrentResourceThread();
	ULONG				failCount;
	ULONG				attemptCount = InterlockedIncrement(&FailMallocAttemptCount);
	ULONG				randomNumber;

	if ((threadId == CurrentFailThread) || (NonPagedPoolMustSucceed == PoolType)) {
		//
		// This is an internal malloc (ie., the tree package has just called back into us), or it's a must
		// succeed call.  Just let it go.
		//
		return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
	}

	randomNumber = SipGenerateRandomNumber();

	if (0 == (randomNumber % FailFrequency)) {
		PSIS_FAIL_ENTRY		failEntry;
		SIS_FAIL_ENTRY_KEY	failEntryKey[1];

		KeAcquireSpinLock(FailMallocLock, &OldIrql);
		ASSERT(0 == CurrentFailThread);
		CurrentFailThread = threadId;

		//
		// See if we've already failed this one.
		//
		failEntryKey->File = File;
		failEntryKey->Line = Line;

		failEntry = SipLookupElementTree(FailMallocTree, failEntryKey);

		if (NULL == failEntry) {
			failEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_FAIL_ENTRY), ' siS');
			if (NULL == failEntry) {
				//
				// A real malloc failure!  Fail the user's malloc as well.
				//
#if		DBG
				DbgPrint("SIS: SipRandomlyFailingExAllocatePoolWithTag: internal ExAllocatePoolWithTag failed\n");
#endif	// DBG
				CurrentFailThread = 0;

				KeReleaseSpinLock(FailMallocLock, OldIrql);
				return NULL;
			}
			failEntry->File = File;
			failEntry->Line = Line;
			failEntry->Era = attemptCount / FailMallocEraSize;
			failCount = failEntry->count = 1;

			SipInsertElementTree(FailMallocTree, failEntry, failEntryKey);
		} else {
			if (failEntry->Era != attemptCount / FailMallocEraSize) {
				failCount = failEntry->count = 1;
				failEntry->Era = attemptCount / FailMallocEraSize;
			} else {
				failCount = ++failEntry->count;
			}
		}

		CurrentFailThread = 0;
		KeReleaseSpinLock(FailMallocLock, OldIrql);

		//
		// For now, don't fail a request from a specific site twice.
		//
		if (failCount == 1) {
#if		DBG
			if (!(BJBDebug & 0x02000000)) {
				DbgPrint("SIS: SipRandomlyFailingExAllocatePoolWithTag: failing malloc from file %s, line %d, size %d\n",File,Line,NumberOfBytes);
			}
#endif	// DBG
			SIS_MARK_POINT_ULONG(File);
			SIS_MARK_POINT_ULONG(Line);

			InterlockedIncrement(&IntentionallyFailedMallocs);

			return NULL;
		}
	}

	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}
//
// WARNING: ExAllocatePoolWithTag called later in this file will not have randomly failing behavior.
//
#endif	// RANDOMLY_FAILING_MALLOC

#if		COUNTING_MALLOC
//
// The counting malloc code must follow the randomly failing malloc code in the file, because of
// macro redefinitions. 
//

#undef	ExAllocatePoolWithTag
#undef	ExFreePool
//
// This is copied from ntos\inc\ex.h
//
#if		!defined(POOL_TAGGING)
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif	// !POOL_TAGGING

typedef struct _SIS_COUNTING_MALLOC_CLASS_KEY {
	POOL_TYPE										poolType;
	ULONG											tag;
	PCHAR											file;
	ULONG											line;
} SIS_COUNTING_MALLOC_CLASS_KEY, *PSIS_COUNTING_MALLOC_CLASS_KEY;

typedef struct _SIS_COUNTING_MALLOC_CLASS_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_COUNTING_MALLOC_CLASS_KEY;
	ULONG											numberOutstanding;
	ULONG											bytesOutstanding;
	ULONG											numberEverAllocated;
	LONGLONG										bytesEverAllocated;
	struct _SIS_COUNTING_MALLOC_CLASS_ENTRY			*prev, *next;
} SIS_COUNTING_MALLOC_CLASS_ENTRY, *PSIS_COUNTING_MALLOC_CLASS_ENTRY;

typedef struct _SIS_COUNTING_MALLOC_KEY {
	PVOID				p;
} SIS_COUNTING_MALLOC_KEY, *PSIS_COUNTING_MALLOC_KEY;

typedef struct _SIS_COUNTING_MALLOC_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_COUNTING_MALLOC_KEY;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY		classEntry;
	ULONG									byteCount;
} SIS_COUNTING_MALLOC_ENTRY, *PSIS_COUNTING_MALLOC_ENTRY;

KSPIN_LOCK							CountingMallocLock[1];
BOOLEAN								CountingMallocInternalFailure = FALSE;
SIS_COUNTING_MALLOC_CLASS_ENTRY		CountingMallocClassListHead[1];
SIS_TREE							CountingMallocClassTree[1];
SIS_TREE							CountingMallocTree[1];

LONG NTAPI
SipCountingMallocClassCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_COUNTING_MALLOC_CLASS_KEY		key = Key;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	entry = Node;

	if (key->poolType > entry->poolType)	return 1;
	if (key->poolType < entry->poolType)	return -1;
	ASSERT(key->poolType == entry->poolType);

	if (key->tag > entry->tag)				return 1;
	if (key->tag < entry->tag)				return -1;
	ASSERT(key->tag == entry->tag);

	if (key->file > entry->file)	return 1;
	if (key->file < entry->file)	return -1;
	ASSERT(key->file == entry->file);

	if (key->line > entry->line)	return 1;
	if (key->line < entry->line)	return -1;
	ASSERT(key->line == entry->line);

	return 0;
}

LONG NTAPI
SipCountingMallocCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_COUNTING_MALLOC_KEY	key = Key;
	PSIS_COUNTING_MALLOC_ENTRY	entry = Node;

	if (key->p < entry->p)	return 1;
	if (key->p > entry->p)	return -1;
	ASSERT(key->p == entry->p);

	return 0;
}

VOID *
SipCountingExAllocatePoolWithTag(
    IN POOL_TYPE 		PoolType,
    IN ULONG 			NumberOfBytes,
    IN ULONG 			Tag,
	IN PCHAR			File,
	IN ULONG			Line)
{
	PVOID								memoryFromExAllocate;
	KIRQL								OldIrql;
	SIS_COUNTING_MALLOC_CLASS_KEY		classKey[1];
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	classEntry;
	SIS_COUNTING_MALLOC_KEY				key[1];
	PSIS_COUNTING_MALLOC_ENTRY			entry;
	//
	// First do the actual malloc
	//

	memoryFromExAllocate = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);

	if (NULL == memoryFromExAllocate) {
		//
		// We're out of memory.  Punt.
		//
		SIS_MARK_POINT();
		return NULL;
	}

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);
	//
	// See if we already have a class entry for this tag/poolType pair.
	//
	classKey->tag = Tag;
	classKey->poolType = PoolType;
	classKey->file = File;
	classKey->line = Line;

	classEntry = SipLookupElementTree(CountingMallocClassTree, classKey);
	if (NULL == classEntry) {
		//
		// This is the first time we've seen a malloc of this class.
		//
		classEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_COUNTING_MALLOC_CLASS_ENTRY), ' siS');
		if (NULL == classEntry) {
			SIS_MARK_POINT();
			CountingMallocInternalFailure = TRUE;
			KeReleaseSpinLock(CountingMallocLock, OldIrql);
			return memoryFromExAllocate;
		}

		//
		// Fill in the new class entry.
		//
		classEntry->tag = Tag;
		classEntry->poolType = PoolType;
		classEntry->file = File;
		classEntry->line = Line;
		classEntry->numberOutstanding = 0;
		classEntry->bytesOutstanding = 0;
		classEntry->numberEverAllocated = 0;
		classEntry->bytesEverAllocated = 0;

		//
		// Put it in the tree of classes.
		//

		SipInsertElementTree(CountingMallocClassTree, classEntry, classKey);

		//
		// And put it in the list of classes.
		//

		classEntry->prev = CountingMallocClassListHead;
		classEntry->next = CountingMallocClassListHead->next;
		classEntry->prev->next = classEntry->next->prev = classEntry;
	}

	//
	// Roll up an entry for the pointer.
	//
	entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_COUNTING_MALLOC_ENTRY), ' siS');

	if (NULL == entry) {
		CountingMallocInternalFailure = TRUE;
		KeReleaseSpinLock(CountingMallocLock, OldIrql);
		return memoryFromExAllocate;
	}

	//
	// Update the stats in the class.
	//
	classEntry->numberOutstanding++;
	classEntry->bytesOutstanding += NumberOfBytes;
	classEntry->numberEverAllocated++;
	classEntry->bytesEverAllocated += NumberOfBytes;

	//
	// Fill in the pointer entry.
	//
	entry->p = memoryFromExAllocate;
	entry->classEntry = classEntry;
	entry->byteCount = NumberOfBytes;

	//
	// Stick it in the tree.
	//
	key->p = memoryFromExAllocate;
	SipInsertElementTree(CountingMallocTree, entry, key);
	
	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	return memoryFromExAllocate;
}

VOID
SipCountingExFreePool(
	PVOID				p)
{
	SIS_COUNTING_MALLOC_KEY				key[1];
	PSIS_COUNTING_MALLOC_ENTRY			entry;
	KIRQL								OldIrql;

	key->p = p;

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);

	entry = SipLookupElementTree(CountingMallocTree, key);
	if (NULL == entry) {
		//
		// We may have failed to allocate the entry because of an
		// internal failure in the counting package, or else we're
		// freeing memory that was allocated by another system
		// component, like the SystemBuffer in an irp.
		//
	} else {
		//
		// Update the stats in the class.
		//
		ASSERT(entry->classEntry->numberOutstanding > 0);
		entry->classEntry->numberOutstanding--;

		ASSERT(entry->classEntry->bytesOutstanding >= entry->byteCount);
		entry->classEntry->bytesOutstanding -= entry->byteCount;

		//
		// Remove the entry from the tree
		//
		SipDeleteElementTree(CountingMallocTree, entry);

		//
		// And free it
		//
		ExFreePool(entry);
	}

	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	//
	// Free the caller's memory
	//

	ExFreePool(p);
}

VOID
SipInitCountingMalloc(void)
{
	KeInitializeSpinLock(CountingMallocLock);

	CountingMallocClassListHead->next = CountingMallocClassListHead->prev = CountingMallocClassListHead;

	SipInitializeTree(CountingMallocClassTree, SipCountingMallocClassCompareRoutine);
	SipInitializeTree(CountingMallocTree, SipCountingMallocCompareRoutine);
}

VOID
SipDumpCountingMallocStats(void)
{
	KIRQL								OldIrql;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	classEntry;
	ULONG								totalAllocated = 0;
	ULONG								totalEverAllocated = 0;
	ULONG								totalBytesAllocated = 0;
	ULONG								totalBytesEverAllocated = 0;
	extern ULONG						BJBDumpCountingMallocNow;

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);

	if (0 == BJBDumpCountingMallocNow) {
		KeReleaseSpinLock(CountingMallocLock, OldIrql);
		return;
	}

	BJBDumpCountingMallocNow = 0;

	DbgPrint("Tag\tFile\tLine\tPoolType\tCountOutstanding\tBytesOutstanding\tTotalEverAllocated\tTotalBytesAllocated\n");

	for (classEntry = CountingMallocClassListHead->next;
		 classEntry != CountingMallocClassListHead;
		 classEntry = classEntry->next) {

		DbgPrint("%c%c%c%c\t%s\t%d\t%s\t%d\t%d\t%d\t%d\n",
					(CHAR)(classEntry->tag >> 24),
					(CHAR)(classEntry->tag >> 16),
					(CHAR)(classEntry->tag >> 8),
					(CHAR)(classEntry->tag),
					classEntry->file,
					classEntry->line,
					(classEntry->poolType == NonPagedPool) ? "NonPagedPool" : ((classEntry->poolType == PagedPool) ? "PagedPool" : "Other"),
					classEntry->numberOutstanding,
					classEntry->bytesOutstanding,
					classEntry->numberEverAllocated,
					(ULONG)classEntry->bytesEverAllocated);

		totalAllocated += classEntry->numberOutstanding;
		totalEverAllocated += classEntry->numberEverAllocated;
		totalBytesAllocated += classEntry->bytesOutstanding;
		totalBytesEverAllocated += (ULONG)classEntry->bytesEverAllocated;
	}

	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	DbgPrint("%d objects, %d bytes currently allocated.   %d objects, %d bytes ever allocated.\n",
				totalAllocated,totalBytesAllocated,totalEverAllocated,totalBytesEverAllocated);
	
}
#endif	// COUNTING_MALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sifastio.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sifastio.c

Abstract:

	Fast IO routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:

--*/

#include "sip.h"

BOOLEAN scEnableFastIo = FALSE;

//
//  Macro to test if FASI_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))


//
//  Pragma definitions
//

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SiFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SiFastIoRead)
#pragma alloc_text(PAGE, SiFastIoLock)
#pragma alloc_text(PAGE, SiFastIoUnlockSingle)
#pragma alloc_text(PAGE, SiFastIoUnlockAll)
#pragma alloc_text(PAGE, SiFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SiFastIoDeviceControl)
#pragma alloc_text(PAGE, SiFastIoDetachDevice)
#pragma alloc_text(PAGE, SiFastIoMdlRead)
#pragma alloc_text(PAGE, SiFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SiFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, SiFastIoReadCompressed)
#pragma alloc_text(PAGE, SiFastIoWriteCompressed)
#pragma alloc_text(PAGE, SiFastIoQueryOpen)
#endif	// ALLOC_PRAGMA



BOOLEAN
SiFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {
            PSIS_PER_FILE_OBJECT        perFO;
            PSIS_SCB                    scb;
	        PFILE_OBJECT				FileObjectForNTFS;
	        BOOLEAN						UpdateCurrentByteOffset;
	        BOOLEAN						worked;
		    SIS_RANGE_DIRTY_STATE		dirtyState;

            //
            //  See if this is an SIS'd file
            //

	        if (SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                //
                //  For now this is always FALSE so we are never doing this path
                //

		        if (!scEnableFastIo) {

			        return FALSE;
		        }

		        SIS_MARK_POINT_ULONG(scb);

                //
                // SipGetRangeDirty can block.
                //

		        if (Wait) {

		            return FALSE;
		        }

		        SipAcquireScb(scb);

		        //
		        // This is a synchronous user cached read, and we don't have to check for
		        // locks or oplocks.  Figure out which file object to send it down on and
		        // then forward the request to NTFS.  
		        //

		        dirtyState = SipGetRangeDirty(
						        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
						        scb,
						        FileOffset,
						        Length,
						        TRUE);			// FaultedIsDirty

		        //
		        //  We never have to update the faulted ranges on this call,
		        //  because this isn't a pagingIO read, so it won't put stuff
		        //  into the faulted area.  On the other hand, this can
		        //  generate a page fault, which will in turn put something into
		        //  the faulted area, but that gets handled by the mainline
		        //  SipCommonRead code.
		        //

		        SipReleaseScb(scb);

		        if (dirtyState == Mixed) {
			        //
			        // Take the slow path.
			        //

			        return FALSE;
		        }

		        if (dirtyState == Dirty) {
			        //
			        // The range is dirty, so we want to go to the copied file, which
			        // is the file we're called with.
			        //

			        FileObjectForNTFS = FileObject;
			        UpdateCurrentByteOffset = FALSE;

		        } else {
			        //
			        // The range is clean, so we want to go to the CS file.  Switch it
			        // here.
			        //
			
			        FileObjectForNTFS = scb->PerLink->CsFile->UnderlyingFileObject;
			        UpdateCurrentByteOffset = TRUE;
		        }

		        worked = (fastIoDispatch->FastIoRead)(
		                        FileObjectForNTFS,
                                FileOffset,
                                Length,
                                Wait,
                                LockKey,
                                Buffer,
                                IoStatus,
                                nextDeviceObject);

		        if (worked 
			        && UpdateCurrentByteOffset
			        && (IoStatus->Status == STATUS_SUCCESS ||
				        IoStatus->Status == STATUS_BUFFER_OVERFLOW ||
				        IoStatus->Status == STATUS_END_OF_FILE)) {
			        //
			        // The fast read worked, and we revectored it to a different
			        // file object, so we need to update the CurrentByteOffset.
			        //

			        FileObject->CurrentByteOffset.QuadPart = 
				        FileOffset->QuadPart + IoStatus->Information;
		        }

		        SIS_MARK_POINT_ULONG(scb);

                return worked;

	        } else {

                return (fastIoDispatch->FastIoRead)(
                            FileObject,
                            FileOffset,
                            Length,
                            Wait,
                            LockKey,
                            Buffer,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB				scb;
	        KIRQL					OldIrql;

            //
            //  See if this is an SIS'd file
            //

	        if (SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                //
                //  For now this is always FALSE so we are never doing this path
                //

                if (!scEnableFastIo) {

                    return FALSE;
                }
        
                SIS_MARK_POINT_ULONG(scb);

                //
                // SipAddRangeToFaultedList may block.
                //
		        if (Wait) {

                    return FALSE;
		        }

		        //
		        // Send the write down to the underlying filesystem.  We always
		        // send it on the same file object we got, because writes always
		        // go to the copied file, not the common store file.
		        //

		        SIS_MARK_POINT();

		        if (!(fastIoDispatch->FastIoWrite)(
					        FileObject,
					        FileOffset,
					        Length,
					        Wait,
					        LockKey,
					        Buffer,
					        IoStatus,
					        nextDeviceObject)) {

			        SIS_MARK_POINT();

#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: SiFastIoWrite failed, %#x\n", IoStatus->Status);
#endif
			        //
			        // It didn't work, so the call to us also didn't work.
			        //

			        return FALSE;
		        }

		        SIS_MARK_POINT();

		        //
		        // We need to update the written range to include the newly written area.
		        //

		        SipAcquireScb(scb);

		        SipAddRangeToFaultedList(
				        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
				        scb,
				        FileOffset,
				        IoStatus->Information);

		        SipReleaseScb(scb);

		        KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
		        scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
		        KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

		        return TRUE;

	        } else {

                return (fastIoDispatch->FastIoWrite)(
                            FileObject,
                            FileOffset,
                            Length,
                            Wait,
                            LockKey,
                            Buffer,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {
        	PSIS_PER_FILE_OBJECT		perFO;
        	PSIS_SCB					scb;
	        BOOLEAN                     fixItUp = FALSE;
	        KIRQL                       OldIrql;

	        if (SipIsFileObjectSIS(FileObject, DeviceObject, FindActive, &perFO, &scb)) {

		        KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

			    //
			    // It's a SIS file and it wasn't opened as a reparse point, 
			    // we need to fix up the result.
			    //

		        fixItUp = (!(perFO->Flags & SIS_PER_FO_OPEN_REPARSE));

		        KeReleaseSpinLock(perFO->SpinLock, OldIrql);
	        }

            //
            //  Make the call, return if it failed
            //

            if (!(fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject )) {

		        return FALSE;
	        }

            //
            //  It was successful, remove the REPARSE and SPARSE information
            //

	        if (fixItUp) {

		        ASSERT(NULL != Buffer);
		        Buffer->FileAttributes &= ~(FILE_ATTRIBUTE_REPARSE_POINT|FILE_ATTRIBUTE_SPARSE_FILE);

		        if (0 == Buffer->FileAttributes) {

			        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
		        }
	        }

            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					worked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if (!GCHEnableFastIo && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoLock)(
                                    FileObject,
                                    FileOffset,
                                    Length,
                                    ProcessId,
                                    Key,
                                    FailImmediately,
                                    ExclusiveLock,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        SipAcquireScb(scb);

	        //
	        //  Now call the FsRtl routine to do the actual processing of the
	        //  Lock request
	        //
	        worked = FsRtlFastLock(&scb->FileLock,
					          FileObject,
					          FileOffset,
					          Length,
					          ProcessId,
					          Key,
					          FailImmediately,
					          ExclusiveLock,
					          IoStatus,
					          NULL,
					          FALSE);

	        SipReleaseScb(scb);

	        return worked;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if ((!GCHEnableFastIo) && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoUnlockSingle)(
                                    FileObject,
                                    FileOffset,
                                    Length,
                                    ProcessId,
                                    Key,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);
	
	        SipAcquireScb(scb);

	        //
            //  Now call the FsRtl routine to do the actual processing of the
            //  Lock request.  The call will always succeed.
	        //

	        IoStatus->Information = 0;
            IoStatus->Status = FsRtlFastUnlockSingle(&scb->FileLock,
											         FileObject,
											         FileOffset,
											         Length,
											         ProcessId,
											         Key,
											         NULL,
											         FALSE);

	        SipReleaseScb(scb);

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {
	            PSIS_PER_FILE_OBJECT	perFO;
	            PSIS_SCB 				scb;
	            BOOLEAN					calldownWorked;
	            BOOLEAN					isSISFile;

	            isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	            if ((!GCHEnableFastIo) && isSISFile) {

		            return FALSE;
	            }

                calldownWorked = (fastIoDispatch->FastIoUnlockAll)(
                                        FileObject,
                                        ProcessId,
                                        IoStatus,
                                        nextDeviceObject );

	            if (!calldownWorked || !isSISFile) {

		            return calldownWorked;
	            }

	            SIS_MARK_POINT_ULONG(scb);

	            //		
	            //  Acquire exclusive access to the scb this operation can always wait
	            //

	            SipAcquireScb(scb);

                //  Now call the FsRtl routine to do the actual processing of the
                //  Lock request.  The call will always succeed.

                IoStatus->Status = FsRtlFastUnlockAll(&scb->FileLock,
										              FileObject,
										              ProcessId,
										              NULL);
		
	            SipReleaseScb(scb);

	            return TRUE;
            }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if ((!GCHEnableFastIo) && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoUnlockAllByKey)(
                                    FileObject,
                                    ProcessId,
                                    Key,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        //
	        //  Acquire exclusive access to the scb this operation can always wait
	        //

	        SipAcquireScb(scb);

            //  Now call the FsRtl routine to do the actual processing of the
            //  Lock request.  The call will always succeed.

            IoStatus->Status = FsRtlFastUnlockAllByKey(&scb->FileLock,
											           FileObject,
											           ProcessId,
											           Key,
											           NULL);

	        SipReleaseScb(scb);

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->FastIoDeviceControl)(
                            FileObject,
                            Wait,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            IoControlCode,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


VOID
SiFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    //
    //  Display name information
    //

#if DBG 
    {
        PDEVICE_EXTENSION devExt = SourceDevice->DeviceExtension;

        SipCacheDeviceName( SourceDevice );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Detaching from volume          \"%wZ\"\n",
                    &devExt->Name );
    }
#endif

    //
    //  Detach from the file system's volume device object.
    //

    IoDetachDevice( TargetDevice );
    SipCleanupDeviceExtension( SourceDevice );
    IoDeleteDevice( SourceDevice );
}


BOOLEAN
SiFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {
	        PSIS_PER_FILE_OBJECT		perFO;
	        PSIS_SCB					scb;
	        BOOLEAN						fixItUp = FALSE;
	        KIRQL						OldIrql;

	        if (SipIsFileObjectSIS(FileObject, DeviceObject, FindActive, &perFO, &scb)) {

		        KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

			    //
			    // It's a SIS file and it wasn't opened as a reparse point, we need to fix up
			    // the result.
			    //

		        fixItUp = (!(perFO->Flags & SIS_PER_FO_OPEN_REPARSE));

		        KeReleaseSpinLock(perFO->SpinLock, OldIrql);
	        }

            if (!(fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject )) {

                return FALSE;   // The fastIO failed, so pass the failure up.
            }

            //
            //  It was successful, remove the REPARSE and SPARSE information
            //

	        if (fixItUp) {

		        ASSERT(NULL != Buffer);
		        Buffer->FileAttributes &= ~(FILE_ATTRIBUTE_REPARSE_POINT|FILE_ATTRIBUTE_SPARSE_FILE);

		        if (0 == Buffer->FileAttributes) {

			        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
		        }
	        }

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB				scb;
	        SIS_RANGE_DIRTY_STATE	dirtyState;

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {
                return (fastIoDispatch->MdlRead)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        if (!GCHEnableFastIo) {

		        return FALSE;
	        }

	        SipAcquireScb(scb);

	        dirtyState = SipGetRangeDirty(
					        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					        scb,
					        FileOffset,
					        Length,
					        TRUE);			// FaultedIsDirty

	        SipReleaseScb(scb);

	        if (dirtyState == Clean) {

                return (fastIoDispatch->MdlRead)(
                            scb->PerLink->CsFile->UnderlyingFileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {
	        PSIS_PER_FILE_OBJECT	perFO;
            PSIS_SCB                scb;

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                return (fastIoDispatch->MdlReadComplete)(
                            FileObject,
                            MdlChain,
                            nextDeviceObject );
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        if (!GCHEnableFastIo) {

		        return FALSE;
	        }

            return (fastIoDispatch->MdlReadComplete)(
                        scb->PerLink->CsFile->UnderlyingFileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->PrepareMdlWrite)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->MdlWriteComplete)(
                            FileObject,
                            FileOffset,
                            MdlChain,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast Io routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


BOOLEAN
SiFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->FastIoReadCompressed)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            Buffer,
                            MdlChain,
                            IoStatus,
                            CompressedDataInfo,
                            CompressedDataInfoLength,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

        	if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {
                return (fastIoDispatch->FastIoWriteCompressed)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            Buffer,
                            MdlChain,
                            IoStatus,
                            CompressedDataInfo,
                            CompressedDataInfoLength,
                            nextDeviceObject );
        	}

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
            return result;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\filter\sicreate.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sicreate.c

Abstract:

	Create file handling for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

typedef struct _SIS_CREATE_COMPLETION_CONTEXT {
	//
	// An event set by the completion routine once the irp is completed.
	//
	KEVENT				event[1];

	//
	// The completion status of the request.
	//
	IO_STATUS_BLOCK		Iosb[1];

	//
	// This is set if the completion routine returned STATUS_SUCCESS and allowed
	// the irp to finish complete processing.  It is FALSE if the caller needs to
	// complete the irp again.
	//
	BOOLEAN				completeFinished;

	//
	// Was the FILE_OPEN_REPARSE_POINT flag set in the original open request?
	//
	BOOLEAN				openReparsePoint;

	//
	// Was the create disposition supersede, overwrite or overwrite_if?
	//
	BOOLEAN				overwriteOrSupersede;

	//
	// Was this an open of an alternate stream of a SIS reparse point?
	//
	BOOLEAN				alternateStream;

	//
	// The index values for the link.  These are retrieved by the
	// completion routine.
	//

	CSID				CSid;
	LINK_INDEX			LinkIndex;

    //
    // The link file's id is stored in the reparse point info to avoid having
    // to call ntfs to get it.
    //

    LARGE_INTEGER       LinkFileNtfsId;

    //
    // The common store file is opened via its file id.
    //

    LARGE_INTEGER       CSFileNtfsId;

} SIS_CREATE_COMPLETION_CONTEXT, *PSIS_CREATE_COMPLETION_CONTEXT;

NTSTATUS
SiCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SiCreateCompletionStage2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SipWaitForFinalCopy(
	IN PSIS_PER_LINK	perLink,
	IN BOOLEAN			FinalCopyInProgress);

typedef struct _SI_DEREF_FILE_OBJECT_WORK_CONTEXT {
	WORK_QUEUE_ITEM				workQueueItem[1];
	PFILE_OBJECT				fileObject;
} SI_DEREF_FILE_OBJECT_WORK_CONTEXT, *PSI_DEREF_FILE_OBJECT_WORK_CONTEXT;

VOID
SiDerefFileObjectWork(
	IN PVOID			parameter)
/*++

Routine Description:

	A worker thread routine to drop an object reference.  Takes a pointer
	to a context record that in turn holds a pointer to the file object
	to dereference.  Dereferences the object and frees the context.

Arguments:

	parameter - the SI_DEREF_FILE_OBJECT_WORK_CONTEXT for this work item.

Return Value:

	void

--*/
{
	PSI_DEREF_FILE_OBJECT_WORK_CONTEXT		context = parameter;

	SIS_MARK_POINT_ULONG(context->fileObject);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SiDerefFileObjectWork: fo %p\n",context->fileObject);
	}
#endif	// DBG

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ObDereferenceObject(context->fileObject);
	ExFreePool(context);

}



NTSTATUS
SiOplockBreakNotifyCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
/*++

Routine Description:

	Someone had a complete-if-oplocked create finish indicating that there was
	an oplock break in progress.  We sent down an FSCTL_OPLOCK_BREAK_NOTIFY irp
	in order to see when the oplock break completes so that we'll know that we
	don't have block CS file reads.

	The FSCTL has now completed, and this is the completion routine.  Indicate
	that the oplock break is complete, wake up anyone who might be waiting,
	free the irp and return STATUS_MORE_PROCESSING_REQUIRED so that the IO system
	doesn't go nuts with an irp that doesn't have anything above SIS.

	In order to assure that the file object doesn't get deallocated while the fsctl
	is outstanding, we took a reference to it before we launched the fsctl.  We
	need to drop that reference here; if we're not called at PASSIVE_LEVEL we can't
	do that, so we may have to post the dereference.

Arguments:
v	DeviceObject	- our device object

	irp				- the create irp, which contains the create request in the
					  current stack location.

	context			- a PVOID cast of the perFO.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSIS_PER_FILE_OBJECT		perFO = Context;
    KIRQL						OldIrql;

    UNREFERENCED_PARAMETER( DeviceObject );
	SIS_MARK_POINT_ULONG(perFO);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SiOplockBreakNotifyCompletion: perFO %p, fileObject %p\n",perFO,perFO->fileObject);
	}
#endif	// DBG

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
	ASSERT(perFO->Flags & SIS_PER_FO_OPBREAK);
	perFO->Flags &= ~SIS_PER_FO_OPBREAK;

	if (perFO->Flags & SIS_PER_FO_OPBREAK_WAITERS) {
		perFO->Flags &= ~SIS_PER_FO_OPBREAK_WAITERS;

		ASSERT(perFO->BreakEvent);
		KeSetEvent(perFO->BreakEvent, IO_NO_INCREMENT, FALSE);
	}
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	if (PASSIVE_LEVEL != OldIrql) {
		//
		// We were called at raised IRQL, so we can't drop the reference that
		// we hold to the file object.  Post a work item to do that.
		//
		PSI_DEREF_FILE_OBJECT_WORK_CONTEXT	context;

		SIS_MARK_POINT_ULONG(perFO);

		context = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREF_FILE_OBJECT_WORK_CONTEXT), ' siS');
		if (NULL == context) {
			//
			// Too bad, dribble it.
			//
			SIS_MARK_POINT_ULONG(perFO);

#if		DBG
			if (BJBDebug & 0x2000) {
				DbgPrint("SIS: SiOplockBreakNotifyCompletion: dribbling FO: perFO %x, fo %x\n",perFO,perFO->fileObject);
			}
#endif	// DBG

		} else {

#if		DBG
			if (BJBDebug & 0x2000) {
				DbgPrint("SIS: SiOplockBreakNotifyCompletion: pushing off level: perFO %x, fo %x\n",perFO,perFO->fileObject);
			}
#endif	// DBG

			ExInitializeWorkItem(
				context->workQueueItem,
				SiDerefFileObjectWork,
				(PVOID)context);

			context->fileObject = perFO->fileObject;

			ExQueueWorkItem(context->workQueueItem,CriticalWorkQueue);
		}
		
	} else {
		//
		// We're already at PASSIVE_LEVEL and so can dereference the object inline.
		//
		ObDereferenceObject(perFO->fileObject);
	}

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SiUnopenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

	SIS has decicided to back out the open of a file object; to do that it
	sends down a cleanup and close to NTFS.  Either the cleanup or close has
	completed.  Since we use the same IRP that the original create came down
	on, we need to stop the completion processing.  Clear out pending, set
	an event to restart the calling thread and return 
	STATUS_MORE_PROCESSING_REQUIRED.

Arguments:
	DeviceObject	- our device object

	irp				- the create irp, which we're using for the cleanup/close

	context			- pointer to an event to set

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT		event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );

	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SipUnopenFileObject(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp)
/*++

Routine Description:

	NTFS has successfully completed a create on a file, but we haven't yet
	let the irp bubble up to the IO system.  For some reason, we have decided
	that we need to fail the irp, so we have to back NTFS out of the
	idea that the file's open.  To that end, we send down a cleanup and then
	a close on the file.

Arguments:
	DeviceObject	- our device object

	irp				- the create irp, which contains the create request in the
					  current stack location.

Return Value:

	void; if this fails, we just have to ignore it, because we're out of options.

--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION		nextIrpSp = IoGetNextIrpStackLocation(Irp);
	KEVENT					event[1];
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

	ASSERT(IRP_MJ_CREATE == irpSp->MajorFunction);
	ASSERT(NULL != irpSp->FileObject);

	SIS_MARK_POINT_ULONG(irpSp->FileObject);

#if		DBG
///*BJB*/	DbgPrint("SIS: SipUnopenFile object: unopening file object at 0x%x on irp 0x%x\n",irpSp->FileObject,Irp);
#endif	// DBG

	KeInitializeEvent(event, NotificationEvent, FALSE);

	//
	// First, send down the cleanup.
	//

    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

	nextIrpSp->MajorFunction = IRP_MJ_CLEANUP;
	nextIrpSp->MinorFunction = 0;

	IoSetCompletionRoutine(
		Irp,
		SiUnopenCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// If the cleanup failed, then don't try to send down the close.
		// We'll just dribble the file, because we're plain out of options.
		//

		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
		DbgPrint("SIS: SipUnopenFileObject, cleanup failed 0x%x on file object 0x%x\n",
					Irp->IoStatus.Status, irpSp->FileObject);
#endif	// DBG

		return;
	}

	//
	// Now, send down the close.
	//
	
    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

	nextIrpSp->MajorFunction = IRP_MJ_CLOSE;
	nextIrpSp->MinorFunction = 0;

	IoSetCompletionRoutine(
		Irp,
		SiUnopenCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

#if		DBG
	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// I don't think closes can fail, but just in case...
		//
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

		DbgPrint("SIS: SipUnopenFileObject, close failed 0x%x on file object 0x%x (!)\n",
					Irp->IoStatus.Status, irpSp->FileObject);
	}
#endif	//DBG

	return;
}

BOOLEAN
SipDoesFileObjectDescribeAlternateStream(
	IN PUNICODE_STRING					fileName,
	IN PFILE_OBJECT						relatedFileObject,
	IN PDEVICE_OBJECT					DeviceObject)
/*++

Routine Description:

	Figure out whether this file object describes an alternate stream
	or the unnamed data stream.  This function can only be called on file
	objects that have not yet completed the create process, because it looks
	at the fileObject->FileName field which is only guaranteed to be
	meaningful in that case.

	This works by parsing the file name, looking for ':' characters in the
	terminal part of the path name (ie., after the final '\').

	If the file name is empty, is checks the relatedFileObject.  In this case,
	we are opening an alternate stream iff the related file object is not a SIS
	file object.  NB: This assumes that the newly opened file object has a SIS
	reparse point on it.  If it doesn't, then we may return FALSE when we should
	say TRUE.  Caveat Emptor!

Arguments:

	fileName - The name used to open the file.

	relatedFileObject - The related file object used to open the file.

	DeviceObject - the SIS device object.

Return Value:

	TRUE if the file object describes an alternate stream, FALSE otherwise.

--*/

{
	LONG					index;
	LONG					firstColonIndex = -1;

	if (0 == fileName->Length) {
		
		//
		// This is probably a relative open using the empty file name, esstentially opening the
		// same file as the related file object.  Since we know this reparse point
		//
		PSIS_PER_FILE_OBJECT		perFO;
		PSIS_SCB					scb;

		if (NULL == relatedFileObject) {
			//
			// There's no file name and no related file object.  It's strange that
			// this open worked at all.
			//

			SIS_MARK_POINT();
			return FALSE;
		}

		return !SipIsFileObjectSIS(relatedFileObject, DeviceObject, FindActive, &perFO, &scb);

	}

	for (index = fileName->Length / sizeof(WCHAR) - 1;
		 index >= 0;
		 index--) {

		if ('\\' == fileName->Buffer[index]) {
			break;
		}
		if (':' == fileName->Buffer[index]) {
			if (-1 == firstColonIndex) {
				//
				// This is the first colon we've seen.  Just remember where it is.
				//
				firstColonIndex = index;
			} else {
				//
				// We've now seen two colons.  If they're next to one another,
				// this is the unnamed stream.  If they're not, this is a named
				// stream.
				//
				ASSERT(index < firstColonIndex);

				if (index + 1 == firstColonIndex) {
					//
					// We saw "::", which means this is the unnamed stream.
					//
					return FALSE;
				} else {
					//
					// We saw  ":streamName:", which means this is a named stream.
					//
					return TRUE;
				}
			}
		}
	}

	if (-1 != firstColonIndex) {
		//
		// We saw a colon.  If it's not the last character of the file name, this is
		// an alternate stream.
		//
		if (firstColonIndex != (LONG)(fileName->Length / sizeof(WCHAR) - 1)) {
			//
			// It was "something:somethingElse" where somethingElse is not the empty
			// string.  It's an alternate stream.
			//
			return TRUE;
		}
	}

	return FALSE;

}

NTSTATUS
SiCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful; if
	the user is trying to open with FILE_OPEN_REPARSE_POINT, it clears the
	flag and uses a special complete routine, in order to prevent users from
	opening SIS reparse points (while allowing opening of other reparse points).

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
	CHAR							reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define	reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
	CSID							newCSid;
    FILE_INTERNAL_INFORMATION		internalInfo[1];
	LINK_INDEX						newLinkIndex;
	LARGE_INTEGER					newCSFileNtfsId;
	LARGE_INTEGER					newLinkFileNtfsId;
	UNICODE_STRING					fileName[1];
	LONGLONG						CSFileChecksumFromReparsePoint;
    PIO_STACK_LOCATION 				irpSp;
    PDEVICE_EXTENSION 				deviceExtension;
    PIO_STACK_LOCATION 				nextIrpSp;
	SIS_CREATE_COMPLETION_CONTEXT	context[1];
	PSIS_SCB						scb = NULL;
	PSIS_PER_LINK					perLink;
	PSIS_CS_FILE					CSFile;
	PSIS_PER_FILE_OBJECT			perFO = NULL;
	PFILE_OBJECT					fileObject;
	PFILE_OBJECT					relatedFileObject = NULL;
	NTSTATUS						status;
	KIRQL							OldIrql;
    UCHAR                           CreateDisposition = 0;
	BOOLEAN							validReparseStructure;
	BOOLEAN							bogusReparsePoint = FALSE;
	BOOLEAN							fileBackpointerGoneBitSet;
    BOOLEAN                         BPExclusive;
	BOOLEAN							FinalCopyInProgress;
	BOOLEAN 						thingsChanged;
	BOOLEAN							completedStage2 = FALSE;
	BOOLEAN							ReparsePointCorrupted;
	BOOLEAN							EligibleForPartialFinalCopy;
	BOOLEAN							openedById;
    BOOLEAN                         RepairingCollision = FALSE;

	fileName->Buffer = NULL;

retry:

    deviceExtension = DeviceObject->DeviceExtension;

    //
    //  If this is for our control device object, fail the request
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  Do not allow anyone to to open the control device object
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

    irpSp = IoGetCurrentIrpStackLocation( Irp );

	ASSERT(irpSp->MajorFunction == IRP_MJ_CREATE);

	//
	// If this is a paging file open, wash our hands of it.
	//
	if (irpSp->Flags & SL_OPEN_PAGING_FILE) {

		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	fileObject = irpSp->FileObject;
    SIS_MARK_POINT_ULONG(fileObject);

	//
   	// Simply copy this driver stack location contents to the next driver's
   	// stack.
   	//

  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

    CreateDisposition = (UCHAR) ((irpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    if ((CreateDisposition == FILE_SUPERSEDE) ||
   	    (CreateDisposition == FILE_OVERWRITE) ||
       	(CreateDisposition == FILE_OVERWRITE_IF)) {

		context->overwriteOrSupersede = TRUE;
	} else {
		context->overwriteOrSupersede = FALSE;
	}

	openedById = (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) ? TRUE : FALSE;

#if		DBG
/*BJB*/	SIS_MARK_POINT_ULONG(fileObject);
/*BJB*/	if ((NULL != fileObject) && (NULL != fileObject->FileName.Buffer)) {
			ULONG data = 0;
			ULONG i;

			for (i = 0; (i < 4) && (i * sizeof(WCHAR) < irpSp->FileObject->FileName.Length); i++) {
				data = (data >> 8) | ((irpSp->FileObject->FileName.Buffer[irpSp->FileObject->FileName.Length / sizeof(WCHAR) - i - 1] & 0xff) << 24);
			}
			SIS_MARK_POINT_ULONG(data);
/*BJB*/	}

/*BJB*/	SIS_MARK_POINT_ULONG(CreateDisposition << 16 | irpSp->Parameters.Create.ShareAccess);
/*BJB*/	SIS_MARK_POINT_ULONG(irpSp->Parameters.Create.SecurityContext->DesiredAccess);

	if (BJBDebug & 0x40) {
		DbgPrint("SIS: SiCreate %d: fileObject %p, %0.*ws\n",
                    __LINE__,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	if (irpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT) {

		//
		// The user is trying to open a reparse point.  If it's an overwrite or supersede,
		// clear the flag (we'll turn it on again later).  Otherwise, just note that it was
		// set, so that we'll check to see if it's a SIS file later.
		//
		
	    if (context->overwriteOrSupersede) {

			nextIrpSp->Parameters.Create.Options &= ~FILE_OPEN_REPARSE_POINT;
		} else {
			//
			// We need to squirrel away the file name and related file object because we might
			// need to perform a check for an alternate stream later on.
			//
			ASSERT(NULL == fileName->Buffer);

			fileName->Length = 0;
			fileName->MaximumLength = fileObject->FileName.MaximumLength;
			if (fileName->MaximumLength != 0) {
				fileName->Buffer = ExAllocatePoolWithTag(PagedPool, fileName->MaximumLength, ' siS');
				if (NULL == fileName->Buffer) {
					SIS_MARK_POINT();

					status = STATUS_INSUFFICIENT_RESOURCES;
					goto fail;
				}
				SIS_MARK_POINT_ULONG(fileName->Buffer);

				RtlCopyUnicodeString(fileName, &fileObject->FileName);
			}

			ASSERT(NULL == relatedFileObject);
			relatedFileObject = fileObject->RelatedFileObject;
			if (NULL != relatedFileObject) {
				SIS_MARK_POINT_ULONG(relatedFileObject);

				ObReferenceObject(relatedFileObject);
			}
		}

		context->openReparsePoint = TRUE;
	} else {
		context->openReparsePoint = FALSE;
	}

	KeInitializeEvent(context->event,SynchronizationEvent,FALSE);

    IoSetCompletionRoutine(
   	    Irp,
       	SiCreateCompletion,
        context,
   	    TRUE,
       	TRUE,
        TRUE
   	    );

    //
    // Now call the appropriate file system driver with the request.
    //

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

//	SIS_MARK_POINT_ULONG(Irp);
    status = IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );
//	SIS_MARK_POINT_ULONG(status);

	//
	// Wait for the completion routine
	//
	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(context->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
//		SIS_MARK_POINT_ULONG(status);
	} else {
		KeClearEvent(context->event);
	}

    SIS_MARK_POINT();
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (context->completeFinished) {
        PSIS_PER_FILE_OBJECT    lPerFO;
        PSIS_SCB                lScb;

		//
		// It wasn't a SIS reparse point, so the completion routine
		// didn't stop the completion.  Return whatever status was sent
		// to the completion routine.
		//

		SIS_MARK_POINT_ULONG(context->Iosb->Status);

        if (NT_SUCCESS(context->Iosb->Status) &&
            SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &lPerFO, &lScb)) {

            //
            // Indicate that we expect to see a cleanup for this file object.
            // The UnClose count is incremented in the per-FO allocator because
            // we will see closes (but not cleanups) for stream file objects.
            //
            ASSERT(0 == (lPerFO->Flags & SIS_PER_FO_UNCLEANUP));

            InterlockedIncrement(&lPerFO->fc->UncleanCount);
            lPerFO->Flags |= SIS_PER_FO_UNCLEANUP;
        }

        ASSERT(STATUS_PENDING != context->Iosb->Status);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

        return context->Iosb->Status;
    }

	if ((STATUS_REPARSE == context->Iosb->Status) && 
		(IO_REPARSE_TAG_SIS != context->Iosb->Information) &&
		context->openReparsePoint) {

		//
		// This was a request to open a reparse point overwrite or supersede, and it turned out to
		// be a non-SIS reparse point.  Re-submit the open with the reparse
		// flag reset.  Note: there is an unavoidable refcount update race here, because
		// we don't know that this file will not be converted into a SIS file in the interim.
		//

		ASSERT(context->overwriteOrSupersede);

		SIS_MARK_POINT();

	  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
	    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

		nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}

	if (context->alternateStream) {
		//
		// It was an open of an alternate stream of a SIS reparse point.  Turn on 
		// FILE_OPEN_REPARSE_POINT and resubmit the request.
		//
		ASSERT(context->overwriteOrSupersede || !context->openReparsePoint);
		ASSERT(STATUS_REPARSE == context->Iosb->Status);

		SIS_MARK_POINT();

	  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
	    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

		nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}

	//
	// If this was an open reparse point and not supersede/overwrite,
	// we need to skip straight to reading the reparse data.
	//
	if (context->openReparsePoint && !context->overwriteOrSupersede) {
		ASSERT(NT_SUCCESS(context->Iosb->Status));	// or else SiCreateCompletion should have handled it.
		ASSERT(STATUS_REPARSE != context->Iosb->Status);	// because this was FILE_OPEN_REPARSE_POINT

		SIS_MARK_POINT();
		scb = NULL;

		completedStage2 = TRUE;

		goto recheckReparseInfo;
	}

	//
	// It must have been a SIS link.
	//
	ASSERT((STATUS_FILE_CORRUPT_ERROR == context->Iosb->Status) || 
			((STATUS_REPARSE == context->Iosb->Status) &&
			(IO_REPARSE_TAG_SIS == context->Iosb->Information)));

	//
	// Assure that SIS phase 2 initialization has completed.  Doing this here
	// assures that there are no open SIS links until this is completed.
	//
	if (!SipCheckPhase2(deviceExtension)) {

		//
		// This is a SIS reparse point opened without FILE_FLAG_OPEN_REPARSE_POINT
		// on a non-SIS enabled volume.  If it's an overwrite/supersede or it's opened
		// for delete access, then let it continue (if we can't initialize, we probably 
		// don't need to worry about backpointer consitency).  If not, then punt it.
		//

		if (context->overwriteOrSupersede || (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)) {
			SIS_MARK_POINT();

		  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
		    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

			nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

			IoSetCompletionRoutine(
				Irp,
				NULL,
				NULL,
				FALSE,
				FALSE,
				FALSE);

			if (NULL != fileName->Buffer) {
				ExFreePool(fileName->Buffer);
				fileName->Buffer = NULL;
			}
			if (NULL != relatedFileObject) {
				ObDereferenceObject(relatedFileObject);
				relatedFileObject = NULL;
			}

			return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
		} else {
			SIS_MARK_POINT();
			status = STATUS_INVALID_DEVICE_REQUEST;
			goto fail;
		}
	}

	if (STATUS_FILE_CORRUPT_ERROR == context->Iosb->Status) {
		//
		// This error must have come from SiCreateCompletion; if it was from NTFS then completeFinished
		// would have been true.  It indicates that the reparse buffer was a SIS reparse buffer but was
		// bogus.  Set scb to NULL and fall through to the stage 2 open, which will open the underlying
		// file and recheck the reparse point, probably get another invalid, and let the underlying file
		// be opened without SIS doing anything.
		//
		scb = NULL;
		bogusReparsePoint = TRUE;
	} else if (context->overwriteOrSupersede) {

		BOOLEAN		finalDeleteInProgress;

		//
		// The create completed with a STATUS_REPARSE and it was a SIS link and
		// there weren't any problems that caused the complete routine to just
		// fail the request.
        //
        // Lookup the scb using the ntfs file id from the reparse info.  Note
        // that we can't trust this id to be correct, but we can use it as a
        // hint.
		//

		SIS_MARK_POINT();
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		scb = SipLookupScb(	&context->LinkIndex,
							&context->CSid,
        	                &context->LinkFileNtfsId,
            	            &context->CSFileNtfsId,
							NULL,				// stream name NTRAID#65188-2000/03/10-nealch Handle alternate data streams
							DeviceObject,
							Irp->Tail.Overlay.Thread,
							&FinalCopyInProgress,
                            NULL);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL == scb) {
#if		DBG
			DbgPrint("SIS: SiCreate: Unable to allocate SCB\n");
#endif	// DBG
			status = STATUS_INSUFFICIENT_RESOURCES;
			SIS_MARK_POINT();
			goto fail;
		}

        SIS_MARK_POINT_ULONG(scb);

        ASSERT(scb->PerLink && scb->PerLink->CsFile);

        if (!IsEqualGUID(&scb->PerLink->CsFile->CSid, &context->CSid)) {

            //
            // There is a link index collision.  Since we're going to blow away
            // the reparse point, just kick off a volume check and let the
            // operation proceed.
            //

			SIS_MARK_POINT_ULONG(scb);

		    SipDereferenceScb(scb, RefsLookedUp);

		  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
		    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

			nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

			IoSetCompletionRoutine(
				Irp,
				NULL,
				NULL,
				FALSE,
				FALSE,
				FALSE);

			if (NULL != fileName->Buffer) {
				ExFreePool(fileName->Buffer);
				fileName->Buffer = NULL;
			}
			if (NULL != relatedFileObject) {
				ObDereferenceObject(relatedFileObject);
				relatedFileObject = NULL;
			}

            SipCheckVolume(deviceExtension);

			return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
        }

		perLink = scb->PerLink;

		if (perLink->COWingThread != Irp->Tail.Overlay.Thread) {

			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
			thingsChanged = SipWaitForFinalCopy(perLink, FinalCopyInProgress);
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			if (thingsChanged) {
				//
				// Something changed out from under us during the final copy.
				// Retry everything.
				//
				SIS_MARK_POINT_ULONG(scb);

				SipDereferenceScb(scb,RefsLookedUp);

				if (NULL != fileName->Buffer) {
					ExFreePool(fileName->Buffer);
					fileName->Buffer = NULL;
				}
				if (NULL != relatedFileObject) {
					ObDereferenceObject(relatedFileObject);
					relatedFileObject = NULL;
				}

				goto retry;
			}
		}


   	    SIS_MARK_POINT_ULONG(CreateDisposition);

#if 0
		DbgPrint("SiCreate %s: fileObject @ 0x%x, %0.*ws\n",
   	                FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

        //
   	    // Assume that our reparse point will be deleted and
    	// prepare for the CS file refcount update.  This will
        // also serialize all overwrite/supersede/delete operations
   	    // on this file until SipCompleteCSRefcountChange is called.
    	//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	
	    status = SipPrepareCSRefcountChange(
					perLink->CsFile,
					&perLink->Index,
					&perLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	    if (!NT_SUCCESS(status)) {
	
		    SIS_MARK_POINT_ULONG(status);

			goto fail;
	    }

		//
		// Verify that this file isn't in the process of being finally deleted.  If it is, fail the create.
		//
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		finalDeleteInProgress = (perLink->Flags & SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		if (finalDeleteInProgress) {
			SIS_MARK_POINT_ULONG(scb);

			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				perLink->CsFile,
				FALSE,
				FALSE);

			status = STATUS_ACCESS_DENIED;

			goto fail;
		}

        SIS_MARK_POINT_ULONG(scb);

	} else {
		//
		// We'll just ignore the stuff in the reparse point for now, and catch it after we really open
		// the file file FILE_OPEN_REPARSE_POINT and query it.  The reparse data that we have now is essentially
		// useless because the file could change between the STATUS_REPARSE return and the actual open
		// of the file below.
		//
		scb = NULL;
	}

	//
	// Now we want to open the reparse point itself.  We do this by turning on the
	// FILE_OPEN_REPARSE_POINT flag and sending the Irp back down to NTFS.  The rest of the
	// work of opening the link (allocating the perFO, etc.) is done in the stage2
	// completion routine.
	//

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));
	nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

	IoSetCompletionRoutine(
		Irp,
		SiCreateCompletionStage2,
		context,
		TRUE,
		TRUE,
		TRUE);

	SIS_MARK_POINT_ULONG(Irp);

	//
	// Again call into the filesystem.
	//
		
	ASSERT(0 == KeReadStateEvent(context->event));

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
//	SIS_MARK_POINT_ULONG(status);

	//
	// Wait for the completion routine to execute.
	//
	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(context->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
	} else {
		KeClearEvent(context->event);
	}
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	//
	// If the completion failed, release the scb and return.
	//
	if (!NT_SUCCESS(context->Iosb->Status)) {

		if (NULL != scb) {

            if (context->overwriteOrSupersede) {

		        SIS_MARK_POINT_ULONG(CreateDisposition);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
				    scb->PerLink->CsFile,
	                FALSE,
	                FALSE);
            }

		    SIS_MARK_POINT_ULONG(context->Iosb->Status);

			SipDereferenceScb(scb, RefsLookedUp);
		}

		Irp->IoStatus = *context->Iosb;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	if (bogusReparsePoint) {
		//
		// Just return the completion to the user.
		//
		SIS_MARK_POINT_ULONG(fileObject);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		Irp->IoStatus = *context->Iosb;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return context->Iosb->Status;
	}

	completedStage2 = TRUE;


    if (context->overwriteOrSupersede) {

	    ULONG						returnedLength;

        //
        // Get the ntfs file id.  If it's the same as the one we started with
        // (ie. the one that triggered the STATUS_REPARSE), then we know that
        // our file was overwritten.
        //

		SIS_MARK_POINT_ULONG(CreateDisposition);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	    status = SipQueryInformationFile(
					irpSp->FileObject,
					DeviceObject,
				    FileInternalInformation,
				    sizeof(FILE_INTERNAL_INFORMATION),
				    internalInfo,
				    &returnedLength);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	    if (!NT_SUCCESS(status)) {

            //
            // Just assume that we didn't overwrite the file.  This may
            // cause the CS reference count to be retained when it shouldn't,
            // but that's better than vice versa, where data loss would
            // result.
            //

		    SIS_MARK_POINT_ULONG(status);
#if DBG
		    DbgPrint("SiCreate %s: SipQueryInformationFile failed 0x%x, (%0.*ws)\n",
                FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
                status,
                irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

            SipCompleteCSRefcountChange(
				scb->PerLink,
				&scb->PerLink->Index,
				scb->PerLink->CsFile,
	            FALSE,
	            FALSE);

        } else {

			PSIS_SCB		newScb;

	        ASSERT(status != STATUS_PENDING);
	        ASSERT(returnedLength == sizeof(FILE_INTERNAL_INFORMATION));

			//
			// If there's another user of this file, then it might have an attached
			// filter context.  If so, even though it's not a SIS file anymore we
			// need to update the unclean count on the file, because we'll see
			// a cleanup for this file object.
			//

			if (SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &perFO, &newScb)) {
	            ASSERT(0 == (perFO->Flags & SIS_PER_FO_UNCLEANUP));

	            InterlockedIncrement(&perFO->fc->UncleanCount);
	            perFO->Flags |= SIS_PER_FO_UNCLEANUP;
			}

            if (internalInfo->IndexNumber.QuadPart != scb->PerLink->LinkFileNtfsId.QuadPart) {

                //
                // This is a different file.  (Could have been moved without us
                // knowing, or a delete/create/overwrite/supersede race before the
                // SipPrepareCSRefcountChange.)
                //
                SIS_MARK_POINT();
#if DBG
		        DbgPrint("SiCreate %s: different file opened, (%0.*ws)\n",
                    FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
                    status,
                    irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
					scb->PerLink->CsFile,
	                FALSE,
	                FALSE);

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

            } else {

                //
                // This is the same file.  Remove a reference from the
                // common store file, and mark the scb truncated and the
                // reparse point gone.
                //
		        SIS_MARK_POINT();

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
					scb->PerLink->CsFile,
                    (BOOLEAN) ((scb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? FALSE : TRUE),
	                FALSE);

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

				SipAcquireScb(scb);
				scb->SizeBackedByUnderlyingFile = 0;
				SipReleaseScb(scb);
            }
        }

#if DBG
	    //
	    // Try to read the reparse information from the file that we just opened.
        // It should not be a SIS reparse point (SIS reparse points are always
        // created using exclusive access).
	    //

		RtlZeroMemory(reparseBuffer,sizeof(SIS_REPARSE_DATA_SIZE));

	    status = SipFsControlFile(
					    irpSp->FileObject,
					    DeviceObject,
					    FSCTL_GET_REPARSE_POINT,
					    NULL,
					    0,
					    reparseBuffer,
					    SIS_REPARSE_DATA_SIZE,
						NULL);						// returned output buffer length

        if (NT_SUCCESS(status)) {

            ASSERT(IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag);

        } else {

            ASSERT(STATUS_NOT_A_REPARSE_POINT == status || 
                   STATUS_FILE_CORRUPT_ERROR == status || 
			      (STATUS_BUFFER_OVERFLOW == status && IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag));

        }
#endif

		//
		// This is no longer a sis link (or at least we assume so).
        // Detach ourself from the file and let the open complete normally.
		//
		SipDereferenceScb(scb, RefsLookedUp);

        //
        // The completion status is whatever came back from the completion of the actual
        // open.  Copy it into the irp.
        //
        Irp->IoStatus = *context->Iosb;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

        return context->Iosb->Status;
    }

recheckReparseInfo:

    SIS_MARK_POINT();

	//
	// Read the reparse information from the file that we just opened.  Until we do that,
	// we don't have any assurance that it's the file whose STATUS_REPARSE we got; someone
	// may have changed the file in the interim.
	//

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	status = SipFsControlFile(
					irpSp->FileObject,
					DeviceObject,
					FSCTL_GET_REPARSE_POINT,
					NULL,
					0,
					reparseBuffer,
					SIS_REPARSE_DATA_SIZE,
					NULL);						// returned output buffer length

	SIS_MARK_POINT_ULONG(status);
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	//
	// If get reparse failed with a status code that indicates that we're just looking
	// at the wrong kind of reparse point, or if the reparse tag isn't a SIS reparse
	// tag, let the open proceed without SIS involvement.
	//

	if ((STATUS_BUFFER_TOO_SMALL == status) ||
		(STATUS_VOLUME_NOT_UPGRADED == status) ||
		(STATUS_NOT_A_REPARSE_POINT == status) ||
		(STATUS_BUFFER_OVERFLOW == status) ||
        (STATUS_INVALID_PARAMETER == status) ||     //happens when opening a volume
		(NT_SUCCESS(status) && (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag))) {

		SIS_MARK_POINT_ULONG(reparseBuffer->ReparseTag);

		//
		// This is a non-sis link now.  Detach ourself from the file and
		// let the open complete normally.
		//

		if (NULL != scb) {
			SipDereferenceScb(scb, RefsLookedUp);
			scb = NULL;
		}

        //
        // It seems unlikely that we in the process of repairing a collision, but
        // handle it just the same.
        //
        if (RepairingCollision) {
		    SIS_MARK_POINT();
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		//
		// This could be a SIS file object from which we've already deleted the reparse point.
		// If so, then we need to increment the uncleanup count.
		//

        if (SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &perFO, &scb)) {

            //
            // Indicate that we expect to see a cleanup for this file object.
            // The UnClose count is incremented in the per-FO allocator because
            // we will see closes (but not cleanups) for stream file objects.
            //

		    SIS_MARK_POINT_ULONG(fileObject);
            ASSERT(0 == (perFO->Flags & SIS_PER_FO_UNCLEANUP));

            InterlockedIncrement(&perFO->fc->UncleanCount);
            perFO->Flags |= SIS_PER_FO_UNCLEANUP;
        }

		//
		// The completion status is whatever came back from the completion of the actual
		// open.  Copy it into the irp.
		//
		Irp->IoStatus = *context->Iosb;
		
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		//
		// The get reparse point failed, but not with a status that we'd expected.
		// Fail the entire open with the same status.
		//

		SIS_MARK_POINT_ULONG(status);

        if (RepairingCollision) {
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		goto fail;
	}


	validReparseStructure = SipIndicesFromReparseBuffer(
								reparseBuffer,
								&newCSid,
								&newLinkIndex,
								&newCSFileNtfsId,
								&newLinkFileNtfsId,
								&CSFileChecksumFromReparsePoint,
								&EligibleForPartialFinalCopy,
								&ReparsePointCorrupted);

	if (!validReparseStructure) {

        //
        // It seems unlikely that we're in the process of repairing a collision, but
        // handle it just the same.
        //
        if (RepairingCollision) {
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		if (ReparsePointCorrupted) {
			//
			// This is a bogus reparse point.  Delete the reparse point and open the
			// underlying file.
			//
			SIS_MARK_POINT_ULONG(irpSp->FileObject);

			goto deleteReparsePoint;
		}

		//
		// This is a reparse buffer that's not corrupt, but which we don't understand,
		// presumably from a newer version of the filter.  Open the underlying file.
		//
		goto openUnderlyingFile;
	}

	//
	// If the user specified FILE_OPEN_REPARSE_POINT and not overwrite/supersede,
	// this might actually be an alternate stream.  We need to parse the file name
	// to figure this out, and if so complete the irp.
	//
	if (context->openReparsePoint
		&& (!context->overwriteOrSupersede) 
		&& (!openedById)
		&& SipDoesFileObjectDescribeAlternateStream(fileName,relatedFileObject, DeviceObject)) {

		SIS_MARK_POINT_ULONG(irpSp->FileObject);
        ASSERT(!RepairingCollision);

		//
		// This is an alternate stream of a SIS file object that the user opened
		// with FILE_OPEN_REPARSE_POINT.  Do not attach to it, just return it directly
		// to the user.
		//

		Irp->IoStatus = *context->Iosb;
		
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	//
	// Have to check phase2 in case we got here through the FILE_OPEN_REPARSE_POINT path.
	//
	if (!SipCheckPhase2(deviceExtension)) {
		SIS_MARK_POINT();

		//
		// We can't initialize.  This must be an open reparse point because otherwise
		// we would have quit at the earlier phase2 check.  Just open the underlying file.
		//

		ASSERT(context->openReparsePoint);
        ASSERT(!RepairingCollision);

		goto openUnderlyingFile;
	}

	//
	// Handle the case where the file is a SIS link, but not the right one.
	// This can happen if someone deletes the link that we started opening
	// and the creates a new one in the same filename between when we got
	// STATUS_REPARSE and here.  This also always happens on FILE_OPEN_REPARSE_POINT
	// calls that are not supersede/overwrite.  Also handle the case where
    // we have a link index collision (two or more files have the same link
    // index).
	//
	if ((NULL == scb) ||
        (newLinkIndex.QuadPart != scb->PerLink->Index.QuadPart) ||
        !IsEqualGUID(&scb->PerLink->CsFile->CSid, &newCSid)) {
		PSIS_SCB		newScb;

		SIS_MARK_POINT_ULONG(scb);
		SIS_MARK_POINT_ULONG(newLinkIndex.QuadPart);

		//
		// Lookup the new SCB and drop our reference to the old one.
        //
        // The ntfs file id is the one we got from ntfs, not the reparse info.
		//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		newScb = SipLookupScb(
					&newLinkIndex,
					&newCSid,
					&newLinkFileNtfsId,
					&newCSFileNtfsId,
					NULL,							// stream name NTRAID#65188-2000/03/10-nealch Handle alternate data streams
					DeviceObject,
					Irp->Tail.Overlay.Thread,
					&FinalCopyInProgress,
                    NULL);


		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL == newScb) {
			//
			// We're out of memory in a bad place.  Just fail the open request.
			//
			SIS_MARK_POINT();

			status = STATUS_INSUFFICIENT_RESOURCES;
			goto fail;
		}

		SIS_MARK_POINT_ULONG(newScb);

        if (!IsEqualGUID(&newScb->PerLink->CsFile->CSid, &newCSid)) {
            if (!RepairingCollision) {
                //
                // We just detected a link index collision.  Take the collision
                // mutant and recheck for collision (in case of thread race).  If
                // there's no race (or we win), then we'll end up in the else
	            // clause below.
                //
                SipCheckVolume(deviceExtension);

                status = SipAcquireCollisionLock(deviceExtension);

                if (!NT_SUCCESS(status)) {
                    goto fail;
                }

                RepairingCollision = TRUE;

            } else {
                BOOLEAN rc;
                LINK_INDEX AllocatedIndex;

                //
                // We've completed the second pass after taking the collision
                // mutant, and the collision still exists, so now it's time
                // to fix it.
                //
                status = SipAllocateIndex(deviceExtension, &AllocatedIndex);

                if (!NT_SUCCESS(status)) {
                    SipDereferenceScb(newScb, RefsLookedUp);
                    SipReleaseCollisionLock(deviceExtension);
                    RepairingCollision = FALSE;
                    goto fail;
                }

                //
                // Don't bother getting the ntfs file id from ntfs.  If the one
                // in the reparse info is wrong, then this link index is assumed
                // bogus and will be deleted below.
                //

                //
                // Update the link index in the reparse info and write it out
                // to the file.
                //
                rc = SipIndicesIntoReparseBuffer(
                        reparseBuffer,
                        &newCSid,
                        &AllocatedIndex,
                        &newCSFileNtfsId,
                        &newLinkFileNtfsId,
                        &CSFileChecksumFromReparsePoint,
                        EligibleForPartialFinalCopy);

                ASSERT(rc);

                status = SipFsControlFile(
                                irpSp->FileObject,
                                DeviceObject,
                                FSCTL_SET_REPARSE_POINT,
                                reparseBuffer,
                                SIS_REPARSE_DATA_SIZE,
                                NULL,
                                0,
                                NULL);      // returned output buffer length

                if (!NT_SUCCESS(status)) {
                    SipDereferenceScb(newScb, RefsLookedUp);
                    SipReleaseCollisionLock(deviceExtension);
                    RepairingCollision = FALSE;
                    goto fail;
                }

                //
                // Release the collision mutex and restart at RecheckReparseInfo.
                //
                SipReleaseCollisionLock(deviceExtension);
                RepairingCollision = FALSE;
            }

            //
            // Note that we're not releasing the scb we collided with, since we
            // want that to stick around to catch any other threads that try to
            // open the file we're fixing.
            //
            if (NULL != scb) {
                SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipDereferenceScb(scb, RefsLookedUp);
        
                SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
            }
            scb = newScb;
            newScb = NULL;
            goto recheckReparseInfo;

        } else if (RepairingCollision) {
            //
            // There must have been a thread race and we lost.  Just release
            // the collision mutex and continue.
            //
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;

        }

		ASSERT(newScb != scb);

		if (newScb->PerLink->COWingThread != Irp->Tail.Overlay.Thread) {
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			thingsChanged = SipWaitForFinalCopy(newScb->PerLink, FinalCopyInProgress);

			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			if (thingsChanged) {
				//
				// Go off and recheck this file's reparse point data.
				//

				SIS_MARK_POINT();

				SipDereferenceScb(newScb, RefsLookedUp);
				newScb = NULL;

				goto recheckReparseInfo;
			}
		} else {
			//
			// We're the COWingThread.  Since things can't change under the COWing thread,
			// this must be the first pass through here.  Assert that.
			//
			ASSERT(NULL == scb);
		}

		//
		// Switch scbs and complete the open.
		//

		if (NULL != scb) {
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			SipDereferenceScb(scb, RefsLookedUp);
	
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		}
		scb = newScb;
		newScb = NULL;

		//
		// Check to make sure there's a CS file for this file.
		//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		status = SipAssureCSFileOpen(scb->PerLink->CsFile);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (!NT_SUCCESS(status)) {
            //
            //  This feature was removed on 5/13/02 by nealch.  It was causing
            //  too many problems to have the reparse point deleted if the
            //  common store file happens to not exist.  We need the ability
            //  for people who accidently delete the common store directory
            //  to put the files back and have their link start working again.
            //
//			// The CS file open failed.  If it failed because the CS file isn't there, delete the
//			// reparse point and open the underlying file.  Otherwise, let the open complete.
//			//
//
//			if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
//				SIS_MARK_POINT();
//				goto deleteReparsePoint;
//			}

            //
            //  If they only wanted to open the reparse point, go ahead and
            //  allow this.
            //

            if (context->openReparsePoint) {

                goto openUnderlyingFile;
    		}

			SIS_MARK_POINT_ULONG(status);
			goto fail;
		}

		perLink = scb->PerLink;
		CSFile = perLink->CsFile;

		SipAcquireScb(scb);
		KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
		if (!(scb->PerLink->Flags & (SIS_PER_LINK_DIRTY|SIS_PER_LINK_BACKPOINTER_GONE)) && (scb->SizeBackedByUnderlyingFile == 0)) {
			scb->SizeBackedByUnderlyingFile = CSFile->FileSize.QuadPart;
		}
		KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);
		SipReleaseScb(scb);

    } else if (RepairingCollision) {
        //
        // There must have been a thread race and we lost.  Just release
        // the collision mutex and continue.
        //
        SipReleaseCollisionLock(deviceExtension);
        RepairingCollision = FALSE;
    }

	//
	// Assert that this really is the file we think it is.
	//
	ASSERT(newLinkIndex.QuadPart == perLink->Index.QuadPart);
	ASSERT(IsEqualGUID(&newCSid,&CSFile->CSid));
    ASSERT(newLinkFileNtfsId.QuadPart == perLink->LinkFileNtfsId.QuadPart);

	//
	// Determine if the reparse point has the right CS file checksum. 
	// 
	if ((CSFileChecksumFromReparsePoint != CSFile->Checksum)
#if		DBG
		&& (!(BJBDebug & 0x100))
#endif	// DBG
		) {
		//
		// This reparse point has the wrong checksum.  Delete the reparse point and let the open of
		// the underlying file proceed.
		// 
		SIS_MARK_POINT();

#if		DBG
		DbgPrint("SIS: SiCreate %d: checksum mismatch on reparse point.\n",__LINE__);
		DbgPrint("\tr: %08x%08x, c: %08x%08x\n", CSFileChecksumFromReparsePoint, CSFile->Checksum);
#endif	// DBG

		goto deleteReparsePoint;
	}

	SIS_MARK_POINT_ULONG(scb);

	//
	// Check that the reparse point has an NTFS file Id that matches the one in the
	// reparse point.  If it doesn't (which can happen with user set reparse points)
	// then delete the reparse point.
	//
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	status = SipQueryInformationFile(
				irpSp->FileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);								// returned length

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto fail;
	}

	if (internalInfo->IndexNumber.QuadPart != scb->PerLink->LinkFileNtfsId.QuadPart) {
		SIS_MARK_POINT_ULONG(scb->PerLink->LinkFileNtfsId.LowPart);

		//
		// The file and reparse point don't match on NTFS id.  Thus, the reparse point
		// is bogus and we need to delete it.
		//
		goto deleteReparsePoint;
	}

#if		0
	//
	// Verify that the link index for this file is within the range 
	// that we think could have possibly been allocated.
	//

	status = SipGetMaxUsedIndex(deviceExtension,MaxUsedIndex);
	if (NT_SUCCESS(status)) {
		if ((MaxUsedIndex->QuadPart < perLink->Index.QuadPart)) {
			//
			// One of the indices is bigger than what we think we could have possibly
			// allocated.  Something's fishy, so initiate a volume check.
			//
			SIS_MARK_POINT_ULONG(MaxUsedIndex->HighPart);
			SIS_MARK_POINT_ULONG(MaxUsedIndex->LowPart);
			SIS_MARK_POINT_ULONG(perLink->Index.HighPart);
			SIS_MARK_POINT_ULONG(perLink->Index.LowPart);

			SipCheckVolume(deviceExtension);
		}
	} else {
		//
		// Since this was only a consistency check, ignore that it failed.
		//
		SIS_MARK_POINT_ULONG(status);
	}
#endif	// 0

    //
    // If a volume check is underway, we're probably going to be writing the
    // backpointer back to disk, and to do that we must hold the backpointer
    // resource exclusive.  
    //
    if (deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE) {
		SipAcquireBackpointerResource(CSFile,TRUE,TRUE);
        BPExclusive = TRUE;
    } else {
		SipAcquireBackpointerResource(CSFile,FALSE,TRUE);
        BPExclusive = FALSE;
    }
	SipAcquireScb(scb);

RecheckDelete:

	//
	// Check to see if this file is in the process of being finally deleted, and
	// deny access to it if it is.  This cures a race between where the uncleanup
	// count is decremented in siclnup.c and incremented here in the delete
	// case.
	//
	// Also check to see if the file has the DELETED bit set, in which case it's
	// been overwritten and we should just open it without checking the
	// backpointers.
	//

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	if ((perLink->Flags & (SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|SIS_PER_LINK_FILE_DELETED))
#if		DBG
		|| (BJBDebug & 0x80)
#endif	// DBG
		) {

		SIS_MARK_POINT_ULONG(perLink);
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);
		SipReleaseScb(scb);
		SipReleaseBackpointerResource(CSFile);

		status = STATUS_ACCESS_DENIED;
		goto fail;
	}

	fileBackpointerGoneBitSet = (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (fileBackpointerGoneBitSet) {

		//
		// If the file's deleted, we shouldn't be sending anything to the
		// CS file.  Set SizeBacked to 0.  (This also happens in the
		// delete path, but there's a race with this code, so both
		// sides do it.
		//
		scb->SizeBackedByUnderlyingFile = 0;

	} else if (!context->openReparsePoint) {

        BOOLEAN foundBP;

		//
		// Check to see that the backpointer is here for this file.
		// We don't do the check on FILE_OPEN_REPARSE_POINT because
		// restore uses this to open links that were restored prior to
		// the files to which they referred.
		//

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
		status = SipCheckBackpointer(perLink, BPExclusive, &foundBP);
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

        if (!NT_SUCCESS(status)) {

		    SIS_MARK_POINT_ULONG(status);
		    SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);

            //
            // STATUS_MEDIA_WRITE_PROTECTED means that SipCheckBackpointer
            // needs to write the backpointer back to disk, and to do so,
            // we must take the backpointer resource exclusive.
            //
            if (STATUS_MEDIA_WRITE_PROTECTED == status) {

		        SIS_MARK_POINT_ULONG(perLink);

				SipAcquireBackpointerResource(CSFile,TRUE,TRUE);
	            SipAcquireScb(scb);
                BPExclusive = TRUE;

                goto RecheckDelete;

            }

		    goto fail;
        }

        if (!foundBP) {
            LINK_INDEX lNewLinkIndex;

            //
            // The backpointer was not found.  SipCheckBackpointer has already
            // initiated a volume check, and we now need to add a backpointer.
            // (Volume checking is dependent on SiCreate fixing all link
            // corruption, including the backpointer.)  We don't have to worry
            // about the common store file being deleted before we can add a
            // backpointer because no common store files are ever deleted while
            // a volume check is in progress.
            //

	        ASSERT((perLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) == 0);

		    SIS_MARK_POINT_ULONG(perLink);
		    SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);

	        status = SipPrepareCSRefcountChange(
					    perLink->CsFile,
					    &lNewLinkIndex,
					    &perLink->LinkFileNtfsId,
					    SIS_REFCOUNT_UPDATE_LINK_CREATED);

            if (!NT_SUCCESS(status)) {
                goto fail;
            }

            //
            // We now hold the backpointer resource exclusive.  See if a race
            // with another thread has already fixed the backpointer.
            //
	        if (perLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) {

                //
                // The backpointer has been fixed.  We're done.
                //
                status = SipCompleteCSRefcountChange(
				            perLink,
				            &perLink->Index,
					        perLink->CsFile,
	                        FALSE,
	                        TRUE);

                ASSERT(STATUS_SUCCESS == status);

            } else {

                BOOLEAN rc;

                //
                // Update the link index in the reparse info and write it out
                // to the file.
                //
                rc = SipIndicesIntoReparseBuffer(
	                    reparseBuffer,
	                    &CSFile->CSid,
	                    &lNewLinkIndex,
                        &CSFile->CSFileNtfsId,
                        &perLink->LinkFileNtfsId,
	                    &CSFile->Checksum,
						EligibleForPartialFinalCopy);

                ASSERT(rc);

	            status = SipFsControlFile(
					            irpSp->FileObject,
					            DeviceObject,
					            FSCTL_SET_REPARSE_POINT,
					            reparseBuffer,
					            SIS_REPARSE_DATA_SIZE,
					            NULL,
					            0,
						        NULL);      // returned output buffer length

                if (NT_SUCCESS(status)) {

                    //
                    // The backpointer has been fixed.  Reset the link index
                    // in the perlink structure.
                    //
                    SipUpdateLinkIndex(scb, &lNewLinkIndex);

                    status = SipCompleteCSRefcountChange(
				                perLink,
				                &perLink->Index,
					            perLink->CsFile,
	                            TRUE,
	                            TRUE);

                    if (! NT_SUCCESS(status)) {
                        goto fail;
                    }

                    ASSERT(STATUS_SUCCESS == status);
				    KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                    perLink->Flags |= SIS_PER_LINK_BACKPOINTER_VERIFIED;
				    KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                } else {

                    //
                    // Not much we can do.
                    //
                    SipCompleteCSRefcountChange(
				        perLink,
				        &perLink->Index,
					    perLink->CsFile,
	                    FALSE,
	                    TRUE);

                    goto fail;

                }
            }

			SipAcquireBackpointerResource(CSFile,FALSE,TRUE);
	        SipAcquireScb(scb);
            BPExclusive = FALSE;

            goto RecheckDelete;
        }
	}

	//
	// Check to see if we need to query allocated ranges for this file.
	//
	if (EligibleForPartialFinalCopy && !(scb->Flags & SIS_SCB_RANGES_INITIALIZED)) {
		//
		// We need to do a query allocated ranges for this file.  Any ranges that are
		// allocated we set dirty.
		//
#define	OUT_ARB_COUNT		10

		FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
		FILE_ALLOCATED_RANGE_BUFFER		outArb[OUT_ARB_COUNT];
		ULONG							returnedLength;
		ULONG							i;
		NTSTATUS						addRangeStatus;
		FILE_STANDARD_INFORMATION		standardInfo[1];

		inArb->FileOffset.QuadPart = 0;
		inArb->Length.QuadPart = MAXLONGLONG;

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		for (;;) {

			//
			// Query the allocated ranges for this file.
			//

			status = SipFsControlFile(
						irpSp->FileObject,
						DeviceObject,
						FSCTL_QUERY_ALLOCATED_RANGES,
						inArb,
						sizeof(FILE_ALLOCATED_RANGE_BUFFER),
						outArb,
						sizeof(FILE_ALLOCATED_RANGE_BUFFER) * OUT_ARB_COUNT,
						&returnedLength);

			//
			// Run through all of the returned allocated ranges and mark them dirty.
			//
			ASSERT((returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0) && 
				   (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) <= OUT_ARB_COUNT));

			//
			// If the query allocated ranges failed for some other reason that having too much to write
			// into the buffer we provided, fail the whole create.
			//
			if (!NT_SUCCESS(status) && (STATUS_BUFFER_OVERFLOW != status)) {
				SipReleaseScb(scb);
				SipReleaseBackpointerResource(CSFile);

				SIS_MARK_POINT_ULONG(status);
				goto fail;
			}

			ASSERT(NT_SUCCESS(status) || (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) == OUT_ARB_COUNT));

			for (i = 0; i < returnedLength/sizeof(FILE_ALLOCATED_RANGE_BUFFER); i++) {
				//
				// Assert that the allocated ranges are in order; if this isn't true the code will still work, but it
				// will query the same range repetedly.
				//
				ASSERT(i == 0 || outArb[i].FileOffset.QuadPart > outArb[i-1].FileOffset.QuadPart);

				//
				// The file has an allocated range.  Mark it dirty.
				//
#if		DBG
				if (BJBDebug & 0x100000) {
					DbgPrint("SIS: SiCreate %d: found a newly opened file with an allocated range, start 0x%x.0x%x, length 0x%x.0x%x\n",
                            __LINE__,
							outArb[i].FileOffset.HighPart,outArb[i].FileOffset.LowPart,
							outArb[i].Length.HighPart,outArb[i].Length.LowPart);
				}
#endif	// DBG

				SIS_MARK_POINT_ULONG(outArb[i].FileOffset.LowPart);
				SIS_MARK_POINT_ULONG(outArb[i].Length.LowPart);

				//
				// Mark the range dirty
				//
				addRangeStatus = SipAddRangeToWrittenList(
										deviceExtension,
										scb,
										&outArb[i].FileOffset,
										outArb[i].Length.QuadPart);

				scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

				if (outArb[i].FileOffset.QuadPart != 0 ||
					outArb[i].Length.QuadPart > deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
					scb->Flags |= SIS_SCB_BACKING_FILE_OPENED_DIRTY;
				}


				if (!NT_SUCCESS(addRangeStatus)) {
					SipReleaseScb(scb);
					SipReleaseBackpointerResource(CSFile);

					status = addRangeStatus;
					SIS_MARK_POINT_ULONG(status);
					goto fail;
				}
			}

			//
			// If this isn't the last iteration, update the inArb.
			//
			if (STATUS_BUFFER_OVERFLOW == status) {
				//
				// Assert that we're making progress.
				//
				ASSERT((outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart >= inArb->FileOffset.QuadPart) && (outArb[OUT_ARB_COUNT-1].Length.QuadPart > 0));

				//
				// Move up our input range.
				//
				inArb->FileOffset.QuadPart = outArb[OUT_ARB_COUNT-1].Fil